diff --git a/arch/powerpc/boot/bootinfo.h b/arch/powerpc/boot/bootinfo.h
new file mode 100644
index 0000000..67a2956
--- /dev/null
+++ b/arch/powerpc/boot/bootinfo.h
@@ -0,0 +1,38 @@
+/*
+ * Non-machine dependent bootinfo structure.  Basic idea
+ * borrowed from the m68k.
+ *
+ * Copyright (C) 1999 Cort Dougan <cort@ppc.kernel.org>
+ */
+
+#ifndef _PPC_BOOTINFO_H
+#define _PPC_BOOTINFO_H
+
+struct bi_record {
+	unsigned long tag;		/* tag ID */
+	unsigned long size;		/* size of record (in bytes) */
+	unsigned long data[0];	/* data */
+};
+
+#define BI_FIRST				0x1010  /* first record - marker */
+#define BI_LAST					0x1011	/* last record - marker */
+#define BI_CMD_LINE				0x1012
+#define BI_BOOTLOADER_ID		0x1013
+#define BI_INITRD				0x1014
+#define BI_SYSMAP				0x1015
+#define BI_MACHTYPE				0x1016
+#define BI_MEMSIZE				0x1017
+#define BI_BOARD_INFO			0x1018
+#define BI_MENMON_PARAMETERS	0x1100
+
+extern unsigned long boot_mem_size;
+
+static inline struct bi_record *
+bootinfo_addr(unsigned long offset)
+{
+	return (struct bi_record *)_ALIGN((offset) + (1 << 20) - 1,
+			(1 << 20));
+}
+
+#endif /* _PPC_BOOTINFO_H */
+
diff --git a/arch/powerpc/boot/cuboot-spacecom2.c b/arch/powerpc/boot/cuboot-spacecom2.c
new file mode 100644
index 0000000..a91f663
--- /dev/null
+++ b/arch/powerpc/boot/cuboot-spacecom2.c
@@ -0,0 +1,267 @@
+/*
+ * Old U-boot compatibility for SpaceCom II board
+ *
+ * Author: Christian Koerner <ckoerner@sysgo.com>
+ *
+ * Copyright (c) 2010
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#define TARGET_PPC_MPC52xx
+
+#include "stringify.h"
+#include "ops.h"
+#include "stdio.h"
+#include "io.h"
+#include "page.h"
+#include "ppcboot.h"
+#include "page.h"
+#include "bootinfo.h"
+#include "mmparastring.h"
+
+#ifndef SPRN_SVR
+#define SPRN_SVR	0x11E	/* System Version Register */
+#endif
+
+#define mfspr(rn)	({unsigned long rval; \
+			asm volatile("mfspr %0," __stringify(rn) \
+				: "=r" (rval)); rval;})
+
+#define COPY_MM_PARM(key, where)\
+    if (MMPARA_SearchKey(key, men5200_mmparastring, strBuf))\
+        MMPARA_StringToInt(10, strBuf, &where);\
+    else\
+        printf("*** key \"" key "\" missing in menmon parameter string!\r\n");
+
+static void parse_menmon_params(struct bi_record *bi);
+
+static bd_t bd;
+static unsigned char cpu_type;
+extern char _end[];
+extern char _dtb_start[], _dtb_end[];
+
+char men5200_mmparastring[1024];	/* needed globally for men_sysparam*/
+
+static void platform_fixups(void)
+{
+	void *soc;
+	void *reg;
+	int div;
+	u32 sysfreq;
+
+	dt_fixup_memory(bd.bi_memstart, bd.bi_memsize);
+	dt_fixup_cpu_clocks(bd.bi_intfreq, bd.bi_busfreq / 4, bd.bi_busfreq);
+
+	/* Unfortunately, the specific model number is encoded in the
+	 * soc node name in existing dts files -- once that is fixed,
+	 * this can do a simple path lookup.
+	 */
+	soc = find_node_by_devtype(NULL, "soc");
+	if (soc) {
+		char strBuf[50];
+		/*void *serial = NULL;*/
+		void *ethernet = NULL;
+		void *sysparams = NULL;
+		unsigned char valid = 0;		
+
+		setprop(soc, "bus-frequency", &bd.bi_ipbfreq,
+		        sizeof(bd.bi_busfreq));
+
+		/* set cpu type property */
+		setprop(soc, "cpu-type", &cpu_type,sizeof(cpu_type));	
+
+		/* get mac address from bootloader and put it to tree*/		
+		char *p = MMPARA_SearchKey( "nmac0=", men5200_mmparastring, strBuf );
+		if (p != NULL) {
+			while ((ethernet = find_node_by_devtype(ethernet, "network"))) {
+				if (get_parent(ethernet) != soc)
+					continue;
+
+				printf("Retrieving nmac0 from MENMON: %s\r\n", p );
+				setprop(ethernet, "men-mac-address", p, strlen(p));
+				valid = 1;
+			}
+		}
+		
+		if (!valid) {
+			printf("*** WARNING: Retrieving Ethernet address failed!, "
+				   "use default\r\n");
+		}
+
+		/* we have to pass mmparastring to kernel. We can do it by puting it  *
+		 * to device tree leaf called "menmonparams". This is not a pretty    *
+		 * nice way, but the simplest at this stage. This params should be    *
+		 * parsed here and put one by one to device tree blob. But this       *
+		 * inquire bigger changes on driver side also                         */
+		printf("MENMON parameter string: \r\n %s \r\n", men5200_mmparastring);
+		printf("MENMON parameter string length: %d \r\n", strlen(men5200_mmparastring));
+
+		sysparams = finddevice("/chosen");
+		if (sysparams) {
+			printf("Storing MENMON parameter string in dev tree.\r\n");
+			setprop(sysparams, "menmonparams", men5200_mmparastring, strlen(men5200_mmparastring));
+			/* flash start and flash size are used by MTD map driver */
+			setprop(sysparams, "flashstart", &bd.bi_flashstart, sizeof(bd.bi_flashstart));
+			setprop(sysparams, "flashsize", &bd.bi_flashsize, sizeof(bd.bi_flashsize));
+		} else
+			printf("*** WARNING: Can't store MENMON parameter string\r\n");
+
+		if (!dt_xlate_reg(soc, 0, (void*)&reg, NULL))
+			return;
+		div = in_8(reg + 0x204) & 0x00200 ? 8:4;
+		sysfreq = bd.bi_busfreq * div;
+		setprop(soc, "system-frequency", &sysfreq, sizeof(sysfreq));
+	}
+}
+
+static void parse_bootinfo(struct bi_record *rec)
+{
+	if (rec == NULL || rec->tag != BI_FIRST)
+		return;
+	while (rec->tag != BI_LAST) {
+		/*unsigned long *data = rec->data;*/
+		switch (rec->tag) {
+		case BI_CMD_LINE:
+			/* we don't care abou that as we can grab it from r6 */
+			/*strlcpy(cmdline, (void *)data, sizeof(cmdline));*/
+			break;
+#if defined(CONFIG_BLK_DEV_INITRD) || defined(CONFIG_EXTRACT_ROOTFS)
+		case BI_INITRD:
+			/* TODO - but probably not needed */
+			/*initrd_start = data[0];*/
+			/*initrd_end = data[0] + data[1];*/
+			break;
+#endif /* CONFIG_BLK_DEV_INITRD */
+#ifdef CONFIG_PPC_MULTIPLATFORM
+		case BI_MACHTYPE:
+			break;
+#endif
+		case BI_MEMSIZE:
+			/*boot_mem_size = data[0];*/
+			break;
+		}
+		rec = (struct bi_record *)((unsigned long)rec + rec->size);
+	}
+}
+
+static void parse_menmon_params(struct bi_record *bi)
+{
+	char strBuf[20];
+	unsigned int fl_size;
+	memset(&bd, 0, sizeof(bd));
+
+	/* set default values first */
+	bd.bi_intfreq = 384000000;      /* core clock 		         */
+	bd.bi_busfreq = 128000000;      /* XLB clock: 128Mhz@EM1     */
+	bd.bi_ipbfreq = 64000000;       /* IPB clock                 */
+	bd.bi_pcifreq = 32000000;       /* PCI clock                 */
+	bd.bi_baudrate = 115200;        /* console baud rate         */
+	bd.bi_memsize = 256*1024*1024;  /* mem size                  */
+	bd.bi_flashstart = 0xffe00000;  /* flash start (2MB device)  */
+	bd.bi_flashsize = 2*1024*1024;  /* min. flash size           */
+
+	men5200_mmparastring[0] = '\0';
+	while (bi->tag != BI_LAST) {
+		if (bi->tag == BI_MENMON_PARAMETERS) {
+			memcpy(men5200_mmparastring, (void *)bi->data, bi->size);
+			break;
+		}
+		bi = (struct bi_record *)((unsigned long)bi + bi->size);
+	}
+	/* we can't use printf yet */
+	/*printf("MENMON parameter string: '%s'\r\n", men5200_mmparastring);*/
+
+	COPY_MM_PARM("cpuclkhz=",	bd.bi_intfreq	);
+	COPY_MM_PARM("ipbclkhz=",	bd.bi_ipbfreq	);
+	COPY_MM_PARM("xlbclkhz=",	bd.bi_busfreq	); // NOK TBC
+	COPY_MM_PARM("flash0=",		bd.bi_flashsize	);
+	COPY_MM_PARM("mem0=",		bd.bi_memsize	); // NOK TBC
+
+	fl_size = bd.bi_flashsize;
+
+	if ((fl_size == 2048)||(fl_size == 4096)||(fl_size == 8192)) {
+		/* adjust Flash start address according to size */
+		bd.bi_flashstart = (0xffffffff-(fl_size * 1024)) + 1;
+		/*printf("Flash start address:0x%08lx.\r\n",bd.bi_flashstart);*/
+	} else {
+		/*printf(" *** invalid Flash size in flash0. Use defaults.\r\n");*/
+		bd.bi_flashstart	= 0xffe00000; 
+		bd.bi_flashsize 	= 2*1024;
+	}
+
+	/* mem sizes are needed in _byte_ */
+	bd.bi_memsize *= 1024;
+	bd.bi_flashsize *= 1024;    
+}
+
+void platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+                   unsigned long r6, unsigned long r7)
+{
+	struct bi_record* bi = NULL;
+	unsigned int cpu_svr = 0;
+	unsigned long end_of_ram;        /* = bd.bi_memstart + bd.bi_memsize;*/
+	unsigned long avail_ram;         /* = end_of_ram - (unsigned long)_end;*/
+	
+	loader_info.initrd_addr = r4;
+	loader_info.initrd_size = r4 ? r5 - r4 : 0;
+	loader_info.cmdline = (char *)r6;
+	loader_info.cmdline_len = r7 - r6;
+
+	/* MENMON passes the address of a board info structure in R3 */
+	if (r3 != 0) {
+		bi = (struct bi_record *)(r3);
+	}
+
+	/* be more paranoid - check for BI_FIRST and correct size */
+	if (!bi || (bi->tag != BI_FIRST) ||(bi->size != sizeof(struct bi_record))) {
+		/*printf("Bootinfo records not found\n\r");*/
+	}
+
+	parse_bootinfo(bi);
+	parse_menmon_params(bi);    
+
+	/* after parse menmon params bd is set */
+	end_of_ram = bd.bi_memstart + bd.bi_memsize;
+	avail_ram = end_of_ram - (unsigned long)_end;
+    
+	simple_alloc_init(_end, avail_ram - 1024*1024, 32, 64);
+	fdt_init(_dtb_start);
+	serial_console_init();
+	/* from now on we can use printf as serial was initialized */
+	
+	/* disable editing of command line */
+	console_ops.edit_cmdline = NULL;
+	
+	/* BAT setup */
+	/*mpc52xx_set_bat(); */
+
+	printf("\r\nFound MPC52xx CPU Revision: ");
+	cpu_svr = mfspr(SPRN_SVR);
+
+	switch(cpu_svr) {
+	case 0x80110012:
+		cpu_type		  = 0xa2;
+		break;
+	case 0x80110020:
+		cpu_type		  = 0xb1;
+		break;
+	case 0x80110021:
+		cpu_type		  = 0xb2;
+		break;
+	case 0x80110022:
+		cpu_type		  = 0xb3;
+		break;
+	default:
+		cpu_type		  = 0x00;
+		printf(" UNKNOWN\r\n");
+	}
+	/* cpu_type is static variable which will be put to dev tree by platform_fixups */
+	printf("%02X (SVR=0x%08X)\r\n", cpu_type, cpu_svr );
+	printf("Available RAM: %d bytes, RAM ends at: 0x%x\r\n", (int)avail_ram, (int)end_of_ram);
+
+	platform_ops.fixups = platform_fixups;
+}
+
diff --git a/arch/powerpc/boot/dts/spacecom2.dts b/arch/powerpc/boot/dts/spacecom2.dts
new file mode 100644
index 0000000..841f09e
--- /dev/null
+++ b/arch/powerpc/boot/dts/spacecom2.dts
@@ -0,0 +1,314 @@
+/*
+ * SpaceCom II Device Tree Source
+ *
+ * Copyright 2010
+ * Christian Koerner <ckoener@sysgo.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/*
+ * WARNING: Do not depend on this tree layout remaining static just yet.
+ * The MPC5200 device tree conventions are still in flux
+ * Keep an eye on the linuxppc-dev mailing list for more details
+ */
+ 
+/dts-v1/;
+
+/ {
+	model = "men,spacecom2";
+	// revision = "1.0";
+	compatible = "men,spacecom2";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,5200@0 {
+			device_type = "cpu";
+			reg = <0>;
+			d-cache-line-size = <32>;
+			i-cache-line-size = <32>;
+			d-cache-size = <0x4000>;	// L1, 16K
+			i-cache-size = <0x4000>;	// L1, 16K
+			timebase-frequency = <0>;	// from bootloader
+			bus-frequency = <0>;		// from bootloader
+			clock-frequency = <0>;		// from bootloader
+			32-bit;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x10000000>;	// 256MB
+	};
+	
+	soc5200@f0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "fsl,mpc5200b-immr";
+		device_type = "soc";
+
+		ranges = <0 0xf0000000 0xf000c000>;
+		reg = <0xf0000000 0x0000c000>;
+
+		bus-frequency = <0>;		// from bootloader
+		system-frequency = <0>;		// from bootloader
+		cpu-type = <0>;				// from bootloader
+
+		cdm@200 {
+			compatible = "fsl,mpc5200b-cdm","fsl,mpc5200-cdm";
+			reg = <0x200 0x38>;
+		};
+
+		csc@300 {
+			compatible = "fsl,mpc5200b-csc","fsl,mpc5200-csc";
+			reg = <0x300 0x30>;
+		};
+		
+		mpc5200_pic: pic@500 {
+			// 5200 interrupts are encoded into two levels;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			device_type = "interrupt-controller";
+			compatible = "fsl,mpc5200b-pic","fsl,mpc5200-pic";
+			reg = <0x500 0x80>;
+		};
+
+		rled: timer@650 {	// Controls red status LED
+			compatible = "fsl,mpc5200-gpt";
+			cell-index = <0>;
+			reg = <0x650 0x10>;
+			interrupts = <1 14 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		gpio-leds {
+			compatible = "gpio-leds";
+
+			red {
+				default-state = "keep";
+				gpios = <&rled 0 0>;
+			};
+		};
+
+		wdt@600 {	// Watchdog
+			compatible = "fsl,mpc5200b-gpt","fsl,mpc5200-gpt";
+			reg = <0x600 0x10>;
+			has-wdt;
+		};		
+
+		timer@610 {	// Controls battery test
+			compatible = "fsl,mpc5200-gpt";
+			cell-index = <1>;
+			reg = <0x610 0x10>;
+			interrupts = <1 10 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		timer@620 {	// Controls power supply
+			compatible = "fsl,mpc5200-gpt";
+			cell-index = <2>;
+			reg = <0x620 0x10>;
+			interrupts = <1 11 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		rtc@800 {	// Real time clock
+			compatible = "fsl,mpc5200b-rtc","fsl,mpc5200-rtc";
+			device_type = "rtc";
+			reg = <0x800 0x100>;
+			interrupts = <1 5 0 1 6 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		can@900 {
+			compatible = "fsl,mpc5200b-mscan","fsl,mpc5200-mscan";
+			cell-index = <0>;
+			interrupts = <2 17 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			reg = <0x900 0x80>;
+		};
+		
+		gpio@b00 {
+			compatible = "fsl,mpc5200b-gpio","fsl,mpc5200-gpio";
+			reg = <0xb00 0x40>;
+			interrupts = <1 7 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		pci@d00 {
+			#interrupt-cells = <1>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			device_type = "pci";
+			compatible = "fsl,mpc5200b-pci","fsl,mpc5200-pci";
+			reg = <0xd00 0x100>;
+			interrupt-map-mask = <0xf800 0 0 7>;
+			interrupt-map = <0xc000 0 0 1 &mpc5200_pic 0 0 3
+							 0xc000 0 0 2 &mpc5200_pic 0 0 3
+							 0xc000 0 0 3 &mpc5200_pic 0 0 3
+							 0xc000 0 0 4 &mpc5200_pic 0 0 3>;
+			clock-frequency = <0>; // From boot loader
+			interrupts = <2 8 0 2 9 0 2 10 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			bus-range = <0 0>;
+			ranges = <0x42000000 0 0x80000000 0x90000000 0 0x20000000
+					  0x02000000 0 0xa0000000 0xb0000000 0 0x10000000
+					  0x01000000 0 0x00000000 0xc0000000 0 0x01000000>;
+		};
+
+		dma-controller@1200 {
+			device_type = "dma-controller";
+			compatible = "fsl,mpc5200b-bestcomm","fsl,mpc5200-bestcomm";
+			reg = <0x1200 0x80>;
+			interrupts = <3 0 0  3 1 0  3 2 0  3 3 0
+			              3 4 0  3 5 0  3 6 0  3 7 0
+			              3 8 0  3 9 0  3 10 0  3 11 0
+			              3 12 0  3 13 0  3 14 0  3 15 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		xlb@1f00 {
+			compatible = "fsl,mpc5200b-xlb","fsl,mpc5200-xlb";
+			reg = <0x1f00 0x100>;
+		};
+
+		serial@2000 {		// PSC1 Front panel
+			device_type = "serial";
+			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
+			port-number = <0>;  // Logical port assignment
+			reg = <0x2000 0x100>;
+			interrupts = <2 1 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		serial@2600 {		// PSC4 SpaceStation
+			device_type = "serial";
+			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
+			port-number = <1>;  // Logical port assignment
+			reg = <0x2600 0x100>;
+			interrupts = <2 11 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		serial@2800 {		// PSC5 Battery
+			device_type = "serial";
+			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
+			port-number = <2>;  // Logical port assignment
+			reg = <0x2800 0x100>;
+			interrupts = <2 12 0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
+
+		ethernet@3000 {
+			device_type = "network";
+			compatible = "fsl,mpc5200b-fec","fsl,mpc5200-fec";
+			reg = <0x3000 0x400>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <2 5 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			phy-handle = <&phy0>;
+		};
+		
+		mdio@3000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,mpc5200b-mdio", "fsl,mpc5200-mdio";
+			reg = <0x3000 0x400>;	// fec range, since we need to setup fec interrupts
+			interrupts = <2 5 0>;	// these are for "mii command finished", not link changes & co.
+			interrupt-parent = <&mpc5200_pic>;
+
+			phy0:ethernet-phy@0 {
+				device_type = "ethernet-phy";
+				reg = <1>;
+			};
+		};
+
+		i2c@3d00 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			device_type = "i2c";
+			compatible = "fsl,mpc5200b-i2c","fsl,mpc5200-i2c","fsl-i2c";
+			cell-index = <0>;
+			reg = <0x3d00 0x40>;
+			interrupts = <2 15 0>;
+			interrupt-parent = <&mpc5200_pic>;
+			fsl5200-clocking;
+			
+			temp@4d {
+				compatible = "lm75";
+				reg = <0x4d>;
+			};
+			
+			rtc@51 {
+				compatible = "rtc-rx8581,rx8581";
+				reg = <0x51>;
+			};
+			
+			eeprom: at24@54 {
+				compatible = "at24,24c08";
+				reg = <0x54>;
+			};
+		};
+
+		sram@8000 {
+			device_type = "sram";
+			compatible = "fsl,mpc5200b-sram","fsl,mpc5200-sram","sram";
+			reg = <0x8000 0x4000>;
+		};
+	};
+
+	lpb {
+		model = "fsl,lpb";
+		compatible = "fsl,lpb";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		reg = <0xffe00000 0x00200000>;
+		ranges = <0 0xffe00000 0xffe00000 0x00200000>;
+		
+		flash@0xffe00000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "cfi-flash";
+			bank-width = <1>;
+			device-width = <1>;
+			reg = <0 0xffe00000 0x00200000>;
+		
+			partition@0 {
+				label = "User";
+				reg = <0x00000000 0x00100000>;
+			};
+		
+			partition@100000 {
+				label = "PrimaryMenMon";
+				reg = <0x00100000 0x00080000>;
+			};
+		
+			partition@180000 {
+				label = "SecondaryMenMon";
+				reg = <0x00180000 0x00080000>;
+			};
+		};
+	};
+
+	chosen {
+		name = "chosen";
+        linux,platform = <0x00000600>; 
+		linux,stdout-path = "/soc5200@f0000000/serial@2000";
+		menmonparams = "";
+		flashstart = <0>; //from bootloader
+		flashsize = <0>; //from bootloader
+	};
+};
diff --git a/arch/powerpc/boot/mmparastring.c b/arch/powerpc/boot/mmparastring.c
new file mode 100644
index 0000000..130f475
--- /dev/null
+++ b/arch/powerpc/boot/mmparastring.c
@@ -0,0 +1,148 @@
+/*********************  P r o g r a m  -  M o d u l e ***********************
+ *  
+ *         Name: mmparastring.c
+ *      Project: many
+ *
+ *       Author: kp
+ *        $Date: 2010-08-16 16:57:47 $
+ *    $Revision: 1.1.1.1 $
+ *
+ *  Description: Routines to parse MENMON parameter string
+ *                      
+ *	Some MENMONs provide an ASCII string in memory containing board and
+ *	other parameters (first implemented on MEN B11). This library allows
+ *	you to parse these parameters easily. Can be used also to parse parameters
+ *	in VxWorks bootline
+ *                      
+ *     Required: -
+ *     Switches: MENMON
+ *
+ *---------------------------[ Public Functions ]----------------------------
+ *  MMPARA_SearchKey
+ *	MMPARA_StringToInt
+ *-------------------------------[ History ]---------------------------------
+ *
+ * cloned from common mmparastring 1.3
+ *
+ *---------------------------------------------------------------------------
+ * (c) Copyright 2002 by MEN mikro elektronik GmbH, Nuernberg, Germany 
+ ****************************************************************************/
+/* This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include "string.h"
+#include "mmparastring.h"
+
+#ifndef NULL
+# define NULL (void *)0
+#endif
+
+static int strncmp2(char *s1, char *s2, int  n)
+/*  register const char *s1, *s2; */
+/*  register int n; */
+{
+/* Compare 2 strings. */
+
+  while (1) {
+    if( n==0 ) return 0;
+    if (*s1 != *s2) return(*s1 - *s2);
+    if (*s1 == 0 )return(0);
+    n--;
+    s1++;
+    s2++;
+  }
+}
+
+static char *EatBlanks( char *p )
+{
+	while( *p==' ' || *p=='\t' )
+		p++;
+	return p;
+}
+
+/********************************* MMPARA_SearchKey **************************
+ *
+ *  Description: Search for a parameter in bootline or menmon parameters
+ *			   
+ *			     Copies the string found into the supplied buffer.
+ *				 dst must be large enough...	
+ *---------------------------------------------------------------------------
+ *  Input......: key				parameter name (e.g. "cbr=")
+ *				 src				source string containing parameters
+ *				 dst				destination string 
+ *  Output.....: returns:			<dst> or NULL if parameter not found
+ *  Globals....: -
+ ****************************************************************************/
+char *MMPARA_SearchKey( char *key, char *src, char *dst )
+{
+	int keylen;
+	char *orgDst = dst;
+
+	if( (src == NULL) || (dst == NULL) || (key == NULL) )
+		return NULL;
+
+	keylen = strlen(key);
+
+	while( *src ){
+		src = EatBlanks(src);	/* skip spaces */
+
+		if( strncmp2( key, src, keylen ) == 0 ){
+			/*--- found it ---*/
+
+			src += keylen;	/* skip parameter */
+			
+			/*--- copy string until next blank or EOS ---*/
+			while( *src && *src!=' ')
+				*dst++ = *src++;
+			*dst = '\0';
+			return orgDst;
+		}
+		/* search for next blank */
+		while( *src && *src!=' ')
+			src++;		
+	}
+	return NULL;
+}
+
+/********************************* MMPARA_StringToInt ***********************
+ *
+ *  Description: Convert string to integer accordung to "base"
+ *			   
+ *  If an illegal character is found, conversion is aborted and the return
+ *	value points to the unsuccessfully parsed character
+ *  Will handle positive integers only
+ *---------------------------------------------------------------------------
+ *  Input......: base			radix (2,10,16)
+ *				 expr		    string to parse
+ *  Output.....: returns:		ptr to first unsuccessfully parsed char
+ *				 *valP			value parsed
+ *  Globals....: -
+ ****************************************************************************/
+char *MMPARA_StringToInt( int base, char *expr, unsigned long *valP)
+{
+	unsigned long tmp=0, new;
+
+	while( *expr ){
+		if( *expr >= '0' && *expr <= '9' )
+			new = *expr - '0';
+		else if( *expr >= 'a' && *expr <= 'f' )
+			new = *expr - 'a' + 10;
+		else if( *expr >= 'A' && *expr <= 'F' )
+			new = *expr - 'A' + 10;
+		else
+			goto ex;
+		
+		if( new >= base )
+			goto ex;
+
+		tmp = (tmp*base) + new;
+		expr++;
+	}
+ex:
+	*valP = tmp;
+	return expr;
+}
+
diff --git a/arch/powerpc/boot/mmparastring.h b/arch/powerpc/boot/mmparastring.h
new file mode 100644
index 0000000..542362d
--- /dev/null
+++ b/arch/powerpc/boot/mmparastring.h
@@ -0,0 +1,20 @@
+/*
+ * arch/ppc/platforms/mmparastring.h
+ * 
+ * Header file for mmparastring.c to parse MENMON parameter strings
+ *
+ * Author: Klaus Popp <klaus.popp@men.de>
+ *
+ * Copyright 2002 MEN Mikro Elektronik GmbH.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+char *MMPARA_SearchKey( char *key, char *src, char *dst );
+char *MMPARA_StringToInt( int base, char *expr, unsigned long *valP);
+char *MMPARA_StringToIp( char *str, unsigned long *ipP );
+
+
diff --git a/arch/powerpc/boot/stringify.h b/arch/powerpc/boot/stringify.h
new file mode 100644
index 0000000..0b43883
--- /dev/null
+++ b/arch/powerpc/boot/stringify.h
@@ -0,0 +1,12 @@
+#ifndef __LINUX_STRINGIFY_H
+#define __LINUX_STRINGIFY_H
+
+/* Indirect stringification.  Doing two levels allows the parameter to be a
+ * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)
+ * converts to "bar".
+ */
+
+#define __stringify_1(x)	#x
+#define __stringify(x)		__stringify_1(x)
+
+#endif	/* !__LINUX_STRINGIFY_H */
diff --git a/arch/powerpc/platforms/52xx/mpc52xx_pic.h b/arch/powerpc/platforms/52xx/mpc52xx_pic.h
new file mode 100644
index 0000000..8437e27
--- /dev/null
+++ b/arch/powerpc/platforms/52xx/mpc52xx_pic.h
@@ -0,0 +1,11 @@
+/* HW IRQ mapping */
+#define MPC52xx_IRQ_L1_CRIT	(0)
+#define MPC52xx_IRQ_L1_MAIN	(1)
+#define MPC52xx_IRQ_L1_PERP	(2)
+#define MPC52xx_IRQ_L1_SDMA	(3)
+
+#define MPC52xx_IRQ_L1_OFFSET	(6)
+#define MPC52xx_IRQ_L1_MASK	(0x00c0)
+#define MPC52xx_IRQ_L2_MASK	(0x003f)
+
+#define MPC52xx_IRQ_HIGHTESTHWIRQ (0xd0)
diff --git a/arch/powerpc/platforms/52xx/spacecom2.c b/arch/powerpc/platforms/52xx/spacecom2.c
new file mode 100644
index 0000000..2ed6150
--- /dev/null
+++ b/arch/powerpc/platforms/52xx/spacecom2.c
@@ -0,0 +1,648 @@
+/*********************  P r o g r a m  -  M o d u l e ***********************/
+/*!
+ *        \file  spacecom2.c
+ *
+ *      \author  kp/ts
+ *        $Date: 2010-08-18 15:49:15 $
+ *    $Revision: 1.2 $
+ *
+ *        \brief Platform support file for the SpaceCom II board based on MPC52xx.
+ *               Located in linux tree: arch/powerpc/platforms/52xx/spacecom2/
+ *
+ *
+ *-------------------------------[ History ]---------------------------------
+ *
+ * $Log: not supported by cvs2svn $
+ * Revision 1.1.1.1  2010/08/16 16:57:47  mar
+ * PR#280-projects Add 2.6.34.
+ *
+ * Revision 1.5  2010/07/15 13:10:08  cko
+ * Enable the 48 MHz oscillator as system clock of the external USB controller.
+ *
+ * Revision 1.4  2010/07/07 14:56:32  mar
+ * PR#274-projects Add GPIO/Led subsystem support.
+ *
+ * Revision 1.3  2010/06/23 14:46:46  cko
+ * - Added workaround for bs.uboot bug by setting load and entry address.
+ * - Removed setting of the USB clock. Let the MenMon set this bit.
+ * - Changed the link address to support a kernel size of up to 12 MB (the MenMon can't handle bigger images).
+ *
+ * Revision 1.2  2010/06/21 16:37:28  mar
+ * PR#274-projects Fix the GPIO setup, make serial ports work.
+ *
+ * Revision 1.1.1.1  2010/06/01 10:03:00  cko
+ * Initial import of the SpaceCom II BSP.
+ *
+ * Revision 1.11  2010/02/10 19:13:12  ts
+ * R: cosmetics, removed #if 0... parts
+ *
+ * Revision 1.10  2009/10/20 13:36:19  ts
+ * R: message about applied reset to CPLD didnt appear
+ * M: inclreased verbose level to KERN_WARNING
+ *
+ * Revision 1.9  2009/10/15 12:18:54  ts
+ * R: Cosmetics, aligned Register output
+ *
+ * Revision 1.8  2009/09/17 13:54:03  ts
+ * R: USB showed abnormal behaviour on boards with 256MB because Menmon didnt
+ *    setup XLB snoop size window correctly.
+ * M: setup snoop window size again according to mem0 parameter
+ *
+ * Revision 1.7  2009/09/11 13:44:00  ts
+ * R: 1) In case Silicon revision wasnt found 0xB3 is assumed but was not set
+ *    2) when M99 on D203 was opened (m_open) the F500 PCI bridge was disabled
+ * M: 1) actually assign 0xb3 to    ppc_md.cpu_type
+ *    2) in menem1_pcidev_enable(): PCI_CMD read out before changing
+ *
+ * Revision 1.6  2009/03/18 14:23:00  ts
+ * R: New fileset 10EM01-90 created, official release
+ *
+ * Revision 1.5  2009/03/11 19:35:54  ts
+ * R: small cosmetics, indented XLB and register dumps more correctly
+ *
+ * Revision 1.4  2009/03/10 17:57:32  ts
+ * R: 1) FEC Ethernet didnt work correctly
+ *    2) EM1 specific settings e.g. for USB not at right location in
+ *       mpc52xx_common.c
+ * M: 1) enabled XLB pipelining and display thorough XLB config settings
+ *    2) moved all MEN specific stuff in men5200_setup.c
+ *
+ * Revision 1.3  2009/03/06 15:52:31  ts
+ * R: Cosmetics, removed one unintended CVS tag
+ *
+ * Revision 1.2  2009/03/06 15:40:37  ts
+ * R: 1) kernel crash while booting on F12: ppc_md.cpu_type wasnt set,
+ *    PCI enumeration thought its early Rev. A2 and tried to apply Conf Type 1
+ *    bug workaround which crashed
+ *    2) MENMON parameter string wasnt visible
+ * M: 1) ppc_md.cpu_type retrieved in setup_arch from device tree
+ *    2) added printk with MENMON parameter string
+ *
+ * Revision 1.1  03.02.2009 15:41:12 by ts
+ * R: BSP maintenance now at MEN, own repository location
+ *
+ *---------------------------------------------------------------------------
+ * (c) Copyright by MEN mikro elektronik GmbH, Nuremberg, Germany
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ ****************************************************************************/
+
+#undef DEBUG
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ipic.h>
+#include <asm/irq.h>
+#include <asm/prom.h>
+#include <asm/udbg.h>
+#include <sysdev/fsl_soc.h>
+#include <asm/of_platform.h>
+#include <asm/mpc52xx.h>
+#include <platforms/52xx/spacecom2.h>
+#include <platforms/52xx/mpc52xx_pic.h>
+
+#define USB_EXT_SYNC 4
+#define USB_EXT_EN   2
+
+#define MAX_MEM_STRNGSZ         32      /* should hold '1048576'+'\0' */
+#define MAX_MMPARASTRING_LEN    1024
+char men5200_mmparastring[MAX_MMPARASTRING_LEN];
+char revision[MAX_MMPARASTRING_LEN];
+
+/* needed globally for men_sysparam*/
+EXPORT_SYMBOL(men5200_mmparastring); /* for men_sysparam and others */
+
+/* ======================================================================== */
+/* Platform specific code                                                   */
+/* ======================================================================== */
+void spacecom2_show_cpuinfo(struct seq_file *m)
+{
+	struct device_node* np = of_find_all_nodes(NULL);
+	const char *model = NULL;
+
+	if (np)
+		model = of_get_property(np, "model", NULL);
+
+	seq_printf(m, "vendor\t\t: MEN \n");
+	seq_printf(m, "machine\t\t: %s\n", model ? model : "Unknown");
+	seq_printf(m, "boardrevision\t: %s\n", revision);
+	of_node_put(np);
+}
+
+/***************************************************************************/
+/** helper to convert strings to int
+ *
+ *  \input  base   base of number (2,10,16)
+ *  \input  expr   string to parse
+ *  \output valP   result of value parsed
+ *
+ *  \return position to first character decoded
+ */
+char *str2int(int base, char *expr, unsigned long *valP)
+{
+	unsigned long tmp = 0, new;
+	
+	while (*expr) {
+		if (*expr >= '0' && *expr <= '9')
+			new = *expr - '0';
+		else if (*expr >= 'a' && *expr <= 'f')
+			new = *expr - 'a' + 10;
+		else if (*expr >= 'A' && *expr <= 'F')
+			new = *expr - 'A' + 10;
+		else
+			goto ex;
+		
+		if (new >= base)
+			goto ex;
+		
+		tmp = (tmp * base) + new;
+		expr++;
+	}
+	ex:
+	*valP = tmp;
+
+	return expr;
+}
+
+#ifdef CONFIG_PCI
+
+/***************************************************************************/
+/** used mapping of external IRQs to interrupt lines:
+ *
+ * MPC5200
+ * IRQ input    line    assigned(Menmon)    MPC52xx irq value
+ * IRQ0         INTA        0xf0                MPC52xx_IRQ0
+ * IRQ1         INTB        0xf1                MPC52xx_IRQ1
+ * IRQ2         INTC        0xf2                MPC52xx_IRQ2
+ * IRQ3         INTD        0xf3                MPC52xx_IRQ3
+ *
+ * \returns     (ISA)IRQ number to assign to this devices PCI_INTERRUPT_LINE.
+ *               Its assigned as in the table above, all setup done in Menmon
+ *
+ * \brief fixes pci irq mapping
+ *  void pci_irq_fixup(struct pci_dev *);
+ */
+void __devinit pci_irq_fixup(struct pci_dev *dev)
+{
+	unsigned char line;
+
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE,&line);
+	
+	/* 0x00 = (MPC52xx_IRQ_L1_CRIT << MPC52xx_IRQ_L1_OFFSET) + 0
+	 * 0x41 = (MPC52xx_IRQ_L1_MAIN << MPC52xx_IRQ_L1_OFFSET) + 1
+	 * 0x42 = (MPC52xx_IRQ_L1_MAIN << MPC52xx_IRQ_L1_OFFSET) + 2
+	 * 0x43 = (MPC52xx_IRQ_L1_MAIN << MPC52xx_IRQ_L1_OFFSET) + 3
+	 */
+	switch (line) {
+	case 0xf0:
+		dev->irq = irq_create_mapping(NULL, 0x00);
+		break;
+	case 0xf1:
+		dev->irq = irq_create_mapping(NULL, 0x41);
+		break;
+	case 0xf2:
+		dev->irq = irq_create_mapping(NULL, 0x42);
+		break;
+	case 0xf3:
+		dev->irq = irq_create_mapping(NULL, 0x43);
+		break;
+	default:
+		return;
+	}
+
+	if (dev->irq != NO_IRQ) {
+		set_irq_type(dev->irq, IRQ_TYPE_LEVEL_LOW);
+	}
+}
+
+/***************************************************************************/
+/* Called when pci_enable_device() is called or
+ * when a device with no assigned resource is found.
+ * Returns 0 to allow assignment/enabling of the device.
+ * machdep.h: int (*pcibios_enable_device_hook)(struct pci_dev *);
+ */
+static int pcidev_enable(struct pci_dev *dev)
+{
+	int idx;
+	unsigned short cmd = 0;
+	struct resource *r;
+	
+	for (idx=0; idx < 6; idx++) {
+		/* dont change command bits which are already set */
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		r = &dev->resource[idx];
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+#if 0
+	printk("pcidev_enable: vendor:0x%04x device :0x%04x cmd 0x%04x\n",
+	dev->vendor, dev->device, cmd );
+#endif
+	pci_write_config_word(dev, PCI_COMMAND, cmd );
+
+	return 0;
+}
+
+#endif /* CONFIG_PCI */
+
+static void __init spacecom2_setup_cpu(void)
+{
+	/* specific SpaceCom II setup . Others are set at mpc52xx_setup_cpu */
+	struct device_node *np;
+	struct mpc52xx_gpio __iomem *gpio;
+	struct mpc52xx_cdm  __iomem *cdm;
+	struct mpc52xx_intr __iomem *intr;
+	struct mpc52xx_xlb  __iomem *xlb;
+	u32 __iomem *csc;
+	
+	u32 port_config = 0;
+	u32 snoop_size = 0;
+	u32 intr_ctrl, i;
+	u32 reg_val;
+	char memory[MAX_MEM_STRNGSZ];
+	unsigned long memsize = 0;
+	char *mP;
+	
+	/* helper for verbose register dump */
+	const char *pmode[4] = {
+		"No parking            ",
+		"Reserved              ",
+		"most recently used    ",
+		"as set in CONFIG[10:8]"
+	};
+	
+	/*--------------------
+	| Map zones           |
+	--------------------*/
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5200b-gpio");
+	gpio = of_iomap(np, 0);
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5200b-cdm");
+	cdm = of_iomap(np, 0);
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5200b-pic");
+	intr = of_iomap(np, 0);
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5200b-xlb");
+	xlb = of_iomap(np, 0);
+	of_node_put(np);
+	
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5200b-csc");
+	csc = of_iomap(np, 0);
+	of_node_put(np);	
+
+	if (!gpio || !cdm || !intr || !xlb || !csc) {
+		printk(KERN_ERR __FILE__ ": "                                   \
+		"*** Error while remapping one of GPIO/CDM/INTR/XLB/CSC Registers"
+		" for configuration. Expect some abnormal behavior!\n");
+		
+		printk(KERN_ERR "Remapped values:\n ");
+		printk(KERN_ERR "GPIO:    %p\n ", gpio);
+		printk(KERN_ERR "CDM:     %p\n ", cdm);
+		printk(KERN_ERR "INTR:    %p\n ", intr);
+		printk(KERN_ERR "XLB:     %p\n ", xlb);
+		printk(KERN_ERR "CSC:     %p\n ", csc);
+		goto unmap_regs;
+	}
+	
+	/*--------------------
+	| USB clk settings    |
+	--------------------*/
+	/*
+	* ts: now use external 48 MHz at RevB2/3 boards.
+	* check MPC5200 CDM 48MHz Fractional Divider Configuration Register
+	* User Manual p. 5-15
+	*/
+	out_8( &cdm->ext_48mhz_en,  USB_EXT_SYNC | USB_EXT_EN );
+	out_8( &cdm->fd_enable,     0x0 );
+	
+	/*--------------------
+	| XLB configuration   |
+	--------------------*/
+	/*
+	* Enable pipelining, fixes FEC problems, but suitable only for MPC5200B
+	* ts: check if the other mentioned fix ("disable BestComm snoop" )
+	*  must be / can be applied too ?
+	*/
+	out_be32(&xlb->config, in_be32(&xlb->config) & ~MPC52xx_XLB_CFG_PLDIS);
+
+	/*
+	* Fix XLB snoop window Problem with 256 MB boards and MM <=1.20
+	*/
+	
+	/* dont have MMPARA_xx funcs here, seek for 'mem0=' */
+	memset((void*)memory, 0x0, MAX_MEM_STRNGSZ);
+	for (i = 0; i < (MAX_MMPARASTRING_LEN - MAX_MEM_STRNGSZ - 1); i++ ) {
+		mP = &men5200_mmparastring[i];  /* paranoia! accept mem0= or MEM0= */
+		if (((mP[0]=='m')||(mP[0]=='M')) && ((mP[1]=='e')||(mP[1]=='E')) &&
+			((mP[2]=='m')||(mP[2]=='M')) && ( mP[3]=='0')) {
+			mP+=5; /* skip 'mem0=' */
+			memcpy(memory, mP, MAX_MEM_STRNGSZ);
+			memory[MAX_MEM_STRNGSZ-1] = 0;
+		}
+	}
+	str2int(10, memory, &memsize);
+	
+	if (memsize) {
+		printk(KERN_INFO "XLB snoop window check: Found memsize '%ld'\n",
+			   memsize);
+	} else {
+		printk(KERN_INFO "*** couldnt find 'mem0=' param, assume 128MB!\n");
+		memsize=MEM_SIZE_128MB;
+	}
+	
+	snoop_size = in_be32(&xlb->snoop_window);
+	printk(KERN_INFO "Got XLB snoop size window: 0x%08x\n", snoop_size);
+	
+	snoop_size &=~0xffffffe0; /* clear WINSIZE[4:0] */
+	
+	switch (memsize) {
+	case MEM_SIZE_1GB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_1GB;
+		break;
+	case MEM_SIZE_512MB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_512MB;
+		break;
+	case MEM_SIZE_256MB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_256MB;
+		break;
+	case MEM_SIZE_128MB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_128MB;
+		break;
+	case MEM_SIZE_64MB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_64MB;
+		break;
+	case MEM_SIZE_32MB:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_32MB;
+		break;
+	default:
+		snoop_size |= XLBARB_SNOOPWIN_SIZE_128MB;
+	}
+	
+	printk(KERN_INFO "Set XLB snoop size window: 0x%08x\n", snoop_size);
+	/* commit changed XLB snoop size */
+	out_be32(&xlb->snoop_window, snoop_size );
+	
+	/*--------------------
+	| port configuration  |
+	--------------------*/
+	
+	/* Get port mux config */
+	port_config = in_be32(&gpio->port_config);
+	
+	/* Set it to 0x80052004 */
+	/* Serial ports on PCS1 PSC4 PSC5 */
+	port_config &= ~0x00000007;
+	port_config |=  0x00000004;
+
+	/* Disable internal USB and set PSC4 and PSC5 there */
+	port_config &= ~0x00003000;
+	port_config |=  0x00002000; 
+	
+	/* Ethernet port */
+	port_config &= ~0x000f0000; /* 100 Mbits with MDIO lines */
+	port_config |= 0x00050000;
+	
+	/* CAN port, PSC2 */
+	port_config &= ~0x00000070;
+	port_config |= 0x00000010;
+	
+	/* Commit port config */
+	out_be32(&gpio->port_config, port_config);
+	
+	/* IRQ0-3: level-sensitive, active low (PCI like) */
+	intr_ctrl = in_be32(&intr->ctrl);
+	intr_ctrl &= ~0x00ff0000;
+	intr_ctrl |= 0x00ff0000;
+	out_be32(&intr->ctrl, intr_ctrl);
+	
+	/* Enable write access to the boot flash */
+	out_be32(csc, in_be32(csc) & ~3);
+	
+	/* everything should be up and running. Dump internal registers summary: */
+	printk(KERN_INFO
+		"Setup of CPU finished. Most important Register settings:\n");
+	reg_val = in_be32(&xlb->config);
+	printk(KERN_INFO "  XLB configuration register:                0x%08x\n",
+		reg_val);
+	printk(KERN_INFO "  |-> Pipelining: %s                   CONFIG[31]\n",
+		(reg_val & (1<<31)) ? "disabled" : "enabled ");
+	printk(KERN_INFO "  |-> BestComm snooping: %s            CONFIG[16]\n",
+		(reg_val & (1<<16)) ? "disabled" : "enabled ");
+	printk(KERN_INFO "  |-> XLB snoop: %s                    CONFIG[15]\n",
+		(reg_val & (1<<15)) ? "enabled ": "disabled" );
+	printk(KERN_INFO "  |-> write-with-flush: %s             CONFIG[14]\n",
+		(reg_val & (1<<14)) ? "enabled " : "disabled");
+	printk(KERN_INFO "  |-> Timebase counter: %s             CONFIG[13]\n",
+		(reg_val & (1<<13)) ? "enabled" : "stopped");
+	printk(KERN_INFO "  |-> Min. Waitstates: %s              CONFIG[11]\n",
+		(reg_val & (1<<11)) ? "1      " : "0        ");
+	printk(KERN_INFO "  |-> parked Master: %d               "
+		"        CONFIG[10:8]\n", ((reg_val & 0x700) >> 8)  );
+	printk(KERN_INFO "  `-> parking mode: %s   CONFIG[6:5]\n",
+		pmode[ (reg_val & 0x60) >> 5 ]);
+	
+	reg_val = in_be32(&gpio->port_config);
+	printk(KERN_INFO "  GPIO port configuration Register           0x%08x\n",
+		reg_val);
+
+	/* the member is u8 ext_48mhz_en but we read 32bit at once */
+	reg_val = in_be32((u32*)&cdm->ext_48mhz_en);
+	printk(KERN_INFO "  CDM fract. divider configuration:          0x%08x\n",
+		reg_val);
+	printk(KERN_INFO "  |-> USB 48MHz clk select: %s         FDCR[25]\n",
+		(reg_val & (1<<25)) ? "external" : "internal");
+
+	printk(KERN_INFO "  |-> ext 48MHz USB clk sync: %s       FDCR[26]\n",
+		(reg_val & (1<<26)) ? "synchron" : "asyncron" );
+
+	printk(KERN_INFO "  `-> fractional divider: %s           FDCR[16]\n",
+		 (reg_val & (1<<26)) ? "enabled " : "disabled" );
+
+	reg_val = in_be32(&xlb->snoop_window);
+	printk(KERN_INFO "  XLB snoop window register:                 0x%08x\n",
+		reg_val);
+
+	memset((void*)memory, 0x0, MAX_MEM_STRNGSZ);
+	for (i = 0; i < (MAX_MMPARASTRING_LEN - 7 - 1); i++ ) {
+		mP = &men5200_mmparastring[i];
+		if (!strncmp(mP, "brdrev=", 7)) {
+			mP+=7; /* skip */
+			memcpy(memory, mP, MAX_MEM_STRNGSZ);
+			memory[MAX_MEM_STRNGSZ-1] = 0;
+		}
+	}
+	{
+		char *s = strchr(memory, ' ');
+		if (s)
+			*s = 0;
+		strncpy(revision, memory, 10);
+	}
+
+	/* Unmap reg zone */
+unmap_regs:
+	iounmap(gpio);
+	iounmap(cdm);
+	iounmap(intr);
+	iounmap(xlb);
+	iounmap(csc);
+}
+
+static void __init spacecom2_setup_arch(void)
+{
+	struct device_node *np;
+	struct device_node *devp;
+	
+	const char * tmp_mmparastring = NULL;
+	
+	/* Retrieve MENMON parameter string */
+	devp = of_find_node_by_path("/chosen");
+	if (devp)
+		tmp_mmparastring = of_get_property(devp, "menmonparams", NULL);
+	
+	if ((!devp) || (!tmp_mmparastring)) {
+		printk(KERN_ERR __FILE__ ": " \
+		"Error while retrieving MENMON parameter string. "
+		"Expect some abnormal behavior\n");
+	} else {
+		memcpy(men5200_mmparastring,
+			tmp_mmparastring,
+			strlen(tmp_mmparastring));
+		printk(KERN_INFO "MENMON parameter string: '%s'\n",
+		   men5200_mmparastring );
+	}
+	
+	if (ppc_md.progress)
+		ppc_md.progress("spacecom2_setup_arch()", 0);
+	
+	np = of_find_node_by_type(NULL, "cpu");
+	if (np) {
+		const unsigned int *fp =
+			of_get_property(np, "clock-frequency", NULL);
+		if (fp)
+			loops_per_jiffy = *fp / HZ;
+		else
+			loops_per_jiffy = 50000000 / HZ;
+		of_node_put(np);
+	}
+
+	/* Map important registers from the internal memory map */
+	mpc52xx_map_common_devices();
+
+	/* Some mpc5200 & mpc5200b related configuration */
+	mpc5200_setup_xlb_arbiter();
+
+	spacecom2_setup_cpu();  /* Platform specific */
+	
+#ifdef CONFIG_PM
+	mpc52xx_suspend.board_suspend_prepare = mpc5200_suspend_prepare;
+	mpc52xx_suspend.board_resume_finish = mpc5200_resume_finish;
+	mpc52xx_pm_init();
+#endif
+	
+#ifdef CONFIG_PCI
+	np = of_find_node_by_type(NULL, "pci");
+	if (np) {
+		mpc52xx_add_bridge(np);
+		of_node_put(np);
+	}
+#endif
+	
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+#ifdef  CONFIG_ROOT_NFS
+	ROOT_DEV = Root_NFS;
+#else
+	ROOT_DEV = Root_HDA1;
+#endif
+}
+
+void pcibios_fixup(void)
+{
+	struct pci_dev *dev;
+	
+	/* Search the external USB controller */
+	dev = pci_get_bus_and_slot(0, PCI_DEVFN(0x18, 0));
+	/* System clock is 48 MHz oscillator. */
+	pci_write_config_dword(dev, 0xe4, 0x20);
+
+	dev = NULL;
+	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		if (dev->devfn == 0xa0) {
+			dev->irq = (MPC52xx_IRQ_L1_CRIT << MPC52xx_IRQ_L1_OFFSET) + 0;
+			/* MPC52xx_IRQ0 */
+			pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+		}
+	}
+}
+
+/*
+ * Called very early, MMU is off, device-tree isn't unflattened
+ */
+static int __init spacecom2_probe(void)
+{
+	unsigned long node = of_get_flat_dt_root();
+	const char *model = of_get_flat_dt_prop(node, "model", NULL);
+
+	if (!of_flat_dt_is_compatible(node, "men,spacecom2"))
+		return 0;
+
+	pr_debug("%s board found\n", model ? model : "unknown");
+	printk("%s board found\n", model ? model : "unknown");
+
+	return 1;
+}
+
+define_machine(spacecom2) {
+	.name                       = "spacecom2",
+	.probe                      = spacecom2_probe,
+	.setup_arch                 = spacecom2_setup_arch,
+	.init                       = mpc52xx_declare_of_platform_devices,
+	.init_IRQ                   = mpc52xx_init_irq,
+	.get_irq                    = mpc52xx_get_irq,
+	.show_cpuinfo               = spacecom2_show_cpuinfo,
+	.calibrate_decr             = generic_calibrate_decr,
+	.progress                   = udbg_progress,
+	
+#ifdef CONFIG_PCI
+	.pci_irq_fixup              = pci_irq_fixup,
+	.pcibios_enable_device_hook = pcidev_enable,
+	.pcibios_fixup              = pcibios_fixup,
+#endif /* CONFIG_PCI*/
+	
+	/*.find_end_of_memory   = mpc52xx_find_end_of_memory,*/
+	/*.setup_io_mappings    = mpc52xx_map_io,*/
+	.restart                    = mpc52xx_restart,
+#if 0
+	.power_off                  = mpc52xx_power_off,
+	.halt                       = mpc52xx_halt,
+#endif
+	.calibrate_decr             = generic_calibrate_decr,
+};
diff --git a/arch/powerpc/platforms/52xx/spacecom2.h b/arch/powerpc/platforms/52xx/spacecom2.h
new file mode 100644
index 0000000..aa6989d
--- /dev/null
+++ b/arch/powerpc/platforms/52xx/spacecom2.h
@@ -0,0 +1,67 @@
+/*********************  P r o g r a m  -  M o d u l e ***********************/
+/*!
+ *        \file  spacecom2.h
+ *
+ *      \author  kp/ts
+ *        $Date: 2010-08-16 16:57:47 $
+ *    $Revision: 1.1.1.1 $
+ *
+ *        \brief basic header defines for SpaceCom II ElinOS BSP.
+ *				 Located in linux tree: arch/powerpc/platforms/52xx/
+ *
+ * 
+ *-------------------------------[ History ]---------------------------------
+ *
+ * $Log: not supported by cvs2svn $
+ * Revision 1.1.1.1  2010/06/01 10:03:00  cko
+ * Initial import of the SpaceCom II BSP.
+ *
+ * Revision 1.3  2009/10/14 18:14:27  ts
+ * R: cosmetics, documentation header added
+ *
+ * Revision 1.2  14.10.2009 13:45:07 by ts
+ * R: EM1 MM didnt properly set up XLB snoop size, made USB not work
+ * M: reinitialize size bits in linux, added size defines
+ *
+ * Revision 1.1  18.03.2009 14:23:06 by ts
+ * R: New fileset 10EM01-90 created, official release
+ *
+ *---------------------------------------------------------------------------
+ * (c) Copyright by MEN mikro elektronik GmbH, Nuremberg, Germany
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ ****************************************************************************/
+
+#ifndef __PLATFORMS_SPACECOM2_H
+#define __PLATFORMS_SPACECOM2_H
+
+#define MPC52xx_PF_CONSOLE_PORT 	0 		/* PSC0 */
+
+/* set XLB snoop window size to a correct value */
+#define XLBARB_SNOOPWIN_SIZE_1GB		0x1D
+#define MEM_SIZE_1GB					(1<<20)  /* 1048576 */
+#define XLBARB_SNOOPWIN_SIZE_512MB		0x1C
+#define MEM_SIZE_512MB					(1<<19)  /* 524288 	*/
+#define XLBARB_SNOOPWIN_SIZE_256MB		0x1B
+#define MEM_SIZE_256MB					(1<<18)	 /* 262144 	*/
+#define XLBARB_SNOOPWIN_SIZE_128MB		0x1A
+#define MEM_SIZE_128MB					(1<<17)  /* 131072 	*/
+#define XLBARB_SNOOPWIN_SIZE_64MB		0x19
+#define MEM_SIZE_64MB					(1<<16)  /*  65536 	*/
+#define XLBARB_SNOOPWIN_SIZE_32MB		0x18
+#define MEM_SIZE_32MB					(1<<15)  /* 32768 	*/
+
+extern char men5200_mmparastring[];
+extern u32 spacecom2_flash_size;
+
+extern int powersave_nap;
+extern void (*really_late_time_init)(void);
+
+extern void mpc52xx_find_bridges(void);
+extern void men5200_time_init(void);
+
+
+#endif /* __PLATFORMS_SPACECOM2_H */
diff --git a/drivers/net/wireless/ath/carl9170/Kconfig b/drivers/net/wireless/ath/carl9170/Kconfig
new file mode 100644
index 0000000..2d1b821
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/Kconfig
@@ -0,0 +1,41 @@
+config CARL9170
+	tristate "Linux Community AR9170 802.11n USB support"
+	depends on USB && MAC80211 && EXPERIMENTAL
+	select FW_LOADER
+	select CRC32
+	help
+	  This is another driver for the Atheros "otus" 802.11n USB devices.
+
+	  This driver provides more features than the original,
+	  but it needs a special firmware (carl9170-1.fw) to do that.
+
+	  The firmware can be downloaded from our wiki here:
+	  <http://wireless.kernel.org/en/users/Drivers/carl9170>
+
+	  If you choose to build a module, it'll be called carl9170.
+
+config CARL9170_LEDS
+	bool "SoftLED Support"
+	depends on CARL9170
+	select MAC80211_LEDS
+	select LEDS_CLASS
+	select NEW_LEDS
+	default y
+	help
+	  This option is necessary, if you want your device' LEDs to blink
+
+	  Say Y, unless you need the LEDs for firmware debugging.
+
+config CARL9170_DEBUGFS
+	bool "DebugFS Support"
+	depends on CARL9170 && DEBUG_FS && MAC80211_DEBUGFS
+	default n
+	help
+	  Export several driver and device internals to user space.
+
+	  Say N.
+
+config CARL9170_WPC
+	bool
+	depends on CARL9170 && (INPUT = y || INPUT = CARL9170)
+	default y
diff --git a/drivers/net/wireless/ath/carl9170/Makefile b/drivers/net/wireless/ath/carl9170/Makefile
new file mode 100644
index 0000000..f64ed76
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/Makefile
@@ -0,0 +1,4 @@
+carl9170-objs := main.o usb.o cmd.o mac.o phy.o led.o fw.o tx.o rx.o
+carl9170-$(CONFIG_CARL9170_DEBUGFS) += debug.o
+
+obj-$(CONFIG_CARL9170) += carl9170.o
diff --git a/drivers/net/wireless/ath/carl9170/carl9170.h b/drivers/net/wireless/ath/carl9170/carl9170.h
new file mode 100644
index 0000000..6cf0c9e
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/carl9170.h
@@ -0,0 +1,628 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * Driver specific definitions
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __CARL9170_H
+#define __CARL9170_H
+
+#include <linux/kernel.h>
+#include <linux/firmware.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <linux/usb.h>
+#ifdef CONFIG_CARL9170_LEDS
+#include <linux/leds.h>
+#endif /* CONFIG_CARL170_LEDS */
+#ifdef CONFIG_CARL9170_WPC
+#include <linux/input.h>
+#endif /* CONFIG_CARL9170_WPC */
+#include "eeprom.h"
+#include "wlan.h"
+#include "hw.h"
+#include "fwdesc.h"
+#include "fwcmd.h"
+#include "../regd.h"
+
+#ifdef CONFIG_CARL9170_DEBUGFS
+#include "debug.h"
+#endif /* CONFIG_CARL9170_DEBUGFS */
+
+#define CARL9170FW_NAME	"carl9170-1.fw"
+
+#define PAYLOAD_MAX	(CARL9170_MAX_CMD_LEN / 4 - 1)
+
+enum carl9170_rf_init_mode {
+	CARL9170_RFI_NONE,
+	CARL9170_RFI_WARM,
+	CARL9170_RFI_COLD,
+};
+
+#define CARL9170_MAX_RX_BUFFER_SIZE		8192
+
+enum carl9170_device_state {
+	CARL9170_UNKNOWN_STATE,
+	CARL9170_STOPPED,
+	CARL9170_IDLE,
+	CARL9170_STARTED,
+};
+
+#define CARL9170_NUM_TID		16
+#define WME_BA_BMP_SIZE			64
+#define CARL9170_TX_USER_RATE_TRIES	3
+
+#define WME_AC_BE   2
+#define WME_AC_BK   3
+#define WME_AC_VI   1
+#define WME_AC_VO   0
+
+#define TID_TO_WME_AC(_tid)				\
+	((((_tid) == 0) || ((_tid) == 3)) ? WME_AC_BE :	\
+	 (((_tid) == 1) || ((_tid) == 2)) ? WME_AC_BK :	\
+	 (((_tid) == 4) || ((_tid) == 5)) ? WME_AC_VI :	\
+	 WME_AC_VO)
+
+#define SEQ_DIFF(_start, _seq) \
+	(((_start) - (_seq)) & 0x0fff)
+#define SEQ_PREV(_seq) \
+	(((_seq) - 1) & 0x0fff)
+#define SEQ_NEXT(_seq) \
+	(((_seq) + 1) & 0x0fff)
+#define BAW_WITHIN(_start, _bawsz, _seqno) \
+	((((_seqno) - (_start)) & 0xfff) < (_bawsz))
+
+enum carl9170_tid_state {
+	CARL9170_TID_STATE_INVALID,
+	CARL9170_TID_STATE_KILLED,
+	CARL9170_TID_STATE_SHUTDOWN,
+	CARL9170_TID_STATE_SUSPEND,
+	CARL9170_TID_STATE_PROGRESS,
+	CARL9170_TID_STATE_IDLE,
+	CARL9170_TID_STATE_XMIT,
+};
+
+#define CARL9170_BAW_BITS (2 * WME_BA_BMP_SIZE)
+#define CARL9170_BAW_SIZE (BITS_TO_LONGS(CARL9170_BAW_BITS))
+#define CARL9170_BAW_LEN (DIV_ROUND_UP(CARL9170_BAW_BITS, BITS_PER_BYTE))
+
+struct carl9170_sta_tid {
+	/* must be the first entry! */
+	struct list_head list;
+
+	/* temporary list for RCU unlink procedure */
+	struct list_head tmp_list;
+
+	/* lock for the following data structures */
+	spinlock_t lock;
+
+	unsigned int counter;
+	enum carl9170_tid_state state;
+	u8 tid;		/* TID number ( 0 - 15 ) */
+	u16 max;	/* max. AMPDU size */
+
+	u16 snx;	/* awaiting _next_ frame */
+	u16 hsn;	/* highest _queued_ sequence */
+	u16 bsn;	/* base of the tx/agg bitmap */
+	unsigned long bitmap[CARL9170_BAW_SIZE];
+
+	/* Preaggregation reorder queue */
+	struct sk_buff_head queue;
+};
+
+#define CARL9170_QUEUE_TIMEOUT		256
+#define CARL9170_BUMP_QUEUE		1000
+#define CARL9170_TX_TIMEOUT		2500
+#define CARL9170_JANITOR_DELAY		128
+#define CARL9170_QUEUE_STUCK_TIMEOUT	5500
+
+#define CARL9170_NUM_TX_AGG_MAX		30
+
+/*
+ * Tradeoff between stability/latency and speed.
+ *
+ * AR9170_TXQ_DEPTH is devised by dividing the amount of available
+ * tx buffers with the size of a full ethernet frame + overhead.
+ *
+ * Naturally: The higher the limit, the faster the device CAN send.
+ * However, even a slight over-commitment at the wrong time and the
+ * hardware is doomed to send all already-queued frames at suboptimal
+ * rates. This in turn leads to an enourmous amount of unsuccessful
+ * retries => Latency goes up, whereas the throughput goes down. CRASH!
+ */
+#define CARL9170_NUM_TX_LIMIT_HARD	((AR9170_TXQ_DEPTH * 3) / 2)
+#define CARL9170_NUM_TX_LIMIT_SOFT	(AR9170_TXQ_DEPTH)
+
+struct carl9170_tx_queue_stats {
+	unsigned int count;
+	unsigned int limit;
+	unsigned int len;
+};
+
+struct carl9170_vif {
+	unsigned int id;
+	struct ieee80211_vif *vif;
+};
+
+struct carl9170_vif_info {
+	struct list_head list;
+	bool active;
+	unsigned int id;
+	struct sk_buff *beacon;
+	bool enable_beacon;
+};
+
+#define AR9170_NUM_RX_URBS	16
+#define AR9170_NUM_RX_URBS_MUL	2
+#define AR9170_NUM_TX_URBS	8
+#define AR9170_NUM_RX_URBS_POOL (AR9170_NUM_RX_URBS_MUL * AR9170_NUM_RX_URBS)
+
+enum carl9170_device_features {
+	CARL9170_WPS_BUTTON		= BIT(0),
+	CARL9170_ONE_LED		= BIT(1),
+};
+
+#ifdef CONFIG_CARL9170_LEDS
+struct ar9170;
+
+struct carl9170_led {
+	struct ar9170 *ar;
+	struct led_classdev l;
+	char name[32];
+	unsigned int toggled;
+	bool last_state;
+	bool registered;
+};
+#endif /* CONFIG_CARL9170_LEDS */
+
+enum carl9170_restart_reasons {
+	CARL9170_RR_NO_REASON = 0,
+	CARL9170_RR_FATAL_FIRMWARE_ERROR,
+	CARL9170_RR_TOO_MANY_FIRMWARE_ERRORS,
+	CARL9170_RR_WATCHDOG,
+	CARL9170_RR_STUCK_TX,
+	CARL9170_RR_SLOW_SYSTEM,
+	CARL9170_RR_COMMAND_TIMEOUT,
+	CARL9170_RR_TOO_MANY_PHY_ERRORS,
+	CARL9170_RR_LOST_RSP,
+	CARL9170_RR_INVALID_RSP,
+	CARL9170_RR_USER_REQUEST,
+
+	__CARL9170_RR_LAST,
+};
+
+enum carl9170_erp_modes {
+	CARL9170_ERP_INVALID,
+	CARL9170_ERP_AUTO,
+	CARL9170_ERP_MAC80211,
+	CARL9170_ERP_OFF,
+	CARL9170_ERP_CTS,
+	CARL9170_ERP_RTS,
+	__CARL9170_ERP_NUM,
+};
+
+struct ar9170 {
+	struct ath_common common;
+	struct ieee80211_hw *hw;
+	struct mutex mutex;
+	enum carl9170_device_state state;
+	spinlock_t state_lock;
+	enum carl9170_restart_reasons last_reason;
+	bool registered;
+
+	/* USB */
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct usb_anchor rx_anch;
+	struct usb_anchor rx_work;
+	struct usb_anchor rx_pool;
+	struct usb_anchor tx_wait;
+	struct usb_anchor tx_anch;
+	struct usb_anchor tx_cmd;
+	struct usb_anchor tx_err;
+	struct tasklet_struct usb_tasklet;
+	atomic_t tx_cmd_urbs;
+	atomic_t tx_anch_urbs;
+	atomic_t rx_anch_urbs;
+	atomic_t rx_work_urbs;
+	atomic_t rx_pool_urbs;
+	kernel_ulong_t features;
+
+	/* firmware settings */
+	struct completion fw_load_wait;
+	struct completion fw_boot_wait;
+	struct {
+		const struct carl9170fw_desc_head *desc;
+		const struct firmware *fw;
+		unsigned int offset;
+		unsigned int address;
+		unsigned int cmd_bufs;
+		unsigned int api_version;
+		unsigned int vif_num;
+		unsigned int err_counter;
+		unsigned int bug_counter;
+		u32 beacon_addr;
+		unsigned int beacon_max_len;
+		bool rx_stream;
+		bool tx_stream;
+		bool rx_filter;
+		unsigned int mem_blocks;
+		unsigned int mem_block_size;
+		unsigned int rx_size;
+	} fw;
+
+	/* reset / stuck frames/queue detection */
+	struct work_struct restart_work;
+	unsigned int restart_counter;
+	unsigned long queue_stop_timeout[__AR9170_NUM_TXQ];
+	unsigned long max_queue_stop_timeout[__AR9170_NUM_TXQ];
+	bool needs_full_reset;
+	atomic_t pending_restarts;
+
+	/* interface mode settings */
+	struct list_head vif_list;
+	unsigned long vif_bitmap;
+	unsigned int vifs;
+	struct carl9170_vif vif_priv[AR9170_MAX_VIRTUAL_MAC];
+
+	/* beaconing */
+	spinlock_t beacon_lock;
+	unsigned int global_pretbtt;
+	unsigned int global_beacon_int;
+	struct carl9170_vif_info *beacon_iter;
+	unsigned int beacon_enabled;
+
+	/* cryptographic engine */
+	u64 usedkeys;
+	bool rx_software_decryption;
+	bool disable_offload;
+
+	/* filter settings */
+	u64 cur_mc_hash;
+	u32 cur_filter;
+	unsigned int filter_state;
+	unsigned int rx_filter_caps;
+	bool sniffer_enabled;
+
+	/* MAC */
+	enum carl9170_erp_modes erp_mode;
+
+	/* PHY */
+	struct ieee80211_channel *channel;
+	int noise[4];
+	unsigned int chan_fail;
+	unsigned int total_chan_fail;
+	u8 heavy_clip;
+	u8 ht_settings;
+
+	/* power calibration data */
+	u8 power_5G_leg[4];
+	u8 power_2G_cck[4];
+	u8 power_2G_ofdm[4];
+	u8 power_5G_ht20[8];
+	u8 power_5G_ht40[8];
+	u8 power_2G_ht20[8];
+	u8 power_2G_ht40[8];
+
+#ifdef CONFIG_CARL9170_LEDS
+	/* LED */
+	struct delayed_work led_work;
+	struct carl9170_led leds[AR9170_NUM_LEDS];
+#endif /* CONFIG_CARL9170_LEDS */
+
+	/* qos queue settings */
+	spinlock_t tx_stats_lock;
+	struct carl9170_tx_queue_stats tx_stats[__AR9170_NUM_TXQ];
+	struct ieee80211_tx_queue_params edcf[5];
+	struct completion tx_flush;
+
+	/* CMD */
+	int cmd_seq;
+	int readlen;
+	u8 *readbuf;
+	spinlock_t cmd_lock;
+	struct completion cmd_wait;
+	union {
+		__le32 cmd_buf[PAYLOAD_MAX + 1];
+		struct carl9170_cmd cmd;
+		struct carl9170_rsp rsp;
+	};
+
+	/* statistics */
+	unsigned int tx_dropped;
+	unsigned int tx_ack_failures;
+	unsigned int tx_fcs_errors;
+	unsigned int rx_dropped;
+
+	/* EEPROM */
+	struct ar9170_eeprom eeprom;
+
+	/* tx queuing */
+	struct sk_buff_head tx_pending[__AR9170_NUM_TXQ];
+	struct sk_buff_head tx_status[__AR9170_NUM_TXQ];
+	struct delayed_work tx_janitor;
+	unsigned long tx_janitor_last_run;
+	bool tx_schedule;
+
+	/* tx ampdu */
+	struct work_struct ampdu_work;
+	spinlock_t tx_ampdu_list_lock;
+	struct carl9170_sta_tid *tx_ampdu_iter;
+	struct list_head tx_ampdu_list;
+	atomic_t tx_ampdu_upload;
+	atomic_t tx_ampdu_scheduler;
+	atomic_t tx_total_pending;
+	atomic_t tx_total_queued;
+	unsigned int tx_ampdu_list_len;
+	int current_density;
+	int current_factor;
+	bool tx_ampdu_schedule;
+
+	/* internal memory management */
+	spinlock_t mem_lock;
+	unsigned long *mem_bitmap;
+	atomic_t mem_free_blocks;
+	atomic_t mem_allocs;
+
+	/* rxstream mpdu merge */
+	struct ar9170_rx_head rx_plcp;
+	bool rx_has_plcp;
+	struct sk_buff *rx_failover;
+	int rx_failover_missing;
+
+#ifdef CONFIG_CARL9170_WPC
+	struct {
+		bool pbc_state;
+		struct input_dev *pbc;
+		char name[32];
+		char phys[32];
+	} wps;
+#endif /* CONFIG_CARL9170_WPC */
+
+#ifdef CONFIG_CARL9170_DEBUGFS
+	struct carl9170_debug debug;
+	struct dentry *debug_dir;
+#endif /* CONFIG_CARL9170_DEBUGFS */
+
+	/* PSM */
+	struct work_struct ps_work;
+	struct {
+		unsigned int dtim_counter;
+		unsigned long last_beacon;
+		unsigned long last_action;
+		unsigned long last_slept;
+		unsigned int sleep_ms;
+		unsigned int off_override;
+		bool state;
+	} ps;
+};
+
+enum carl9170_ps_off_override_reasons {
+	PS_OFF_VIF	= BIT(0),
+	PS_OFF_BCN	= BIT(1),
+	PS_OFF_5GHZ	= BIT(2),
+};
+
+struct carl9170_ba_stats {
+	u8 ampdu_len;
+	u8 ampdu_ack_len;
+	bool clear;
+};
+
+struct carl9170_sta_info {
+	bool ht_sta;
+	unsigned int ampdu_max_len;
+	struct carl9170_sta_tid *agg[CARL9170_NUM_TID];
+	struct carl9170_ba_stats stats[CARL9170_NUM_TID];
+};
+
+struct carl9170_tx_info {
+	unsigned long timeout;
+	struct ar9170 *ar;
+	struct kref ref;
+};
+
+#define CHK_DEV_STATE(a, s)	(((struct ar9170 *)a)->state >= (s))
+#define IS_INITIALIZED(a)	(CHK_DEV_STATE(a, CARL9170_STOPPED))
+#define IS_ACCEPTING_CMD(a)	(CHK_DEV_STATE(a, CARL9170_IDLE))
+#define IS_STARTED(a)		(CHK_DEV_STATE(a, CARL9170_STARTED))
+
+static inline void __carl9170_set_state(struct ar9170 *ar,
+	enum carl9170_device_state newstate)
+{
+	ar->state = newstate;
+}
+
+static inline void carl9170_set_state(struct ar9170 *ar,
+	enum carl9170_device_state newstate)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar->state_lock, flags);
+	__carl9170_set_state(ar, newstate);
+	spin_unlock_irqrestore(&ar->state_lock, flags);
+}
+
+static inline void carl9170_set_state_when(struct ar9170 *ar,
+	enum carl9170_device_state min, enum carl9170_device_state newstate)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ar->state_lock, flags);
+	if (CHK_DEV_STATE(ar, min))
+		__carl9170_set_state(ar, newstate);
+	spin_unlock_irqrestore(&ar->state_lock, flags);
+}
+
+/* exported interface */
+void *carl9170_alloc(size_t priv_size);
+int carl9170_register(struct ar9170 *ar);
+void carl9170_unregister(struct ar9170 *ar);
+void carl9170_free(struct ar9170 *ar);
+void carl9170_restart(struct ar9170 *ar, const enum carl9170_restart_reasons r);
+void carl9170_ps_check(struct ar9170 *ar);
+
+/* USB back-end */
+int carl9170_usb_open(struct ar9170 *ar);
+void carl9170_usb_stop(struct ar9170 *ar);
+void carl9170_usb_tx(struct ar9170 *ar, struct sk_buff *skb);
+void carl9170_usb_handle_tx_err(struct ar9170 *ar);
+int carl9170_exec_cmd(struct ar9170 *ar, const enum carl9170_cmd_oids,
+		      u32 plen, void *payload, u32 rlen, void *resp);
+int __carl9170_exec_cmd(struct ar9170 *ar, struct carl9170_cmd *cmd,
+			const bool free_buf);
+int carl9170_usb_restart(struct ar9170 *ar);
+void carl9170_usb_reset(struct ar9170 *ar);
+
+/* MAC */
+int carl9170_init_mac(struct ar9170 *ar);
+int carl9170_set_qos(struct ar9170 *ar);
+int carl9170_update_multicast(struct ar9170 *ar, const u64 mc_hast);
+int carl9170_mod_virtual_mac(struct ar9170 *ar, const unsigned int id,
+			     const u8 *mac);
+int carl9170_set_operating_mode(struct ar9170 *ar);
+int carl9170_set_beacon_timers(struct ar9170 *ar);
+int carl9170_set_dyn_sifs_ack(struct ar9170 *ar);
+int carl9170_set_rts_cts_rate(struct ar9170 *ar);
+int carl9170_set_ampdu_settings(struct ar9170 *ar);
+int carl9170_set_slot_time(struct ar9170 *ar);
+int carl9170_set_mac_rates(struct ar9170 *ar);
+int carl9170_set_hwretry_limit(struct ar9170 *ar, const u32 max_retry);
+int carl9170_update_beacon(struct ar9170 *ar, const bool submit);
+int carl9170_upload_key(struct ar9170 *ar, const u8 id, const u8 *mac,
+	const u8 ktype, const u8 keyidx, const u8 *keydata, const int keylen);
+int carl9170_disable_key(struct ar9170 *ar, const u8 id);
+
+/* RX */
+void carl9170_rx(struct ar9170 *ar, void *buf, unsigned int len);
+void carl9170_handle_command_response(struct ar9170 *ar, void *buf, u32 len);
+
+/* TX */
+int carl9170_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb);
+void carl9170_tx_janitor(struct work_struct *work);
+void carl9170_tx_process_status(struct ar9170 *ar,
+				const struct carl9170_rsp *cmd);
+void carl9170_tx_status(struct ar9170 *ar, struct sk_buff *skb,
+			const bool success);
+void carl9170_tx_callback(struct ar9170 *ar, struct sk_buff *skb);
+void carl9170_tx_drop(struct ar9170 *ar, struct sk_buff *skb);
+void carl9170_tx_scheduler(struct ar9170 *ar);
+void carl9170_tx_get_skb(struct sk_buff *skb);
+int carl9170_tx_put_skb(struct sk_buff *skb);
+
+/* LEDs */
+#ifdef CONFIG_CARL9170_LEDS
+int carl9170_led_register(struct ar9170 *ar);
+void carl9170_led_unregister(struct ar9170 *ar);
+#endif /* CONFIG_CARL9170_LEDS */
+int carl9170_led_init(struct ar9170 *ar);
+int carl9170_led_set_state(struct ar9170 *ar, const u32 led_state);
+
+/* PHY / RF */
+int carl9170_set_channel(struct ar9170 *ar, struct ieee80211_channel *channel,
+	enum nl80211_channel_type bw, enum carl9170_rf_init_mode rfi);
+int carl9170_get_noisefloor(struct ar9170 *ar);
+
+/* FW */
+int carl9170_parse_firmware(struct ar9170 *ar);
+int carl9170_fw_fix_eeprom(struct ar9170 *ar);
+
+extern struct ieee80211_rate __carl9170_ratetable[];
+extern int modparam_noht;
+
+static inline struct ar9170 *carl9170_get_priv(struct carl9170_vif *carl_vif)
+{
+	return container_of(carl_vif, struct ar9170,
+			    vif_priv[carl_vif->id]);
+}
+
+static inline struct ieee80211_hdr *carl9170_get_hdr(struct sk_buff *skb)
+{
+	return (void *)((struct _carl9170_tx_superframe *)
+		skb->data)->frame_data;
+}
+
+static inline u16 get_seq_h(struct ieee80211_hdr *hdr)
+{
+	return le16_to_cpu(hdr->seq_ctrl) >> 4;
+}
+
+static inline u16 carl9170_get_seq(struct sk_buff *skb)
+{
+	return get_seq_h(carl9170_get_hdr(skb));
+}
+
+static inline u16 get_tid_h(struct ieee80211_hdr *hdr)
+{
+	return (ieee80211_get_qos_ctl(hdr))[0] & IEEE80211_QOS_CTL_TID_MASK;
+}
+
+static inline u16 carl9170_get_tid(struct sk_buff *skb)
+{
+	return get_tid_h(carl9170_get_hdr(skb));
+}
+
+static inline struct ieee80211_vif *
+carl9170_get_vif(struct carl9170_vif_info *priv)
+{
+	return container_of((void *)priv, struct ieee80211_vif, drv_priv);
+}
+
+/* Protected by ar->mutex or RCU */
+static inline struct ieee80211_vif *carl9170_get_main_vif(struct ar9170 *ar)
+{
+	struct carl9170_vif_info *cvif;
+
+	list_for_each_entry_rcu(cvif, &ar->vif_list, list) {
+		if (cvif->active)
+			return carl9170_get_vif(cvif);
+	}
+
+	return NULL;
+}
+
+static inline bool is_main_vif(struct ar9170 *ar, struct ieee80211_vif *vif)
+{
+	bool ret;
+
+	rcu_read_lock();
+	ret = (carl9170_get_main_vif(ar) == vif);
+	rcu_read_unlock();
+	return ret;
+}
+
+#endif /* __CARL9170_H */
diff --git a/drivers/net/wireless/ath/carl9170/cmd.c b/drivers/net/wireless/ath/carl9170/cmd.c
new file mode 100644
index 0000000..c21f336
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/cmd.c
@@ -0,0 +1,188 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * Basic HW register/memory/command access functions
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "carl9170.h"
+#include "cmd.h"
+
+int carl9170_write_reg(struct ar9170 *ar, const u32 reg, const u32 val)
+{
+	__le32 buf[2] = {
+		cpu_to_le32(reg),
+		cpu_to_le32(val),
+	};
+	int err;
+
+	err = carl9170_exec_cmd(ar, CARL9170_CMD_WREG, sizeof(buf),
+				(u8 *) buf, 0, NULL);
+	if (err) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "writing reg %#x "
+				"(val %#x) failed (%d)\n", reg, val, err);
+		}
+	}
+	return err;
+}
+
+int carl9170_read_mreg(struct ar9170 *ar, const int nregs,
+		       const u32 *regs, u32 *out)
+{
+	int i, err;
+	__le32 *offs, *res;
+
+	/* abuse "out" for the register offsets, must be same length */
+	offs = (__le32 *)out;
+	for (i = 0; i < nregs; i++)
+		offs[i] = cpu_to_le32(regs[i]);
+
+	/* also use the same buffer for the input */
+	res = (__le32 *)out;
+
+	err = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,
+				4 * nregs, (u8 *)offs,
+				4 * nregs, (u8 *)res);
+	if (err) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "reading regs failed (%d)\n",
+				  err);
+		}
+		return err;
+	}
+
+	/* convert result to cpu endian */
+	for (i = 0; i < nregs; i++)
+		out[i] = le32_to_cpu(res[i]);
+
+	return 0;
+}
+
+int carl9170_read_reg(struct ar9170 *ar, u32 reg, u32 *val)
+{
+	return carl9170_read_mreg(ar, 1, &reg, val);
+}
+
+int carl9170_echo_test(struct ar9170 *ar, const u32 v)
+{
+	u32 echores;
+	int err;
+
+	err = carl9170_exec_cmd(ar, CARL9170_CMD_ECHO,
+				4, (u8 *)&v,
+				4, (u8 *)&echores);
+	if (err)
+		return err;
+
+	if (v != echores) {
+		wiphy_info(ar->hw->wiphy, "wrong echo %x != %x", v, echores);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct carl9170_cmd *carl9170_cmd_buf(struct ar9170 *ar,
+	const enum carl9170_cmd_oids cmd, const unsigned int len)
+{
+	struct carl9170_cmd *tmp;
+
+	tmp = kzalloc(sizeof(struct carl9170_cmd_head) + len, GFP_ATOMIC);
+	if (tmp) {
+		tmp->hdr.cmd = cmd;
+		tmp->hdr.len = len;
+	}
+
+	return tmp;
+}
+
+int carl9170_reboot(struct ar9170 *ar)
+{
+	struct carl9170_cmd *cmd;
+	int err;
+
+	cmd = carl9170_cmd_buf(ar, CARL9170_CMD_REBOOT_ASYNC, 0);
+	if (!cmd)
+		return -ENOMEM;
+
+	err = __carl9170_exec_cmd(ar, (struct carl9170_cmd *)cmd, true);
+	return err;
+}
+
+int carl9170_mac_reset(struct ar9170 *ar)
+{
+	return carl9170_exec_cmd(ar, CARL9170_CMD_SWRST,
+				 0, NULL, 0, NULL);
+}
+
+int carl9170_bcn_ctrl(struct ar9170 *ar, const unsigned int vif_id,
+		       const u32 mode, const u32 addr, const u32 len)
+{
+	struct carl9170_cmd *cmd;
+
+	cmd = carl9170_cmd_buf(ar, CARL9170_CMD_BCN_CTRL_ASYNC,
+			       sizeof(struct carl9170_bcn_ctrl_cmd));
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->bcn_ctrl.vif_id = cpu_to_le32(vif_id);
+	cmd->bcn_ctrl.mode = cpu_to_le32(mode);
+	cmd->bcn_ctrl.bcn_addr = cpu_to_le32(addr);
+	cmd->bcn_ctrl.bcn_len = cpu_to_le32(len);
+
+	return __carl9170_exec_cmd(ar, cmd, true);
+}
+
+int carl9170_powersave(struct ar9170 *ar, const bool ps)
+{
+	struct carl9170_cmd *cmd;
+	u32 state;
+
+	cmd = carl9170_cmd_buf(ar, CARL9170_CMD_PSM_ASYNC,
+			       sizeof(struct carl9170_psm));
+	if (!cmd)
+		return -ENOMEM;
+
+	if (ps) {
+		/* Sleep until next TBTT */
+		state = CARL9170_PSM_SLEEP | 1;
+	} else {
+		/* wake up immediately */
+		state = 1;
+	}
+
+	cmd->psm.state = cpu_to_le32(state);
+	return __carl9170_exec_cmd(ar, cmd, true);
+}
diff --git a/drivers/net/wireless/ath/carl9170/cmd.h b/drivers/net/wireless/ath/carl9170/cmd.h
new file mode 100644
index 0000000..f78728c
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/cmd.h
@@ -0,0 +1,168 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * Basic HW register/memory/command access functions
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __CMD_H
+#define __CMD_H
+
+#include "carl9170.h"
+
+/* basic HW access */
+int carl9170_write_reg(struct ar9170 *ar, const u32 reg, const u32 val);
+int carl9170_read_reg(struct ar9170 *ar, const u32 reg, u32 *val);
+int carl9170_read_mreg(struct ar9170 *ar, const int nregs,
+		       const u32 *regs, u32 *out);
+int carl9170_echo_test(struct ar9170 *ar, u32 v);
+int carl9170_reboot(struct ar9170 *ar);
+int carl9170_mac_reset(struct ar9170 *ar);
+int carl9170_powersave(struct ar9170 *ar, const bool power_on);
+int carl9170_bcn_ctrl(struct ar9170 *ar, const unsigned int vif_id,
+		       const u32 mode, const u32 addr, const u32 len);
+
+static inline int carl9170_flush_cab(struct ar9170 *ar,
+				     const unsigned int vif_id)
+{
+	return carl9170_bcn_ctrl(ar, vif_id, CARL9170_BCN_CTRL_DRAIN, 0, 0);
+}
+
+static inline int carl9170_rx_filter(struct ar9170 *ar,
+				     const unsigned int _rx_filter)
+{
+	__le32 rx_filter = cpu_to_le32(_rx_filter);
+
+	return carl9170_exec_cmd(ar, CARL9170_CMD_RX_FILTER,
+				sizeof(rx_filter), (u8 *)&rx_filter,
+				0, NULL);
+}
+
+struct carl9170_cmd *carl9170_cmd_buf(struct ar9170 *ar,
+	const enum carl9170_cmd_oids cmd, const unsigned int len);
+
+/*
+ * Macros to facilitate writing multiple registers in a single
+ * write-combining USB command. Note that when the first group
+ * fails the whole thing will fail without any others attempted,
+ * but you won't know which write in the group failed.
+ */
+#define carl9170_regwrite_begin(ar)					\
+do {									\
+	int __nreg = 0, __err = 0;					\
+	struct ar9170 *__ar = ar;
+
+#define carl9170_regwrite(r, v) do {					\
+	__ar->cmd_buf[2 * __nreg + 1] = cpu_to_le32(r);			\
+	__ar->cmd_buf[2 * __nreg + 2] = cpu_to_le32(v);			\
+	__nreg++;							\
+	if ((__nreg >= PAYLOAD_MAX/2)) {				\
+		if (IS_ACCEPTING_CMD(__ar))				\
+			__err = carl9170_exec_cmd(__ar,			\
+				CARL9170_CMD_WREG, 8 * __nreg,		\
+				(u8 *) &__ar->cmd_buf[1], 0, NULL);	\
+		else							\
+			goto __regwrite_out;				\
+									\
+		__nreg = 0;						\
+		if (__err)						\
+			goto __regwrite_out;				\
+	}								\
+} while (0)
+
+#define carl9170_regwrite_finish()					\
+__regwrite_out :							\
+	if (__err == 0 && __nreg) {					\
+		if (IS_ACCEPTING_CMD(__ar))				\
+			__err = carl9170_exec_cmd(__ar,			\
+				CARL9170_CMD_WREG, 8 * __nreg,		\
+				(u8 *) &__ar->cmd_buf[1], 0, NULL);	\
+		__nreg = 0;						\
+	}
+
+#define carl9170_regwrite_result()					\
+	__err;								\
+} while (0);
+
+
+#define carl9170_async_get_buf()					\
+do {									\
+	__cmd = carl9170_cmd_buf(__carl, CARL9170_CMD_WREG_ASYNC,	\
+				 CARL9170_MAX_CMD_PAYLOAD_LEN);		\
+	if (__cmd == NULL) {						\
+		__err = -ENOMEM;					\
+		goto __async_regwrite_out;				\
+	}								\
+} while (0);
+
+#define carl9170_async_regwrite_begin(carl)				\
+do {									\
+	int __nreg = 0, __err = 0;					\
+	struct ar9170 *__carl = carl;					\
+	struct carl9170_cmd *__cmd;					\
+	carl9170_async_get_buf();					\
+
+#define carl9170_async_regwrite(r, v) do {				\
+	__cmd->wreg.regs[__nreg].addr = cpu_to_le32(r);			\
+	__cmd->wreg.regs[__nreg].val = cpu_to_le32(v);			\
+	__nreg++;							\
+	if ((__nreg >= PAYLOAD_MAX/2)) {				\
+		if (IS_ACCEPTING_CMD(__carl)) {				\
+			__cmd->hdr.len = 8 * __nreg;			\
+			__err = __carl9170_exec_cmd(__carl, __cmd, true);\
+			__cmd = NULL;					\
+			carl9170_async_get_buf();			\
+		} else {						\
+			goto __async_regwrite_out;			\
+		}							\
+		__nreg = 0;						\
+		if (__err)						\
+			goto __async_regwrite_out;			\
+	}								\
+} while (0)
+
+#define carl9170_async_regwrite_finish()				\
+__async_regwrite_out :							\
+	if (__err == 0 && __nreg) {					\
+		__cmd->hdr.len = 8 * __nreg;				\
+		if (IS_ACCEPTING_CMD(__carl))				\
+			__err = __carl9170_exec_cmd(__carl, __cmd, true);\
+		__nreg = 0;						\
+	}
+
+#define carl9170_async_regwrite_result()				\
+	__err;								\
+} while (0);
+
+#endif /* __CMD_H */
diff --git a/drivers/net/wireless/ath/carl9170/debug.c b/drivers/net/wireless/ath/carl9170/debug.c
new file mode 100644
index 0000000..0ac1124
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/debug.c
@@ -0,0 +1,902 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * debug(fs) probing
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2008-2009 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/vmalloc.h>
+#include "carl9170.h"
+#include "cmd.h"
+
+#define ADD(buf, off, max, fmt, args...)				\
+	off += snprintf(&buf[off], max - off, fmt, ##args);
+
+static int carl9170_debugfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+struct carl9170_debugfs_fops {
+	unsigned int read_bufsize;
+	mode_t attr;
+	char *(*read)(struct ar9170 *ar, char *buf, size_t bufsize,
+		      ssize_t *len);
+	ssize_t (*write)(struct ar9170 *aru, const char *buf, size_t size);
+	const struct file_operations fops;
+
+	enum carl9170_device_state req_dev_state;
+};
+
+static ssize_t carl9170_debugfs_read(struct file *file, char __user *userbuf,
+				     size_t count, loff_t *ppos)
+{
+	struct carl9170_debugfs_fops *dfops;
+	struct ar9170 *ar;
+	char *buf = NULL, *res_buf = NULL;
+	ssize_t ret = 0;
+	int err = 0;
+
+	if (!count)
+		return 0;
+
+	ar = file->private_data;
+
+	if (!ar)
+		return -ENODEV;
+	dfops = container_of(file->f_op, struct carl9170_debugfs_fops, fops);
+
+	if (!dfops->read)
+		return -ENOSYS;
+
+	if (dfops->read_bufsize) {
+		buf = vmalloc(dfops->read_bufsize);
+		if (!buf)
+			return -ENOMEM;
+	}
+
+	mutex_lock(&ar->mutex);
+	if (!CHK_DEV_STATE(ar, dfops->req_dev_state)) {
+		err = -ENODEV;
+		res_buf = buf;
+		goto out_free;
+	}
+
+	res_buf = dfops->read(ar, buf, dfops->read_bufsize, &ret);
+
+	if (ret > 0)
+		err = simple_read_from_buffer(userbuf, count, ppos,
+					      res_buf, ret);
+	else
+		err = ret;
+
+	WARN_ON_ONCE(dfops->read_bufsize && (res_buf != buf));
+
+out_free:
+	vfree(res_buf);
+	mutex_unlock(&ar->mutex);
+	return err;
+}
+
+static ssize_t carl9170_debugfs_write(struct file *file,
+	const char __user *userbuf, size_t count, loff_t *ppos)
+{
+	struct carl9170_debugfs_fops *dfops;
+	struct ar9170 *ar;
+	char *buf = NULL;
+	int err = 0;
+
+	if (!count)
+		return 0;
+
+	if (count > PAGE_SIZE)
+		return -E2BIG;
+
+	ar = file->private_data;
+
+	if (!ar)
+		return -ENODEV;
+	dfops = container_of(file->f_op, struct carl9170_debugfs_fops, fops);
+
+	if (!dfops->write)
+		return -ENOSYS;
+
+	buf = vmalloc(count);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, userbuf, count)) {
+		err = -EFAULT;
+		goto out_free;
+	}
+
+	if (mutex_trylock(&ar->mutex) == 0) {
+		err = -EAGAIN;
+		goto out_free;
+	}
+
+	if (!CHK_DEV_STATE(ar, dfops->req_dev_state)) {
+		err = -ENODEV;
+		goto out_unlock;
+	}
+
+	err = dfops->write(ar, buf, count);
+	if (err)
+		goto out_unlock;
+
+out_unlock:
+	mutex_unlock(&ar->mutex);
+
+out_free:
+	vfree(buf);
+	return err;
+}
+
+#define __DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,	\
+			       _attr, _dstate)				\
+static const struct carl9170_debugfs_fops carl_debugfs_##name ##_ops = {\
+	.read_bufsize = _read_bufsize,					\
+	.read = _read,							\
+	.write = _write,						\
+	.attr = _attr,							\
+	.req_dev_state = _dstate,					\
+	.fops = {							\
+		.open	= carl9170_debugfs_open,			\
+		.read	= carl9170_debugfs_read,			\
+		.write	= carl9170_debugfs_write,			\
+		.owner	= THIS_MODULE					\
+	},								\
+}
+
+#define DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize, _attr)	\
+	__DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,	\
+			       _attr, CARL9170_STARTED)			\
+
+#define DEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)			\
+	DEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,	\
+			     NULL, _read_bufsize, S_IRUSR)
+
+#define DEBUGFS_DECLARE_WO_FILE(name)					\
+	DEBUGFS_DECLARE_FILE(name, NULL, carl9170_debugfs_##name ##_write,\
+			     0, S_IWUSR)
+
+#define DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize)			\
+	DEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,	\
+			     carl9170_debugfs_##name ##_write,		\
+			     _read_bufsize, S_IRUSR | S_IWUSR)
+
+#define __DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize, _dstate)		\
+	__DEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,	\
+			     carl9170_debugfs_##name ##_write,		\
+			     _read_bufsize, S_IRUSR | S_IWUSR, _dstate)
+
+#define DEBUGFS_READONLY_FILE(name, _read_bufsize, fmt, value...)	\
+static char *carl9170_debugfs_ ##name ## _read(struct ar9170 *ar,	\
+					     char *buf, size_t buf_size,\
+					     ssize_t *len)		\
+{									\
+	ADD(buf, *len, buf_size, fmt "\n", ##value);			\
+	return buf;							\
+}									\
+DEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)
+
+static char *carl9170_debugfs_mem_usage_read(struct ar9170 *ar, char *buf,
+					     size_t bufsize, ssize_t *len)
+{
+	ADD(buf, *len, bufsize, "jar: [");
+
+	spin_lock_bh(&ar->mem_lock);
+
+	*len += bitmap_scnprintf(&buf[*len], bufsize - *len,
+				  ar->mem_bitmap, ar->fw.mem_blocks);
+
+	ADD(buf, *len, bufsize, "]\n");
+
+	ADD(buf, *len, bufsize, "cookies: used:%3d / total:%3d, allocs:%d\n",
+	    bitmap_weight(ar->mem_bitmap, ar->fw.mem_blocks),
+	    ar->fw.mem_blocks, atomic_read(&ar->mem_allocs));
+
+	ADD(buf, *len, bufsize, "memory: free:%3d (%3d KiB) / total:%3d KiB)\n",
+	    atomic_read(&ar->mem_free_blocks),
+	    (atomic_read(&ar->mem_free_blocks) * ar->fw.mem_block_size) / 1024,
+	    (ar->fw.mem_blocks * ar->fw.mem_block_size) / 1024);
+
+	spin_unlock_bh(&ar->mem_lock);
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(mem_usage, 512);
+
+static char *carl9170_debugfs_qos_stat_read(struct ar9170 *ar, char *buf,
+					    size_t bufsize, ssize_t *len)
+{
+	ADD(buf, *len, bufsize, "%s QoS AC\n", modparam_noht ? "Hardware" :
+	    "Software");
+
+	ADD(buf, *len, bufsize, "[     VO            VI       "
+				 "     BE            BK      ]\n");
+
+	spin_lock_bh(&ar->tx_stats_lock);
+	ADD(buf, *len, bufsize, "[length/limit  length/limit  "
+				 "length/limit  length/limit ]\n"
+				"[   %3d/%3d       %3d/%3d    "
+				 "   %3d/%3d       %3d/%3d   ]\n\n",
+	    ar->tx_stats[0].len, ar->tx_stats[0].limit,
+	    ar->tx_stats[1].len, ar->tx_stats[1].limit,
+	    ar->tx_stats[2].len, ar->tx_stats[2].limit,
+	    ar->tx_stats[3].len, ar->tx_stats[3].limit);
+
+	ADD(buf, *len, bufsize, "[    total         total     "
+				 "    total         total    ]\n"
+				"[%10d    %10d    %10d    %10d   ]\n\n",
+	    ar->tx_stats[0].count, ar->tx_stats[1].count,
+	    ar->tx_stats[2].count, ar->tx_stats[3].count);
+
+	spin_unlock_bh(&ar->tx_stats_lock);
+
+	ADD(buf, *len, bufsize, "[  pend/waittx   pend/waittx "
+				 "  pend/waittx   pend/waittx]\n"
+				"[   %3d/%3d       %3d/%3d    "
+				 "   %3d/%3d       %3d/%3d   ]\n\n",
+	    skb_queue_len(&ar->tx_pending[0]),
+	    skb_queue_len(&ar->tx_status[0]),
+	    skb_queue_len(&ar->tx_pending[1]),
+	    skb_queue_len(&ar->tx_status[1]),
+	    skb_queue_len(&ar->tx_pending[2]),
+	    skb_queue_len(&ar->tx_status[2]),
+	    skb_queue_len(&ar->tx_pending[3]),
+	    skb_queue_len(&ar->tx_status[3]));
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(qos_stat, 512);
+
+static void carl9170_debugfs_format_frame(struct ar9170 *ar,
+	struct sk_buff *skb, const char *prefix, char *buf,
+	ssize_t *off, ssize_t bufsize)
+{
+	struct _carl9170_tx_superframe *txc = (void *) skb->data;
+	struct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);
+	struct carl9170_tx_info *arinfo = (void *) txinfo->rate_driver_data;
+	struct ieee80211_hdr *hdr = (void *) txc->frame_data;
+
+	ADD(buf, *off, bufsize, "%s %p, c:%2x, DA:%pM, sq:%4d, mc:%.4x, "
+	    "pc:%.8x, to:%d ms\n", prefix, skb, txc->s.cookie,
+	    ieee80211_get_DA(hdr), get_seq_h(hdr),
+	    le16_to_cpu(txc->f.mac_control), le32_to_cpu(txc->f.phy_control),
+	    jiffies_to_msecs(jiffies - arinfo->timeout));
+}
+
+
+static char *carl9170_debugfs_ampdu_state_read(struct ar9170 *ar, char *buf,
+					       size_t bufsize, ssize_t *len)
+{
+	struct carl9170_sta_tid *iter;
+	struct sk_buff *skb;
+	int cnt = 0, fc;
+	int offset;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(iter, &ar->tx_ampdu_list, list) {
+
+		spin_lock_bh(&iter->lock);
+		ADD(buf, *len, bufsize, "Entry: #%2d TID:%1d, BSN:%4d, "
+		    "SNX:%4d, HSN:%4d, BAW:%2d, state:%1d, toggles:%d\n",
+		    cnt, iter->tid, iter->bsn, iter->snx, iter->hsn,
+		    iter->max, iter->state, iter->counter);
+
+		ADD(buf, *len, bufsize, "\tWindow:  [");
+
+		*len += bitmap_scnprintf(&buf[*len], bufsize - *len,
+			iter->bitmap, CARL9170_BAW_BITS);
+
+#define BM_STR_OFF(offset)					\
+	((CARL9170_BAW_BITS - (offset) - 1) / 4 +		\
+	 (CARL9170_BAW_BITS - (offset) - 1) / 32 + 1)
+
+		ADD(buf, *len, bufsize, ",W]\n");
+
+		offset = BM_STR_OFF(0);
+		ADD(buf, *len, bufsize, "\tBase Seq: %*s\n", offset, "T");
+
+		offset = BM_STR_OFF(SEQ_DIFF(iter->snx, iter->bsn));
+		ADD(buf, *len, bufsize, "\tNext Seq: %*s\n", offset, "W");
+
+		offset = BM_STR_OFF(((int)iter->hsn - (int)iter->bsn) %
+				     CARL9170_BAW_BITS);
+		ADD(buf, *len, bufsize, "\tLast Seq: %*s\n", offset, "N");
+
+		ADD(buf, *len, bufsize, "\tPre-Aggregation reorder buffer: "
+		    " currently queued:%d\n", skb_queue_len(&iter->queue));
+
+		fc = 0;
+		skb_queue_walk(&iter->queue, skb) {
+			char prefix[32];
+
+			snprintf(prefix, sizeof(prefix), "\t\t%3d :", fc);
+			carl9170_debugfs_format_frame(ar, skb, prefix, buf,
+						      len, bufsize);
+
+			fc++;
+		}
+		spin_unlock_bh(&iter->lock);
+		cnt++;
+	}
+	rcu_read_unlock();
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(ampdu_state, 8000);
+
+static void carl9170_debugfs_queue_dump(struct ar9170 *ar, char *buf,
+	ssize_t *len, size_t bufsize, struct sk_buff_head *queue)
+{
+	struct sk_buff *skb;
+	char prefix[16];
+	int fc = 0;
+
+	spin_lock_bh(&queue->lock);
+	skb_queue_walk(queue, skb) {
+		snprintf(prefix, sizeof(prefix), "%3d :", fc);
+		carl9170_debugfs_format_frame(ar, skb, prefix, buf,
+					      len, bufsize);
+		fc++;
+	}
+	spin_unlock_bh(&queue->lock);
+}
+
+#define DEBUGFS_QUEUE_DUMP(q, qi)					\
+static char *carl9170_debugfs_##q ##_##qi ##_read(struct ar9170 *ar,	\
+	char *buf, size_t bufsize, ssize_t *len)			\
+{									\
+	carl9170_debugfs_queue_dump(ar, buf, len, bufsize, &ar->q[qi]);	\
+	return buf;							\
+}									\
+DEBUGFS_DECLARE_RO_FILE(q##_##qi, 8000);
+
+static char *carl9170_debugfs_sta_psm_read(struct ar9170 *ar, char *buf,
+					   size_t bufsize, ssize_t *len)
+{
+	ADD(buf, *len, bufsize, "psm state: %s\n", (ar->ps.off_override ?
+	    "FORCE CAM" : (ar->ps.state ? "PSM" : "CAM")));
+
+	ADD(buf, *len, bufsize, "sleep duration: %d ms.\n", ar->ps.sleep_ms);
+	ADD(buf, *len, bufsize, "last power-state transition: %d ms ago.\n",
+	    jiffies_to_msecs(jiffies - ar->ps.last_action));
+	ADD(buf, *len, bufsize, "last CAM->PSM transition: %d ms ago.\n",
+	    jiffies_to_msecs(jiffies - ar->ps.last_slept));
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(sta_psm, 160);
+
+static char *carl9170_debugfs_tx_stuck_read(struct ar9170 *ar, char *buf,
+					    size_t bufsize, ssize_t *len)
+{
+	int i;
+
+	for (i = 0; i < ar->hw->queues; i++) {
+		ADD(buf, *len, bufsize, "TX queue [%d]: %10d max:%10d ms.\n",
+		    i, ieee80211_queue_stopped(ar->hw, i) ?
+		    jiffies_to_msecs(jiffies - ar->queue_stop_timeout[i]) : 0,
+		    jiffies_to_msecs(ar->max_queue_stop_timeout[i]));
+
+		ar->max_queue_stop_timeout[i] = 0;
+	}
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(tx_stuck, 180);
+
+static char *carl9170_debugfs_phy_noise_read(struct ar9170 *ar, char *buf,
+					     size_t bufsize, ssize_t *len)
+{
+	int err;
+
+	err = carl9170_get_noisefloor(ar);
+	if (err) {
+		*len = err;
+		return buf;
+	}
+
+	ADD(buf, *len, bufsize, "Chain 0: %10d dBm, ext. chan.:%10d dBm\n",
+	    ar->noise[0], ar->noise[2]);
+	ADD(buf, *len, bufsize, "Chain 2: %10d dBm, ext. chan.:%10d dBm\n",
+	    ar->noise[1], ar->noise[3]);
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(phy_noise, 180);
+
+static char *carl9170_debugfs_vif_dump_read(struct ar9170 *ar, char *buf,
+					    size_t bufsize, ssize_t *len)
+{
+	struct carl9170_vif_info *iter;
+	int i = 0;
+
+	ADD(buf, *len, bufsize, "registered VIFs:%d \\ %d\n",
+	    ar->vifs, ar->fw.vif_num);
+
+	ADD(buf, *len, bufsize, "VIF bitmap: [");
+
+	*len += bitmap_scnprintf(&buf[*len], bufsize - *len,
+				 &ar->vif_bitmap, ar->fw.vif_num);
+
+	ADD(buf, *len, bufsize, "]\n");
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(iter, &ar->vif_list, list) {
+		struct ieee80211_vif *vif = carl9170_get_vif(iter);
+		ADD(buf, *len, bufsize, "\t%d = [%s VIF, id:%d, type:%x "
+		    " mac:%pM %s]\n", i, (carl9170_get_main_vif(ar) == vif ?
+		    "Master" : " Slave"), iter->id, vif->type, vif->addr,
+		    iter->enable_beacon ? "beaconing " : "");
+		i++;
+	}
+	rcu_read_unlock();
+
+	return buf;
+}
+DEBUGFS_DECLARE_RO_FILE(vif_dump, 8000);
+
+#define UPDATE_COUNTER(ar, name)	({				\
+	u32 __tmp[ARRAY_SIZE(name##_regs)];				\
+	unsigned int __i, __err = -ENODEV;				\
+									\
+	for (__i = 0; __i < ARRAY_SIZE(name##_regs); __i++) {		\
+		__tmp[__i] = name##_regs[__i].reg;			\
+		ar->debug.stats.name##_counter[__i] = 0;		\
+	}								\
+									\
+	if (IS_STARTED(ar))						\
+		__err = carl9170_read_mreg(ar, ARRAY_SIZE(name##_regs),	\
+			__tmp, ar->debug.stats.name##_counter);		\
+	(__err); })
+
+#define TALLY_SUM_UP(ar, name)	do {					\
+	unsigned int __i;						\
+									\
+	for (__i = 0; __i < ARRAY_SIZE(name##_regs); __i++) {		\
+		ar->debug.stats.name##_sum[__i] +=			\
+			ar->debug.stats.name##_counter[__i];		\
+	}								\
+} while (0)
+
+#define DEBUGFS_HW_TALLY_FILE(name, f)					\
+static char *carl9170_debugfs_##name ## _read(struct ar9170 *ar,	\
+	 char *dum, size_t bufsize, ssize_t *ret)			\
+{									\
+	char *buf;							\
+	int i, max_len, err;						\
+									\
+	max_len = ARRAY_SIZE(name##_regs) * 80;				\
+	buf = vmalloc(max_len);						\
+	if (!buf)							\
+		return NULL;						\
+									\
+	err = UPDATE_COUNTER(ar, name);					\
+	if (err) {							\
+		*ret = err;						\
+		return buf;						\
+	}								\
+									\
+	TALLY_SUM_UP(ar, name);						\
+									\
+	for (i = 0; i < ARRAY_SIZE(name##_regs); i++) {			\
+		ADD(buf, *ret, max_len, "%22s = %" f "[+%" f "]\n",	\
+		    name##_regs[i].nreg, ar->debug.stats.name ##_sum[i],\
+		    ar->debug.stats.name ##_counter[i]);		\
+	}								\
+									\
+	return buf;							\
+}									\
+DEBUGFS_DECLARE_RO_FILE(name, 0);
+
+#define DEBUGFS_HW_REG_FILE(name, f)					\
+static char *carl9170_debugfs_##name ## _read(struct ar9170 *ar,	\
+	char *dum, size_t bufsize, ssize_t *ret)			\
+{									\
+	char *buf;							\
+	int i, max_len, err;						\
+									\
+	max_len = ARRAY_SIZE(name##_regs) * 80;				\
+	buf = vmalloc(max_len);						\
+	if (!buf)							\
+		return NULL;						\
+									\
+	err = UPDATE_COUNTER(ar, name);					\
+	if (err) {							\
+		*ret = err;						\
+		return buf;						\
+	}								\
+									\
+	for (i = 0; i < ARRAY_SIZE(name##_regs); i++) {			\
+		ADD(buf, *ret, max_len, "%22s = %" f "\n",		\
+		    name##_regs[i].nreg,				\
+		    ar->debug.stats.name##_counter[i]);			\
+	}								\
+									\
+	return buf;							\
+}									\
+DEBUGFS_DECLARE_RO_FILE(name, 0);
+
+static ssize_t carl9170_debugfs_hw_ioread32_write(struct ar9170 *ar,
+	const char *buf, size_t count)
+{
+	int err = 0, i, n = 0, max_len = 32, res;
+	unsigned int reg, tmp;
+
+	if (!count)
+		return 0;
+
+	if (count > max_len)
+		return -E2BIG;
+
+	res = sscanf(buf, "0x%X %d", &reg, &n);
+	if (res < 1) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (res == 1)
+		n = 1;
+
+	if (n > 15) {
+		err = -EMSGSIZE;
+		goto out;
+	}
+
+	if ((reg >= 0x280000) || ((reg + (n << 2)) >= 0x280000)) {
+		err = -EADDRNOTAVAIL;
+		goto out;
+	}
+
+	if (reg & 3) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	for (i = 0; i < n; i++) {
+		err = carl9170_read_reg(ar, reg + (i << 2), &tmp);
+		if (err)
+			goto out;
+
+		ar->debug.ring[ar->debug.ring_tail].reg = reg + (i << 2);
+		ar->debug.ring[ar->debug.ring_tail].value = tmp;
+		ar->debug.ring_tail++;
+		ar->debug.ring_tail %= CARL9170_DEBUG_RING_SIZE;
+	}
+
+out:
+	return err ? err : count;
+}
+
+static char *carl9170_debugfs_hw_ioread32_read(struct ar9170 *ar, char *buf,
+					       size_t bufsize, ssize_t *ret)
+{
+	int i = 0;
+
+	while (ar->debug.ring_head != ar->debug.ring_tail) {
+		ADD(buf, *ret, bufsize, "%.8x = %.8x\n",
+		    ar->debug.ring[ar->debug.ring_head].reg,
+		    ar->debug.ring[ar->debug.ring_head].value);
+
+		ar->debug.ring_head++;
+		ar->debug.ring_head %= CARL9170_DEBUG_RING_SIZE;
+
+		if (i++ == 64)
+			break;
+	}
+	ar->debug.ring_head = ar->debug.ring_tail;
+	return buf;
+}
+DEBUGFS_DECLARE_RW_FILE(hw_ioread32, CARL9170_DEBUG_RING_SIZE * 40);
+
+static ssize_t carl9170_debugfs_bug_write(struct ar9170 *ar, const char *buf,
+					  size_t count)
+{
+	int err;
+
+	if (count < 1)
+		return -EINVAL;
+
+	switch (buf[0]) {
+	case 'F':
+		ar->needs_full_reset = true;
+		break;
+
+	case 'R':
+		if (!IS_STARTED(ar)) {
+			err = -EAGAIN;
+			goto out;
+		}
+
+		ar->needs_full_reset = false;
+		break;
+
+	case 'M':
+		err = carl9170_mac_reset(ar);
+		if (err < 0)
+			count = err;
+
+		goto out;
+
+	case 'P':
+		err = carl9170_set_channel(ar, ar->hw->conf.channel,
+			ar->hw->conf.channel_type, CARL9170_RFI_COLD);
+		if (err < 0)
+			count = err;
+
+		goto out;
+
+	default:
+		return -EINVAL;
+	}
+
+	carl9170_restart(ar, CARL9170_RR_USER_REQUEST);
+
+out:
+	return count;
+}
+
+static char *carl9170_debugfs_bug_read(struct ar9170 *ar, char *buf,
+				       size_t bufsize, ssize_t *ret)
+{
+	ADD(buf, *ret, bufsize, "[P]hy reinit, [R]estart, [F]ull usb reset, "
+	    "[M]ac reset\n");
+	ADD(buf, *ret, bufsize, "firmware restarts:%d, last reason:%d\n",
+		ar->restart_counter, ar->last_reason);
+	ADD(buf, *ret, bufsize, "phy reinit errors:%d (%d)\n",
+		ar->total_chan_fail, ar->chan_fail);
+	ADD(buf, *ret, bufsize, "reported firmware errors:%d\n",
+		ar->fw.err_counter);
+	ADD(buf, *ret, bufsize, "reported firmware BUGs:%d\n",
+		ar->fw.bug_counter);
+	ADD(buf, *ret, bufsize, "pending restart requests:%d\n",
+		atomic_read(&ar->pending_restarts));
+	return buf;
+}
+__DEBUGFS_DECLARE_RW_FILE(bug, 400, CARL9170_STOPPED);
+
+static const char *erp_modes[] = {
+	[CARL9170_ERP_INVALID] = "INVALID",
+	[CARL9170_ERP_AUTO] = "Automatic",
+	[CARL9170_ERP_MAC80211] = "Set by MAC80211",
+	[CARL9170_ERP_OFF] = "Force Off",
+	[CARL9170_ERP_RTS] = "Force RTS",
+	[CARL9170_ERP_CTS] = "Force CTS"
+};
+
+static char *carl9170_debugfs_erp_read(struct ar9170 *ar, char *buf,
+				       size_t bufsize, ssize_t *ret)
+{
+	ADD(buf, *ret, bufsize, "ERP Setting: (%d) -> %s\n", ar->erp_mode,
+	    erp_modes[ar->erp_mode]);
+	return buf;
+}
+
+static ssize_t carl9170_debugfs_erp_write(struct ar9170 *ar, const char *buf,
+					  size_t count)
+{
+	int res, val;
+
+	if (count < 1)
+		return -EINVAL;
+
+	res = sscanf(buf, "%d", &val);
+	if (res != 1)
+		return -EINVAL;
+
+	if (!((val > CARL9170_ERP_INVALID) &&
+	      (val < __CARL9170_ERP_NUM)))
+		return -EINVAL;
+
+	ar->erp_mode = val;
+	return count;
+}
+
+DEBUGFS_DECLARE_RW_FILE(erp, 80);
+
+static ssize_t carl9170_debugfs_hw_iowrite32_write(struct ar9170 *ar,
+	const char *buf, size_t count)
+{
+	int err = 0, max_len = 22, res;
+	u32 reg, val;
+
+	if (!count)
+		return 0;
+
+	if (count > max_len)
+		return -E2BIG;
+
+	res = sscanf(buf, "0x%X 0x%X", &reg, &val);
+	if (res != 2) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (reg <= 0x100000 || reg >= 0x280000) {
+		err = -EADDRNOTAVAIL;
+		goto out;
+	}
+
+	if (reg & 3) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = carl9170_write_reg(ar, reg, val);
+	if (err)
+		goto out;
+
+out:
+	return err ? err : count;
+}
+DEBUGFS_DECLARE_WO_FILE(hw_iowrite32);
+
+DEBUGFS_HW_TALLY_FILE(hw_tx_tally, "u");
+DEBUGFS_HW_TALLY_FILE(hw_rx_tally, "u");
+DEBUGFS_HW_TALLY_FILE(hw_phy_errors, "u");
+DEBUGFS_HW_REG_FILE(hw_wlan_queue, ".8x");
+DEBUGFS_HW_REG_FILE(hw_pta_queue, ".8x");
+DEBUGFS_HW_REG_FILE(hw_ampdu_info, ".8x");
+DEBUGFS_QUEUE_DUMP(tx_status, 0);
+DEBUGFS_QUEUE_DUMP(tx_status, 1);
+DEBUGFS_QUEUE_DUMP(tx_status, 2);
+DEBUGFS_QUEUE_DUMP(tx_status, 3);
+DEBUGFS_QUEUE_DUMP(tx_pending, 0);
+DEBUGFS_QUEUE_DUMP(tx_pending, 1);
+DEBUGFS_QUEUE_DUMP(tx_pending, 2);
+DEBUGFS_QUEUE_DUMP(tx_pending, 3);
+DEBUGFS_READONLY_FILE(usb_tx_anch_urbs, 20, "%d",
+		      atomic_read(&ar->tx_anch_urbs));
+DEBUGFS_READONLY_FILE(usb_rx_anch_urbs, 20, "%d",
+		      atomic_read(&ar->rx_anch_urbs));
+DEBUGFS_READONLY_FILE(usb_rx_work_urbs, 20, "%d",
+		      atomic_read(&ar->rx_work_urbs));
+DEBUGFS_READONLY_FILE(usb_rx_pool_urbs, 20, "%d",
+		      atomic_read(&ar->rx_pool_urbs));
+
+DEBUGFS_READONLY_FILE(tx_total_queued, 20, "%d",
+		      atomic_read(&ar->tx_total_queued));
+DEBUGFS_READONLY_FILE(tx_ampdu_scheduler, 20, "%d",
+		      atomic_read(&ar->tx_ampdu_scheduler));
+
+DEBUGFS_READONLY_FILE(tx_total_pending, 20, "%d",
+		      atomic_read(&ar->tx_total_pending));
+
+DEBUGFS_READONLY_FILE(tx_ampdu_list_len, 20, "%d",
+		      ar->tx_ampdu_list_len);
+
+DEBUGFS_READONLY_FILE(tx_ampdu_upload, 20, "%d",
+		      atomic_read(&ar->tx_ampdu_upload));
+
+DEBUGFS_READONLY_FILE(tx_janitor_last_run, 64, "last run:%d ms ago",
+	jiffies_to_msecs(jiffies - ar->tx_janitor_last_run));
+
+DEBUGFS_READONLY_FILE(tx_dropped, 20, "%d", ar->tx_dropped);
+
+DEBUGFS_READONLY_FILE(rx_dropped, 20, "%d", ar->rx_dropped);
+
+DEBUGFS_READONLY_FILE(sniffer_enabled, 20, "%d", ar->sniffer_enabled);
+DEBUGFS_READONLY_FILE(rx_software_decryption, 20, "%d",
+		      ar->rx_software_decryption);
+DEBUGFS_READONLY_FILE(ampdu_factor, 20, "%d",
+		      ar->current_factor);
+DEBUGFS_READONLY_FILE(ampdu_density, 20, "%d",
+		      ar->current_density);
+
+DEBUGFS_READONLY_FILE(beacon_int, 20, "%d TU", ar->global_beacon_int);
+DEBUGFS_READONLY_FILE(pretbtt, 20, "%d TU", ar->global_pretbtt);
+
+void carl9170_debugfs_register(struct ar9170 *ar)
+{
+	ar->debug_dir = debugfs_create_dir(KBUILD_MODNAME,
+		ar->hw->wiphy->debugfsdir);
+
+#define DEBUGFS_ADD(name)						\
+	debugfs_create_file(#name, carl_debugfs_##name ##_ops.attr,	\
+			    ar->debug_dir, ar,				\
+			    &carl_debugfs_##name ## _ops.fops);
+
+	DEBUGFS_ADD(usb_tx_anch_urbs);
+	DEBUGFS_ADD(usb_rx_pool_urbs);
+	DEBUGFS_ADD(usb_rx_anch_urbs);
+	DEBUGFS_ADD(usb_rx_work_urbs);
+
+	DEBUGFS_ADD(tx_total_queued);
+	DEBUGFS_ADD(tx_total_pending);
+	DEBUGFS_ADD(tx_dropped);
+	DEBUGFS_ADD(tx_stuck);
+	DEBUGFS_ADD(tx_ampdu_upload);
+	DEBUGFS_ADD(tx_ampdu_scheduler);
+	DEBUGFS_ADD(tx_ampdu_list_len);
+
+	DEBUGFS_ADD(rx_dropped);
+	DEBUGFS_ADD(sniffer_enabled);
+	DEBUGFS_ADD(rx_software_decryption);
+
+	DEBUGFS_ADD(mem_usage);
+	DEBUGFS_ADD(qos_stat);
+	DEBUGFS_ADD(sta_psm);
+	DEBUGFS_ADD(ampdu_state);
+
+	DEBUGFS_ADD(hw_tx_tally);
+	DEBUGFS_ADD(hw_rx_tally);
+	DEBUGFS_ADD(hw_phy_errors);
+	DEBUGFS_ADD(phy_noise);
+
+	DEBUGFS_ADD(hw_wlan_queue);
+	DEBUGFS_ADD(hw_pta_queue);
+	DEBUGFS_ADD(hw_ampdu_info);
+
+	DEBUGFS_ADD(ampdu_density);
+	DEBUGFS_ADD(ampdu_factor);
+
+	DEBUGFS_ADD(tx_janitor_last_run);
+
+	DEBUGFS_ADD(tx_status_0);
+	DEBUGFS_ADD(tx_status_1);
+	DEBUGFS_ADD(tx_status_2);
+	DEBUGFS_ADD(tx_status_3);
+
+	DEBUGFS_ADD(tx_pending_0);
+	DEBUGFS_ADD(tx_pending_1);
+	DEBUGFS_ADD(tx_pending_2);
+	DEBUGFS_ADD(tx_pending_3);
+
+	DEBUGFS_ADD(hw_ioread32);
+	DEBUGFS_ADD(hw_iowrite32);
+	DEBUGFS_ADD(bug);
+
+	DEBUGFS_ADD(erp);
+
+	DEBUGFS_ADD(vif_dump);
+
+	DEBUGFS_ADD(beacon_int);
+	DEBUGFS_ADD(pretbtt);
+
+#undef DEBUGFS_ADD
+}
+
+void carl9170_debugfs_unregister(struct ar9170 *ar)
+{
+	debugfs_remove_recursive(ar->debug_dir);
+}
diff --git a/drivers/net/wireless/ath/carl9170/debug.h b/drivers/net/wireless/ath/carl9170/debug.h
new file mode 100644
index 0000000..ea4b975
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/debug.h
@@ -0,0 +1,134 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * debug header
+ *
+ * Copyright 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __DEBUG_H
+#define __DEBUG_H
+
+#include "eeprom.h"
+#include "wlan.h"
+#include "hw.h"
+#include "fwdesc.h"
+#include "fwcmd.h"
+#include "../regd.h"
+
+struct hw_stat_reg_entry {
+	u32 reg;
+	char nreg[32];
+};
+
+#define	STAT_MAC_REG(reg)	\
+	{ (AR9170_MAC_REG_##reg), #reg }
+
+#define	STAT_PTA_REG(reg)	\
+	{ (AR9170_PTA_REG_##reg), #reg }
+
+#define	STAT_USB_REG(reg)	\
+	{ (AR9170_USB_REG_##reg), #reg }
+
+static const struct hw_stat_reg_entry hw_rx_tally_regs[] = {
+	STAT_MAC_REG(RX_CRC32),		STAT_MAC_REG(RX_CRC16),
+	STAT_MAC_REG(RX_TIMEOUT_COUNT),	STAT_MAC_REG(RX_ERR_DECRYPTION_UNI),
+	STAT_MAC_REG(RX_ERR_DECRYPTION_MUL), STAT_MAC_REG(RX_MPDU),
+	STAT_MAC_REG(RX_DROPPED_MPDU),	STAT_MAC_REG(RX_DEL_MPDU),
+};
+
+static const struct hw_stat_reg_entry hw_phy_errors_regs[] = {
+	STAT_MAC_REG(RX_PHY_MISC_ERROR), STAT_MAC_REG(RX_PHY_XR_ERROR),
+	STAT_MAC_REG(RX_PHY_OFDM_ERROR), STAT_MAC_REG(RX_PHY_CCK_ERROR),
+	STAT_MAC_REG(RX_PHY_HT_ERROR), STAT_MAC_REG(RX_PHY_TOTAL),
+};
+
+static const struct hw_stat_reg_entry hw_tx_tally_regs[] = {
+	STAT_MAC_REG(TX_TOTAL),		STAT_MAC_REG(TX_UNDERRUN),
+	STAT_MAC_REG(TX_RETRY),
+};
+
+static const struct hw_stat_reg_entry hw_wlan_queue_regs[] = {
+	STAT_MAC_REG(DMA_STATUS),	STAT_MAC_REG(DMA_TRIGGER),
+	STAT_MAC_REG(DMA_TXQ0_ADDR),	STAT_MAC_REG(DMA_TXQ0_CURR_ADDR),
+	STAT_MAC_REG(DMA_TXQ1_ADDR),	STAT_MAC_REG(DMA_TXQ1_CURR_ADDR),
+	STAT_MAC_REG(DMA_TXQ2_ADDR),	STAT_MAC_REG(DMA_TXQ2_CURR_ADDR),
+	STAT_MAC_REG(DMA_TXQ3_ADDR),	STAT_MAC_REG(DMA_TXQ3_CURR_ADDR),
+	STAT_MAC_REG(DMA_RXQ_ADDR),	STAT_MAC_REG(DMA_RXQ_CURR_ADDR),
+};
+
+static const struct hw_stat_reg_entry hw_ampdu_info_regs[] = {
+	STAT_MAC_REG(AMPDU_DENSITY),	STAT_MAC_REG(AMPDU_FACTOR),
+};
+
+static const struct hw_stat_reg_entry hw_pta_queue_regs[] = {
+	STAT_PTA_REG(DN_CURR_ADDRH),	STAT_PTA_REG(DN_CURR_ADDRL),
+	STAT_PTA_REG(UP_CURR_ADDRH),	STAT_PTA_REG(UP_CURR_ADDRL),
+	STAT_PTA_REG(DMA_STATUS),	STAT_PTA_REG(DMA_MODE_CTRL),
+};
+
+#define	DEFINE_TALLY(name)					\
+	u32 name##_sum[ARRAY_SIZE(name##_regs)],		\
+	    name##_counter[ARRAY_SIZE(name##_regs)]		\
+
+#define	DEFINE_STAT(name)					\
+	u32 name##_counter[ARRAY_SIZE(name##_regs)]		\
+
+struct ath_stats {
+	DEFINE_TALLY(hw_tx_tally);
+	DEFINE_TALLY(hw_rx_tally);
+	DEFINE_TALLY(hw_phy_errors);
+	DEFINE_STAT(hw_wlan_queue);
+	DEFINE_STAT(hw_pta_queue);
+	DEFINE_STAT(hw_ampdu_info);
+};
+
+struct carl9170_debug_mem_rbe {
+	u32 reg;
+	u32 value;
+};
+
+#define	CARL9170_DEBUG_RING_SIZE			64
+
+struct carl9170_debug {
+	struct ath_stats stats;
+	struct carl9170_debug_mem_rbe ring[CARL9170_DEBUG_RING_SIZE];
+	struct mutex ring_lock;
+	unsigned int ring_head, ring_tail;
+	struct delayed_work update_tally;
+};
+
+struct ar9170;
+
+void carl9170_debugfs_register(struct ar9170 *ar);
+void carl9170_debugfs_unregister(struct ar9170 *ar);
+#endif /* __DEBUG_H */
diff --git a/drivers/net/wireless/ath/carl9170/eeprom.h b/drivers/net/wireless/ath/carl9170/eeprom.h
new file mode 100644
index 0000000..7cff40a
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/eeprom.h
@@ -0,0 +1,216 @@
+/*
+ * Shared Atheros AR9170 Header
+ *
+ * EEPROM layout
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __CARL9170_SHARED_EEPROM_H
+#define __CARL9170_SHARED_EEPROM_H
+
+#define AR9170_EEPROM_START		0x1600
+
+#define AR5416_MAX_CHAINS		2
+#define AR5416_MODAL_SPURS		5
+
+struct ar9170_eeprom_modal {
+	__le32	antCtrlChain[AR5416_MAX_CHAINS];
+	__le32	antCtrlCommon;
+	s8	antennaGainCh[AR5416_MAX_CHAINS];
+	u8	switchSettling;
+	u8	txRxAttenCh[AR5416_MAX_CHAINS];
+	u8	rxTxMarginCh[AR5416_MAX_CHAINS];
+	s8	adcDesiredSize;
+	s8	pgaDesiredSize;
+	u8	xlnaGainCh[AR5416_MAX_CHAINS];
+	u8	txEndToXpaOff;
+	u8	txEndToRxOn;
+	u8	txFrameToXpaOn;
+	u8	thresh62;
+	s8	noiseFloorThreshCh[AR5416_MAX_CHAINS];
+	u8	xpdGain;
+	u8	xpd;
+	s8	iqCalICh[AR5416_MAX_CHAINS];
+	s8	iqCalQCh[AR5416_MAX_CHAINS];
+	u8	pdGainOverlap;
+	u8	ob;
+	u8	db;
+	u8	xpaBiasLvl;
+	u8	pwrDecreaseFor2Chain;
+	u8	pwrDecreaseFor3Chain;
+	u8	txFrameToDataStart;
+	u8	txFrameToPaOn;
+	u8	ht40PowerIncForPdadc;
+	u8	bswAtten[AR5416_MAX_CHAINS];
+	u8	bswMargin[AR5416_MAX_CHAINS];
+	u8	swSettleHt40;
+	u8	reserved[22];
+	struct spur_channel {
+		__le16 spurChan;
+		u8	spurRangeLow;
+		u8	spurRangeHigh;
+	} __packed spur_channels[AR5416_MODAL_SPURS];
+} __packed;
+
+#define AR5416_NUM_PD_GAINS		4
+#define AR5416_PD_GAIN_ICEPTS		5
+
+struct ar9170_calibration_data_per_freq {
+	u8	pwr_pdg[AR5416_NUM_PD_GAINS][AR5416_PD_GAIN_ICEPTS];
+	u8	vpd_pdg[AR5416_NUM_PD_GAINS][AR5416_PD_GAIN_ICEPTS];
+} __packed;
+
+#define AR5416_NUM_5G_CAL_PIERS		8
+#define AR5416_NUM_2G_CAL_PIERS		4
+
+#define AR5416_NUM_5G_TARGET_PWRS	8
+#define AR5416_NUM_2G_CCK_TARGET_PWRS	3
+#define AR5416_NUM_2G_OFDM_TARGET_PWRS	4
+#define AR5416_MAX_NUM_TGT_PWRS		8
+
+struct ar9170_calibration_target_power_legacy {
+	u8	freq;
+	u8	power[4];
+} __packed;
+
+struct ar9170_calibration_target_power_ht {
+	u8	freq;
+	u8	power[8];
+} __packed;
+
+#define AR5416_NUM_CTLS			24
+
+struct ar9170_calctl_edges {
+	u8	channel;
+#define AR9170_CALCTL_EDGE_FLAGS	0xC0
+	u8	power_flags;
+} __packed;
+
+#define AR5416_NUM_BAND_EDGES		8
+
+struct ar9170_calctl_data {
+	struct ar9170_calctl_edges
+		control_edges[AR5416_MAX_CHAINS][AR5416_NUM_BAND_EDGES];
+} __packed;
+
+struct ar9170_eeprom {
+	__le16	length;
+	__le16	checksum;
+	__le16	version;
+	u8	operating_flags;
+#define AR9170_OPFLAG_5GHZ		1
+#define AR9170_OPFLAG_2GHZ		2
+	u8	misc;
+	__le16	reg_domain[2];
+	u8	mac_address[6];
+	u8	rx_mask;
+	u8	tx_mask;
+	__le16	rf_silent;
+	__le16	bluetooth_options;
+	__le16	device_capabilities;
+	__le32	build_number;
+	u8	deviceType;
+	u8	reserved[33];
+
+	u8	customer_data[64];
+
+	struct ar9170_eeprom_modal
+		modal_header[2];
+
+	u8	cal_freq_pier_5G[AR5416_NUM_5G_CAL_PIERS];
+	u8	cal_freq_pier_2G[AR5416_NUM_2G_CAL_PIERS];
+
+	struct ar9170_calibration_data_per_freq
+		cal_pier_data_5G[AR5416_MAX_CHAINS][AR5416_NUM_5G_CAL_PIERS],
+		cal_pier_data_2G[AR5416_MAX_CHAINS][AR5416_NUM_2G_CAL_PIERS];
+
+	/* power calibration data */
+	struct ar9170_calibration_target_power_legacy
+		cal_tgt_pwr_5G[AR5416_NUM_5G_TARGET_PWRS];
+	struct ar9170_calibration_target_power_ht
+		cal_tgt_pwr_5G_ht20[AR5416_NUM_5G_TARGET_PWRS],
+		cal_tgt_pwr_5G_ht40[AR5416_NUM_5G_TARGET_PWRS];
+
+	struct ar9170_calibration_target_power_legacy
+		cal_tgt_pwr_2G_cck[AR5416_NUM_2G_CCK_TARGET_PWRS],
+		cal_tgt_pwr_2G_ofdm[AR5416_NUM_2G_OFDM_TARGET_PWRS];
+	struct ar9170_calibration_target_power_ht
+		cal_tgt_pwr_2G_ht20[AR5416_NUM_2G_OFDM_TARGET_PWRS],
+		cal_tgt_pwr_2G_ht40[AR5416_NUM_2G_OFDM_TARGET_PWRS];
+
+	/* conformance testing limits */
+	u8	ctl_index[AR5416_NUM_CTLS];
+	struct ar9170_calctl_data
+		ctl_data[AR5416_NUM_CTLS];
+
+	u8	pad;
+	__le16	subsystem_id;
+} __packed;
+
+#define AR9170_LED_MODE_POWER_ON		0x0001
+#define AR9170_LED_MODE_RESERVED		0x0002
+#define AR9170_LED_MODE_DISABLE_STATE		0x0004
+#define AR9170_LED_MODE_OFF_IN_PSM		0x0008
+
+/* AR9170_LED_MODE BIT is set */
+#define AR9170_LED_MODE_FREQUENCY_S		4
+#define AR9170_LED_MODE_FREQUENCY		0x0030
+#define AR9170_LED_MODE_FREQUENCY_1HZ		0x0000
+#define AR9170_LED_MODE_FREQUENCY_0_5HZ		0x0010
+#define AR9170_LED_MODE_FREQUENCY_0_25HZ	0x0020
+#define AR9170_LED_MODE_FREQUENCY_0_125HZ	0x0030
+
+/* AR9170_LED_MODE BIT is not set */
+#define AR9170_LED_MODE_CONN_STATE_S		4
+#define AR9170_LED_MODE_CONN_STATE		0x0030
+#define AR9170_LED_MODE_CONN_STATE_FORCE_OFF	0x0000
+#define AR9170_LED_MODE_CONN_STATE_FORCE_ON	0x0010
+/* Idle off / Active on */
+#define AR9170_LED_MODE_CONN_STATE_IOFF_AON	0x0020
+/* Idle on / Active off */
+#define AR9170_LED_MODE_CONN_STATE_ION_AOFF	0x0010
+
+#define AR9170_LED_MODE_MODE			0x0040
+#define AR9170_LED_MODE_RESERVED2		0x0080
+
+#define AR9170_LED_MODE_TON_SCAN_S		8
+#define AR9170_LED_MODE_TON_SCAN		0x0f00
+
+#define AR9170_LED_MODE_TOFF_SCAN_S		12
+#define AR9170_LED_MODE_TOFF_SCAN		0xf000
+
+struct ar9170_led_mode {
+	__le16 led;
+};
+
+#endif /* __CARL9170_SHARED_EEPROM_H */
diff --git a/drivers/net/wireless/ath/carl9170/fw.c b/drivers/net/wireless/ath/carl9170/fw.c
new file mode 100644
index 0000000..ae6c006
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/fw.c
@@ -0,0 +1,402 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * firmware parser
+ *
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ */
+
+#include <linux/kernel.h>
+#include <linux/firmware.h>
+#include <linux/crc32.h>
+#include "carl9170.h"
+#include "fwcmd.h"
+#include "version.h"
+
+#define MAKE_STR(symbol) #symbol
+#define TO_STR(symbol) MAKE_STR(symbol)
+#define CARL9170FW_API_VER_STR TO_STR(CARL9170FW_API_MAX_VER)
+MODULE_VERSION(CARL9170FW_API_VER_STR ":" CARL9170FW_VERSION_GIT);
+
+static const u8 otus_magic[4] = { OTUS_MAGIC };
+
+static const void *carl9170_fw_find_desc(struct ar9170 *ar, const u8 descid[4],
+	const unsigned int len, const u8 compatible_revision)
+{
+	const struct carl9170fw_desc_head *iter;
+
+	carl9170fw_for_each_hdr(iter, ar->fw.desc) {
+		if (carl9170fw_desc_cmp(iter, descid, len,
+					compatible_revision))
+			return (void *)iter;
+	}
+
+	/* needed to find the LAST desc */
+	if (carl9170fw_desc_cmp(iter, descid, len,
+				compatible_revision))
+		return (void *)iter;
+
+	return NULL;
+}
+
+static int carl9170_fw_verify_descs(struct ar9170 *ar,
+	const struct carl9170fw_desc_head *head, unsigned int max_len)
+{
+	const struct carl9170fw_desc_head *pos;
+	unsigned long pos_addr, end_addr;
+	unsigned int pos_length;
+
+	if (max_len < sizeof(*pos))
+		return -ENODATA;
+
+	max_len = min_t(unsigned int, CARL9170FW_DESC_MAX_LENGTH, max_len);
+
+	pos = head;
+	pos_addr = (unsigned long) pos;
+	end_addr = pos_addr + max_len;
+
+	while (pos_addr < end_addr) {
+		if (pos_addr + sizeof(*head) > end_addr)
+			return -E2BIG;
+
+		pos_length = le16_to_cpu(pos->length);
+
+		if (pos_length < sizeof(*head))
+			return -EBADMSG;
+
+		if (pos_length > max_len)
+			return -EOVERFLOW;
+
+		if (pos_addr + pos_length > end_addr)
+			return -EMSGSIZE;
+
+		if (carl9170fw_desc_cmp(pos, LAST_MAGIC,
+					CARL9170FW_LAST_DESC_SIZE,
+					CARL9170FW_LAST_DESC_CUR_VER))
+			return 0;
+
+		pos_addr += pos_length;
+		pos = (void *)pos_addr;
+		max_len -= pos_length;
+	}
+	return -EINVAL;
+}
+
+static void carl9170_fw_info(struct ar9170 *ar)
+{
+	const struct carl9170fw_motd_desc *motd_desc;
+	unsigned int str_ver_len;
+	u32 fw_date;
+
+	dev_info(&ar->udev->dev, "driver   API: %s 2%03d-%02d-%02d [%d-%d]\n",
+		CARL9170FW_VERSION_GIT, CARL9170FW_VERSION_YEAR,
+		CARL9170FW_VERSION_MONTH, CARL9170FW_VERSION_DAY,
+		CARL9170FW_API_MIN_VER, CARL9170FW_API_MAX_VER);
+
+	motd_desc = carl9170_fw_find_desc(ar, MOTD_MAGIC,
+		sizeof(*motd_desc), CARL9170FW_MOTD_DESC_CUR_VER);
+
+	if (motd_desc) {
+		str_ver_len = strnlen(motd_desc->release,
+			CARL9170FW_MOTD_RELEASE_LEN);
+
+		fw_date = le32_to_cpu(motd_desc->fw_year_month_day);
+
+		dev_info(&ar->udev->dev, "firmware API: %.*s 2%03d-%02d-%02d\n",
+			 str_ver_len, motd_desc->release,
+			 CARL9170FW_GET_YEAR(fw_date),
+			 CARL9170FW_GET_MONTH(fw_date),
+			 CARL9170FW_GET_DAY(fw_date));
+
+		strlcpy(ar->hw->wiphy->fw_version, motd_desc->release,
+			sizeof(ar->hw->wiphy->fw_version));
+	}
+}
+
+static bool valid_dma_addr(const u32 address)
+{
+	if (address >= AR9170_SRAM_OFFSET &&
+	    address < (AR9170_SRAM_OFFSET + AR9170_SRAM_SIZE))
+		return true;
+
+	return false;
+}
+
+static bool valid_cpu_addr(const u32 address)
+{
+	if (valid_dma_addr(address) || (address >= AR9170_PRAM_OFFSET &&
+	    address < (AR9170_PRAM_OFFSET + AR9170_PRAM_SIZE)))
+		return true;
+
+	return false;
+}
+
+static int carl9170_fw(struct ar9170 *ar, const __u8 *data, size_t len)
+{
+	const struct carl9170fw_otus_desc *otus_desc;
+	const struct carl9170fw_chk_desc *chk_desc;
+	const struct carl9170fw_last_desc *last_desc;
+
+	last_desc = carl9170_fw_find_desc(ar, LAST_MAGIC,
+		sizeof(*last_desc), CARL9170FW_LAST_DESC_CUR_VER);
+	if (!last_desc)
+		return -EINVAL;
+
+	otus_desc = carl9170_fw_find_desc(ar, OTUS_MAGIC,
+		sizeof(*otus_desc), CARL9170FW_OTUS_DESC_CUR_VER);
+	if (!otus_desc) {
+		dev_err(&ar->udev->dev, "failed to find compatible firmware "
+			"descriptor.\n");
+		return -ENODATA;
+	}
+
+	chk_desc = carl9170_fw_find_desc(ar, CHK_MAGIC,
+		sizeof(*chk_desc), CARL9170FW_CHK_DESC_CUR_VER);
+
+	if (chk_desc) {
+		unsigned long fin, diff;
+		unsigned int dsc_len;
+		u32 crc32;
+
+		dsc_len = min_t(unsigned int, len,
+			(unsigned long)chk_desc - (unsigned long)otus_desc);
+
+		fin = (unsigned long) last_desc + sizeof(*last_desc);
+		diff = fin - (unsigned long) otus_desc;
+
+		if (diff < len)
+			len -= diff;
+
+		if (len < 256)
+			return -EIO;
+
+		crc32 = crc32_le(~0, data, len);
+		if (cpu_to_le32(crc32) != chk_desc->fw_crc32) {
+			dev_err(&ar->udev->dev, "fw checksum test failed.\n");
+			return -ENOEXEC;
+		}
+
+		crc32 = crc32_le(crc32, (void *)otus_desc, dsc_len);
+		if (cpu_to_le32(crc32) != chk_desc->hdr_crc32) {
+			dev_err(&ar->udev->dev, "descriptor check failed.\n");
+			return -EINVAL;
+		}
+	} else {
+		dev_warn(&ar->udev->dev, "Unprotected firmware image.\n");
+	}
+
+#define SUPP(feat)						\
+	(carl9170fw_supports(otus_desc->feature_set, feat))
+
+	if (!SUPP(CARL9170FW_DUMMY_FEATURE)) {
+		dev_err(&ar->udev->dev, "invalid firmware descriptor "
+			"format detected.\n");
+		return -EINVAL;
+	}
+
+	ar->fw.api_version = otus_desc->api_ver;
+
+	if (ar->fw.api_version < CARL9170FW_API_MIN_VER ||
+	    ar->fw.api_version > CARL9170FW_API_MAX_VER) {
+		dev_err(&ar->udev->dev, "unsupported firmware api version.\n");
+		return -EINVAL;
+	}
+
+	if (!SUPP(CARL9170FW_COMMAND_PHY) || SUPP(CARL9170FW_UNUSABLE) ||
+	    !SUPP(CARL9170FW_HANDLE_BACK_REQ)) {
+		dev_err(&ar->udev->dev, "firmware does support "
+			"mandatory features.\n");
+		return -ECANCELED;
+	}
+
+	if (ilog2(le32_to_cpu(otus_desc->feature_set)) >=
+		__CARL9170FW_FEATURE_NUM) {
+		dev_warn(&ar->udev->dev, "driver does not support all "
+			 "firmware features.\n");
+	}
+
+	if (!SUPP(CARL9170FW_COMMAND_CAM)) {
+		dev_info(&ar->udev->dev, "crypto offloading is disabled "
+			 "by firmware.\n");
+		ar->disable_offload = true;
+	}
+
+	if (SUPP(CARL9170FW_PSM))
+		ar->hw->flags |= IEEE80211_HW_SUPPORTS_PS;
+
+	if (!SUPP(CARL9170FW_USB_INIT_FIRMWARE)) {
+		dev_err(&ar->udev->dev, "firmware does not provide "
+			"mandatory interfaces.\n");
+		return -EINVAL;
+	}
+
+	if (SUPP(CARL9170FW_MINIBOOT))
+		ar->fw.offset = le16_to_cpu(otus_desc->miniboot_size);
+	else
+		ar->fw.offset = 0;
+
+	if (SUPP(CARL9170FW_USB_DOWN_STREAM)) {
+		ar->hw->extra_tx_headroom += sizeof(struct ar9170_stream);
+		ar->fw.tx_stream = true;
+	}
+
+	if (SUPP(CARL9170FW_USB_UP_STREAM))
+		ar->fw.rx_stream = true;
+
+	if (SUPP(CARL9170FW_RX_FILTER)) {
+		ar->fw.rx_filter = true;
+		ar->rx_filter_caps = FIF_FCSFAIL | FIF_PLCPFAIL |
+			FIF_CONTROL | FIF_PSPOLL | FIF_OTHER_BSS |
+			FIF_PROMISC_IN_BSS;
+	}
+
+	ar->fw.vif_num = otus_desc->vif_num;
+	ar->fw.cmd_bufs = otus_desc->cmd_bufs;
+	ar->fw.address = le32_to_cpu(otus_desc->fw_address);
+	ar->fw.rx_size = le16_to_cpu(otus_desc->rx_max_frame_len);
+	ar->fw.mem_blocks = min_t(unsigned int, otus_desc->tx_descs, 0xfe);
+	atomic_set(&ar->mem_free_blocks, ar->fw.mem_blocks);
+	ar->fw.mem_block_size = le16_to_cpu(otus_desc->tx_frag_len);
+
+	if (ar->fw.vif_num >= AR9170_MAX_VIRTUAL_MAC || !ar->fw.vif_num ||
+	    ar->fw.mem_blocks < 16 || !ar->fw.cmd_bufs ||
+	    ar->fw.mem_block_size < 64 || ar->fw.mem_block_size > 512 ||
+	    ar->fw.rx_size > 32768 || ar->fw.rx_size < 4096 ||
+	    !valid_cpu_addr(ar->fw.address)) {
+		dev_err(&ar->udev->dev, "firmware shows obvious signs of "
+			"malicious tampering.\n");
+		return -EINVAL;
+	}
+
+	ar->fw.beacon_addr = le32_to_cpu(otus_desc->bcn_addr);
+	ar->fw.beacon_max_len = le16_to_cpu(otus_desc->bcn_len);
+
+	if (valid_dma_addr(ar->fw.beacon_addr) && ar->fw.beacon_max_len >=
+	    AR9170_MAC_BCN_LENGTH_MAX) {
+		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+
+		if (SUPP(CARL9170FW_WLANTX_CAB)) {
+			ar->hw->wiphy->interface_modes |=
+				BIT(NL80211_IFTYPE_AP);
+		}
+	}
+
+#undef SUPPORTED
+	return 0;
+}
+
+static struct carl9170fw_desc_head *
+carl9170_find_fw_desc(struct ar9170 *ar, const __u8 *fw_data, const size_t len)
+
+{
+	int scan = 0, found = 0;
+
+	if (!carl9170fw_size_check(len)) {
+		dev_err(&ar->udev->dev, "firmware size is out of bound.\n");
+		return NULL;
+	}
+
+	while (scan < len - sizeof(struct carl9170fw_desc_head)) {
+		if (fw_data[scan++] == otus_magic[found])
+			found++;
+		else
+			found = 0;
+
+		if (scan >= len)
+			break;
+
+		if (found == sizeof(otus_magic))
+			break;
+	}
+
+	if (found != sizeof(otus_magic))
+		return NULL;
+
+	return (void *)&fw_data[scan - found];
+}
+
+int carl9170_fw_fix_eeprom(struct ar9170 *ar)
+{
+	const struct carl9170fw_fix_desc *fix_desc = NULL;
+	unsigned int i, n, off;
+	u32 *data = (void *)&ar->eeprom;
+
+	fix_desc = carl9170_fw_find_desc(ar, FIX_MAGIC,
+		sizeof(*fix_desc), CARL9170FW_FIX_DESC_CUR_VER);
+
+	if (!fix_desc)
+		return 0;
+
+	n = (le16_to_cpu(fix_desc->head.length) - sizeof(*fix_desc)) /
+	    sizeof(struct carl9170fw_fix_entry);
+
+	for (i = 0; i < n; i++) {
+		off = le32_to_cpu(fix_desc->data[i].address) -
+		      AR9170_EEPROM_START;
+
+		if (off >= sizeof(struct ar9170_eeprom) || (off & 3)) {
+			dev_err(&ar->udev->dev, "Skip invalid entry %d\n", i);
+			continue;
+		}
+
+		data[off / sizeof(*data)] &=
+			le32_to_cpu(fix_desc->data[i].mask);
+		data[off / sizeof(*data)] |=
+			le32_to_cpu(fix_desc->data[i].value);
+	}
+
+	return 0;
+}
+
+int carl9170_parse_firmware(struct ar9170 *ar)
+{
+	const struct carl9170fw_desc_head *fw_desc = NULL;
+	const struct firmware *fw = ar->fw.fw;
+	unsigned long header_offset = 0;
+	int err;
+
+	if (WARN_ON(!fw))
+		return -EINVAL;
+
+	fw_desc = carl9170_find_fw_desc(ar, fw->data, fw->size);
+
+	if (!fw_desc) {
+		dev_err(&ar->udev->dev, "unsupported firmware.\n");
+		return -ENODATA;
+	}
+
+	header_offset = (unsigned long)fw_desc - (unsigned long)fw->data;
+
+	err = carl9170_fw_verify_descs(ar, fw_desc, fw->size - header_offset);
+	if (err) {
+		dev_err(&ar->udev->dev, "damaged firmware (%d).\n", err);
+		return err;
+	}
+
+	ar->fw.desc = fw_desc;
+
+	carl9170_fw_info(ar);
+
+	err = carl9170_fw(ar, fw->data, fw->size);
+	if (err) {
+		dev_err(&ar->udev->dev, "failed to parse firmware (%d).\n",
+			err);
+		return err;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/ath/carl9170/fwcmd.h b/drivers/net/wireless/ath/carl9170/fwcmd.h
new file mode 100644
index 0000000..d552166
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/fwcmd.h
@@ -0,0 +1,284 @@
+/*
+ * Shared Atheros AR9170 Header
+ *
+ * Firmware command interface definitions
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __CARL9170_SHARED_FWCMD_H
+#define __CARL9170_SHARED_FWCMD_H
+
+#define	CARL9170_MAX_CMD_LEN		64
+#define	CARL9170_MAX_CMD_PAYLOAD_LEN	60
+
+#define CARL9170FW_API_MIN_VER		1
+#define CARL9170FW_API_MAX_VER		1
+
+enum carl9170_cmd_oids {
+	CARL9170_CMD_RREG		= 0x00,
+	CARL9170_CMD_WREG		= 0x01,
+	CARL9170_CMD_ECHO		= 0x02,
+	CARL9170_CMD_SWRST		= 0x03,
+	CARL9170_CMD_REBOOT		= 0x04,
+	CARL9170_CMD_BCN_CTRL		= 0x05,
+	CARL9170_CMD_READ_TSF		= 0x06,
+	CARL9170_CMD_RX_FILTER		= 0x07,
+
+	/* CAM */
+	CARL9170_CMD_EKEY		= 0x10,
+	CARL9170_CMD_DKEY		= 0x11,
+
+	/* RF / PHY */
+	CARL9170_CMD_FREQUENCY		= 0x20,
+	CARL9170_CMD_RF_INIT		= 0x21,
+	CARL9170_CMD_SYNTH		= 0x22,
+	CARL9170_CMD_FREQ_START		= 0x23,
+	CARL9170_CMD_PSM		= 0x24,
+
+	/* Asychronous command flag */
+	CARL9170_CMD_ASYNC_FLAG		= 0x40,
+	CARL9170_CMD_WREG_ASYNC		= (CARL9170_CMD_WREG |
+					   CARL9170_CMD_ASYNC_FLAG),
+	CARL9170_CMD_REBOOT_ASYNC	= (CARL9170_CMD_REBOOT |
+					   CARL9170_CMD_ASYNC_FLAG),
+	CARL9170_CMD_BCN_CTRL_ASYNC	= (CARL9170_CMD_BCN_CTRL |
+					   CARL9170_CMD_ASYNC_FLAG),
+	CARL9170_CMD_PSM_ASYNC		= (CARL9170_CMD_PSM |
+					   CARL9170_CMD_ASYNC_FLAG),
+
+	/* responses and traps */
+	CARL9170_RSP_FLAG		= 0xc0,
+	CARL9170_RSP_PRETBTT		= 0xc0,
+	CARL9170_RSP_TXCOMP		= 0xc1,
+	CARL9170_RSP_BEACON_CONFIG	= 0xc2,
+	CARL9170_RSP_ATIM		= 0xc3,
+	CARL9170_RSP_WATCHDOG		= 0xc6,
+	CARL9170_RSP_TEXT		= 0xca,
+	CARL9170_RSP_HEXDUMP		= 0xcc,
+	CARL9170_RSP_RADAR		= 0xcd,
+	CARL9170_RSP_GPIO		= 0xce,
+	CARL9170_RSP_BOOT		= 0xcf,
+};
+
+struct carl9170_set_key_cmd {
+	__le16		user;
+	__le16		keyId;
+	__le16		type;
+	u8		macAddr[6];
+	u32		key[4];
+} __packed;
+#define CARL9170_SET_KEY_CMD_SIZE		28
+
+struct carl9170_disable_key_cmd {
+	__le16		user;
+	__le16		padding;
+} __packed;
+#define CARL9170_DISABLE_KEY_CMD_SIZE		4
+
+struct carl9170_u32_list {
+	u32	vals[0];
+} __packed;
+
+struct carl9170_reg_list {
+	__le32		regs[0];
+} __packed;
+
+struct carl9170_write_reg {
+	struct {
+		__le32		addr;
+		__le32		val;
+	} regs[0] __packed;
+} __packed;
+
+#define	CARL9170FW_PHY_HT_ENABLE		0x4
+#define	CARL9170FW_PHY_HT_DYN2040		0x8
+#define	CARL9170FW_PHY_HT_EXT_CHAN_OFF		0x3
+#define	CARL9170FW_PHY_HT_EXT_CHAN_OFF_S	2
+
+struct carl9170_rf_init {
+	__le32		freq;
+	u8		ht_settings;
+	u8		padding2[3];
+	__le32		delta_slope_coeff_exp;
+	__le32		delta_slope_coeff_man;
+	__le32		delta_slope_coeff_exp_shgi;
+	__le32		delta_slope_coeff_man_shgi;
+	__le32		finiteLoopCount;
+} __packed;
+#define CARL9170_RF_INIT_SIZE		28
+
+struct carl9170_rf_init_result {
+	__le32		ret;		/* AR9170_PHY_REG_AGC_CONTROL */
+} __packed;
+#define	CARL9170_RF_INIT_RESULT_SIZE	4
+
+#define	CARL9170_PSM_SLEEP		0x1000
+#define	CARL9170_PSM_SOFTWARE		0
+#define	CARL9170_PSM_WAKE		0 /* internally used. */
+#define	CARL9170_PSM_COUNTER		0xfff
+#define	CARL9170_PSM_COUNTER_S		0
+
+struct carl9170_psm {
+	__le32		state;
+} __packed;
+#define CARL9170_PSM_SIZE		4
+
+struct carl9170_rx_filter_cmd {
+	__le32		rx_filter;
+} __packed;
+#define CARL9170_RX_FILTER_CMD_SIZE	4
+
+#define CARL9170_RX_FILTER_BAD		0x01
+#define CARL9170_RX_FILTER_OTHER_RA	0x02
+#define CARL9170_RX_FILTER_DECRY_FAIL	0x04
+#define CARL9170_RX_FILTER_CTL_OTHER	0x08
+#define CARL9170_RX_FILTER_CTL_PSPOLL	0x10
+#define CARL9170_RX_FILTER_CTL_BACKR	0x20
+#define CARL9170_RX_FILTER_MGMT		0x40
+#define CARL9170_RX_FILTER_DATA		0x80
+
+struct carl9170_bcn_ctrl_cmd {
+	__le32		vif_id;
+	__le32		mode;
+	__le32		bcn_addr;
+	__le32		bcn_len;
+} __packed;
+#define CARL9170_BCN_CTRL_CMD_SIZE	16
+
+#define CARL9170_BCN_CTRL_DRAIN	0
+#define CARL9170_BCN_CTRL_CAB_TRIGGER	1
+
+struct carl9170_cmd_head {
+	union {
+		struct {
+			u8	len;
+			u8	cmd;
+			u8	seq;
+			u8	ext;
+		} __packed;
+
+		u32 hdr_data;
+	} __packed;
+} __packed;
+
+struct carl9170_cmd {
+	struct carl9170_cmd_head hdr;
+	union {
+		struct carl9170_set_key_cmd	setkey;
+		struct carl9170_disable_key_cmd	disablekey;
+		struct carl9170_u32_list	echo;
+		struct carl9170_reg_list	rreg;
+		struct carl9170_write_reg	wreg;
+		struct carl9170_rf_init		rf_init;
+		struct carl9170_psm		psm;
+		struct carl9170_bcn_ctrl_cmd	bcn_ctrl;
+		struct carl9170_rx_filter_cmd	rx_filter;
+		u8 data[CARL9170_MAX_CMD_PAYLOAD_LEN];
+	} __packed;
+} __packed;
+
+#define	CARL9170_TX_STATUS_QUEUE	3
+#define	CARL9170_TX_STATUS_QUEUE_S	0
+#define	CARL9170_TX_STATUS_RIX_S	2
+#define	CARL9170_TX_STATUS_RIX		(3 << CARL9170_TX_STATUS_RIX_S)
+#define	CARL9170_TX_STATUS_TRIES_S	4
+#define	CARL9170_TX_STATUS_TRIES	(7 << CARL9170_TX_STATUS_TRIES_S)
+#define	CARL9170_TX_STATUS_SUCCESS	0x80
+
+/*
+ * NOTE:
+ * Both structs [carl9170_tx_status and _carl9170_tx_status]
+ * need to be "bit for bit" in sync.
+ */
+struct carl9170_tx_status {
+	/*
+	 * Beware of compiler bugs in all gcc pre 4.4!
+	 */
+
+	u8 cookie;
+	u8 queue:2;
+	u8 rix:2;
+	u8 tries:3;
+	u8 success:1;
+} __packed;
+struct _carl9170_tx_status {
+	/*
+	 * This version should be immune to all alignment bugs.
+	 */
+
+	u8 cookie;
+	u8 info;
+} __packed;
+#define CARL9170_TX_STATUS_SIZE		2
+
+#define	CARL9170_RSP_TX_STATUS_NUM	(CARL9170_MAX_CMD_PAYLOAD_LEN /	\
+					 sizeof(struct _carl9170_tx_status))
+
+#define	CARL9170_TX_MAX_RATE_TRIES	7
+
+#define	CARL9170_TX_MAX_RATES		4
+#define	CARL9170_TX_MAX_RETRY_RATES	(CARL9170_TX_MAX_RATES - 1)
+#define	CARL9170_ERR_MAGIC		"ERR:"
+#define	CARL9170_BUG_MAGIC		"BUG:"
+
+struct carl9170_gpio {
+	__le32 gpio;
+} __packed;
+#define CARL9170_GPIO_SIZE		4
+
+struct carl9170_tsf_rsp {
+	union {
+		__le32 tsf[2];
+		__le64 tsf_64;
+	} __packed;
+} __packed;
+#define CARL9170_TSF_RSP_SIZE		8
+
+struct carl9170_rsp {
+	struct carl9170_cmd_head hdr;
+
+	union {
+		struct carl9170_rf_init_result	rf_init_res;
+		struct carl9170_u32_list	rreg_res;
+		struct carl9170_u32_list	echo;
+		struct carl9170_tx_status	tx_status[0];
+		struct _carl9170_tx_status	_tx_status[0];
+		struct carl9170_gpio		gpio;
+		struct carl9170_tsf_rsp		tsf;
+		struct carl9170_psm		psm;
+		u8 data[CARL9170_MAX_CMD_PAYLOAD_LEN];
+	} __packed;
+} __packed;
+
+#endif /* __CARL9170_SHARED_FWCMD_H */
diff --git a/drivers/net/wireless/ath/carl9170/fwdesc.h b/drivers/net/wireless/ath/carl9170/fwdesc.h
new file mode 100644
index 0000000..71f3821
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/fwdesc.h
@@ -0,0 +1,241 @@
+/*
+ * Shared CARL9170 Header
+ *
+ * Firmware descriptor format
+ *
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ */
+
+#ifndef __CARL9170_SHARED_FWDESC_H
+#define __CARL9170_SHARED_FWDESC_H
+
+/* NOTE: Don't mess with the order of the flags! */
+enum carl9170fw_feature_list {
+	/* Always set */
+	CARL9170FW_DUMMY_FEATURE,
+
+	/*
+	 * Indicates that this image has special boot block which prevents
+	 * legacy drivers to drive the firmware.
+	 */
+	CARL9170FW_MINIBOOT,
+
+	/* usb registers are initialized by the firmware */
+	CARL9170FW_USB_INIT_FIRMWARE,
+
+	/* command traps & notifications are send through EP2 */
+	CARL9170FW_USB_RESP_EP2,
+
+	/* usb download (app -> fw) stream */
+	CARL9170FW_USB_DOWN_STREAM,
+
+	/* usb upload (fw -> app) stream */
+	CARL9170FW_USB_UP_STREAM,
+
+	/* unusable - reserved to flag non-functional debug firmwares */
+	CARL9170FW_UNUSABLE,
+
+	/* AR9170_CMD_RF_INIT, AR9170_CMD_FREQ_START, AR9170_CMD_FREQUENCY */
+	CARL9170FW_COMMAND_PHY,
+
+	/* AR9170_CMD_EKEY, AR9170_CMD_DKEY */
+	CARL9170FW_COMMAND_CAM,
+
+	/* Firmware has a software Content After Beacon Queueing mechanism */
+	CARL9170FW_WLANTX_CAB,
+
+	/* The firmware is capable of responding to incoming BAR frames */
+	CARL9170FW_HANDLE_BACK_REQ,
+
+	/* GPIO Interrupt | CARL9170_RSP_GPIO */
+	CARL9170FW_GPIO_INTERRUPT,
+
+	/* Firmware PSM support | CARL9170_CMD_PSM */
+	CARL9170FW_PSM,
+
+	/* Firmware RX filter | CARL9170_CMD_RX_FILTER */
+	CARL9170FW_RX_FILTER,
+
+	/* KEEP LAST */
+	__CARL9170FW_FEATURE_NUM
+};
+
+#define OTUS_MAGIC	"OTAR"
+#define MOTD_MAGIC	"MOTD"
+#define FIX_MAGIC	"FIX\0"
+#define DBG_MAGIC	"DBG\0"
+#define CHK_MAGIC	"CHK\0"
+#define LAST_MAGIC	"LAST"
+
+#define CARL9170FW_SET_DAY(d) (((d) - 1) % 31)
+#define CARL9170FW_SET_MONTH(m) ((((m) - 1) % 12) * 31)
+#define CARL9170FW_SET_YEAR(y) (((y) - 10) * 372)
+
+#define CARL9170FW_GET_DAY(d) (((d) % 31) + 1)
+#define CARL9170FW_GET_MONTH(m) ((((m) / 31) % 12) + 1)
+#define CARL9170FW_GET_YEAR(y) ((y) / 372 + 10)
+
+struct carl9170fw_desc_head {
+	u8	magic[4];
+	__le16 length;
+	u8 min_ver;
+	u8 cur_ver;
+} __packed;
+#define CARL9170FW_DESC_HEAD_SIZE			\
+	(sizeof(struct carl9170fw_desc_head))
+
+#define CARL9170FW_OTUS_DESC_MIN_VER		6
+#define CARL9170FW_OTUS_DESC_CUR_VER		6
+struct carl9170fw_otus_desc {
+	struct carl9170fw_desc_head head;
+	__le32 feature_set;
+	__le32 fw_address;
+	__le32 bcn_addr;
+	__le16 bcn_len;
+	__le16 miniboot_size;
+	__le16 tx_frag_len;
+	__le16 rx_max_frame_len;
+	u8 tx_descs;
+	u8 cmd_bufs;
+	u8 api_ver;
+	u8 vif_num;
+} __packed;
+#define CARL9170FW_OTUS_DESC_SIZE			\
+	(sizeof(struct carl9170fw_otus_desc))
+
+#define CARL9170FW_MOTD_STRING_LEN			24
+#define CARL9170FW_MOTD_RELEASE_LEN			20
+#define CARL9170FW_MOTD_DESC_MIN_VER			1
+#define CARL9170FW_MOTD_DESC_CUR_VER			2
+struct carl9170fw_motd_desc {
+	struct carl9170fw_desc_head head;
+	__le32 fw_year_month_day;
+	char desc[CARL9170FW_MOTD_STRING_LEN];
+	char release[CARL9170FW_MOTD_RELEASE_LEN];
+} __packed;
+#define CARL9170FW_MOTD_DESC_SIZE			\
+	(sizeof(struct carl9170fw_motd_desc))
+
+#define CARL9170FW_FIX_DESC_MIN_VER			1
+#define CARL9170FW_FIX_DESC_CUR_VER			2
+struct carl9170fw_fix_entry {
+	__le32 address;
+	__le32 mask;
+	__le32 value;
+} __packed;
+
+struct carl9170fw_fix_desc {
+	struct carl9170fw_desc_head head;
+	struct carl9170fw_fix_entry data[0];
+} __packed;
+#define CARL9170FW_FIX_DESC_SIZE			\
+	(sizeof(struct carl9170fw_fix_desc))
+
+#define CARL9170FW_DBG_DESC_MIN_VER			1
+#define CARL9170FW_DBG_DESC_CUR_VER			3
+struct carl9170fw_dbg_desc {
+	struct carl9170fw_desc_head head;
+
+	__le32 bogoclock_addr;
+	__le32 counter_addr;
+	__le32 rx_total_addr;
+	__le32 rx_overrun_addr;
+	__le32 rx_filter;
+
+	/* Put your debugging definitions here */
+} __packed;
+#define CARL9170FW_DBG_DESC_SIZE			\
+	(sizeof(struct carl9170fw_dbg_desc))
+
+#define CARL9170FW_CHK_DESC_MIN_VER			1
+#define CARL9170FW_CHK_DESC_CUR_VER			2
+struct carl9170fw_chk_desc {
+	struct carl9170fw_desc_head head;
+	__le32 fw_crc32;
+	__le32 hdr_crc32;
+} __packed;
+#define CARL9170FW_CHK_DESC_SIZE			\
+	(sizeof(struct carl9170fw_chk_desc))
+
+#define CARL9170FW_LAST_DESC_MIN_VER			1
+#define CARL9170FW_LAST_DESC_CUR_VER			2
+struct carl9170fw_last_desc {
+	struct carl9170fw_desc_head head;
+} __packed;
+#define CARL9170FW_LAST_DESC_SIZE			\
+	(sizeof(struct carl9170fw_fix_desc))
+
+#define CARL9170FW_DESC_MAX_LENGTH			8192
+
+#define CARL9170FW_FILL_DESC(_magic, _length, _min_ver, _cur_ver)	\
+	.head = {							\
+		.magic = _magic,					\
+		.length = cpu_to_le16(_length),				\
+		.min_ver = _min_ver,					\
+		.cur_ver = _cur_ver,					\
+	}
+
+static inline void carl9170fw_fill_desc(struct carl9170fw_desc_head *head,
+					 u8 magic[4], __le16 length,
+					 u8 min_ver, u8 cur_ver)
+{
+	head->magic[0] = magic[0];
+	head->magic[1] = magic[1];
+	head->magic[2] = magic[2];
+	head->magic[3] = magic[3];
+
+	head->length = length;
+	head->min_ver = min_ver;
+	head->cur_ver = cur_ver;
+}
+
+#define carl9170fw_for_each_hdr(desc, fw_desc)				\
+	for (desc = fw_desc;						\
+	     memcmp(desc->magic, LAST_MAGIC, 4) &&			\
+	     le16_to_cpu(desc->length) >= CARL9170FW_DESC_HEAD_SIZE &&	\
+	     le16_to_cpu(desc->length) < CARL9170FW_DESC_MAX_LENGTH;	\
+	     desc = (void *)((unsigned long)desc + le16_to_cpu(desc->length)))
+
+#define CHECK_HDR_VERSION(head, _min_ver)				\
+	(((head)->cur_ver < _min_ver) || ((head)->min_ver > _min_ver))	\
+
+static inline bool carl9170fw_supports(__le32 list, u8 feature)
+{
+	return le32_to_cpu(list) & BIT(feature);
+}
+
+static inline bool carl9170fw_desc_cmp(const struct carl9170fw_desc_head *head,
+				       const u8 descid[4], u16 min_len,
+				       u8 compatible_revision)
+{
+	if (descid[0] == head->magic[0] && descid[1] == head->magic[1] &&
+	    descid[2] == head->magic[2] && descid[3] == head->magic[3] &&
+	    !CHECK_HDR_VERSION(head, compatible_revision) &&
+	    (le16_to_cpu(head->length) >= min_len))
+		return true;
+
+	return false;
+}
+
+#define CARL9170FW_MIN_SIZE	32
+#define CARL9170FW_MAX_SIZE	16384
+
+static inline bool carl9170fw_size_check(unsigned int len)
+{
+	return (len <= CARL9170FW_MAX_SIZE && len >= CARL9170FW_MIN_SIZE);
+}
+
+#endif /* __CARL9170_SHARED_FWDESC_H */
diff --git a/drivers/net/wireless/ath/carl9170/hw.h b/drivers/net/wireless/ath/carl9170/hw.h
new file mode 100644
index 0000000..2f471b3
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/hw.h
@@ -0,0 +1,739 @@
+/*
+ * Shared Atheros AR9170 Header
+ *
+ * Register map, hardware-specific definitions
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __CARL9170_SHARED_HW_H
+#define __CARL9170_SHARED_HW_H
+
+/* High Speed UART */
+#define	AR9170_UART_REG_BASE			0x1c0000
+
+/* Definitions of interrupt registers */
+#define	AR9170_UART_REG_RX_BUFFER		(AR9170_UART_REG_BASE + 0x000)
+#define	AR9170_UART_REG_TX_HOLDING		(AR9170_UART_REG_BASE + 0x004)
+#define	AR9170_UART_REG_FIFO_CONTROL		(AR9170_UART_REG_BASE + 0x010)
+#define		AR9170_UART_FIFO_CTRL_RESET_RX_FIFO	0x02
+#define		AR9170_UART_FIFO_CTRL_RESET_TX_FIFO	0x04
+
+#define	AR9170_UART_REG_LINE_CONTROL		(AR9170_UART_REG_BASE + 0x014)
+#define	AR9170_UART_REG_MODEM_CONTROL		(AR9170_UART_REG_BASE + 0x018)
+#define		AR9170_UART_MODEM_CTRL_DTR_BIT		0x01
+#define		AR9170_UART_MODEM_CTRL_RTS_BIT		0x02
+#define		AR9170_UART_MODEM_CTRL_INTERNAL_LOOP_BACK	0x10
+#define		AR9170_UART_MODEM_CTRL_AUTO_RTS		0x20
+#define		AR9170_UART_MODEM_CTRL_AUTO_CTR		0x40
+
+#define	AR9170_UART_REG_LINE_STATUS		(AR9170_UART_REG_BASE + 0x01c)
+#define		AR9170_UART_LINE_STS_RX_DATA_READY	0x01
+#define		AR9170_UART_LINE_STS_RX_BUFFER_OVERRUN	0x02
+#define		AR9170_UART_LINE_STS_RX_BREAK_IND	0x10
+#define		AR9170_UART_LINE_STS_TX_FIFO_NEAR_EMPTY	0x20
+#define		AR9170_UART_LINE_STS_TRANSMITTER_EMPTY	0x40
+
+#define	AR9170_UART_REG_MODEM_STATUS		(AR9170_UART_REG_BASE + 0x020)
+#define		AR9170_UART_MODEM_STS_CTS_CHANGE	0x01
+#define		AR9170_UART_MODEM_STS_DSR_CHANGE	0x02
+#define		AR9170_UART_MODEM_STS_DCD_CHANGE	0x08
+#define		AR9170_UART_MODEM_STS_CTS_COMPL		0x10
+#define		AR9170_UART_MODEM_STS_DSR_COMPL		0x20
+#define		AR9170_UART_MODEM_STS_DCD_COMPL		0x80
+
+#define	AR9170_UART_REG_SCRATCH			(AR9170_UART_REG_BASE + 0x024)
+#define	AR9170_UART_REG_DIVISOR_LSB		(AR9170_UART_REG_BASE + 0x028)
+#define	AR9170_UART_REG_DIVISOR_MSB		(AR9170_UART_REG_BASE + 0x02c)
+#define	AR9170_UART_REG_WORD_RX_BUFFER		(AR9170_UART_REG_BASE + 0x034)
+#define	AR9170_UART_REG_WORD_TX_HOLDING		(AR9170_UART_REG_BASE + 0x038)
+#define	AR9170_UART_REG_FIFO_COUNT		(AR9170_UART_REG_BASE + 0x03c)
+#define	AR9170_UART_REG_REMAINDER		(AR9170_UART_REG_BASE + 0x04c)
+
+/* Timer */
+#define	AR9170_TIMER_REG_BASE			0x1c1000
+
+#define	AR9170_TIMER_REG_WATCH_DOG		(AR9170_TIMER_REG_BASE + 0x000)
+#define	AR9170_TIMER_REG_TIMER0			(AR9170_TIMER_REG_BASE + 0x010)
+#define	AR9170_TIMER_REG_TIMER1			(AR9170_TIMER_REG_BASE + 0x014)
+#define	AR9170_TIMER_REG_TIMER2			(AR9170_TIMER_REG_BASE + 0x018)
+#define	AR9170_TIMER_REG_TIMER3			(AR9170_TIMER_REG_BASE + 0x01c)
+#define	AR9170_TIMER_REG_TIMER4			(AR9170_TIMER_REG_BASE + 0x020)
+#define	AR9170_TIMER_REG_CONTROL		(AR9170_TIMER_REG_BASE + 0x024)
+#define		AR9170_TIMER_CTRL_DISABLE_CLOCK		0x100
+
+#define	AR9170_TIMER_REG_INTERRUPT		(AR9170_TIMER_REG_BASE + 0x028)
+#define		AR9170_TIMER_INT_TIMER0			0x001
+#define		AR9170_TIMER_INT_TIMER1			0x002
+#define		AR9170_TIMER_INT_TIMER2			0x004
+#define		AR9170_TIMER_INT_TIMER3			0x008
+#define		AR9170_TIMER_INT_TIMER4			0x010
+#define		AR9170_TIMER_INT_TICK_TIMER		0x100
+
+#define	AR9170_TIMER_REG_TICK_TIMER		(AR9170_TIMER_REG_BASE + 0x030)
+#define	AR9170_TIMER_REG_CLOCK_LOW		(AR9170_TIMER_REG_BASE + 0x040)
+#define	AR9170_TIMER_REG_CLOCK_HIGH		(AR9170_TIMER_REG_BASE + 0x044)
+
+#define	AR9170_MAC_REG_BASE			0x1c3000
+
+#define	AR9170_MAC_REG_POWER_STATE_CTRL		(AR9170_MAC_REG_BASE + 0x500)
+#define		AR9170_MAC_POWER_STATE_CTRL_RESET	0x20
+
+#define	AR9170_MAC_REG_MAC_POWER_STATE_CTRL	(AR9170_MAC_REG_BASE + 0x50c)
+
+#define	AR9170_MAC_REG_INT_CTRL			(AR9170_MAC_REG_BASE + 0x510)
+#define		AR9170_MAC_INT_TXC			BIT(0)
+#define		AR9170_MAC_INT_RXC			BIT(1)
+#define		AR9170_MAC_INT_RETRY_FAIL		BIT(2)
+#define		AR9170_MAC_INT_WAKEUP			BIT(3)
+#define		AR9170_MAC_INT_ATIM			BIT(4)
+#define		AR9170_MAC_INT_DTIM			BIT(5)
+#define		AR9170_MAC_INT_CFG_BCN			BIT(6)
+#define		AR9170_MAC_INT_ABORT			BIT(7)
+#define		AR9170_MAC_INT_QOS			BIT(8)
+#define		AR9170_MAC_INT_MIMO_PS			BIT(9)
+#define		AR9170_MAC_INT_KEY_GEN			BIT(10)
+#define		AR9170_MAC_INT_DECRY_NOUSER		BIT(11)
+#define		AR9170_MAC_INT_RADAR			BIT(12)
+#define		AR9170_MAC_INT_QUIET_FRAME		BIT(13)
+#define		AR9170_MAC_INT_PRETBTT			BIT(14)
+
+#define	AR9170_MAC_REG_TSF_L			(AR9170_MAC_REG_BASE + 0x514)
+#define	AR9170_MAC_REG_TSF_H			(AR9170_MAC_REG_BASE + 0x518)
+
+#define	AR9170_MAC_REG_ATIM_WINDOW		(AR9170_MAC_REG_BASE + 0x51c)
+#define		AR9170_MAC_ATIM_PERIOD_S		0
+#define		AR9170_MAC_ATIM_PERIOD			0x0000ffff
+
+#define	AR9170_MAC_REG_BCN_PERIOD		(AR9170_MAC_REG_BASE + 0x520)
+#define		AR9170_MAC_BCN_PERIOD_S			0
+#define		AR9170_MAC_BCN_PERIOD			0x0000ffff
+#define		AR9170_MAC_BCN_DTIM_S			16
+#define		AR9170_MAC_BCN_DTIM			0x00ff0000
+#define		AR9170_MAC_BCN_AP_MODE			BIT(24)
+#define		AR9170_MAC_BCN_IBSS_MODE		BIT(25)
+#define		AR9170_MAC_BCN_PWR_MGT			BIT(26)
+#define		AR9170_MAC_BCN_STA_PS			BIT(27)
+
+#define	AR9170_MAC_REG_PRETBTT			(AR9170_MAC_REG_BASE + 0x524)
+#define		AR9170_MAC_PRETBTT_S			0
+#define		AR9170_MAC_PRETBTT			0x0000ffff
+#define		AR9170_MAC_PRETBTT2_S			16
+#define		AR9170_MAC_PRETBTT2			0xffff0000
+
+#define	AR9170_MAC_REG_MAC_ADDR_L		(AR9170_MAC_REG_BASE + 0x610)
+#define	AR9170_MAC_REG_MAC_ADDR_H		(AR9170_MAC_REG_BASE + 0x614)
+#define	AR9170_MAC_REG_BSSID_L			(AR9170_MAC_REG_BASE + 0x618)
+#define	AR9170_MAC_REG_BSSID_H			(AR9170_MAC_REG_BASE + 0x61c)
+
+#define	AR9170_MAC_REG_GROUP_HASH_TBL_L		(AR9170_MAC_REG_BASE + 0x624)
+#define	AR9170_MAC_REG_GROUP_HASH_TBL_H		(AR9170_MAC_REG_BASE + 0x628)
+
+#define	AR9170_MAC_REG_RX_TIMEOUT		(AR9170_MAC_REG_BASE + 0x62c)
+
+#define	AR9170_MAC_REG_BASIC_RATE		(AR9170_MAC_REG_BASE + 0x630)
+#define	AR9170_MAC_REG_MANDATORY_RATE		(AR9170_MAC_REG_BASE + 0x634)
+#define	AR9170_MAC_REG_RTS_CTS_RATE		(AR9170_MAC_REG_BASE + 0x638)
+#define	AR9170_MAC_REG_BACKOFF_PROTECT		(AR9170_MAC_REG_BASE + 0x63c)
+#define	AR9170_MAC_REG_RX_THRESHOLD		(AR9170_MAC_REG_BASE + 0x640)
+#define	AR9170_MAC_REG_AFTER_PNP		(AR9170_MAC_REG_BASE + 0x648)
+#define	AR9170_MAC_REG_RX_PE_DELAY		(AR9170_MAC_REG_BASE + 0x64c)
+
+#define	AR9170_MAC_REG_DYNAMIC_SIFS_ACK		(AR9170_MAC_REG_BASE + 0x658)
+#define	AR9170_MAC_REG_SNIFFER			(AR9170_MAC_REG_BASE + 0x674)
+#define		AR9170_MAC_SNIFFER_ENABLE_PROMISC	BIT(0)
+#define		AR9170_MAC_SNIFFER_DEFAULTS		0x02000000
+#define	AR9170_MAC_REG_ENCRYPTION		(AR9170_MAC_REG_BASE + 0x678)
+#define		AR9170_MAC_ENCRYPTION_RX_SOFTWARE	BIT(3)
+#define		AR9170_MAC_ENCRYPTION_DEFAULTS		0x70
+
+#define	AR9170_MAC_REG_MISC_680			(AR9170_MAC_REG_BASE + 0x680)
+#define	AR9170_MAC_REG_MISC_684			(AR9170_MAC_REG_BASE + 0x684)
+#define	AR9170_MAC_REG_TX_UNDERRUN		(AR9170_MAC_REG_BASE + 0x688)
+
+#define	AR9170_MAC_REG_FRAMETYPE_FILTER		(AR9170_MAC_REG_BASE + 0x68c)
+#define		AR9170_MAC_FTF_ASSOC_REQ		BIT(0)
+#define		AR9170_MAC_FTF_ASSOC_RESP		BIT(1)
+#define		AR9170_MAC_FTF_REASSOC_REQ		BIT(2)
+#define		AR9170_MAC_FTF_REASSOC_RESP		BIT(3)
+#define		AR9170_MAC_FTF_PRB_REQ			BIT(4)
+#define		AR9170_MAC_FTF_PRB_RESP			BIT(5)
+#define		AR9170_MAC_FTF_BIT6			BIT(6)
+#define		AR9170_MAC_FTF_BIT7			BIT(7)
+#define		AR9170_MAC_FTF_BEACON			BIT(8)
+#define		AR9170_MAC_FTF_ATIM			BIT(9)
+#define		AR9170_MAC_FTF_DEASSOC			BIT(10)
+#define		AR9170_MAC_FTF_AUTH			BIT(11)
+#define		AR9170_MAC_FTF_DEAUTH			BIT(12)
+#define		AR9170_MAC_FTF_BIT13			BIT(13)
+#define		AR9170_MAC_FTF_BIT14			BIT(14)
+#define		AR9170_MAC_FTF_BIT15			BIT(15)
+#define		AR9170_MAC_FTF_BAR			BIT(24)
+#define		AR9170_MAC_FTF_BA			BIT(25)
+#define		AR9170_MAC_FTF_PSPOLL			BIT(26)
+#define		AR9170_MAC_FTF_RTS			BIT(27)
+#define		AR9170_MAC_FTF_CTS			BIT(28)
+#define		AR9170_MAC_FTF_ACK			BIT(29)
+#define		AR9170_MAC_FTF_CFE			BIT(30)
+#define		AR9170_MAC_FTF_CFE_ACK			BIT(31)
+#define		AR9170_MAC_FTF_DEFAULTS			0x0500ffff
+#define		AR9170_MAC_FTF_MONITOR			0xff00ffff
+
+#define	AR9170_MAC_REG_ACK_EXTENSION		(AR9170_MAC_REG_BASE + 0x690)
+#define	AR9170_MAC_REG_ACK_TPC			(AR9170_MAC_REG_BASE + 0x694)
+#define	AR9170_MAC_REG_EIFS_AND_SIFS		(AR9170_MAC_REG_BASE + 0x698)
+#define	AR9170_MAC_REG_RX_TIMEOUT_COUNT		(AR9170_MAC_REG_BASE + 0x69c)
+#define	AR9170_MAC_REG_RX_TOTAL			(AR9170_MAC_REG_BASE + 0x6a0)
+#define	AR9170_MAC_REG_RX_CRC32			(AR9170_MAC_REG_BASE + 0x6a4)
+#define	AR9170_MAC_REG_RX_CRC16			(AR9170_MAC_REG_BASE + 0x6a8)
+#define	AR9170_MAC_REG_RX_ERR_DECRYPTION_UNI	(AR9170_MAC_REG_BASE + 0x6ac)
+#define	AR9170_MAC_REG_RX_OVERRUN		(AR9170_MAC_REG_BASE + 0x6b0)
+#define	AR9170_MAC_REG_RX_ERR_DECRYPTION_MUL	(AR9170_MAC_REG_BASE + 0x6bc)
+#define AR9170_MAC_REG_TX_BLOCKACKS		(AR9170_MAC_REG_BASE + 0x6c0)
+#define AR9170_MAC_REG_NAV_COUNT		(AR9170_MAC_REG_BASE + 0x6c4)
+#define AR9170_MAC_REG_BACKOFF_STATUS		(AR9170_MAC_REG_BASE + 0x6c8)
+#define	AR9170_MAC_REG_TX_RETRY			(AR9170_MAC_REG_BASE + 0x6cc)
+
+#define AR9170_MAC_REG_TX_COMPLETE		(AR9170_MAC_REG_BASE + 0x6d4)
+
+#define	AR9170_MAC_REG_CHANNEL_BUSY		(AR9170_MAC_REG_BASE + 0x6e8)
+#define	AR9170_MAC_REG_EXT_BUSY			(AR9170_MAC_REG_BASE + 0x6ec)
+
+#define	AR9170_MAC_REG_SLOT_TIME		(AR9170_MAC_REG_BASE + 0x6f0)
+#define	AR9170_MAC_REG_TX_TOTAL			(AR9170_MAC_REG_BASE + 0x6f4)
+#define AR9170_MAC_REG_ACK_FC			(AR9170_MAC_REG_BASE + 0x6f8)
+
+#define	AR9170_MAC_REG_CAM_MODE			(AR9170_MAC_REG_BASE + 0x700)
+#define		AR9170_MAC_CAM_IBSS			0xe0
+#define		AR9170_MAC_CAM_AP			0xa1
+#define		AR9170_MAC_CAM_STA			0x2
+#define		AR9170_MAC_CAM_AP_WDS			0x3
+#define		AR9170_MAC_CAM_DEFAULTS			(0xf << 24)
+#define		AR9170_MAC_CAM_HOST_PENDING		0x80000000
+
+#define	AR9170_MAC_REG_CAM_ROLL_CALL_TBL_L	(AR9170_MAC_REG_BASE + 0x704)
+#define	AR9170_MAC_REG_CAM_ROLL_CALL_TBL_H	(AR9170_MAC_REG_BASE + 0x708)
+
+#define	AR9170_MAC_REG_CAM_ADDR			(AR9170_MAC_REG_BASE + 0x70c)
+#define		AR9170_MAC_CAM_ADDR_WRITE		0x80000000
+#define	AR9170_MAC_REG_CAM_DATA0		(AR9170_MAC_REG_BASE + 0x720)
+#define	AR9170_MAC_REG_CAM_DATA1		(AR9170_MAC_REG_BASE + 0x724)
+#define	AR9170_MAC_REG_CAM_DATA2		(AR9170_MAC_REG_BASE + 0x728)
+#define	AR9170_MAC_REG_CAM_DATA3		(AR9170_MAC_REG_BASE + 0x72c)
+
+#define	AR9170_MAC_REG_CAM_DBG0			(AR9170_MAC_REG_BASE + 0x730)
+#define	AR9170_MAC_REG_CAM_DBG1			(AR9170_MAC_REG_BASE + 0x734)
+#define	AR9170_MAC_REG_CAM_DBG2			(AR9170_MAC_REG_BASE + 0x738)
+#define	AR9170_MAC_REG_CAM_STATE		(AR9170_MAC_REG_BASE + 0x73c)
+#define		AR9170_MAC_CAM_STATE_READ_PENDING	0x40000000
+#define		AR9170_MAC_CAM_STATE_WRITE_PENDING	0x80000000
+
+#define	AR9170_MAC_REG_CAM_TXKEY		(AR9170_MAC_REG_BASE + 0x740)
+#define	AR9170_MAC_REG_CAM_RXKEY		(AR9170_MAC_REG_BASE + 0x750)
+
+#define	AR9170_MAC_REG_CAM_TX_ENC_TYPE		(AR9170_MAC_REG_BASE + 0x760)
+#define	AR9170_MAC_REG_CAM_RX_ENC_TYPE		(AR9170_MAC_REG_BASE + 0x770)
+#define	AR9170_MAC_REG_CAM_TX_SERACH_HIT	(AR9170_MAC_REG_BASE + 0x780)
+#define	AR9170_MAC_REG_CAM_RX_SERACH_HIT	(AR9170_MAC_REG_BASE + 0x790)
+
+#define	AR9170_MAC_REG_AC0_CW			(AR9170_MAC_REG_BASE + 0xb00)
+#define	AR9170_MAC_REG_AC1_CW			(AR9170_MAC_REG_BASE + 0xb04)
+#define	AR9170_MAC_REG_AC2_CW			(AR9170_MAC_REG_BASE + 0xb08)
+#define	AR9170_MAC_REG_AC3_CW			(AR9170_MAC_REG_BASE + 0xb0c)
+#define	AR9170_MAC_REG_AC4_CW			(AR9170_MAC_REG_BASE + 0xb10)
+#define	AR9170_MAC_REG_AC2_AC1_AC0_AIFS		(AR9170_MAC_REG_BASE + 0xb14)
+#define	AR9170_MAC_REG_AC4_AC3_AC2_AIFS		(AR9170_MAC_REG_BASE + 0xb18)
+#define AR9170_MAC_REG_TXOP_ACK_EXTENSION	(AR9170_MAC_REG_BASE + 0xb1c)
+#define AR9170_MAC_REG_TXOP_ACK_INTERVAL	(AR9170_MAC_REG_BASE + 0xb20)
+#define AR9170_MAC_REG_CONTENTION_POINT		(AR9170_MAC_REG_BASE + 0xb24)
+#define	AR9170_MAC_REG_RETRY_MAX		(AR9170_MAC_REG_BASE + 0xb28)
+#define AR9170_MAC_REG_TID_CFACK_CFEND_RATE	(AR9170_MAC_REG_BASE + 0xb2c)
+#define	AR9170_MAC_REG_TXOP_NOT_ENOUGH_IND	(AR9170_MAC_REG_BASE + 0xb30)
+#define AR9170_MAC_REG_TKIP_TSC			(AR9170_MAC_REG_BASE + 0xb34)
+#define AR9170_MAC_REG_TXOP_DURATION		(AR9170_MAC_REG_BASE + 0xb38)
+#define AR9170_MAC_REG_TX_QOS_THRESHOLD		(AR9170_MAC_REG_BASE + 0xb3c)
+#define	AR9170_MAC_REG_QOS_PRIORITY_VIRTUAL_CCA	(AR9170_MAC_REG_BASE + 0xb40)
+#define		AR9170_MAC_VIRTUAL_CCA_Q0		BIT(15)
+#define		AR9170_MAC_VIRTUAL_CCA_Q1		BIT(16)
+#define		AR9170_MAC_VIRTUAL_CCA_Q2		BIT(17)
+#define		AR9170_MAC_VIRTUAL_CCA_Q3		BIT(18)
+#define		AR9170_MAC_VIRTUAL_CCA_Q4		BIT(19)
+#define		AR9170_MAC_VIRTUAL_CCA_ALL		(0xf8000)
+
+#define	AR9170_MAC_REG_AC1_AC0_TXOP		(AR9170_MAC_REG_BASE + 0xb44)
+#define	AR9170_MAC_REG_AC3_AC2_TXOP		(AR9170_MAC_REG_BASE + 0xb48)
+
+#define	AR9170_MAC_REG_AMPDU_COUNT		(AR9170_MAC_REG_BASE + 0xb88)
+#define	AR9170_MAC_REG_MPDU_COUNT		(AR9170_MAC_REG_BASE + 0xb8c)
+
+#define	AR9170_MAC_REG_AMPDU_FACTOR		(AR9170_MAC_REG_BASE + 0xb9c)
+#define		AR9170_MAC_AMPDU_FACTOR			0x7f0000
+#define		AR9170_MAC_AMPDU_FACTOR_S		16
+#define	AR9170_MAC_REG_AMPDU_DENSITY		(AR9170_MAC_REG_BASE + 0xba0)
+#define		AR9170_MAC_AMPDU_DENSITY		0x7
+#define		AR9170_MAC_AMPDU_DENSITY_S		0
+
+#define	AR9170_MAC_REG_FCS_SELECT		(AR9170_MAC_REG_BASE + 0xbb0)
+#define		AR9170_MAC_FCS_SWFCS			0x1
+#define		AR9170_MAC_FCS_FIFO_PROT		0x4
+
+#define	AR9170_MAC_REG_RTS_CTS_TPC		(AR9170_MAC_REG_BASE + 0xbb4)
+#define AR9170_MAC_REG_CFEND_QOSNULL_TPC	(AR9170_MAC_REG_BASE + 0xbb8)
+
+#define	AR9170_MAC_REG_ACK_TABLE		(AR9170_MAC_REG_BASE + 0xc00)
+#define AR9170_MAC_REG_RX_CONTROL		(AR9170_MAC_REG_BASE + 0xc40)
+#define		AR9170_MAC_RX_CTRL_DEAGG		0x1
+#define		AR9170_MAC_RX_CTRL_SHORT_FILTER		0x2
+#define		AR9170_MAC_RX_CTRL_SA_DA_SEARCH		0x20
+#define		AR9170_MAC_RX_CTRL_PASS_TO_HOST		BIT(28)
+#define		AR9170_MAC_RX_CTRL_ACK_IN_SNIFFER	BIT(30)
+
+#define AR9170_MAC_REG_RX_CONTROL_1		(AR9170_MAC_REG_BASE + 0xc44)
+
+#define	AR9170_MAC_REG_AMPDU_RX_THRESH		(AR9170_MAC_REG_BASE + 0xc50)
+
+#define	AR9170_MAC_REG_RX_MPDU			(AR9170_MAC_REG_BASE + 0xca0)
+#define	AR9170_MAC_REG_RX_DROPPED_MPDU		(AR9170_MAC_REG_BASE + 0xca4)
+#define	AR9170_MAC_REG_RX_DEL_MPDU		(AR9170_MAC_REG_BASE + 0xca8)
+#define	AR9170_MAC_REG_RX_PHY_MISC_ERROR	(AR9170_MAC_REG_BASE + 0xcac)
+#define	AR9170_MAC_REG_RX_PHY_XR_ERROR		(AR9170_MAC_REG_BASE + 0xcb0)
+#define	AR9170_MAC_REG_RX_PHY_OFDM_ERROR	(AR9170_MAC_REG_BASE + 0xcb4)
+#define	AR9170_MAC_REG_RX_PHY_CCK_ERROR		(AR9170_MAC_REG_BASE + 0xcb8)
+#define	AR9170_MAC_REG_RX_PHY_HT_ERROR		(AR9170_MAC_REG_BASE + 0xcbc)
+#define	AR9170_MAC_REG_RX_PHY_TOTAL		(AR9170_MAC_REG_BASE + 0xcc0)
+
+#define	AR9170_MAC_REG_DMA_TXQ_ADDR		(AR9170_MAC_REG_BASE + 0xd00)
+#define	AR9170_MAC_REG_DMA_TXQ_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd04)
+#define	AR9170_MAC_REG_DMA_TXQ0_ADDR		(AR9170_MAC_REG_BASE + 0xd00)
+#define	AR9170_MAC_REG_DMA_TXQ0_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd04)
+#define	AR9170_MAC_REG_DMA_TXQ1_ADDR		(AR9170_MAC_REG_BASE + 0xd08)
+#define	AR9170_MAC_REG_DMA_TXQ1_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd0c)
+#define	AR9170_MAC_REG_DMA_TXQ2_ADDR		(AR9170_MAC_REG_BASE + 0xd10)
+#define	AR9170_MAC_REG_DMA_TXQ2_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd14)
+#define	AR9170_MAC_REG_DMA_TXQ3_ADDR		(AR9170_MAC_REG_BASE + 0xd18)
+#define	AR9170_MAC_REG_DMA_TXQ3_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd1c)
+#define	AR9170_MAC_REG_DMA_TXQ4_ADDR		(AR9170_MAC_REG_BASE + 0xd20)
+#define	AR9170_MAC_REG_DMA_TXQ4_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd24)
+#define	AR9170_MAC_REG_DMA_RXQ_ADDR		(AR9170_MAC_REG_BASE + 0xd28)
+#define	AR9170_MAC_REG_DMA_RXQ_CURR_ADDR	(AR9170_MAC_REG_BASE + 0xd2c)
+
+#define	AR9170_MAC_REG_DMA_TRIGGER		(AR9170_MAC_REG_BASE + 0xd30)
+#define		AR9170_DMA_TRIGGER_TXQ0			BIT(0)
+#define		AR9170_DMA_TRIGGER_TXQ1			BIT(1)
+#define		AR9170_DMA_TRIGGER_TXQ2			BIT(2)
+#define		AR9170_DMA_TRIGGER_TXQ3			BIT(3)
+#define		AR9170_DMA_TRIGGER_TXQ4			BIT(4)
+#define		AR9170_DMA_TRIGGER_RXQ			BIT(8)
+
+#define AR9170_MAC_REG_DMA_WLAN_STATUS		(AR9170_MAC_REG_BASE + 0xd38)
+#define	AR9170_MAC_REG_DMA_STATUS		(AR9170_MAC_REG_BASE + 0xd3c)
+
+#define	AR9170_MAC_REG_TXRX_MPI			(AR9170_MAC_REG_BASE + 0xd7c)
+#define		AR9170_MAC_TXRX_MPI_TX_MPI_MASK		0x0000000f
+#define		AR9170_MAC_TXRX_MPI_TX_TO_MASK		0x0000fff0
+#define		AR9170_MAC_TXRX_MPI_RX_MPI_MASK		0x000f0000
+#define		AR9170_MAC_TXRX_MPI_RX_TO_MASK		0xfff00000
+
+#define	AR9170_MAC_REG_BCN_ADDR			(AR9170_MAC_REG_BASE + 0xd84)
+#define	AR9170_MAC_REG_BCN_LENGTH		(AR9170_MAC_REG_BASE + 0xd88)
+#define		AR9170_MAC_BCN_LENGTH_MAX		256
+
+#define AR9170_MAC_REG_BCN_STATUS		(AR9170_MAC_REG_BASE + 0xd8c)
+
+#define	AR9170_MAC_REG_BCN_PLCP			(AR9170_MAC_REG_BASE + 0xd90)
+#define	AR9170_MAC_REG_BCN_CTRL			(AR9170_MAC_REG_BASE + 0xd94)
+#define		AR9170_BCN_CTRL_READY			0x01
+#define		AR9170_BCN_CTRL_LOCK			0x02
+
+#define AR9170_MAC_REG_BCN_CURR_ADDR		(AR9170_MAC_REG_BASE + 0xd98)
+#define	AR9170_MAC_REG_BCN_COUNT		(AR9170_MAC_REG_BASE + 0xd9c)
+
+
+#define	AR9170_MAC_REG_BCN_HT1			(AR9170_MAC_REG_BASE + 0xda0)
+#define	AR9170_MAC_REG_BCN_HT2			(AR9170_MAC_REG_BASE + 0xda4)
+
+#define	AR9170_MAC_REG_DMA_TXQX_ADDR_CURR	(AR9170_MAC_REG_BASE + 0xdc0)
+
+/* Random number generator */
+#define	AR9170_RAND_REG_BASE			0x1d0000
+
+#define	AR9170_RAND_REG_NUM			(AR9170_RAND_REG_BASE + 0x000)
+#define	AR9170_RAND_REG_MODE			(AR9170_RAND_REG_BASE + 0x004)
+#define		AR9170_RAND_MODE_MANUAL			0x000
+#define		AR9170_RAND_MODE_FREE			0x001
+
+/* GPIO */
+#define	AR9170_GPIO_REG_BASE			0x1d0100
+#define	AR9170_GPIO_REG_PORT_TYPE		(AR9170_GPIO_REG_BASE + 0x000)
+#define	AR9170_GPIO_REG_PORT_DATA		(AR9170_GPIO_REG_BASE + 0x004)
+#define		AR9170_GPIO_PORT_LED_0			1
+#define		AR9170_GPIO_PORT_LED_1			2
+/* WPS Button GPIO for TP-Link TL-WN821N */
+#define		AR9170_GPIO_PORT_WPS_BUTTON_PRESSED	4
+
+/* Memory Controller */
+#define	AR9170_MC_REG_BASE			0x1d1000
+
+#define	AR9170_MC_REG_FLASH_WAIT_STATE		(AR9170_MC_REG_BASE + 0x000)
+#define	AR9170_MC_REG_SEEPROM_WP0		(AR9170_MC_REG_BASE + 0x400)
+#define	AR9170_MC_REG_SEEPROM_WP1		(AR9170_MC_REG_BASE + 0x404)
+#define	AR9170_MC_REG_SEEPROM_WP2		(AR9170_MC_REG_BASE + 0x408)
+
+/* Interrupt Controller */
+#define	AR9170_MAX_INT_SRC			9
+#define	AR9170_INT_REG_BASE			0x1d2000
+
+#define	AR9170_INT_REG_FLAG			(AR9170_INT_REG_BASE + 0x000)
+#define	AR9170_INT_REG_FIQ_MASK			(AR9170_INT_REG_BASE + 0x004)
+#define	AR9170_INT_REG_IRQ_MASK			(AR9170_INT_REG_BASE + 0x008)
+/* INT_REG_FLAG, INT_REG_FIQ_MASK and INT_REG_IRQ_MASK */
+#define		AR9170_INT_FLAG_WLAN			0x001
+#define		AR9170_INT_FLAG_PTAB_BIT		0x002
+#define		AR9170_INT_FLAG_SE_BIT			0x004
+#define		AR9170_INT_FLAG_UART_BIT		0x008
+#define		AR9170_INT_FLAG_TIMER_BIT		0x010
+#define		AR9170_INT_FLAG_EXT_BIT			0x020
+#define		AR9170_INT_FLAG_SW_BIT			0x040
+#define		AR9170_INT_FLAG_USB_BIT			0x080
+#define		AR9170_INT_FLAG_ETHERNET_BIT		0x100
+
+#define	AR9170_INT_REG_PRIORITY1		(AR9170_INT_REG_BASE + 0x00c)
+#define	AR9170_INT_REG_PRIORITY2		(AR9170_INT_REG_BASE + 0x010)
+#define	AR9170_INT_REG_PRIORITY3		(AR9170_INT_REG_BASE + 0x014)
+#define	AR9170_INT_REG_EXT_INT_CONTROL		(AR9170_INT_REG_BASE + 0x018)
+#define	AR9170_INT_REG_SW_INT_CONTROL		(AR9170_INT_REG_BASE + 0x01c)
+#define		AR9170_INT_SW_INT_ENABLE		0x1
+
+#define	AR9170_INT_REG_FIQ_ENCODE		(AR9170_INT_REG_BASE + 0x020)
+#define	AR9170_INT_INT_IRQ_ENCODE		(AR9170_INT_REG_BASE + 0x024)
+
+/* Power Management */
+#define	AR9170_PWR_REG_BASE			0x1d4000
+
+#define AR9170_PWR_REG_POWER_STATE		(AR9170_PWR_REG_BASE + 0x000)
+
+#define	AR9170_PWR_REG_RESET			(AR9170_PWR_REG_BASE + 0x004)
+#define		AR9170_PWR_RESET_COMMIT_RESET_MASK	BIT(0)
+#define		AR9170_PWR_RESET_WLAN_MASK		BIT(1)
+#define		AR9170_PWR_RESET_DMA_MASK		BIT(2)
+#define		AR9170_PWR_RESET_BRIDGE_MASK		BIT(3)
+#define		AR9170_PWR_RESET_AHB_MASK		BIT(9)
+#define		AR9170_PWR_RESET_BB_WARM_RESET		BIT(10)
+#define		AR9170_PWR_RESET_BB_COLD_RESET		BIT(11)
+#define		AR9170_PWR_RESET_ADDA_CLK_COLD_RESET	BIT(12)
+#define		AR9170_PWR_RESET_PLL			BIT(13)
+#define		AR9170_PWR_RESET_USB_PLL		BIT(14)
+
+#define	AR9170_PWR_REG_CLOCK_SEL		(AR9170_PWR_REG_BASE + 0x008)
+#define		AR9170_PWR_CLK_AHB_40MHZ		0
+#define		AR9170_PWR_CLK_AHB_20_22MHZ		1
+#define		AR9170_PWR_CLK_AHB_40_44MHZ		2
+#define		AR9170_PWR_CLK_AHB_80_88MHZ		3
+#define		AR9170_PWR_CLK_DAC_160_INV_DLY		0x70
+
+#define	AR9170_PWR_REG_CHIP_REVISION		(AR9170_PWR_REG_BASE + 0x010)
+#define AR9170_PWR_REG_PLL_ADDAC		(AR9170_PWR_REG_BASE + 0x014)
+#define	AR9170_PWR_REG_WATCH_DOG_MAGIC		(AR9170_PWR_REG_BASE + 0x020)
+
+/* Faraday USB Controller */
+#define	AR9170_USB_REG_BASE			0x1e1000
+
+#define	AR9170_USB_REG_MAIN_CTRL		(AR9170_USB_REG_BASE + 0x000)
+#define		AR9170_USB_MAIN_CTRL_REMOTE_WAKEUP	BIT(0)
+#define		AR9170_USB_MAIN_CTRL_ENABLE_GLOBAL_INT	BIT(2)
+#define		AR9170_USB_MAIN_CTRL_HIGHSPEED		BIT(6)
+
+#define	AR9170_USB_REG_DEVICE_ADDRESS		(AR9170_USB_REG_BASE + 0x001)
+#define		AR9170_USB_DEVICE_ADDRESS_CONFIGURE	BIT(7)
+
+#define	AR9170_USB_REG_TEST			(AR9170_USB_REG_BASE + 0x002)
+#define	AR9170_USB_REG_PHY_TEST_SELECT		(AR9170_USB_REG_BASE + 0x008)
+#define	AR9170_USB_REG_CX_CONFIG_STATUS		(AR9170_USB_REG_BASE + 0x00b)
+#define	AR9170_USB_REG_EP0_DATA			(AR9170_USB_REG_BASE + 0x00c)
+#define	AR9170_USB_REG_EP0_DATA1		(AR9170_USB_REG_BASE + 0x00c)
+#define	AR9170_USB_REG_EP0_DATA2		(AR9170_USB_REG_BASE + 0x00d)
+
+#define	AR9170_USB_REG_INTR_MASK_BYTE_0		(AR9170_USB_REG_BASE + 0x011)
+#define	AR9170_USB_REG_INTR_MASK_BYTE_1		(AR9170_USB_REG_BASE + 0x012)
+#define	AR9170_USB_REG_INTR_MASK_BYTE_2		(AR9170_USB_REG_BASE + 0x013)
+#define	AR9170_USB_REG_INTR_MASK_BYTE_3		(AR9170_USB_REG_BASE + 0x014)
+#define	AR9170_USB_REG_INTR_MASK_BYTE_4		(AR9170_USB_REG_BASE + 0x015)
+#define		AR9170_USB_INTR_DISABLE_OUT_INT		(BIT(7) | BIT(6))
+
+#define	AR9170_USB_REG_INTR_MASK_BYTE_5		(AR9170_USB_REG_BASE + 0x016)
+#define	AR9170_USB_REG_INTR_MASK_BYTE_6		(AR9170_USB_REG_BASE + 0x017)
+#define		AR9170_USB_INTR_DISABLE_IN_INT		BIT(6)
+
+#define	AR9170_USB_REG_INTR_MASK_BYTE_7		(AR9170_USB_REG_BASE + 0x018)
+
+#define	AR9170_USB_REG_INTR_GROUP		(AR9170_USB_REG_BASE + 0x020)
+
+#define	AR9170_USB_REG_INTR_SOURCE_0		(AR9170_USB_REG_BASE + 0x021)
+#define	AR9170_USB_REG_INTR_SOURCE_1		(AR9170_USB_REG_BASE + 0x022)
+#define	AR9170_USB_REG_INTR_SOURCE_2		(AR9170_USB_REG_BASE + 0x023)
+#define	AR9170_USB_REG_INTR_SOURCE_3		(AR9170_USB_REG_BASE + 0x024)
+#define	AR9170_USB_REG_INTR_SOURCE_4		(AR9170_USB_REG_BASE + 0x025)
+#define	AR9170_USB_REG_INTR_SOURCE_5		(AR9170_USB_REG_BASE + 0x026)
+#define	AR9170_USB_REG_INTR_SOURCE_6		(AR9170_USB_REG_BASE + 0x027)
+#define	AR9170_USB_REG_INTR_SOURCE_7		(AR9170_USB_REG_BASE + 0x028)
+
+#define	AR9170_USB_REG_EP_MAP			(AR9170_USB_REG_BASE + 0x030)
+#define	AR9170_USB_REG_EP1_MAP			(AR9170_USB_REG_BASE + 0x030)
+#define	AR9170_USB_REG_EP2_MAP			(AR9170_USB_REG_BASE + 0x031)
+#define	AR9170_USB_REG_EP3_MAP			(AR9170_USB_REG_BASE + 0x032)
+#define	AR9170_USB_REG_EP4_MAP			(AR9170_USB_REG_BASE + 0x033)
+#define	AR9170_USB_REG_EP5_MAP			(AR9170_USB_REG_BASE + 0x034)
+#define	AR9170_USB_REG_EP6_MAP			(AR9170_USB_REG_BASE + 0x035)
+#define	AR9170_USB_REG_EP7_MAP			(AR9170_USB_REG_BASE + 0x036)
+#define	AR9170_USB_REG_EP8_MAP			(AR9170_USB_REG_BASE + 0x037)
+#define	AR9170_USB_REG_EP9_MAP			(AR9170_USB_REG_BASE + 0x038)
+#define	AR9170_USB_REG_EP10_MAP			(AR9170_USB_REG_BASE + 0x039)
+
+#define	AR9170_USB_REG_EP_IN_MAX_SIZE_HIGH	(AR9170_USB_REG_BASE + 0x03f)
+#define		AR9170_USB_EP_IN_TOGGLE			0x10
+
+#define	AR9170_USB_REG_EP_IN_MAX_SIZE_LOW	(AR9170_USB_REG_BASE + 0x03e)
+
+#define	AR9170_USB_REG_EP_OUT_MAX_SIZE_HIGH	(AR9170_USB_REG_BASE + 0x05f)
+#define		AR9170_USB_EP_OUT_TOGGLE		0x10
+
+#define	AR9170_USB_REG_EP_OUT_MAX_SIZE_LOW	(AR9170_USB_REG_BASE + 0x05e)
+
+#define	AR9170_USB_REG_EP3_BYTE_COUNT_HIGH	(AR9170_USB_REG_BASE + 0x0ae)
+#define	AR9170_USB_REG_EP3_BYTE_COUNT_LOW	(AR9170_USB_REG_BASE + 0x0be)
+#define	AR9170_USB_REG_EP4_BYTE_COUNT_HIGH	(AR9170_USB_REG_BASE + 0x0af)
+#define	AR9170_USB_REG_EP4_BYTE_COUNT_LOW	(AR9170_USB_REG_BASE + 0x0bf)
+
+#define	AR9170_USB_REG_FIFO_MAP			(AR9170_USB_REG_BASE + 0x080)
+#define	AR9170_USB_REG_FIFO0_MAP		(AR9170_USB_REG_BASE + 0x080)
+#define	AR9170_USB_REG_FIFO1_MAP		(AR9170_USB_REG_BASE + 0x081)
+#define	AR9170_USB_REG_FIFO2_MAP		(AR9170_USB_REG_BASE + 0x082)
+#define	AR9170_USB_REG_FIFO3_MAP		(AR9170_USB_REG_BASE + 0x083)
+#define	AR9170_USB_REG_FIFO4_MAP		(AR9170_USB_REG_BASE + 0x084)
+#define	AR9170_USB_REG_FIFO5_MAP		(AR9170_USB_REG_BASE + 0x085)
+#define	AR9170_USB_REG_FIFO6_MAP		(AR9170_USB_REG_BASE + 0x086)
+#define	AR9170_USB_REG_FIFO7_MAP		(AR9170_USB_REG_BASE + 0x087)
+#define	AR9170_USB_REG_FIFO8_MAP		(AR9170_USB_REG_BASE + 0x088)
+#define	AR9170_USB_REG_FIFO9_MAP		(AR9170_USB_REG_BASE + 0x089)
+
+#define	AR9170_USB_REG_FIFO_CONFIG		(AR9170_USB_REG_BASE + 0x090)
+#define	AR9170_USB_REG_FIFO0_CONFIG		(AR9170_USB_REG_BASE + 0x090)
+#define	AR9170_USB_REG_FIFO1_CONFIG		(AR9170_USB_REG_BASE + 0x091)
+#define	AR9170_USB_REG_FIFO2_CONFIG		(AR9170_USB_REG_BASE + 0x092)
+#define	AR9170_USB_REG_FIFO3_CONFIG		(AR9170_USB_REG_BASE + 0x093)
+#define	AR9170_USB_REG_FIFO4_CONFIG		(AR9170_USB_REG_BASE + 0x094)
+#define	AR9170_USB_REG_FIFO5_CONFIG		(AR9170_USB_REG_BASE + 0x095)
+#define	AR9170_USB_REG_FIFO6_CONFIG		(AR9170_USB_REG_BASE + 0x096)
+#define	AR9170_USB_REG_FIFO7_CONFIG		(AR9170_USB_REG_BASE + 0x097)
+#define	AR9170_USB_REG_FIFO8_CONFIG		(AR9170_USB_REG_BASE + 0x098)
+#define	AR9170_USB_REG_FIFO9_CONFIG		(AR9170_USB_REG_BASE + 0x099)
+
+#define	AR9170_USB_REG_EP3_DATA			(AR9170_USB_REG_BASE + 0x0f8)
+#define	AR9170_USB_REG_EP4_DATA			(AR9170_USB_REG_BASE + 0x0fc)
+
+#define	AR9170_USB_REG_FIFO_SIZE		(AR9170_USB_REG_BASE + 0x100)
+#define	AR9170_USB_REG_DMA_CTL			(AR9170_USB_REG_BASE + 0x108)
+#define		AR9170_USB_DMA_CTL_ENABLE_TO_DEVICE	BIT(0)
+#define		AR9170_USB_DMA_CTL_ENABLE_FROM_DEVICE	BIT(1)
+#define		AR9170_USB_DMA_CTL_HIGH_SPEED		BIT(2)
+#define		AR9170_USB_DMA_CTL_UP_PACKET_MODE	BIT(3)
+#define		AR9170_USB_DMA_CTL_UP_STREAM_S		4
+#define		AR9170_USB_DMA_CTL_UP_STREAM		(BIT(4) | BIT(5))
+#define		AR9170_USB_DMA_CTL_UP_STREAM_4K		(0)
+#define		AR9170_USB_DMA_CTL_UP_STREAM_8K		BIT(4)
+#define		AR9170_USB_DMA_CTL_UP_STREAM_16K	BIT(5)
+#define		AR9170_USB_DMA_CTL_UP_STREAM_32K	(BIT(4) | BIT(5))
+#define		AR9170_USB_DMA_CTL_DOWN_STREAM		BIT(6)
+
+#define	AR9170_USB_REG_DMA_STATUS		(AR9170_USB_REG_BASE + 0x10c)
+#define		AR9170_USB_DMA_STATUS_UP_IDLE		BIT(8)
+#define		AR9170_USB_DMA_STATUS_DN_IDLE		BIT(16)
+
+#define	AR9170_USB_REG_MAX_AGG_UPLOAD		(AR9170_USB_REG_BASE + 0x110)
+#define	AR9170_USB_REG_UPLOAD_TIME_CTL		(AR9170_USB_REG_BASE + 0x114)
+#define	AR9170_USB_REG_CBUS_CTRL		(AR9170_USB_REG_BASE + 0x1f0)
+#define		AR9170_USB_CBUS_CTRL_BUFFER_END		(BIT(1))
+
+/* PCI/USB to AHB Bridge */
+#define	AR9170_PTA_REG_BASE			0x1e2000
+
+#define	AR9170_PTA_REG_CMD			(AR9170_PTA_REG_BASE + 0x000)
+#define	AR9170_PTA_REG_PARAM1			(AR9170_PTA_REG_BASE + 0x004)
+#define	AR9170_PTA_REG_PARAM2			(AR9170_PTA_REG_BASE + 0x008)
+#define	AR9170_PTA_REG_PARAM3			(AR9170_PTA_REG_BASE + 0x00c)
+#define	AR9170_PTA_REG_RSP			(AR9170_PTA_REG_BASE + 0x010)
+#define	AR9170_PTA_REG_STATUS1			(AR9170_PTA_REG_BASE + 0x014)
+#define	AR9170_PTA_REG_STATUS2			(AR9170_PTA_REG_BASE + 0x018)
+#define	AR9170_PTA_REG_STATUS3			(AR9170_PTA_REG_BASE + 0x01c)
+#define	AR9170_PTA_REG_AHB_INT_FLAG		(AR9170_PTA_REG_BASE + 0x020)
+#define	AR9170_PTA_REG_AHB_INT_MASK		(AR9170_PTA_REG_BASE + 0x024)
+#define	AR9170_PTA_REG_AHB_INT_ACK		(AR9170_PTA_REG_BASE + 0x028)
+#define	AR9170_PTA_REG_AHB_SCRATCH1		(AR9170_PTA_REG_BASE + 0x030)
+#define	AR9170_PTA_REG_AHB_SCRATCH2		(AR9170_PTA_REG_BASE + 0x034)
+#define	AR9170_PTA_REG_AHB_SCRATCH3		(AR9170_PTA_REG_BASE + 0x038)
+#define	AR9170_PTA_REG_AHB_SCRATCH4		(AR9170_PTA_REG_BASE + 0x03c)
+
+#define	AR9170_PTA_REG_SHARE_MEM_CTRL		(AR9170_PTA_REG_BASE + 0x124)
+
+/*
+ * PCI to AHB Bridge
+ */
+
+#define	AR9170_PTA_REG_INT_FLAG			(AR9170_PTA_REG_BASE + 0x100)
+#define		AR9170_PTA_INT_FLAG_DN			0x01
+#define		AR9170_PTA_INT_FLAG_UP			0x02
+#define		AR9170_PTA_INT_FLAG_CMD			0x04
+
+#define	AR9170_PTA_REG_INT_MASK			(AR9170_PTA_REG_BASE + 0x104)
+#define	AR9170_PTA_REG_DN_DMA_ADDRL		(AR9170_PTA_REG_BASE + 0x108)
+#define	AR9170_PTA_REG_DN_DMA_ADDRH		(AR9170_PTA_REG_BASE + 0x10c)
+#define	AR9170_PTA_REG_UP_DMA_ADDRL		(AR9170_PTA_REG_BASE + 0x110)
+#define	AR9170_PTA_REG_UP_DMA_ADDRH		(AR9170_PTA_REG_BASE + 0x114)
+#define	AR9170_PTA_REG_DN_PEND_TIME		(AR9170_PTA_REG_BASE + 0x118)
+#define	AR9170_PTA_REG_UP_PEND_TIME		(AR9170_PTA_REG_BASE + 0x11c)
+#define	AR9170_PTA_REG_CONTROL			(AR9170_PTA_REG_BASE + 0x120)
+#define		AR9170_PTA_CTRL_4_BEAT_BURST		0x00
+#define		AR9170_PTA_CTRL_8_BEAT_BURST		0x01
+#define		AR9170_PTA_CTRL_16_BEAT_BURST		0x02
+#define		AR9170_PTA_CTRL_LOOPBACK_MODE		0x10
+
+#define	AR9170_PTA_REG_MEM_CTRL			(AR9170_PTA_REG_BASE + 0x124)
+#define	AR9170_PTA_REG_MEM_ADDR			(AR9170_PTA_REG_BASE + 0x128)
+#define	AR9170_PTA_REG_DN_DMA_TRIGGER		(AR9170_PTA_REG_BASE + 0x12c)
+#define	AR9170_PTA_REG_UP_DMA_TRIGGER		(AR9170_PTA_REG_BASE + 0x130)
+#define	AR9170_PTA_REG_DMA_STATUS		(AR9170_PTA_REG_BASE + 0x134)
+#define	AR9170_PTA_REG_DN_CURR_ADDRL		(AR9170_PTA_REG_BASE + 0x138)
+#define	AR9170_PTA_REG_DN_CURR_ADDRH		(AR9170_PTA_REG_BASE + 0x13c)
+#define	AR9170_PTA_REG_UP_CURR_ADDRL		(AR9170_PTA_REG_BASE + 0x140)
+#define	AR9170_PTA_REG_UP_CURR_ADDRH		(AR9170_PTA_REG_BASE + 0x144)
+#define	AR9170_PTA_REG_DMA_MODE_CTRL		(AR9170_PTA_REG_BASE + 0x148)
+#define		AR9170_PTA_DMA_MODE_CTRL_RESET		BIT(0)
+#define		AR9170_PTA_DMA_MODE_CTRL_DISABLE_USB	BIT(1)
+
+/* Protocol Controller Module */
+#define	AR9170_MAC_REG_PC_REG_BASE		(AR9170_MAC_REG_BASE + 0xe00)
+
+
+#define	AR9170_NUM_LEDS				2
+
+/* CAM */
+#define	AR9170_CAM_MAX_USER			64
+#define	AR9170_CAM_MAX_KEY_LENGTH		16
+
+#define AR9170_SRAM_OFFSET		0x100000
+#define AR9170_SRAM_SIZE		0x18000
+
+#define AR9170_PRAM_OFFSET		0x200000
+#define AR9170_PRAM_SIZE		0x8000
+
+enum cpu_clock {
+	AHB_STATIC_40MHZ = 0,
+	AHB_GMODE_22MHZ = 1,
+	AHB_AMODE_20MHZ = 1,
+	AHB_GMODE_44MHZ = 2,
+	AHB_AMODE_40MHZ = 2,
+	AHB_GMODE_88MHZ = 3,
+	AHB_AMODE_80MHZ = 3
+};
+
+/* USB endpoints */
+enum ar9170_usb_ep {
+	/*
+	 * Control EP is always EP 0 (USB SPEC)
+	 *
+	 * The weird thing is: the original firmware has a few
+	 * comments that suggest that the actual EP numbers
+	 * are in the 1 to 10 range?!
+	 */
+	AR9170_USB_EP_CTRL		= 0,
+
+	AR9170_USB_EP_TX,
+	AR9170_USB_EP_RX,
+	AR9170_USB_EP_IRQ,
+	AR9170_USB_EP_CMD,
+	AR9170_USB_NUM_EXTRA_EP		= 4,
+
+	__AR9170_USB_NUM_EP,
+
+	__AR9170_USB_NUM_MAX_EP		= 10
+};
+
+enum ar9170_usb_fifo {
+	__AR9170_USB_NUM_MAX_FIFO	= 10
+};
+
+enum ar9170_tx_queues {
+	AR9170_TXQ0	= 0,
+	AR9170_TXQ1,
+	AR9170_TXQ2,
+	AR9170_TXQ3,
+	AR9170_TXQ_SPECIAL,
+
+	/* keep last */
+	__AR9170_NUM_TX_QUEUES = 5
+};
+
+#define	AR9170_TX_STREAM_TAG		0x697e
+#define	AR9170_RX_STREAM_TAG		0x4e00
+#define	AR9170_RX_STREAM_MAX_SIZE	0xffff
+
+struct ar9170_stream {
+	__le16 length;
+	__le16 tag;
+
+	u8 payload[0];
+};
+
+#define AR9170_MAX_ACKTABLE_ENTRIES			8
+#define AR9170_MAX_VIRTUAL_MAC				7
+
+#define	AR9170_USB_EP_CTRL_MAX				64
+#define	AR9170_USB_EP_TX_MAX				512
+#define	AR9170_USB_EP_RX_MAX				512
+#define	AR9170_USB_EP_IRQ_MAX				64
+#define	AR9170_USB_EP_CMD_MAX				64
+
+/* Trigger PRETBTT interrupt 6 Kus earlier */
+#define CARL9170_PRETBTT_KUS				6
+
+#define	AR5416_MAX_RATE_POWER				63
+
+#define SET_VAL(reg, value, newvalue)					\
+	(value = ((value) & ~reg) | (((newvalue) << reg##_S) & reg))
+
+#define SET_CONSTVAL(reg, newvalue)					\
+	(((newvalue) << reg##_S) & reg)
+
+#define MOD_VAL(reg, value, newvalue)					\
+	(((value) & ~reg) | (((newvalue) << reg##_S) & reg))
+#endif	/* __CARL9170_SHARED_HW_H */
diff --git a/drivers/net/wireless/ath/carl9170/led.c b/drivers/net/wireless/ath/carl9170/led.c
new file mode 100644
index 0000000..4bb2cbd
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/led.c
@@ -0,0 +1,190 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * LED handling
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparer <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "carl9170.h"
+#include "cmd.h"
+
+int carl9170_led_set_state(struct ar9170 *ar, const u32 led_state)
+{
+	return carl9170_write_reg(ar, AR9170_GPIO_REG_PORT_DATA, led_state);
+}
+
+int carl9170_led_init(struct ar9170 *ar)
+{
+	int err;
+
+	/* disable LEDs */
+	/* GPIO [0/1 mode: output, 2/3: input] */
+	err = carl9170_write_reg(ar, AR9170_GPIO_REG_PORT_TYPE, 3);
+	if (err)
+		goto out;
+
+	/* GPIO 0/1 value: off */
+	err = carl9170_led_set_state(ar, 0);
+
+out:
+	return err;
+}
+
+#ifdef CONFIG_CARL9170_LEDS
+static void carl9170_led_update(struct work_struct *work)
+{
+	struct ar9170 *ar = container_of(work, struct ar9170, led_work.work);
+	int i, tmp = 300, blink_delay = 1000;
+	u32 led_val = 0;
+	bool rerun = false;
+
+	if (!IS_ACCEPTING_CMD(ar))
+		return;
+
+	mutex_lock(&ar->mutex);
+	for (i = 0; i < AR9170_NUM_LEDS; i++) {
+		if (ar->leds[i].registered) {
+			if (ar->leds[i].last_state ||
+			    ar->leds[i].toggled) {
+
+				if (ar->leds[i].toggled)
+					tmp = 70 + 200 / (ar->leds[i].toggled);
+
+				if (tmp < blink_delay)
+					blink_delay = tmp;
+
+				led_val |= 1 << i;
+				ar->leds[i].toggled = 0;
+				rerun = true;
+			}
+		}
+	}
+
+	carl9170_led_set_state(ar, led_val);
+	mutex_unlock(&ar->mutex);
+
+	if (!rerun)
+		return;
+
+	ieee80211_queue_delayed_work(ar->hw,
+				     &ar->led_work,
+				     msecs_to_jiffies(blink_delay));
+}
+
+static void carl9170_led_set_brightness(struct led_classdev *led,
+					enum led_brightness brightness)
+{
+	struct carl9170_led *arl = container_of(led, struct carl9170_led, l);
+	struct ar9170 *ar = arl->ar;
+
+	if (!arl->registered)
+		return;
+
+	if (arl->last_state != !!brightness) {
+		arl->toggled++;
+		arl->last_state = !!brightness;
+	}
+
+	if (likely(IS_ACCEPTING_CMD(ar) && arl->toggled))
+		ieee80211_queue_delayed_work(ar->hw, &ar->led_work, HZ/10);
+}
+
+static int carl9170_led_register_led(struct ar9170 *ar, int i, char *name,
+				     char *trigger)
+{
+	int err;
+
+	snprintf(ar->leds[i].name, sizeof(ar->leds[i].name),
+		 "carl9170-%s::%s", wiphy_name(ar->hw->wiphy), name);
+
+	ar->leds[i].ar = ar;
+	ar->leds[i].l.name = ar->leds[i].name;
+	ar->leds[i].l.brightness_set = carl9170_led_set_brightness;
+	ar->leds[i].l.brightness = 0;
+	ar->leds[i].l.default_trigger = trigger;
+
+	err = led_classdev_register(wiphy_dev(ar->hw->wiphy),
+				    &ar->leds[i].l);
+	if (err) {
+		wiphy_err(ar->hw->wiphy, "failed to register %s LED (%d).\n",
+			ar->leds[i].name, err);
+	} else {
+		ar->leds[i].registered = true;
+	}
+
+	return err;
+}
+
+void carl9170_led_unregister(struct ar9170 *ar)
+{
+	int i;
+
+	for (i = 0; i < AR9170_NUM_LEDS; i++)
+		if (ar->leds[i].registered) {
+			led_classdev_unregister(&ar->leds[i].l);
+			ar->leds[i].registered = false;
+			ar->leds[i].toggled = 0;
+		}
+
+	cancel_delayed_work_sync(&ar->led_work);
+}
+
+int carl9170_led_register(struct ar9170 *ar)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&ar->led_work, carl9170_led_update);
+
+	err = carl9170_led_register_led(ar, 0, "tx",
+					ieee80211_get_tx_led_name(ar->hw));
+	if (err)
+		goto fail;
+
+	if (ar->features & CARL9170_ONE_LED)
+		return 0;
+
+	err = carl9170_led_register_led(ar, 1, "assoc",
+					ieee80211_get_assoc_led_name(ar->hw));
+	if (err)
+		goto fail;
+
+	return 0;
+
+fail:
+	carl9170_led_unregister(ar);
+	return err;
+}
+
+#endif /* CONFIG_CARL9170_LEDS */
diff --git a/drivers/net/wireless/ath/carl9170/mac.c b/drivers/net/wireless/ath/carl9170/mac.c
new file mode 100644
index 0000000..2305bc2
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/mac.c
@@ -0,0 +1,604 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * MAC programming
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <asm/unaligned.h>
+
+#include "carl9170.h"
+#include "cmd.h"
+
+int carl9170_set_dyn_sifs_ack(struct ar9170 *ar)
+{
+	u32 val;
+
+	if (conf_is_ht40(&ar->hw->conf))
+		val = 0x010a;
+	else {
+		if (ar->hw->conf.channel->band == IEEE80211_BAND_2GHZ)
+			val = 0x105;
+		else
+			val = 0x104;
+	}
+
+	return carl9170_write_reg(ar, AR9170_MAC_REG_DYNAMIC_SIFS_ACK, val);
+}
+
+int carl9170_set_rts_cts_rate(struct ar9170 *ar)
+{
+	u32 rts_rate, cts_rate;
+
+	if (conf_is_ht(&ar->hw->conf)) {
+		/* 12 mbit OFDM */
+		rts_rate = 0x1da;
+		cts_rate = 0x10a;
+	} else {
+		if (ar->hw->conf.channel->band == IEEE80211_BAND_2GHZ) {
+			/* 11 mbit CCK */
+			rts_rate = 033;
+			cts_rate = 003;
+		} else {
+			/* 6 mbit OFDM */
+			rts_rate = 0x1bb;
+			cts_rate = 0x10b;
+		}
+	}
+
+	return carl9170_write_reg(ar, AR9170_MAC_REG_RTS_CTS_RATE,
+				  rts_rate | (cts_rate) << 16);
+}
+
+int carl9170_set_slot_time(struct ar9170 *ar)
+{
+	struct ieee80211_vif *vif;
+	u32 slottime = 20;
+
+	rcu_read_lock();
+	vif = carl9170_get_main_vif(ar);
+	if (!vif) {
+		rcu_read_unlock();
+		return 0;
+	}
+
+	if ((ar->hw->conf.channel->band == IEEE80211_BAND_5GHZ) ||
+	    vif->bss_conf.use_short_slot)
+		slottime = 9;
+
+	rcu_read_unlock();
+
+	return carl9170_write_reg(ar, AR9170_MAC_REG_SLOT_TIME,
+				  slottime << 10);
+}
+
+int carl9170_set_mac_rates(struct ar9170 *ar)
+{
+	struct ieee80211_vif *vif;
+	u32 basic, mandatory;
+
+	rcu_read_lock();
+	vif = carl9170_get_main_vif(ar);
+
+	if (!vif) {
+		rcu_read_unlock();
+		return 0;
+	}
+
+	basic = (vif->bss_conf.basic_rates & 0xf);
+	basic |= (vif->bss_conf.basic_rates & 0xff0) << 4;
+	rcu_read_unlock();
+
+	if (ar->hw->conf.channel->band == IEEE80211_BAND_5GHZ)
+		mandatory = 0xff00; /* OFDM 6/9/12/18/24/36/48/54 */
+	else
+		mandatory = 0xff0f; /* OFDM (6/9../54) + CCK (1/2/5.5/11) */
+
+	carl9170_regwrite_begin(ar);
+	carl9170_regwrite(AR9170_MAC_REG_BASIC_RATE, basic);
+	carl9170_regwrite(AR9170_MAC_REG_MANDATORY_RATE, mandatory);
+	carl9170_regwrite_finish();
+
+	return carl9170_regwrite_result();
+}
+
+int carl9170_set_qos(struct ar9170 *ar)
+{
+	carl9170_regwrite_begin(ar);
+
+	carl9170_regwrite(AR9170_MAC_REG_AC0_CW, ar->edcf[0].cw_min |
+			  (ar->edcf[0].cw_max << 16));
+	carl9170_regwrite(AR9170_MAC_REG_AC1_CW, ar->edcf[1].cw_min |
+			  (ar->edcf[1].cw_max << 16));
+	carl9170_regwrite(AR9170_MAC_REG_AC2_CW, ar->edcf[2].cw_min |
+			  (ar->edcf[2].cw_max << 16));
+	carl9170_regwrite(AR9170_MAC_REG_AC3_CW, ar->edcf[3].cw_min |
+			  (ar->edcf[3].cw_max << 16));
+	carl9170_regwrite(AR9170_MAC_REG_AC4_CW, ar->edcf[4].cw_min |
+			  (ar->edcf[4].cw_max << 16));
+
+	carl9170_regwrite(AR9170_MAC_REG_AC2_AC1_AC0_AIFS,
+			  ((ar->edcf[0].aifs * 9 + 10)) |
+			  ((ar->edcf[1].aifs * 9 + 10) << 12) |
+			  ((ar->edcf[2].aifs * 9 + 10) << 24));
+	carl9170_regwrite(AR9170_MAC_REG_AC4_AC3_AC2_AIFS,
+			  ((ar->edcf[2].aifs * 9 + 10) >> 8) |
+			  ((ar->edcf[3].aifs * 9 + 10) << 4) |
+			  ((ar->edcf[4].aifs * 9 + 10) << 16));
+
+	carl9170_regwrite(AR9170_MAC_REG_AC1_AC0_TXOP,
+			  ar->edcf[0].txop | ar->edcf[1].txop << 16);
+	carl9170_regwrite(AR9170_MAC_REG_AC3_AC2_TXOP,
+			  ar->edcf[2].txop | ar->edcf[3].txop << 16 |
+			  ar->edcf[4].txop << 24);
+
+	carl9170_regwrite_finish();
+
+	return carl9170_regwrite_result();
+}
+
+int carl9170_init_mac(struct ar9170 *ar)
+{
+	carl9170_regwrite_begin(ar);
+
+	/* switch MAC to OTUS interface */
+	carl9170_regwrite(0x1c3600, 0x3);
+
+	carl9170_regwrite(AR9170_MAC_REG_ACK_EXTENSION, 0x40);
+
+	carl9170_regwrite(AR9170_MAC_REG_RETRY_MAX, 0x0);
+
+	carl9170_regwrite(AR9170_MAC_REG_FRAMETYPE_FILTER,
+			  AR9170_MAC_FTF_MONITOR);
+
+	/* enable MMIC */
+	carl9170_regwrite(AR9170_MAC_REG_SNIFFER,
+			AR9170_MAC_SNIFFER_DEFAULTS);
+
+	carl9170_regwrite(AR9170_MAC_REG_RX_THRESHOLD, 0xc1f80);
+
+	carl9170_regwrite(AR9170_MAC_REG_RX_PE_DELAY, 0x70);
+	carl9170_regwrite(AR9170_MAC_REG_EIFS_AND_SIFS, 0xa144000);
+	carl9170_regwrite(AR9170_MAC_REG_SLOT_TIME, 9 << 10);
+
+	/* CF-END & CF-ACK rate => 24M OFDM */
+	carl9170_regwrite(AR9170_MAC_REG_TID_CFACK_CFEND_RATE, 0x59900000);
+
+	/* NAV protects ACK only (in TXOP) */
+	carl9170_regwrite(AR9170_MAC_REG_TXOP_DURATION, 0x201);
+
+	/* Set Beacon PHY CTRL's TPC to 0x7, TA1=1 */
+	/* OTUS set AM to 0x1 */
+	carl9170_regwrite(AR9170_MAC_REG_BCN_HT1, 0x8000170);
+
+	carl9170_regwrite(AR9170_MAC_REG_BACKOFF_PROTECT, 0x105);
+
+	/* Aggregation MAX number and timeout */
+	carl9170_regwrite(AR9170_MAC_REG_AMPDU_FACTOR, 0xa);
+	carl9170_regwrite(AR9170_MAC_REG_AMPDU_DENSITY, 0x140a00);
+
+	carl9170_regwrite(AR9170_MAC_REG_FRAMETYPE_FILTER,
+			  AR9170_MAC_FTF_DEFAULTS);
+
+	carl9170_regwrite(AR9170_MAC_REG_RX_CONTROL,
+			  AR9170_MAC_RX_CTRL_DEAGG |
+			  AR9170_MAC_RX_CTRL_SHORT_FILTER);
+
+	/* rate sets */
+	carl9170_regwrite(AR9170_MAC_REG_BASIC_RATE, 0x150f);
+	carl9170_regwrite(AR9170_MAC_REG_MANDATORY_RATE, 0x150f);
+	carl9170_regwrite(AR9170_MAC_REG_RTS_CTS_RATE, 0x0030033);
+
+	/* MIMO response control */
+	carl9170_regwrite(AR9170_MAC_REG_ACK_TPC, 0x4003c1e);
+
+	carl9170_regwrite(AR9170_MAC_REG_AMPDU_RX_THRESH, 0xffff);
+
+	/* set PHY register read timeout (??) */
+	carl9170_regwrite(AR9170_MAC_REG_MISC_680, 0xf00008);
+
+	/* Disable Rx TimeOut, workaround for BB. */
+	carl9170_regwrite(AR9170_MAC_REG_RX_TIMEOUT, 0x0);
+
+	/* Set WLAN DMA interrupt mode: generate int per packet */
+	carl9170_regwrite(AR9170_MAC_REG_TXRX_MPI, 0x110011);
+
+	carl9170_regwrite(AR9170_MAC_REG_FCS_SELECT,
+			AR9170_MAC_FCS_FIFO_PROT);
+
+	/* Disables the CF_END frame, undocumented register */
+	carl9170_regwrite(AR9170_MAC_REG_TXOP_NOT_ENOUGH_IND,
+			0x141e0f48);
+
+	/* reset group hash table */
+	carl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_L, 0xffffffff);
+	carl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_H, 0xffffffff);
+
+	/* disable PRETBTT interrupt */
+	carl9170_regwrite(AR9170_MAC_REG_PRETBTT, 0x0);
+	carl9170_regwrite(AR9170_MAC_REG_BCN_PERIOD, 0x0);
+
+	carl9170_regwrite_finish();
+
+	return carl9170_regwrite_result();
+}
+
+static int carl9170_set_mac_reg(struct ar9170 *ar,
+				const u32 reg, const u8 *mac)
+{
+	static const u8 zero[ETH_ALEN] = { 0 };
+
+	if (!mac)
+		mac = zero;
+
+	carl9170_regwrite_begin(ar);
+
+	carl9170_regwrite(reg, get_unaligned_le32(mac));
+	carl9170_regwrite(reg + 4, get_unaligned_le16(mac + 4));
+
+	carl9170_regwrite_finish();
+
+	return carl9170_regwrite_result();
+}
+
+int carl9170_mod_virtual_mac(struct ar9170 *ar, const unsigned int id,
+			     const u8 *mac)
+{
+	if (WARN_ON(id >= ar->fw.vif_num))
+		return -EINVAL;
+
+	return carl9170_set_mac_reg(ar,
+		AR9170_MAC_REG_ACK_TABLE + (id - 1) * 8, mac);
+}
+
+int carl9170_update_multicast(struct ar9170 *ar, const u64 mc_hash)
+{
+	int err;
+
+	carl9170_regwrite_begin(ar);
+	carl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_H, mc_hash >> 32);
+	carl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_L, mc_hash);
+	carl9170_regwrite_finish();
+	err = carl9170_regwrite_result();
+	if (err)
+		return err;
+
+	ar->cur_mc_hash = mc_hash;
+	return 0;
+}
+
+int carl9170_set_operating_mode(struct ar9170 *ar)
+{
+	struct ieee80211_vif *vif;
+	struct ath_common *common = &ar->common;
+	u8 *mac_addr, *bssid;
+	u32 cam_mode = AR9170_MAC_CAM_DEFAULTS;
+	u32 enc_mode = AR9170_MAC_ENCRYPTION_DEFAULTS;
+	u32 rx_ctrl = AR9170_MAC_RX_CTRL_DEAGG |
+		      AR9170_MAC_RX_CTRL_SHORT_FILTER;
+	u32 sniffer = AR9170_MAC_SNIFFER_DEFAULTS;
+	int err = 0;
+
+	rcu_read_lock();
+	vif = carl9170_get_main_vif(ar);
+
+	if (vif) {
+		mac_addr = common->macaddr;
+		bssid = common->curbssid;
+
+		switch (vif->type) {
+		case NL80211_IFTYPE_MESH_POINT:
+		case NL80211_IFTYPE_ADHOC:
+			cam_mode |= AR9170_MAC_CAM_IBSS;
+			break;
+		case NL80211_IFTYPE_AP:
+			cam_mode |= AR9170_MAC_CAM_AP;
+
+			/* iwlagn 802.11n STA Workaround */
+			rx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;
+			break;
+		case NL80211_IFTYPE_WDS:
+			cam_mode |= AR9170_MAC_CAM_AP_WDS;
+			rx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;
+			break;
+		case NL80211_IFTYPE_STATION:
+			cam_mode |= AR9170_MAC_CAM_STA;
+			rx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;
+			break;
+		default:
+			WARN(1, "Unsupported operation mode %x\n", vif->type);
+			err = -EOPNOTSUPP;
+			break;
+		}
+	} else {
+		mac_addr = NULL;
+		bssid = NULL;
+	}
+	rcu_read_unlock();
+
+	if (err)
+		return err;
+
+	if (ar->rx_software_decryption)
+		enc_mode |= AR9170_MAC_ENCRYPTION_RX_SOFTWARE;
+
+	if (ar->sniffer_enabled) {
+		rx_ctrl |= AR9170_MAC_RX_CTRL_ACK_IN_SNIFFER;
+		sniffer |= AR9170_MAC_SNIFFER_ENABLE_PROMISC;
+		enc_mode |= AR9170_MAC_ENCRYPTION_RX_SOFTWARE;
+	}
+
+	err = carl9170_set_mac_reg(ar, AR9170_MAC_REG_MAC_ADDR_L, mac_addr);
+	if (err)
+		return err;
+
+	err = carl9170_set_mac_reg(ar, AR9170_MAC_REG_BSSID_L, bssid);
+	if (err)
+		return err;
+
+	carl9170_regwrite_begin(ar);
+	carl9170_regwrite(AR9170_MAC_REG_SNIFFER, sniffer);
+	carl9170_regwrite(AR9170_MAC_REG_CAM_MODE, cam_mode);
+	carl9170_regwrite(AR9170_MAC_REG_ENCRYPTION, enc_mode);
+	carl9170_regwrite(AR9170_MAC_REG_RX_CONTROL, rx_ctrl);
+	carl9170_regwrite_finish();
+
+	return carl9170_regwrite_result();
+}
+
+int carl9170_set_hwretry_limit(struct ar9170 *ar, const unsigned int max_retry)
+{
+	u32 tmp = min_t(u32, 0x33333, max_retry * 0x11111);
+
+	return carl9170_write_reg(ar, AR9170_MAC_REG_RETRY_MAX, tmp);
+}
+
+int carl9170_set_beacon_timers(struct ar9170 *ar)
+{
+	struct ieee80211_vif *vif;
+	u32 v = 0;
+	u32 pretbtt = 0;
+
+	rcu_read_lock();
+	vif = carl9170_get_main_vif(ar);
+
+	if (vif) {
+		struct carl9170_vif_info *mvif;
+		mvif = (void *) vif->drv_priv;
+
+		if (mvif->enable_beacon && !WARN_ON(!ar->beacon_enabled)) {
+			ar->global_beacon_int = vif->bss_conf.beacon_int /
+						ar->beacon_enabled;
+
+			SET_VAL(AR9170_MAC_BCN_DTIM, v,
+				vif->bss_conf.dtim_period);
+
+			switch (vif->type) {
+			case NL80211_IFTYPE_MESH_POINT:
+			case NL80211_IFTYPE_ADHOC:
+				v |= AR9170_MAC_BCN_IBSS_MODE;
+				break;
+			case NL80211_IFTYPE_AP:
+				v |= AR9170_MAC_BCN_AP_MODE;
+				break;
+			default:
+				WARN_ON_ONCE(1);
+				break;
+			}
+		} else if (vif->type == NL80211_IFTYPE_STATION) {
+			ar->global_beacon_int = vif->bss_conf.beacon_int;
+
+			SET_VAL(AR9170_MAC_BCN_DTIM, v,
+				ar->hw->conf.ps_dtim_period);
+
+			v |= AR9170_MAC_BCN_STA_PS |
+			     AR9170_MAC_BCN_PWR_MGT;
+		}
+
+		if (ar->global_beacon_int) {
+			if (ar->global_beacon_int < 15) {
+				rcu_read_unlock();
+				return -ERANGE;
+			}
+
+			ar->global_pretbtt = ar->global_beacon_int -
+					CARL9170_PRETBTT_KUS;
+		} else {
+			ar->global_pretbtt = 0;
+		}
+	} else {
+		ar->global_beacon_int = 0;
+		ar->global_pretbtt = 0;
+	}
+
+	rcu_read_unlock();
+
+	SET_VAL(AR9170_MAC_BCN_PERIOD, v, ar->global_beacon_int);
+	SET_VAL(AR9170_MAC_PRETBTT, pretbtt, ar->global_pretbtt);
+	SET_VAL(AR9170_MAC_PRETBTT2, pretbtt, ar->global_pretbtt);
+
+	carl9170_regwrite_begin(ar);
+	carl9170_regwrite(AR9170_MAC_REG_PRETBTT, pretbtt);
+	carl9170_regwrite(AR9170_MAC_REG_BCN_PERIOD, v);
+	carl9170_regwrite_finish();
+	return carl9170_regwrite_result();
+}
+
+int carl9170_update_beacon(struct ar9170 *ar, const bool submit)
+{
+	struct sk_buff *skb;
+	struct carl9170_vif_info *cvif;
+	__le32 *data, *old = NULL;
+	u32 word, off, addr, len;
+	int i = 0, err = 0;
+
+	rcu_read_lock();
+	cvif = rcu_dereference(ar->beacon_iter);
+retry:
+	if (ar->vifs == 0 || !cvif)
+		goto out_unlock;
+
+	list_for_each_entry_continue_rcu(cvif, &ar->vif_list, list) {
+		if (cvif->active && cvif->enable_beacon)
+			goto found;
+	}
+
+	if (!ar->beacon_enabled || i++)
+		goto out_unlock;
+
+	goto retry;
+
+found:
+	rcu_assign_pointer(ar->beacon_iter, cvif);
+
+	skb = ieee80211_beacon_get_tim(ar->hw, carl9170_get_vif(cvif),
+		NULL, NULL);
+
+	if (!skb) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+
+	spin_lock_bh(&ar->beacon_lock);
+	data = (__le32 *)skb->data;
+	if (cvif->beacon)
+		old = (__le32 *)cvif->beacon->data;
+
+	off = cvif->id * AR9170_MAC_BCN_LENGTH_MAX;
+	addr = ar->fw.beacon_addr + off;
+	len = roundup(skb->len + FCS_LEN, 4);
+
+	if ((off + len) > ar->fw.beacon_max_len) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "beacon does not "
+				  "fit into device memory!\n");
+		}
+
+		spin_unlock_bh(&ar->beacon_lock);
+		dev_kfree_skb_any(skb);
+		err = -EINVAL;
+		goto out_unlock;
+	}
+
+	if (len > AR9170_MAC_BCN_LENGTH_MAX) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "no support for beacons "
+				"bigger than %d (yours:%d).\n",
+				 AR9170_MAC_BCN_LENGTH_MAX, len);
+		}
+
+		spin_unlock_bh(&ar->beacon_lock);
+		dev_kfree_skb_any(skb);
+		err = -EMSGSIZE;
+		goto out_unlock;
+	}
+
+	carl9170_async_regwrite_begin(ar);
+
+	/* XXX: use skb->cb info */
+	if (ar->hw->conf.channel->band == IEEE80211_BAND_2GHZ) {
+		carl9170_async_regwrite(AR9170_MAC_REG_BCN_PLCP,
+				((skb->len + FCS_LEN) << (3 + 16)) + 0x0400);
+	} else {
+		carl9170_async_regwrite(AR9170_MAC_REG_BCN_PLCP,
+				((skb->len + FCS_LEN) << 16) + 0x001b);
+	}
+
+	for (i = 0; i < DIV_ROUND_UP(skb->len, 4); i++) {
+		/*
+		 * XXX: This accesses beyond skb data for up
+		 *	to the last 3 bytes!!
+		 */
+
+		if (old && (data[i] == old[i]))
+			continue;
+
+		word = le32_to_cpu(data[i]);
+		carl9170_async_regwrite(addr + 4 * i, word);
+	}
+	carl9170_async_regwrite_finish();
+
+	dev_kfree_skb_any(cvif->beacon);
+	cvif->beacon = NULL;
+
+	err = carl9170_async_regwrite_result();
+	if (!err)
+		cvif->beacon = skb;
+	spin_unlock_bh(&ar->beacon_lock);
+	if (err)
+		goto out_unlock;
+
+	if (submit) {
+		err = carl9170_bcn_ctrl(ar, cvif->id,
+					CARL9170_BCN_CTRL_CAB_TRIGGER,
+					addr, skb->len + FCS_LEN);
+
+		if (err)
+			goto out_unlock;
+	}
+out_unlock:
+	rcu_read_unlock();
+	return err;
+}
+
+int carl9170_upload_key(struct ar9170 *ar, const u8 id, const u8 *mac,
+			const u8 ktype, const u8 keyidx, const u8 *keydata,
+			const int keylen)
+{
+	struct carl9170_set_key_cmd key = { };
+	static const u8 bcast[ETH_ALEN] = {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+	mac = mac ? : bcast;
+
+	key.user = cpu_to_le16(id);
+	key.keyId = cpu_to_le16(keyidx);
+	key.type = cpu_to_le16(ktype);
+	memcpy(&key.macAddr, mac, ETH_ALEN);
+	if (keydata)
+		memcpy(&key.key, keydata, keylen);
+
+	return carl9170_exec_cmd(ar, CARL9170_CMD_EKEY,
+		sizeof(key), (u8 *)&key, 0, NULL);
+}
+
+int carl9170_disable_key(struct ar9170 *ar, const u8 id)
+{
+	struct carl9170_disable_key_cmd key = { };
+
+	key.user = cpu_to_le16(id);
+
+	return carl9170_exec_cmd(ar, CARL9170_CMD_DKEY,
+		sizeof(key), (u8 *)&key, 0, NULL);
+}
diff --git a/drivers/net/wireless/ath/carl9170/main.c b/drivers/net/wireless/ath/carl9170/main.c
new file mode 100644
index 0000000..af0642f
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/main.c
@@ -0,0 +1,1764 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * mac80211 interaction code
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/random.h>
+#include <net/mac80211.h>
+#include <net/cfg80211.h>
+#include "hw.h"
+#include "carl9170.h"
+#include "cmd.h"
+
+static int modparam_nohwcrypt;
+module_param_named(nohwcrypt, modparam_nohwcrypt, bool, S_IRUGO);
+MODULE_PARM_DESC(nohwcrypt, "Disable hardware crypto offload.");
+
+int modparam_noht;
+module_param_named(noht, modparam_noht, int, S_IRUGO);
+MODULE_PARM_DESC(noht, "Disable MPDU aggregation.");
+
+#define RATE(_bitrate, _hw_rate, _txpidx, _flags) {	\
+	.bitrate	= (_bitrate),			\
+	.flags		= (_flags),			\
+	.hw_value	= (_hw_rate) | (_txpidx) << 4,	\
+}
+
+struct ieee80211_rate __carl9170_ratetable[] = {
+	RATE(10, 0, 0, 0),
+	RATE(20, 1, 1, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(55, 2, 2, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(110, 3, 3, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(60, 0xb, 0, 0),
+	RATE(90, 0xf, 0, 0),
+	RATE(120, 0xa, 0, 0),
+	RATE(180, 0xe, 0, 0),
+	RATE(240, 0x9, 0, 0),
+	RATE(360, 0xd, 1, 0),
+	RATE(480, 0x8, 2, 0),
+	RATE(540, 0xc, 3, 0),
+};
+#undef RATE
+
+#define carl9170_g_ratetable	(__carl9170_ratetable + 0)
+#define carl9170_g_ratetable_size	12
+#define carl9170_a_ratetable	(__carl9170_ratetable + 4)
+#define carl9170_a_ratetable_size	8
+
+/*
+ * NB: The hw_value is used as an index into the carl9170_phy_freq_params
+ *     array in phy.c so that we don't have to do frequency lookups!
+ */
+#define CHAN(_freq, _idx) {		\
+	.center_freq	= (_freq),	\
+	.hw_value	= (_idx),	\
+	.max_power	= 18, /* XXX */	\
+}
+
+static struct ieee80211_channel carl9170_2ghz_chantable[] = {
+	CHAN(2412,  0),
+	CHAN(2417,  1),
+	CHAN(2422,  2),
+	CHAN(2427,  3),
+	CHAN(2432,  4),
+	CHAN(2437,  5),
+	CHAN(2442,  6),
+	CHAN(2447,  7),
+	CHAN(2452,  8),
+	CHAN(2457,  9),
+	CHAN(2462, 10),
+	CHAN(2467, 11),
+	CHAN(2472, 12),
+	CHAN(2484, 13),
+};
+
+static struct ieee80211_channel carl9170_5ghz_chantable[] = {
+	CHAN(4920, 14),
+	CHAN(4940, 15),
+	CHAN(4960, 16),
+	CHAN(4980, 17),
+	CHAN(5040, 18),
+	CHAN(5060, 19),
+	CHAN(5080, 20),
+	CHAN(5180, 21),
+	CHAN(5200, 22),
+	CHAN(5220, 23),
+	CHAN(5240, 24),
+	CHAN(5260, 25),
+	CHAN(5280, 26),
+	CHAN(5300, 27),
+	CHAN(5320, 28),
+	CHAN(5500, 29),
+	CHAN(5520, 30),
+	CHAN(5540, 31),
+	CHAN(5560, 32),
+	CHAN(5580, 33),
+	CHAN(5600, 34),
+	CHAN(5620, 35),
+	CHAN(5640, 36),
+	CHAN(5660, 37),
+	CHAN(5680, 38),
+	CHAN(5700, 39),
+	CHAN(5745, 40),
+	CHAN(5765, 41),
+	CHAN(5785, 42),
+	CHAN(5805, 43),
+	CHAN(5825, 44),
+	CHAN(5170, 45),
+	CHAN(5190, 46),
+	CHAN(5210, 47),
+	CHAN(5230, 48),
+};
+#undef CHAN
+
+#define CARL9170_HT_CAP							\
+{									\
+	.ht_supported	= true,						\
+	.cap		= IEEE80211_HT_CAP_MAX_AMSDU |			\
+			  IEEE80211_HT_CAP_SUP_WIDTH_20_40 |		\
+			  IEEE80211_HT_CAP_SGI_40 |			\
+			  IEEE80211_HT_CAP_DSSSCCK40 |			\
+			  IEEE80211_HT_CAP_SM_PS,			\
+	.ampdu_factor	= IEEE80211_HT_MAX_AMPDU_64K,			\
+	.ampdu_density	= IEEE80211_HT_MPDU_DENSITY_8,			\
+	.mcs		= {						\
+		.rx_mask = { 0xff, 0xff, 0, 0, 0x1, 0, 0, 0, 0, 0, },	\
+		.rx_highest = cpu_to_le16(300),				\
+		.tx_params = IEEE80211_HT_MCS_TX_DEFINED,		\
+	},								\
+}
+
+static struct ieee80211_supported_band carl9170_band_2GHz = {
+	.channels	= carl9170_2ghz_chantable,
+	.n_channels	= ARRAY_SIZE(carl9170_2ghz_chantable),
+	.bitrates	= carl9170_g_ratetable,
+	.n_bitrates	= carl9170_g_ratetable_size,
+	.ht_cap		= CARL9170_HT_CAP,
+};
+
+static struct ieee80211_supported_band carl9170_band_5GHz = {
+	.channels	= carl9170_5ghz_chantable,
+	.n_channels	= ARRAY_SIZE(carl9170_5ghz_chantable),
+	.bitrates	= carl9170_a_ratetable,
+	.n_bitrates	= carl9170_a_ratetable_size,
+	.ht_cap		= CARL9170_HT_CAP,
+};
+
+static void carl9170_ampdu_gc(struct ar9170 *ar)
+{
+	struct carl9170_sta_tid *tid_info;
+	LIST_HEAD(tid_gc);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) {
+		spin_lock_bh(&ar->tx_ampdu_list_lock);
+		if (tid_info->state == CARL9170_TID_STATE_SHUTDOWN) {
+			tid_info->state = CARL9170_TID_STATE_KILLED;
+			list_del_rcu(&tid_info->list);
+			ar->tx_ampdu_list_len--;
+			list_add_tail(&tid_info->tmp_list, &tid_gc);
+		}
+		spin_unlock_bh(&ar->tx_ampdu_list_lock);
+
+	}
+	rcu_assign_pointer(ar->tx_ampdu_iter, tid_info);
+	rcu_read_unlock();
+
+	synchronize_rcu();
+
+	while (!list_empty(&tid_gc)) {
+		struct sk_buff *skb;
+		tid_info = list_first_entry(&tid_gc, struct carl9170_sta_tid,
+					    tmp_list);
+
+		while ((skb = __skb_dequeue(&tid_info->queue)))
+			carl9170_tx_status(ar, skb, false);
+
+		list_del_init(&tid_info->tmp_list);
+		kfree(tid_info);
+	}
+}
+
+static void carl9170_flush(struct ar9170 *ar, bool drop_queued)
+{
+	if (drop_queued) {
+		int i;
+
+		/*
+		 * We can only drop frames which have not been uploaded
+		 * to the device yet.
+		 */
+
+		for (i = 0; i < ar->hw->queues; i++) {
+			struct sk_buff *skb;
+
+			while ((skb = skb_dequeue(&ar->tx_pending[i]))) {
+				struct ieee80211_tx_info *info;
+
+				info = IEEE80211_SKB_CB(skb);
+				if (info->flags & IEEE80211_TX_CTL_AMPDU)
+					atomic_dec(&ar->tx_ampdu_upload);
+
+				carl9170_tx_status(ar, skb, false);
+			}
+		}
+	}
+
+	/* Wait for all other outstanding frames to timeout. */
+	if (atomic_read(&ar->tx_total_queued))
+		WARN_ON(wait_for_completion_timeout(&ar->tx_flush, HZ) == 0);
+}
+
+static void carl9170_flush_ba(struct ar9170 *ar)
+{
+	struct sk_buff_head free;
+	struct carl9170_sta_tid *tid_info;
+	struct sk_buff *skb;
+
+	__skb_queue_head_init(&free);
+
+	rcu_read_lock();
+	spin_lock_bh(&ar->tx_ampdu_list_lock);
+	list_for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) {
+		if (tid_info->state > CARL9170_TID_STATE_SUSPEND) {
+			tid_info->state = CARL9170_TID_STATE_SUSPEND;
+
+			spin_lock(&tid_info->lock);
+			while ((skb = __skb_dequeue(&tid_info->queue)))
+				__skb_queue_tail(&free, skb);
+			spin_unlock(&tid_info->lock);
+		}
+	}
+	spin_unlock_bh(&ar->tx_ampdu_list_lock);
+	rcu_read_unlock();
+
+	while ((skb = __skb_dequeue(&free)))
+		carl9170_tx_status(ar, skb, false);
+}
+
+static void carl9170_zap_queues(struct ar9170 *ar)
+{
+	struct carl9170_vif_info *cvif;
+	unsigned int i;
+
+	carl9170_ampdu_gc(ar);
+
+	carl9170_flush_ba(ar);
+	carl9170_flush(ar, true);
+
+	for (i = 0; i < ar->hw->queues; i++) {
+		spin_lock_bh(&ar->tx_status[i].lock);
+		while (!skb_queue_empty(&ar->tx_status[i])) {
+			struct sk_buff *skb;
+
+			skb = skb_peek(&ar->tx_status[i]);
+			carl9170_tx_get_skb(skb);
+			spin_unlock_bh(&ar->tx_status[i].lock);
+			carl9170_tx_drop(ar, skb);
+			spin_lock_bh(&ar->tx_status[i].lock);
+			carl9170_tx_put_skb(skb);
+		}
+		spin_unlock_bh(&ar->tx_status[i].lock);
+	}
+
+	BUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_SOFT < 1);
+	BUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_HARD < CARL9170_NUM_TX_LIMIT_SOFT);
+	BUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_HARD >= CARL9170_BAW_BITS);
+
+	/* reinitialize queues statistics */
+	memset(&ar->tx_stats, 0, sizeof(ar->tx_stats));
+	for (i = 0; i < ar->hw->queues; i++)
+		ar->tx_stats[i].limit = CARL9170_NUM_TX_LIMIT_HARD;
+
+	for (i = 0; i < DIV_ROUND_UP(ar->fw.mem_blocks, BITS_PER_LONG); i++)
+		ar->mem_bitmap[i] = 0;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(cvif, &ar->vif_list, list) {
+		spin_lock_bh(&ar->beacon_lock);
+		dev_kfree_skb_any(cvif->beacon);
+		cvif->beacon = NULL;
+		spin_unlock_bh(&ar->beacon_lock);
+	}
+	rcu_read_unlock();
+
+	atomic_set(&ar->tx_ampdu_upload, 0);
+	atomic_set(&ar->tx_ampdu_scheduler, 0);
+	atomic_set(&ar->tx_total_pending, 0);
+	atomic_set(&ar->tx_total_queued, 0);
+	atomic_set(&ar->mem_free_blocks, ar->fw.mem_blocks);
+}
+
+#define CARL9170_FILL_QUEUE(queue, ai_fs, cwmin, cwmax, _txop)		\
+do {									\
+	queue.aifs = ai_fs;						\
+	queue.cw_min = cwmin;						\
+	queue.cw_max = cwmax;						\
+	queue.txop = _txop;						\
+} while (0)
+
+static int carl9170_op_start(struct ieee80211_hw *hw)
+{
+	struct ar9170 *ar = hw->priv;
+	int err, i;
+
+	mutex_lock(&ar->mutex);
+
+	carl9170_zap_queues(ar);
+
+	/* reset QoS defaults */
+	CARL9170_FILL_QUEUE(ar->edcf[0], 3, 15, 1023,  0); /* BEST EFFORT */
+	CARL9170_FILL_QUEUE(ar->edcf[1], 2, 7,    15, 94); /* VIDEO */
+	CARL9170_FILL_QUEUE(ar->edcf[2], 2, 3,     7, 47); /* VOICE */
+	CARL9170_FILL_QUEUE(ar->edcf[3], 7, 15, 1023,  0); /* BACKGROUND */
+	CARL9170_FILL_QUEUE(ar->edcf[4], 2, 3,     7,  0); /* SPECIAL */
+
+	ar->current_factor = ar->current_density = -1;
+	/* "The first key is unique." */
+	ar->usedkeys = 1;
+	ar->filter_state = 0;
+	ar->ps.last_action = jiffies;
+	ar->ps.last_slept = jiffies;
+	ar->erp_mode = CARL9170_ERP_AUTO;
+	ar->rx_software_decryption = false;
+	ar->disable_offload = false;
+
+	for (i = 0; i < ar->hw->queues; i++) {
+		ar->queue_stop_timeout[i] = jiffies;
+		ar->max_queue_stop_timeout[i] = 0;
+	}
+
+	atomic_set(&ar->mem_allocs, 0);
+
+	err = carl9170_usb_open(ar);
+	if (err)
+		goto out;
+
+	err = carl9170_init_mac(ar);
+	if (err)
+		goto out;
+
+	err = carl9170_set_qos(ar);
+	if (err)
+		goto out;
+
+	if (ar->fw.rx_filter) {
+		err = carl9170_rx_filter(ar, CARL9170_RX_FILTER_OTHER_RA |
+			CARL9170_RX_FILTER_CTL_OTHER | CARL9170_RX_FILTER_BAD);
+		if (err)
+			goto out;
+	}
+
+	err = carl9170_write_reg(ar, AR9170_MAC_REG_DMA_TRIGGER,
+				 AR9170_DMA_TRIGGER_RXQ);
+	if (err)
+		goto out;
+
+	/* Clear key-cache */
+	for (i = 0; i < AR9170_CAM_MAX_USER + 4; i++) {
+		err = carl9170_upload_key(ar, i, NULL, AR9170_ENC_ALG_NONE,
+					  0, NULL, 0);
+		if (err)
+			goto out;
+
+		err = carl9170_upload_key(ar, i, NULL, AR9170_ENC_ALG_NONE,
+					  1, NULL, 0);
+		if (err)
+			goto out;
+
+		if (i < AR9170_CAM_MAX_USER) {
+			err = carl9170_disable_key(ar, i);
+			if (err)
+				goto out;
+		}
+	}
+
+	carl9170_set_state_when(ar, CARL9170_IDLE, CARL9170_STARTED);
+
+	ieee80211_wake_queues(ar->hw);
+	err = 0;
+
+out:
+	mutex_unlock(&ar->mutex);
+	return err;
+}
+
+static void carl9170_cancel_worker(struct ar9170 *ar)
+{
+	cancel_delayed_work_sync(&ar->tx_janitor);
+#ifdef CONFIG_CARL9170_LEDS
+	cancel_delayed_work_sync(&ar->led_work);
+#endif /* CONFIG_CARL9170_LEDS */
+	cancel_work_sync(&ar->ps_work);
+	cancel_work_sync(&ar->ampdu_work);
+}
+
+static void carl9170_op_stop(struct ieee80211_hw *hw)
+{
+	struct ar9170 *ar = hw->priv;
+
+	carl9170_set_state_when(ar, CARL9170_STARTED, CARL9170_IDLE);
+
+	ieee80211_stop_queues(ar->hw);
+
+	mutex_lock(&ar->mutex);
+	if (IS_ACCEPTING_CMD(ar)) {
+		rcu_assign_pointer(ar->beacon_iter, NULL);
+
+		carl9170_led_set_state(ar, 0);
+
+		/* stop DMA */
+		carl9170_write_reg(ar, AR9170_MAC_REG_DMA_TRIGGER, 0);
+		carl9170_usb_stop(ar);
+	}
+
+	carl9170_zap_queues(ar);
+	mutex_unlock(&ar->mutex);
+
+	carl9170_cancel_worker(ar);
+}
+
+static void carl9170_restart_work(struct work_struct *work)
+{
+	struct ar9170 *ar = container_of(work, struct ar9170,
+					 restart_work);
+	int err;
+
+	ar->usedkeys = 0;
+	ar->filter_state = 0;
+	carl9170_cancel_worker(ar);
+
+	mutex_lock(&ar->mutex);
+	err = carl9170_usb_restart(ar);
+	if (net_ratelimit()) {
+		if (err) {
+			dev_err(&ar->udev->dev, "Failed to restart device "
+				" (%d).\n", err);
+		 } else {
+			dev_info(&ar->udev->dev, "device restarted "
+				 "successfully.\n");
+		}
+	}
+
+	carl9170_zap_queues(ar);
+	mutex_unlock(&ar->mutex);
+	if (!err) {
+		ar->restart_counter++;
+		atomic_set(&ar->pending_restarts, 0);
+
+		ieee80211_restart_hw(ar->hw);
+	} else {
+		/*
+		 * The reset was unsuccessful and the device seems to
+		 * be dead. But there's still one option: a low-level
+		 * usb subsystem reset...
+		 */
+
+		carl9170_usb_reset(ar);
+	}
+}
+
+void carl9170_restart(struct ar9170 *ar, const enum carl9170_restart_reasons r)
+{
+	carl9170_set_state_when(ar, CARL9170_STARTED, CARL9170_IDLE);
+
+	/*
+	 * Sometimes, an error can trigger several different reset events.
+	 * By ignoring these *surplus* reset events, the device won't be
+	 * killed again, right after it has recovered.
+	 */
+	if (atomic_inc_return(&ar->pending_restarts) > 1) {
+		dev_dbg(&ar->udev->dev, "ignoring restart (%d)\n", r);
+		return;
+	}
+
+	ieee80211_stop_queues(ar->hw);
+
+	dev_err(&ar->udev->dev, "restart device (%d)\n", r);
+
+	if (!WARN_ON(r == CARL9170_RR_NO_REASON) ||
+	    !WARN_ON(r >= __CARL9170_RR_LAST))
+		ar->last_reason = r;
+
+	if (!ar->registered)
+		return;
+
+	if (IS_ACCEPTING_CMD(ar) && !ar->needs_full_reset)
+		ieee80211_queue_work(ar->hw, &ar->restart_work);
+	else
+		carl9170_usb_reset(ar);
+
+	/*
+	 * At this point, the device instance might have vanished/disabled.
+	 * So, don't put any code which access the ar9170 struct
+	 * without proper protection.
+	 */
+}
+
+static int carl9170_init_interface(struct ar9170 *ar,
+				   struct ieee80211_vif *vif)
+{
+	struct ath_common *common = &ar->common;
+	int err;
+
+	if (!vif) {
+		WARN_ON_ONCE(IS_STARTED(ar));
+		return 0;
+	}
+
+	memcpy(common->macaddr, vif->addr, ETH_ALEN);
+
+	if (modparam_nohwcrypt ||
+	    ((vif->type != NL80211_IFTYPE_STATION) &&
+	     (vif->type != NL80211_IFTYPE_AP))) {
+		ar->rx_software_decryption = true;
+		ar->disable_offload = true;
+	}
+
+	err = carl9170_set_operating_mode(ar);
+	return err;
+}
+
+static int carl9170_op_add_interface(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif)
+{
+	struct carl9170_vif_info *vif_priv = (void *) vif->drv_priv;
+	struct ieee80211_vif *main_vif;
+	struct ar9170 *ar = hw->priv;
+	int vif_id = -1, err = 0;
+
+	mutex_lock(&ar->mutex);
+	rcu_read_lock();
+	if (vif_priv->active) {
+		/*
+		 * Skip the interface structure initialization,
+		 * if the vif survived the _restart call.
+		 */
+		vif_id = vif_priv->id;
+		vif_priv->enable_beacon = false;
+
+		spin_lock_bh(&ar->beacon_lock);
+		dev_kfree_skb_any(vif_priv->beacon);
+		vif_priv->beacon = NULL;
+		spin_unlock_bh(&ar->beacon_lock);
+
+		goto init;
+	}
+
+	main_vif = carl9170_get_main_vif(ar);
+
+	if (main_vif) {
+		switch (main_vif->type) {
+		case NL80211_IFTYPE_STATION:
+			if (vif->type == NL80211_IFTYPE_STATION)
+				break;
+
+			err = -EBUSY;
+			rcu_read_unlock();
+
+			goto unlock;
+
+		case NL80211_IFTYPE_AP:
+			if ((vif->type == NL80211_IFTYPE_STATION) ||
+			    (vif->type == NL80211_IFTYPE_WDS) ||
+			    (vif->type == NL80211_IFTYPE_AP))
+				break;
+
+			err = -EBUSY;
+			rcu_read_unlock();
+			goto unlock;
+
+		default:
+			rcu_read_unlock();
+			goto unlock;
+		}
+	}
+
+	vif_id = bitmap_find_free_region(&ar->vif_bitmap, ar->fw.vif_num, 0);
+
+	if (vif_id < 0) {
+		rcu_read_unlock();
+
+		err = -ENOSPC;
+		goto unlock;
+	}
+
+	BUG_ON(ar->vif_priv[vif_id].id != vif_id);
+
+	vif_priv->active = true;
+	vif_priv->id = vif_id;
+	vif_priv->enable_beacon = false;
+	ar->vifs++;
+	list_add_tail_rcu(&vif_priv->list, &ar->vif_list);
+	rcu_assign_pointer(ar->vif_priv[vif_id].vif, vif);
+
+init:
+	if (carl9170_get_main_vif(ar) == vif) {
+		rcu_assign_pointer(ar->beacon_iter, vif_priv);
+		rcu_read_unlock();
+
+		err = carl9170_init_interface(ar, vif);
+		if (err)
+			goto unlock;
+	} else {
+		err = carl9170_mod_virtual_mac(ar, vif_id, vif->addr);
+		rcu_read_unlock();
+
+		if (err)
+			goto unlock;
+	}
+
+unlock:
+	if (err && (vif_id != -1)) {
+		vif_priv->active = false;
+		bitmap_release_region(&ar->vif_bitmap, vif_id, 0);
+		ar->vifs--;
+		rcu_assign_pointer(ar->vif_priv[vif_id].vif, NULL);
+		list_del_rcu(&vif_priv->list);
+		mutex_unlock(&ar->mutex);
+		synchronize_rcu();
+	} else {
+		if (ar->vifs > 1)
+			ar->ps.off_override |= PS_OFF_VIF;
+
+		mutex_unlock(&ar->mutex);
+	}
+
+	return err;
+}
+
+static void carl9170_op_remove_interface(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif)
+{
+	struct carl9170_vif_info *vif_priv = (void *) vif->drv_priv;
+	struct ieee80211_vif *main_vif;
+	struct ar9170 *ar = hw->priv;
+	unsigned int id;
+
+	mutex_lock(&ar->mutex);
+
+	if (WARN_ON_ONCE(!vif_priv->active))
+		goto unlock;
+
+	ar->vifs--;
+
+	rcu_read_lock();
+	main_vif = carl9170_get_main_vif(ar);
+
+	id = vif_priv->id;
+
+	vif_priv->active = false;
+	WARN_ON(vif_priv->enable_beacon);
+	vif_priv->enable_beacon = false;
+	list_del_rcu(&vif_priv->list);
+	rcu_assign_pointer(ar->vif_priv[id].vif, NULL);
+
+	if (vif == main_vif) {
+		rcu_read_unlock();
+
+		if (ar->vifs) {
+			WARN_ON(carl9170_init_interface(ar,
+					carl9170_get_main_vif(ar)));
+		} else {
+			carl9170_set_operating_mode(ar);
+		}
+	} else {
+		rcu_read_unlock();
+
+		WARN_ON(carl9170_mod_virtual_mac(ar, id, NULL));
+	}
+
+	carl9170_update_beacon(ar, false);
+	carl9170_flush_cab(ar, id);
+
+	spin_lock_bh(&ar->beacon_lock);
+	dev_kfree_skb_any(vif_priv->beacon);
+	vif_priv->beacon = NULL;
+	spin_unlock_bh(&ar->beacon_lock);
+
+	bitmap_release_region(&ar->vif_bitmap, id, 0);
+
+	carl9170_set_beacon_timers(ar);
+
+	if (ar->vifs == 1)
+		ar->ps.off_override &= ~PS_OFF_VIF;
+
+unlock:
+	mutex_unlock(&ar->mutex);
+
+	synchronize_rcu();
+}
+
+void carl9170_ps_check(struct ar9170 *ar)
+{
+	ieee80211_queue_work(ar->hw, &ar->ps_work);
+}
+
+/* caller must hold ar->mutex */
+static int carl9170_ps_update(struct ar9170 *ar)
+{
+	bool ps = false;
+	int err = 0;
+
+	if (!ar->ps.off_override)
+		ps = (ar->hw->conf.flags & IEEE80211_CONF_PS);
+
+	if (ps != ar->ps.state) {
+		err = carl9170_powersave(ar, ps);
+		if (err)
+			return err;
+
+		if (ar->ps.state && !ps) {
+			ar->ps.sleep_ms = jiffies_to_msecs(jiffies -
+				ar->ps.last_action);
+		}
+
+		if (ps)
+			ar->ps.last_slept = jiffies;
+
+		ar->ps.last_action = jiffies;
+		ar->ps.state = ps;
+	}
+
+	return 0;
+}
+
+static void carl9170_ps_work(struct work_struct *work)
+{
+	struct ar9170 *ar = container_of(work, struct ar9170,
+					 ps_work);
+	mutex_lock(&ar->mutex);
+	if (IS_STARTED(ar))
+		WARN_ON_ONCE(carl9170_ps_update(ar) != 0);
+	mutex_unlock(&ar->mutex);
+}
+
+
+static int carl9170_op_config(struct ieee80211_hw *hw, u32 changed)
+{
+	struct ar9170 *ar = hw->priv;
+	int err = 0;
+
+	mutex_lock(&ar->mutex);
+	if (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {
+		/* TODO */
+		err = 0;
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_PS) {
+		err = carl9170_ps_update(ar);
+		if (err)
+			goto out;
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		/* TODO */
+		err = 0;
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_SMPS) {
+		/* TODO */
+		err = 0;
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		/* adjust slot time for 5 GHz */
+		err = carl9170_set_slot_time(ar);
+		if (err)
+			goto out;
+
+		err = carl9170_set_channel(ar, hw->conf.channel,
+			hw->conf.channel_type, CARL9170_RFI_NONE);
+		if (err)
+			goto out;
+
+		err = carl9170_set_dyn_sifs_ack(ar);
+		if (err)
+			goto out;
+
+		err = carl9170_set_rts_cts_rate(ar);
+		if (err)
+			goto out;
+	}
+
+out:
+	mutex_unlock(&ar->mutex);
+	return err;
+}
+
+static u64 carl9170_op_prepare_multicast(struct ieee80211_hw *hw,
+					 struct netdev_hw_addr_list *mc_list)
+{
+	struct netdev_hw_addr *ha;
+	u64 mchash;
+
+	/* always get broadcast frames */
+	mchash = 1ULL << (0xff >> 2);
+
+#if 0
+	netdev_hw_addr_list_for_each(ha, mc_list)
+		mchash |= 1ULL << (ha->addr[5] >> 2);
+#endif
+
+	return mchash;
+}
+
+static void carl9170_op_configure_filter(struct ieee80211_hw *hw,
+					 unsigned int changed_flags,
+					 unsigned int *new_flags,
+					 u64 multicast)
+{
+	struct ar9170 *ar = hw->priv;
+
+	/* mask supported flags */
+	*new_flags &= FIF_ALLMULTI | ar->rx_filter_caps;
+
+	if (!IS_ACCEPTING_CMD(ar))
+		return;
+
+	mutex_lock(&ar->mutex);
+
+	ar->filter_state = *new_flags;
+	/*
+	 * We can support more by setting the sniffer bit and
+	 * then checking the error flags, later.
+	 */
+
+	if (changed_flags & FIF_ALLMULTI && *new_flags & FIF_ALLMULTI)
+		multicast = ~0ULL;
+
+	if (multicast != ar->cur_mc_hash)
+		WARN_ON(carl9170_update_multicast(ar, multicast));
+
+	if (changed_flags & (FIF_OTHER_BSS | FIF_PROMISC_IN_BSS)) {
+		ar->sniffer_enabled = !!(*new_flags &
+			(FIF_OTHER_BSS | FIF_PROMISC_IN_BSS));
+
+		WARN_ON(carl9170_set_operating_mode(ar));
+	}
+
+	if (ar->fw.rx_filter && changed_flags & ar->rx_filter_caps) {
+		u32 rx_filter = 0;
+
+		if (!(*new_flags & (FIF_FCSFAIL | FIF_PLCPFAIL)))
+			rx_filter |= CARL9170_RX_FILTER_BAD;
+
+		if (!(*new_flags & FIF_CONTROL))
+			rx_filter |= CARL9170_RX_FILTER_CTL_OTHER;
+
+		if (!(*new_flags & FIF_PSPOLL))
+			rx_filter |= CARL9170_RX_FILTER_CTL_PSPOLL;
+
+		if (!(*new_flags & (FIF_OTHER_BSS | FIF_PROMISC_IN_BSS))) {
+			rx_filter |= CARL9170_RX_FILTER_OTHER_RA;
+			rx_filter |= CARL9170_RX_FILTER_DECRY_FAIL;
+		}
+
+		WARN_ON(carl9170_rx_filter(ar, rx_filter));
+	}
+
+	mutex_unlock(&ar->mutex);
+}
+
+
+static void carl9170_op_bss_info_changed(struct ieee80211_hw *hw,
+					 struct ieee80211_vif *vif,
+					 struct ieee80211_bss_conf *bss_conf,
+					 u32 changed)
+{
+	struct ar9170 *ar = hw->priv;
+	struct ath_common *common = &ar->common;
+	int err = 0;
+	struct carl9170_vif_info *vif_priv;
+	struct ieee80211_vif *main_vif;
+
+	mutex_lock(&ar->mutex);
+	vif_priv = (void *) vif->drv_priv;
+	main_vif = carl9170_get_main_vif(ar);
+	if (WARN_ON(!main_vif))
+		goto out;
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		struct carl9170_vif_info *iter;
+		int i = 0;
+
+		vif_priv->enable_beacon = bss_conf->enable_beacon;
+		rcu_read_lock();
+		list_for_each_entry_rcu(iter, &ar->vif_list, list) {
+			if (iter->active && iter->enable_beacon)
+				i++;
+
+		}
+		rcu_read_unlock();
+
+		ar->beacon_enabled = i;
+	}
+
+	if (changed & BSS_CHANGED_BEACON) {
+		err = carl9170_update_beacon(ar, false);
+		if (err)
+			goto out;
+	}
+
+	if (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON |
+		       BSS_CHANGED_BEACON_INT)) {
+
+		if (main_vif != vif) {
+			bss_conf->beacon_int = main_vif->bss_conf.beacon_int;
+			bss_conf->dtim_period = main_vif->bss_conf.dtim_period;
+		}
+
+		/*
+		 * Therefore a hard limit for the broadcast traffic should
+		 * prevent false alarms.
+		 */
+		if (vif->type != NL80211_IFTYPE_STATION &&
+		    (bss_conf->beacon_int * bss_conf->dtim_period >=
+		     (CARL9170_QUEUE_STUCK_TIMEOUT / 2))) {
+			err = -EINVAL;
+			goto out;
+		}
+
+		err = carl9170_set_beacon_timers(ar);
+		if (err)
+			goto out;
+	}
+
+	if (changed & BSS_CHANGED_HT) {
+		/* TODO */
+		err = 0;
+		if (err)
+			goto out;
+	}
+
+	if (main_vif != vif)
+		goto out;
+
+	/*
+	 * The following settings can only be changed by the
+	 * master interface.
+	 */
+
+	if (changed & BSS_CHANGED_BSSID) {
+		memcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);
+		err = carl9170_set_operating_mode(ar);
+		if (err)
+			goto out;
+	}
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		ar->common.curaid = bss_conf->aid;
+		err = carl9170_set_beacon_timers(ar);
+		if (err)
+			goto out;
+	}
+
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		err = carl9170_set_slot_time(ar);
+		if (err)
+			goto out;
+	}
+
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		err = carl9170_set_mac_rates(ar);
+		if (err)
+			goto out;
+	}
+
+out:
+	WARN_ON_ONCE(err && IS_STARTED(ar));
+	mutex_unlock(&ar->mutex);
+}
+
+static u64 carl9170_op_get_tsf(struct ieee80211_hw *hw)
+{
+	struct ar9170 *ar = hw->priv;
+	struct carl9170_tsf_rsp tsf;
+	int err;
+
+	mutex_lock(&ar->mutex);
+	err = carl9170_exec_cmd(ar, CARL9170_CMD_READ_TSF,
+				0, NULL, sizeof(tsf), &tsf);
+	mutex_unlock(&ar->mutex);
+	if (WARN_ON(err))
+		return 0;
+
+	return le64_to_cpu(tsf.tsf_64);
+}
+
+static int carl9170_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+			       struct ieee80211_vif *vif,
+			       struct ieee80211_sta *sta,
+			       struct ieee80211_key_conf *key)
+{
+	struct ar9170 *ar = hw->priv;
+	int err = 0, i;
+	u8 ktype;
+
+	return -EOPNOTSUPP;
+}
+
+static int carl9170_op_sta_add(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif,
+			       struct ieee80211_sta *sta)
+{
+	struct carl9170_sta_info *sta_info = (void *) sta->drv_priv;
+	unsigned int i;
+
+	if (sta->ht_cap.ht_supported) {
+		if (sta->ht_cap.ampdu_density > 6) {
+			/*
+			 * HW does support 16us AMPDU density.
+			 * No HT-Xmit for station.
+			 */
+
+			return 0;
+		}
+
+		for (i = 0; i < CARL9170_NUM_TID; i++)
+			rcu_assign_pointer(sta_info->agg[i], NULL);
+
+		sta_info->ampdu_max_len = 1 << (3 + sta->ht_cap.ampdu_factor);
+		sta_info->ht_sta = true;
+	}
+
+	return 0;
+}
+
+static int carl9170_op_sta_remove(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta)
+{
+	struct ar9170 *ar = hw->priv;
+	struct carl9170_sta_info *sta_info = (void *) sta->drv_priv;
+	unsigned int i;
+	bool cleanup = false;
+
+	if (sta->ht_cap.ht_supported) {
+
+		sta_info->ht_sta = false;
+
+		rcu_read_lock();
+		for (i = 0; i < CARL9170_NUM_TID; i++) {
+			struct carl9170_sta_tid *tid_info;
+
+			tid_info = rcu_dereference(sta_info->agg[i]);
+			rcu_assign_pointer(sta_info->agg[i], NULL);
+
+			if (!tid_info)
+				continue;
+
+			spin_lock_bh(&ar->tx_ampdu_list_lock);
+			if (tid_info->state > CARL9170_TID_STATE_SHUTDOWN)
+				tid_info->state = CARL9170_TID_STATE_SHUTDOWN;
+			spin_unlock_bh(&ar->tx_ampdu_list_lock);
+			cleanup = true;
+		}
+		rcu_read_unlock();
+
+		if (cleanup)
+			carl9170_ampdu_gc(ar);
+	}
+
+	return 0;
+}
+
+static int carl9170_op_conf_tx(struct ieee80211_hw *hw, u16 queue,
+			       const struct ieee80211_tx_queue_params *param)
+{
+	struct ar9170 *ar = hw->priv;
+	int ret;
+
+	mutex_lock(&ar->mutex);
+	if (queue < ar->hw->queues) {
+		memcpy(&ar->edcf[ar9170_qmap[queue]], param, sizeof(*param));
+		ret = carl9170_set_qos(ar);
+	} else {
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&ar->mutex);
+	return ret;
+}
+
+static void carl9170_ampdu_work(struct work_struct *work)
+{
+	struct ar9170 *ar = container_of(work, struct ar9170,
+					 ampdu_work);
+
+	if (!IS_STARTED(ar))
+		return;
+
+	mutex_lock(&ar->mutex);
+	carl9170_ampdu_gc(ar);
+	mutex_unlock(&ar->mutex);
+}
+
+static int carl9170_op_ampdu_action(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    enum ieee80211_ampdu_mlme_action action,
+				    struct ieee80211_sta *sta,
+				    u16 tid, u16 *ssn)
+{
+	struct ar9170 *ar = hw->priv;
+	struct carl9170_sta_info *sta_info = (void *) sta->drv_priv;
+	struct carl9170_sta_tid *tid_info;
+
+	if (modparam_noht)
+		return -EOPNOTSUPP;
+
+	switch (action) {
+	case IEEE80211_AMPDU_TX_START:
+		if (!sta_info->ht_sta)
+			return -EOPNOTSUPP;
+
+		rcu_read_lock();
+		if (rcu_dereference(sta_info->agg[tid])) {
+			rcu_read_unlock();
+			return -EBUSY;
+		}
+
+		tid_info = kzalloc(sizeof(struct carl9170_sta_tid),
+				   GFP_ATOMIC);
+		if (!tid_info) {
+			rcu_read_unlock();
+			return -ENOMEM;
+		}
+
+		tid_info->hsn = tid_info->bsn = tid_info->snx = (*ssn);
+		tid_info->state = CARL9170_TID_STATE_PROGRESS;
+		tid_info->tid = tid;
+		tid_info->max = sta_info->ampdu_max_len;
+
+		INIT_LIST_HEAD(&tid_info->list);
+		INIT_LIST_HEAD(&tid_info->tmp_list);
+		skb_queue_head_init(&tid_info->queue);
+		spin_lock_init(&tid_info->lock);
+
+		spin_lock_bh(&ar->tx_ampdu_list_lock);
+		ar->tx_ampdu_list_len++;
+		list_add_tail_rcu(&tid_info->list, &ar->tx_ampdu_list);
+		rcu_assign_pointer(sta_info->agg[tid], tid_info);
+		spin_unlock_bh(&ar->tx_ampdu_list_lock);
+		rcu_read_unlock();
+
+		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		break;
+
+	case IEEE80211_AMPDU_TX_STOP:
+		rcu_read_lock();
+		tid_info = rcu_dereference(sta_info->agg[tid]);
+		if (tid_info) {
+			spin_lock_bh(&ar->tx_ampdu_list_lock);
+			if (tid_info->state > CARL9170_TID_STATE_SHUTDOWN)
+				tid_info->state = CARL9170_TID_STATE_SHUTDOWN;
+			spin_unlock_bh(&ar->tx_ampdu_list_lock);
+		}
+
+		rcu_assign_pointer(sta_info->agg[tid], NULL);
+		rcu_read_unlock();
+
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		ieee80211_queue_work(ar->hw, &ar->ampdu_work);
+		break;
+
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		rcu_read_lock();
+		tid_info = rcu_dereference(sta_info->agg[tid]);
+
+		sta_info->stats[tid].clear = true;
+
+		if (tid_info) {
+			bitmap_zero(tid_info->bitmap, CARL9170_BAW_SIZE);
+			tid_info->state = CARL9170_TID_STATE_IDLE;
+		}
+		rcu_read_unlock();
+
+		if (WARN_ON_ONCE(!tid_info))
+			return -EFAULT;
+
+		break;
+
+	case IEEE80211_AMPDU_RX_START:
+	case IEEE80211_AMPDU_RX_STOP:
+		/* Handled by hardware */
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_CARL9170_WPC
+static int carl9170_register_wps_button(struct ar9170 *ar)
+{
+	struct input_dev *input;
+	int err;
+
+	if (!(ar->features & CARL9170_WPS_BUTTON))
+		return 0;
+
+	input = input_allocate_device();
+	if (!input)
+		return -ENOMEM;
+
+	snprintf(ar->wps.name, sizeof(ar->wps.name), "%s WPS Button",
+		 wiphy_name(ar->hw->wiphy));
+
+	snprintf(ar->wps.phys, sizeof(ar->wps.phys),
+		 "ieee80211/%s/input0", wiphy_name(ar->hw->wiphy));
+
+	input->name = ar->wps.name;
+	input->phys = ar->wps.phys;
+	input->id.bustype = BUS_USB;
+	input->dev.parent = &ar->hw->wiphy->dev;
+
+	input_set_capability(input, EV_KEY, KEY_WPS_BUTTON);
+
+	err = input_register_device(input);
+	if (err) {
+		input_free_device(input);
+		return err;
+	}
+
+	ar->wps.pbc = input;
+	return 0;
+}
+#endif /* CONFIG_CARL9170_WPC */
+
+static int carl9170_op_get_survey(struct ieee80211_hw *hw, int idx,
+				struct survey_info *survey)
+{
+	struct ar9170 *ar = hw->priv;
+	int err;
+
+	if (idx != 0)
+		return -ENOENT;
+
+	mutex_lock(&ar->mutex);
+	err = carl9170_get_noisefloor(ar);
+	mutex_unlock(&ar->mutex);
+	if (err)
+		return err;
+
+	survey->channel = ar->channel;
+	survey->filled = SURVEY_INFO_NOISE_DBM;
+	survey->noise = ar->noise[0];
+	return 0;
+}
+
+static void carl9170_op_flush(struct ieee80211_hw *hw, bool drop)
+{
+	struct ar9170 *ar = hw->priv;
+	unsigned int vid;
+
+	mutex_lock(&ar->mutex);
+	for_each_set_bit(vid, &ar->vif_bitmap, ar->fw.vif_num)
+		carl9170_flush_cab(ar, vid);
+
+	carl9170_flush(ar, drop);
+	mutex_unlock(&ar->mutex);
+}
+
+static int carl9170_op_get_stats(struct ieee80211_hw *hw,
+				 struct ieee80211_low_level_stats *stats)
+{
+	struct ar9170 *ar = hw->priv;
+
+	memset(stats, 0, sizeof(*stats));
+	stats->dot11ACKFailureCount = ar->tx_ack_failures;
+	stats->dot11FCSErrorCount = ar->tx_fcs_errors;
+	return 0;
+}
+
+static void carl9170_op_sta_notify(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   enum sta_notify_cmd cmd,
+				   struct ieee80211_sta *sta)
+{
+	struct ar9170 *ar = hw->priv;
+	struct carl9170_sta_info *sta_info = (void *) sta->drv_priv;
+	struct sk_buff *skb, *tmp;
+	struct sk_buff_head free;
+	int i;
+
+	switch (cmd) {
+	case STA_NOTIFY_SLEEP:
+		/*
+		 * Since the peer is no longer listening, we have to return
+		 * as many SKBs as possible back to the mac80211 stack.
+		 * It will deal with the retry procedure, once the peer
+		 * has become available again.
+		 *
+		 * NB: Ideally, the driver should return the all frames in
+		 * the correct, ascending order. However, I think that this
+		 * functionality should be implemented in the stack and not
+		 * here...
+		 */
+
+		__skb_queue_head_init(&free);
+
+		if (sta->ht_cap.ht_supported) {
+			rcu_read_lock();
+			for (i = 0; i < CARL9170_NUM_TID; i++) {
+				struct carl9170_sta_tid *tid_info;
+
+				tid_info = rcu_dereference(sta_info->agg[i]);
+
+				if (!tid_info)
+					continue;
+
+				spin_lock_bh(&ar->tx_ampdu_list_lock);
+				if (tid_info->state >
+				    CARL9170_TID_STATE_SUSPEND)
+					tid_info->state =
+						CARL9170_TID_STATE_SUSPEND;
+				spin_unlock_bh(&ar->tx_ampdu_list_lock);
+
+				spin_lock_bh(&tid_info->lock);
+				while ((skb = __skb_dequeue(&tid_info->queue)))
+					__skb_queue_tail(&free, skb);
+				spin_unlock_bh(&tid_info->lock);
+			}
+			rcu_read_unlock();
+		}
+
+		for (i = 0; i < ar->hw->queues; i++) {
+			spin_lock_bh(&ar->tx_pending[i].lock);
+			skb_queue_walk_safe(&ar->tx_pending[i], skb, tmp) {
+				struct _carl9170_tx_superframe *super;
+				struct ieee80211_hdr *hdr;
+				struct ieee80211_tx_info *info;
+
+				super = (void *) skb->data;
+				hdr = (void *) super->frame_data;
+
+				if (compare_ether_addr(hdr->addr1, sta->addr))
+					continue;
+
+				__skb_unlink(skb, &ar->tx_pending[i]);
+
+				info = IEEE80211_SKB_CB(skb);
+				if (info->flags & IEEE80211_TX_CTL_AMPDU)
+					atomic_dec(&ar->tx_ampdu_upload);
+
+				carl9170_tx_status(ar, skb, false);
+			}
+			spin_unlock_bh(&ar->tx_pending[i].lock);
+		}
+
+		while ((skb = __skb_dequeue(&free)))
+			carl9170_tx_status(ar, skb, false);
+
+		break;
+
+	case STA_NOTIFY_AWAKE:
+		if (!sta->ht_cap.ht_supported)
+			return;
+
+		rcu_read_lock();
+		for (i = 0; i < CARL9170_NUM_TID; i++) {
+			struct carl9170_sta_tid *tid_info;
+
+			tid_info = rcu_dereference(sta_info->agg[i]);
+
+			if (!tid_info)
+				continue;
+
+			if ((tid_info->state == CARL9170_TID_STATE_SUSPEND))
+				tid_info->state = CARL9170_TID_STATE_IDLE;
+		}
+		rcu_read_unlock();
+		break;
+	}
+}
+
+static const struct ieee80211_ops carl9170_ops = {
+	.start			= carl9170_op_start,
+	.stop			= carl9170_op_stop,
+	.tx			= carl9170_op_tx,
+	.flush			= carl9170_op_flush,
+	.add_interface		= carl9170_op_add_interface,
+	.remove_interface	= carl9170_op_remove_interface,
+	.config			= carl9170_op_config,
+	.prepare_multicast	= carl9170_op_prepare_multicast,
+	.configure_filter	= carl9170_op_configure_filter,
+	.conf_tx		= carl9170_op_conf_tx,
+	.bss_info_changed	= carl9170_op_bss_info_changed,
+	.get_tsf		= carl9170_op_get_tsf,
+	.set_key		= carl9170_op_set_key,
+	.sta_add		= carl9170_op_sta_add,
+	.sta_remove		= carl9170_op_sta_remove,
+	.sta_notify		= carl9170_op_sta_notify,
+//	.get_survey		= carl9170_op_get_survey,
+	.get_stats		= carl9170_op_get_stats,
+	.ampdu_action		= carl9170_op_ampdu_action,
+};
+
+void *carl9170_alloc(size_t priv_size)
+{
+	struct ieee80211_hw *hw;
+	struct ar9170 *ar;
+	struct sk_buff *skb;
+	int i;
+
+	/*
+	 * this buffer is used for rx stream reconstruction.
+	 * Under heavy load this device (or the transport layer?)
+	 * tends to split the streams into separate rx descriptors.
+	 */
+
+	skb = __dev_alloc_skb(AR9170_RX_STREAM_MAX_SIZE, GFP_KERNEL);
+	if (!skb)
+		goto err_nomem;
+
+	hw = ieee80211_alloc_hw(priv_size, &carl9170_ops);
+	if (!hw)
+		goto err_nomem;
+
+	ar = hw->priv;
+	ar->hw = hw;
+	ar->rx_failover = skb;
+
+	memset(&ar->rx_plcp, 0, sizeof(struct ar9170_rx_head));
+	ar->rx_has_plcp = false;
+
+	/*
+	 * Here's a hidden pitfall!
+	 *
+	 * All 4 AC queues work perfectly well under _legacy_ operation.
+	 * However as soon as aggregation is enabled, the traffic flow
+	 * gets very bumpy. Therefore we have to _switch_ to a
+	 * software AC with a single HW queue.
+	 */
+	hw->queues = __AR9170_NUM_TXQ;
+
+	mutex_init(&ar->mutex);
+	spin_lock_init(&ar->beacon_lock);
+	spin_lock_init(&ar->cmd_lock);
+	spin_lock_init(&ar->tx_stats_lock);
+	spin_lock_init(&ar->tx_ampdu_list_lock);
+	spin_lock_init(&ar->mem_lock);
+	spin_lock_init(&ar->state_lock);
+	atomic_set(&ar->pending_restarts, 0);
+	ar->vifs = 0;
+	for (i = 0; i < ar->hw->queues; i++) {
+		skb_queue_head_init(&ar->tx_status[i]);
+		skb_queue_head_init(&ar->tx_pending[i]);
+	}
+	INIT_WORK(&ar->ps_work, carl9170_ps_work);
+	INIT_WORK(&ar->restart_work, carl9170_restart_work);
+	INIT_WORK(&ar->ampdu_work, carl9170_ampdu_work);
+	INIT_DELAYED_WORK(&ar->tx_janitor, carl9170_tx_janitor);
+	INIT_LIST_HEAD(&ar->tx_ampdu_list);
+	rcu_assign_pointer(ar->tx_ampdu_iter,
+			   (struct carl9170_sta_tid *) &ar->tx_ampdu_list);
+
+	bitmap_zero(&ar->vif_bitmap, ar->fw.vif_num);
+	INIT_LIST_HEAD(&ar->vif_list);
+	init_completion(&ar->tx_flush);
+
+	/*
+	 * Note:
+	 * IBSS/ADHOC and AP mode are only enabled, if the firmware
+	 * supports these modes. The code which will add the
+	 * additional interface_modes is in fw.c.
+	 */
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+
+	hw->flags |= IEEE80211_HW_RX_INCLUDES_FCS |
+		     IEEE80211_HW_REPORTS_TX_ACK_STATUS |
+		     IEEE80211_HW_SUPPORTS_PS |
+		     IEEE80211_HW_PS_NULLFUNC_STACK |
+		     IEEE80211_HW_SIGNAL_DBM;
+
+	if (!modparam_noht) {
+		/*
+		 * see the comment above, why we allow the user
+		 * to disable HT by a module parameter.
+		 */
+		hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
+	}
+
+	hw->extra_tx_headroom = sizeof(struct _carl9170_tx_superframe);
+	hw->sta_data_size = sizeof(struct carl9170_sta_info);
+	hw->vif_data_size = sizeof(struct carl9170_vif_info);
+
+	hw->max_rates = CARL9170_TX_MAX_RATES;
+	hw->max_rate_tries = CARL9170_TX_USER_RATE_TRIES;
+
+	for (i = 0; i < ARRAY_SIZE(ar->noise); i++)
+		ar->noise[i] = -95; /* ATH_DEFAULT_NOISE_FLOOR */
+
+	hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+	return ar;
+
+err_nomem:
+	kfree_skb(skb);
+	return ERR_PTR(-ENOMEM);
+}
+
+static int carl9170_read_eeprom(struct ar9170 *ar)
+{
+#define RW	8	/* number of words to read at once */
+#define RB	(sizeof(u32) * RW)
+	u8 *eeprom = (void *)&ar->eeprom;
+	__le32 offsets[RW];
+	int i, j, err;
+
+	BUILD_BUG_ON(sizeof(ar->eeprom) & 3);
+
+	BUILD_BUG_ON(RB > CARL9170_MAX_CMD_LEN - 4);
+#ifndef __CHECKER__
+	/* don't want to handle trailing remains */
+	BUILD_BUG_ON(sizeof(ar->eeprom) % RB);
+#endif
+
+	for (i = 0; i < sizeof(ar->eeprom)/RB; i++) {
+		for (j = 0; j < RW; j++)
+			offsets[j] = cpu_to_le32(AR9170_EEPROM_START +
+						 RB * i + 4 * j);
+
+		err = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,
+					RB, (u8 *) &offsets,
+					RB, eeprom + RB * i);
+		if (err)
+			return err;
+	}
+
+#undef RW
+#undef RB
+	return 0;
+}
+
+static int carl9170_parse_eeprom(struct ar9170 *ar)
+{
+	struct ath_regulatory *regulatory = &ar->common.regulatory;
+	unsigned int rx_streams, tx_streams, tx_params = 0;
+	int bands = 0;
+
+	if (ar->eeprom.length == cpu_to_le16(0xffff))
+		return -ENODATA;
+
+	rx_streams = hweight8(ar->eeprom.rx_mask);
+	tx_streams = hweight8(ar->eeprom.tx_mask);
+
+	if (rx_streams != tx_streams) {
+		tx_params = IEEE80211_HT_MCS_TX_RX_DIFF;
+
+		WARN_ON(!(tx_streams >= 1 && tx_streams <=
+			IEEE80211_HT_MCS_TX_MAX_STREAMS));
+
+		tx_params = (tx_streams - 1) <<
+			    IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;
+
+		carl9170_band_2GHz.ht_cap.mcs.tx_params |= tx_params;
+		carl9170_band_5GHz.ht_cap.mcs.tx_params |= tx_params;
+	}
+
+	if (ar->eeprom.operating_flags & AR9170_OPFLAG_2GHZ) {
+		ar->hw->wiphy->bands[IEEE80211_BAND_2GHZ] =
+			&carl9170_band_2GHz;
+		bands++;
+	}
+	if (ar->eeprom.operating_flags & AR9170_OPFLAG_5GHZ) {
+		ar->hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
+			&carl9170_band_5GHz;
+		bands++;
+	}
+
+	/*
+	 * I measured this, a bandswitch takes roughly
+	 * 135 ms and a frequency switch about 80.
+	 *
+	 * FIXME: measure these values again once EEPROM settings
+	 *	  are used, that will influence them!
+	 */
+	if (bands == 2)
+		ar->hw->channel_change_time = 135 * 1000;
+	else
+		ar->hw->channel_change_time = 80 * 1000;
+
+	regulatory->current_rd = le16_to_cpu(ar->eeprom.reg_domain[0]);
+	regulatory->current_rd_ext = le16_to_cpu(ar->eeprom.reg_domain[1]);
+
+	/* second part of wiphy init */
+	SET_IEEE80211_PERM_ADDR(ar->hw, ar->eeprom.mac_address);
+
+	return bands ? 0 : -EINVAL;
+}
+
+static int carl9170_reg_notifier(struct wiphy *wiphy,
+				 struct regulatory_request *request)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct ar9170 *ar = hw->priv;
+
+	return ath_reg_notifier_apply(wiphy, request, &ar->common.regulatory);
+}
+
+int carl9170_register(struct ar9170 *ar)
+{
+	struct ath_regulatory *regulatory = &ar->common.regulatory;
+	int err = 0, i;
+
+	if (WARN_ON(ar->mem_bitmap))
+		return -EINVAL;
+
+	ar->mem_bitmap = kzalloc(roundup(ar->fw.mem_blocks, BITS_PER_LONG) *
+				 sizeof(unsigned long), GFP_KERNEL);
+
+	if (!ar->mem_bitmap)
+		return -ENOMEM;
+
+	/* try to read EEPROM, init MAC addr */
+	err = carl9170_read_eeprom(ar);
+	if (err)
+		return err;
+
+	err = carl9170_fw_fix_eeprom(ar);
+	if (err)
+		return err;
+
+	err = carl9170_parse_eeprom(ar);
+	if (err)
+		return err;
+
+	err = ath_regd_init(regulatory, ar->hw->wiphy,
+			    carl9170_reg_notifier);
+	if (err)
+		return err;
+
+	if (modparam_noht) {
+		carl9170_band_2GHz.ht_cap.ht_supported = false;
+		carl9170_band_5GHz.ht_cap.ht_supported = false;
+	}
+
+	for (i = 0; i < ar->fw.vif_num; i++) {
+		ar->vif_priv[i].id = i;
+		ar->vif_priv[i].vif = NULL;
+	}
+
+	err = ieee80211_register_hw(ar->hw);
+	if (err)
+		return err;
+
+	/* mac80211 interface is now registered */
+	ar->registered = true;
+
+	if (!ath_is_world_regd(regulatory))
+		regulatory_hint(ar->hw->wiphy, regulatory->alpha2);
+
+#ifdef CONFIG_CARL9170_DEBUGFS
+	carl9170_debugfs_register(ar);
+#endif /* CONFIG_CARL9170_DEBUGFS */
+
+	err = carl9170_led_init(ar);
+	if (err)
+		goto err_unreg;
+
+#ifdef CONFIG_CARL9170_LEDS
+	err = carl9170_led_register(ar);
+	if (err)
+		goto err_unreg;
+#endif /* CONFIG_CAR9L170_LEDS */
+
+#ifdef CONFIG_CARL9170_WPC
+	err = carl9170_register_wps_button(ar);
+	if (err)
+		goto err_unreg;
+#endif /* CONFIG_CARL9170_WPC */
+
+	dev_info(&ar->udev->dev, "Atheros AR9170 is registered as '%s'\n",
+		 wiphy_name(ar->hw->wiphy));
+
+	return 0;
+
+err_unreg:
+	carl9170_unregister(ar);
+	return err;
+}
+
+void carl9170_unregister(struct ar9170 *ar)
+{
+	if (!ar->registered)
+		return;
+
+	ar->registered = false;
+
+#ifdef CONFIG_CARL9170_LEDS
+	carl9170_led_unregister(ar);
+#endif /* CONFIG_CARL9170_LEDS */
+
+#ifdef CONFIG_CARL9170_DEBUGFS
+	carl9170_debugfs_unregister(ar);
+#endif /* CONFIG_CARL9170_DEBUGFS */
+
+#ifdef CONFIG_CARL9170_WPC
+	if (ar->wps.pbc) {
+		input_unregister_device(ar->wps.pbc);
+		ar->wps.pbc = NULL;
+	}
+#endif /* CONFIG_CARL9170_WPC */
+
+	carl9170_cancel_worker(ar);
+	cancel_work_sync(&ar->restart_work);
+
+	ieee80211_unregister_hw(ar->hw);
+}
+
+void carl9170_free(struct ar9170 *ar)
+{
+	WARN_ON(ar->registered);
+	WARN_ON(IS_INITIALIZED(ar));
+
+	kfree_skb(ar->rx_failover);
+	ar->rx_failover = NULL;
+
+	kfree(ar->mem_bitmap);
+	ar->mem_bitmap = NULL;
+
+	mutex_destroy(&ar->mutex);
+
+	ieee80211_free_hw(ar->hw);
+}
diff --git a/drivers/net/wireless/ath/carl9170/phy.c b/drivers/net/wireless/ath/carl9170/phy.c
new file mode 100644
index 0000000..89deca3
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/phy.c
@@ -0,0 +1,1810 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * PHY and RF code
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/bitrev.h>
+#include "carl9170.h"
+#include "cmd.h"
+#include "phy.h"
+
+static int carl9170_init_power_cal(struct ar9170 *ar)
+{
+	carl9170_regwrite_begin(ar);
+
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE_MAX, 0x7f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE1, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE2, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE3, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE4, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE5, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE6, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE7, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE8, 0x3f3f3f3f);
+	carl9170_regwrite(AR9170_PHY_REG_POWER_TX_RATE9, 0x3f3f3f3f);
+
+	carl9170_regwrite_finish();
+	return carl9170_regwrite_result();
+}
+
+struct carl9170_phy_init {
+	u32 reg, _5ghz_20, _5ghz_40, _2ghz_40, _2ghz_20;
+};
+
+static struct carl9170_phy_init ar5416_phy_init[] = {
+	{ 0x1c5800, 0x00000007, 0x00000007, 0x00000007, 0x00000007, },
+	{ 0x1c5804, 0x00000300, 0x000003c4, 0x000003c4, 0x00000300, },
+	{ 0x1c5808, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c580c, 0xad848e19, 0xad848e19, 0xad848e19, 0xad848e19, },
+	{ 0x1c5810, 0x7d14e000, 0x7d14e000, 0x7d14e000, 0x7d14e000, },
+	{ 0x1c5814, 0x9c0a9f6b, 0x9c0a9f6b, 0x9c0a9f6b, 0x9c0a9f6b, },
+	{ 0x1c5818, 0x00000090, 0x00000090, 0x00000090, 0x00000090, },
+	{ 0x1c581c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5820, 0x02020200, 0x02020200, 0x02020200, 0x02020200, },
+	{ 0x1c5824, 0x00000e0e, 0x00000e0e, 0x00000e0e, 0x00000e0e, },
+	{ 0x1c5828, 0x0a020001, 0x0a020001, 0x0a020001, 0x0a020001, },
+	{ 0x1c582c, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, },
+	{ 0x1c5830, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5834, 0x00000e0e, 0x00000e0e, 0x00000e0e, 0x00000e0e, },
+	{ 0x1c5838, 0x00000007, 0x00000007, 0x00000007, 0x00000007, },
+	{ 0x1c583c, 0x00200400, 0x00200400, 0x00200400, 0x00200400, },
+	{ 0x1c5840, 0x206a002e, 0x206a002e, 0x206a002e, 0x206a002e, },
+	{ 0x1c5844, 0x1372161e, 0x13721c1e, 0x13721c24, 0x137216a4, },
+	{ 0x1c5848, 0x001a6a65, 0x001a6a65, 0x00197a68, 0x00197a68, },
+	{ 0x1c584c, 0x1284233c, 0x1284233c, 0x1284233c, 0x1284233c, },
+	{ 0x1c5850, 0x6c48b4e4, 0x6d48b4e4, 0x6d48b0e4, 0x6c48b0e4, },
+	{ 0x1c5854, 0x00000859, 0x00000859, 0x00000859, 0x00000859, },
+	{ 0x1c5858, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e, },
+	{ 0x1c585c, 0x31395c5e, 0x3139605e, 0x3139605e, 0x31395c5e, },
+	{ 0x1c5860, 0x0004dd10, 0x0004dd10, 0x0004dd20, 0x0004dd20, },
+	{ 0x1c5864, 0x0001c600, 0x0001c600, 0x0001c600, 0x0001c600, },
+	{ 0x1c5868, 0x409a4190, 0x409a4190, 0x409a4190, 0x409a4190, },
+	{ 0x1c586c, 0x050cb081, 0x050cb081, 0x050cb081, 0x050cb081, },
+	{ 0x1c5900, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5904, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5908, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c590c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5914, 0x000007d0, 0x000007d0, 0x00000898, 0x00000898, },
+	{ 0x1c5918, 0x00000118, 0x00000230, 0x00000268, 0x00000134, },
+	{ 0x1c591c, 0x10000fff, 0x10000fff, 0x10000fff, 0x10000fff, },
+	{ 0x1c5920, 0x0510081c, 0x0510081c, 0x0510001c, 0x0510001c, },
+	{ 0x1c5924, 0xd0058a15, 0xd0058a15, 0xd0058a15, 0xd0058a15, },
+	{ 0x1c5928, 0x00000001, 0x00000001, 0x00000001, 0x00000001, },
+	{ 0x1c592c, 0x00000004, 0x00000004, 0x00000004, 0x00000004, },
+	{ 0x1c5934, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c5938, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c593c, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, },
+	{ 0x1c5944, 0xdfb81020, 0xdfb81020, 0xdfb81020, 0xdfb81020, },
+	{ 0x1c5948, 0x9280b212, 0x9280b212, 0x9280b212, 0x9280b212, },
+	{ 0x1c594c, 0x00020028, 0x00020028, 0x00020028, 0x00020028, },
+	{ 0x1c5954, 0x5d50e188, 0x5d50e188, 0x5d50e188, 0x5d50e188, },
+	{ 0x1c5958, 0x00081fff, 0x00081fff, 0x00081fff, 0x00081fff, },
+	{ 0x1c5960, 0x00009b40, 0x00009b40, 0x00009b40, 0x00009b40, },
+	{ 0x1c5964, 0x00001120, 0x00001120, 0x00001120, 0x00001120, },
+	{ 0x1c5970, 0x190fb515, 0x190fb515, 0x190fb515, 0x190fb515, },
+	{ 0x1c5974, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5978, 0x00000001, 0x00000001, 0x00000001, 0x00000001, },
+	{ 0x1c597c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5980, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5984, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5988, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c598c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5990, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5994, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5998, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c599c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59a0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59a4, 0x00000007, 0x00000007, 0x00000007, 0x00000007, },
+	{ 0x1c59a8, 0x001fff00, 0x001fff00, 0x001fff00, 0x001fff00, },
+	{ 0x1c59ac, 0x006f00c4, 0x006f00c4, 0x006f00c4, 0x006f00c4, },
+	{ 0x1c59b0, 0x03051000, 0x03051000, 0x03051000, 0x03051000, },
+	{ 0x1c59b4, 0x00000820, 0x00000820, 0x00000820, 0x00000820, },
+	{ 0x1c59bc, 0x00181400, 0x00181400, 0x00181400, 0x00181400, },
+	{ 0x1c59c0, 0x038919be, 0x038919be, 0x038919be, 0x038919be, },
+	{ 0x1c59c4, 0x06336f77, 0x06336f77, 0x06336f77, 0x06336f77, },
+	{ 0x1c59c8, 0x6af6532c, 0x6af6532c, 0x6af6532c, 0x6af6532c, },
+	{ 0x1c59cc, 0x08f186c8, 0x08f186c8, 0x08f186c8, 0x08f186c8, },
+	{ 0x1c59d0, 0x00046384, 0x00046384, 0x00046384, 0x00046384, },
+	{ 0x1c59d4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59d8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59dc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59e0, 0x00000200, 0x00000200, 0x00000200, 0x00000200, },
+	{ 0x1c59e4, 0x64646464, 0x64646464, 0x64646464, 0x64646464, },
+	{ 0x1c59e8, 0x3c787878, 0x3c787878, 0x3c787878, 0x3c787878, },
+	{ 0x1c59ec, 0x000000aa, 0x000000aa, 0x000000aa, 0x000000aa, },
+	{ 0x1c59f0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c59fc, 0x00001042, 0x00001042, 0x00001042, 0x00001042, },
+	{ 0x1c5a00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5a04, 0x00000040, 0x00000040, 0x00000040, 0x00000040, },
+	{ 0x1c5a08, 0x00000080, 0x00000080, 0x00000080, 0x00000080, },
+	{ 0x1c5a0c, 0x000001a1, 0x000001a1, 0x00000141, 0x00000141, },
+	{ 0x1c5a10, 0x000001e1, 0x000001e1, 0x00000181, 0x00000181, },
+	{ 0x1c5a14, 0x00000021, 0x00000021, 0x000001c1, 0x000001c1, },
+	{ 0x1c5a18, 0x00000061, 0x00000061, 0x00000001, 0x00000001, },
+	{ 0x1c5a1c, 0x00000168, 0x00000168, 0x00000041, 0x00000041, },
+	{ 0x1c5a20, 0x000001a8, 0x000001a8, 0x000001a8, 0x000001a8, },
+	{ 0x1c5a24, 0x000001e8, 0x000001e8, 0x000001e8, 0x000001e8, },
+	{ 0x1c5a28, 0x00000028, 0x00000028, 0x00000028, 0x00000028, },
+	{ 0x1c5a2c, 0x00000068, 0x00000068, 0x00000068, 0x00000068, },
+	{ 0x1c5a30, 0x00000189, 0x00000189, 0x000000a8, 0x000000a8, },
+	{ 0x1c5a34, 0x000001c9, 0x000001c9, 0x00000169, 0x00000169, },
+	{ 0x1c5a38, 0x00000009, 0x00000009, 0x000001a9, 0x000001a9, },
+	{ 0x1c5a3c, 0x00000049, 0x00000049, 0x000001e9, 0x000001e9, },
+	{ 0x1c5a40, 0x00000089, 0x00000089, 0x00000029, 0x00000029, },
+	{ 0x1c5a44, 0x00000170, 0x00000170, 0x00000069, 0x00000069, },
+	{ 0x1c5a48, 0x000001b0, 0x000001b0, 0x00000190, 0x00000190, },
+	{ 0x1c5a4c, 0x000001f0, 0x000001f0, 0x000001d0, 0x000001d0, },
+	{ 0x1c5a50, 0x00000030, 0x00000030, 0x00000010, 0x00000010, },
+	{ 0x1c5a54, 0x00000070, 0x00000070, 0x00000050, 0x00000050, },
+	{ 0x1c5a58, 0x00000191, 0x00000191, 0x00000090, 0x00000090, },
+	{ 0x1c5a5c, 0x000001d1, 0x000001d1, 0x00000151, 0x00000151, },
+	{ 0x1c5a60, 0x00000011, 0x00000011, 0x00000191, 0x00000191, },
+	{ 0x1c5a64, 0x00000051, 0x00000051, 0x000001d1, 0x000001d1, },
+	{ 0x1c5a68, 0x00000091, 0x00000091, 0x00000011, 0x00000011, },
+	{ 0x1c5a6c, 0x000001b8, 0x000001b8, 0x00000051, 0x00000051, },
+	{ 0x1c5a70, 0x000001f8, 0x000001f8, 0x00000198, 0x00000198, },
+	{ 0x1c5a74, 0x00000038, 0x00000038, 0x000001d8, 0x000001d8, },
+	{ 0x1c5a78, 0x00000078, 0x00000078, 0x00000018, 0x00000018, },
+	{ 0x1c5a7c, 0x00000199, 0x00000199, 0x00000058, 0x00000058, },
+	{ 0x1c5a80, 0x000001d9, 0x000001d9, 0x00000098, 0x00000098, },
+	{ 0x1c5a84, 0x00000019, 0x00000019, 0x00000159, 0x00000159, },
+	{ 0x1c5a88, 0x00000059, 0x00000059, 0x00000199, 0x00000199, },
+	{ 0x1c5a8c, 0x00000099, 0x00000099, 0x000001d9, 0x000001d9, },
+	{ 0x1c5a90, 0x000000d9, 0x000000d9, 0x00000019, 0x00000019, },
+	{ 0x1c5a94, 0x000000f9, 0x000000f9, 0x00000059, 0x00000059, },
+	{ 0x1c5a98, 0x000000f9, 0x000000f9, 0x00000099, 0x00000099, },
+	{ 0x1c5a9c, 0x000000f9, 0x000000f9, 0x000000d9, 0x000000d9, },
+	{ 0x1c5aa0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5aa4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5aa8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5aac, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ab0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ab4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ab8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5abc, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ac0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ac4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ac8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5acc, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ad0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ad4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ad8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5adc, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ae0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ae4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5ae8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5aec, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5af0, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5af4, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5af8, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5afc, 0x000000f9, 0x000000f9, 0x000000f9, 0x000000f9, },
+	{ 0x1c5b00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5b04, 0x00000001, 0x00000001, 0x00000001, 0x00000001, },
+	{ 0x1c5b08, 0x00000002, 0x00000002, 0x00000002, 0x00000002, },
+	{ 0x1c5b0c, 0x00000003, 0x00000003, 0x00000003, 0x00000003, },
+	{ 0x1c5b10, 0x00000004, 0x00000004, 0x00000004, 0x00000004, },
+	{ 0x1c5b14, 0x00000005, 0x00000005, 0x00000005, 0x00000005, },
+	{ 0x1c5b18, 0x00000008, 0x00000008, 0x00000008, 0x00000008, },
+	{ 0x1c5b1c, 0x00000009, 0x00000009, 0x00000009, 0x00000009, },
+	{ 0x1c5b20, 0x0000000a, 0x0000000a, 0x0000000a, 0x0000000a, },
+	{ 0x1c5b24, 0x0000000b, 0x0000000b, 0x0000000b, 0x0000000b, },
+	{ 0x1c5b28, 0x0000000c, 0x0000000c, 0x0000000c, 0x0000000c, },
+	{ 0x1c5b2c, 0x0000000d, 0x0000000d, 0x0000000d, 0x0000000d, },
+	{ 0x1c5b30, 0x00000010, 0x00000010, 0x00000010, 0x00000010, },
+	{ 0x1c5b34, 0x00000011, 0x00000011, 0x00000011, 0x00000011, },
+	{ 0x1c5b38, 0x00000012, 0x00000012, 0x00000012, 0x00000012, },
+	{ 0x1c5b3c, 0x00000013, 0x00000013, 0x00000013, 0x00000013, },
+	{ 0x1c5b40, 0x00000014, 0x00000014, 0x00000014, 0x00000014, },
+	{ 0x1c5b44, 0x00000015, 0x00000015, 0x00000015, 0x00000015, },
+	{ 0x1c5b48, 0x00000018, 0x00000018, 0x00000018, 0x00000018, },
+	{ 0x1c5b4c, 0x00000019, 0x00000019, 0x00000019, 0x00000019, },
+	{ 0x1c5b50, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a, },
+	{ 0x1c5b54, 0x0000001b, 0x0000001b, 0x0000001b, 0x0000001b, },
+	{ 0x1c5b58, 0x0000001c, 0x0000001c, 0x0000001c, 0x0000001c, },
+	{ 0x1c5b5c, 0x0000001d, 0x0000001d, 0x0000001d, 0x0000001d, },
+	{ 0x1c5b60, 0x00000020, 0x00000020, 0x00000020, 0x00000020, },
+	{ 0x1c5b64, 0x00000021, 0x00000021, 0x00000021, 0x00000021, },
+	{ 0x1c5b68, 0x00000022, 0x00000022, 0x00000022, 0x00000022, },
+	{ 0x1c5b6c, 0x00000023, 0x00000023, 0x00000023, 0x00000023, },
+	{ 0x1c5b70, 0x00000024, 0x00000024, 0x00000024, 0x00000024, },
+	{ 0x1c5b74, 0x00000025, 0x00000025, 0x00000025, 0x00000025, },
+	{ 0x1c5b78, 0x00000028, 0x00000028, 0x00000028, 0x00000028, },
+	{ 0x1c5b7c, 0x00000029, 0x00000029, 0x00000029, 0x00000029, },
+	{ 0x1c5b80, 0x0000002a, 0x0000002a, 0x0000002a, 0x0000002a, },
+	{ 0x1c5b84, 0x0000002b, 0x0000002b, 0x0000002b, 0x0000002b, },
+	{ 0x1c5b88, 0x0000002c, 0x0000002c, 0x0000002c, 0x0000002c, },
+	{ 0x1c5b8c, 0x0000002d, 0x0000002d, 0x0000002d, 0x0000002d, },
+	{ 0x1c5b90, 0x00000030, 0x00000030, 0x00000030, 0x00000030, },
+	{ 0x1c5b94, 0x00000031, 0x00000031, 0x00000031, 0x00000031, },
+	{ 0x1c5b98, 0x00000032, 0x00000032, 0x00000032, 0x00000032, },
+	{ 0x1c5b9c, 0x00000033, 0x00000033, 0x00000033, 0x00000033, },
+	{ 0x1c5ba0, 0x00000034, 0x00000034, 0x00000034, 0x00000034, },
+	{ 0x1c5ba4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5ba8, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bac, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bb0, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bb4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bb8, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bbc, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bc0, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bc4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bc8, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bcc, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bd0, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bd4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bd8, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bdc, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5be0, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5be4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5be8, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bec, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bf0, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bf4, 0x00000035, 0x00000035, 0x00000035, 0x00000035, },
+	{ 0x1c5bf8, 0x00000010, 0x00000010, 0x00000010, 0x00000010, },
+	{ 0x1c5bfc, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a, },
+	{ 0x1c5c00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c0c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c10, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c14, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c18, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c1c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c20, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c24, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c28, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c2c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c30, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c34, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c38, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5c3c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5cf0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5cf4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5cf8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c5cfc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6200, 0x00000008, 0x00000008, 0x0000000e, 0x0000000e, },
+	{ 0x1c6204, 0x00000440, 0x00000440, 0x00000440, 0x00000440, },
+	{ 0x1c6208, 0xd6be4788, 0xd6be4788, 0xd03e4788, 0xd03e4788, },
+	{ 0x1c620c, 0x012e8160, 0x012e8160, 0x012a8160, 0x012a8160, },
+	{ 0x1c6210, 0x40806333, 0x40806333, 0x40806333, 0x40806333, },
+	{ 0x1c6214, 0x00106c10, 0x00106c10, 0x00106c10, 0x00106c10, },
+	{ 0x1c6218, 0x009c4060, 0x009c4060, 0x009c4060, 0x009c4060, },
+	{ 0x1c621c, 0x1883800a, 0x1883800a, 0x1883800a, 0x1883800a, },
+	{ 0x1c6220, 0x018830c6, 0x018830c6, 0x018830c6, 0x018830c6, },
+	{ 0x1c6224, 0x00000400, 0x00000400, 0x00000400, 0x00000400, },
+	{ 0x1c6228, 0x000009b5, 0x000009b5, 0x000009b5, 0x000009b5, },
+	{ 0x1c622c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6230, 0x00000108, 0x00000210, 0x00000210, 0x00000108, },
+	{ 0x1c6234, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c6238, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c623c, 0x13c889af, 0x13c889af, 0x13c889af, 0x13c889af, },
+	{ 0x1c6240, 0x38490a20, 0x38490a20, 0x38490a20, 0x38490a20, },
+	{ 0x1c6244, 0x00007bb6, 0x00007bb6, 0x00007bb6, 0x00007bb6, },
+	{ 0x1c6248, 0x0fff3ffc, 0x0fff3ffc, 0x0fff3ffc, 0x0fff3ffc, },
+	{ 0x1c624c, 0x00000001, 0x00000001, 0x00000001, 0x00000001, },
+	{ 0x1c6250, 0x0000a000, 0x0000a000, 0x0000a000, 0x0000a000, },
+	{ 0x1c6254, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6258, 0x0cc75380, 0x0cc75380, 0x0cc75380, 0x0cc75380, },
+	{ 0x1c625c, 0x0f0f0f01, 0x0f0f0f01, 0x0f0f0f01, 0x0f0f0f01, },
+	{ 0x1c6260, 0xdfa91f01, 0xdfa91f01, 0xdfa91f01, 0xdfa91f01, },
+	{ 0x1c6264, 0x00418a11, 0x00418a11, 0x00418a11, 0x00418a11, },
+	{ 0x1c6268, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c626c, 0x09249126, 0x09249126, 0x09249126, 0x09249126, },
+	{ 0x1c6274, 0x0a1a9caa, 0x0a1a9caa, 0x0a1a7caa, 0x0a1a7caa, },
+	{ 0x1c6278, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, },
+	{ 0x1c627c, 0x051701ce, 0x051701ce, 0x051701ce, 0x051701ce, },
+	{ 0x1c6300, 0x18010000, 0x18010000, 0x18010000, 0x18010000, },
+	{ 0x1c6304, 0x30032602, 0x30032602, 0x2e032402, 0x2e032402, },
+	{ 0x1c6308, 0x48073e06, 0x48073e06, 0x4a0a3c06, 0x4a0a3c06, },
+	{ 0x1c630c, 0x560b4c0a, 0x560b4c0a, 0x621a540b, 0x621a540b, },
+	{ 0x1c6310, 0x641a600f, 0x641a600f, 0x764f6c1b, 0x764f6c1b, },
+	{ 0x1c6314, 0x7a4f6e1b, 0x7a4f6e1b, 0x845b7a5a, 0x845b7a5a, },
+	{ 0x1c6318, 0x8c5b7e5a, 0x8c5b7e5a, 0x950f8ccf, 0x950f8ccf, },
+	{ 0x1c631c, 0x9d0f96cf, 0x9d0f96cf, 0xa5cf9b4f, 0xa5cf9b4f, },
+	{ 0x1c6320, 0xb51fa69f, 0xb51fa69f, 0xbddfaf1f, 0xbddfaf1f, },
+	{ 0x1c6324, 0xcb3fbd07, 0xcb3fbcbf, 0xd1ffc93f, 0xd1ffc93f, },
+	{ 0x1c6328, 0x0000d7bf, 0x0000d7bf, 0x00000000, 0x00000000, },
+	{ 0x1c632c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6330, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6334, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6338, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c633c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6340, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6344, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c6348, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, },
+	{ 0x1c634c, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, },
+	{ 0x1c6350, 0x3fffffff, 0x3fffffff, 0x3fffffff, 0x3fffffff, },
+	{ 0x1c6354, 0x0003ffff, 0x0003ffff, 0x0003ffff, 0x0003ffff, },
+	{ 0x1c6358, 0x79a8aa1f, 0x79a8aa1f, 0x79a8aa1f, 0x79a8aa1f, },
+	{ 0x1c6388, 0x08000000, 0x08000000, 0x08000000, 0x08000000, },
+	{ 0x1c638c, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c6390, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c6394, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, },
+	{ 0x1c6398, 0x000001ce, 0x000001ce, 0x000001ce, 0x000001ce, },
+	{ 0x1c639c, 0x00000007, 0x00000007, 0x00000007, 0x00000007, },
+	{ 0x1c63a0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63a4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63a8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63ac, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63b0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63b4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63b8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63bc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63c0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63c4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63c8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63cc, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c63d0, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c63d4, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, 0x3f3f3f3f, },
+	{ 0x1c63d8, 0x00000000, 0x00000000, 0x00000000, 0x00000000, },
+	{ 0x1c63dc, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, },
+	{ 0x1c63e0, 0x000000c0, 0x000000c0, 0x000000c0, 0x000000c0, },
+	{ 0x1c6848, 0x00180a65, 0x00180a65, 0x00180a68, 0x00180a68, },
+	{ 0x1c6920, 0x0510001c, 0x0510001c, 0x0510001c, 0x0510001c, },
+	{ 0x1c6960, 0x00009b40, 0x00009b40, 0x00009b40, 0x00009b40, },
+	{ 0x1c720c, 0x012e8160, 0x012e8160, 0x012a8160, 0x012a8160, },
+	{ 0x1c726c, 0x09249126, 0x09249126, 0x09249126, 0x09249126, },
+	{ 0x1c7848, 0x00180a65, 0x00180a65, 0x00180a68, 0x00180a68, },
+	{ 0x1c7920, 0x0510001c, 0x0510001c, 0x0510001c, 0x0510001c, },
+	{ 0x1c7960, 0x00009b40, 0x00009b40, 0x00009b40, 0x00009b40, },
+	{ 0x1c820c, 0x012e8160, 0x012e8160, 0x012a8160, 0x012a8160, },
+	{ 0x1c826c, 0x09249126, 0x09249126, 0x09249126, 0x09249126, },
+/*	{ 0x1c8864, 0x0001ce00, 0x0001ce00, 0x0001ce00, 0x0001ce00, }, */
+	{ 0x1c8864, 0x0001c600, 0x0001c600, 0x0001c600, 0x0001c600, },
+	{ 0x1c895c, 0x004b6a8e, 0x004b6a8e, 0x004b6a8e, 0x004b6a8e, },
+	{ 0x1c8968, 0x000003ce, 0x000003ce, 0x000003ce, 0x000003ce, },
+	{ 0x1c89bc, 0x00181400, 0x00181400, 0x00181400, 0x00181400, },
+	{ 0x1c9270, 0x00820820, 0x00820820, 0x00820820, 0x00820820, },
+	{ 0x1c935c, 0x066c420f, 0x066c420f, 0x066c420f, 0x066c420f, },
+	{ 0x1c9360, 0x0f282207, 0x0f282207, 0x0f282207, 0x0f282207, },
+	{ 0x1c9364, 0x17601685, 0x17601685, 0x17601685, 0x17601685, },
+	{ 0x1c9368, 0x1f801104, 0x1f801104, 0x1f801104, 0x1f801104, },
+	{ 0x1c936c, 0x37a00c03, 0x37a00c03, 0x37a00c03, 0x37a00c03, },
+	{ 0x1c9370, 0x3fc40883, 0x3fc40883, 0x3fc40883, 0x3fc40883, },
+	{ 0x1c9374, 0x57c00803, 0x57c00803, 0x57c00803, 0x57c00803, },
+	{ 0x1c9378, 0x5fd80682, 0x5fd80682, 0x5fd80682, 0x5fd80682, },
+	{ 0x1c937c, 0x7fe00482, 0x7fe00482, 0x7fe00482, 0x7fe00482, },
+	{ 0x1c9380, 0x7f3c7bba, 0x7f3c7bba, 0x7f3c7bba, 0x7f3c7bba, },
+	{ 0x1c9384, 0xf3307ff0, 0xf3307ff0, 0xf3307ff0, 0xf3307ff0, }
+};
+
+/*
+ * look up a certain register in ar5416_phy_init[] and return the init. value
+ * for the band and bandwidth given. Return 0 if register address not found.
+ */
+static u32 carl9170_def_val(u32 reg, bool is_2ghz, bool is_40mhz)
+{
+	unsigned int i;
+	for (i = 0; i < ARRAY_SIZE(ar5416_phy_init); i++) {
+		if (ar5416_phy_init[i].reg != reg)
+			continue;
+
+		if (is_2ghz) {
+			if (is_40mhz)
+				return ar5416_phy_init[i]._2ghz_40;
+			else
+				return ar5416_phy_init[i]._2ghz_20;
+		} else {
+			if (is_40mhz)
+				return ar5416_phy_init[i]._5ghz_40;
+			else
+				return ar5416_phy_init[i]._5ghz_20;
+		}
+	}
+	return 0;
+}
+
+/*
+ * initialize some phy regs from eeprom values in modal_header[]
+ * acc. to band and bandwith
+ */
+static int carl9170_init_phy_from_eeprom(struct ar9170 *ar,
+				bool is_2ghz, bool is_40mhz)
+{
+	static const u8 xpd2pd[16] = {
+		0x2, 0x2, 0x2, 0x1, 0x2, 0x2, 0x6, 0x2,
+		0x2, 0x3, 0x7, 0x2, 0xb, 0x2, 0x2, 0x2
+	};
+	/* pointer to the modal_header acc. to band */
+	struct ar9170_eeprom_modal *m = &ar->eeprom.modal_header[is_2ghz];
+	u32 val;
+
+	carl9170_regwrite_begin(ar);
+
+	/* ant common control (index 0) */
+	carl9170_regwrite(AR9170_PHY_REG_SWITCH_COM,
+		le32_to_cpu(m->antCtrlCommon));
+
+	/* ant control chain 0 (index 1) */
+	carl9170_regwrite(AR9170_PHY_REG_SWITCH_CHAIN_0,
+		le32_to_cpu(m->antCtrlChain[0]));
+
+	/* ant control chain 2 (index 2) */
+	carl9170_regwrite(AR9170_PHY_REG_SWITCH_CHAIN_2,
+		le32_to_cpu(m->antCtrlChain[1]));
+
+	/* SwSettle (index 3) */
+	if (!is_40mhz) {
+		val = carl9170_def_val(AR9170_PHY_REG_SETTLING,
+				     is_2ghz, is_40mhz);
+		SET_VAL(AR9170_PHY_SETTLING_SWITCH, val, m->switchSettling);
+		carl9170_regwrite(AR9170_PHY_REG_SETTLING, val);
+	}
+
+	/* adcDesired, pdaDesired (index 4) */
+	val = carl9170_def_val(AR9170_PHY_REG_DESIRED_SZ, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_DESIRED_SZ_PGA, val, m->pgaDesiredSize);
+	SET_VAL(AR9170_PHY_DESIRED_SZ_ADC, val, m->adcDesiredSize);
+	carl9170_regwrite(AR9170_PHY_REG_DESIRED_SZ, val);
+
+	/* TxEndToXpaOff, TxFrameToXpaOn (index 5) */
+	val = carl9170_def_val(AR9170_PHY_REG_RF_CTL4, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_RF_CTL4_TX_END_XPAB_OFF, val, m->txEndToXpaOff);
+	SET_VAL(AR9170_PHY_RF_CTL4_TX_END_XPAA_OFF, val, m->txEndToXpaOff);
+	SET_VAL(AR9170_PHY_RF_CTL4_FRAME_XPAB_ON, val, m->txFrameToXpaOn);
+	SET_VAL(AR9170_PHY_RF_CTL4_FRAME_XPAA_ON, val, m->txFrameToXpaOn);
+	carl9170_regwrite(AR9170_PHY_REG_RF_CTL4, val);
+
+	/* TxEndToRxOn (index 6) */
+	val = carl9170_def_val(AR9170_PHY_REG_RF_CTL3, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_RF_CTL3_TX_END_TO_A2_RX_ON, val, m->txEndToRxOn);
+	carl9170_regwrite(AR9170_PHY_REG_RF_CTL3, val);
+
+	/* thresh62 (index 7) */
+	val = carl9170_def_val(0x1c8864, is_2ghz, is_40mhz);
+	val = (val & ~0x7f000) | (m->thresh62 << 12);
+	carl9170_regwrite(0x1c8864, val);
+
+	/* tx/rx attenuation chain 0 (index 8) */
+	val = carl9170_def_val(AR9170_PHY_REG_RXGAIN, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_RXGAIN_TXRX_ATTEN, val, m->txRxAttenCh[0]);
+	carl9170_regwrite(AR9170_PHY_REG_RXGAIN, val);
+
+	/* tx/rx attenuation chain 2 (index 9) */
+	val = carl9170_def_val(AR9170_PHY_REG_RXGAIN_CHAIN_2,
+			       is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_RXGAIN_TXRX_ATTEN, val, m->txRxAttenCh[1]);
+	carl9170_regwrite(AR9170_PHY_REG_RXGAIN_CHAIN_2, val);
+
+	/* tx/rx margin chain 0 (index 10) */
+	val = carl9170_def_val(AR9170_PHY_REG_GAIN_2GHZ, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_GAIN_2GHZ_RXTX_MARGIN, val, m->rxTxMarginCh[0]);
+	/* bsw margin chain 0 for 5GHz only */
+	if (!is_2ghz)
+		SET_VAL(AR9170_PHY_GAIN_2GHZ_BSW_MARGIN, val, m->bswMargin[0]);
+	carl9170_regwrite(AR9170_PHY_REG_GAIN_2GHZ, val);
+
+	/* tx/rx margin chain 2 (index 11) */
+	val = carl9170_def_val(AR9170_PHY_REG_GAIN_2GHZ_CHAIN_2,
+			       is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_GAIN_2GHZ_RXTX_MARGIN, val, m->rxTxMarginCh[1]);
+	carl9170_regwrite(AR9170_PHY_REG_GAIN_2GHZ_CHAIN_2, val);
+
+	/* iqCall, iqCallq chain 0 (index 12) */
+	val = carl9170_def_val(AR9170_PHY_REG_TIMING_CTRL4(0),
+			       is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF, val, m->iqCalICh[0]);
+	SET_VAL(AR9170_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF, val, m->iqCalQCh[0]);
+	carl9170_regwrite(AR9170_PHY_REG_TIMING_CTRL4(0), val);
+
+	/* iqCall, iqCallq chain 2 (index 13) */
+	val = carl9170_def_val(AR9170_PHY_REG_TIMING_CTRL4(2),
+			       is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF, val, m->iqCalICh[1]);
+	SET_VAL(AR9170_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF, val, m->iqCalQCh[1]);
+	carl9170_regwrite(AR9170_PHY_REG_TIMING_CTRL4(2), val);
+
+	/* xpd gain mask (index 14) */
+	val = carl9170_def_val(AR9170_PHY_REG_TPCRG1, is_2ghz, is_40mhz);
+	SET_VAL(AR9170_PHY_TPCRG1_PD_GAIN_1, val,
+		xpd2pd[m->xpdGain & 0xf] & 3);
+	SET_VAL(AR9170_PHY_TPCRG1_PD_GAIN_2, val,
+		xpd2pd[m->xpdGain & 0xf] >> 2);
+	carl9170_regwrite(AR9170_PHY_REG_TPCRG1, val);
+
+	carl9170_regwrite(AR9170_PHY_REG_RX_CHAINMASK, ar->eeprom.rx_mask);
+	carl9170_regwrite(AR9170_PHY_REG_CAL_CHAINMASK, ar->eeprom.rx_mask);
+
+	carl9170_regwrite_finish();
+	return carl9170_regwrite_result();
+}
+
+static int carl9170_init_phy(struct ar9170 *ar, enum ieee80211_band band)
+{
+	int i, err;
+	u32 val;
+	bool is_2ghz = band == IEEE80211_BAND_2GHZ;
+	bool is_40mhz = conf_is_ht40(&ar->hw->conf);
+
+	carl9170_regwrite_begin(ar);
+
+	for (i = 0; i < ARRAY_SIZE(ar5416_phy_init); i++) {
+		if (is_40mhz) {
+			if (is_2ghz)
+				val = ar5416_phy_init[i]._2ghz_40;
+			else
+				val = ar5416_phy_init[i]._5ghz_40;
+		} else {
+			if (is_2ghz)
+				val = ar5416_phy_init[i]._2ghz_20;
+			else
+				val = ar5416_phy_init[i]._5ghz_20;
+		}
+
+		carl9170_regwrite(ar5416_phy_init[i].reg, val);
+	}
+
+	carl9170_regwrite_finish();
+	err = carl9170_regwrite_result();
+	if (err)
+		return err;
+
+	err = carl9170_init_phy_from_eeprom(ar, is_2ghz, is_40mhz);
+	if (err)
+		return err;
+
+	err = carl9170_init_power_cal(ar);
+	if (err)
+		return err;
+
+	/* XXX: remove magic! */
+	if (is_2ghz)
+		err = carl9170_write_reg(ar, AR9170_PWR_REG_PLL_ADDAC, 0x5163);
+	else
+		err = carl9170_write_reg(ar, AR9170_PWR_REG_PLL_ADDAC, 0x5143);
+
+	return err;
+}
+
+struct carl9170_rf_initvals {
+	u32 reg, _5ghz, _2ghz;
+};
+
+static struct carl9170_rf_initvals carl9170_rf_initval[] = {
+	/* bank 0 */
+	{ 0x1c58b0, 0x1e5795e5, 0x1e5795e5},
+	{ 0x1c58e0, 0x02008020, 0x02008020},
+	/* bank 1 */
+	{ 0x1c58b0, 0x02108421, 0x02108421},
+	{ 0x1c58ec, 0x00000008, 0x00000008},
+	/* bank 2 */
+	{ 0x1c58b0, 0x0e73ff17, 0x0e73ff17},
+	{ 0x1c58e0, 0x00000420, 0x00000420},
+	/* bank 3 */
+	{ 0x1c58f0, 0x01400018, 0x01c00018},
+	/* bank 4 */
+	{ 0x1c58b0, 0x000001a1, 0x000001a1},
+	{ 0x1c58e8, 0x00000001, 0x00000001},
+	/* bank 5 */
+	{ 0x1c58b0, 0x00000013, 0x00000013},
+	{ 0x1c58e4, 0x00000002, 0x00000002},
+	/* bank 6 */
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00004000, 0x00004000},
+	{ 0x1c58b0, 0x00006c00, 0x00006c00},
+	{ 0x1c58b0, 0x00002c00, 0x00002c00},
+	{ 0x1c58b0, 0x00004800, 0x00004800},
+	{ 0x1c58b0, 0x00004000, 0x00004000},
+	{ 0x1c58b0, 0x00006000, 0x00006000},
+	{ 0x1c58b0, 0x00001000, 0x00001000},
+	{ 0x1c58b0, 0x00004000, 0x00004000},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00087c00, 0x00087c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00005400, 0x00005400},
+	{ 0x1c58b0, 0x00000c00, 0x00000c00},
+	{ 0x1c58b0, 0x00001800, 0x00001800},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00006c00, 0x00006c00},
+	{ 0x1c58b0, 0x00006c00, 0x00006c00},
+	{ 0x1c58b0, 0x00007c00, 0x00007c00},
+	{ 0x1c58b0, 0x00002c00, 0x00002c00},
+	{ 0x1c58b0, 0x00003c00, 0x00003c00},
+	{ 0x1c58b0, 0x00003800, 0x00003800},
+	{ 0x1c58b0, 0x00001c00, 0x00001c00},
+	{ 0x1c58b0, 0x00000800, 0x00000800},
+	{ 0x1c58b0, 0x00000408, 0x00000408},
+	{ 0x1c58b0, 0x00004c15, 0x00004c15},
+	{ 0x1c58b0, 0x00004188, 0x00004188},
+	{ 0x1c58b0, 0x0000201e, 0x0000201e},
+	{ 0x1c58b0, 0x00010408, 0x00010408},
+	{ 0x1c58b0, 0x00000801, 0x00000801},
+	{ 0x1c58b0, 0x00000c08, 0x00000c08},
+	{ 0x1c58b0, 0x0000181e, 0x0000181e},
+	{ 0x1c58b0, 0x00001016, 0x00001016},
+	{ 0x1c58b0, 0x00002800, 0x00002800},
+	{ 0x1c58b0, 0x00004010, 0x00004010},
+	{ 0x1c58b0, 0x0000081c, 0x0000081c},
+	{ 0x1c58b0, 0x00000115, 0x00000115},
+	{ 0x1c58b0, 0x00000015, 0x00000015},
+	{ 0x1c58b0, 0x00000066, 0x00000066},
+	{ 0x1c58b0, 0x0000001c, 0x0000001c},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000004, 0x00000004},
+	{ 0x1c58b0, 0x00000015, 0x00000015},
+	{ 0x1c58b0, 0x0000001f, 0x0000001f},
+	{ 0x1c58e0, 0x00000000, 0x00000400},
+	/* bank 7 */
+	{ 0x1c58b0, 0x000000a0, 0x000000a0},
+	{ 0x1c58b0, 0x00000000, 0x00000000},
+	{ 0x1c58b0, 0x00000040, 0x00000040},
+	{ 0x1c58f0, 0x0000001c, 0x0000001c},
+};
+
+static int carl9170_init_rf_banks_0_7(struct ar9170 *ar, bool band5ghz)
+{
+	int err, i;
+
+	carl9170_regwrite_begin(ar);
+
+	for (i = 0; i < ARRAY_SIZE(carl9170_rf_initval); i++)
+		carl9170_regwrite(carl9170_rf_initval[i].reg,
+				  band5ghz ? carl9170_rf_initval[i]._5ghz
+					   : carl9170_rf_initval[i]._2ghz);
+
+	carl9170_regwrite_finish();
+	err = carl9170_regwrite_result();
+	if (err)
+		wiphy_err(ar->hw->wiphy, "rf init failed\n");
+
+	return err;
+}
+
+struct carl9170_phy_freq_params {
+	u8 coeff_exp;
+	u16 coeff_man;
+	u8 coeff_exp_shgi;
+	u16 coeff_man_shgi;
+};
+
+enum carl9170_bw {
+	CARL9170_BW_20,
+	CARL9170_BW_40_BELOW,
+	CARL9170_BW_40_ABOVE,
+
+	__CARL9170_NUM_BW,
+};
+
+struct carl9170_phy_freq_entry {
+	u16 freq;
+	struct carl9170_phy_freq_params params[__CARL9170_NUM_BW];
+};
+
+/* NB: must be in sync with channel tables in main! */
+static const struct carl9170_phy_freq_entry carl9170_phy_freq_params[] = {
+/*
+ *	freq,
+ *		20MHz,
+ *		40MHz (below),
+ *		40Mhz (above),
+ */
+	{ 2412, {
+		{ 3, 21737, 3, 19563, },
+		{ 3, 21827, 3, 19644, },
+		{ 3, 21647, 3, 19482, },
+	} },
+	{ 2417, {
+		{ 3, 21692, 3, 19523, },
+		{ 3, 21782, 3, 19604, },
+		{ 3, 21602, 3, 19442, },
+	} },
+	{ 2422, {
+		{ 3, 21647, 3, 19482, },
+		{ 3, 21737, 3, 19563, },
+		{ 3, 21558, 3, 19402, },
+	} },
+	{ 2427, {
+		{ 3, 21602, 3, 19442, },
+		{ 3, 21692, 3, 19523, },
+		{ 3, 21514, 3, 19362, },
+	} },
+	{ 2432, {
+		{ 3, 21558, 3, 19402, },
+		{ 3, 21647, 3, 19482, },
+		{ 3, 21470, 3, 19323, },
+	} },
+	{ 2437, {
+		{ 3, 21514, 3, 19362, },
+		{ 3, 21602, 3, 19442, },
+		{ 3, 21426, 3, 19283, },
+	} },
+	{ 2442, {
+		{ 3, 21470, 3, 19323, },
+		{ 3, 21558, 3, 19402, },
+		{ 3, 21382, 3, 19244, },
+	} },
+	{ 2447, {
+		{ 3, 21426, 3, 19283, },
+		{ 3, 21514, 3, 19362, },
+		{ 3, 21339, 3, 19205, },
+	} },
+	{ 2452, {
+		{ 3, 21382, 3, 19244, },
+		{ 3, 21470, 3, 19323, },
+		{ 3, 21295, 3, 19166, },
+	} },
+	{ 2457, {
+		{ 3, 21339, 3, 19205, },
+		{ 3, 21426, 3, 19283, },
+		{ 3, 21252, 3, 19127, },
+	} },
+	{ 2462, {
+		{ 3, 21295, 3, 19166, },
+		{ 3, 21382, 3, 19244, },
+		{ 3, 21209, 3, 19088, },
+	} },
+	{ 2467, {
+		{ 3, 21252, 3, 19127, },
+		{ 3, 21339, 3, 19205, },
+		{ 3, 21166, 3, 19050, },
+	} },
+	{ 2472, {
+		{ 3, 21209, 3, 19088, },
+		{ 3, 21295, 3, 19166, },
+		{ 3, 21124, 3, 19011, },
+	} },
+	{ 2484, {
+		{ 3, 21107, 3, 18996, },
+		{ 3, 21192, 3, 19073, },
+		{ 3, 21022, 3, 18920, },
+	} },
+	{ 4920, {
+		{ 4, 21313, 4, 19181, },
+		{ 4, 21356, 4, 19220, },
+		{ 4, 21269, 4, 19142, },
+	} },
+	{ 4940, {
+		{ 4, 21226, 4, 19104, },
+		{ 4, 21269, 4, 19142, },
+		{ 4, 21183, 4, 19065, },
+	} },
+	{ 4960, {
+		{ 4, 21141, 4, 19027, },
+		{ 4, 21183, 4, 19065, },
+		{ 4, 21098, 4, 18988, },
+	} },
+	{ 4980, {
+		{ 4, 21056, 4, 18950, },
+		{ 4, 21098, 4, 18988, },
+		{ 4, 21014, 4, 18912, },
+	} },
+	{ 5040, {
+		{ 4, 20805, 4, 18725, },
+		{ 4, 20846, 4, 18762, },
+		{ 4, 20764, 4, 18687, },
+	} },
+	{ 5060, {
+		{ 4, 20723, 4, 18651, },
+		{ 4, 20764, 4, 18687, },
+		{ 4, 20682, 4, 18614, },
+	} },
+	{ 5080, {
+		{ 4, 20641, 4, 18577, },
+		{ 4, 20682, 4, 18614, },
+		{ 4, 20601, 4, 18541, },
+	} },
+	{ 5180, {
+		{ 4, 20243, 4, 18219, },
+		{ 4, 20282, 4, 18254, },
+		{ 4, 20204, 4, 18183, },
+	} },
+	{ 5200, {
+		{ 4, 20165, 4, 18148, },
+		{ 4, 20204, 4, 18183, },
+		{ 4, 20126, 4, 18114, },
+	} },
+	{ 5220, {
+		{ 4, 20088, 4, 18079, },
+		{ 4, 20126, 4, 18114, },
+		{ 4, 20049, 4, 18044, },
+	} },
+	{ 5240, {
+		{ 4, 20011, 4, 18010, },
+		{ 4, 20049, 4, 18044, },
+		{ 4, 19973, 4, 17976, },
+	} },
+	{ 5260, {
+		{ 4, 19935, 4, 17941, },
+		{ 4, 19973, 4, 17976, },
+		{ 4, 19897, 4, 17907, },
+	} },
+	{ 5280, {
+		{ 4, 19859, 4, 17873, },
+		{ 4, 19897, 4, 17907, },
+		{ 4, 19822, 4, 17840, },
+	} },
+	{ 5300, {
+		{ 4, 19784, 4, 17806, },
+		{ 4, 19822, 4, 17840, },
+		{ 4, 19747, 4, 17772, },
+	} },
+	{ 5320, {
+		{ 4, 19710, 4, 17739, },
+		{ 4, 19747, 4, 17772, },
+		{ 4, 19673, 4, 17706, },
+	} },
+	{ 5500, {
+		{ 4, 19065, 4, 17159, },
+		{ 4, 19100, 4, 17190, },
+		{ 4, 19030, 4, 17127, },
+	} },
+	{ 5520, {
+		{ 4, 18996, 4, 17096, },
+		{ 4, 19030, 4, 17127, },
+		{ 4, 18962, 4, 17065, },
+	} },
+	{ 5540, {
+		{ 4, 18927, 4, 17035, },
+		{ 4, 18962, 4, 17065, },
+		{ 4, 18893, 4, 17004, },
+	} },
+	{ 5560, {
+		{ 4, 18859, 4, 16973, },
+		{ 4, 18893, 4, 17004, },
+		{ 4, 18825, 4, 16943, },
+	} },
+	{ 5580, {
+		{ 4, 18792, 4, 16913, },
+		{ 4, 18825, 4, 16943, },
+		{ 4, 18758, 4, 16882, },
+	} },
+	{ 5600, {
+		{ 4, 18725, 4, 16852, },
+		{ 4, 18758, 4, 16882, },
+		{ 4, 18691, 4, 16822, },
+	} },
+	{ 5620, {
+		{ 4, 18658, 4, 16792, },
+		{ 4, 18691, 4, 16822, },
+		{ 4, 18625, 4, 16762, },
+	} },
+	{ 5640, {
+		{ 4, 18592, 4, 16733, },
+		{ 4, 18625, 4, 16762, },
+		{ 4, 18559, 4, 16703, },
+	} },
+	{ 5660, {
+		{ 4, 18526, 4, 16673, },
+		{ 4, 18559, 4, 16703, },
+		{ 4, 18493, 4, 16644, },
+	} },
+	{ 5680, {
+		{ 4, 18461, 4, 16615, },
+		{ 4, 18493, 4, 16644, },
+		{ 4, 18428, 4, 16586, },
+	} },
+	{ 5700, {
+		{ 4, 18396, 4, 16556, },
+		{ 4, 18428, 4, 16586, },
+		{ 4, 18364, 4, 16527, },
+	} },
+	{ 5745, {
+		{ 4, 18252, 4, 16427, },
+		{ 4, 18284, 4, 16455, },
+		{ 4, 18220, 4, 16398, },
+	} },
+	{ 5765, {
+		{ 4, 18189, 5, 32740, },
+		{ 4, 18220, 4, 16398, },
+		{ 4, 18157, 5, 32683, },
+	} },
+	{ 5785, {
+		{ 4, 18126, 5, 32626, },
+		{ 4, 18157, 5, 32683, },
+		{ 4, 18094, 5, 32570, },
+	} },
+	{ 5805, {
+		{ 4, 18063, 5, 32514, },
+		{ 4, 18094, 5, 32570, },
+		{ 4, 18032, 5, 32458, },
+	} },
+	{ 5825, {
+		{ 4, 18001, 5, 32402, },
+		{ 4, 18032, 5, 32458, },
+		{ 4, 17970, 5, 32347, },
+	} },
+	{ 5170, {
+		{ 4, 20282, 4, 18254, },
+		{ 4, 20321, 4, 18289, },
+		{ 4, 20243, 4, 18219, },
+	} },
+	{ 5190, {
+		{ 4, 20204, 4, 18183, },
+		{ 4, 20243, 4, 18219, },
+		{ 4, 20165, 4, 18148, },
+	} },
+	{ 5210, {
+		{ 4, 20126, 4, 18114, },
+		{ 4, 20165, 4, 18148, },
+		{ 4, 20088, 4, 18079, },
+	} },
+	{ 5230, {
+		{ 4, 20049, 4, 18044, },
+		{ 4, 20088, 4, 18079, },
+		{ 4, 20011, 4, 18010, },
+	} },
+};
+
+static int carl9170_init_rf_bank4_pwr(struct ar9170 *ar, bool band5ghz,
+				      u32 freq, enum carl9170_bw bw)
+{
+	int err;
+	u32 d0, d1, td0, td1, fd0, fd1;
+	u8 chansel;
+	u8 refsel0 = 1, refsel1 = 0;
+	u8 lf_synth = 0;
+
+	switch (bw) {
+	case CARL9170_BW_40_ABOVE:
+		freq += 10;
+		break;
+	case CARL9170_BW_40_BELOW:
+		freq -= 10;
+		break;
+	case CARL9170_BW_20:
+		break;
+	default:
+		BUG();
+		return -ENOSYS;
+	}
+
+	if (band5ghz) {
+		if (freq % 10) {
+			chansel = (freq - 4800) / 5;
+		} else {
+			chansel = ((freq - 4800) / 10) * 2;
+			refsel0 = 0;
+			refsel1 = 1;
+		}
+		chansel = byte_rev_table[chansel];
+	} else {
+		if (freq == 2484) {
+			chansel = 10 + (freq - 2274) / 5;
+			lf_synth = 1;
+		} else
+			chansel = 16 + (freq - 2272) / 5;
+		chansel *= 4;
+		chansel = byte_rev_table[chansel];
+	}
+
+	d1 =	chansel;
+	d0 =	0x21 |
+		refsel0 << 3 |
+		refsel1 << 2 |
+		lf_synth << 1;
+	td0 =	d0 & 0x1f;
+	td1 =	d1 & 0x1f;
+	fd0 =	td1 << 5 | td0;
+
+	td0 =	(d0 >> 5) & 0x7;
+	td1 =	(d1 >> 5) & 0x7;
+	fd1 =	td1 << 5 | td0;
+
+	carl9170_regwrite_begin(ar);
+
+	carl9170_regwrite(0x1c58b0, fd0);
+	carl9170_regwrite(0x1c58e8, fd1);
+
+	carl9170_regwrite_finish();
+	err = carl9170_regwrite_result();
+	if (err)
+		return err;
+
+	msleep(20);
+
+	return 0;
+}
+
+static const struct carl9170_phy_freq_params *
+carl9170_get_hw_dyn_params(struct ieee80211_channel *channel,
+			   enum carl9170_bw bw)
+{
+	unsigned int chanidx = 0;
+	u16 freq = 2412;
+
+	if (channel) {
+		chanidx = channel->hw_value;
+		freq = channel->center_freq;
+	}
+
+	BUG_ON(chanidx >= ARRAY_SIZE(carl9170_phy_freq_params));
+
+	BUILD_BUG_ON(__CARL9170_NUM_BW != 3);
+
+	WARN_ON(carl9170_phy_freq_params[chanidx].freq != freq);
+
+	return &carl9170_phy_freq_params[chanidx].params[bw];
+}
+
+static int carl9170_find_freq_idx(int nfreqs, u8 *freqs, u8 f)
+{
+	int idx = nfreqs - 2;
+
+	while (idx >= 0) {
+		if (f >= freqs[idx])
+			return idx;
+		idx--;
+	}
+
+	return 0;
+}
+
+static s32 carl9170_interpolate_s32(s32 x, s32 x1, s32 y1, s32 x2, s32 y2)
+{
+	/* nothing to interpolate, it's horizontal */
+	if (y2 == y1)
+		return y1;
+
+	/* check if we hit one of the edges */
+	if (x == x1)
+		return y1;
+	if (x == x2)
+		return y2;
+
+	/* x1 == x2 is bad, hopefully == x */
+	if (x2 == x1)
+		return y1;
+
+	return y1 + (((y2 - y1) * (x - x1)) / (x2 - x1));
+}
+
+static u8 carl9170_interpolate_u8(u8 x, u8 x1, u8 y1, u8 x2, u8 y2)
+{
+#define SHIFT		8
+	s32 y;
+
+	y = carl9170_interpolate_s32(x << SHIFT, x1 << SHIFT,
+		y1 << SHIFT, x2 << SHIFT, y2 << SHIFT);
+
+	/*
+	 * XXX: unwrap this expression
+	 *	Isn't it just DIV_ROUND_UP(y, 1<<SHIFT)?
+	 *	Can we rely on the compiler to optimise away the div?
+	 */
+	return (y >> SHIFT) + ((y & (1<<(SHIFT-1))) >> (SHIFT - 1));
+#undef SHIFT
+}
+
+static u8 carl9170_interpolate_val(u8 x, u8 *x_array, u8 *y_array)
+{
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		if (x <= x_array[i + 1])
+			break;
+	}
+
+	return carl9170_interpolate_u8(x, x_array[i], y_array[i],
+		x_array[i + 1], y_array[i + 1]);
+}
+
+static int carl9170_set_freq_cal_data(struct ar9170 *ar,
+	struct ieee80211_channel *channel)
+{
+	u8 *cal_freq_pier;
+	u8 vpds[2][AR5416_PD_GAIN_ICEPTS];
+	u8 pwrs[2][AR5416_PD_GAIN_ICEPTS];
+	int chain, idx, i;
+	u32 phy_data = 0;
+	u8 f, tmp;
+
+	switch (channel->band) {
+	case IEEE80211_BAND_2GHZ:
+		f = channel->center_freq - 2300;
+		cal_freq_pier = ar->eeprom.cal_freq_pier_2G;
+		i = AR5416_NUM_2G_CAL_PIERS - 1;
+		break;
+
+	case IEEE80211_BAND_5GHZ:
+		f = (channel->center_freq - 4800) / 5;
+		cal_freq_pier = ar->eeprom.cal_freq_pier_5G;
+		i = AR5416_NUM_5G_CAL_PIERS - 1;
+		break;
+
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	for (; i >= 0; i--) {
+		if (cal_freq_pier[i] != 0xff)
+			break;
+	}
+	if (i < 0)
+		return -EINVAL;
+
+	idx = carl9170_find_freq_idx(i, cal_freq_pier, f);
+
+	carl9170_regwrite_begin(ar);
+
+	for (chain = 0; chain < AR5416_MAX_CHAINS; chain++) {
+		for (i = 0; i < AR5416_PD_GAIN_ICEPTS; i++) {
+			struct ar9170_calibration_data_per_freq *cal_pier_data;
+			int j;
+
+			switch (channel->band) {
+			case IEEE80211_BAND_2GHZ:
+				cal_pier_data = &ar->eeprom.
+					cal_pier_data_2G[chain][idx];
+				break;
+
+			case IEEE80211_BAND_5GHZ:
+				cal_pier_data = &ar->eeprom.
+					cal_pier_data_5G[chain][idx];
+				break;
+
+			default:
+				return -EINVAL;
+			}
+
+			for (j = 0; j < 2; j++) {
+				vpds[j][i] = carl9170_interpolate_u8(f,
+					cal_freq_pier[idx],
+					cal_pier_data->vpd_pdg[j][i],
+					cal_freq_pier[idx + 1],
+					cal_pier_data[1].vpd_pdg[j][i]);
+
+				pwrs[j][i] = carl9170_interpolate_u8(f,
+					cal_freq_pier[idx],
+					cal_pier_data->pwr_pdg[j][i],
+					cal_freq_pier[idx + 1],
+					cal_pier_data[1].pwr_pdg[j][i]) / 2;
+			}
+		}
+
+		for (i = 0; i < 76; i++) {
+			if (i < 25) {
+				tmp = carl9170_interpolate_val(i, &pwrs[0][0],
+							       &vpds[0][0]);
+			} else {
+				tmp = carl9170_interpolate_val(i - 12,
+							       &pwrs[1][0],
+							       &vpds[1][0]);
+			}
+
+			phy_data |= tmp << ((i & 3) << 3);
+			if ((i & 3) == 3) {
+				carl9170_regwrite(0x1c6280 + chain * 0x1000 +
+						  (i & ~3), phy_data);
+				phy_data = 0;
+			}
+		}
+
+		for (i = 19; i < 32; i++)
+			carl9170_regwrite(0x1c6280 + chain * 0x1000 + (i << 2),
+					  0x0);
+	}
+
+	carl9170_regwrite_finish();
+	return carl9170_regwrite_result();
+}
+
+static u8 carl9170_get_max_edge_power(struct ar9170 *ar,
+	u32 freq, struct ar9170_calctl_edges edges[])
+{
+	int i;
+	u8 rc = AR5416_MAX_RATE_POWER;
+	u8 f;
+	if (freq < 3000)
+		f = freq - 2300;
+	else
+		f = (freq - 4800) / 5;
+
+	for (i = 0; i < AR5416_NUM_BAND_EDGES; i++) {
+		if (edges[i].channel == 0xff)
+			break;
+		if (f == edges[i].channel) {
+			/* exact freq match */
+			rc = edges[i].power_flags & ~AR9170_CALCTL_EDGE_FLAGS;
+			break;
+		}
+		if (i > 0 && f < edges[i].channel) {
+			if (f > edges[i - 1].channel &&
+			    edges[i - 1].power_flags &
+			    AR9170_CALCTL_EDGE_FLAGS) {
+				/* lower channel has the inband flag set */
+				rc = edges[i - 1].power_flags &
+					~AR9170_CALCTL_EDGE_FLAGS;
+			}
+			break;
+		}
+	}
+
+	if (i == AR5416_NUM_BAND_EDGES) {
+		if (f > edges[i - 1].channel &&
+		    edges[i - 1].power_flags & AR9170_CALCTL_EDGE_FLAGS) {
+			/* lower channel has the inband flag set */
+			rc = edges[i - 1].power_flags &
+				~AR9170_CALCTL_EDGE_FLAGS;
+		}
+	}
+	return rc;
+}
+
+static u8 carl9170_get_heavy_clip(struct ar9170 *ar, u32 freq,
+	enum carl9170_bw bw, struct ar9170_calctl_edges edges[])
+{
+	u8 f;
+	int i;
+	u8 rc = 0;
+
+	if (freq < 3000)
+		f = freq - 2300;
+	else
+		f = (freq - 4800) / 5;
+
+	if (bw == CARL9170_BW_40_BELOW || bw == CARL9170_BW_40_ABOVE)
+		rc |= 0xf0;
+
+	for (i = 0; i < AR5416_NUM_BAND_EDGES; i++) {
+		if (edges[i].channel == 0xff)
+			break;
+		if (f == edges[i].channel) {
+			if (!(edges[i].power_flags & AR9170_CALCTL_EDGE_FLAGS))
+				rc |= 0x0f;
+			break;
+		}
+	}
+
+	return rc;
+}
+
+/*
+ * calculate the conformance test limits and the heavy clip parameter
+ * and apply them to ar->power* (derived from otus hal/hpmain.c, line 3706)
+ */
+static void carl9170_calc_ctl(struct ar9170 *ar, u32 freq, enum carl9170_bw bw)
+{
+	u8 ctl_grp; /* CTL group */
+	u8 ctl_idx; /* CTL index */
+	int i, j;
+	struct ctl_modes {
+		u8 ctl_mode;
+		u8 max_power;
+		u8 *pwr_cal_data;
+		int pwr_cal_len;
+	} *modes;
+
+	/*
+	 * order is relevant in the mode_list_*: we fall back to the
+	 * lower indices if any mode is missed in the EEPROM.
+	 */
+	struct ctl_modes mode_list_2ghz[] = {
+		{ CTL_11B, 0, ar->power_2G_cck, 4 },
+		{ CTL_11G, 0, ar->power_2G_ofdm, 4 },
+		{ CTL_2GHT20, 0, ar->power_2G_ht20, 8 },
+		{ CTL_2GHT40, 0, ar->power_2G_ht40, 8 },
+	};
+	struct ctl_modes mode_list_5ghz[] = {
+		{ CTL_11A, 0, ar->power_5G_leg, 4 },
+		{ CTL_5GHT20, 0, ar->power_5G_ht20, 8 },
+		{ CTL_5GHT40, 0, ar->power_5G_ht40, 8 },
+	};
+	int nr_modes;
+
+#define EDGES(c, n) (ar->eeprom.ctl_data[c].control_edges[n])
+
+	ar->heavy_clip = 0;
+
+	/*
+	 * TODO: investigate the differences between OTUS'
+	 * hpreg.c::zfHpGetRegulatoryDomain() and
+	 * ath/regd.c::ath_regd_get_band_ctl() -
+	 * e.g. for FCC3_WORLD the OTUS procedure
+	 * always returns CTL_FCC, while the one in ath/ delivers
+	 * CTL_ETSI for 2GHz and CTL_FCC for 5GHz.
+	 */
+	ctl_grp = ath_regd_get_band_ctl(&ar->common.regulatory,
+					ar->hw->conf.channel->band);
+
+	/* ctl group not found - either invalid band (NO_CTL) or ww roaming */
+	if (ctl_grp == NO_CTL || ctl_grp == SD_NO_CTL)
+		ctl_grp = CTL_FCC;
+
+	if (ctl_grp != CTL_FCC)
+		/* skip CTL and heavy clip for CTL_MKK and CTL_ETSI */
+		return;
+
+	if (ar->hw->conf.channel->band == IEEE80211_BAND_2GHZ) {
+		modes = mode_list_2ghz;
+		nr_modes = ARRAY_SIZE(mode_list_2ghz);
+	} else {
+		modes = mode_list_5ghz;
+		nr_modes = ARRAY_SIZE(mode_list_5ghz);
+	}
+
+	for (i = 0; i < nr_modes; i++) {
+		u8 c = ctl_grp | modes[i].ctl_mode;
+		for (ctl_idx = 0; ctl_idx < AR5416_NUM_CTLS; ctl_idx++)
+			if (c == ar->eeprom.ctl_index[ctl_idx])
+				break;
+		if (ctl_idx < AR5416_NUM_CTLS) {
+			int f_off = 0;
+
+			/*
+			 * determine heavy clip parameter
+			 * from the 11G edges array
+			 */
+			if (modes[i].ctl_mode == CTL_11G) {
+				ar->heavy_clip =
+					carl9170_get_heavy_clip(ar,
+						freq, bw, EDGES(ctl_idx, 1));
+			}
+
+			/* adjust freq for 40MHz */
+			if (modes[i].ctl_mode == CTL_2GHT40 ||
+			    modes[i].ctl_mode == CTL_5GHT40) {
+				if (bw == CARL9170_BW_40_BELOW)
+					f_off = -10;
+				else
+					f_off = 10;
+			}
+
+			modes[i].max_power =
+				carl9170_get_max_edge_power(ar,
+					freq+f_off, EDGES(ctl_idx, 1));
+
+			/*
+			 * TODO: check if the regulatory max. power is
+			 * controlled by cfg80211 for DFS.
+			 * (hpmain applies it to max_power itself for DFS freq)
+			 */
+
+		} else {
+			/*
+			 * Workaround in otus driver, hpmain.c, line 3906:
+			 * if no data for 5GHT20 are found, take the
+			 * legacy 5G value. We extend this here to fallback
+			 * from any other HT* or 11G, too.
+			 */
+			int k = i;
+
+			modes[i].max_power = AR5416_MAX_RATE_POWER;
+			while (k-- > 0) {
+				if (modes[k].max_power !=
+				    AR5416_MAX_RATE_POWER) {
+					modes[i].max_power = modes[k].max_power;
+					break;
+				}
+			}
+		}
+
+		/* apply max power to pwr_cal_data (ar->power_*) */
+		for (j = 0; j < modes[i].pwr_cal_len; j++) {
+			modes[i].pwr_cal_data[j] = min(modes[i].pwr_cal_data[j],
+						       modes[i].max_power);
+		}
+	}
+
+	if (ar->heavy_clip & 0xf0) {
+		ar->power_2G_ht40[0]--;
+		ar->power_2G_ht40[1]--;
+		ar->power_2G_ht40[2]--;
+	}
+	if (ar->heavy_clip & 0xf) {
+		ar->power_2G_ht20[0]++;
+		ar->power_2G_ht20[1]++;
+		ar->power_2G_ht20[2]++;
+	}
+
+#undef EDGES
+}
+
+static int carl9170_set_power_cal(struct ar9170 *ar, u32 freq,
+				  enum carl9170_bw bw)
+{
+	struct ar9170_calibration_target_power_legacy *ctpl;
+	struct ar9170_calibration_target_power_ht *ctph;
+	u8 *ctpres;
+	int ntargets;
+	int idx, i, n;
+	u8 ackpower, ackchains, f;
+	u8 pwr_freqs[AR5416_MAX_NUM_TGT_PWRS];
+
+	if (freq < 3000)
+		f = freq - 2300;
+	else
+		f = (freq - 4800)/5;
+
+	/*
+	 * cycle through the various modes
+	 *
+	 * legacy modes first: 5G, 2G CCK, 2G OFDM
+	 */
+	for (i = 0; i < 3; i++) {
+		switch (i) {
+		case 0: /* 5 GHz legacy */
+			ctpl = &ar->eeprom.cal_tgt_pwr_5G[0];
+			ntargets = AR5416_NUM_5G_TARGET_PWRS;
+			ctpres = ar->power_5G_leg;
+			break;
+		case 1: /* 2.4 GHz CCK */
+			ctpl = &ar->eeprom.cal_tgt_pwr_2G_cck[0];
+			ntargets = AR5416_NUM_2G_CCK_TARGET_PWRS;
+			ctpres = ar->power_2G_cck;
+			break;
+		case 2: /* 2.4 GHz OFDM */
+			ctpl = &ar->eeprom.cal_tgt_pwr_2G_ofdm[0];
+			ntargets = AR5416_NUM_2G_OFDM_TARGET_PWRS;
+			ctpres = ar->power_2G_ofdm;
+			break;
+		default:
+			BUG();
+		}
+
+		for (n = 0; n < ntargets; n++) {
+			if (ctpl[n].freq == 0xff)
+				break;
+			pwr_freqs[n] = ctpl[n].freq;
+		}
+		ntargets = n;
+		idx = carl9170_find_freq_idx(ntargets, pwr_freqs, f);
+		for (n = 0; n < 4; n++)
+			ctpres[n] = carl9170_interpolate_u8(f,
+				ctpl[idx + 0].freq, ctpl[idx + 0].power[n],
+				ctpl[idx + 1].freq, ctpl[idx + 1].power[n]);
+	}
+
+	/* HT modes now: 5G HT20, 5G HT40, 2G CCK, 2G OFDM, 2G HT20, 2G HT40 */
+	for (i = 0; i < 4; i++) {
+		switch (i) {
+		case 0: /* 5 GHz HT 20 */
+			ctph = &ar->eeprom.cal_tgt_pwr_5G_ht20[0];
+			ntargets = AR5416_NUM_5G_TARGET_PWRS;
+			ctpres = ar->power_5G_ht20;
+			break;
+		case 1: /* 5 GHz HT 40 */
+			ctph = &ar->eeprom.cal_tgt_pwr_5G_ht40[0];
+			ntargets = AR5416_NUM_5G_TARGET_PWRS;
+			ctpres = ar->power_5G_ht40;
+			break;
+		case 2: /* 2.4 GHz HT 20 */
+			ctph = &ar->eeprom.cal_tgt_pwr_2G_ht20[0];
+			ntargets = AR5416_NUM_2G_OFDM_TARGET_PWRS;
+			ctpres = ar->power_2G_ht20;
+			break;
+		case 3: /* 2.4 GHz HT 40 */
+			ctph = &ar->eeprom.cal_tgt_pwr_2G_ht40[0];
+			ntargets = AR5416_NUM_2G_OFDM_TARGET_PWRS;
+			ctpres = ar->power_2G_ht40;
+			break;
+		default:
+			BUG();
+		}
+
+		for (n = 0; n < ntargets; n++) {
+			if (ctph[n].freq == 0xff)
+				break;
+			pwr_freqs[n] = ctph[n].freq;
+		}
+		ntargets = n;
+		idx = carl9170_find_freq_idx(ntargets, pwr_freqs, f);
+		for (n = 0; n < 8; n++)
+			ctpres[n] = carl9170_interpolate_u8(f,
+				ctph[idx + 0].freq, ctph[idx + 0].power[n],
+				ctph[idx + 1].freq, ctph[idx + 1].power[n]);
+	}
+
+	/* calc. conformance test limits and apply to ar->power*[] */
+	carl9170_calc_ctl(ar, freq, bw);
+
+	/* set ACK/CTS TX power */
+	carl9170_regwrite_begin(ar);
+
+	if (ar->eeprom.tx_mask != 1)
+		ackchains = AR9170_TX_PHY_TXCHAIN_2;
+	else
+		ackchains = AR9170_TX_PHY_TXCHAIN_1;
+
+	if (freq < 3000)
+		ackpower = ar->power_2G_ofdm[0] & 0x3f;
+	else
+		ackpower = ar->power_5G_leg[0] & 0x3f;
+
+	carl9170_regwrite(AR9170_MAC_REG_ACK_TPC,
+			  0x3c1e | ackpower << 20 | ackchains << 26);
+	carl9170_regwrite(AR9170_MAC_REG_RTS_CTS_TPC,
+			  ackpower << 5 | ackchains << 11 |
+			  ackpower << 21 | ackchains << 27);
+
+	carl9170_regwrite(AR9170_MAC_REG_CFEND_QOSNULL_TPC,
+			  ackpower << 5 | ackchains << 11 |
+			  ackpower << 21 | ackchains << 27);
+
+	carl9170_regwrite_finish();
+	return carl9170_regwrite_result();
+}
+
+/* TODO: replace this with sign_extend32(noise, 8) */
+static int carl9170_calc_noise_dbm(u32 raw_noise)
+{
+	if (raw_noise & 0x100)
+		return ~0x1ff | raw_noise;
+	else
+		return raw_noise;
+}
+
+int carl9170_get_noisefloor(struct ar9170 *ar)
+{
+	static const u32 phy_regs[] = {
+		AR9170_PHY_REG_CCA, AR9170_PHY_REG_CH2_CCA,
+		AR9170_PHY_REG_EXT_CCA, AR9170_PHY_REG_CH2_EXT_CCA };
+	u32 phy_res[ARRAY_SIZE(phy_regs)];
+	int err, i;
+
+	BUILD_BUG_ON(ARRAY_SIZE(phy_regs) != ARRAY_SIZE(ar->noise));
+
+	err = carl9170_read_mreg(ar, ARRAY_SIZE(phy_regs), phy_regs, phy_res);
+	if (err)
+		return err;
+
+	for (i = 0; i < 2; i++) {
+		ar->noise[i] = carl9170_calc_noise_dbm(
+			(phy_res[i] >> 19) & 0x1ff);
+
+		ar->noise[i + 2] = carl9170_calc_noise_dbm(
+			(phy_res[i + 2] >> 23) & 0x1ff);
+	}
+
+	return 0;
+}
+
+static enum carl9170_bw nl80211_to_carl(enum nl80211_channel_type type)
+{
+	switch (type) {
+	case NL80211_CHAN_NO_HT:
+	case NL80211_CHAN_HT20:
+		return CARL9170_BW_20;
+	case NL80211_CHAN_HT40MINUS:
+		return CARL9170_BW_40_BELOW;
+	case NL80211_CHAN_HT40PLUS:
+		return CARL9170_BW_40_ABOVE;
+	default:
+		BUG();
+	}
+}
+
+int carl9170_set_channel(struct ar9170 *ar, struct ieee80211_channel *channel,
+			 enum nl80211_channel_type _bw,
+			 enum carl9170_rf_init_mode rfi)
+{
+	const struct carl9170_phy_freq_params *freqpar;
+	struct carl9170_rf_init_result rf_res;
+	struct carl9170_rf_init rf;
+	u32 cmd, tmp, offs = 0, new_ht = 0;
+	int err;
+	enum carl9170_bw bw;
+	bool warm_reset;
+	struct ieee80211_channel *old_channel = NULL;
+
+	bw = nl80211_to_carl(_bw);
+
+	if (conf_is_ht(&ar->hw->conf))
+		new_ht |= CARL9170FW_PHY_HT_ENABLE;
+
+	if (conf_is_ht40(&ar->hw->conf))
+		new_ht |= CARL9170FW_PHY_HT_DYN2040;
+
+	/* may be NULL at first setup */
+	if (ar->channel) {
+		old_channel = ar->channel;
+		warm_reset = (old_channel->band != channel->band) ||
+			     (old_channel->center_freq ==
+			      channel->center_freq) ||
+			     (ar->ht_settings != new_ht);
+
+		ar->channel = NULL;
+	} else {
+		warm_reset = true;
+	}
+
+	/* HW workaround */
+	if (!ar->hw->wiphy->bands[IEEE80211_BAND_5GHZ] &&
+	    channel->center_freq <= 2417)
+		warm_reset = true;
+
+	if (rfi != CARL9170_RFI_NONE || warm_reset) {
+		u32 val;
+
+		if (rfi == CARL9170_RFI_COLD)
+			val = AR9170_PWR_RESET_BB_COLD_RESET;
+		else
+			val = AR9170_PWR_RESET_BB_WARM_RESET;
+
+		/* warm/cold reset BB/ADDA */
+		err = carl9170_write_reg(ar, AR9170_PWR_REG_RESET, val);
+		if (err)
+			return err;
+
+		err = carl9170_write_reg(ar, AR9170_PWR_REG_RESET, 0x0);
+		if (err)
+			return err;
+
+		err = carl9170_init_phy(ar, channel->band);
+		if (err)
+			return err;
+
+		err = carl9170_init_rf_banks_0_7(ar,
+			channel->band == IEEE80211_BAND_5GHZ);
+		if (err)
+			return err;
+
+		cmd = CARL9170_CMD_RF_INIT;
+
+		msleep(100);
+
+		err = carl9170_echo_test(ar, 0xaabbccdd);
+		if (err)
+			return err;
+	} else {
+		cmd = CARL9170_CMD_FREQUENCY;
+	}
+
+	err = carl9170_exec_cmd(ar, CARL9170_CMD_FREQ_START, 0, NULL, 0, NULL);
+	if (err)
+		return err;
+
+	err = carl9170_write_reg(ar, AR9170_PHY_REG_HEAVY_CLIP_ENABLE,
+				 0x200);
+
+	err = carl9170_init_rf_bank4_pwr(ar,
+		channel->band == IEEE80211_BAND_5GHZ,
+		channel->center_freq, bw);
+	if (err)
+		return err;
+
+	tmp = AR9170_PHY_TURBO_FC_SINGLE_HT_LTF1 |
+	      AR9170_PHY_TURBO_FC_HT_EN;
+
+	switch (bw) {
+	case CARL9170_BW_20:
+		break;
+	case CARL9170_BW_40_BELOW:
+		tmp |= AR9170_PHY_TURBO_FC_DYN2040_EN |
+		       AR9170_PHY_TURBO_FC_SHORT_GI_40;
+		offs = 3;
+		break;
+	case CARL9170_BW_40_ABOVE:
+		tmp |= AR9170_PHY_TURBO_FC_DYN2040_EN |
+		       AR9170_PHY_TURBO_FC_SHORT_GI_40 |
+		       AR9170_PHY_TURBO_FC_DYN2040_PRI_CH;
+		offs = 1;
+		break;
+	default:
+		BUG();
+		return -ENOSYS;
+	}
+
+	if (ar->eeprom.tx_mask != 1)
+		tmp |= AR9170_PHY_TURBO_FC_WALSH;
+
+	err = carl9170_write_reg(ar, AR9170_PHY_REG_TURBO, tmp);
+	if (err)
+		return err;
+
+	err = carl9170_set_freq_cal_data(ar, channel);
+	if (err)
+		return err;
+
+	err = carl9170_set_power_cal(ar, channel->center_freq, bw);
+	if (err)
+		return err;
+
+	freqpar = carl9170_get_hw_dyn_params(channel, bw);
+
+	rf.ht_settings = new_ht;
+	if (conf_is_ht40(&ar->hw->conf))
+		SET_VAL(CARL9170FW_PHY_HT_EXT_CHAN_OFF, rf.ht_settings, offs);
+
+	rf.freq = cpu_to_le32(channel->center_freq * 1000);
+	rf.delta_slope_coeff_exp = cpu_to_le32(freqpar->coeff_exp);
+	rf.delta_slope_coeff_man = cpu_to_le32(freqpar->coeff_man);
+	rf.delta_slope_coeff_exp_shgi = cpu_to_le32(freqpar->coeff_exp_shgi);
+	rf.delta_slope_coeff_man_shgi = cpu_to_le32(freqpar->coeff_man_shgi);
+
+	if (rfi != CARL9170_RFI_NONE)
+		rf.finiteLoopCount = cpu_to_le32(2000);
+	else
+		rf.finiteLoopCount = cpu_to_le32(1000);
+
+	err = carl9170_exec_cmd(ar, cmd, sizeof(rf), &rf,
+				sizeof(rf_res), &rf_res);
+	if (err)
+		return err;
+
+	err = le32_to_cpu(rf_res.ret);
+	if (err != 0) {
+		ar->chan_fail++;
+		ar->total_chan_fail++;
+
+		wiphy_err(ar->hw->wiphy, "channel change: %d -> %d "
+			  "failed (%d).\n", old_channel ?
+			  old_channel->center_freq : -1, channel->center_freq,
+			  err);
+
+		if ((rfi == CARL9170_RFI_COLD) || (ar->chan_fail > 3)) {
+			/*
+			 * We have tried very hard to change to _another_
+			 * channel and we've failed to do so!
+			 * Chances are that the PHY/RF is no longer
+			 * operable (due to corruptions/fatal events/bugs?)
+			 * and we need to reset at a higher level.
+			 */
+			carl9170_restart(ar, CARL9170_RR_TOO_MANY_PHY_ERRORS);
+			return 0;
+		}
+
+		err = carl9170_set_channel(ar, channel, _bw,
+					   CARL9170_RFI_COLD);
+		if (err)
+			return err;
+	} else {
+		ar->chan_fail = 0;
+	}
+
+	err = carl9170_get_noisefloor(ar);
+	if (err)
+		return err;
+
+	if (ar->heavy_clip) {
+		err = carl9170_write_reg(ar, AR9170_PHY_REG_HEAVY_CLIP_ENABLE,
+					 0x200 | ar->heavy_clip);
+		if (err) {
+			if (net_ratelimit()) {
+				wiphy_err(ar->hw->wiphy, "failed to set "
+				       "heavy clip\n");
+			}
+
+			return err;
+		}
+	}
+
+	/* FIXME: PSM does not work in 5GHz Band */
+	if (channel->band == IEEE80211_BAND_5GHZ)
+		ar->ps.off_override |= PS_OFF_5GHZ;
+	else
+		ar->ps.off_override &= ~PS_OFF_5GHZ;
+
+	ar->channel = channel;
+	ar->ht_settings = new_ht;
+	return 0;
+}
diff --git a/drivers/net/wireless/ath/carl9170/phy.h b/drivers/net/wireless/ath/carl9170/phy.h
new file mode 100644
index 0000000..02c34eb
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/phy.h
@@ -0,0 +1,564 @@
+/*
+ * Shared Atheros AR9170 Header
+ *
+ * PHY register map
+ *
+ * Copyright (c) 2008-2009 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __CARL9170_SHARED_PHY_H
+#define __CARL9170_SHARED_PHY_H
+
+#define	AR9170_PHY_REG_BASE			(0x1bc000 + 0x9800)
+#define	AR9170_PHY_REG(_n)			(AR9170_PHY_REG_BASE + \
+						 ((_n) << 2))
+
+#define	AR9170_PHY_REG_TEST			(AR9170_PHY_REG_BASE + 0x0000)
+#define		AR9170_PHY_TEST_AGC_CLR			0x10000000
+#define		AR9170_PHY_TEST_RFSILENT_BB		0x00002000
+
+#define	AR9170_PHY_REG_TURBO			(AR9170_PHY_REG_BASE + 0x0004)
+#define		AR9170_PHY_TURBO_FC_TURBO_MODE		0x00000001
+#define		AR9170_PHY_TURBO_FC_TURBO_SHORT		0x00000002
+#define		AR9170_PHY_TURBO_FC_DYN2040_EN		0x00000004
+#define		AR9170_PHY_TURBO_FC_DYN2040_PRI_ONLY	0x00000008
+#define		AR9170_PHY_TURBO_FC_DYN2040_PRI_CH	0x00000010
+/* For 25 MHz channel spacing -- not used but supported by hw */
+#define		AR9170_PHY_TURBO_FC_DYN2040_EXT_CH	0x00000020
+#define		AR9170_PHY_TURBO_FC_HT_EN		0x00000040
+#define		AR9170_PHY_TURBO_FC_SHORT_GI_40		0x00000080
+#define		AR9170_PHY_TURBO_FC_WALSH		0x00000100
+#define		AR9170_PHY_TURBO_FC_SINGLE_HT_LTF1	0x00000200
+#define		AR9170_PHY_TURBO_FC_ENABLE_DAC_FIFO	0x00000800
+
+#define	AR9170_PHY_REG_TEST2			(AR9170_PHY_REG_BASE + 0x0008)
+
+#define	AR9170_PHY_REG_TIMING2			(AR9170_PHY_REG_BASE + 0x0010)
+#define		AR9170_PHY_TIMING2_USE_FORCE		0x00001000
+#define		AR9170_PHY_TIMING2_FORCE		0x00000fff
+#define		AR9170_PHY_TIMING2_FORCE_S			 0
+
+#define	AR9170_PHY_REG_TIMING3			(AR9170_PHY_REG_BASE + 0x0014)
+#define		AR9170_PHY_TIMING3_DSC_EXP		0x0001e000
+#define		AR9170_PHY_TIMING3_DSC_EXP_S		13
+#define		AR9170_PHY_TIMING3_DSC_MAN		0xfffe0000
+#define		AR9170_PHY_TIMING3_DSC_MAN_S		17
+
+#define	AR9170_PHY_REG_CHIP_ID			(AR9170_PHY_REG_BASE + 0x0018)
+#define		AR9170_PHY_CHIP_ID_REV_0		0x80
+#define		AR9170_PHY_CHIP_ID_REV_1		0x81
+#define		AR9170_PHY_CHIP_ID_9160_REV_0		0xb0
+
+#define	AR9170_PHY_REG_ACTIVE			(AR9170_PHY_REG_BASE + 0x001c)
+#define		AR9170_PHY_ACTIVE_EN			0x00000001
+#define		AR9170_PHY_ACTIVE_DIS			0x00000000
+
+#define	AR9170_PHY_REG_RF_CTL2			(AR9170_PHY_REG_BASE + 0x0024)
+#define		AR9170_PHY_RF_CTL2_TX_END_DATA_START	0x000000ff
+#define		AR9170_PHY_RF_CTL2_TX_END_DATA_START_S	0
+#define		AR9170_PHY_RF_CTL2_TX_END_PA_ON		0x0000ff00
+#define		AR9170_PHY_RF_CTL2_TX_END_PA_ON_S	8
+
+#define	AR9170_PHY_REG_RF_CTL3                  (AR9170_PHY_REG_BASE + 0x0028)
+#define		AR9170_PHY_RF_CTL3_TX_END_TO_A2_RX_ON	0x00ff0000
+#define		AR9170_PHY_RF_CTL3_TX_END_TO_A2_RX_ON_S	16
+
+#define	AR9170_PHY_REG_ADC_CTL			(AR9170_PHY_REG_BASE + 0x002c)
+#define		AR9170_PHY_ADC_CTL_OFF_INBUFGAIN	0x00000003
+#define		AR9170_PHY_ADC_CTL_OFF_INBUFGAIN_S	0
+#define		AR9170_PHY_ADC_CTL_OFF_PWDDAC		0x00002000
+#define		AR9170_PHY_ADC_CTL_OFF_PWDBANDGAP	0x00004000
+#define		AR9170_PHY_ADC_CTL_OFF_PWDADC		0x00008000
+#define		AR9170_PHY_ADC_CTL_ON_INBUFGAIN		0x00030000
+#define		AR9170_PHY_ADC_CTL_ON_INBUFGAIN_S	16
+
+#define	AR9170_PHY_REG_ADC_SERIAL_CTL		(AR9170_PHY_REG_BASE + 0x0030)
+#define		AR9170_PHY_ADC_SCTL_SEL_INTERNAL_ADDAC	0x00000000
+#define		AR9170_PHY_ADC_SCTL_SEL_EXTERNAL_RADIO	0x00000001
+
+#define	AR9170_PHY_REG_RF_CTL4			(AR9170_PHY_REG_BASE + 0x0034)
+#define		AR9170_PHY_RF_CTL4_TX_END_XPAB_OFF	0xff000000
+#define		AR9170_PHY_RF_CTL4_TX_END_XPAB_OFF_S	24
+#define		AR9170_PHY_RF_CTL4_TX_END_XPAA_OFF	0x00ff0000
+#define		AR9170_PHY_RF_CTL4_TX_END_XPAA_OFF_S	16
+#define		AR9170_PHY_RF_CTL4_FRAME_XPAB_ON	0x0000ff00
+#define		AR9170_PHY_RF_CTL4_FRAME_XPAB_ON_S	8
+#define		AR9170_PHY_RF_CTL4_FRAME_XPAA_ON	0x000000ff
+#define		AR9170_PHY_RF_CTL4_FRAME_XPAA_ON_S	0
+
+#define	AR9170_PHY_REG_TSTDAC_CONST		(AR9170_PHY_REG_BASE + 0x003c)
+
+#define	AR9170_PHY_REG_SETTLING			(AR9170_PHY_REG_BASE + 0x0044)
+#define		AR9170_PHY_SETTLING_SWITCH		0x00003f80
+#define		AR9170_PHY_SETTLING_SWITCH_S		7
+
+#define	AR9170_PHY_REG_RXGAIN			(AR9170_PHY_REG_BASE + 0x0048)
+#define	AR9170_PHY_REG_RXGAIN_CHAIN_2		(AR9170_PHY_REG_BASE + 0x2048)
+#define		AR9170_PHY_RXGAIN_TXRX_ATTEN		0x0003f000
+#define		AR9170_PHY_RXGAIN_TXRX_ATTEN_S		12
+#define		AR9170_PHY_RXGAIN_TXRX_RF_MAX		0x007c0000
+#define		AR9170_PHY_RXGAIN_TXRX_RF_MAX_S		18
+
+#define	AR9170_PHY_REG_DESIRED_SZ		(AR9170_PHY_REG_BASE + 0x0050)
+#define		AR9170_PHY_DESIRED_SZ_ADC		0x000000ff
+#define		AR9170_PHY_DESIRED_SZ_ADC_S		0
+#define		AR9170_PHY_DESIRED_SZ_PGA		0x0000ff00
+#define		AR9170_PHY_DESIRED_SZ_PGA_S		8
+#define		AR9170_PHY_DESIRED_SZ_TOT_DES		0x0ff00000
+#define		AR9170_PHY_DESIRED_SZ_TOT_DES_S		20
+
+#define	AR9170_PHY_REG_FIND_SIG			(AR9170_PHY_REG_BASE + 0x0058)
+#define		AR9170_PHY_FIND_SIG_FIRSTEP		0x0003f000
+#define		AR9170_PHY_FIND_SIG_FIRSTEP_S		12
+#define		AR9170_PHY_FIND_SIG_FIRPWR		0x03fc0000
+#define		AR9170_PHY_FIND_SIG_FIRPWR_S		18
+
+#define	AR9170_PHY_REG_AGC_CTL1			(AR9170_PHY_REG_BASE + 0x005c)
+#define		AR9170_PHY_AGC_CTL1_COARSE_LOW		0x00007f80
+#define		AR9170_PHY_AGC_CTL1_COARSE_LOW_S	7
+#define		AR9170_PHY_AGC_CTL1_COARSE_HIGH		0x003f8000
+#define		AR9170_PHY_AGC_CTL1_COARSE_HIGH_S	15
+
+#define	AR9170_PHY_REG_AGC_CONTROL		(AR9170_PHY_REG_BASE + 0x0060)
+#define		AR9170_PHY_AGC_CONTROL_CAL		0x00000001
+#define		AR9170_PHY_AGC_CONTROL_NF		0x00000002
+#define		AR9170_PHY_AGC_CONTROL_ENABLE_NF	0x00008000
+#define		AR9170_PHY_AGC_CONTROL_FLTR_CAL		0x00010000
+#define		AR9170_PHY_AGC_CONTROL_NO_UPDATE_NF	0x00020000
+
+#define	AR9170_PHY_REG_CCA			(AR9170_PHY_REG_BASE + 0x0064)
+#define		AR9170_PHY_CCA_MINCCA_PWR		0x0ff80000
+#define		AR9170_PHY_CCA_MINCCA_PWR_S		19
+#define		AR9170_PHY_CCA_THRESH62			0x0007f000
+#define		AR9170_PHY_CCA_THRESH62_S		12
+
+#define	AR9170_PHY_REG_SFCORR			(AR9170_PHY_REG_BASE + 0x0068)
+#define		AR9170_PHY_SFCORR_M2COUNT_THR		0x0000001f
+#define		AR9170_PHY_SFCORR_M2COUNT_THR_S		0
+#define		AR9170_PHY_SFCORR_M1_THRESH		0x00fe0000
+#define		AR9170_PHY_SFCORR_M1_THRESH_S		17
+#define		AR9170_PHY_SFCORR_M2_THRESH		0x7f000000
+#define		AR9170_PHY_SFCORR_M2_THRESH_S		24
+
+#define	AR9170_PHY_REG_SFCORR_LOW		(AR9170_PHY_REG_BASE + 0x006c)
+#define		AR9170_PHY_SFCORR_LOW_USE_SELF_CORR_LOW	0x00000001
+#define		AR9170_PHY_SFCORR_LOW_M2COUNT_THR_LOW	0x00003f00
+#define		AR9170_PHY_SFCORR_LOW_M2COUNT_THR_LOW_S	8
+#define		AR9170_PHY_SFCORR_LOW_M1_THRESH_LOW	0x001fc000
+#define		AR9170_PHY_SFCORR_LOW_M1_THRESH_LOW_S	14
+#define		AR9170_PHY_SFCORR_LOW_M2_THRESH_LOW	0x0fe00000
+#define		AR9170_PHY_SFCORR_LOW_M2_THRESH_LOW_S	21
+
+#define	AR9170_PHY_REG_SLEEP_CTR_CONTROL	(AR9170_PHY_REG_BASE + 0x0070)
+#define	AR9170_PHY_REG_SLEEP_CTR_LIMIT		(AR9170_PHY_REG_BASE + 0x0074)
+#define	AR9170_PHY_REG_SLEEP_SCAL		(AR9170_PHY_REG_BASE + 0x0078)
+
+#define	AR9170_PHY_REG_PLL_CTL			(AR9170_PHY_REG_BASE + 0x007c)
+#define		AR9170_PHY_PLL_CTL_40			0xaa
+#define		AR9170_PHY_PLL_CTL_40_5413		0x04
+#define		AR9170_PHY_PLL_CTL_44			0xab
+#define		AR9170_PHY_PLL_CTL_44_2133		0xeb
+#define		AR9170_PHY_PLL_CTL_40_2133		0xea
+
+#define	AR9170_PHY_REG_BIN_MASK_1		(AR9170_PHY_REG_BASE + 0x0100)
+#define	AR9170_PHY_REG_BIN_MASK_2		(AR9170_PHY_REG_BASE + 0x0104)
+#define	AR9170_PHY_REG_BIN_MASK_3		(AR9170_PHY_REG_BASE + 0x0108)
+#define	AR9170_PHY_REG_MASK_CTL			(AR9170_PHY_REG_BASE + 0x010c)
+
+/* analogue power on time (100ns) */
+#define	AR9170_PHY_REG_RX_DELAY			(AR9170_PHY_REG_BASE + 0x0114)
+#define	AR9170_PHY_REG_SEARCH_START_DELAY	(AR9170_PHY_REG_BASE + 0x0118)
+#define		AR9170_PHY_RX_DELAY_DELAY		0x00003fff
+
+#define	AR9170_PHY_REG_TIMING_CTRL4(_i)		(AR9170_PHY_REG_BASE + \
+						(0x0120 + ((_i) << 12)))
+#define		AR9170_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF		0x01f
+#define		AR9170_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF_S	0
+#define		AR9170_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF		0x7e0
+#define		AR9170_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF_S	5
+#define		AR9170_PHY_TIMING_CTRL4_IQCORR_ENABLE		0x800
+#define		AR9170_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX	0xf000
+#define		AR9170_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX_S	12
+#define		AR9170_PHY_TIMING_CTRL4_DO_IQCAL		0x10000
+#define		AR9170_PHY_TIMING_CTRL4_ENABLE_SPUR_RSSI	0x80000000
+#define		AR9170_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER	0x40000000
+#define		AR9170_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK	0x20000000
+#define		AR9170_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK	0x10000000
+
+#define	AR9170_PHY_REG_TIMING5			(AR9170_PHY_REG_BASE + 0x0124)
+#define		AR9170_PHY_TIMING5_CYCPWR_THR1		0x000000fe
+#define		AR9170_PHY_TIMING5_CYCPWR_THR1_S	1
+
+#define	AR9170_PHY_REG_POWER_TX_RATE1		(AR9170_PHY_REG_BASE + 0x0134)
+#define	AR9170_PHY_REG_POWER_TX_RATE2		(AR9170_PHY_REG_BASE + 0x0138)
+#define	AR9170_PHY_REG_POWER_TX_RATE_MAX	(AR9170_PHY_REG_BASE + 0x013c)
+#define		AR9170_PHY_POWER_TX_RATE_MAX_TPC_ENABLE	0x00000040
+
+#define	AR9170_PHY_REG_FRAME_CTL		(AR9170_PHY_REG_BASE + 0x0144)
+#define		AR9170_PHY_FRAME_CTL_TX_CLIP		0x00000038
+#define		AR9170_PHY_FRAME_CTL_TX_CLIP_S		3
+
+#define	AR9170_PHY_REG_SPUR_REG			(AR9170_PHY_REG_BASE + 0x014c)
+#define		AR9170_PHY_SPUR_REG_MASK_RATE_CNTL	(0xff << 18)
+#define		AR9170_PHY_SPUR_REG_MASK_RATE_CNTL_S	18
+#define		AR9170_PHY_SPUR_REG_ENABLE_MASK_PPM	0x20000
+#define		AR9170_PHY_SPUR_REG_MASK_RATE_SELECT	(0xff << 9)
+#define		AR9170_PHY_SPUR_REG_MASK_RATE_SELECT_S	9
+#define		AR9170_PHY_SPUR_REG_ENABLE_VIT_SPUR_RSSI	0x100
+#define		AR9170_PHY_SPUR_REG_SPUR_RSSI_THRESH	0x7f
+#define		AR9170_PHY_SPUR_REG_SPUR_RSSI_THRESH_S	0
+
+#define	AR9170_PHY_REG_RADAR_EXT		(AR9170_PHY_REG_BASE + 0x0140)
+#define		AR9170_PHY_RADAR_EXT_ENA		0x00004000
+
+#define	AR9170_PHY_REG_RADAR_0			(AR9170_PHY_REG_BASE + 0x0154)
+#define		AR9170_PHY_RADAR_0_ENA			0x00000001
+#define		AR9170_PHY_RADAR_0_FFT_ENA		0x80000000
+/* inband pulse threshold */
+#define		AR9170_PHY_RADAR_0_INBAND		0x0000003e
+#define		AR9170_PHY_RADAR_0_INBAND_S		1
+/* pulse RSSI threshold */
+#define		AR9170_PHY_RADAR_0_PRSSI		0x00000fc0
+#define		AR9170_PHY_RADAR_0_PRSSI_S		6
+/* pulse height threshold */
+#define		AR9170_PHY_RADAR_0_HEIGHT		0x0003f000
+#define		AR9170_PHY_RADAR_0_HEIGHT_S		12
+/* radar RSSI threshold */
+#define		AR9170_PHY_RADAR_0_RRSSI		0x00fc0000
+#define		AR9170_PHY_RADAR_0_RRSSI_S		18
+/* radar firepower threshold */
+#define		AR9170_PHY_RADAR_0_FIRPWR		0x7f000000
+#define		AR9170_PHY_RADAR_0_FIRPWR_S		24
+
+#define	AR9170_PHY_REG_RADAR_1			(AR9170_PHY_REG_BASE + 0x0158)
+#define		AR9170_PHY_RADAR_1_RELPWR_ENA		0x00800000
+#define		AR9170_PHY_RADAR_1_USE_FIR128		0x00400000
+#define		AR9170_PHY_RADAR_1_RELPWR_THRESH	0x003f0000
+#define		AR9170_PHY_RADAR_1_RELPWR_THRESH_S	16
+#define		AR9170_PHY_RADAR_1_BLOCK_CHECK		0x00008000
+#define		AR9170_PHY_RADAR_1_MAX_RRSSI		0x00004000
+#define		AR9170_PHY_RADAR_1_RELSTEP_CHECK	0x00002000
+#define		AR9170_PHY_RADAR_1_RELSTEP_THRESH	0x00001f00
+#define		AR9170_PHY_RADAR_1_RELSTEP_THRESH_S	8
+#define		AR9170_PHY_RADAR_1_MAXLEN		0x000000ff
+#define		AR9170_PHY_RADAR_1_MAXLEN_S		0
+
+#define	AR9170_PHY_REG_SWITCH_CHAIN_0		(AR9170_PHY_REG_BASE + 0x0160)
+#define	AR9170_PHY_REG_SWITCH_CHAIN_2		(AR9170_PHY_REG_BASE + 0x2160)
+
+#define	AR9170_PHY_REG_SWITCH_COM		(AR9170_PHY_REG_BASE + 0x0164)
+
+#define	AR9170_PHY_REG_CCA_THRESHOLD		(AR9170_PHY_REG_BASE + 0x0168)
+
+#define	AR9170_PHY_REG_SIGMA_DELTA		(AR9170_PHY_REG_BASE + 0x016c)
+#define		AR9170_PHY_SIGMA_DELTA_ADC_SEL		0x00000003
+#define		AR9170_PHY_SIGMA_DELTA_ADC_SEL_S	0
+#define		AR9170_PHY_SIGMA_DELTA_FILT2		0x000000f8
+#define		AR9170_PHY_SIGMA_DELTA_FILT2_S		3
+#define		AR9170_PHY_SIGMA_DELTA_FILT1		0x00001f00
+#define		AR9170_PHY_SIGMA_DELTA_FILT1_S		8
+#define		AR9170_PHY_SIGMA_DELTA_ADC_CLIP		0x01ffe000
+#define		AR9170_PHY_SIGMA_DELTA_ADC_CLIP_S	13
+
+#define	AR9170_PHY_REG_RESTART			(AR9170_PHY_REG_BASE + 0x0170)
+#define		AR9170_PHY_RESTART_DIV_GC		0x001c0000
+#define		AR9170_PHY_RESTART_DIV_GC_S		18
+
+#define	AR9170_PHY_REG_RFBUS_REQ		(AR9170_PHY_REG_BASE + 0x017c)
+#define		AR9170_PHY_RFBUS_REQ_EN			0x00000001
+
+#define	AR9170_PHY_REG_TIMING7			(AR9170_PHY_REG_BASE + 0x0180)
+#define	AR9170_PHY_REG_TIMING8			(AR9170_PHY_REG_BASE + 0x0184)
+#define		AR9170_PHY_TIMING8_PILOT_MASK_2		0x000fffff
+#define		AR9170_PHY_TIMING8_PILOT_MASK_2_S	0
+
+#define	AR9170_PHY_REG_BIN_MASK2_1		(AR9170_PHY_REG_BASE + 0x0188)
+#define	AR9170_PHY_REG_BIN_MASK2_2		(AR9170_PHY_REG_BASE + 0x018c)
+#define	AR9170_PHY_REG_BIN_MASK2_3		(AR9170_PHY_REG_BASE + 0x0190)
+#define	AR9170_PHY_REG_BIN_MASK2_4		(AR9170_PHY_REG_BASE + 0x0194)
+#define		AR9170_PHY_BIN_MASK2_4_MASK_4		0x00003fff
+#define		AR9170_PHY_BIN_MASK2_4_MASK_4_S		0
+
+#define	AR9170_PHY_REG_TIMING9			(AR9170_PHY_REG_BASE + 0x0198)
+#define	AR9170_PHY_REG_TIMING10			(AR9170_PHY_REG_BASE + 0x019c)
+#define		AR9170_PHY_TIMING10_PILOT_MASK_2	0x000fffff
+#define		AR9170_PHY_TIMING10_PILOT_MASK_2_S	0
+
+#define	AR9170_PHY_REG_TIMING11			(AR9170_PHY_REG_BASE + 0x01a0)
+#define		AR9170_PHY_TIMING11_SPUR_DELTA_PHASE	0x000fffff
+#define		AR9170_PHY_TIMING11_SPUR_DELTA_PHASE_S	0
+#define		AR9170_PHY_TIMING11_SPUR_FREQ_SD	0x3ff00000
+#define		AR9170_PHY_TIMING11_SPUR_FREQ_SD_S	20
+#define		AR9170_PHY_TIMING11_USE_SPUR_IN_AGC	0x40000000
+#define		AR9170_PHY_TIMING11_USE_SPUR_IN_SELFCOR	0x80000000
+
+#define	AR9170_PHY_REG_RX_CHAINMASK		(AR9170_PHY_REG_BASE + 0x01a4)
+#define	AR9170_PHY_REG_NEW_ADC_DC_GAIN_CORR(_i)	(AR9170_PHY_REG_BASE + \
+						 0x01b4 + ((_i) << 12))
+#define		AR9170_PHY_NEW_ADC_GAIN_CORR_ENABLE		0x40000000
+#define		AR9170_PHY_NEW_ADC_DC_OFFSET_CORR_ENABLE	0x80000000
+
+#define	AR9170_PHY_REG_MULTICHAIN_GAIN_CTL	(AR9170_PHY_REG_BASE + 0x01ac)
+#define		AR9170_PHY_9285_ANT_DIV_CTL_ALL		0x7f000000
+#define		AR9170_PHY_9285_ANT_DIV_CTL		0x01000000
+#define		AR9170_PHY_9285_ANT_DIV_CTL_S		24
+#define		AR9170_PHY_9285_ANT_DIV_ALT_LNACONF	0x06000000
+#define		AR9170_PHY_9285_ANT_DIV_ALT_LNACONF_S	25
+#define		AR9170_PHY_9285_ANT_DIV_MAIN_LNACONF	0x18000000
+#define		AR9170_PHY_9285_ANT_DIV_MAIN_LNACONF_S	27
+#define		AR9170_PHY_9285_ANT_DIV_ALT_GAINTB	0x20000000
+#define		AR9170_PHY_9285_ANT_DIV_ALT_GAINTB_S	29
+#define		AR9170_PHY_9285_ANT_DIV_MAIN_GAINTB	0x40000000
+#define		AR9170_PHY_9285_ANT_DIV_MAIN_GAINTB_S	30
+#define		AR9170_PHY_9285_ANT_DIV_LNA1		2
+#define		AR9170_PHY_9285_ANT_DIV_LNA2		1
+#define		AR9170_PHY_9285_ANT_DIV_LNA1_PLUS_LNA2	3
+#define		AR9170_PHY_9285_ANT_DIV_LNA1_MINUS_LNA2	0
+#define		AR9170_PHY_9285_ANT_DIV_GAINTB_0	0
+#define		AR9170_PHY_9285_ANT_DIV_GAINTB_1	1
+
+#define	AR9170_PHY_REG_EXT_CCA0			(AR9170_PHY_REG_BASE + 0x01b8)
+#define		AR9170_PHY_REG_EXT_CCA0_THRESH62	0x000000ff
+#define		AR9170_PHY_REG_EXT_CCA0_THRESH62_S	0
+
+#define	AR9170_PHY_REG_EXT_CCA			(AR9170_PHY_REG_BASE + 0x01bc)
+#define		AR9170_PHY_EXT_CCA_CYCPWR_THR1		0x0000fe00
+#define		AR9170_PHY_EXT_CCA_CYCPWR_THR1_S	9
+#define		AR9170_PHY_EXT_CCA_THRESH62		0x007f0000
+#define		AR9170_PHY_EXT_CCA_THRESH62_S		16
+#define		AR9170_PHY_EXT_MINCCA_PWR		0xff800000
+#define		AR9170_PHY_EXT_MINCCA_PWR_S		23
+
+#define	AR9170_PHY_REG_SFCORR_EXT		(AR9170_PHY_REG_BASE + 0x01c0)
+#define		AR9170_PHY_SFCORR_EXT_M1_THRESH		0x0000007f
+#define		AR9170_PHY_SFCORR_EXT_M1_THRESH_S	0
+#define		AR9170_PHY_SFCORR_EXT_M2_THRESH		0x00003f80
+#define		AR9170_PHY_SFCORR_EXT_M2_THRESH_S	7
+#define		AR9170_PHY_SFCORR_EXT_M1_THRESH_LOW	0x001fc000
+#define		AR9170_PHY_SFCORR_EXT_M1_THRESH_LOW_S	14
+#define		AR9170_PHY_SFCORR_EXT_M2_THRESH_LOW	0x0fe00000
+#define		AR9170_PHY_SFCORR_EXT_M2_THRESH_LOW_S	21
+#define		AR9170_PHY_SFCORR_SPUR_SUBCHNL_SD_S	28
+
+#define	AR9170_PHY_REG_HALFGI			(AR9170_PHY_REG_BASE + 0x01d0)
+#define		AR9170_PHY_HALFGI_DSC_MAN		0x0007fff0
+#define		AR9170_PHY_HALFGI_DSC_MAN_S		4
+#define		AR9170_PHY_HALFGI_DSC_EXP		0x0000000f
+#define		AR9170_PHY_HALFGI_DSC_EXP_S		0
+
+#define	AR9170_PHY_REG_CHANNEL_MASK_01_30	(AR9170_PHY_REG_BASE + 0x01d4)
+#define	AR9170_PHY_REG_CHANNEL_MASK_31_60	(AR9170_PHY_REG_BASE + 0x01d8)
+
+#define	AR9170_PHY_REG_CHAN_INFO_MEMORY		(AR9170_PHY_REG_BASE + 0x01dc)
+#define		AR9170_PHY_CHAN_INFO_MEMORY_CAPTURE_MASK	0x0001
+
+#define	AR9170_PHY_REG_HEAVY_CLIP_ENABLE	(AR9170_PHY_REG_BASE + 0x01e0)
+#define	AR9170_PHY_REG_HEAVY_CLIP_FACTOR_RIFS	(AR9170_PHY_REG_BASE + 0x01ec)
+#define		AR9170_PHY_RIFS_INIT_DELAY		0x03ff0000
+
+#define	AR9170_PHY_REG_CALMODE			(AR9170_PHY_REG_BASE + 0x01f0)
+#define		AR9170_PHY_CALMODE_IQ			0x00000000
+#define		AR9170_PHY_CALMODE_ADC_GAIN		0x00000001
+#define		AR9170_PHY_CALMODE_ADC_DC_PER		0x00000002
+#define		AR9170_PHY_CALMODE_ADC_DC_INIT		0x00000003
+
+#define	AR9170_PHY_REG_REFCLKDLY		(AR9170_PHY_REG_BASE + 0x01f4)
+#define	AR9170_PHY_REG_REFCLKPD			(AR9170_PHY_REG_BASE + 0x01f8)
+
+
+#define	AR9170_PHY_REG_CAL_MEAS_0(_i)		(AR9170_PHY_REG_BASE + \
+						 0x0410 + ((_i) << 12))
+#define	AR9170_PHY_REG_CAL_MEAS_1(_i)		(AR9170_PHY_REG_BASE + \
+						 0x0414 \ + ((_i) << 12))
+#define	AR9170_PHY_REG_CAL_MEAS_2(_i)		(AR9170_PHY_REG_BASE + \
+						 0x0418 + ((_i) << 12))
+#define	AR9170_PHY_REG_CAL_MEAS_3(_i)		(AR9170_PHY_REG_BASE + \
+						 0x041c + ((_i) << 12))
+
+#define	AR9170_PHY_REG_CURRENT_RSSI		(AR9170_PHY_REG_BASE + 0x041c)
+
+#define	AR9170_PHY_REG_RFBUS_GRANT		(AR9170_PHY_REG_BASE + 0x0420)
+#define		AR9170_PHY_RFBUS_GRANT_EN		0x00000001
+
+#define	AR9170_PHY_REG_CHAN_INFO_GAIN_DIFF	(AR9170_PHY_REG_BASE + 0x04f4)
+#define		AR9170_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT	320
+
+#define	AR9170_PHY_REG_CHAN_INFO_GAIN		(AR9170_PHY_REG_BASE + 0x04fc)
+
+#define	AR9170_PHY_REG_MODE			(AR9170_PHY_REG_BASE + 0x0a00)
+#define		AR9170_PHY_MODE_ASYNCFIFO		0x80
+#define		AR9170_PHY_MODE_AR2133			0x08
+#define		AR9170_PHY_MODE_AR5111			0x00
+#define		AR9170_PHY_MODE_AR5112			0x08
+#define		AR9170_PHY_MODE_DYNAMIC			0x04
+#define		AR9170_PHY_MODE_RF2GHZ			0x02
+#define		AR9170_PHY_MODE_RF5GHZ			0x00
+#define		AR9170_PHY_MODE_CCK			0x01
+#define		AR9170_PHY_MODE_OFDM			0x00
+#define		AR9170_PHY_MODE_DYN_CCK_DISABLE		0x100
+
+#define	AR9170_PHY_REG_CCK_TX_CTRL		(AR9170_PHY_REG_BASE + 0x0a04)
+#define		AR9170_PHY_CCK_TX_CTRL_JAPAN			0x00000010
+#define		AR9170_PHY_CCK_TX_CTRL_TX_DAC_SCALE_CCK         0x0000000c
+#define		AR9170_PHY_CCK_TX_CTRL_TX_DAC_SCALE_CCK_S       2
+
+#define	AR9170_PHY_REG_CCK_DETECT		(AR9170_PHY_REG_BASE + 0x0a08)
+#define		AR9170_PHY_CCK_DETECT_WEAK_SIG_THR_CCK		0x0000003f
+#define		AR9170_PHY_CCK_DETECT_WEAK_SIG_THR_CCK_S	0
+/* [12:6] settling time for antenna switch */
+#define		AR9170_PHY_CCK_DETECT_ANT_SWITCH_TIME		0x00001fc0
+#define		AR9170_PHY_CCK_DETECT_ANT_SWITCH_TIME_S		6
+#define		AR9170_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV	0x2000
+#define		AR9170_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV_S	13
+
+#define	AR9170_PHY_REG_GAIN_2GHZ		(AR9170_PHY_REG_BASE + 0x0a0c)
+#define	AR9170_PHY_REG_GAIN_2GHZ_CHAIN_2	(AR9170_PHY_REG_BASE + 0x2a0c)
+#define		AR9170_PHY_GAIN_2GHZ_RXTX_MARGIN	0x00fc0000
+#define		AR9170_PHY_GAIN_2GHZ_RXTX_MARGIN_S	18
+#define		AR9170_PHY_GAIN_2GHZ_BSW_MARGIN		0x00003c00
+#define		AR9170_PHY_GAIN_2GHZ_BSW_MARGIN_S	10
+#define		AR9170_PHY_GAIN_2GHZ_BSW_ATTEN		0x0000001f
+#define		AR9170_PHY_GAIN_2GHZ_BSW_ATTEN_S	0
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN2_MARGIN	0x003e0000
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN2_MARGIN_S	17
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN1_MARGIN	0x0001f000
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN1_MARGIN_S	12
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN2_DB		0x00000fc0
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN2_DB_S	6
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN1_DB		0x0000003f
+#define		AR9170_PHY_GAIN_2GHZ_XATTEN1_DB_S	0
+
+#define	AR9170_PHY_REG_CCK_RXCTRL4		(AR9170_PHY_REG_BASE + 0x0a1c)
+#define		AR9170_PHY_CCK_RXCTRL4_FREQ_EST_SHORT	0x01f80000
+#define		AR9170_PHY_CCK_RXCTRL4_FREQ_EST_SHORT_S	19
+
+#define	AR9170_PHY_REG_DAG_CTRLCCK		(AR9170_PHY_REG_BASE + 0x0a28)
+#define		AR9170_REG_DAG_CTRLCCK_EN_RSSI_THR	0x00000200
+#define		AR9170_REG_DAG_CTRLCCK_RSSI_THR		0x0001fc00
+#define		AR9170_REG_DAG_CTRLCCK_RSSI_THR_S	10
+
+#define	AR9170_PHY_REG_FORCE_CLKEN_CCK		(AR9170_PHY_REG_BASE + 0x0a2c)
+#define		AR9170_FORCE_CLKEN_CCK_MRC_MUX		0x00000040
+
+#define	AR9170_PHY_REG_POWER_TX_RATE3		(AR9170_PHY_REG_BASE + 0x0a34)
+#define	AR9170_PHY_REG_POWER_TX_RATE4		(AR9170_PHY_REG_BASE + 0x0a38)
+
+#define	AR9170_PHY_REG_SCRM_SEQ_XR		(AR9170_PHY_REG_BASE + 0x0a3c)
+#define	AR9170_PHY_REG_HEADER_DETECT_XR		(AR9170_PHY_REG_BASE + 0x0a40)
+#define	AR9170_PHY_REG_CHIRP_DETECTED_XR	(AR9170_PHY_REG_BASE + 0x0a44)
+#define	AR9170_PHY_REG_BLUETOOTH		(AR9170_PHY_REG_BASE + 0x0a54)
+
+#define	AR9170_PHY_REG_TPCRG1			(AR9170_PHY_REG_BASE + 0x0a58)
+#define		AR9170_PHY_TPCRG1_NUM_PD_GAIN		0x0000c000
+#define		AR9170_PHY_TPCRG1_NUM_PD_GAIN_S		14
+#define		AR9170_PHY_TPCRG1_PD_GAIN_1		0x00030000
+#define		AR9170_PHY_TPCRG1_PD_GAIN_1_S		16
+#define		AR9170_PHY_TPCRG1_PD_GAIN_2		0x000c0000
+#define		AR9170_PHY_TPCRG1_PD_GAIN_2_S		18
+#define		AR9170_PHY_TPCRG1_PD_GAIN_3		0x00300000
+#define		AR9170_PHY_TPCRG1_PD_GAIN_3_S		20
+#define		AR9170_PHY_TPCRG1_PD_CAL_ENABLE		0x00400000
+#define		AR9170_PHY_TPCRG1_PD_CAL_ENABLE_S	22
+
+#define	AR9170_PHY_REG_TX_PWRCTRL4		(AR9170_PHY_REG_BASE + 0x0a64)
+#define		AR9170_PHY_TX_PWRCTRL_PD_AVG_VALID	0x00000001
+#define		AR9170_PHY_TX_PWRCTRL_PD_AVG_VALID_S	0
+#define		AR9170_PHY_TX_PWRCTRL_PD_AVG_OUT	0x000001fe
+#define		AR9170_PHY_TX_PWRCTRL_PD_AVG_OUT_S	1
+
+#define	AR9170_PHY_REG_ANALOG_SWAP		(AR9170_PHY_REG_BASE + 0x0a68)
+#define		AR9170_PHY_ANALOG_SWAP_AB		0x0001
+#define		AR9170_PHY_ANALOG_SWAP_ALT_CHAIN	0x00000040
+
+#define	AR9170_PHY_REG_TPCRG5			(AR9170_PHY_REG_BASE + 0x0a6c)
+#define		AR9170_PHY_TPCRG5_PD_GAIN_OVERLAP	0x0000000f
+#define		AR9170_PHY_TPCRG5_PD_GAIN_OVERLAP_S	0
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_1	0x000003f0
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_1_S	4
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_2	0x0000fc00
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_2_S	10
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_3    0x003f0000
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_3_S  16
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_4    0x0fc00000
+#define		AR9170_PHY_TPCRG5_PD_GAIN_BOUNDARY_4_S  22
+
+#define	AR9170_PHY_REG_TX_PWRCTRL6_0		(AR9170_PHY_REG_BASE + 0x0a70)
+#define	AR9170_PHY_REG_TX_PWRCTRL6_1		(AR9170_PHY_REG_BASE + 0x1a70)
+#define		AR9170_PHY_TX_PWRCTRL_ERR_EST_MODE	0x03000000
+#define		AR9170_PHY_TX_PWRCTRL_ERR_EST_MODE_S	24
+
+#define	AR9170_PHY_REG_TX_PWRCTRL7		(AR9170_PHY_REG_BASE + 0x0a74)
+#define		AR9170_PHY_TX_PWRCTRL_INIT_TX_GAIN	0x01f80000
+#define		AR9170_PHY_TX_PWRCTRL_INIT_TX_GAIN_S	19
+
+#define	AR9170_PHY_REG_TX_PWRCTRL9		(AR9170_PHY_REG_BASE + 0x0a7c)
+#define		AR9170_PHY_TX_DESIRED_SCALE_CCK		0x00007c00
+#define		AR9170_PHY_TX_DESIRED_SCALE_CCK_S	10
+#define		AR9170_PHY_TX_PWRCTRL9_RES_DC_REMOVAL	0x80000000
+#define		AR9170_PHY_TX_PWRCTRL9_RES_DC_REMOVAL_S	31
+
+#define	AR9170_PHY_REG_TX_GAIN_TBL1		(AR9170_PHY_REG_BASE + 0x0b00)
+#define		AR9170_PHY_TX_GAIN			0x0007f000
+#define		AR9170_PHY_TX_GAIN_S			12
+
+/* Carrier leak calibration control, do it after AGC calibration */
+#define	AR9170_PHY_REG_CL_CAL_CTL		(AR9170_PHY_REG_BASE + 0x0b58)
+#define		AR9170_PHY_CL_CAL_ENABLE		0x00000002
+#define		AR9170_PHY_CL_CAL_PARALLEL_CAL_ENABLE	0x00000001
+
+#define	AR9170_PHY_REG_POWER_TX_RATE5		(AR9170_PHY_REG_BASE + 0x0b8c)
+#define	AR9170_PHY_REG_POWER_TX_RATE6		(AR9170_PHY_REG_BASE + 0x0b90)
+
+#define	AR9170_PHY_REG_CH0_TX_PWRCTRL11		(AR9170_PHY_REG_BASE + 0x0b98)
+#define	AR9170_PHY_REG_CH1_TX_PWRCTRL11		(AR9170_PHY_REG_BASE + 0x1b98)
+#define		AR9170_PHY_TX_CHX_PWRCTRL_OLPC_TEMP_COMP	0x0000fc00
+#define		AR9170_PHY_TX_CHX_PWRCTRL_OLPC_TEMP_COMP_S	10
+
+#define	AR9170_PHY_REG_CAL_CHAINMASK		(AR9170_PHY_REG_BASE + 0x0b9c)
+#define	AR9170_PHY_REG_VIT_MASK2_M_46_61	(AR9170_PHY_REG_BASE + 0x0ba0)
+#define	AR9170_PHY_REG_MASK2_M_31_45		(AR9170_PHY_REG_BASE + 0x0ba4)
+#define	AR9170_PHY_REG_MASK2_M_16_30		(AR9170_PHY_REG_BASE + 0x0ba8)
+#define	AR9170_PHY_REG_MASK2_M_00_15		(AR9170_PHY_REG_BASE + 0x0bac)
+#define	AR9170_PHY_REG_PILOT_MASK_01_30		(AR9170_PHY_REG_BASE + 0x0bb0)
+#define	AR9170_PHY_REG_PILOT_MASK_31_60		(AR9170_PHY_REG_BASE + 0x0bb4)
+#define	AR9170_PHY_REG_MASK2_P_15_01		(AR9170_PHY_REG_BASE + 0x0bb8)
+#define	AR9170_PHY_REG_MASK2_P_30_16		(AR9170_PHY_REG_BASE + 0x0bbc)
+#define	AR9170_PHY_REG_MASK2_P_45_31		(AR9170_PHY_REG_BASE + 0x0bc0)
+#define	AR9170_PHY_REG_MASK2_P_61_45		(AR9170_PHY_REG_BASE + 0x0bc4)
+#define	AR9170_PHY_REG_POWER_TX_SUB		(AR9170_PHY_REG_BASE + 0x0bc8)
+#define	AR9170_PHY_REG_POWER_TX_RATE7		(AR9170_PHY_REG_BASE + 0x0bcc)
+#define	AR9170_PHY_REG_POWER_TX_RATE8		(AR9170_PHY_REG_BASE + 0x0bd0)
+#define	AR9170_PHY_REG_POWER_TX_RATE9		(AR9170_PHY_REG_BASE + 0x0bd4)
+#define	AR9170_PHY_REG_XPA_CFG			(AR9170_PHY_REG_BASE + 0x0bd8)
+#define		AR9170_PHY_FORCE_XPA_CFG		0x000000001
+#define		AR9170_PHY_FORCE_XPA_CFG_S		0
+
+#define	AR9170_PHY_REG_CH1_CCA			(AR9170_PHY_REG_BASE + 0x1064)
+#define		AR9170_PHY_CH1_MINCCA_PWR		0x0ff80000
+#define		AR9170_PHY_CH1_MINCCA_PWR_S		19
+
+#define	AR9170_PHY_REG_CH2_CCA			(AR9170_PHY_REG_BASE + 0x2064)
+#define		AR9170_PHY_CH2_MINCCA_PWR		0x0ff80000
+#define		AR9170_PHY_CH2_MINCCA_PWR_S		19
+
+#define	AR9170_PHY_REG_CH1_EXT_CCA		(AR9170_PHY_REG_BASE + 0x11bc)
+#define		AR9170_PHY_CH1_EXT_MINCCA_PWR		0xff800000
+#define		AR9170_PHY_CH1_EXT_MINCCA_PWR_S		23
+
+#define	AR9170_PHY_REG_CH2_EXT_CCA		(AR9170_PHY_REG_BASE + 0x21bc)
+#define		AR9170_PHY_CH2_EXT_MINCCA_PWR		0xff800000
+#define		AR9170_PHY_CH2_EXT_MINCCA_PWR_S		23
+
+#endif	/* __CARL9170_SHARED_PHY_H */
diff --git a/drivers/net/wireless/ath/carl9170/rx.c b/drivers/net/wireless/ath/carl9170/rx.c
new file mode 100644
index 0000000..939a0e9
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/rx.c
@@ -0,0 +1,938 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * 802.11 & command trap routines
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/crc32.h>
+#include <net/mac80211.h>
+#include "carl9170.h"
+#include "hw.h"
+#include "cmd.h"
+
+static void carl9170_dbg_message(struct ar9170 *ar, const char *buf, u32 len)
+{
+	bool restart = false;
+	enum carl9170_restart_reasons reason = CARL9170_RR_NO_REASON;
+
+	if (len > 3) {
+		if (memcmp(buf, CARL9170_ERR_MAGIC, 3) == 0) {
+			ar->fw.err_counter++;
+			if (ar->fw.err_counter > 3) {
+				restart = true;
+				reason = CARL9170_RR_TOO_MANY_FIRMWARE_ERRORS;
+			}
+		}
+
+		if (memcmp(buf, CARL9170_BUG_MAGIC, 3) == 0) {
+			ar->fw.bug_counter++;
+			restart = true;
+			reason = CARL9170_RR_FATAL_FIRMWARE_ERROR;
+		}
+	}
+
+	wiphy_info(ar->hw->wiphy, "FW: %.*s\n", len, buf);
+
+	if (restart)
+		carl9170_restart(ar, reason);
+}
+
+static void carl9170_handle_ps(struct ar9170 *ar, struct carl9170_rsp *rsp)
+{
+	u32 ps;
+	bool new_ps;
+
+	ps = le32_to_cpu(rsp->psm.state);
+
+	new_ps = (ps & CARL9170_PSM_COUNTER) != CARL9170_PSM_WAKE;
+	if (ar->ps.state != new_ps) {
+		if (!new_ps) {
+			ar->ps.sleep_ms = jiffies_to_msecs(jiffies -
+				ar->ps.last_action);
+		}
+
+		ar->ps.last_action = jiffies;
+
+		ar->ps.state = new_ps;
+	}
+}
+
+static int carl9170_check_sequence(struct ar9170 *ar, unsigned int seq)
+{
+	if (ar->cmd_seq < -1)
+		return 0;
+
+	/*
+	 * Initialize Counter
+	 */
+	if (ar->cmd_seq < 0)
+		ar->cmd_seq = seq;
+
+	/*
+	 * The sequence is strictly monotonic increasing and it never skips!
+	 *
+	 * Therefore we can safely assume that whenever we received an
+	 * unexpected sequence we have lost some valuable data.
+	 */
+	if (seq != ar->cmd_seq) {
+		int count;
+
+		count = (seq - ar->cmd_seq) % ar->fw.cmd_bufs;
+
+		wiphy_err(ar->hw->wiphy, "lost %d command responses/traps! "
+			  "w:%d g:%d\n", count, ar->cmd_seq, seq);
+
+		carl9170_restart(ar, CARL9170_RR_LOST_RSP);
+		return -EIO;
+	}
+
+	ar->cmd_seq = (ar->cmd_seq + 1) % ar->fw.cmd_bufs;
+	return 0;
+}
+
+static void carl9170_cmd_callback(struct ar9170 *ar, u32 len, void *buffer)
+{
+	/*
+	 * Some commands may have a variable response length
+	 * and we cannot predict the correct length in advance.
+	 * So we only check if we provided enough space for the data.
+	 */
+	if (unlikely(ar->readlen != (len - 4))) {
+		dev_warn(&ar->udev->dev, "received invalid command response:"
+			 "got %d, instead of %d\n", len - 4, ar->readlen);
+		print_hex_dump_bytes("carl9170 cmd:", DUMP_PREFIX_OFFSET,
+			ar->cmd_buf, (ar->cmd.hdr.len + 4) & 0x3f);
+		print_hex_dump_bytes("carl9170 rsp:", DUMP_PREFIX_OFFSET,
+			buffer, len);
+		/*
+		 * Do not complete. The command times out,
+		 * and we get a stack trace from there.
+		 */
+		carl9170_restart(ar, CARL9170_RR_INVALID_RSP);
+	}
+
+	spin_lock(&ar->cmd_lock);
+	if (ar->readbuf) {
+		if (len >= 4)
+			memcpy(ar->readbuf, buffer + 4, len - 4);
+
+		ar->readbuf = NULL;
+	}
+	complete(&ar->cmd_wait);
+	spin_unlock(&ar->cmd_lock);
+}
+
+void carl9170_handle_command_response(struct ar9170 *ar, void *buf, u32 len)
+{
+	struct carl9170_rsp *cmd = (void *) buf;
+	struct ieee80211_vif *vif;
+
+	if (carl9170_check_sequence(ar, cmd->hdr.seq))
+		return;
+
+	if ((cmd->hdr.cmd & CARL9170_RSP_FLAG) != CARL9170_RSP_FLAG) {
+		if (!(cmd->hdr.cmd & CARL9170_CMD_ASYNC_FLAG))
+			carl9170_cmd_callback(ar, len, buf);
+
+		return;
+	}
+
+	if (unlikely(cmd->hdr.len != (len - 4))) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "FW: received over-/under"
+				"sized event %x (%d, but should be %d).\n",
+			       cmd->hdr.cmd, cmd->hdr.len, len - 4);
+
+			print_hex_dump_bytes("dump:", DUMP_PREFIX_NONE,
+					     buf, len);
+		}
+
+		return;
+	}
+
+	/* hardware event handlers */
+	switch (cmd->hdr.cmd) {
+	case CARL9170_RSP_PRETBTT:
+		/* pre-TBTT event */
+		rcu_read_lock();
+		vif = carl9170_get_main_vif(ar);
+
+		if (!vif) {
+			rcu_read_unlock();
+			break;
+		}
+
+		switch (vif->type) {
+		case NL80211_IFTYPE_STATION:
+			carl9170_handle_ps(ar, cmd);
+			break;
+
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_ADHOC:
+			carl9170_update_beacon(ar, true);
+			break;
+
+		default:
+			break;
+		}
+		rcu_read_unlock();
+
+		break;
+
+
+	case CARL9170_RSP_TXCOMP:
+		/* TX status notification */
+		carl9170_tx_process_status(ar, cmd);
+		break;
+
+	case CARL9170_RSP_BEACON_CONFIG:
+		/*
+		 * (IBSS) beacon send notification
+		 * bytes: 04 c2 XX YY B4 B3 B2 B1
+		 *
+		 * XX always 80
+		 * YY always 00
+		 * B1-B4 "should" be the number of send out beacons.
+		 */
+		break;
+
+	case CARL9170_RSP_ATIM:
+		/* End of Atim Window */
+		break;
+
+	case CARL9170_RSP_WATCHDOG:
+		/* Watchdog Interrupt */
+		carl9170_restart(ar, CARL9170_RR_WATCHDOG);
+		break;
+
+	case CARL9170_RSP_TEXT:
+		/* firmware debug */
+		carl9170_dbg_message(ar, (char *)buf + 4, len - 4);
+		break;
+
+	case CARL9170_RSP_HEXDUMP:
+		wiphy_dbg(ar->hw->wiphy, "FW: HD %d\n", len - 4);
+		print_hex_dump_bytes("FW:", DUMP_PREFIX_NONE,
+				     (char *)buf + 4, len - 4);
+		break;
+
+	case CARL9170_RSP_RADAR:
+		if (!net_ratelimit())
+			break;
+
+		wiphy_info(ar->hw->wiphy, "FW: RADAR! Please report this "
+		       "incident to linux-wireless@vger.kernel.org !\n");
+		break;
+
+	case CARL9170_RSP_GPIO:
+#ifdef CONFIG_CARL9170_WPC
+		if (ar->wps.pbc) {
+			bool state = !!(cmd->gpio.gpio & cpu_to_le32(
+				AR9170_GPIO_PORT_WPS_BUTTON_PRESSED));
+
+			if (state != ar->wps.pbc_state) {
+				ar->wps.pbc_state = state;
+				input_report_key(ar->wps.pbc, KEY_WPS_BUTTON,
+						 state);
+				input_sync(ar->wps.pbc);
+			}
+		}
+#endif /* CONFIG_CARL9170_WPC */
+		break;
+
+	case CARL9170_RSP_BOOT:
+		complete(&ar->fw_boot_wait);
+		break;
+
+	default:
+		wiphy_err(ar->hw->wiphy, "FW: received unhandled event %x\n",
+			cmd->hdr.cmd);
+		print_hex_dump_bytes("dump:", DUMP_PREFIX_NONE, buf, len);
+		break;
+	}
+}
+
+static int carl9170_rx_mac_status(struct ar9170 *ar,
+	struct ar9170_rx_head *head, struct ar9170_rx_macstatus *mac,
+	struct ieee80211_rx_status *status)
+{
+	struct ieee80211_channel *chan;
+	u8 error, decrypt;
+
+	BUILD_BUG_ON(sizeof(struct ar9170_rx_head) != 12);
+	BUILD_BUG_ON(sizeof(struct ar9170_rx_macstatus) != 4);
+
+	error = mac->error;
+
+	if (error & AR9170_RX_ERROR_WRONG_RA) {
+		if (!ar->sniffer_enabled)
+			return -EINVAL;
+	}
+
+	if (error & AR9170_RX_ERROR_PLCP) {
+		if (!(ar->filter_state & FIF_PLCPFAIL))
+			return -EINVAL;
+
+		status->flag |= RX_FLAG_FAILED_PLCP_CRC;
+	}
+
+	if (error & AR9170_RX_ERROR_FCS) {
+		ar->tx_fcs_errors++;
+
+		if (!(ar->filter_state & FIF_FCSFAIL))
+			return -EINVAL;
+
+		status->flag |= RX_FLAG_FAILED_FCS_CRC;
+	}
+
+	decrypt = ar9170_get_decrypt_type(mac);
+	if (!(decrypt & AR9170_RX_ENC_SOFTWARE) &&
+	    decrypt != AR9170_ENC_ALG_NONE) {
+		if ((decrypt == AR9170_ENC_ALG_TKIP) &&
+		    (error & AR9170_RX_ERROR_MMIC))
+			status->flag |= RX_FLAG_MMIC_ERROR;
+
+		status->flag |= RX_FLAG_DECRYPTED;
+	}
+
+	if (error & AR9170_RX_ERROR_DECRYPT && !ar->sniffer_enabled)
+		return -ENODATA;
+
+	error &= ~(AR9170_RX_ERROR_MMIC |
+		   AR9170_RX_ERROR_FCS |
+		   AR9170_RX_ERROR_WRONG_RA |
+		   AR9170_RX_ERROR_DECRYPT |
+		   AR9170_RX_ERROR_PLCP);
+
+	/* drop any other error frames */
+	if (unlikely(error)) {
+		/* TODO: update netdevice's RX dropped/errors statistics */
+
+		if (net_ratelimit())
+			wiphy_dbg(ar->hw->wiphy, "received frame with "
+			       "suspicious error code (%#x).\n", error);
+
+		return -EINVAL;
+	}
+
+	chan = ar->channel;
+	if (chan) {
+		status->band = chan->band;
+		status->freq = chan->center_freq;
+	}
+
+	switch (mac->status & AR9170_RX_STATUS_MODULATION) {
+	case AR9170_RX_STATUS_MODULATION_CCK:
+		if (mac->status & AR9170_RX_STATUS_SHORT_PREAMBLE)
+			status->flag |= RX_FLAG_SHORTPRE;
+		switch (head->plcp[0]) {
+		case AR9170_RX_PHY_RATE_CCK_1M:
+			status->rate_idx = 0;
+			break;
+		case AR9170_RX_PHY_RATE_CCK_2M:
+			status->rate_idx = 1;
+			break;
+		case AR9170_RX_PHY_RATE_CCK_5M:
+			status->rate_idx = 2;
+			break;
+		case AR9170_RX_PHY_RATE_CCK_11M:
+			status->rate_idx = 3;
+			break;
+		default:
+			if (net_ratelimit()) {
+				wiphy_err(ar->hw->wiphy, "invalid plcp cck "
+				       "rate (%x).\n", head->plcp[0]);
+			}
+
+			return -EINVAL;
+		}
+		break;
+
+	case AR9170_RX_STATUS_MODULATION_DUPOFDM:
+	case AR9170_RX_STATUS_MODULATION_OFDM:
+		switch (head->plcp[0] & 0xf) {
+		case AR9170_TXRX_PHY_RATE_OFDM_6M:
+			status->rate_idx = 0;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_9M:
+			status->rate_idx = 1;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_12M:
+			status->rate_idx = 2;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_18M:
+			status->rate_idx = 3;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_24M:
+			status->rate_idx = 4;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_36M:
+			status->rate_idx = 5;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_48M:
+			status->rate_idx = 6;
+			break;
+		case AR9170_TXRX_PHY_RATE_OFDM_54M:
+			status->rate_idx = 7;
+			break;
+		default:
+			if (net_ratelimit()) {
+				wiphy_err(ar->hw->wiphy, "invalid plcp ofdm "
+					"rate (%x).\n", head->plcp[0]);
+			}
+
+			return -EINVAL;
+		}
+		if (status->band == IEEE80211_BAND_2GHZ)
+			status->rate_idx += 4;
+		break;
+
+	case AR9170_RX_STATUS_MODULATION_HT:
+		if (head->plcp[3] & 0x80)
+			status->flag |= RX_FLAG_40MHZ;
+		if (head->plcp[6] & 0x80)
+			status->flag |= RX_FLAG_SHORT_GI;
+
+		status->rate_idx = clamp(0, 75, head->plcp[3] & 0x7f);
+		status->flag |= RX_FLAG_HT;
+		break;
+
+	default:
+		BUG();
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+static void carl9170_rx_phy_status(struct ar9170 *ar,
+	struct ar9170_rx_phystatus *phy, struct ieee80211_rx_status *status)
+{
+	int i;
+
+	BUILD_BUG_ON(sizeof(struct ar9170_rx_phystatus) != 20);
+
+	for (i = 0; i < 3; i++)
+		if (phy->rssi[i] != 0x80)
+			status->antenna |= BIT(i);
+
+	/* post-process RSSI */
+	for (i = 0; i < 7; i++)
+		if (phy->rssi[i] & 0x80)
+			phy->rssi[i] = ((phy->rssi[i] & 0x7f) + 1) & 0x7f;
+
+	/* TODO: we could do something with phy_errors */
+	status->signal = ar->noise[0] + phy->rssi_combined;
+}
+
+static struct sk_buff *carl9170_rx_copy_data(u8 *buf, int len)
+{
+	struct sk_buff *skb;
+	int reserved = 0;
+	struct ieee80211_hdr *hdr = (void *) buf;
+
+	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		u8 *qc = ieee80211_get_qos_ctl(hdr);
+		reserved += NET_IP_ALIGN;
+
+		if (*qc & IEEE80211_QOS_CONTROL_A_MSDU_PRESENT)
+			reserved += NET_IP_ALIGN;
+	}
+
+	if (ieee80211_has_a4(hdr->frame_control))
+		reserved += NET_IP_ALIGN;
+
+	reserved = 32 + (reserved & NET_IP_ALIGN);
+
+	skb = dev_alloc_skb(len + reserved);
+	if (likely(skb)) {
+		skb_reserve(skb, reserved);
+		memcpy(skb_put(skb, len), buf, len);
+	}
+
+	return skb;
+}
+
+static u8 *carl9170_find_ie(u8 *data, unsigned int len, u8 ie)
+{
+	struct ieee80211_mgmt *mgmt = (void *)data;
+	u8 *pos, *end;
+
+	pos = (u8 *)mgmt->u.beacon.variable;
+	end = data + len;
+	while (pos < end) {
+		if (pos + 2 + pos[1] > end)
+			return NULL;
+
+		if (pos[0] == ie)
+			return pos;
+
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
+
+/*
+ * NOTE:
+ *
+ * The firmware is in charge of waking up the device just before
+ * the AP is expected to transmit the next beacon.
+ *
+ * This leaves the driver with the important task of deciding when
+ * to set the PHY back to bed again.
+ */
+static void carl9170_ps_beacon(struct ar9170 *ar, void *data, unsigned int len)
+{
+	struct ieee80211_hdr *hdr = (void *) data;
+	struct ieee80211_tim_ie *tim_ie;
+	u8 *tim;
+	u8 tim_len;
+	bool cam;
+
+	if (likely(!(ar->hw->conf.flags & IEEE80211_CONF_PS)))
+		return;
+
+	/* check if this really is a beacon */
+	if (!ieee80211_is_beacon(hdr->frame_control))
+		return;
+
+	/* min. beacon length + FCS_LEN */
+	if (len <= 40 + FCS_LEN)
+		return;
+
+	/* and only beacons from the associated BSSID, please */
+	if (compare_ether_addr(hdr->addr3, ar->common.curbssid) ||
+	    !ar->common.curaid)
+		return;
+
+	ar->ps.last_beacon = jiffies;
+
+	tim = carl9170_find_ie(data, len - FCS_LEN, WLAN_EID_TIM);
+	if (!tim)
+		return;
+
+	if (tim[1] < sizeof(*tim_ie))
+		return;
+
+	tim_len = tim[1];
+	tim_ie = (struct ieee80211_tim_ie *) &tim[2];
+
+	if (!WARN_ON_ONCE(!ar->hw->conf.ps_dtim_period))
+		ar->ps.dtim_counter = (tim_ie->dtim_count - 1) %
+			ar->hw->conf.ps_dtim_period;
+
+	/* Check whenever the PHY can be turned off again. */
+
+	/* 1. What about buffered unicast traffic for our AID? */
+	cam = ieee80211_check_tim(tim_ie, tim_len, ar->common.curaid);
+
+	/* 2. Maybe the AP wants to send multicast/broadcast data? */
+	cam = !!(tim_ie->bitmap_ctrl & 0x01);
+
+	if (!cam) {
+		/* back to low-power land. */
+		ar->ps.off_override &= ~PS_OFF_BCN;
+		carl9170_ps_check(ar);
+	} else {
+		/* force CAM */
+		ar->ps.off_override |= PS_OFF_BCN;
+	}
+}
+
+static bool carl9170_ampdu_check(struct ar9170 *ar, u8 *buf, u8 ms)
+{
+	__le16 fc;
+
+	if ((ms & AR9170_RX_STATUS_MPDU) == AR9170_RX_STATUS_MPDU_SINGLE) {
+		/*
+		 * This frame is not part of an aMPDU.
+		 * Therefore it is not subjected to any
+		 * of the following content restrictions.
+		 */
+		return true;
+	}
+
+	/*
+	 * "802.11n - 7.4a.3 A-MPDU contents" describes in which contexts
+	 * certain frame types can be part of an aMPDU.
+	 *
+	 * In order to keep the processing cost down, I opted for a
+	 * stateless filter solely based on the frame control field.
+	 */
+
+	fc = ((struct ieee80211_hdr *)buf)->frame_control;
+	if (ieee80211_is_data_qos(fc) && ieee80211_is_data_present(fc))
+		return true;
+
+	if (ieee80211_is_ack(fc) || ieee80211_is_back(fc) ||
+	    ieee80211_is_back_req(fc))
+		return true;
+
+	if (ieee80211_is_action(fc))
+		return true;
+
+	return false;
+}
+
+/*
+ * If the frame alignment is right (or the kernel has
+ * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS), and there
+ * is only a single MPDU in the USB frame, then we could
+ * submit to mac80211 the SKB directly. However, since
+ * there may be multiple packets in one SKB in stream
+ * mode, and we need to observe the proper ordering,
+ * this is non-trivial.
+ */
+
+static void carl9170_handle_mpdu(struct ar9170 *ar, u8 *buf, int len)
+{
+	struct ar9170_rx_head *head;
+	struct ar9170_rx_macstatus *mac;
+	struct ar9170_rx_phystatus *phy = NULL;
+	struct ieee80211_rx_status status;
+	struct sk_buff *skb;
+	int mpdu_len;
+	u8 mac_status;
+
+	if (!IS_STARTED(ar))
+		return;
+
+	if (unlikely(len < sizeof(*mac)))
+		goto drop;
+
+	mpdu_len = len - sizeof(*mac);
+
+	mac = (void *)(buf + mpdu_len);
+	mac_status = mac->status;
+	switch (mac_status & AR9170_RX_STATUS_MPDU) {
+	case AR9170_RX_STATUS_MPDU_FIRST:
+		/* Aggregated MPDUs start with an PLCP header */
+		if (likely(mpdu_len >= sizeof(struct ar9170_rx_head))) {
+			head = (void *) buf;
+
+			/*
+			 * The PLCP header needs to be cached for the
+			 * following MIDDLE + LAST A-MPDU packets.
+			 *
+			 * So, if you are wondering why all frames seem
+			 * to share a common RX status information,
+			 * then you have the answer right here...
+			 */
+			memcpy(&ar->rx_plcp, (void *) buf,
+			       sizeof(struct ar9170_rx_head));
+
+			mpdu_len -= sizeof(struct ar9170_rx_head);
+			buf += sizeof(struct ar9170_rx_head);
+
+			ar->rx_has_plcp = true;
+		} else {
+			if (net_ratelimit()) {
+				wiphy_err(ar->hw->wiphy, "plcp info "
+					"is clipped.\n");
+			}
+
+			goto drop;
+		}
+		break;
+
+	case AR9170_RX_STATUS_MPDU_LAST:
+		/*
+		 * The last frame of an A-MPDU has an extra tail
+		 * which does contain the phy status of the whole
+		 * aggregate.
+		 */
+
+		if (likely(mpdu_len >= sizeof(struct ar9170_rx_phystatus))) {
+			mpdu_len -= sizeof(struct ar9170_rx_phystatus);
+			phy = (void *)(buf + mpdu_len);
+		} else {
+			if (net_ratelimit()) {
+				wiphy_err(ar->hw->wiphy, "frame tail "
+					"is clipped.\n");
+			}
+
+			goto drop;
+		}
+
+	case AR9170_RX_STATUS_MPDU_MIDDLE:
+		/*  These are just data + mac status */
+		if (unlikely(!ar->rx_has_plcp)) {
+			if (!net_ratelimit())
+				return;
+
+			wiphy_err(ar->hw->wiphy, "rx stream does not start "
+					"with a first_mpdu frame tag.\n");
+
+			goto drop;
+		}
+
+		head = &ar->rx_plcp;
+		break;
+
+	case AR9170_RX_STATUS_MPDU_SINGLE:
+		/* single mpdu has both: plcp (head) and phy status (tail) */
+		head = (void *) buf;
+
+		mpdu_len -= sizeof(struct ar9170_rx_head);
+		mpdu_len -= sizeof(struct ar9170_rx_phystatus);
+
+		buf += sizeof(struct ar9170_rx_head);
+		phy = (void *)(buf + mpdu_len);
+		break;
+
+	default:
+		BUG_ON(1);
+		break;
+	}
+
+	/* FC + DU + RA + FCS */
+	if (unlikely(mpdu_len < (2 + 2 + ETH_ALEN + FCS_LEN)))
+		goto drop;
+
+	memset(&status, 0, sizeof(status));
+	if (unlikely(carl9170_rx_mac_status(ar, head, mac, &status)))
+		goto drop;
+
+	if (!carl9170_ampdu_check(ar, buf, mac_status))
+		goto drop;
+
+	if (phy)
+		carl9170_rx_phy_status(ar, phy, &status);
+
+	carl9170_ps_beacon(ar, buf, mpdu_len);
+
+	skb = carl9170_rx_copy_data(buf, mpdu_len);
+	if (!skb)
+		goto drop;
+
+	memcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));
+	ieee80211_rx(ar->hw, skb);
+	return;
+
+drop:
+	ar->rx_dropped++;
+}
+
+static void carl9170_rx_untie_cmds(struct ar9170 *ar, const u8 *respbuf,
+				   const unsigned int resplen)
+{
+	struct carl9170_rsp *cmd;
+	int i = 0;
+
+	while (i < resplen) {
+		cmd = (void *) &respbuf[i];
+
+		i += cmd->hdr.len + 4;
+		if (unlikely(i > resplen))
+			break;
+
+		carl9170_handle_command_response(ar, cmd, cmd->hdr.len + 4);
+	}
+
+	if (unlikely(i != resplen)) {
+		if (!net_ratelimit())
+			return;
+
+		wiphy_err(ar->hw->wiphy, "malformed firmware trap:\n");
+		print_hex_dump_bytes("rxcmd:", DUMP_PREFIX_OFFSET,
+				     respbuf, resplen);
+	}
+}
+
+static void __carl9170_rx(struct ar9170 *ar, u8 *buf, unsigned int len)
+{
+	unsigned int i = 0;
+
+	/* weird thing, but this is the same in the original driver */
+	while (len > 2 && i < 12 && buf[0] == 0xff && buf[1] == 0xff) {
+		i += 2;
+		len -= 2;
+		buf += 2;
+	}
+
+	if (unlikely(len < 4))
+		return;
+
+	/* found the 6 * 0xffff marker? */
+	if (i == 12)
+		carl9170_rx_untie_cmds(ar, buf, len);
+	else
+		carl9170_handle_mpdu(ar, buf, len);
+}
+
+static void carl9170_rx_stream(struct ar9170 *ar, void *buf, unsigned int len)
+{
+	unsigned int tlen, wlen = 0, clen = 0;
+	struct ar9170_stream *rx_stream;
+	u8 *tbuf;
+
+	tbuf = buf;
+	tlen = len;
+
+	while (tlen >= 4) {
+		rx_stream = (void *) tbuf;
+		clen = le16_to_cpu(rx_stream->length);
+		wlen = ALIGN(clen, 4);
+
+		/* check if this is stream has a valid tag.*/
+		if (rx_stream->tag != cpu_to_le16(AR9170_RX_STREAM_TAG)) {
+			/*
+			 * TODO: handle the highly unlikely event that the
+			 * corrupted stream has the TAG at the right position.
+			 */
+
+			/* check if the frame can be repaired. */
+			if (!ar->rx_failover_missing) {
+
+				/* this is not "short read". */
+				if (net_ratelimit()) {
+					wiphy_err(ar->hw->wiphy,
+						"missing tag!\n");
+				}
+
+				__carl9170_rx(ar, tbuf, tlen);
+				return;
+			}
+
+			if (ar->rx_failover_missing > tlen) {
+				if (net_ratelimit()) {
+					wiphy_err(ar->hw->wiphy,
+						"possible multi "
+						"stream corruption!\n");
+					goto err_telluser;
+				} else {
+					goto err_silent;
+				}
+			}
+
+			memcpy(skb_put(ar->rx_failover, tlen), tbuf, tlen);
+			ar->rx_failover_missing -= tlen;
+
+			if (ar->rx_failover_missing <= 0) {
+				/*
+				 * nested carl9170_rx_stream call!
+				 *
+				 * termination is guranteed, even when the
+				 * combined frame also have an element with
+				 * a bad tag.
+				 */
+
+				ar->rx_failover_missing = 0;
+				carl9170_rx_stream(ar, ar->rx_failover->data,
+						   ar->rx_failover->len);
+
+				skb_reset_tail_pointer(ar->rx_failover);
+				skb_trim(ar->rx_failover, 0);
+			}
+
+			return;
+		}
+
+		/* check if stream is clipped */
+		if (wlen > tlen - 4) {
+			if (ar->rx_failover_missing) {
+				/* TODO: handle double stream corruption. */
+				if (net_ratelimit()) {
+					wiphy_err(ar->hw->wiphy, "double rx "
+						"stream corruption!\n");
+					goto err_telluser;
+				} else {
+					goto err_silent;
+				}
+			}
+
+			/*
+			 * save incomplete data set.
+			 * the firmware will resend the missing bits when
+			 * the rx - descriptor comes round again.
+			 */
+
+			memcpy(skb_put(ar->rx_failover, tlen), tbuf, tlen);
+			ar->rx_failover_missing = clen - tlen;
+			return;
+		}
+		__carl9170_rx(ar, rx_stream->payload, clen);
+
+		tbuf += wlen + 4;
+		tlen -= wlen + 4;
+	}
+
+	if (tlen) {
+		if (net_ratelimit()) {
+			wiphy_err(ar->hw->wiphy, "%d bytes of unprocessed "
+				"data left in rx stream!\n", tlen);
+		}
+
+		goto err_telluser;
+	}
+
+	return;
+
+err_telluser:
+	wiphy_err(ar->hw->wiphy, "damaged RX stream data [want:%d, "
+		"data:%d, rx:%d, pending:%d ]\n", clen, wlen, tlen,
+		ar->rx_failover_missing);
+
+	if (ar->rx_failover_missing)
+		print_hex_dump_bytes("rxbuf:", DUMP_PREFIX_OFFSET,
+				     ar->rx_failover->data,
+				     ar->rx_failover->len);
+
+	print_hex_dump_bytes("stream:", DUMP_PREFIX_OFFSET,
+			     buf, len);
+
+	wiphy_err(ar->hw->wiphy, "please check your hardware and cables, if "
+		"you see this message frequently.\n");
+
+err_silent:
+	if (ar->rx_failover_missing) {
+		skb_reset_tail_pointer(ar->rx_failover);
+		skb_trim(ar->rx_failover, 0);
+		ar->rx_failover_missing = 0;
+	}
+}
+
+void carl9170_rx(struct ar9170 *ar, void *buf, unsigned int len)
+{
+	if (ar->fw.rx_stream)
+		carl9170_rx_stream(ar, buf, len);
+	else
+		__carl9170_rx(ar, buf, len);
+}
diff --git a/drivers/net/wireless/ath/carl9170/tx.c b/drivers/net/wireless/ath/carl9170/tx.c
new file mode 100644
index 0000000..9b44714
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/tx.c
@@ -0,0 +1,1324 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * 802.11 xmit & status routines
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <net/mac80211.h>
+#include "carl9170.h"
+#include "hw.h"
+#include "cmd.h"
+
+static inline unsigned int __carl9170_get_queue(struct ar9170 *ar,
+						unsigned int queue)
+{
+	if (unlikely(modparam_noht)) {
+		return queue;
+	} else {
+		/*
+		 * This is just another workaround, until
+		 * someone figures out how to get QoS and
+		 * AMPDU to play nicely together.
+		 */
+
+		return 2;		/* AC_BE */
+	}
+}
+
+static inline unsigned int carl9170_get_queue(struct ar9170 *ar,
+					      struct sk_buff *skb)
+{
+	return __carl9170_get_queue(ar, skb_get_queue_mapping(skb));
+}
+
+static bool is_mem_full(struct ar9170 *ar)
+{
+	return (DIV_ROUND_UP(IEEE80211_MAX_FRAME_LEN, ar->fw.mem_block_size) >
+		atomic_read(&ar->mem_free_blocks));
+}
+
+static void carl9170_tx_accounting(struct ar9170 *ar, struct sk_buff *skb)
+{
+	int queue, i;
+	bool mem_full;
+
+	atomic_inc(&ar->tx_total_queued);
+
+	queue = skb_get_queue_mapping(skb);
+	spin_lock_bh(&ar->tx_stats_lock);
+
+	/*
+	 * The driver has to accept the frame, regardless if the queue is
+	 * full to the brim, or not. We have to do the queuing internally,
+	 * since mac80211 assumes that a driver which can operate with
+	 * aggregated frames does not reject frames for this reason.
+	 */
+	ar->tx_stats[queue].len++;
+	ar->tx_stats[queue].count++;
+
+	mem_full = is_mem_full(ar);
+	for (i = 0; i < ar->hw->queues; i++) {
+		if (mem_full || ar->tx_stats[i].len >= ar->tx_stats[i].limit) {
+			ieee80211_stop_queue(ar->hw, i);
+			ar->queue_stop_timeout[i] = jiffies;
+		}
+	}
+
+	spin_unlock_bh(&ar->tx_stats_lock);
+}
+
+static void carl9170_tx_accounting_free(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *txinfo;
+	int queue;
+
+	txinfo = IEEE80211_SKB_CB(skb);
+	queue = skb_get_queue_mapping(skb);
+
+	spin_lock_bh(&ar->tx_stats_lock);
+
+	ar->tx_stats[queue].len--;
+
+	if (!is_mem_full(ar)) {
+		unsigned int i;
+		for (i = 0; i < ar->hw->queues; i++) {
+			if (ar->tx_stats[i].len >= CARL9170_NUM_TX_LIMIT_SOFT)
+				continue;
+
+			if (ieee80211_queue_stopped(ar->hw, i)) {
+				unsigned long tmp;
+
+				tmp = jiffies - ar->queue_stop_timeout[i];
+				if (tmp > ar->max_queue_stop_timeout[i])
+					ar->max_queue_stop_timeout[i] = tmp;
+			}
+
+			ieee80211_wake_queue(ar->hw, i);
+		}
+	}
+
+	spin_unlock_bh(&ar->tx_stats_lock);
+	if (atomic_dec_and_test(&ar->tx_total_queued))
+		complete(&ar->tx_flush);
+}
+
+static int carl9170_alloc_dev_space(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct _carl9170_tx_superframe *super = (void *) skb->data;
+	unsigned int chunks;
+	int cookie = -1;
+
+	atomic_inc(&ar->mem_allocs);
+
+	chunks = DIV_ROUND_UP(skb->len, ar->fw.mem_block_size);
+	if (unlikely(atomic_sub_return(chunks, &ar->mem_free_blocks) < 0)) {
+		atomic_add(chunks, &ar->mem_free_blocks);
+		return -ENOSPC;
+	}
+
+	spin_lock_bh(&ar->mem_lock);
+	cookie = bitmap_find_free_region(ar->mem_bitmap, ar->fw.mem_blocks, 0);
+	spin_unlock_bh(&ar->mem_lock);
+
+	if (unlikely(cookie < 0)) {
+		atomic_add(chunks, &ar->mem_free_blocks);
+		return -ENOSPC;
+	}
+
+	super = (void *) skb->data;
+
+	/*
+	 * Cookie #0 serves two special purposes:
+	 *  1. The firmware might use it generate BlockACK frames
+	 *     in responds of an incoming BlockAckReqs.
+	 *
+	 *  2. Prevent double-free bugs.
+	 */
+	super->s.cookie = (u8) cookie + 1;
+	return 0;
+}
+
+static void carl9170_release_dev_space(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct _carl9170_tx_superframe *super = (void *) skb->data;
+	int cookie;
+
+	/* make a local copy of the cookie */
+	cookie = super->s.cookie;
+	/* invalidate cookie */
+	super->s.cookie = 0;
+
+	/*
+	 * Do a out-of-bounds check on the cookie:
+	 *
+	 *  * cookie "0" is reserved and won't be assigned to any
+	 *    out-going frame. Internally however, it is used to
+	 *    mark no longer/un-accounted frames and serves as a
+	 *    cheap way of preventing frames from being freed
+	 *    twice by _accident_. NB: There is a tiny race...
+	 *
+	 *  * obviously, cookie number is limited by the amount
+	 *    of available memory blocks, so the number can
+	 *    never execeed the mem_blocks count.
+	 */
+	if (unlikely(WARN_ON_ONCE(cookie == 0) ||
+	    WARN_ON_ONCE(cookie > ar->fw.mem_blocks)))
+		return;
+
+	atomic_add(DIV_ROUND_UP(skb->len, ar->fw.mem_block_size),
+		   &ar->mem_free_blocks);
+
+	spin_lock_bh(&ar->mem_lock);
+	bitmap_release_region(ar->mem_bitmap, cookie - 1, 0);
+	spin_unlock_bh(&ar->mem_lock);
+}
+
+/* Called from any context */
+static void carl9170_tx_release(struct kref *ref)
+{
+	struct ar9170 *ar;
+	struct carl9170_tx_info *arinfo;
+	struct ieee80211_tx_info *txinfo;
+	struct sk_buff *skb;
+
+	arinfo = container_of(ref, struct carl9170_tx_info, ref);
+	txinfo = container_of((void *) arinfo, struct ieee80211_tx_info,
+			      rate_driver_data);
+	skb = container_of((void *) txinfo, struct sk_buff, cb);
+
+	ar = arinfo->ar;
+	if (WARN_ON_ONCE(!ar))
+		return;
+
+	BUILD_BUG_ON(
+	    offsetof(struct ieee80211_tx_info, status.ampdu_ack_len) != 23);
+
+	memset(&txinfo->status.ampdu_ack_len, 0,
+	       sizeof(struct ieee80211_tx_info) -
+	       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));
+
+	if (atomic_read(&ar->tx_total_queued))
+		ar->tx_schedule = true;
+
+	if (txinfo->flags & IEEE80211_TX_CTL_AMPDU) {
+		if (!atomic_read(&ar->tx_ampdu_upload))
+			ar->tx_ampdu_schedule = true;
+
+		if (txinfo->flags & IEEE80211_TX_STAT_AMPDU) {
+			txinfo->status.ampdu_len = txinfo->pad[0];
+			txinfo->status.ampdu_ack_len = txinfo->pad[1];
+			txinfo->pad[0] = txinfo->pad[1] = 0;
+		} else if (txinfo->flags & IEEE80211_TX_STAT_ACK) {
+			/*
+			 * drop redundant tx_status reports:
+			 *
+			 * 1. ampdu_ack_len of the final tx_status does
+			 *    include the feedback of this particular frame.
+			 *
+			 * 2. tx_status_irqsafe only queues up to 128
+			 *    tx feedback reports and discards the rest.
+			 *
+			 * 3. minstrel_ht is picky, it only accepts
+			 *    reports of frames with the TX_STATUS_AMPDU flag.
+			 */
+
+			dev_kfree_skb_any(skb);
+			return;
+		} else {
+			/*
+			 * Frame has failed, but we want to keep it in
+			 * case it was lost due to a power-state
+			 * transition.
+			 */
+		}
+	}
+
+	skb_pull(skb, sizeof(struct _carl9170_tx_superframe));
+	ieee80211_tx_status_irqsafe(ar->hw, skb);
+}
+
+void carl9170_tx_get_skb(struct sk_buff *skb)
+{
+	struct carl9170_tx_info *arinfo = (void *)
+		(IEEE80211_SKB_CB(skb))->rate_driver_data;
+	kref_get(&arinfo->ref);
+}
+
+int carl9170_tx_put_skb(struct sk_buff *skb)
+{
+	struct carl9170_tx_info *arinfo = (void *)
+		(IEEE80211_SKB_CB(skb))->rate_driver_data;
+
+	return kref_put(&arinfo->ref, carl9170_tx_release);
+}
+
+/* Caller must hold the tid_info->lock & rcu_read_lock */
+static void carl9170_tx_shift_bm(struct ar9170 *ar,
+	struct carl9170_sta_tid *tid_info, u16 seq)
+{
+	u16 off;
+
+	off = SEQ_DIFF(seq, tid_info->bsn);
+
+	if (WARN_ON_ONCE(off >= CARL9170_BAW_BITS))
+		return;
+
+	/*
+	 * Sanity check. For each MPDU we set the bit in bitmap and
+	 * clear it once we received the tx_status.
+	 * But if the bit is already cleared then we've been bitten
+	 * by a bug.
+	 */
+	WARN_ON_ONCE(!test_and_clear_bit(off, tid_info->bitmap));
+
+	off = SEQ_DIFF(tid_info->snx, tid_info->bsn);
+	if (WARN_ON_ONCE(off >= CARL9170_BAW_BITS))
+		return;
+
+	if (!bitmap_empty(tid_info->bitmap, off))
+		off = find_first_bit(tid_info->bitmap, off);
+
+	tid_info->bsn += off;
+	tid_info->bsn &= 0x0fff;
+
+	bitmap_shift_right(tid_info->bitmap, tid_info->bitmap,
+			   off, CARL9170_BAW_BITS);
+}
+
+static void carl9170_tx_status_process_ampdu(struct ar9170 *ar,
+	struct sk_buff *skb, struct ieee80211_tx_info *txinfo)
+{
+	struct _carl9170_tx_superframe *super = (void *) skb->data;
+	struct ieee80211_hdr *hdr = (void *) super->frame_data;
+	struct ieee80211_tx_info *tx_info;
+	struct carl9170_tx_info *ar_info;
+	struct carl9170_sta_info *sta_info;
+	struct ieee80211_sta *sta;
+	struct carl9170_sta_tid *tid_info;
+	struct ieee80211_vif *vif;
+	unsigned int vif_id;
+	u8 tid;
+
+	if (!(txinfo->flags & IEEE80211_TX_CTL_AMPDU) ||
+	    txinfo->flags & IEEE80211_TX_CTL_INJECTED)
+		return;
+
+	tx_info = IEEE80211_SKB_CB(skb);
+	ar_info = (void *) tx_info->rate_driver_data;
+
+	vif_id = (super->s.misc & CARL9170_TX_SUPER_MISC_VIF_ID) >>
+		 CARL9170_TX_SUPER_MISC_VIF_ID_S;
+
+	if (WARN_ON_ONCE(vif_id >= AR9170_MAX_VIRTUAL_MAC))
+		return;
+
+	rcu_read_lock();
+	vif = rcu_dereference(ar->vif_priv[vif_id].vif);
+	if (unlikely(!vif))
+		goto out_rcu;
+
+	/*
+	 * Normally we should use wrappers like ieee80211_get_DA to get
+	 * the correct peer ieee80211_sta.
+	 *
+	 * But there is a problem with indirect traffic (broadcasts, or
+	 * data which is designated for other stations) in station mode.
+	 * The frame will be directed to the AP for distribution and not
+	 * to the actual destination.
+	 */
+	sta = ieee80211_find_sta(vif, hdr->addr1);
+	if (unlikely(!sta))
+		goto out_rcu;
+
+	tid = get_tid_h(hdr);
+
+	sta_info = (void *) sta->drv_priv;
+	tid_info = rcu_dereference(sta_info->agg[tid]);
+	if (!tid_info)
+		goto out_rcu;
+
+	spin_lock_bh(&tid_info->lock);
+	if (likely(tid_info->state >= CARL9170_TID_STATE_IDLE))
+		carl9170_tx_shift_bm(ar, tid_info, get_seq_h(hdr));
+
+	if (sta_info->stats[tid].clear) {
+		sta_info->stats[tid].clear = false;
+		sta_info->stats[tid].ampdu_len = 0;
+		sta_info->stats[tid].ampdu_ack_len = 0;
+	}
+
+	sta_info->stats[tid].ampdu_len++;
+	if (txinfo->status.rates[0].count == 1)
+		sta_info->stats[tid].ampdu_ack_len++;
+
+	if (super->f.mac_control & cpu_to_le16(AR9170_TX_MAC_IMM_BA)) {
+		txinfo->pad[0] = sta_info->stats[tid].ampdu_len;
+		txinfo->pad[1] = sta_info->stats[tid].ampdu_ack_len;
+		txinfo->flags |= IEEE80211_TX_STAT_AMPDU;
+		sta_info->stats[tid].clear = true;
+	}
+	spin_unlock_bh(&tid_info->lock);
+
+out_rcu:
+	rcu_read_unlock();
+}
+
+void carl9170_tx_status(struct ar9170 *ar, struct sk_buff *skb,
+			const bool success)
+{
+	struct ieee80211_tx_info *txinfo;
+
+	carl9170_tx_accounting_free(ar, skb);
+
+	txinfo = IEEE80211_SKB_CB(skb);
+
+	if (success)
+		txinfo->flags |= IEEE80211_TX_STAT_ACK;
+	else
+		ar->tx_ack_failures++;
+
+	if (txinfo->flags & IEEE80211_TX_CTL_AMPDU)
+		carl9170_tx_status_process_ampdu(ar, skb, txinfo);
+
+	carl9170_tx_put_skb(skb);
+}
+
+/* This function may be called form any context */
+void carl9170_tx_callback(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);
+
+	atomic_dec(&ar->tx_total_pending);
+
+	if (txinfo->flags & IEEE80211_TX_CTL_AMPDU)
+		atomic_dec(&ar->tx_ampdu_upload);
+
+	if (carl9170_tx_put_skb(skb))
+		tasklet_hi_schedule(&ar->usb_tasklet);
+}
+
+static struct sk_buff *carl9170_get_queued_skb(struct ar9170 *ar, u8 cookie,
+					       struct sk_buff_head *queue)
+{
+	struct sk_buff *skb;
+
+	spin_lock_bh(&queue->lock);
+	skb_queue_walk(queue, skb) {
+		struct _carl9170_tx_superframe *txc = (void *) skb->data;
+
+		if (txc->s.cookie != cookie)
+			continue;
+
+		__skb_unlink(skb, queue);
+		spin_unlock_bh(&queue->lock);
+
+		carl9170_release_dev_space(ar, skb);
+		return skb;
+	}
+	spin_unlock_bh(&queue->lock);
+
+	return NULL;
+}
+
+static void carl9170_tx_fill_rateinfo(struct ar9170 *ar, unsigned int rix,
+	unsigned int tries, struct ieee80211_tx_info *txinfo)
+{
+	unsigned int i;
+
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+		if (txinfo->status.rates[i].idx < 0)
+			break;
+
+		if (i == rix) {
+			txinfo->status.rates[i].count = tries;
+			i++;
+			break;
+		}
+	}
+
+	for (; i < IEEE80211_TX_MAX_RATES; i++) {
+		txinfo->status.rates[i].idx = -1;
+		txinfo->status.rates[i].count = 0;
+	}
+}
+
+static void carl9170_check_queue_stop_timeout(struct ar9170 *ar)
+{
+	int i;
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *txinfo;
+	struct carl9170_tx_info *arinfo;
+	bool restart = false;
+
+	for (i = 0; i < ar->hw->queues; i++) {
+		spin_lock_bh(&ar->tx_status[i].lock);
+
+		skb = skb_peek(&ar->tx_status[i]);
+
+		if (!skb)
+			goto next;
+
+		txinfo = IEEE80211_SKB_CB(skb);
+		arinfo = (void *) txinfo->rate_driver_data;
+
+		if (time_is_before_jiffies(arinfo->timeout +
+		    msecs_to_jiffies(CARL9170_QUEUE_STUCK_TIMEOUT)) == true)
+			restart = true;
+
+next:
+		spin_unlock_bh(&ar->tx_status[i].lock);
+	}
+
+	if (restart) {
+		/*
+		 * At least one queue has been stuck for long enough.
+		 * Give the device a kick and hope it gets back to
+		 * work.
+		 *
+		 * possible reasons may include:
+		 *  - frames got lost/corrupted (bad connection to the device)
+		 *  - stalled rx processing/usb controller hiccups
+		 *  - firmware errors/bugs
+		 *  - every bug you can think of.
+		 *  - all bugs you can't...
+		 *  - ...
+		 */
+		carl9170_restart(ar, CARL9170_RR_STUCK_TX);
+	}
+}
+
+void carl9170_tx_janitor(struct work_struct *work)
+{
+	struct ar9170 *ar = container_of(work, struct ar9170,
+					 tx_janitor.work);
+	if (!IS_STARTED(ar))
+		return;
+
+	ar->tx_janitor_last_run = jiffies;
+
+	carl9170_check_queue_stop_timeout(ar);
+
+	if (!atomic_read(&ar->tx_total_queued))
+		return;
+
+	ieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,
+		msecs_to_jiffies(CARL9170_TX_TIMEOUT));
+}
+
+static void __carl9170_tx_process_status(struct ar9170 *ar,
+	const uint8_t cookie, const uint8_t info)
+{
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *txinfo;
+	struct carl9170_tx_info *arinfo;
+	unsigned int r, t, q;
+	bool success = true;
+
+	q = ar9170_qmap[info & CARL9170_TX_STATUS_QUEUE];
+
+	skb = carl9170_get_queued_skb(ar, cookie, &ar->tx_status[q]);
+	if (!skb) {
+		/*
+		 * We have lost the race to another thread.
+		 */
+
+		return ;
+	}
+
+	txinfo = IEEE80211_SKB_CB(skb);
+	arinfo = (void *) txinfo->rate_driver_data;
+
+	if (!(info & CARL9170_TX_STATUS_SUCCESS))
+		success = false;
+
+	r = (info & CARL9170_TX_STATUS_RIX) >> CARL9170_TX_STATUS_RIX_S;
+	t = (info & CARL9170_TX_STATUS_TRIES) >> CARL9170_TX_STATUS_TRIES_S;
+
+	carl9170_tx_fill_rateinfo(ar, r, t, txinfo);
+	carl9170_tx_status(ar, skb, success);
+}
+
+void carl9170_tx_process_status(struct ar9170 *ar,
+				const struct carl9170_rsp *cmd)
+{
+	unsigned int i;
+
+	for (i = 0;  i < cmd->hdr.ext; i++) {
+		if (WARN_ON(i > ((cmd->hdr.len / 2) + 1))) {
+			print_hex_dump_bytes("UU:", DUMP_PREFIX_NONE,
+					     (void *) cmd, cmd->hdr.len + 4);
+			break;
+		}
+
+		__carl9170_tx_process_status(ar, cmd->_tx_status[i].cookie,
+					     cmd->_tx_status[i].info);
+	}
+}
+
+static __le32 carl9170_tx_physet(struct ar9170 *ar,
+	struct ieee80211_tx_info *info, struct ieee80211_tx_rate *txrate)
+{
+	struct ieee80211_rate *rate = NULL;
+	u32 power, chains;
+	__le32 tmp;
+
+	tmp = cpu_to_le32(0);
+
+	if (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+		tmp |= cpu_to_le32(AR9170_TX_PHY_BW_40MHZ <<
+			AR9170_TX_PHY_BW_S);
+	/* this works because 40 MHz is 2 and dup is 3 */
+	if (txrate->flags & IEEE80211_TX_RC_DUP_DATA)
+		tmp |= cpu_to_le32(AR9170_TX_PHY_BW_40MHZ_DUP <<
+			AR9170_TX_PHY_BW_S);
+
+	if (txrate->flags & IEEE80211_TX_RC_SHORT_GI)
+		tmp |= cpu_to_le32(AR9170_TX_PHY_SHORT_GI);
+
+	if (txrate->flags & IEEE80211_TX_RC_MCS) {
+		u32 r = txrate->idx;
+		u8 *txpower;
+
+		/* heavy clip control */
+		tmp |= cpu_to_le32((r & 0x7) <<
+			AR9170_TX_PHY_TX_HEAVY_CLIP_S);
+
+		if (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) {
+			if (info->band == IEEE80211_BAND_5GHZ)
+				txpower = ar->power_5G_ht40;
+			else
+				txpower = ar->power_2G_ht40;
+		} else {
+			if (info->band == IEEE80211_BAND_5GHZ)
+				txpower = ar->power_5G_ht20;
+			else
+				txpower = ar->power_2G_ht20;
+		}
+
+		power = txpower[r & 7];
+
+		/* +1 dBm for HT40 */
+		if (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+			power += 2;
+
+		r <<= AR9170_TX_PHY_MCS_S;
+		BUG_ON(r & ~AR9170_TX_PHY_MCS);
+
+		tmp |= cpu_to_le32(r & AR9170_TX_PHY_MCS);
+		tmp |= cpu_to_le32(AR9170_TX_PHY_MOD_HT);
+
+		/*
+		 * green field preamble does not work.
+		 *
+		 * if (txrate->flags & IEEE80211_TX_RC_GREEN_FIELD)
+		 * tmp |= cpu_to_le32(AR9170_TX_PHY_GREENFIELD);
+		 */
+	} else {
+		u8 *txpower;
+		u32 mod;
+		u32 phyrate;
+		u8 idx = txrate->idx;
+
+		if (info->band != IEEE80211_BAND_2GHZ) {
+			idx += 4;
+			txpower = ar->power_5G_leg;
+			mod = AR9170_TX_PHY_MOD_OFDM;
+		} else {
+			if (idx < 4) {
+				txpower = ar->power_2G_cck;
+				mod = AR9170_TX_PHY_MOD_CCK;
+			} else {
+				mod = AR9170_TX_PHY_MOD_OFDM;
+				txpower = ar->power_2G_ofdm;
+			}
+		}
+
+		rate = &__carl9170_ratetable[idx];
+
+		phyrate = rate->hw_value & 0xF;
+		power = txpower[(rate->hw_value & 0x30) >> 4];
+		phyrate <<= AR9170_TX_PHY_MCS_S;
+
+		tmp |= cpu_to_le32(mod);
+		tmp |= cpu_to_le32(phyrate);
+
+		/*
+		 * short preamble seems to be broken too.
+		 *
+		 * if (txrate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
+		 *	tmp |= cpu_to_le32(AR9170_TX_PHY_SHORT_PREAMBLE);
+		 */
+	}
+	power <<= AR9170_TX_PHY_TX_PWR_S;
+	power &= AR9170_TX_PHY_TX_PWR;
+	tmp |= cpu_to_le32(power);
+
+	/* set TX chains */
+	if (ar->eeprom.tx_mask == 1) {
+		chains = AR9170_TX_PHY_TXCHAIN_1;
+	} else {
+		chains = AR9170_TX_PHY_TXCHAIN_2;
+
+		/* >= 36M legacy OFDM - use only one chain */
+		if (rate && rate->bitrate >= 360 &&
+		    !(txrate->flags & IEEE80211_TX_RC_MCS))
+			chains = AR9170_TX_PHY_TXCHAIN_1;
+	}
+	tmp |= cpu_to_le32(chains << AR9170_TX_PHY_TXCHAIN_S);
+
+	return tmp;
+}
+
+static bool carl9170_tx_rts_check(struct ar9170 *ar,
+				  struct ieee80211_tx_rate *rate,
+				  bool ampdu, bool multi)
+{
+	switch (ar->erp_mode) {
+	case CARL9170_ERP_AUTO:
+		if (ampdu)
+			break;
+
+	case CARL9170_ERP_MAC80211:
+		if (!(rate->flags & IEEE80211_TX_RC_USE_RTS_CTS))
+			break;
+
+	case CARL9170_ERP_RTS:
+		if (likely(!multi))
+			return true;
+
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool carl9170_tx_cts_check(struct ar9170 *ar,
+				  struct ieee80211_tx_rate *rate)
+{
+	switch (ar->erp_mode) {
+	case CARL9170_ERP_AUTO:
+	case CARL9170_ERP_MAC80211:
+		if (!(rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT))
+			break;
+
+	case CARL9170_ERP_CTS:
+		return true;
+
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static int carl9170_tx_prepare(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr;
+	struct _carl9170_tx_superframe *txc;
+	struct carl9170_vif_info *cvif;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_tx_rate *txrate;
+	struct ieee80211_sta *sta;
+	struct carl9170_tx_info *arinfo;
+	unsigned int hw_queue;
+	int i;
+	__le16 mac_tmp;
+	u16 len;
+	bool ampdu, no_ack;
+
+	BUILD_BUG_ON(sizeof(*arinfo) > sizeof(info->rate_driver_data));
+	BUILD_BUG_ON(sizeof(struct _carl9170_tx_superdesc) !=
+		     CARL9170_TX_SUPERDESC_LEN);
+
+	BUILD_BUG_ON(sizeof(struct _ar9170_tx_hwdesc) !=
+		     AR9170_TX_HWDESC_LEN);
+
+	BUILD_BUG_ON(IEEE80211_TX_MAX_RATES < CARL9170_TX_MAX_RATES);
+
+	BUILD_BUG_ON(AR9170_MAX_VIRTUAL_MAC >
+		((CARL9170_TX_SUPER_MISC_VIF_ID >>
+		 CARL9170_TX_SUPER_MISC_VIF_ID_S) + 1));
+
+	hw_queue = ar9170_qmap[carl9170_get_queue(ar, skb)];
+
+	hdr = (void *)skb->data;
+	info = IEEE80211_SKB_CB(skb);
+	len = skb->len;
+
+	/*
+	 * Note: If the frame was sent through a monitor interface,
+	 * the ieee80211_vif pointer can be NULL.
+	 */
+	if (likely(info->control.vif))
+		cvif = (void *) info->control.vif->drv_priv;
+	else
+		cvif = NULL;
+
+	sta = info->control.sta;
+
+	txc = (void *)skb_push(skb, sizeof(*txc));
+	memset(txc, 0, sizeof(*txc));
+
+	SET_VAL(CARL9170_TX_SUPER_MISC_QUEUE, txc->s.misc, hw_queue);
+
+	if (likely(cvif))
+		SET_VAL(CARL9170_TX_SUPER_MISC_VIF_ID, txc->s.misc, cvif->id);
+
+	if (unlikely(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM))
+		txc->s.misc |= CARL9170_TX_SUPER_MISC_CAB;
+
+	if (unlikely(ieee80211_is_probe_resp(hdr->frame_control)))
+		txc->s.misc |= CARL9170_TX_SUPER_MISC_FILL_IN_TSF;
+
+	mac_tmp = cpu_to_le16(AR9170_TX_MAC_HW_DURATION |
+			      AR9170_TX_MAC_BACKOFF);
+	mac_tmp |= cpu_to_le16((hw_queue << AR9170_TX_MAC_QOS_S) &&
+			       AR9170_TX_MAC_QOS);
+
+	no_ack = !!(info->flags & IEEE80211_TX_CTL_NO_ACK);
+	if (unlikely(no_ack))
+		mac_tmp |= cpu_to_le16(AR9170_TX_MAC_NO_ACK);
+
+	if (info->control.hw_key) {
+		len += info->control.hw_key->icv_len;
+
+		WARN_ON(1);
+		goto err_out;
+	}
+
+	ampdu = !!(info->flags & IEEE80211_TX_CTL_AMPDU);
+	if (ampdu) {
+		unsigned int density, factor;
+
+		if (unlikely(!sta || !cvif))
+			goto err_out;
+
+		factor = min_t(unsigned int, 1u,
+			 info->control.sta->ht_cap.ampdu_factor);
+
+		density = info->control.sta->ht_cap.ampdu_density;
+
+		if (density) {
+			/*
+			 * Watch out!
+			 *
+			 * Otus uses slightly different density values than
+			 * those from the 802.11n spec.
+			 */
+
+			density = max_t(unsigned int, density + 1, 7u);
+		}
+
+		SET_VAL(CARL9170_TX_SUPER_AMPDU_DENSITY,
+			txc->s.ampdu_settings, density);
+
+		SET_VAL(CARL9170_TX_SUPER_AMPDU_FACTOR,
+			txc->s.ampdu_settings, factor);
+
+		for (i = 0; i < CARL9170_TX_MAX_RATES; i++) {
+			txrate = &info->control.rates[i];
+			if (txrate->idx >= 0) {
+				txc->s.ri[i] =
+					CARL9170_TX_SUPER_RI_AMPDU;
+
+				if (WARN_ON(!(txrate->flags &
+					      IEEE80211_TX_RC_MCS))) {
+					/*
+					 * Not sure if it's even possible
+					 * to aggregate non-ht rates with
+					 * this HW.
+					 */
+					goto err_out;
+				}
+				continue;
+			}
+
+			txrate->idx = 0;
+			txrate->count = ar->hw->max_rate_tries;
+		}
+
+		mac_tmp |= cpu_to_le16(AR9170_TX_MAC_AGGR);
+	}
+
+	/*
+	 * NOTE: For the first rate, the ERP & AMPDU flags are directly
+	 * taken from mac_control. For all fallback rate, the firmware
+	 * updates the mac_control flags from the rate info field.
+	 */
+	for (i = 1; i < CARL9170_TX_MAX_RATES; i++) {
+		txrate = &info->control.rates[i];
+		if (txrate->idx < 0)
+			break;
+
+		SET_VAL(CARL9170_TX_SUPER_RI_TRIES, txc->s.ri[i],
+			txrate->count);
+
+		if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
+			txc->s.ri[i] |= (AR9170_TX_MAC_PROT_RTS <<
+				CARL9170_TX_SUPER_RI_ERP_PROT_S);
+		else if (carl9170_tx_cts_check(ar, txrate))
+			txc->s.ri[i] |= (AR9170_TX_MAC_PROT_CTS <<
+				CARL9170_TX_SUPER_RI_ERP_PROT_S);
+
+		txc->s.rr[i - 1] = carl9170_tx_physet(ar, info, txrate);
+	}
+
+	txrate = &info->control.rates[0];
+	SET_VAL(CARL9170_TX_SUPER_RI_TRIES, txc->s.ri[0], txrate->count);
+
+	if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
+		mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_RTS);
+	else if (carl9170_tx_cts_check(ar, txrate))
+		mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_CTS);
+
+	txc->s.len = cpu_to_le16(skb->len);
+	txc->f.length = cpu_to_le16(len + FCS_LEN);
+	txc->f.mac_control = mac_tmp;
+	txc->f.phy_control = carl9170_tx_physet(ar, info, txrate);
+
+	arinfo = (void *)info->rate_driver_data;
+	arinfo->timeout = jiffies;
+	arinfo->ar = ar;
+	kref_init(&arinfo->ref);
+	return 0;
+
+err_out:
+	skb_pull(skb, sizeof(*txc));
+	return -EINVAL;
+}
+
+static void carl9170_set_immba(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct _carl9170_tx_superframe *super;
+
+	super = (void *) skb->data;
+	super->f.mac_control |= cpu_to_le16(AR9170_TX_MAC_IMM_BA);
+}
+
+static void carl9170_set_ampdu_params(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct _carl9170_tx_superframe *super;
+	int tmp;
+
+	super = (void *) skb->data;
+
+	tmp = (super->s.ampdu_settings & CARL9170_TX_SUPER_AMPDU_DENSITY) <<
+		CARL9170_TX_SUPER_AMPDU_DENSITY_S;
+
+	/*
+	 * If you haven't noticed carl9170_tx_prepare has already filled
+	 * in all ampdu spacing & factor parameters.
+	 * Now it's the time to check whenever the settings have to be
+	 * updated by the firmware, or if everything is still the same.
+	 *
+	 * There's no sane way to handle different density values with
+	 * this hardware, so we may as well just do the compare in the
+	 * driver.
+	 */
+
+	if (tmp != ar->current_density) {
+		ar->current_density = tmp;
+		super->s.ampdu_settings |=
+			CARL9170_TX_SUPER_AMPDU_COMMIT_DENSITY;
+	}
+
+	tmp = (super->s.ampdu_settings & CARL9170_TX_SUPER_AMPDU_FACTOR) <<
+		CARL9170_TX_SUPER_AMPDU_FACTOR_S;
+
+	if (tmp != ar->current_factor) {
+		ar->current_factor = tmp;
+		super->s.ampdu_settings |=
+			CARL9170_TX_SUPER_AMPDU_COMMIT_FACTOR;
+	}
+}
+
+static bool carl9170_tx_rate_check(struct ar9170 *ar, struct sk_buff *_dest,
+				   struct sk_buff *_src)
+{
+	struct _carl9170_tx_superframe *dest, *src;
+
+	dest = (void *) _dest->data;
+	src = (void *) _src->data;
+
+	/*
+	 * The mac80211 rate control algorithm expects that all MPDUs in
+	 * an AMPDU share the same tx vectors.
+	 * This is not really obvious right now, because the hardware
+	 * does the AMPDU setup according to its own rulebook.
+	 * Our nicely assembled, strictly monotonic increasing mpdu
+	 * chains will be broken up, mashed back together...
+	 */
+
+	return (dest->f.phy_control == src->f.phy_control);
+}
+
+static void carl9170_tx_ampdu(struct ar9170 *ar)
+{
+	struct sk_buff_head agg;
+	struct carl9170_sta_tid *tid_info;
+	struct sk_buff *skb, *first;
+	unsigned int i = 0, done_ampdus = 0;
+	u16 seq, queue, tmpssn;
+
+	atomic_inc(&ar->tx_ampdu_scheduler);
+	ar->tx_ampdu_schedule = false;
+
+	if (atomic_read(&ar->tx_ampdu_upload))
+		return;
+
+	if (!ar->tx_ampdu_list_len)
+		return;
+
+	__skb_queue_head_init(&agg);
+
+	rcu_read_lock();
+	tid_info = rcu_dereference(ar->tx_ampdu_iter);
+	if (WARN_ON_ONCE(!tid_info)) {
+		rcu_read_unlock();
+		return;
+	}
+
+retry:
+	list_for_each_entry_continue_rcu(tid_info, &ar->tx_ampdu_list, list) {
+		i++;
+
+		if (tid_info->state < CARL9170_TID_STATE_PROGRESS)
+			continue;
+
+		queue = TID_TO_WME_AC(tid_info->tid);
+
+		spin_lock_bh(&tid_info->lock);
+		if (tid_info->state != CARL9170_TID_STATE_XMIT)
+			goto processed;
+
+		tid_info->counter++;
+		first = skb_peek(&tid_info->queue);
+		tmpssn = carl9170_get_seq(first);
+		seq = tid_info->snx;
+
+		if (unlikely(tmpssn != seq)) {
+			tid_info->state = CARL9170_TID_STATE_IDLE;
+
+			goto processed;
+		}
+
+		while ((skb = skb_peek(&tid_info->queue))) {
+			/* strict 0, 1, ..., n - 1, n frame sequence order */
+			if (unlikely(carl9170_get_seq(skb) != seq))
+				break;
+
+			/* don't upload more than AMPDU FACTOR allows. */
+			if (unlikely(SEQ_DIFF(tid_info->snx, tid_info->bsn) >=
+			    (tid_info->max - 1)))
+				break;
+
+			if (!carl9170_tx_rate_check(ar, skb, first))
+				break;
+
+			atomic_inc(&ar->tx_ampdu_upload);
+			tid_info->snx = seq = SEQ_NEXT(seq);
+			__skb_unlink(skb, &tid_info->queue);
+
+			__skb_queue_tail(&agg, skb);
+
+			if (skb_queue_len(&agg) >= CARL9170_NUM_TX_AGG_MAX)
+				break;
+		}
+
+		if (skb_queue_empty(&tid_info->queue) ||
+		    carl9170_get_seq(skb_peek(&tid_info->queue)) !=
+		    tid_info->snx) {
+			/*
+			 * stop TID, if A-MPDU frames are still missing,
+			 * or whenever the queue is empty.
+			 */
+
+			tid_info->state = CARL9170_TID_STATE_IDLE;
+		}
+		done_ampdus++;
+
+processed:
+		spin_unlock_bh(&tid_info->lock);
+
+		if (skb_queue_empty(&agg))
+			continue;
+
+		/* apply ampdu spacing & factor settings */
+		carl9170_set_ampdu_params(ar, skb_peek(&agg));
+
+		/* set aggregation push bit */
+		carl9170_set_immba(ar, skb_peek_tail(&agg));
+
+		spin_lock_bh(&ar->tx_pending[queue].lock);
+		skb_queue_splice_tail_init(&agg, &ar->tx_pending[queue]);
+		spin_unlock_bh(&ar->tx_pending[queue].lock);
+		ar->tx_schedule = true;
+	}
+	if ((done_ampdus++ == 0) && (i++ == 0))
+		goto retry;
+
+	rcu_assign_pointer(ar->tx_ampdu_iter, tid_info);
+	rcu_read_unlock();
+}
+
+static struct sk_buff *carl9170_tx_pick_skb(struct ar9170 *ar,
+					    struct sk_buff_head *queue)
+{
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *info;
+	struct carl9170_tx_info *arinfo;
+
+	BUILD_BUG_ON(sizeof(*arinfo) > sizeof(info->rate_driver_data));
+
+	spin_lock_bh(&queue->lock);
+	skb = skb_peek(queue);
+	if (unlikely(!skb))
+		goto err_unlock;
+
+	if (carl9170_alloc_dev_space(ar, skb))
+		goto err_unlock;
+
+	__skb_unlink(skb, queue);
+	spin_unlock_bh(&queue->lock);
+
+	info = IEEE80211_SKB_CB(skb);
+	arinfo = (void *) info->rate_driver_data;
+
+	arinfo->timeout = jiffies;
+
+	/*
+	 * increase ref count to "2".
+	 * Ref counting is the easiest way to solve the race between
+	 * the the urb's completion routine: carl9170_tx_callback and
+	 * wlan tx status functions: carl9170_tx_status/janitor.
+	 */
+	carl9170_tx_get_skb(skb);
+
+	return skb;
+
+err_unlock:
+	spin_unlock_bh(&queue->lock);
+	return NULL;
+}
+
+void carl9170_tx_drop(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct _carl9170_tx_superframe *super;
+	uint8_t q = 0;
+
+	ar->tx_dropped++;
+
+	super = (void *)skb->data;
+	SET_VAL(CARL9170_TX_SUPER_MISC_QUEUE, q,
+		ar9170_qmap[carl9170_get_queue(ar, skb)]);
+	__carl9170_tx_process_status(ar, super->s.cookie, q);
+}
+
+static void carl9170_tx(struct ar9170 *ar)
+{
+	struct sk_buff *skb;
+	unsigned int i, q;
+	bool schedule_garbagecollector = false;
+
+	ar->tx_schedule = false;
+
+	if (unlikely(!IS_STARTED(ar)))
+		return;
+
+	carl9170_usb_handle_tx_err(ar);
+
+	for (i = 0; i < ar->hw->queues; i++) {
+		while (!skb_queue_empty(&ar->tx_pending[i])) {
+			skb = carl9170_tx_pick_skb(ar, &ar->tx_pending[i]);
+			if (unlikely(!skb))
+				break;
+
+			atomic_inc(&ar->tx_total_pending);
+
+			q = __carl9170_get_queue(ar, i);
+			/*
+			 * NB: tx_status[i] vs. tx_status[q],
+			 * TODO: Move into pick_skb or alloc_dev_space.
+			 */
+			skb_queue_tail(&ar->tx_status[q], skb);
+
+			carl9170_usb_tx(ar, skb);
+			schedule_garbagecollector = true;
+		}
+	}
+
+	if (!schedule_garbagecollector)
+		return;
+
+	ieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,
+		msecs_to_jiffies(CARL9170_TX_TIMEOUT));
+}
+
+static bool carl9170_tx_ampdu_queue(struct ar9170 *ar,
+	struct ieee80211_sta *sta, struct sk_buff *skb)
+{
+	struct carl9170_sta_info *sta_info;
+	struct carl9170_sta_tid *agg;
+	struct sk_buff *iter;
+	unsigned int max;
+	u16 tid, seq, qseq, off;
+	bool run = false;
+
+	tid = carl9170_get_tid(skb);
+	seq = carl9170_get_seq(skb);
+	sta_info = (void *) sta->drv_priv;
+
+	rcu_read_lock();
+	agg = rcu_dereference(sta_info->agg[tid]);
+	max = sta_info->ampdu_max_len;
+
+	if (!agg)
+		goto err_unlock_rcu;
+
+	spin_lock_bh(&agg->lock);
+	if (unlikely(agg->state < CARL9170_TID_STATE_IDLE))
+		goto err_unlock;
+
+	/* check if sequence is within the BA window */
+	if (unlikely(!BAW_WITHIN(agg->bsn, CARL9170_BAW_BITS, seq)))
+		goto err_unlock;
+
+	if (WARN_ON_ONCE(!BAW_WITHIN(agg->snx, CARL9170_BAW_BITS, seq)))
+		goto err_unlock;
+
+	off = SEQ_DIFF(seq, agg->bsn);
+	if (WARN_ON_ONCE(test_and_set_bit(off, agg->bitmap)))
+		goto err_unlock;
+
+	if (likely(BAW_WITHIN(agg->hsn, CARL9170_BAW_BITS, seq))) {
+		__skb_queue_tail(&agg->queue, skb);
+		agg->hsn = seq;
+		goto queued;
+	}
+
+	skb_queue_reverse_walk(&agg->queue, iter) {
+		qseq = carl9170_get_seq(iter);
+
+		if (BAW_WITHIN(qseq, CARL9170_BAW_BITS, seq)) {
+			__skb_queue_after(&agg->queue, iter, skb);
+			goto queued;
+		}
+	}
+
+	__skb_queue_head(&agg->queue, skb);
+queued:
+
+	if (unlikely(agg->state != CARL9170_TID_STATE_XMIT)) {
+		if (agg->snx == carl9170_get_seq(skb_peek(&agg->queue))) {
+			agg->state = CARL9170_TID_STATE_XMIT;
+			run = true;
+		}
+	}
+
+	spin_unlock_bh(&agg->lock);
+	rcu_read_unlock();
+
+	return run;
+
+err_unlock:
+	spin_unlock_bh(&agg->lock);
+
+err_unlock_rcu:
+	rcu_read_unlock();
+	carl9170_tx_status(ar, skb, false);
+	ar->tx_dropped++;
+	return false;
+}
+
+int carl9170_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct ar9170 *ar = hw->priv;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_sta *sta;
+	bool run;
+
+	if (unlikely(!IS_STARTED(ar)))
+		goto err_free;
+
+	info = IEEE80211_SKB_CB(skb);
+	sta = info->control.sta;
+
+	if (unlikely(carl9170_tx_prepare(ar, skb)))
+		goto err_free;
+
+	carl9170_tx_accounting(ar, skb);
+	/*
+	 * from now on, one has to use carl9170_tx_status to free
+	 * all ressouces which are associated with the frame.
+	 */
+
+	if (info->flags & IEEE80211_TX_CTL_AMPDU) {
+		if (WARN_ON_ONCE(!sta))
+			goto err_free;
+
+		run = carl9170_tx_ampdu_queue(ar, sta, skb);
+		if (run)
+			carl9170_tx_ampdu(ar);
+
+	} else {
+		unsigned int queue = skb_get_queue_mapping(skb);
+
+		skb_queue_tail(&ar->tx_pending[queue], skb);
+	}
+
+	carl9170_tx(ar);
+	return NETDEV_TX_OK;
+
+err_free:
+	ar->tx_dropped++;
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+void carl9170_tx_scheduler(struct ar9170 *ar)
+{
+
+	if (ar->tx_ampdu_schedule)
+		carl9170_tx_ampdu(ar);
+
+	if (ar->tx_schedule)
+		carl9170_tx(ar);
+}
diff --git a/drivers/net/wireless/ath/carl9170/usb.c b/drivers/net/wireless/ath/carl9170/usb.c
new file mode 100644
index 0000000..c7f6193
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/usb.c
@@ -0,0 +1,1136 @@
+/*
+ * Atheros CARL9170 driver
+ *
+ * USB - frontend
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/firmware.h>
+#include <linux/etherdevice.h>
+#include <linux/device.h>
+#include <net/mac80211.h>
+#include "carl9170.h"
+#include "cmd.h"
+#include "hw.h"
+#include "fwcmd.h"
+
+MODULE_AUTHOR("Johannes Berg <johannes@sipsolutions.net>");
+MODULE_AUTHOR("Christian Lamparter <chunkeey@googlemail.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Atheros AR9170 802.11n USB wireless");
+MODULE_FIRMWARE(CARL9170FW_NAME);
+MODULE_ALIAS("ar9170usb");
+MODULE_ALIAS("arusb_lnx");
+
+/*
+ * Note:
+ *
+ * Always update our wiki's device list (located at:
+ * http://wireless.kernel.org/en/users/Drivers/ar9170/devices ),
+ * whenever you add a new device.
+ */
+static struct usb_device_id carl9170_usb_ids[] = {
+	/* Atheros 9170 */
+	{ USB_DEVICE(0x0cf3, 0x9170) },
+	/* Atheros TG121N */
+	{ USB_DEVICE(0x0cf3, 0x1001) },
+	/* TP-Link TL-WN821N v2 */
+	{ USB_DEVICE(0x0cf3, 0x1002), .driver_info = CARL9170_WPS_BUTTON |
+		 CARL9170_ONE_LED },
+	/* 3Com Dual Band 802.11n USB Adapter */
+	{ USB_DEVICE(0x0cf3, 0x1010) },
+	/* H3C Dual Band 802.11n USB Adapter */
+	{ USB_DEVICE(0x0cf3, 0x1011) },
+	/* Cace Airpcap NX */
+	{ USB_DEVICE(0xcace, 0x0300) },
+	/* D-Link DWA 160 A1 */
+	{ USB_DEVICE(0x07d1, 0x3c10) },
+	/* D-Link DWA 160 A2 */
+	{ USB_DEVICE(0x07d1, 0x3a09) },
+	/* Netgear WNA1000 */
+	{ USB_DEVICE(0x0846, 0x9040) },
+	/* Netgear WNDA3100 */
+	{ USB_DEVICE(0x0846, 0x9010) },
+	/* Netgear WN111 v2 */
+	{ USB_DEVICE(0x0846, 0x9001), .driver_info = CARL9170_ONE_LED },
+	/* Zydas ZD1221 */
+	{ USB_DEVICE(0x0ace, 0x1221) },
+	/* Proxim ORiNOCO 802.11n USB */
+	{ USB_DEVICE(0x1435, 0x0804) },
+	/* WNC Generic 11n USB Dongle */
+	{ USB_DEVICE(0x1435, 0x0326) },
+	/* ZyXEL NWD271N */
+	{ USB_DEVICE(0x0586, 0x3417) },
+	/* Z-Com UB81 BG */
+	{ USB_DEVICE(0x0cde, 0x0023) },
+	/* Z-Com UB82 ABG */
+	{ USB_DEVICE(0x0cde, 0x0026) },
+	/* Sphairon Homelink 1202 */
+	{ USB_DEVICE(0x0cde, 0x0027) },
+	/* Arcadyan WN7512 */
+	{ USB_DEVICE(0x083a, 0xf522) },
+	/* Planex GWUS300 */
+	{ USB_DEVICE(0x2019, 0x5304) },
+	/* IO-Data WNGDNUS2 */
+	{ USB_DEVICE(0x04bb, 0x093f) },
+	/* NEC WL300NU-G */
+	{ USB_DEVICE(0x0409, 0x0249) },
+	/* AVM FRITZ!WLAN USB Stick N */
+	{ USB_DEVICE(0x057c, 0x8401) },
+	/* AVM FRITZ!WLAN USB Stick N 2.4 */
+	{ USB_DEVICE(0x057c, 0x8402) },
+	/* Qwest/Actiontec 802AIN Wireless N USB Network Adapter */
+	{ USB_DEVICE(0x1668, 0x1200) },
+
+	/* terminate */
+	{}
+};
+MODULE_DEVICE_TABLE(usb, carl9170_usb_ids);
+
+static void carl9170_usb_submit_data_urb(struct ar9170 *ar)
+{
+	struct urb *urb;
+	int err;
+
+	if (atomic_inc_return(&ar->tx_anch_urbs) > AR9170_NUM_TX_URBS)
+		goto err_acc;
+
+	urb = usb_get_from_anchor(&ar->tx_wait);
+	if (!urb)
+		goto err_acc;
+
+	usb_anchor_urb(urb, &ar->tx_anch);
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (unlikely(err)) {
+		if (net_ratelimit()) {
+			dev_err(&ar->udev->dev, "tx submit failed (%d)\n",
+				urb->status);
+		}
+
+		usb_unanchor_urb(urb);
+		usb_anchor_urb(urb, &ar->tx_err);
+	}
+
+	usb_free_urb(urb);
+
+	if (likely(err == 0))
+		return;
+
+err_acc:
+	atomic_dec(&ar->tx_anch_urbs);
+}
+
+static void carl9170_usb_tx_data_complete(struct urb *urb)
+{
+	struct ar9170 *ar = (struct ar9170 *)
+	      usb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));
+
+	if (WARN_ON_ONCE(!ar)) {
+		dev_kfree_skb_irq(urb->context);
+		return;
+	}
+
+	atomic_dec(&ar->tx_anch_urbs);
+
+	switch (urb->status) {
+	/* everything is fine */
+	case 0:
+		carl9170_tx_callback(ar, (void *)urb->context);
+		break;
+
+	/* disconnect */
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		/*
+		 * Defer the frame clean-up to the tasklet worker.
+		 * This is necessary, because carl9170_tx_drop
+		 * does not work in an irqsave context.
+		 */
+		usb_anchor_urb(urb, &ar->tx_err);
+		return;
+
+	/* a random transmission error has occurred? */
+	default:
+		if (net_ratelimit()) {
+			dev_err(&ar->udev->dev, "tx failed (%d)\n",
+				urb->status);
+		}
+
+		usb_anchor_urb(urb, &ar->tx_err);
+		break;
+	}
+
+	if (likely(IS_STARTED(ar)))
+		carl9170_usb_submit_data_urb(ar);
+}
+
+static int carl9170_usb_submit_cmd_urb(struct ar9170 *ar)
+{
+	struct urb *urb;
+	int err;
+
+	if (atomic_inc_return(&ar->tx_cmd_urbs) != 1) {
+		atomic_dec(&ar->tx_cmd_urbs);
+		return 0;
+	}
+
+	urb = usb_get_from_anchor(&ar->tx_cmd);
+	if (!urb) {
+		atomic_dec(&ar->tx_cmd_urbs);
+		return 0;
+	}
+
+	usb_anchor_urb(urb, &ar->tx_anch);
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (unlikely(err)) {
+		usb_unanchor_urb(urb);
+		atomic_dec(&ar->tx_cmd_urbs);
+	}
+	usb_free_urb(urb);
+
+	return err;
+}
+
+static void carl9170_usb_cmd_complete(struct urb *urb)
+{
+	struct ar9170 *ar = urb->context;
+	int err = 0;
+
+	if (WARN_ON_ONCE(!ar))
+		return;
+
+	atomic_dec(&ar->tx_cmd_urbs);
+
+	switch (urb->status) {
+	/* everything is fine */
+	case 0:
+		break;
+
+	/* disconnect */
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		return;
+
+	default:
+		err = urb->status;
+		break;
+	}
+
+	if (!IS_INITIALIZED(ar))
+		return;
+
+	if (err)
+		dev_err(&ar->udev->dev, "submit cmd cb failed (%d).\n", err);
+
+	err = carl9170_usb_submit_cmd_urb(ar);
+	if (err)
+		dev_err(&ar->udev->dev, "submit cmd failed (%d).\n", err);
+}
+
+static void carl9170_usb_rx_irq_complete(struct urb *urb)
+{
+	struct ar9170 *ar = urb->context;
+
+	if (WARN_ON_ONCE(!ar))
+		return;
+
+	switch (urb->status) {
+	/* everything is fine */
+	case 0:
+		break;
+
+	/* disconnect */
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		return;
+
+	default:
+		goto resubmit;
+	}
+
+	carl9170_handle_command_response(ar, urb->transfer_buffer,
+					 urb->actual_length);
+
+resubmit:
+	usb_anchor_urb(urb, &ar->rx_anch);
+	if (unlikely(usb_submit_urb(urb, GFP_ATOMIC)))
+		usb_unanchor_urb(urb);
+}
+
+static int carl9170_usb_submit_rx_urb(struct ar9170 *ar, gfp_t gfp)
+{
+	struct urb *urb;
+	int err = 0, runs = 0;
+
+	while ((atomic_read(&ar->rx_anch_urbs) < AR9170_NUM_RX_URBS) &&
+		(runs++ < AR9170_NUM_RX_URBS)) {
+		err = -ENOSPC;
+		urb = usb_get_from_anchor(&ar->rx_pool);
+		if (urb) {
+			usb_anchor_urb(urb, &ar->rx_anch);
+			err = usb_submit_urb(urb, gfp);
+			if (unlikely(err)) {
+				usb_unanchor_urb(urb);
+				usb_anchor_urb(urb, &ar->rx_pool);
+			} else {
+				atomic_dec(&ar->rx_pool_urbs);
+				atomic_inc(&ar->rx_anch_urbs);
+			}
+			usb_free_urb(urb);
+		}
+	}
+
+	return err;
+}
+
+static void carl9170_usb_rx_work(struct ar9170 *ar)
+{
+	struct urb *urb;
+	int i;
+
+	for (i = 0; i < AR9170_NUM_RX_URBS_POOL; i++) {
+		urb = usb_get_from_anchor(&ar->rx_work);
+		if (!urb)
+			break;
+
+		atomic_dec(&ar->rx_work_urbs);
+		if (IS_INITIALIZED(ar)) {
+			carl9170_rx(ar, urb->transfer_buffer,
+				    urb->actual_length);
+		}
+
+		usb_anchor_urb(urb, &ar->rx_pool);
+		atomic_inc(&ar->rx_pool_urbs);
+
+		usb_free_urb(urb);
+
+		carl9170_usb_submit_rx_urb(ar, GFP_ATOMIC);
+	}
+}
+
+void carl9170_usb_handle_tx_err(struct ar9170 *ar)
+{
+	struct urb *urb;
+
+	while ((urb = usb_get_from_anchor(&ar->tx_err))) {
+		struct sk_buff *skb = (void *)urb->context;
+
+		carl9170_tx_drop(ar, skb);
+		carl9170_tx_callback(ar, skb);
+		usb_free_urb(urb);
+	}
+}
+
+static void carl9170_usb_tasklet(unsigned long data)
+{
+	struct ar9170 *ar = (struct ar9170 *) data;
+
+	if (!IS_INITIALIZED(ar))
+		return;
+
+	carl9170_usb_rx_work(ar);
+
+	/*
+	 * Strictly speaking: The tx scheduler is not part of the USB system.
+	 * But the rx worker returns frames back to the mac80211-stack and
+	 * this is the _perfect_ place to generate the next transmissions.
+	 */
+	if (IS_STARTED(ar))
+		carl9170_tx_scheduler(ar);
+}
+
+static void carl9170_usb_rx_complete(struct urb *urb)
+{
+	struct ar9170 *ar = (struct ar9170 *)urb->context;
+	int err;
+
+	if (WARN_ON_ONCE(!ar))
+		return;
+
+	atomic_dec(&ar->rx_anch_urbs);
+
+	switch (urb->status) {
+	case 0:
+		/* rx path */
+		usb_anchor_urb(urb, &ar->rx_work);
+		atomic_inc(&ar->rx_work_urbs);
+		break;
+
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ENODEV:
+	case -ESHUTDOWN:
+		/* handle disconnect events*/
+		return;
+
+	default:
+		/* handle all other errors */
+		usb_anchor_urb(urb, &ar->rx_pool);
+		atomic_inc(&ar->rx_pool_urbs);
+		break;
+	}
+
+	err = carl9170_usb_submit_rx_urb(ar, GFP_ATOMIC);
+	if (unlikely(err)) {
+		/*
+		 * usb_submit_rx_urb reported a problem.
+		 * In case this is due to a rx buffer shortage,
+		 * elevate the tasklet worker priority to
+		 * the highest available level.
+		 */
+		tasklet_hi_schedule(&ar->usb_tasklet);
+
+		if (atomic_read(&ar->rx_anch_urbs) == 0) {
+			/*
+			 * The system is too slow to cope with
+			 * the enormous workload. We have simply
+			 * run out of active rx urbs and this
+			 * unfortunatly leads to an unpredictable
+			 * device.
+			 */
+
+			carl9170_restart(ar, CARL9170_RR_SLOW_SYSTEM);
+		}
+	} else {
+		/*
+		 * Using anything less than _high_ priority absolutely
+		 * kills the rx performance my UP-System...
+		 */
+		tasklet_hi_schedule(&ar->usb_tasklet);
+	}
+}
+
+static struct urb *carl9170_usb_alloc_rx_urb(struct ar9170 *ar, gfp_t gfp)
+{
+	struct urb *urb;
+	void *buf;
+
+	buf = kmalloc(ar->fw.rx_size, gfp);
+	if (!buf)
+		return NULL;
+
+	urb = usb_alloc_urb(0, gfp);
+	if (!urb) {
+		kfree(buf);
+		return NULL;
+	}
+
+	usb_fill_bulk_urb(urb, ar->udev, usb_rcvbulkpipe(ar->udev,
+			  AR9170_USB_EP_RX), buf, ar->fw.rx_size,
+			  carl9170_usb_rx_complete, ar);
+
+	urb->transfer_flags |= URB_FREE_BUFFER;
+
+	return urb;
+}
+
+static int carl9170_usb_send_rx_irq_urb(struct ar9170 *ar)
+{
+	struct urb *urb = NULL;
+	void *ibuf;
+	int err = -ENOMEM;
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		goto out;
+
+	ibuf = kmalloc(AR9170_USB_EP_CTRL_MAX, GFP_KERNEL);
+	if (!ibuf)
+		goto out;
+
+	usb_fill_int_urb(urb, ar->udev, usb_rcvintpipe(ar->udev,
+			 AR9170_USB_EP_IRQ), ibuf, AR9170_USB_EP_CTRL_MAX,
+			 carl9170_usb_rx_irq_complete, ar, 1);
+
+	urb->transfer_flags |= URB_FREE_BUFFER;
+
+	usb_anchor_urb(urb, &ar->rx_anch);
+	err = usb_submit_urb(urb, GFP_KERNEL);
+	if (err)
+		usb_unanchor_urb(urb);
+
+out:
+	usb_free_urb(urb);
+	return err;
+}
+
+static int carl9170_usb_init_rx_bulk_urbs(struct ar9170 *ar)
+{
+	struct urb *urb;
+	int i, err = -EINVAL;
+
+	/*
+	 * The driver actively maintains a second shadow
+	 * pool for inactive, but fully-prepared rx urbs.
+	 *
+	 * The pool should help the driver to master huge
+	 * workload spikes without running the risk of
+	 * undersupplying the hardware or wasting time by
+	 * processing rx data (streams) inside the urb
+	 * completion (hardirq context).
+	 */
+	for (i = 0; i < AR9170_NUM_RX_URBS_POOL; i++) {
+		urb = carl9170_usb_alloc_rx_urb(ar, GFP_KERNEL);
+		if (!urb) {
+			err = -ENOMEM;
+			goto err_out;
+		}
+
+		usb_anchor_urb(urb, &ar->rx_pool);
+		atomic_inc(&ar->rx_pool_urbs);
+		usb_free_urb(urb);
+	}
+
+	err = carl9170_usb_submit_rx_urb(ar, GFP_KERNEL);
+	if (err)
+		goto err_out;
+
+	/* the device now waiting for the firmware. */
+	carl9170_set_state_when(ar, CARL9170_STOPPED, CARL9170_IDLE);
+	return 0;
+
+err_out:
+
+	usb_scuttle_anchored_urbs(&ar->rx_pool);
+	usb_scuttle_anchored_urbs(&ar->rx_work);
+	usb_kill_anchored_urbs(&ar->rx_anch);
+	return err;
+}
+
+static int carl9170_usb_flush(struct ar9170 *ar)
+{
+	struct urb *urb;
+	int ret, err = 0;
+
+	while ((urb = usb_get_from_anchor(&ar->tx_wait))) {
+		struct sk_buff *skb = (void *)urb->context;
+		carl9170_tx_drop(ar, skb);
+		carl9170_tx_callback(ar, skb);
+		usb_free_urb(urb);
+	}
+
+	ret = usb_wait_anchor_empty_timeout(&ar->tx_cmd, HZ);
+	if (ret == 0)
+		err = -ETIMEDOUT;
+
+	/* lets wait a while until the tx - queues are dried out */
+	ret = usb_wait_anchor_empty_timeout(&ar->tx_anch, HZ);
+	if (ret == 0)
+		err = -ETIMEDOUT;
+
+	usb_kill_anchored_urbs(&ar->tx_anch);
+	carl9170_usb_handle_tx_err(ar);
+
+	return err;
+}
+
+static void carl9170_usb_cancel_urbs(struct ar9170 *ar)
+{
+	int err;
+
+	carl9170_set_state(ar, CARL9170_UNKNOWN_STATE);
+
+	err = carl9170_usb_flush(ar);
+	if (err)
+		dev_err(&ar->udev->dev, "stuck tx urbs!\n");
+
+	usb_poison_anchored_urbs(&ar->tx_anch);
+	carl9170_usb_handle_tx_err(ar);
+	usb_poison_anchored_urbs(&ar->rx_anch);
+
+	tasklet_kill(&ar->usb_tasklet);
+
+	usb_scuttle_anchored_urbs(&ar->rx_work);
+	usb_scuttle_anchored_urbs(&ar->rx_pool);
+	usb_scuttle_anchored_urbs(&ar->tx_cmd);
+}
+
+int __carl9170_exec_cmd(struct ar9170 *ar, struct carl9170_cmd *cmd,
+			const bool free_buf)
+{
+	struct urb *urb;
+
+	if (!IS_INITIALIZED(ar))
+		return -EPERM;
+
+	if (WARN_ON(cmd->hdr.len > CARL9170_MAX_CMD_LEN - 4))
+		return -EINVAL;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb)
+		return -ENOMEM;
+
+	usb_fill_int_urb(urb, ar->udev, usb_sndintpipe(ar->udev,
+		AR9170_USB_EP_CMD), cmd, cmd->hdr.len + 4,
+		carl9170_usb_cmd_complete, ar, 1);
+
+	if (free_buf)
+		urb->transfer_flags |= URB_FREE_BUFFER;
+
+	usb_anchor_urb(urb, &ar->tx_cmd);
+	usb_free_urb(urb);
+
+	return carl9170_usb_submit_cmd_urb(ar);
+}
+
+int carl9170_exec_cmd(struct ar9170 *ar, const enum carl9170_cmd_oids cmd,
+	unsigned int plen, void *payload, unsigned int outlen, void *out)
+{
+	int err = -ENOMEM;
+
+	if (!IS_ACCEPTING_CMD(ar))
+		return -EIO;
+
+	if (!(cmd & CARL9170_CMD_ASYNC_FLAG))
+		might_sleep();
+
+	ar->cmd.hdr.len = plen;
+	ar->cmd.hdr.cmd = cmd;
+	/* writing multiple regs fills this buffer already */
+	if (plen && payload != (u8 *)(ar->cmd.data))
+		memcpy(ar->cmd.data, payload, plen);
+
+	spin_lock_bh(&ar->cmd_lock);
+	ar->readbuf = (u8 *)out;
+	ar->readlen = outlen;
+	spin_unlock_bh(&ar->cmd_lock);
+
+	err = __carl9170_exec_cmd(ar, &ar->cmd, false);
+
+	if (!(cmd & CARL9170_CMD_ASYNC_FLAG)) {
+		err = wait_for_completion_timeout(&ar->cmd_wait, HZ);
+		if (err == 0) {
+			err = -ETIMEDOUT;
+			goto err_unbuf;
+		}
+
+		if (ar->readlen != outlen) {
+			err = -EMSGSIZE;
+			goto err_unbuf;
+		}
+	}
+
+	return 0;
+
+err_unbuf:
+	/* Maybe the device was removed in the moment we were waiting? */
+	if (IS_STARTED(ar)) {
+		dev_err(&ar->udev->dev, "no command feedback "
+			"received (%d).\n", err);
+
+		/* provide some maybe useful debug information */
+		print_hex_dump_bytes("carl9170 cmd: ", DUMP_PREFIX_NONE,
+				     &ar->cmd, plen + 4);
+
+		carl9170_restart(ar, CARL9170_RR_COMMAND_TIMEOUT);
+	}
+
+	/* invalidate to avoid completing the next command prematurely */
+	spin_lock_bh(&ar->cmd_lock);
+	ar->readbuf = NULL;
+	ar->readlen = 0;
+	spin_unlock_bh(&ar->cmd_lock);
+
+	return err;
+}
+
+void carl9170_usb_tx(struct ar9170 *ar, struct sk_buff *skb)
+{
+	struct urb *urb;
+	struct ar9170_stream *tx_stream;
+	void *data;
+	unsigned int len;
+
+	if (!IS_STARTED(ar))
+		goto err_drop;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb)
+		goto err_drop;
+
+	if (ar->fw.tx_stream) {
+		tx_stream = (void *) (skb->data - sizeof(*tx_stream));
+
+		len = skb->len + sizeof(*tx_stream);
+		tx_stream->length = cpu_to_le16(len);
+		tx_stream->tag = cpu_to_le16(AR9170_TX_STREAM_TAG);
+		data = tx_stream;
+	} else {
+		data = skb->data;
+		len = skb->len;
+	}
+
+	usb_fill_bulk_urb(urb, ar->udev, usb_sndbulkpipe(ar->udev,
+		AR9170_USB_EP_TX), data, len,
+		carl9170_usb_tx_data_complete, skb);
+
+	urb->transfer_flags |= URB_ZERO_PACKET;
+
+	usb_anchor_urb(urb, &ar->tx_wait);
+
+	usb_free_urb(urb);
+
+	carl9170_usb_submit_data_urb(ar);
+	return;
+
+err_drop:
+	carl9170_tx_drop(ar, skb);
+	carl9170_tx_callback(ar, skb);
+}
+
+static void carl9170_release_firmware(struct ar9170 *ar)
+{
+	if (ar->fw.fw) {
+		release_firmware(ar->fw.fw);
+		memset(&ar->fw, 0, sizeof(ar->fw));
+	}
+}
+
+void carl9170_usb_stop(struct ar9170 *ar)
+{
+	int ret;
+
+	carl9170_set_state_when(ar, CARL9170_IDLE, CARL9170_STOPPED);
+
+	ret = carl9170_usb_flush(ar);
+	if (ret)
+		dev_err(&ar->udev->dev, "kill pending tx urbs.\n");
+
+	usb_poison_anchored_urbs(&ar->tx_anch);
+	carl9170_usb_handle_tx_err(ar);
+
+	/* kill any pending command */
+	spin_lock_bh(&ar->cmd_lock);
+	ar->readlen = 0;
+	spin_unlock_bh(&ar->cmd_lock);
+	complete_all(&ar->cmd_wait);
+
+	/* This is required to prevent an early completion on _start */
+	INIT_COMPLETION(ar->cmd_wait);
+
+	/*
+	 * Note:
+	 * So far we freed all tx urbs, but we won't dare to touch any rx urbs.
+	 * Else we would end up with a unresponsive device...
+	 */
+}
+
+int carl9170_usb_open(struct ar9170 *ar)
+{
+	usb_unpoison_anchored_urbs(&ar->tx_anch);
+
+	carl9170_set_state_when(ar, CARL9170_STOPPED, CARL9170_IDLE);
+	return 0;
+}
+
+static int carl9170_usb_load_firmware(struct ar9170 *ar)
+{
+	const u8 *data;
+	u8 *buf;
+	unsigned int transfer;
+	size_t len;
+	u32 addr;
+	int err = 0;
+
+	buf = kmalloc(4096, GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	data = ar->fw.fw->data;
+	len = ar->fw.fw->size;
+	addr = ar->fw.address;
+
+	/* this removes the miniboot image */
+	data += ar->fw.offset;
+	len -= ar->fw.offset;
+
+	while (len) {
+		transfer = min_t(unsigned int, len, 4096u);
+		memcpy(buf, data, transfer);
+
+		err = usb_control_msg(ar->udev, usb_sndctrlpipe(ar->udev, 0),
+				      0x30 /* FW DL */, 0x40 | USB_DIR_OUT,
+				      addr >> 8, 0, buf, transfer, 100);
+
+		if (err < 0) {
+			kfree(buf);
+			goto err_out;
+		}
+
+		len -= transfer;
+		data += transfer;
+		addr += transfer;
+	}
+	kfree(buf);
+
+	err = usb_control_msg(ar->udev, usb_sndctrlpipe(ar->udev, 0),
+			      0x31 /* FW DL COMPLETE */,
+			      0x40 | USB_DIR_OUT, 0, 0, NULL, 0, 200);
+
+	if (wait_for_completion_timeout(&ar->fw_boot_wait, HZ) == 0) {
+		err = -ETIMEDOUT;
+		goto err_out;
+	}
+
+	err = carl9170_echo_test(ar, 0x4a110123);
+	if (err)
+		goto err_out;
+
+	/* firmware restarts cmd counter */
+	ar->cmd_seq = -1;
+
+	return 0;
+
+err_out:
+	dev_err(&ar->udev->dev, "firmware upload failed (%d).\n", err);
+	return err;
+}
+
+int carl9170_usb_restart(struct ar9170 *ar)
+{
+	int err = 0;
+
+	if (ar->intf->condition != USB_INTERFACE_BOUND)
+		return 0;
+
+	/* Disable command response sequence counter. */
+	ar->cmd_seq = -2;
+
+	err = carl9170_reboot(ar);
+
+	carl9170_usb_stop(ar);
+
+	if (err)
+		goto err_out;
+
+	tasklet_schedule(&ar->usb_tasklet);
+
+	/* The reboot procedure can take quite a while to complete. */
+	msleep(1100);
+
+	err = carl9170_usb_open(ar);
+	if (err)
+		goto err_out;
+
+	err = carl9170_usb_load_firmware(ar);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	carl9170_usb_cancel_urbs(ar);
+	return err;
+}
+
+void carl9170_usb_reset(struct ar9170 *ar)
+{
+	/*
+	 * This is the last resort to get the device going again
+	 * without any *user replugging action*.
+	 *
+	 * But there is a catch: usb_reset really is like a physical
+	 * *reconnect*. The mac80211 state will be lost in the process.
+	 * Therefore a userspace application, which is monitoring
+	 * the link must step in.
+	 */
+	carl9170_usb_cancel_urbs(ar);
+
+	carl9170_usb_stop(ar);
+
+	usb_queue_reset_device(ar->intf);
+}
+
+static int carl9170_usb_init_device(struct ar9170 *ar)
+{
+	int err;
+
+	err = carl9170_usb_send_rx_irq_urb(ar);
+	if (err)
+		goto err_out;
+
+	err = carl9170_usb_init_rx_bulk_urbs(ar);
+	if (err)
+		goto err_unrx;
+
+	mutex_lock(&ar->mutex);
+	err = carl9170_usb_load_firmware(ar);
+	mutex_unlock(&ar->mutex);
+	if (err)
+		goto err_unrx;
+
+	return 0;
+
+err_unrx:
+	carl9170_usb_cancel_urbs(ar);
+
+err_out:
+	return err;
+}
+
+static void carl9170_usb_firmware_failed(struct ar9170 *ar)
+{
+	struct device *parent = ar->udev->dev.parent;
+	struct usb_device *udev;
+
+	/*
+	 * Store a copy of the usb_device pointer locally.
+	 * This is because device_release_driver initiates
+	 * carl9170_usb_disconnect, which in turn frees our
+	 * driver context (ar).
+	 */
+	udev = ar->udev;
+
+	complete(&ar->fw_load_wait);
+
+	/* unbind anything failed */
+	if (parent)
+		device_lock(parent);
+
+	device_release_driver(&udev->dev);
+	if (parent)
+		device_unlock(parent);
+
+	usb_put_dev(udev);
+}
+
+static void carl9170_usb_firmware_finish(struct ar9170 *ar)
+{
+	int err;
+
+	err = carl9170_parse_firmware(ar);
+	if (err)
+		goto err_freefw;
+
+	err = carl9170_usb_init_device(ar);
+	if (err)
+		goto err_freefw;
+
+	err = carl9170_usb_open(ar);
+	if (err)
+		goto err_unrx;
+
+	err = carl9170_register(ar);
+
+	carl9170_usb_stop(ar);
+	if (err)
+		goto err_unrx;
+
+	complete(&ar->fw_load_wait);
+	usb_put_dev(ar->udev);
+	return;
+
+err_unrx:
+	carl9170_usb_cancel_urbs(ar);
+
+err_freefw:
+	carl9170_release_firmware(ar);
+	carl9170_usb_firmware_failed(ar);
+}
+
+static void carl9170_usb_firmware_step2(const struct firmware *fw,
+					void *context)
+{
+	struct ar9170 *ar = context;
+
+	if (fw) {
+		ar->fw.fw = fw;
+		carl9170_usb_firmware_finish(ar);
+		return;
+	}
+
+	dev_err(&ar->udev->dev, "firmware not found.\n");
+	carl9170_usb_firmware_failed(ar);
+}
+
+static int carl9170_usb_probe(struct usb_interface *intf,
+			      const struct usb_device_id *id)
+{
+	struct ar9170 *ar;
+	struct usb_device *udev;
+	int err;
+
+	err = usb_reset_device(interface_to_usbdev(intf));
+	if (err)
+		return err;
+
+	ar = carl9170_alloc(sizeof(*ar));
+	if (IS_ERR(ar))
+		return PTR_ERR(ar);
+
+	udev = interface_to_usbdev(intf);
+	usb_get_dev(udev);
+	ar->udev = udev;
+	ar->intf = intf;
+	ar->features = id->driver_info;
+
+	usb_set_intfdata(intf, ar);
+	SET_IEEE80211_DEV(ar->hw, &intf->dev);
+
+	init_usb_anchor(&ar->rx_anch);
+	init_usb_anchor(&ar->rx_pool);
+	init_usb_anchor(&ar->rx_work);
+	init_usb_anchor(&ar->tx_wait);
+	init_usb_anchor(&ar->tx_anch);
+	init_usb_anchor(&ar->tx_cmd);
+	init_usb_anchor(&ar->tx_err);
+	init_completion(&ar->cmd_wait);
+	init_completion(&ar->fw_boot_wait);
+	init_completion(&ar->fw_load_wait);
+	tasklet_init(&ar->usb_tasklet, carl9170_usb_tasklet,
+		     (unsigned long)ar);
+
+	atomic_set(&ar->tx_cmd_urbs, 0);
+	atomic_set(&ar->tx_anch_urbs, 0);
+	atomic_set(&ar->rx_work_urbs, 0);
+	atomic_set(&ar->rx_anch_urbs, 0);
+	atomic_set(&ar->rx_pool_urbs, 0);
+	ar->cmd_seq = -2;
+
+	usb_get_dev(ar->udev);
+
+	carl9170_set_state(ar, CARL9170_STOPPED);
+
+	return request_firmware_nowait(THIS_MODULE, 1, CARL9170FW_NAME,
+		&ar->udev->dev, GFP_KERNEL, ar, carl9170_usb_firmware_step2);
+}
+
+static void carl9170_usb_disconnect(struct usb_interface *intf)
+{
+	struct ar9170 *ar = usb_get_intfdata(intf);
+	struct usb_device *udev;
+
+	if (WARN_ON(!ar))
+		return;
+
+	udev = ar->udev;
+	wait_for_completion(&ar->fw_load_wait);
+
+	if (IS_INITIALIZED(ar)) {
+		carl9170_reboot(ar);
+		carl9170_usb_stop(ar);
+	}
+
+	carl9170_usb_cancel_urbs(ar);
+	carl9170_unregister(ar);
+
+	usb_set_intfdata(intf, NULL);
+
+	carl9170_release_firmware(ar);
+	carl9170_free(ar);
+	usb_put_dev(udev);
+}
+
+#ifdef CONFIG_PM
+static int carl9170_usb_suspend(struct usb_interface *intf,
+				pm_message_t message)
+{
+	struct ar9170 *ar = usb_get_intfdata(intf);
+
+	if (!ar)
+		return -ENODEV;
+
+	carl9170_usb_cancel_urbs(ar);
+
+	/*
+	 * firmware automatically reboots for usb suspend.
+	 */
+
+	return 0;
+}
+
+static int carl9170_usb_resume(struct usb_interface *intf)
+{
+	struct ar9170 *ar = usb_get_intfdata(intf);
+	int err;
+
+	if (!ar)
+		return -ENODEV;
+
+	usb_unpoison_anchored_urbs(&ar->rx_anch);
+
+	err = carl9170_usb_init_device(ar);
+	if (err)
+		goto err_unrx;
+
+	err = carl9170_usb_open(ar);
+	if (err)
+		goto err_unrx;
+
+	return 0;
+
+err_unrx:
+	carl9170_usb_cancel_urbs(ar);
+
+	return err;
+}
+#endif /* CONFIG_PM */
+
+static struct usb_driver carl9170_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = carl9170_usb_probe,
+	.disconnect = carl9170_usb_disconnect,
+	.id_table = carl9170_usb_ids,
+	.soft_unbind = 1,
+#ifdef CONFIG_PM
+	.suspend = carl9170_usb_suspend,
+	.resume = carl9170_usb_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init carl9170_usb_init(void)
+{
+	return usb_register(&carl9170_driver);
+}
+
+static void __exit carl9170_usb_exit(void)
+{
+	usb_deregister(&carl9170_driver);
+}
+
+module_init(carl9170_usb_init);
+module_exit(carl9170_usb_exit);
diff --git a/drivers/net/wireless/ath/carl9170/version.h b/drivers/net/wireless/ath/carl9170/version.h
new file mode 100644
index 0000000..ff53f07
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/version.h
@@ -0,0 +1,7 @@
+#ifndef __CARL9170_SHARED_VERSION_H
+#define __CARL9170_SHARED_VERSION_H
+#define CARL9170FW_VERSION_YEAR 10
+#define CARL9170FW_VERSION_MONTH 9
+#define CARL9170FW_VERSION_DAY 28
+#define CARL9170FW_VERSION_GIT "1.8.8.3"
+#endif /* __CARL9170_SHARED_VERSION_H */
diff --git a/drivers/net/wireless/ath/carl9170/wlan.h b/drivers/net/wireless/ath/carl9170/wlan.h
new file mode 100644
index 0000000..2c5c7eb
--- /dev/null
+++ b/drivers/net/wireless/ath/carl9170/wlan.h
@@ -0,0 +1,425 @@
+/*
+ * Shared Atheros AR9170 Header
+ *
+ * RX/TX meta descriptor format
+ *
+ * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2009, 2010, Christian Lamparter <chunkeey@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, see
+ * http://www.gnu.org/licenses/.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *    Copyright (c) 2007-2008 Atheros Communications, Inc.
+ *
+ *    Permission to use, copy, modify, and/or distribute this software for any
+ *    purpose with or without fee is hereby granted, provided that the above
+ *    copyright notice and this permission notice appear in all copies.
+ *
+ *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __CARL9170_SHARED_WLAN_H
+#define __CARL9170_SHARED_WLAN_H
+
+#include "fwcmd.h"
+
+#define	AR9170_RX_PHY_RATE_CCK_1M		0x0a
+#define	AR9170_RX_PHY_RATE_CCK_2M		0x14
+#define	AR9170_RX_PHY_RATE_CCK_5M		0x37
+#define	AR9170_RX_PHY_RATE_CCK_11M		0x6e
+
+#define	AR9170_ENC_ALG_NONE			0x0
+#define	AR9170_ENC_ALG_WEP64			0x1
+#define	AR9170_ENC_ALG_TKIP			0x2
+#define	AR9170_ENC_ALG_AESCCMP			0x4
+#define	AR9170_ENC_ALG_WEP128			0x5
+#define	AR9170_ENC_ALG_WEP256			0x6
+#define	AR9170_ENC_ALG_CENC			0x7
+
+#define	AR9170_RX_ENC_SOFTWARE			0x8
+
+#define	AR9170_RX_STATUS_MODULATION		0x03
+#define	AR9170_RX_STATUS_MODULATION_S		0
+#define	AR9170_RX_STATUS_MODULATION_CCK		0x00
+#define	AR9170_RX_STATUS_MODULATION_OFDM	0x01
+#define	AR9170_RX_STATUS_MODULATION_HT		0x02
+#define	AR9170_RX_STATUS_MODULATION_DUPOFDM	0x03
+
+/* depends on modulation */
+#define	AR9170_RX_STATUS_SHORT_PREAMBLE		0x08
+#define	AR9170_RX_STATUS_GREENFIELD		0x08
+
+#define	AR9170_RX_STATUS_MPDU			0x30
+#define	AR9170_RX_STATUS_MPDU_S			4
+#define	AR9170_RX_STATUS_MPDU_SINGLE		0x00
+#define	AR9170_RX_STATUS_MPDU_FIRST		0x20
+#define	AR9170_RX_STATUS_MPDU_MIDDLE		0x30
+#define	AR9170_RX_STATUS_MPDU_LAST		0x10
+
+#define	AR9170_RX_STATUS_CONT_AGGR		0x40
+#define	AR9170_RX_STATUS_TOTAL_ERROR		0x80
+
+#define	AR9170_RX_ERROR_RXTO			0x01
+#define	AR9170_RX_ERROR_OVERRUN			0x02
+#define	AR9170_RX_ERROR_DECRYPT			0x04
+#define	AR9170_RX_ERROR_FCS			0x08
+#define	AR9170_RX_ERROR_WRONG_RA		0x10
+#define	AR9170_RX_ERROR_PLCP			0x20
+#define	AR9170_RX_ERROR_MMIC			0x40
+
+/* these are either-or */
+#define	AR9170_TX_MAC_PROT_RTS			0x0001
+#define	AR9170_TX_MAC_PROT_CTS			0x0002
+#define	AR9170_TX_MAC_PROT			0x0003
+
+#define	AR9170_TX_MAC_NO_ACK			0x0004
+/* if unset, MAC will only do SIFS space before frame */
+#define	AR9170_TX_MAC_BACKOFF			0x0008
+#define	AR9170_TX_MAC_BURST			0x0010
+#define	AR9170_TX_MAC_AGGR			0x0020
+
+/* encryption is a two-bit field */
+#define	AR9170_TX_MAC_ENCR_NONE			0x0000
+#define	AR9170_TX_MAC_ENCR_RC4			0x0040
+#define	AR9170_TX_MAC_ENCR_CENC			0x0080
+#define	AR9170_TX_MAC_ENCR_AES			0x00c0
+
+#define	AR9170_TX_MAC_MMIC			0x0100
+#define	AR9170_TX_MAC_HW_DURATION		0x0200
+#define	AR9170_TX_MAC_QOS_S			10
+#define	AR9170_TX_MAC_QOS			0x0c00
+#define	AR9170_TX_MAC_DISABLE_TXOP		0x1000
+#define	AR9170_TX_MAC_TXOP_RIFS			0x2000
+#define	AR9170_TX_MAC_IMM_BA			0x4000
+
+/* either-or */
+#define	AR9170_TX_PHY_MOD_CCK			0x00000000
+#define	AR9170_TX_PHY_MOD_OFDM			0x00000001
+#define	AR9170_TX_PHY_MOD_HT			0x00000002
+
+/* depends on modulation */
+#define	AR9170_TX_PHY_SHORT_PREAMBLE		0x00000004
+#define	AR9170_TX_PHY_GREENFIELD		0x00000004
+
+#define	AR9170_TX_PHY_BW_S			3
+#define	AR9170_TX_PHY_BW			(3 << AR9170_TX_PHY_BW_SHIFT)
+#define	AR9170_TX_PHY_BW_20MHZ			0
+#define	AR9170_TX_PHY_BW_40MHZ			2
+#define	AR9170_TX_PHY_BW_40MHZ_DUP		3
+
+#define	AR9170_TX_PHY_TX_HEAVY_CLIP_S		6
+#define	AR9170_TX_PHY_TX_HEAVY_CLIP		(7 << \
+						 AR9170_TX_PHY_TX_HEAVY_CLIP_S)
+
+#define	AR9170_TX_PHY_TX_PWR_S			9
+#define	AR9170_TX_PHY_TX_PWR			(0x3f << \
+						 AR9170_TX_PHY_TX_PWR_S)
+
+#define	AR9170_TX_PHY_TXCHAIN_S			15
+#define	AR9170_TX_PHY_TXCHAIN			(7 << \
+						 AR9170_TX_PHY_TXCHAIN_S)
+#define	AR9170_TX_PHY_TXCHAIN_1			1
+/* use for cck, ofdm 6/9/12/18/24 and HT if capable */
+#define	AR9170_TX_PHY_TXCHAIN_2			5
+
+#define	AR9170_TX_PHY_MCS_S			18
+#define	AR9170_TX_PHY_MCS			(0x7f << \
+						 AR9170_TX_PHY_MCS_S)
+
+#define	AR9170_TX_PHY_RATE_CCK_1M		0x0
+#define	AR9170_TX_PHY_RATE_CCK_2M		0x1
+#define	AR9170_TX_PHY_RATE_CCK_5M		0x2
+#define	AR9170_TX_PHY_RATE_CCK_11M		0x3
+
+/* same as AR9170_RX_PHY_RATE */
+#define	AR9170_TXRX_PHY_RATE_OFDM_6M		0xb
+#define	AR9170_TXRX_PHY_RATE_OFDM_9M		0xf
+#define	AR9170_TXRX_PHY_RATE_OFDM_12M		0xa
+#define	AR9170_TXRX_PHY_RATE_OFDM_18M		0xe
+#define	AR9170_TXRX_PHY_RATE_OFDM_24M		0x9
+#define	AR9170_TXRX_PHY_RATE_OFDM_36M		0xd
+#define	AR9170_TXRX_PHY_RATE_OFDM_48M		0x8
+#define	AR9170_TXRX_PHY_RATE_OFDM_54M		0xc
+
+#define	AR9170_TXRX_PHY_RATE_HT_MCS0		0x0
+#define	AR9170_TXRX_PHY_RATE_HT_MCS1		0x1
+#define	AR9170_TXRX_PHY_RATE_HT_MCS2		0x2
+#define	AR9170_TXRX_PHY_RATE_HT_MCS3		0x3
+#define	AR9170_TXRX_PHY_RATE_HT_MCS4		0x4
+#define	AR9170_TXRX_PHY_RATE_HT_MCS5		0x5
+#define	AR9170_TXRX_PHY_RATE_HT_MCS6		0x6
+#define	AR9170_TXRX_PHY_RATE_HT_MCS7		0x7
+#define	AR9170_TXRX_PHY_RATE_HT_MCS8		0x8
+#define	AR9170_TXRX_PHY_RATE_HT_MCS9		0x9
+#define	AR9170_TXRX_PHY_RATE_HT_MCS10		0xa
+#define	AR9170_TXRX_PHY_RATE_HT_MCS11		0xb
+#define	AR9170_TXRX_PHY_RATE_HT_MCS12		0xc
+#define	AR9170_TXRX_PHY_RATE_HT_MCS13		0xd
+#define	AR9170_TXRX_PHY_RATE_HT_MCS14		0xe
+#define	AR9170_TXRX_PHY_RATE_HT_MCS15		0xf
+
+#define	AR9170_TX_PHY_SHORT_GI			0x80000000
+
+#ifdef __CARL9170FW__
+struct ar9170_tx_hw_mac_control {
+	union {
+		struct {
+			/*
+			 * Beware of compiler bugs in all gcc pre 4.4!
+			 */
+
+			u8 erp_prot:2;
+			u8 no_ack:1;
+			u8 backoff:1;
+			u8 burst:1;
+			u8 ampdu:1;
+
+			u8 enc_mode:2;
+
+			u8 hw_mmic:1;
+			u8 hw_duration:1;
+
+			u8 qos_queue:2;
+
+			u8 disable_txop:1;
+			u8 txop_rifs:1;
+
+			u8 ba_end:1;
+			u8 probe:1;
+		} __packed;
+
+		__le16 set;
+	} __packed;
+} __packed;
+
+struct ar9170_tx_hw_phy_control {
+	union {
+		struct {
+			/*
+			 * Beware of compiler bugs in all gcc pre 4.4!
+			 */
+
+			u8 modulation:2;
+			u8 preamble:1;
+			u8 bandwidth:2;
+			u8:1;
+			u8 heavy_clip:3;
+			u8 tx_power:6;
+			u8 chains:3;
+			u8 mcs:7;
+			u8:6;
+			u8 short_gi:1;
+		} __packed;
+
+		__le32 set;
+	} __packed;
+} __packed;
+
+struct ar9170_tx_rate_info {
+	u8 tries:3;
+	u8 erp_prot:2;
+	u8 ampdu:1;
+	u8 free:2; /* free for use (e.g.:RIFS/TXOP/AMPDU) */
+} __packed;
+
+struct carl9170_tx_superdesc {
+	__le16 len;
+	u8 rix;
+	u8 cnt;
+	u8 cookie;
+	u8 ampdu_density:3;
+	u8 ampdu_factor:2;
+	u8 ampdu_commit_density:1;
+	u8 ampdu_commit_factor:1;
+	u8 ampdu_unused_bit:1;
+	u8 queue:2;
+	u8 reserved:1;
+	u8 vif_id:3;
+	u8 fill_in_tsf:1;
+	u8 cab:1;
+	u8 padding2;
+	struct ar9170_tx_rate_info ri[CARL9170_TX_MAX_RATES];
+	struct ar9170_tx_hw_phy_control rr[CARL9170_TX_MAX_RETRY_RATES];
+} __packed;
+
+struct ar9170_tx_hwdesc {
+	__le16 length;
+	struct ar9170_tx_hw_mac_control mac;
+	struct ar9170_tx_hw_phy_control phy;
+} __packed;
+
+struct ar9170_tx_frame {
+	struct ar9170_tx_hwdesc hdr;
+
+	union {
+		struct ieee80211_hdr i3e;
+		u8 payload[0];
+	} data;
+} __packed;
+
+struct carl9170_tx_superframe {
+	struct carl9170_tx_superdesc s;
+	struct ar9170_tx_frame f;
+} __packed;
+
+#endif /* __CARL9170FW__ */
+
+struct _ar9170_tx_hwdesc {
+	__le16 length;
+	__le16 mac_control;
+	__le32 phy_control;
+} __packed;
+
+#define	CARL9170_TX_SUPER_AMPDU_DENSITY_S		0
+#define	CARL9170_TX_SUPER_AMPDU_DENSITY			0x7
+#define	CARL9170_TX_SUPER_AMPDU_FACTOR			0x18
+#define	CARL9170_TX_SUPER_AMPDU_FACTOR_S		3
+#define	CARL9170_TX_SUPER_AMPDU_COMMIT_DENSITY		0x20
+#define	CARL9170_TX_SUPER_AMPDU_COMMIT_DENSITY_S	5
+#define	CARL9170_TX_SUPER_AMPDU_COMMIT_FACTOR		0x40
+#define	CARL9170_TX_SUPER_AMPDU_COMMIT_FACTOR_S		6
+
+#define CARL9170_TX_SUPER_MISC_QUEUE			0x3
+#define CARL9170_TX_SUPER_MISC_QUEUE_S			0
+#define	CARL9170_TX_SUPER_MISC_VIF_ID			0x38
+#define	CARL9170_TX_SUPER_MISC_VIF_ID_S			3
+#define	CARL9170_TX_SUPER_MISC_FILL_IN_TSF		0x40
+#define	CARL9170_TX_SUPER_MISC_CAB			0x80
+
+#define CARL9170_TX_SUPER_RI_TRIES			0x7
+#define CARL9170_TX_SUPER_RI_TRIES_S			0
+#define CARL9170_TX_SUPER_RI_ERP_PROT			0x18
+#define CARL9170_TX_SUPER_RI_ERP_PROT_S			3
+#define CARL9170_TX_SUPER_RI_AMPDU			0x20
+#define CARL9170_TX_SUPER_RI_AMPDU_S			5
+
+struct _carl9170_tx_superdesc {
+	__le16 len;
+	u8 rix;
+	u8 cnt;
+	u8 cookie;
+	u8 ampdu_settings;
+	u8 misc;
+	u8 padding;
+	u8 ri[CARL9170_TX_MAX_RATES];
+	__le32 rr[CARL9170_TX_MAX_RETRY_RATES];
+} __packed;
+
+struct _carl9170_tx_superframe {
+	struct _carl9170_tx_superdesc s;
+	struct _ar9170_tx_hwdesc f;
+	u8 frame_data[0];
+} __packed;
+
+#define	CARL9170_TX_SUPERDESC_LEN		24
+#define	AR9170_TX_HWDESC_LEN			8
+#define	CARL9170_TX_SUPERFRAME_LEN		(CARL9170_TX_SUPERDESC_LEN + \
+						 AR9170_TX_HWDESC_LEN)
+
+struct ar9170_rx_head {
+	u8 plcp[12];
+} __packed;
+
+#define	AR9170_RX_HEAD_LEN			12
+
+struct ar9170_rx_phystatus {
+	union {
+		struct {
+			u8 rssi_ant0, rssi_ant1, rssi_ant2,
+				rssi_ant0x, rssi_ant1x, rssi_ant2x,
+				rssi_combined;
+		} __packed;
+		u8 rssi[7];
+	} __packed;
+
+	u8 evm_stream0[6], evm_stream1[6];
+	u8 phy_err;
+} __packed;
+
+#define	AR9170_RX_PHYSTATUS_LEN			20
+
+struct ar9170_rx_macstatus {
+	u8 SAidx, DAidx;
+	u8 error;
+	u8 status;
+} __packed;
+
+#define	AR9170_RX_MACSTATUS_LEN			4
+
+struct ar9170_rx_frame_single {
+	struct ar9170_rx_head phy_head;
+	struct ieee80211_hdr i3e;
+	struct ar9170_rx_phystatus phy_tail;
+	struct ar9170_rx_macstatus macstatus;
+} __packed;
+
+struct ar9170_rx_frame_head {
+	struct ar9170_rx_head phy_head;
+	struct ieee80211_hdr i3e;
+	struct ar9170_rx_macstatus macstatus;
+} __packed;
+
+struct ar9170_rx_frame_middle {
+	struct ieee80211_hdr i3e;
+	struct ar9170_rx_macstatus macstatus;
+} __packed;
+
+struct ar9170_rx_frame_tail {
+	struct ieee80211_hdr i3e;
+	struct ar9170_rx_phystatus phy_tail;
+	struct ar9170_rx_macstatus macstatus;
+} __packed;
+
+struct ar9170_rx_frame {
+	union {
+		struct ar9170_rx_frame_single single;
+		struct ar9170_rx_frame_head head;
+		struct ar9170_rx_frame_middle middle;
+		struct ar9170_rx_frame_tail tail;
+	} __packed;
+} __packed;
+
+static inline u8 ar9170_get_decrypt_type(struct ar9170_rx_macstatus *t)
+{
+	return (t->SAidx & 0xc0) >> 4 |
+	       (t->DAidx & 0xc0) >> 6;
+}
+
+enum ar9170_txq {
+	AR9170_TXQ_BE,
+
+	AR9170_TXQ_VI,
+	AR9170_TXQ_VO,
+	AR9170_TXQ_BK,
+
+	__AR9170_NUM_TXQ,
+};
+
+static const u8 ar9170_qmap[__AR9170_NUM_TXQ] = { 2, 1, 0, 3 };
+
+#define	AR9170_TXQ_DEPTH			32
+
+#define wiphy_err(a, b...) printk(b)
+#define wiphy_info(a, b...) printk(b)
+#define wiphy_dbg(a, b...) printk(b)
+
+
+#endif /* __CARL9170_SHARED_WLAN_H */
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 7696a66..8fa6d78 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -65,6 +65,8 @@ source "drivers/staging/rt2860/Kconfig"
 
 source "drivers/staging/rt2870/Kconfig"
 
+source "drivers/staging/rtl8712/Kconfig"
+
 source "drivers/staging/comedi/Kconfig"
 
 source "drivers/staging/asus_oled/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index ea2e70e..14d544b 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_R8187SE)		+= rtl8187se/
 obj-$(CONFIG_RTL8192SU)		+= rtl8192su/
 obj-$(CONFIG_RTL8192U)		+= rtl8192u/
 obj-$(CONFIG_RTL8192E)		+= rtl8192e/
+obj-$(CONFIG_RTL8192SU)		+= rtl8192su/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
 obj-$(CONFIG_DREAM)		+= dream/
 obj-$(CONFIG_POHMELFS)		+= pohmelfs/
diff --git a/drivers/staging/rtl8712/Kconfig b/drivers/staging/rtl8712/Kconfig
new file mode 100644
index 0000000..6a43312
--- /dev/null
+++ b/drivers/staging/rtl8712/Kconfig
@@ -0,0 +1,19 @@
+config R8712U
+	tristate "RealTek RTL8712U (RTL8192SU) Wireless LAN NIC driver"
+	depends on WLAN && USB
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select FW_LOADER
+	default N
+	---help---
+	This option adds the Realtek RTL8712 USB device such as the D-Link DWA-130.
+	If built as a module, it will be called r8712u.
+
+config R8712_TX_AGGR
+	bool "Realtek RTL8712U Transmit Aggregation code"
+	depends on R8712U && BROKEN
+	default N
+	---help---
+	This option provides transmit aggregation for the Realtek RTL8712 USB device.
+
+
diff --git a/drivers/staging/rtl8712/Makefile b/drivers/staging/rtl8712/Makefile
new file mode 100644
index 0000000..029355d
--- /dev/null
+++ b/drivers/staging/rtl8712/Makefile
@@ -0,0 +1,35 @@
+r8712u-y :=				\
+		rtl871x_cmd.o		\
+		rtl8712_cmd.o		\
+		rtl871x_security.o	\
+		rtl871x_eeprom.o	\
+		rtl8712_efuse.o		\
+		hal_init.o		\
+		usb_halinit.o		\
+		usb_ops.o		\
+		usb_ops_linux.o		\
+		rtl871x_io.o		\
+		rtl8712_io.o		\
+		rtl871x_ioctl_linux.o	\
+		rtl871x_ioctl_rtl.o	\
+		rtl871x_ioctl_set.o	\
+		rtl8712_led.o		\
+		rtl871x_mlme.o		\
+		ieee80211.o		\
+		rtl871x_mp_ioctl.o	\
+		rtl871x_mp.o		\
+		mlme_linux.o		\
+		recv_linux.o		\
+		xmit_linux.o		\
+		usb_intf.o		\
+		os_intfs.o		\
+		rtl871x_pwrctrl.o	\
+		rtl8712_recv.o		\
+		rtl871x_recv.o		\
+		rtl871x_sta_mgt.o	\
+		rtl871x_xmit.o		\
+		rtl8712_xmit.o		\
+		hex_to_bin.o
+
+obj-$(CONFIG_R8712U)	:= r8712u.o
+
diff --git a/drivers/staging/rtl8712/TODO b/drivers/staging/rtl8712/TODO
new file mode 100644
index 0000000..d8dfe5b
--- /dev/null
+++ b/drivers/staging/rtl8712/TODO
@@ -0,0 +1,13 @@
+TODO:
+- merge Realtek's bugfixes and new features into the driver
+- switch to use LIB80211
+- switch to use MAC80211
+- checkpatch.pl fixes - only a few remain
+
+Please send any patches to Greg Kroah-Hartman <greg@kroah.com>,
+Larry Finger <Larry.Finger@lwfinger.net> and
+Florian Schilhabel <florian.c.schilhabel@googlemail.com>.
+
+
+
+
diff --git a/drivers/staging/rtl8712/basic_types.h b/drivers/staging/rtl8712/basic_types.h
new file mode 100644
index 0000000..7561bed
--- /dev/null
+++ b/drivers/staging/rtl8712/basic_types.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#include <linux/types.h>
+
+#define SIZE_T __kernel_size_t
+#define sint signed int
+#define FIELD_OFFSET(s, field)	((addr_t)&((s *)(0))->field)
+
+/* Should we extend this to be host_addr_t and target_addr_t for case:
+ *	host : x86_64
+ *	target : mips64
+ */
+#define addr_t unsigned long
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof(SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#endif /*__BASIC_TYPES_H__*/
+
diff --git a/drivers/staging/rtl8712/big_endian.h b/drivers/staging/rtl8712/big_endian.h
new file mode 100644
index 0000000..b16f8ec
--- /dev/null
+++ b/drivers/staging/rtl8712/big_endian.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include "swab.h"
+
+#define __constant_htonl(x) ((__u32)(x))
+#define __constant_ntohl(x) ((__u32)(x))
+#define __constant_htons(x) ((__u16)(x))
+#define __constant_ntohs(x) ((__u16)(x))
+#define __constant_cpu_to_le64(x) ___constant_swab64((x))
+#define __constant_le64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_le32(x) ___constant_swab32((x))
+#define __constant_le32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_le16(x) ___constant_swab16((x))
+#define __constant_le16_to_cpu(x) ___constant_swab16((x))
+#define __constant_cpu_to_be64(x) ((__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_be32(x) ((__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_be16(x) ((__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64(x) __swab64((x))
+#define __le64_to_cpu(x) __swab64((x))
+#define __cpu_to_le32(x) __swab32((x))
+#define __le32_to_cpu(x) __swab32((x))
+#define __cpu_to_le16(x) __swab16((x))
+#define __le16_to_cpu(x) __swab16((x))
+#define __cpu_to_be64(x) ((__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_be32(x) ((__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_be16(x) ((__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64p(x) __swab64p((x))
+#define __le64_to_cpup(x) __swab64p((x))
+#define __cpu_to_le32p(x) __swab32p((x))
+#define __le32_to_cpup(x) __swab32p((x))
+#define __cpu_to_le16p(x) __swab16p((x))
+#define __le16_to_cpup(x) __swab16p((x))
+#define __cpu_to_be64p(x) (*(__u64 *)(x))
+#define __be64_to_cpup(x) (*(__u64 *)(x))
+#define __cpu_to_be32p(x) (*(__u32 *)(x))
+#define __be32_to_cpup(x) (*(__u32 *)(x))
+#define __cpu_to_be16p(x) (*(__u16 *)(x))
+#define __be16_to_cpup(x) (*(__u16 *)(x))
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include "generic.h"
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
+
diff --git a/drivers/staging/rtl8712/drv_types.h b/drivers/staging/rtl8712/drv_types.h
new file mode 100644
index 0000000..ed85b44
--- /dev/null
+++ b/drivers/staging/rtl8712/drv_types.h
@@ -0,0 +1,204 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*---------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+-----------------------------------------------------------------------*/
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+struct _adapter;
+
+#include "osdep_service.h"
+#include "wlan_bssdef.h"
+#include "rtl8712_spec.h"
+#include "rtl8712_hal.h"
+#include <linux/mutex.h>
+#include <linux/completion.h>
+
+enum _NIC_VERSION {
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+};
+
+struct _adapter;
+
+struct	qos_priv	{
+	/* bit mask option: u-apsd, s-apsd, ts, block ack... */
+	unsigned int qos_option;
+};
+
+#include "rtl871x_ht.h"
+#include "rtl871x_cmd.h"
+#include "rtl871x_xmit.h"
+#include "rtl871x_recv.h"
+#include "rtl871x_security.h"
+#include "rtl871x_pwrctrl.h"
+#include "rtl871x_io.h"
+#include "rtl871x_eeprom.h"
+#include "sta_info.h"
+#include "rtl871x_mlme.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_debug.h"
+#include "rtl871x_rf.h"
+#include "rtl871x_event.h"
+#include "rtl871x_led.h"
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+
+struct specific_device_id {
+	u32		flags;
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv {
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	u8	network_mode;	/*infra, ad-hoc, auto*/
+	struct ndis_802_11_ssid	ssid;
+	u8	channel;/* ad-hoc support requirement */
+	u8	wireless_mode;/* A, B, G, auto */
+	u8	vrtl_carrier_sense; /*Enable, Disable, Auto*/
+	u8	vcs_type;/*RTS/CTS, CTS-to-self*/
+	u16	rts_thresh;
+	u16  frag_thresh;
+	u8	preamble;/*long, short, auto*/
+	u8  scan_mode;/*active, passive*/
+	u8  adhoc_tx_pwr;
+	u8  soft_ap;
+	u8  smart_ps;
+	u8 power_mgnt;
+	u8 radio_enable;
+	u8 long_retry_lmt;
+	u8 short_retry_lmt;
+	u16 busy_thresh;
+	u8 ack_policy;
+	u8 mp_mode;
+	u8 software_encrypt;
+	u8 software_decrypt;
+	/* UAPSD */
+	u8 wmm_enable;
+	u8 uapsd_enable;
+	u8 uapsd_max_sp;
+	u8 uapsd_acbk_en;
+	u8 uapsd_acbe_en;
+	u8 uapsd_acvi_en;
+	u8 uapsd_acvo_en;
+
+	struct wlan_bssid_ex dev_network;
+
+	u8 ht_enable;
+	u8 cbw40_enable;
+	u8 ampdu_enable;/*for tx*/
+	u8 rf_config;
+	u8 low_power;
+	u8 wifi_test;
+};
+
+/* For registry parameters */
+#define RGTRY_OFT(field) ((addr_t)FIELD_OFFSET(struct registry_priv, field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv *)0)->field)
+#define BSSID_OFT(field) ((addr_t)FIELD_OFFSET(struct ndis_wlan_bssid_ex, \
+			 field))
+#define BSSID_SZ(field)   sizeof(((struct ndis_wlan_bssid_ex *)0)->field)
+
+struct dvobj_priv {
+	struct _adapter *padapter;
+	u32 nr_endpoint;
+	u8   ishighspeed;
+	uint(*inirp_init)(struct _adapter *adapter);
+	uint(*inirp_deinit)(struct _adapter *adapter);
+	struct semaphore usb_suspend_sema;
+	struct usb_device *pusbdev;
+};
+
+/**
+ * struct _adapter - the main adapter structure for this device.
+ *
+ * bup: True indicates that the interface is Up.
+ */
+struct _adapter {
+	struct	dvobj_priv dvobjpriv;
+	struct	mlme_priv mlmepriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	struct	io_queue	*pio_queue;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	struct	registry_priv	registrypriv;
+	struct	wlan_acl_pool	acl_list;
+	struct	pwrctrl_priv	pwrctrlpriv;
+	struct	eeprom_priv eeprompriv;
+	struct	hal_priv	halpriv;
+	struct	led_priv	ledpriv;
+	struct mp_priv  mppriv;
+	s32	bDriverStopped;
+	s32	bSurpriseRemoved;
+	u32	IsrContent;
+	u32	ImrContent;
+	bool	fw_found;
+	u8	EepromAddressSize;
+	u8	hw_init_completed;
+	struct task_struct *cmdThread;
+	 pid_t evtThread;
+	struct task_struct *xmitThread;
+	pid_t recvThread;
+	uint(*dvobj_init)(struct _adapter *adapter);
+	void  (*dvobj_deinit)(struct _adapter *adapter);
+	struct net_device *pnetdev;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	int pid; /*process id from UI*/
+	_workitem wkFilterRxFF0;
+	u8 blnEnableRxFF0Filter;
+	spinlock_t lockRxFF0Filter;
+	const struct firmware *fw;
+	struct usb_interface *pusb_intf;
+	struct mutex mutex_start;
+	struct completion rtl8712_fw_ready;
+};
+
+static inline u8 *myid(struct eeprom_priv *peepriv)
+{
+	return peepriv->mac_addr;
+}
+
+u8 r8712_usb_hal_bus_init(struct _adapter *adapter);
+
+#endif /*__DRV_TYPES_H__*/
+
diff --git a/drivers/staging/rtl8712/ethernet.h b/drivers/staging/rtl8712/ethernet.h
new file mode 100644
index 0000000..882d61b
--- /dev/null
+++ b/drivers/staging/rtl8712/ethernet.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH		6	/*!< Ethernet Address Length*/
+#define ETHERNET_HEADER_SIZE		14	/*!< Ethernet Header Length*/
+#define LLC_HEADER_SIZE			6	/*!< LLC Header Length*/
+#define TYPE_LENGTH_FIELD_SIZE		2	/*!< Type/Length Size*/
+#define MINIMUM_ETHERNET_PACKET_SIZE	60	/*!< Min Ethernet Packet Size*/
+#define MAXIMUM_ETHERNET_PACKET_SIZE	1514	/*!< Max Ethernet Packet Size*/
+
+/*!< Is Multicast Address? */
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01) != 0)
+/*!< Is Broadcast Address? */
+#define RT_ETH_IS_BROADCAST(_pAddr)	(				\
+			((u8 *)(_pAddr))[0] == 0xff	&&		\
+			((u8 *)(_pAddr))[1] == 0xff	&&		\
+			((u8 *)(_pAddr))[2] == 0xff	&&		\
+			((u8 *)(_pAddr))[3] == 0xff	&&		\
+			((u8 *)(_pAddr))[4] == 0xff	&&		\
+			((u8 *)(_pAddr))[5] == 0xff)
+
+#endif /* #ifndef __INC_ETHERNET_H */
+
diff --git a/drivers/staging/rtl8712/farray.h b/drivers/staging/rtl8712/farray.h
new file mode 100644
index 0000000..9217772
--- /dev/null
+++ b/drivers/staging/rtl8712/farray.h
@@ -0,0 +1,10197 @@
+/* Firmware */
+static const unsigned char f_array[122328] = {
+0x12, 0x87, 0xEC, 0x11, 0x30, 0x00, 0x00, 0x00, 0x08, 0xE8, 0x00, 0x00,
+0x50, 0xF5, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x98, 0xF3, 0x00, 0x00,
+0xF2, 0x00, 0x00, 0x00, 0x05, 0x30, 0x16, 0x53, 0x87, 0x12, 0x12, 0x01,
+0x00, 0x00, 0x12, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01,
+0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x1A, 0x3C, 0x80, 0x03, 0x5A, 0x37, 0x00, 0x80, 0x1B, 0x3C,
+0x80, 0x00, 0x7B, 0x37, 0x00, 0x00, 0x5B, 0xAF, 0x25, 0xB0, 0x1A, 0x3C,
+0x18, 0x03, 0x5A, 0x37, 0x00, 0x80, 0x1B, 0x3C, 0x80, 0x00, 0x7B, 0x37,
+0x00, 0x00, 0x5B, 0xAF, 0x01, 0x80, 0x1A, 0x3C, 0x24, 0xE2, 0x5A, 0x27,
+0x08, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xA1, 0xAF, 0x08, 0x00, 0xA2, 0xAF,
+0x0C, 0x00, 0xA3, 0xAF, 0x10, 0x00, 0xA4, 0xAF, 0x14, 0x00, 0xA5, 0xAF,
+0x18, 0x00, 0xA6, 0xAF, 0x1C, 0x00, 0xA7, 0xAF, 0x20, 0x00, 0xA8, 0xAF,
+0x24, 0x00, 0xA9, 0xAF, 0x28, 0x00, 0xAA, 0xAF, 0x2C, 0x00, 0xAB, 0xAF,
+0x30, 0x00, 0xAC, 0xAF, 0x34, 0x00, 0xAD, 0xAF, 0x38, 0x00, 0xAE, 0xAF,
+0x3C, 0x00, 0xAF, 0xAF, 0x12, 0x40, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00,
+0x00, 0x70, 0x0A, 0x40, 0x40, 0x00, 0xB0, 0xAF, 0x44, 0x00, 0xB1, 0xAF,
+0x48, 0x00, 0xB2, 0xAF, 0x4C, 0x00, 0xB3, 0xAF, 0x50, 0x00, 0xB4, 0xAF,
+0x54, 0x00, 0xB5, 0xAF, 0x58, 0x00, 0xB6, 0xAF, 0x5C, 0x00, 0xB7, 0xAF,
+0x60, 0x00, 0xB8, 0xAF, 0x64, 0x00, 0xB9, 0xAF, 0x68, 0x00, 0xBC, 0xAF,
+0x6C, 0x00, 0xBD, 0xAF, 0x70, 0x00, 0xBE, 0xAF, 0x74, 0x00, 0xBF, 0xAF,
+0x78, 0x00, 0xA8, 0xAF, 0x7C, 0x00, 0xA9, 0xAF, 0x80, 0x00, 0xAA, 0xAF,
+0x17, 0x38, 0x00, 0x08, 0x21, 0x20, 0xA0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xBD, 0x27,
+0x14, 0x00, 0xB1, 0xAF, 0x00, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x11, 0x3C,
+0x18, 0x03, 0x23, 0x36, 0x00, 0x03, 0x42, 0x24, 0x00, 0x00, 0x62, 0xAC,
+0x18, 0x00, 0xB2, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x1C, 0x00, 0xBF, 0xAF,
+0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x42, 0xB0, 0x02, 0x3C,
+0x03, 0x00, 0x47, 0x34, 0x00, 0x00, 0xE3, 0x90, 0x02, 0x80, 0x0A, 0x3C,
+0x02, 0x80, 0x0B, 0x3C, 0xFF, 0x00, 0x70, 0x30, 0x00, 0x36, 0x10, 0x00,
+0x10, 0x00, 0x02, 0x32, 0x03, 0x36, 0x06, 0x00, 0x17, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x12, 0x3C, 0xFC, 0x5C, 0x42, 0x8D, 0x60, 0x1B, 0x44, 0x26,
+0x64, 0x37, 0x83, 0x94, 0x01, 0x00, 0x45, 0x24, 0x10, 0x00, 0x02, 0x24,
+0xB0, 0x03, 0x29, 0x36, 0x1C, 0x03, 0x28, 0x36, 0x00, 0x00, 0xE2, 0xA0,
+0x07, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x68, 0x37, 0x82, 0x94,
+0x64, 0x37, 0x80, 0xA4, 0x68, 0x37, 0x80, 0xA4, 0x00, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x02, 0xAD, 0x00, 0x00, 0x20, 0xAD, 0x10, 0x5E, 0x62, 0x8D,
+0x01, 0x00, 0x63, 0x24, 0xFC, 0x5C, 0x45, 0xAD, 0x01, 0x00, 0x42, 0x24,
+0x10, 0x5E, 0x62, 0xAD, 0x64, 0x37, 0x83, 0xA4, 0x29, 0x00, 0xC0, 0x04,
+0x42, 0xB0, 0x02, 0x3C, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x40, 0x00, 0x02, 0x32, 0x0F, 0x00, 0x40, 0x14, 0x60, 0x1B, 0x44, 0x26,
+0xE0, 0x1B, 0x83, 0x94, 0xDC, 0x1B, 0x85, 0x94, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x80, 0x00, 0x63, 0x30, 0x41, 0xB0, 0x02, 0x3C, 0x25, 0x18, 0x65, 0x00,
+0x08, 0x00, 0x42, 0x34, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x43, 0xA4,
+0x08, 0x00, 0xE0, 0x03, 0xDC, 0x1B, 0x83, 0xA4, 0x42, 0xB0, 0x02, 0x3C,
+0x40, 0x00, 0x03, 0x24, 0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0,
+0x25, 0x62, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x44, 0x26,
+0xE0, 0x1B, 0x83, 0x94, 0xDC, 0x1B, 0x85, 0x94, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x80, 0x00, 0x63, 0x30, 0x41, 0xB0, 0x02, 0x3C, 0x25, 0x18, 0x65, 0x00,
+0x08, 0x00, 0x42, 0x34, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x43, 0xA4,
+0x08, 0x00, 0xE0, 0x03, 0xDC, 0x1B, 0x83, 0xA4, 0x80, 0xFF, 0x03, 0x24,
+0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0, 0x44, 0x22, 0x00, 0x74,
+0x00, 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x84, 0x30, 0x0B, 0x00, 0x82, 0x2C, 0xFF, 0xFF, 0xE7, 0x30,
+0x10, 0x00, 0xA8, 0x93, 0x19, 0x00, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x80, 0x10, 0x04, 0x00, 0x88, 0xE6, 0x63, 0x24,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xB0, 0x02, 0x3C,
+0x78, 0x00, 0x44, 0x34, 0x07, 0x00, 0xE2, 0x30, 0x00, 0x00, 0x85, 0xAC,
+0x04, 0x00, 0x86, 0xAC, 0x04, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00, 0x00,
+0xF8, 0xFF, 0xE2, 0x30, 0x08, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x47, 0x30,
+0x21, 0x10, 0xE8, 0x00, 0x00, 0x80, 0x03, 0x3C, 0x08, 0x00, 0x82, 0xAC,
+0x25, 0x10, 0x43, 0x00, 0x08, 0x00, 0x82, 0xAC, 0x01, 0x00, 0x03, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x6C, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x60, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x54, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x48, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x3C, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x30, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x24, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x18, 0x00, 0x44, 0x34, 0x43, 0xB0, 0x02, 0x3C,
+0x2E, 0x01, 0x00, 0x08, 0x0C, 0x00, 0x44, 0x34, 0x2E, 0x01, 0x00, 0x08,
+0x43, 0xB0, 0x04, 0x3C, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x18, 0x03, 0x42, 0x34, 0x6C, 0x05, 0x63, 0x24, 0x00, 0x00, 0x43, 0xAC,
+0x01, 0x00, 0x05, 0x24, 0x43, 0xB0, 0x02, 0x3C, 0x04, 0x28, 0x85, 0x00,
+0x88, 0x00, 0x44, 0x34, 0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24,
+0xFF, 0xFF, 0x42, 0x30, 0x05, 0x00, 0x43, 0x2C, 0xFD, 0xFF, 0x60, 0x14,
+0x01, 0x00, 0x42, 0x24, 0x00, 0x00, 0x82, 0x94, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0xFF, 0x42, 0x30, 0x24, 0x10, 0x45, 0x00, 0xF5, 0xFF, 0x40, 0x1C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x08, 0x3C, 0x00, 0x80, 0x02, 0x3C, 0xC8, 0xFF, 0xBD, 0x27,
+0x18, 0x03, 0x03, 0x35, 0xC8, 0x05, 0x42, 0x24, 0x00, 0x00, 0x62, 0xAC,
+0x30, 0x00, 0xB6, 0xAF, 0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x34, 0x00, 0xBF, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x20, 0x00, 0xB2, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x0C, 0x00, 0xF2, 0x84,
+0x08, 0x00, 0xF5, 0x8C, 0xFF, 0x00, 0xC6, 0x30, 0x00, 0x01, 0x02, 0x24,
+0x23, 0x10, 0x46, 0x00, 0xFF, 0xFF, 0x51, 0x30, 0xD0, 0x03, 0x08, 0x35,
+0xFF, 0x00, 0x96, 0x30, 0x00, 0x00, 0x12, 0xAD, 0x21, 0xA0, 0xA0, 0x00,
+0x21, 0x30, 0xC5, 0x00, 0x00, 0x00, 0x15, 0xAD, 0x21, 0x20, 0xC0, 0x02,
+0x21, 0x28, 0xA0, 0x02, 0x21, 0x38, 0x20, 0x02, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x23, 0x18, 0x51, 0x02, 0xFF, 0xFF, 0x82, 0x32,
+0x00, 0x94, 0x03, 0x00, 0x03, 0x94, 0x12, 0x00, 0xB4, 0x01, 0x00, 0x08,
+0x02, 0x9A, 0x02, 0x00, 0x28, 0xB0, 0x03, 0x3C, 0xC0, 0x10, 0x13, 0x00,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x90, 0x25, 0xB0, 0x10, 0x3C,
+0x20, 0x10, 0x02, 0x3C, 0xFF, 0x00, 0x93, 0x30, 0x00, 0x22, 0x13, 0x00,
+0xFF, 0xFF, 0x43, 0x32, 0x01, 0x01, 0x45, 0x2A, 0x21, 0xA0, 0x82, 0x00,
+0x21, 0xA8, 0xB1, 0x02, 0xD0, 0x03, 0x02, 0x36, 0x00, 0x01, 0x11, 0x24,
+0x0B, 0x88, 0x65, 0x00, 0x21, 0x20, 0xC0, 0x02, 0x00, 0x00, 0x53, 0xAC,
+0x5B, 0x01, 0x00, 0x0C, 0xB0, 0x03, 0x10, 0x36, 0x21, 0x30, 0x80, 0x02,
+0x21, 0x20, 0xC0, 0x02, 0x21, 0x28, 0xA0, 0x02, 0x21, 0x38, 0x20, 0x02,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x23, 0x18, 0x51, 0x02,
+0x00, 0x94, 0x03, 0x00, 0x03, 0x94, 0x12, 0x00, 0x00, 0x00, 0x12, 0xAE,
+0xE2, 0xFF, 0x40, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0x21, 0x50, 0x80, 0x00, 0x04, 0x00, 0x8D, 0x8C, 0x0C, 0x00, 0x4B, 0x8D,
+0x08, 0x00, 0x84, 0x8C, 0xFF, 0xE0, 0x02, 0x3C, 0x10, 0x00, 0x47, 0x8D,
+0xFF, 0xFF, 0x42, 0x34, 0x1F, 0x00, 0xA9, 0x31, 0x24, 0x20, 0x82, 0x00,
+0x00, 0x1E, 0x09, 0x00, 0x02, 0x14, 0x0B, 0x00, 0x25, 0x40, 0x83, 0x00,
+0x21, 0x78, 0xA0, 0x00, 0xB7, 0x00, 0xE0, 0x04, 0x07, 0x00, 0x44, 0x30,
+0x00, 0x00, 0x42, 0x95, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x0F, 0x42, 0x28,
+0xB9, 0x00, 0x40, 0x10, 0xFF, 0xDF, 0x02, 0x3C, 0x02, 0x80, 0x0E, 0x3C,
+0x08, 0x00, 0x48, 0xAD, 0x60, 0x1B, 0xC3, 0x25, 0xC6, 0x3D, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x40, 0x14, 0xC0, 0x30, 0x09, 0x00,
+0xC6, 0x40, 0x62, 0x90, 0xFF, 0xDF, 0x03, 0x3C, 0xFF, 0xFF, 0x63, 0x34,
+0x07, 0x10, 0x82, 0x00, 0x01, 0x00, 0x42, 0x30, 0x24, 0x18, 0x03, 0x01,
+0x40, 0x17, 0x02, 0x00, 0x25, 0x40, 0x62, 0x00, 0x08, 0x00, 0x48, 0xAD,
+0xC0, 0x30, 0x09, 0x00, 0x21, 0x10, 0xC9, 0x00, 0x80, 0x10, 0x02, 0x00,
+0x21, 0x10, 0x49, 0x00, 0x80, 0x10, 0x02, 0x00, 0x60, 0x1B, 0xC9, 0x25,
+0x21, 0x28, 0x49, 0x00, 0x08, 0x25, 0xA3, 0x8C, 0x01, 0x00, 0x0C, 0x24,
+0x02, 0x13, 0x03, 0x00, 0x01, 0x00, 0x42, 0x30, 0xB5, 0x00, 0x4C, 0x10,
+0x42, 0x18, 0x03, 0x00, 0x82, 0x11, 0x08, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0xC0, 0xFF, 0x02, 0x24,
+0x24, 0x10, 0x02, 0x01, 0x04, 0x00, 0x48, 0x34, 0x08, 0x00, 0x48, 0xAD,
+0x02, 0x80, 0x02, 0x3C, 0xD1, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x6A, 0x00, 0x60, 0x14, 0x21, 0x20, 0xC9, 0x00, 0xD4, 0x23, 0x83, 0x8C,
+0xBF, 0xFF, 0x02, 0x24, 0x24, 0x10, 0xE2, 0x00, 0x40, 0x00, 0x63, 0x30,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0xD4, 0x23, 0x83, 0x8C,
+0x7F, 0xF8, 0x02, 0x24, 0x24, 0x10, 0xE2, 0x00, 0x80, 0x07, 0x63, 0x30,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0xC6, 0x3D, 0x22, 0x91,
+0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x40, 0x14, 0x42, 0x17, 0x08, 0x00,
+0x01, 0x00, 0x44, 0x30, 0xB1, 0x00, 0x8C, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0xC4, 0x25, 0x21, 0x20, 0xC4, 0x00, 0xD4, 0x23, 0x83, 0x8C,
+0xFF, 0xF7, 0x02, 0x24, 0x24, 0x10, 0xE2, 0x00, 0x00, 0x08, 0x63, 0x30,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0xD4, 0x23, 0x83, 0x8C,
+0xFF, 0xEF, 0x02, 0x24, 0x24, 0x10, 0xE2, 0x00, 0x00, 0x10, 0x63, 0x30,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0x60, 0x1B, 0xC5, 0x25,
+0x21, 0x30, 0xC5, 0x00, 0xD4, 0x23, 0xC4, 0x8C, 0xFD, 0xFF, 0x02, 0x3C,
+0x02, 0x00, 0x03, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x83, 0x00,
+0x24, 0x10, 0xE2, 0x00, 0x25, 0x38, 0x44, 0x00, 0x10, 0x00, 0x47, 0xAD,
+0xB0, 0x1B, 0xA3, 0x94, 0xFB, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0xC2, 0x1B, 0x03, 0x00, 0x24, 0x10, 0xE2, 0x00, 0x80, 0x1C, 0x03, 0x00,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0x3B, 0x41, 0xA3, 0x90,
+0xE7, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x03, 0x00, 0x63, 0x30,
+0x24, 0x10, 0xE2, 0x00, 0xC0, 0x1C, 0x03, 0x00, 0x25, 0x38, 0x43, 0x00,
+0x10, 0x00, 0x47, 0xAD, 0xD4, 0x23, 0xC4, 0x8C, 0xFF, 0xFD, 0x02, 0x3C,
+0x00, 0x02, 0x03, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x83, 0x00,
+0x24, 0x10, 0xE2, 0x00, 0x25, 0x38, 0x44, 0x00, 0x10, 0x00, 0x47, 0xAD,
+0xB0, 0x1B, 0xA3, 0x94, 0xFF, 0xFB, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0xC2, 0x1B, 0x03, 0x00, 0x24, 0x10, 0xE2, 0x00, 0x80, 0x1E, 0x03, 0x00,
+0x25, 0x38, 0x43, 0x00, 0x10, 0x00, 0x47, 0xAD, 0x3B, 0x41, 0xA3, 0x90,
+0xFF, 0xE7, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x03, 0x00, 0x63, 0x30,
+0x24, 0x10, 0xE2, 0x00, 0xC0, 0x1E, 0x03, 0x00, 0x25, 0x38, 0x43, 0x00,
+0x10, 0x00, 0x47, 0xAD, 0xD4, 0x23, 0xC3, 0x8C, 0xC0, 0xFF, 0x02, 0x24,
+0x24, 0x10, 0xE2, 0x00, 0x3F, 0x00, 0x63, 0x30, 0x25, 0x10, 0x43, 0x00,
+0x10, 0x00, 0x42, 0xAD, 0xD8, 0x23, 0xC4, 0x8C, 0x14, 0x00, 0x43, 0x8D,
+0xFF, 0xFF, 0x02, 0x3C, 0xFF, 0x7F, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x80, 0x84, 0x30, 0x25, 0x18, 0x64, 0x00, 0x14, 0x00, 0x43, 0xAD,
+0xDA, 0x23, 0xC4, 0x94, 0xE0, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x1F, 0x00, 0x84, 0x30, 0x24, 0x18, 0x62, 0x00, 0x00, 0x24, 0x04, 0x00,
+0x25, 0x18, 0x64, 0x00, 0x14, 0x00, 0x43, 0xAD, 0x02, 0x00, 0x43, 0x91,
+0x02, 0x14, 0x0D, 0x00, 0x01, 0x00, 0x42, 0x30, 0x27, 0x00, 0x40, 0x10,
+0x21, 0x30, 0x6F, 0x00, 0x60, 0x1B, 0xC4, 0x25, 0xE4, 0x1D, 0x85, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xA2, 0x24, 0xE4, 0x1D, 0x82, 0xA4,
+0x0C, 0x00, 0x43, 0x8D, 0x00, 0xF0, 0x02, 0x3C, 0xFF, 0x0F, 0xA5, 0x30,
+0xFF, 0xFF, 0x42, 0x34, 0x00, 0x24, 0x05, 0x00, 0x24, 0x18, 0x62, 0x00,
+0x25, 0x58, 0x83, 0x00, 0x0C, 0x00, 0x4B, 0xAD, 0x16, 0x00, 0xC2, 0x94,
+0x00, 0x19, 0x05, 0x00, 0x60, 0x1B, 0xC4, 0x25, 0x0F, 0x00, 0x42, 0x30,
+0x25, 0x10, 0x43, 0x00, 0x16, 0x00, 0xC2, 0xA4, 0x00, 0x00, 0x43, 0x95,
+0x40, 0x41, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x43, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x40, 0x41, 0x82, 0xAC, 0x14, 0x00, 0x42, 0x8D,
+0x00, 0x00, 0x00, 0x00, 0x42, 0x12, 0x02, 0x00, 0x3F, 0x00, 0x42, 0x30,
+0x0C, 0x00, 0x42, 0x28, 0x44, 0xFF, 0x40, 0x10, 0xFF, 0xDF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x40, 0x02, 0x01, 0x00, 0x40, 0x03, 0x3C,
+0x25, 0x40, 0x03, 0x01, 0xE3, 0x01, 0x00, 0x08, 0x02, 0x80, 0x0E, 0x3C,
+0x60, 0x1B, 0xC3, 0x25, 0xC6, 0x3D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x1D, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x13, 0x0B, 0x00,
+0x0E, 0x00, 0x42, 0x30, 0x21, 0x10, 0x43, 0x00, 0xD4, 0x1D, 0x45, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xA3, 0x24, 0xD4, 0x1D, 0x43, 0xA4,
+0x0C, 0x00, 0x44, 0x8D, 0x00, 0xF0, 0x02, 0x3C, 0xFF, 0x0F, 0xA5, 0x30,
+0xFF, 0xFF, 0x42, 0x34, 0x00, 0x1C, 0x05, 0x00, 0x77, 0x02, 0x00, 0x08,
+0x24, 0x20, 0x82, 0x00, 0x7F, 0xFF, 0x02, 0x24, 0x24, 0x10, 0x02, 0x01,
+0x80, 0x00, 0x63, 0x30, 0x25, 0x40, 0x43, 0x00, 0x08, 0x00, 0x48, 0xAD,
+0x08, 0x25, 0xA3, 0x8C, 0xFF, 0xFF, 0x02, 0x3C, 0xFF, 0x1F, 0x42, 0x34,
+0x07, 0x00, 0x63, 0x30, 0x24, 0x10, 0xE2, 0x00, 0x40, 0x1B, 0x03, 0x00,
+0x25, 0x38, 0x43, 0x00, 0xF1, 0x01, 0x00, 0x08, 0x10, 0x00, 0x47, 0xAD,
+0x02, 0x14, 0x0B, 0x00, 0xFF, 0x0F, 0x45, 0x30, 0x16, 0x00, 0xC2, 0x94,
+0x00, 0x19, 0x05, 0x00, 0x60, 0x1B, 0xC4, 0x25, 0x0F, 0x00, 0x42, 0x30,
+0x25, 0x10, 0x43, 0x00, 0x16, 0x00, 0xC2, 0xA4, 0x00, 0x00, 0x43, 0x95,
+0x40, 0x41, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x43, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x40, 0x41, 0x82, 0xAC, 0xCE, 0x5C, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x4E, 0xFF, 0x64, 0x14, 0x60, 0x1B, 0xC4, 0x25,
+0x3C, 0x41, 0x22, 0x91, 0xFF, 0xF7, 0x03, 0x24, 0x24, 0x18, 0xE3, 0x00,
+0x01, 0x00, 0x42, 0x30, 0xC0, 0x12, 0x02, 0x00, 0x25, 0x38, 0x62, 0x00,
+0x10, 0x00, 0x47, 0xAD, 0x3D, 0x41, 0x22, 0x91, 0xFF, 0xEF, 0x03, 0x24,
+0x24, 0x18, 0xE3, 0x00, 0x01, 0x00, 0x42, 0x30, 0x00, 0x13, 0x02, 0x00,
+0x25, 0x38, 0x43, 0x00, 0x1F, 0x02, 0x00, 0x08, 0x10, 0x00, 0x47, 0xAD,
+0xD8, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xB2, 0xAF, 0x18, 0x00, 0xB0, 0xAF,
+0x24, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB1, 0xAF, 0x04, 0x00, 0x8B, 0x8C,
+0x21, 0x80, 0x80, 0x00, 0x08, 0x00, 0x84, 0x8C, 0x0E, 0x00, 0x07, 0x96,
+0xFF, 0xE0, 0x02, 0x3C, 0x10, 0x00, 0x08, 0x8E, 0x1F, 0x00, 0x6A, 0x31,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x82, 0x00, 0x00, 0x1E, 0x0A, 0x00,
+0x25, 0x48, 0x83, 0x00, 0x21, 0x90, 0xA0, 0x00, 0x21, 0x60, 0xC0, 0x00,
+0xCF, 0x00, 0x00, 0x05, 0x07, 0x00, 0xE7, 0x30, 0x00, 0x00, 0x02, 0x96,
+0x00, 0x00, 0x00, 0x00, 0xFD, 0x0F, 0x42, 0x28, 0xD1, 0x00, 0x40, 0x10,
+0xFF, 0xDF, 0x02, 0x3C, 0x02, 0x80, 0x11, 0x3C, 0x08, 0x00, 0x09, 0xAE,
+0x60, 0x1B, 0x23, 0x26, 0xC6, 0x3D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x40, 0x62, 0x90,
+0xFF, 0xDF, 0x03, 0x3C, 0xFF, 0xFF, 0x63, 0x34, 0x07, 0x10, 0xE2, 0x00,
+0x01, 0x00, 0x42, 0x30, 0x24, 0x18, 0x23, 0x01, 0x40, 0x17, 0x02, 0x00,
+0x25, 0x48, 0x62, 0x00, 0x08, 0x00, 0x09, 0xAE, 0x1C, 0x00, 0x02, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x40, 0x04, 0x04, 0x00, 0x03, 0x24,
+0xC0, 0x30, 0x0A, 0x00, 0x21, 0x10, 0xCA, 0x00, 0x80, 0x10, 0x02, 0x00,
+0x21, 0x10, 0x4A, 0x00, 0x80, 0x10, 0x02, 0x00, 0x60, 0x1B, 0x27, 0x26,
+0x21, 0x28, 0x47, 0x00, 0x08, 0x25, 0xA3, 0x8C, 0x01, 0x00, 0x0A, 0x24,
+0x02, 0x13, 0x03, 0x00, 0x01, 0x00, 0x42, 0x30, 0xE7, 0x00, 0x4A, 0x10,
+0x42, 0x18, 0x03, 0x00, 0x82, 0x11, 0x09, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0xC0, 0xFF, 0x02, 0x24,
+0x24, 0x10, 0x22, 0x01, 0x04, 0x00, 0x49, 0x34, 0x08, 0x00, 0x09, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0xD1, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x6C, 0x00, 0x60, 0x14, 0x21, 0x28, 0xC7, 0x00, 0xD4, 0x23, 0xA4, 0x8C,
+0x10, 0x00, 0x02, 0x8E, 0xBF, 0xFF, 0x03, 0x24, 0x40, 0x00, 0x84, 0x30,
+0x24, 0x10, 0x43, 0x00, 0x25, 0x40, 0x44, 0x00, 0x10, 0x00, 0x08, 0xAE,
+0xD4, 0x23, 0xA3, 0x8C, 0x7F, 0xF8, 0x02, 0x24, 0x24, 0x10, 0x02, 0x01,
+0x80, 0x07, 0x63, 0x30, 0x25, 0x40, 0x43, 0x00, 0x10, 0x00, 0x08, 0xAE,
+0xC6, 0x3D, 0xE2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x40, 0x14,
+0x60, 0x1B, 0x25, 0x26, 0x42, 0x17, 0x09, 0x00, 0x01, 0x00, 0x44, 0x30,
+0x08, 0x01, 0x8A, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x24, 0x26,
+0x21, 0x20, 0xC4, 0x00, 0xD4, 0x23, 0x83, 0x8C, 0xFF, 0xF7, 0x02, 0x24,
+0x24, 0x10, 0x02, 0x01, 0x00, 0x08, 0x63, 0x30, 0x25, 0x40, 0x43, 0x00,
+0x10, 0x00, 0x08, 0xAE, 0xD4, 0x23, 0x83, 0x8C, 0xFF, 0xEF, 0x02, 0x24,
+0x24, 0x10, 0x02, 0x01, 0x00, 0x10, 0x63, 0x30, 0x25, 0x40, 0x43, 0x00,
+0x10, 0x00, 0x08, 0xAE, 0x60, 0x1B, 0x25, 0x26, 0x21, 0x30, 0xC5, 0x00,
+0xD4, 0x23, 0xC4, 0x8C, 0xFD, 0xFF, 0x02, 0x3C, 0x02, 0x00, 0x03, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x83, 0x00, 0x24, 0x10, 0x02, 0x01,
+0x25, 0x40, 0x44, 0x00, 0x10, 0x00, 0x08, 0xAE, 0xB0, 0x1B, 0xA3, 0x94,
+0xFB, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0xC2, 0x1B, 0x03, 0x00,
+0x24, 0x10, 0x02, 0x01, 0x80, 0x1C, 0x03, 0x00, 0x25, 0x40, 0x43, 0x00,
+0x10, 0x00, 0x08, 0xAE, 0x3B, 0x41, 0xA3, 0x90, 0xE7, 0xFF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x03, 0x00, 0x63, 0x30, 0x24, 0x10, 0x02, 0x01,
+0xC0, 0x1C, 0x03, 0x00, 0x25, 0x40, 0x43, 0x00, 0x10, 0x00, 0x08, 0xAE,
+0xD4, 0x23, 0xC4, 0x8C, 0xFF, 0xFD, 0x02, 0x3C, 0x00, 0x02, 0x03, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x83, 0x00, 0x24, 0x10, 0x02, 0x01,
+0x25, 0x40, 0x44, 0x00, 0x10, 0x00, 0x08, 0xAE, 0xB0, 0x1B, 0xA3, 0x94,
+0xFF, 0xFB, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0xC2, 0x1B, 0x03, 0x00,
+0x24, 0x10, 0x02, 0x01, 0x80, 0x1E, 0x03, 0x00, 0x25, 0x40, 0x43, 0x00,
+0x10, 0x00, 0x08, 0xAE, 0x3B, 0x41, 0xA3, 0x90, 0xFF, 0xE7, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x03, 0x00, 0x63, 0x30, 0x24, 0x10, 0x02, 0x01,
+0xC0, 0x1E, 0x03, 0x00, 0x25, 0x40, 0x43, 0x00, 0x10, 0x00, 0x08, 0xAE,
+0xD4, 0x23, 0xC3, 0x8C, 0xC0, 0xFF, 0x02, 0x24, 0x24, 0x10, 0x02, 0x01,
+0x3F, 0x00, 0x63, 0x30, 0x25, 0x10, 0x43, 0x00, 0x10, 0x00, 0x02, 0xAE,
+0xD8, 0x23, 0xC4, 0x8C, 0x14, 0x00, 0x03, 0x8E, 0xFF, 0xFF, 0x02, 0x3C,
+0xFF, 0x7F, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00, 0x00, 0x80, 0x84, 0x30,
+0x25, 0x18, 0x64, 0x00, 0x14, 0x00, 0x03, 0xAE, 0xDA, 0x23, 0xC4, 0x94,
+0xE0, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x1F, 0x00, 0x84, 0x30,
+0x24, 0x18, 0x62, 0x00, 0x00, 0x24, 0x04, 0x00, 0x25, 0x18, 0x64, 0x00,
+0x14, 0x00, 0x03, 0xAE, 0x02, 0x00, 0x02, 0x92, 0x02, 0x24, 0x0B, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x21, 0x10, 0x4C, 0x00, 0xFF, 0xFF, 0x42, 0x30,
+0x01, 0x00, 0x84, 0x30, 0x36, 0x00, 0x80, 0x10, 0x25, 0x30, 0x43, 0x00,
+0x60, 0x1B, 0x24, 0x26, 0xE4, 0x1D, 0x85, 0x94, 0x80, 0x00, 0x07, 0x24,
+0x01, 0x00, 0xA2, 0x24, 0xE4, 0x1D, 0x82, 0xA4, 0x0C, 0x00, 0x03, 0x8E,
+0x00, 0xF0, 0x02, 0x3C, 0xFF, 0x0F, 0xA5, 0x30, 0xFF, 0xFF, 0x42, 0x34,
+0x00, 0x24, 0x05, 0x00, 0x24, 0x18, 0x62, 0x00, 0x25, 0x18, 0x64, 0x00,
+0x0C, 0x00, 0x03, 0xAE, 0x16, 0x00, 0xC2, 0x94, 0x00, 0x19, 0x05, 0x00,
+0x02, 0x00, 0x04, 0x24, 0x0F, 0x00, 0x42, 0x30, 0x25, 0x10, 0x43, 0x00,
+0x16, 0x00, 0xC2, 0xA4, 0x21, 0x28, 0x80, 0x01, 0x21, 0x30, 0x40, 0x02,
+0x01, 0x00, 0x02, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x52, 0xAC,
+0x5B, 0x01, 0x00, 0x0C, 0x02, 0x00, 0x04, 0x24, 0x60, 0x1B, 0x24, 0x26,
+0x00, 0x00, 0x03, 0x96, 0x40, 0x41, 0x82, 0x8C, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x43, 0x00, 0x28, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03,
+0x40, 0x41, 0x82, 0xAC, 0x14, 0x00, 0x02, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x42, 0x12, 0x02, 0x00, 0x3F, 0x00, 0x42, 0x30, 0x0C, 0x00, 0x42, 0x28,
+0x2C, 0xFF, 0x40, 0x10, 0xFF, 0xDF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x48, 0x22, 0x01, 0x00, 0x40, 0x03, 0x3C, 0x25, 0x48, 0x23, 0x01,
+0xFC, 0x02, 0x00, 0x08, 0x02, 0x80, 0x11, 0x3C, 0x60, 0x1B, 0x23, 0x26,
+0xC6, 0x3D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x40, 0x14,
+0x80, 0x00, 0x07, 0x24, 0x0E, 0x00, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x42, 0x30, 0x40, 0x10, 0x02, 0x00, 0x21, 0x10, 0x43, 0x00,
+0xD4, 0x1D, 0x45, 0x94, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xA3, 0x24,
+0xD4, 0x1D, 0x43, 0xA4, 0x0C, 0x00, 0x04, 0x8E, 0x00, 0xF0, 0x02, 0x3C,
+0xFF, 0x0F, 0xA5, 0x30, 0xFF, 0xFF, 0x42, 0x34, 0x00, 0x1C, 0x05, 0x00,
+0x24, 0x20, 0x82, 0x00, 0x25, 0x20, 0x83, 0x00, 0x0C, 0x00, 0x04, 0xAE,
+0x16, 0x00, 0xC2, 0x94, 0x00, 0x19, 0x05, 0x00, 0x02, 0x00, 0x04, 0x24,
+0x0F, 0x00, 0x42, 0x30, 0x25, 0x10, 0x43, 0x00, 0x16, 0x00, 0xC2, 0xA4,
+0x21, 0x28, 0x80, 0x01, 0x21, 0x30, 0x40, 0x02, 0x01, 0x00, 0x02, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x52, 0xAC, 0x5B, 0x01, 0x00, 0x0C,
+0x02, 0x00, 0x04, 0x24, 0x60, 0x1B, 0x24, 0x26, 0x00, 0x00, 0x03, 0x96,
+0x40, 0x41, 0x82, 0x8C, 0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x43, 0x00,
+0x28, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03, 0x40, 0x41, 0x82, 0xAC,
+0x7F, 0xFF, 0x02, 0x24, 0x24, 0x10, 0x22, 0x01, 0x80, 0x00, 0x63, 0x30,
+0x25, 0x48, 0x43, 0x00, 0x08, 0x00, 0x09, 0xAE, 0x08, 0x25, 0xA3, 0x8C,
+0x10, 0x00, 0x04, 0x8E, 0xFF, 0xFF, 0x02, 0x3C, 0x07, 0x00, 0x63, 0x30,
+0xFF, 0x1F, 0x42, 0x34, 0x24, 0x20, 0x82, 0x00, 0x40, 0x1B, 0x03, 0x00,
+0x25, 0x40, 0x83, 0x00, 0x0E, 0x03, 0x00, 0x08, 0x10, 0x00, 0x08, 0xAE,
+0x1E, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x21, 0x30, 0x50, 0x00,
+0x00, 0x00, 0xC4, 0x90, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x82, 0x30,
+0x02, 0x29, 0x02, 0x00, 0x3F, 0x00, 0xA3, 0x10, 0x06, 0x00, 0x02, 0x24,
+0xF4, 0xFE, 0xA2, 0x14, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x02, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0xC2, 0xA0, 0x1E, 0x00, 0x03, 0x92,
+0x1A, 0x00, 0x02, 0x96, 0x21, 0x18, 0x70, 0x00, 0x03, 0x12, 0x02, 0x00,
+0x38, 0x00, 0x62, 0xA0, 0x04, 0x00, 0x0B, 0x8E, 0x08, 0x00, 0x09, 0x8E,
+0x02, 0x03, 0x00, 0x08, 0xC0, 0x30, 0x0A, 0x00, 0x0E, 0x00, 0x02, 0x96,
+0x02, 0x00, 0x04, 0x24, 0xFF, 0x0F, 0x45, 0x30, 0x16, 0x00, 0xC2, 0x94,
+0x00, 0x19, 0x05, 0x00, 0x21, 0x28, 0x80, 0x01, 0x0F, 0x00, 0x42, 0x30,
+0x25, 0x10, 0x43, 0x00, 0x16, 0x00, 0xC2, 0xA4, 0x21, 0x30, 0x40, 0x02,
+0x01, 0x00, 0x02, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x52, 0xAC,
+0x5B, 0x01, 0x00, 0x0C, 0x02, 0x00, 0x04, 0x24, 0x60, 0x1B, 0x24, 0x26,
+0x00, 0x00, 0x03, 0x96, 0x40, 0x41, 0x82, 0x8C, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x43, 0x00, 0x28, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03,
+0x40, 0x41, 0x82, 0xAC, 0xCE, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xF7, 0xFE, 0x64, 0x14, 0x60, 0x1B, 0x24, 0x26, 0x3C, 0x41, 0xE2, 0x90,
+0xFF, 0xF7, 0x03, 0x24, 0x24, 0x18, 0x03, 0x01, 0x01, 0x00, 0x42, 0x30,
+0xC0, 0x12, 0x02, 0x00, 0x25, 0x40, 0x62, 0x00, 0x10, 0x00, 0x08, 0xAE,
+0x3D, 0x41, 0xE2, 0x90, 0xFF, 0xEF, 0x03, 0x24, 0x24, 0x18, 0x03, 0x01,
+0x01, 0x00, 0x42, 0x30, 0x00, 0x13, 0x02, 0x00, 0x25, 0x40, 0x43, 0x00,
+0x3E, 0x03, 0x00, 0x08, 0x10, 0x00, 0x08, 0xAE, 0x1A, 0x00, 0x05, 0x96,
+0x0F, 0x00, 0x84, 0x30, 0x80, 0x20, 0x04, 0x00, 0x21, 0x18, 0xC4, 0x00,
+0x11, 0x00, 0x65, 0xA0, 0x1E, 0x00, 0x02, 0x92, 0x1A, 0x00, 0x03, 0x96,
+0x21, 0x10, 0x50, 0x00, 0x21, 0x10, 0x44, 0x00, 0x03, 0x1A, 0x03, 0x00,
+0x10, 0x00, 0x43, 0xA0, 0x04, 0x00, 0x0B, 0x8E, 0x08, 0x00, 0x09, 0x8E,
+0x02, 0x03, 0x00, 0x08, 0xC0, 0x30, 0x0A, 0x00, 0x00, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x64, 0x11, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xC0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x2C, 0x00, 0xB5, 0xAF,
+0x25, 0xB0, 0x03, 0x3C, 0x60, 0x1B, 0x55, 0x24, 0x00, 0x80, 0x02, 0x3C,
+0x38, 0x00, 0xBE, 0xAF, 0x80, 0x11, 0x42, 0x24, 0xB0, 0x03, 0x7E, 0x34,
+0x18, 0x03, 0x63, 0x34, 0x00, 0x00, 0x62, 0xAC, 0x3C, 0x00, 0xBF, 0xAF,
+0x34, 0x00, 0xB7, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x28, 0x00, 0xB4, 0xAF,
+0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x96, 0x40, 0x00, 0x0C, 0x18, 0x00, 0xB0, 0xAF, 0x8E, 0x04, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0xAE, 0x08, 0x38, 0x46, 0x8E,
+0x21, 0x28, 0x60, 0x02, 0x80, 0x00, 0x07, 0x24, 0x01, 0x00, 0x04, 0x24,
+0x01, 0x00, 0x14, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xB4, 0xAF,
+0x08, 0x38, 0x43, 0x8E, 0x01, 0x00, 0x04, 0x24, 0x00, 0x00, 0xC3, 0xAE,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x1C, 0x42, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x40, 0x10, 0x2A, 0xB0, 0x02, 0x3C,
+0x09, 0x00, 0x42, 0x34, 0x02, 0x00, 0x03, 0x24, 0x00, 0x00, 0x54, 0xA0,
+0x00, 0x00, 0x43, 0xA0, 0xFF, 0x00, 0x03, 0x24, 0x71, 0x00, 0x23, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x38, 0xA2, 0x8E, 0x70, 0x38, 0xB3, 0x8E,
+0x01, 0x00, 0x04, 0x24, 0x00, 0x00, 0xC2, 0xAF, 0x08, 0x38, 0xA2, 0xAE,
+0x00, 0x00, 0xD3, 0xAF, 0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x70, 0x38, 0xA4, 0x8E, 0x74, 0x38, 0xA3, 0x8E, 0x02, 0x80, 0x02, 0x3C,
+0xB4, 0xE6, 0x42, 0x24, 0x00, 0x00, 0x52, 0x8C, 0x80, 0x00, 0x84, 0x24,
+0xFF, 0x00, 0x62, 0x24, 0x2B, 0x10, 0x44, 0x00, 0x0A, 0x18, 0x82, 0x00,
+0x70, 0x38, 0xA3, 0xAE, 0x02, 0x80, 0x03, 0x3C, 0xB8, 0xE6, 0x63, 0x24,
+0x70, 0x38, 0x42, 0x8E, 0x00, 0x00, 0x76, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC2, 0xAE, 0x02, 0x80, 0x17, 0x3C, 0xFF, 0xFF, 0x62, 0x32,
+0x25, 0x80, 0x57, 0x00, 0x00, 0x00, 0xD0, 0xAE, 0x0C, 0x00, 0x02, 0x92,
+0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0xC2, 0xAE, 0x02, 0x00, 0x04, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x93, 0x00, 0xFF, 0xFF, 0x84, 0x30,
+0xE0, 0x61, 0x00, 0x0C, 0x25, 0x20, 0x97, 0x00, 0x0C, 0x00, 0x11, 0x92,
+0x20, 0x10, 0x02, 0x3C, 0x01, 0x00, 0x04, 0x24, 0x00, 0x1A, 0x11, 0x00,
+0x21, 0x18, 0x62, 0x00, 0xFF, 0x00, 0x02, 0x24, 0x21, 0x30, 0x60, 0x00,
+0x06, 0x00, 0x22, 0x12, 0x80, 0x00, 0x07, 0x24, 0x70, 0x38, 0x45, 0x8E,
+0x04, 0x38, 0x43, 0xAE, 0xA8, 0x37, 0x51, 0xA2, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x04, 0x00, 0x04, 0x8E, 0x08, 0x00, 0x03, 0x8E,
+0xFF, 0xE0, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x1F, 0x00, 0x84, 0x30,
+0x24, 0x18, 0x62, 0x00, 0x00, 0x26, 0x04, 0x00, 0xFF, 0xDF, 0x02, 0x3C,
+0x25, 0x18, 0x64, 0x00, 0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x40, 0x04, 0x3C, 0x25, 0x18, 0x64, 0x00, 0xC0, 0xFF, 0x05, 0x24,
+0x82, 0x11, 0x03, 0x00, 0x24, 0x20, 0x65, 0x00, 0x01, 0x00, 0x42, 0x30,
+0xA3, 0xFF, 0x40, 0x10, 0x04, 0x00, 0x84, 0x34, 0x08, 0x00, 0x03, 0xAE,
+0x08, 0x38, 0x46, 0x8E, 0x21, 0x28, 0x60, 0x02, 0x80, 0x00, 0x07, 0x24,
+0x01, 0x00, 0x04, 0x24, 0x01, 0x00, 0x14, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xB4, 0xAF, 0x08, 0x38, 0x43, 0x8E, 0x01, 0x00, 0x04, 0x24,
+0x00, 0x00, 0xC3, 0xAE, 0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x2A, 0x1C, 0x42, 0x92, 0x00, 0x00, 0x00, 0x00, 0xA3, 0xFF, 0x40, 0x14,
+0x2A, 0xB0, 0x02, 0x3C, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x2A, 0x1C, 0x54, 0xA2, 0x02, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0x53, 0x00, 0xFF, 0xFF, 0x42, 0x30, 0x25, 0x10, 0x57, 0x00,
+0x02, 0x00, 0x43, 0x94, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x64, 0x30,
+0x00, 0xC0, 0x84, 0x24, 0x2B, 0x1C, 0x43, 0xA2, 0xA3, 0x31, 0x00, 0x0C,
+0xFF, 0xFF, 0x84, 0x30, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x2A, 0xB0, 0x02, 0x3C, 0x09, 0x00, 0x42, 0x34, 0x02, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x54, 0xA0, 0x00, 0x00, 0x43, 0xA0, 0xFF, 0x00, 0x03, 0x24,
+0x91, 0xFF, 0x23, 0x16, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x62, 0x24,
+0xD0, 0x1B, 0x43, 0x8C, 0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F,
+0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x00, 0x38, 0x63, 0x34,
+0x41, 0xB0, 0x04, 0x3C, 0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x83, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0x43, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x4C, 0x14, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xC0, 0xFF, 0xBD, 0x27, 0x34, 0x00, 0xB7, 0xAF, 0x3C, 0x00, 0xBF, 0xAF,
+0x38, 0x00, 0xBE, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x06, 0x3C,
+0xC0, 0x5D, 0xC5, 0x90, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x18, 0x03, 0x42, 0x34, 0x68, 0x14, 0x63, 0x24, 0x40, 0x00, 0xA4, 0x30,
+0x00, 0x00, 0x43, 0xAC, 0x21, 0xB8, 0x00, 0x00, 0x03, 0x00, 0x80, 0x10,
+0x7F, 0x00, 0xA2, 0x30, 0xBF, 0x00, 0xA2, 0x30, 0x01, 0x00, 0x17, 0x24,
+0xC0, 0x5D, 0xC2, 0xA0, 0x96, 0x40, 0x00, 0x0C, 0x02, 0x80, 0x1E, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x60, 0x1B, 0xD3, 0x27, 0xB0, 0x03, 0x55, 0x34,
+0x59, 0x05, 0x00, 0x08, 0x02, 0x80, 0x16, 0x3C, 0x84, 0x37, 0x91, 0xA2,
+0x60, 0x1B, 0xC2, 0x27, 0xBC, 0x37, 0x46, 0x8C, 0x28, 0x38, 0x45, 0x8C,
+0x03, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x60, 0x1B, 0xD4, 0x27, 0xC0, 0x37, 0x85, 0x8E,
+0x21, 0x20, 0x00, 0x02, 0xD4, 0x02, 0x00, 0x0C, 0x21, 0x30, 0x40, 0x02,
+0x2A, 0xB0, 0x07, 0x3C, 0x0D, 0x00, 0xE2, 0x34, 0x04, 0x00, 0x43, 0x24,
+0x0B, 0x10, 0x77, 0x00, 0x01, 0x00, 0x04, 0x24, 0x02, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x44, 0xA0, 0x00, 0x00, 0x43, 0xA0, 0x0C, 0x5D, 0xC4, 0x96,
+0x25, 0xB0, 0x06, 0x3C, 0x66, 0x03, 0xC5, 0x34, 0x01, 0x00, 0x84, 0x24,
+0x0C, 0x5D, 0xC4, 0xA6, 0x0C, 0x5D, 0xC2, 0x96, 0xFF, 0x00, 0x03, 0x24,
+0x00, 0x00, 0xA2, 0xA4, 0x2F, 0x00, 0x23, 0x12, 0x00, 0x00, 0x00, 0x00,
+0xBC, 0x37, 0x62, 0x8E, 0x28, 0x38, 0x72, 0x8E, 0x03, 0x00, 0x04, 0x24,
+0x00, 0x00, 0xA2, 0xAE, 0xC0, 0x37, 0x62, 0xAE, 0x00, 0x00, 0xB2, 0xAE,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x28, 0x38, 0x64, 0x8E,
+0x2C, 0x38, 0x63, 0x8E, 0x02, 0x80, 0x02, 0x3C, 0xBC, 0xE6, 0x42, 0x24,
+0x00, 0x00, 0x54, 0x8C, 0x80, 0x00, 0x84, 0x24, 0xFF, 0x00, 0x62, 0x24,
+0x2B, 0x10, 0x44, 0x00, 0x0A, 0x18, 0x82, 0x00, 0x28, 0x38, 0x63, 0xAE,
+0x28, 0x38, 0x82, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xAE,
+0x02, 0x80, 0x03, 0x3C, 0xFF, 0xFF, 0x42, 0x32, 0x25, 0x80, 0x43, 0x00,
+0x00, 0x00, 0xB0, 0xAE, 0x0C, 0x00, 0x02, 0x92, 0x01, 0x00, 0x05, 0x24,
+0x00, 0x00, 0xA2, 0xAE, 0x02, 0x00, 0x04, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x20, 0x92, 0x00, 0xFF, 0xFF, 0x84, 0x30, 0xE0, 0x61, 0x00, 0x0C,
+0x25, 0x20, 0x83, 0x00, 0x0C, 0x00, 0x11, 0x92, 0x20, 0x10, 0x02, 0x3C,
+0xFF, 0x00, 0x03, 0x24, 0x00, 0x22, 0x11, 0x00, 0xC2, 0xFF, 0x23, 0x12,
+0x21, 0x20, 0x82, 0x00, 0xB8, 0xFF, 0xE0, 0x16, 0xBC, 0x37, 0x84, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x3B, 0x05, 0x00, 0x08,
+0x80, 0x37, 0x51, 0xA0, 0x1E, 0x00, 0xE0, 0x12, 0x40, 0x00, 0xE4, 0x34,
+0x84, 0x37, 0x83, 0x92, 0x41, 0x00, 0xE4, 0x34, 0xB0, 0x03, 0xC5, 0x34,
+0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC, 0x96, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA4, 0x8C, 0x01, 0x00, 0x02, 0x3C,
+0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x00, 0x80, 0x42, 0x34, 0x25, 0x20, 0x82, 0x00,
+0x41, 0xB0, 0x03, 0x3C, 0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x64, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA4, 0xAC, 0x80, 0x37, 0x83, 0x92,
+0xB0, 0x03, 0xC5, 0x34, 0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC,
+0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA4, 0x8C,
+0x01, 0x00, 0x02, 0x3C, 0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F,
+0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x00, 0x80, 0x42, 0x34,
+0x25, 0x20, 0x82, 0x00, 0x41, 0xB0, 0x03, 0x3C, 0x40, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0x64, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA4, 0xAC,
+0xC0, 0xFF, 0xBD, 0x27, 0x34, 0x00, 0xB7, 0xAF, 0x3C, 0x00, 0xBF, 0xAF,
+0x38, 0x00, 0xBE, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x06, 0x3C,
+0xC0, 0x5D, 0xC5, 0x90, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x18, 0x03, 0x42, 0x34, 0x08, 0x17, 0x63, 0x24, 0x10, 0x00, 0xA4, 0x30,
+0x00, 0x00, 0x43, 0xAC, 0x21, 0xB8, 0x00, 0x00, 0x03, 0x00, 0x80, 0x10,
+0xDF, 0x00, 0xA2, 0x30, 0xEF, 0x00, 0xA2, 0x30, 0x01, 0x00, 0x17, 0x24,
+0xC0, 0x5D, 0xC2, 0xA0, 0xC0, 0x5D, 0xC3, 0x90, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x02, 0x80, 0x1E, 0x3C,
+0x00, 0x00, 0x43, 0xAC, 0x21, 0xA8, 0x40, 0x00, 0x96, 0x40, 0x00, 0x0C,
+0x60, 0x1B, 0xD3, 0x27, 0x05, 0x06, 0x00, 0x08, 0x02, 0x80, 0x16, 0x3C,
+0x8C, 0x37, 0x91, 0xA2, 0x60, 0x1B, 0xC2, 0x27, 0xC8, 0x37, 0x46, 0x8C,
+0x34, 0x38, 0x45, 0x8C, 0x04, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x60, 0x1B, 0xD4, 0x27,
+0xCC, 0x37, 0x85, 0x8E, 0x21, 0x20, 0x00, 0x02, 0xD4, 0x02, 0x00, 0x0C,
+0x21, 0x30, 0x40, 0x02, 0x2A, 0xB0, 0x07, 0x3C, 0x15, 0x00, 0xE2, 0x34,
+0x04, 0x00, 0x43, 0x24, 0x0B, 0x10, 0x77, 0x00, 0x01, 0x00, 0x04, 0x24,
+0x02, 0x00, 0x03, 0x24, 0x00, 0x00, 0x44, 0xA0, 0x00, 0x00, 0x43, 0xA0,
+0x0C, 0x5D, 0xC4, 0x96, 0x25, 0xB0, 0x06, 0x3C, 0x66, 0x03, 0xC5, 0x34,
+0x01, 0x00, 0x84, 0x24, 0x0C, 0x5D, 0xC4, 0xA6, 0x0C, 0x5D, 0xC2, 0x96,
+0xFF, 0x00, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xA4, 0x2F, 0x00, 0x23, 0x12,
+0x00, 0x00, 0x00, 0x00, 0xC8, 0x37, 0x62, 0x8E, 0x34, 0x38, 0x72, 0x8E,
+0x04, 0x00, 0x04, 0x24, 0x00, 0x00, 0xA2, 0xAE, 0xCC, 0x37, 0x62, 0xAE,
+0x00, 0x00, 0xB2, 0xAE, 0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x34, 0x38, 0x64, 0x8E, 0x38, 0x38, 0x63, 0x8E, 0x02, 0x80, 0x02, 0x3C,
+0xC0, 0xE6, 0x42, 0x24, 0x00, 0x00, 0x54, 0x8C, 0x80, 0x00, 0x84, 0x24,
+0xFF, 0x00, 0x62, 0x24, 0x2B, 0x10, 0x44, 0x00, 0x0A, 0x18, 0x82, 0x00,
+0x34, 0x38, 0x63, 0xAE, 0x34, 0x38, 0x82, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xA2, 0xAE, 0x02, 0x80, 0x03, 0x3C, 0xFF, 0xFF, 0x42, 0x32,
+0x25, 0x80, 0x43, 0x00, 0x00, 0x00, 0xB0, 0xAE, 0x0C, 0x00, 0x02, 0x92,
+0x02, 0x00, 0x05, 0x24, 0x00, 0x00, 0xA2, 0xAE, 0x02, 0x00, 0x04, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x92, 0x00, 0xFF, 0xFF, 0x84, 0x30,
+0xE0, 0x61, 0x00, 0x0C, 0x25, 0x20, 0x83, 0x00, 0x0C, 0x00, 0x11, 0x92,
+0x20, 0x10, 0x02, 0x3C, 0xFF, 0x00, 0x03, 0x24, 0x00, 0x22, 0x11, 0x00,
+0xC2, 0xFF, 0x23, 0x12, 0x21, 0x20, 0x82, 0x00, 0xB8, 0xFF, 0xE0, 0x16,
+0xC8, 0x37, 0x84, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0xE7, 0x05, 0x00, 0x08, 0x88, 0x37, 0x51, 0xA0, 0x1D, 0x00, 0xE0, 0x12,
+0x42, 0x00, 0xE4, 0x34, 0x8C, 0x37, 0x83, 0x92, 0x43, 0x00, 0xE4, 0x34,
+0xB0, 0x03, 0xC5, 0x34, 0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC,
+0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA2, 0x8C,
+0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x06, 0x00, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00,
+0x41, 0xB0, 0x04, 0x3C, 0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x82, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA2, 0xAC, 0x88, 0x37, 0x83, 0x92,
+0xB0, 0x03, 0xC5, 0x34, 0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC,
+0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA2, 0x8C,
+0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x06, 0x00, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00,
+0x41, 0xB0, 0x04, 0x3C, 0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x82, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA2, 0xAC, 0xC0, 0xFF, 0xBD, 0x27,
+0x34, 0x00, 0xB7, 0xAF, 0x3C, 0x00, 0xBF, 0xAF, 0x38, 0x00, 0xBE, 0xAF,
+0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF, 0x28, 0x00, 0xB4, 0xAF,
+0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x06, 0x3C, 0xC0, 0x5D, 0xC5, 0x90,
+0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C, 0x18, 0x03, 0x42, 0x34,
+0xB0, 0x19, 0x63, 0x24, 0x01, 0x00, 0xA4, 0x30, 0x00, 0x00, 0x43, 0xAC,
+0x21, 0xB8, 0x00, 0x00, 0x03, 0x00, 0x80, 0x10, 0xF7, 0x00, 0xA2, 0x30,
+0xFE, 0x00, 0xA2, 0x30, 0x01, 0x00, 0x17, 0x24, 0xC0, 0x5D, 0xC2, 0xA0,
+0xC0, 0x5D, 0xC3, 0x90, 0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34,
+0x02, 0x80, 0x1E, 0x3C, 0x00, 0x00, 0x43, 0xAC, 0x21, 0xA8, 0x40, 0x00,
+0x96, 0x40, 0x00, 0x0C, 0x60, 0x1B, 0xD3, 0x27, 0xAE, 0x06, 0x00, 0x08,
+0x02, 0x80, 0x16, 0x3C, 0x9C, 0x37, 0x91, 0xA2, 0x60, 0x1B, 0xC2, 0x27,
+0xD4, 0x37, 0x46, 0x8C, 0x40, 0x38, 0x45, 0x8C, 0x05, 0x00, 0x04, 0x24,
+0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF,
+0x60, 0x1B, 0xD4, 0x27, 0xD8, 0x37, 0x85, 0x8E, 0x21, 0x20, 0x00, 0x02,
+0xD4, 0x02, 0x00, 0x0C, 0x21, 0x30, 0x40, 0x02, 0x2A, 0xB0, 0x07, 0x3C,
+0x1D, 0x00, 0xE2, 0x34, 0x04, 0x00, 0x43, 0x24, 0x0B, 0x10, 0x77, 0x00,
+0x01, 0x00, 0x04, 0x24, 0x02, 0x00, 0x03, 0x24, 0x00, 0x00, 0x44, 0xA0,
+0x00, 0x00, 0x43, 0xA0, 0x0C, 0x5D, 0xC4, 0x96, 0x25, 0xB0, 0x06, 0x3C,
+0x66, 0x03, 0xC5, 0x34, 0x01, 0x00, 0x84, 0x24, 0x0C, 0x5D, 0xC4, 0xA6,
+0x0C, 0x5D, 0xC2, 0x96, 0xFF, 0x00, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xA4,
+0x2F, 0x00, 0x23, 0x12, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x37, 0x62, 0x8E,
+0x40, 0x38, 0x72, 0x8E, 0x05, 0x00, 0x04, 0x24, 0x00, 0x00, 0xA2, 0xAE,
+0xD8, 0x37, 0x62, 0xAE, 0x00, 0x00, 0xB2, 0xAE, 0x5B, 0x01, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x40, 0x38, 0x64, 0x8E, 0x44, 0x38, 0x63, 0x8E,
+0x02, 0x80, 0x02, 0x3C, 0xC4, 0xE6, 0x42, 0x24, 0x00, 0x00, 0x54, 0x8C,
+0x80, 0x00, 0x84, 0x24, 0xFF, 0x00, 0x62, 0x24, 0x2B, 0x10, 0x44, 0x00,
+0x0A, 0x18, 0x82, 0x00, 0x40, 0x38, 0x63, 0xAE, 0x40, 0x38, 0x82, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xAE, 0x02, 0x80, 0x03, 0x3C,
+0xFF, 0xFF, 0x42, 0x32, 0x25, 0x80, 0x43, 0x00, 0x00, 0x00, 0xB0, 0xAE,
+0x0C, 0x00, 0x02, 0x92, 0x08, 0x00, 0x05, 0x24, 0x00, 0x00, 0xA2, 0xAE,
+0x02, 0x00, 0x04, 0x92, 0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x92, 0x00,
+0xFF, 0xFF, 0x84, 0x30, 0xE0, 0x61, 0x00, 0x0C, 0x25, 0x20, 0x83, 0x00,
+0x0C, 0x00, 0x11, 0x92, 0x20, 0x10, 0x02, 0x3C, 0xFF, 0x00, 0x03, 0x24,
+0x00, 0x22, 0x11, 0x00, 0xC2, 0xFF, 0x23, 0x12, 0x21, 0x20, 0x82, 0x00,
+0xB8, 0xFF, 0xE0, 0x16, 0xD4, 0x37, 0x84, 0xAE, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x42, 0x24, 0x90, 0x06, 0x00, 0x08, 0x90, 0x37, 0x51, 0xA0,
+0x1D, 0x00, 0xE0, 0x12, 0x44, 0x00, 0xE4, 0x34, 0x9C, 0x37, 0x83, 0x92,
+0x45, 0x00, 0xE4, 0x34, 0xB0, 0x03, 0xC5, 0x34, 0x00, 0x00, 0x83, 0xA0,
+0x00, 0x00, 0xA3, 0xAC, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xC5, 0x27,
+0xD0, 0x1B, 0xA2, 0x8C, 0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F,
+0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x18, 0x00, 0x03, 0x3C,
+0x25, 0x10, 0x43, 0x00, 0x41, 0xB0, 0x04, 0x3C, 0x40, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0x82, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA2, 0xAC,
+0x90, 0x37, 0x83, 0x92, 0xB0, 0x03, 0xC5, 0x34, 0x00, 0x00, 0x83, 0xA0,
+0x00, 0x00, 0xA3, 0xAC, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xC5, 0x27,
+0xD0, 0x1B, 0xA2, 0x8C, 0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F,
+0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x18, 0x00, 0x03, 0x3C,
+0x25, 0x10, 0x43, 0x00, 0x41, 0xB0, 0x04, 0x3C, 0x40, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0x82, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA2, 0xAC,
+0xC0, 0xFF, 0xBD, 0x27, 0x34, 0x00, 0xB7, 0xAF, 0x3C, 0x00, 0xBF, 0xAF,
+0x38, 0x00, 0xBE, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x06, 0x3C,
+0xC0, 0x5D, 0xC5, 0x90, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x18, 0x03, 0x42, 0x34, 0x54, 0x1C, 0x63, 0x24, 0x02, 0x00, 0xA4, 0x30,
+0x00, 0x00, 0x43, 0xAC, 0x21, 0xB8, 0x00, 0x00, 0x03, 0x00, 0x80, 0x10,
+0xFB, 0x00, 0xA2, 0x30, 0xFD, 0x00, 0xA2, 0x30, 0x01, 0x00, 0x17, 0x24,
+0xC0, 0x5D, 0xC2, 0xA0, 0xC0, 0x5D, 0xC3, 0x90, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0x02, 0x80, 0x1E, 0x3C, 0x00, 0x00, 0x43, 0xAC,
+0x21, 0xA8, 0x40, 0x00, 0x96, 0x40, 0x00, 0x0C, 0x60, 0x1B, 0xD3, 0x27,
+0x57, 0x07, 0x00, 0x08, 0x02, 0x80, 0x16, 0x3C, 0x98, 0x37, 0x91, 0xA2,
+0x60, 0x1B, 0xC2, 0x27, 0xE0, 0x37, 0x46, 0x8C, 0x4C, 0x38, 0x45, 0x8C,
+0x06, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x60, 0x1B, 0xD4, 0x27, 0xE4, 0x37, 0x85, 0x8E,
+0x21, 0x20, 0x00, 0x02, 0xD4, 0x02, 0x00, 0x0C, 0x21, 0x30, 0x40, 0x02,
+0x2A, 0xB0, 0x07, 0x3C, 0x25, 0x00, 0xE2, 0x34, 0x04, 0x00, 0x43, 0x24,
+0x0B, 0x10, 0x77, 0x00, 0x01, 0x00, 0x04, 0x24, 0x02, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x44, 0xA0, 0x00, 0x00, 0x43, 0xA0, 0x0C, 0x5D, 0xC4, 0x96,
+0x25, 0xB0, 0x06, 0x3C, 0x66, 0x03, 0xC5, 0x34, 0x01, 0x00, 0x84, 0x24,
+0x0C, 0x5D, 0xC4, 0xA6, 0x0C, 0x5D, 0xC2, 0x96, 0xFF, 0x00, 0x03, 0x24,
+0x00, 0x00, 0xA2, 0xA4, 0x2F, 0x00, 0x23, 0x12, 0x00, 0x00, 0x00, 0x00,
+0xE0, 0x37, 0x62, 0x8E, 0x4C, 0x38, 0x72, 0x8E, 0x06, 0x00, 0x04, 0x24,
+0x00, 0x00, 0xA2, 0xAE, 0xE4, 0x37, 0x62, 0xAE, 0x00, 0x00, 0xB2, 0xAE,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x38, 0x64, 0x8E,
+0x50, 0x38, 0x63, 0x8E, 0x02, 0x80, 0x02, 0x3C, 0xC8, 0xE6, 0x42, 0x24,
+0x00, 0x00, 0x54, 0x8C, 0x80, 0x00, 0x84, 0x24, 0xFF, 0x00, 0x62, 0x24,
+0x2B, 0x10, 0x44, 0x00, 0x0A, 0x18, 0x82, 0x00, 0x4C, 0x38, 0x63, 0xAE,
+0x4C, 0x38, 0x82, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xAE,
+0x02, 0x80, 0x03, 0x3C, 0xFF, 0xFF, 0x42, 0x32, 0x25, 0x80, 0x43, 0x00,
+0x00, 0x00, 0xB0, 0xAE, 0x0C, 0x00, 0x02, 0x92, 0x04, 0x00, 0x05, 0x24,
+0x00, 0x00, 0xA2, 0xAE, 0x02, 0x00, 0x04, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x20, 0x92, 0x00, 0xFF, 0xFF, 0x84, 0x30, 0xE0, 0x61, 0x00, 0x0C,
+0x25, 0x20, 0x83, 0x00, 0x0C, 0x00, 0x11, 0x92, 0x20, 0x10, 0x02, 0x3C,
+0xFF, 0x00, 0x03, 0x24, 0x00, 0x22, 0x11, 0x00, 0xC2, 0xFF, 0x23, 0x12,
+0x21, 0x20, 0x82, 0x00, 0xB8, 0xFF, 0xE0, 0x16, 0xE0, 0x37, 0x84, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x39, 0x07, 0x00, 0x08,
+0x94, 0x37, 0x51, 0xA0, 0x1D, 0x00, 0xE0, 0x12, 0x46, 0x00, 0xE4, 0x34,
+0x98, 0x37, 0x83, 0x92, 0x47, 0x00, 0xE4, 0x34, 0xB0, 0x03, 0xC5, 0x34,
+0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC, 0x96, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA2, 0x8C, 0x3C, 0x00, 0xBF, 0x8F,
+0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x60, 0x00, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00, 0x41, 0xB0, 0x04, 0x3C,
+0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x82, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xD0, 0x1B, 0xA2, 0xAC, 0x94, 0x37, 0x83, 0x92, 0xB0, 0x03, 0xC5, 0x34,
+0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xA3, 0xAC, 0x96, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0xC5, 0x27, 0xD0, 0x1B, 0xA2, 0x8C, 0x3C, 0x00, 0xBF, 0x8F,
+0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x60, 0x00, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00, 0x41, 0xB0, 0x04, 0x3C,
+0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x82, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xD0, 0x1B, 0xA2, 0xAC, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0xF8, 0x1E, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34, 0xE8, 0xFF, 0xBD, 0x27,
+0x00, 0x00, 0x43, 0xAC, 0x10, 0x00, 0xBF, 0xAF, 0x96, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24, 0xD8, 0x1B, 0xA2, 0x8C,
+0xD0, 0x1B, 0xA4, 0x8C, 0x00, 0x08, 0x03, 0x3C, 0x10, 0x00, 0xBF, 0x8F,
+0x24, 0x10, 0x43, 0x00, 0x25, 0x20, 0x82, 0x00, 0x41, 0xB0, 0x03, 0x3C,
+0x18, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x64, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xD0, 0x1B, 0xA4, 0xAC, 0xC0, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xB0, 0xAF,
+0x00, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x10, 0x3C, 0x18, 0x03, 0x03, 0x36,
+0x58, 0x1F, 0x42, 0x24, 0x00, 0x00, 0x62, 0xAC, 0x34, 0x00, 0xB5, 0xAF,
+0x02, 0x80, 0x15, 0x3C, 0x38, 0x00, 0xBF, 0xAF, 0x2C, 0x00, 0xB3, 0xAF,
+0x28, 0x00, 0xB2, 0xAF, 0x60, 0x1B, 0xB3, 0x26, 0x24, 0x00, 0xB1, 0xAF,
+0x96, 0x40, 0x00, 0x0C, 0x30, 0x00, 0xB4, 0xAF, 0xFC, 0x00, 0x02, 0x36,
+0x00, 0x00, 0x45, 0x8C, 0xAC, 0x1B, 0x64, 0x96, 0xCC, 0x38, 0x63, 0x96,
+0xC4, 0x38, 0x66, 0x8E, 0x23, 0x28, 0xA4, 0x00, 0x21, 0x10, 0xA3, 0x00,
+0x23, 0x88, 0x46, 0x00, 0x23, 0x20, 0x23, 0x02, 0xB0, 0x03, 0x10, 0x36,
+0x2B, 0x10, 0x71, 0x00, 0x00, 0x00, 0x03, 0xAE, 0x00, 0x00, 0x11, 0xAE,
+0x0B, 0x88, 0x82, 0x00, 0x21, 0x20, 0x20, 0x02, 0x53, 0x21, 0x00, 0x0C,
+0xC8, 0x38, 0x65, 0xAE, 0x21, 0x90, 0x40, 0x00, 0x4D, 0x00, 0x40, 0x10,
+0x18, 0x00, 0xA4, 0x27, 0x0C, 0x00, 0x51, 0xAC, 0xC4, 0x38, 0x68, 0x8E,
+0xC8, 0x38, 0x62, 0x8E, 0x08, 0x00, 0x45, 0x8E, 0x20, 0xBD, 0x03, 0x3C,
+0x88, 0x03, 0x63, 0x34, 0x2B, 0x10, 0x48, 0x00, 0x40, 0x10, 0x14, 0x3C,
+0x21, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0x27, 0x32, 0x00, 0x00, 0x65, 0xAC,
+0x2A, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x1B, 0x66, 0x96,
+0x08, 0x00, 0x42, 0x96, 0x40, 0x10, 0x05, 0x3C, 0x21, 0x20, 0x00, 0x00,
+0x21, 0x30, 0x06, 0x01, 0x25, 0x28, 0x45, 0x00, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x18, 0x00, 0xA4, 0x27,
+0x02, 0x80, 0x02, 0x3C, 0x88, 0x54, 0x42, 0x24, 0x04, 0x00, 0x43, 0x8C,
+0x00, 0x00, 0x42, 0xAE, 0x04, 0x00, 0x52, 0xAC, 0x21, 0x20, 0x00, 0x00,
+0x00, 0x00, 0x72, 0xAC, 0x5B, 0x01, 0x00, 0x0C, 0x04, 0x00, 0x43, 0xAE,
+0x60, 0x1B, 0xA5, 0x26, 0xC8, 0x38, 0xA6, 0x8C, 0xAC, 0x1B, 0xA3, 0x94,
+0x25, 0xB0, 0x02, 0x3C, 0xF8, 0x00, 0x42, 0x34, 0x21, 0x18, 0xC3, 0x00,
+0x00, 0x00, 0x43, 0xAC, 0x18, 0x00, 0xA4, 0x27, 0xC4, 0x38, 0xA6, 0xAC,
+0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0xBF, 0x8F, 0x34, 0x00, 0xB5, 0x8F,
+0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F,
+0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x40, 0x00, 0xBD, 0x27, 0xCC, 0x38, 0x70, 0x8E, 0x08, 0x00, 0x45, 0x96,
+0xAC, 0x1B, 0x66, 0x96, 0x23, 0x80, 0x08, 0x02, 0xFF, 0xFF, 0x10, 0x32,
+0x21, 0x30, 0x06, 0x01, 0x25, 0x28, 0xB4, 0x00, 0x21, 0x38, 0x00, 0x02,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x5B, 0x01, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x00, 0x08, 0x00, 0x45, 0x96, 0xAC, 0x1B, 0x62, 0x96,
+0x23, 0x38, 0x30, 0x02, 0x25, 0x28, 0xB4, 0x00, 0x21, 0x10, 0x06, 0x3C,
+0x21, 0x28, 0xB0, 0x00, 0x21, 0x30, 0x46, 0x00, 0xFF, 0xFF, 0xE7, 0x30,
+0x0D, 0x08, 0x00, 0x08, 0x21, 0x20, 0x00, 0x00, 0x8A, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C, 0xC4, 0x5D, 0x62, 0x8C,
+0x18, 0x00, 0xA4, 0x27, 0x08, 0x00, 0x42, 0x34, 0x23, 0x08, 0x00, 0x08,
+0xC4, 0x5D, 0x62, 0xAC, 0x25, 0xB0, 0x05, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0xC0, 0xFF, 0xBD, 0x27, 0x18, 0x03, 0xA4, 0x34, 0x38, 0x21, 0x42, 0x24,
+0x2A, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x82, 0xAC, 0x3C, 0x00, 0xBF, 0xAF,
+0x38, 0x00, 0xBE, 0xAF, 0x34, 0x00, 0xB7, 0xAF, 0x30, 0x00, 0xB6, 0xAF,
+0x2C, 0x00, 0xB5, 0xAF, 0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF,
+0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF,
+0x2C, 0x00, 0x63, 0x34, 0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x24, 0x31, 0x48, 0x00, 0x82, 0x10, 0x00, 0x80, 0x22, 0x31,
+0x37, 0x00, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x14, 0x00, 0x82, 0x10,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x70, 0x24, 0xFF, 0x00, 0x23, 0x31,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x7C, 0x38, 0x05, 0x8E, 0x25, 0xB0, 0x02, 0x3C, 0xFF, 0x00, 0x28, 0x31,
+0x7C, 0x03, 0x42, 0x34, 0x00, 0x00, 0x48, 0xA4, 0x21, 0x30, 0x60, 0x00,
+0x10, 0x38, 0x03, 0xAE, 0xAC, 0x37, 0x09, 0xA2, 0x0A, 0x00, 0x04, 0x24,
+0x00, 0x01, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF,
+0x01, 0x00, 0x03, 0x24, 0x84, 0x38, 0x03, 0xA2, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x50, 0x24, 0x84, 0x38, 0x03, 0x92, 0x01, 0x00, 0x02, 0x24,
+0x31, 0x00, 0x62, 0x10, 0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0x90, 0x24,
+0x85, 0x38, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x10,
+0x00, 0x04, 0x03, 0x3C, 0xD8, 0x1B, 0x02, 0x8E, 0xD0, 0x1B, 0x04, 0x8E,
+0x24, 0x10, 0x43, 0x00, 0x25, 0x20, 0x82, 0x00, 0x41, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0x64, 0xAC, 0xD0, 0x1B, 0x04, 0xAE, 0x3C, 0x00, 0xBF, 0x8F,
+0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x40, 0x00, 0xBD, 0x27, 0x24, 0x10, 0x22, 0x01,
+0xCB, 0xFF, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x43, 0x24, 0xAC, 0x37, 0x62, 0x90, 0x20, 0xB0, 0x03, 0x3C,
+0xB0, 0x03, 0xA4, 0x34, 0x00, 0x12, 0x02, 0x00, 0x21, 0x10, 0x43, 0x00,
+0x0C, 0x00, 0x49, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0xAC,
+0x69, 0x08, 0x00, 0x08, 0xFF, 0x00, 0x24, 0x31, 0x02, 0x80, 0x04, 0x3C,
+0x60, 0x1B, 0x82, 0x24, 0x84, 0x38, 0x40, 0xA0, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x50, 0x24, 0x84, 0x38, 0x03, 0x92, 0x01, 0x00, 0x02, 0x24,
+0xD1, 0xFF, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00, 0x96, 0x40, 0x00, 0x0C,
+0x21, 0x88, 0x00, 0x02, 0x25, 0xB0, 0x02, 0x3C, 0x2A, 0xB0, 0x03, 0x3C,
+0x2C, 0x00, 0x7E, 0x34, 0x02, 0x80, 0x17, 0x3C, 0xB0, 0x03, 0x56, 0x34,
+0x01, 0x00, 0x13, 0x24, 0x21, 0xA0, 0x00, 0x02, 0x21, 0xA8, 0x00, 0x02,
+0x7C, 0x38, 0x30, 0x8E, 0x0A, 0x00, 0x04, 0x24, 0x00, 0x00, 0xD0, 0xAE,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0xFF, 0xFF, 0x08, 0x32, 0x25, 0x80, 0x02, 0x01, 0xC2, 0x5C, 0xE3, 0x92,
+0x02, 0x00, 0x04, 0x92, 0x02, 0x00, 0x02, 0x24, 0x0F, 0x00, 0x63, 0x30,
+0x52, 0x00, 0x62, 0x10, 0x21, 0x38, 0x04, 0x02, 0x20, 0x00, 0x02, 0x24,
+0x54, 0x00, 0x82, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x54, 0xF5, 0x47, 0xAC,
+0x02, 0x00, 0xE2, 0x90, 0x85, 0x38, 0x84, 0x92, 0x03, 0x00, 0xE3, 0x90,
+0xFF, 0x00, 0x52, 0x30, 0x01, 0x00, 0x02, 0x24, 0x21, 0x28, 0xE0, 0x00,
+0x7F, 0x00, 0x66, 0x30, 0x08, 0x00, 0xE7, 0x24, 0x57, 0x00, 0x82, 0x10,
+0x02, 0x80, 0x09, 0x3C, 0x0E, 0x00, 0x02, 0x24, 0x51, 0x00, 0x42, 0x12,
+0x37, 0x00, 0x02, 0x24, 0x4F, 0x00, 0x42, 0x12, 0x10, 0x00, 0x02, 0x24,
+0x4E, 0x00, 0x42, 0x12, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0x38, 0xD7, 0x42, 0x24, 0xC0, 0x18, 0x12, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x34, 0xD7, 0x26, 0xA1, 0x04, 0x00, 0x62, 0x8C, 0x02, 0x80, 0x03, 0x3C,
+0x21, 0x20, 0xE0, 0x00, 0x09, 0xF8, 0x40, 0x00, 0x4C, 0xF5, 0x62, 0xAC,
+0x03, 0x00, 0x40, 0x10, 0x39, 0x00, 0x02, 0x24, 0x3B, 0x00, 0x42, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x85, 0x38, 0x33, 0xA2, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x39, 0x00, 0x02, 0x24, 0x03, 0x00, 0x42, 0x12, 0x02, 0x00, 0x02, 0x24,
+0x01, 0x00, 0xD3, 0xA3, 0x01, 0x00, 0xC2, 0xA3, 0x85, 0x38, 0xA3, 0x92,
+0x01, 0x00, 0x02, 0x24, 0x42, 0x00, 0x62, 0x14, 0xFF, 0x00, 0x02, 0x24,
+0x0C, 0x00, 0x03, 0x92, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x68, 0x30,
+0x3E, 0x00, 0x02, 0x11, 0x02, 0x80, 0x02, 0x3C, 0xAC, 0x37, 0xA3, 0xA2,
+0xAC, 0x37, 0x22, 0x92, 0x7C, 0x38, 0x25, 0x8E, 0x20, 0x10, 0x03, 0x3C,
+0x00, 0x12, 0x02, 0x00, 0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0xC8, 0xAE,
+0x21, 0x30, 0x40, 0x00, 0x10, 0x38, 0x22, 0xAE, 0x0A, 0x00, 0x04, 0x24,
+0x00, 0x01, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF,
+0x7C, 0x38, 0x30, 0x8E, 0x0A, 0x00, 0x04, 0x24, 0x00, 0x00, 0xD0, 0xAE,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0xFF, 0xFF, 0x08, 0x32, 0x25, 0x80, 0x02, 0x01, 0xC2, 0x5C, 0xE3, 0x92,
+0x02, 0x00, 0x04, 0x92, 0x02, 0x00, 0x02, 0x24, 0x0F, 0x00, 0x63, 0x30,
+0xB0, 0xFF, 0x62, 0x14, 0x21, 0x38, 0x04, 0x02, 0x00, 0x00, 0x02, 0x8E,
+0x00, 0x0C, 0x03, 0x3C, 0x24, 0x10, 0x43, 0x00, 0xAE, 0xFF, 0x43, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x95, 0x58, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x7A, 0x37, 0x22, 0x96, 0x85, 0x38, 0x33, 0xA2, 0x01, 0x00, 0x42, 0x24,
+0xF5, 0x08, 0x00, 0x08, 0x7A, 0x37, 0x22, 0xA6, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xF3, 0x08, 0x00, 0x08, 0x85, 0x38, 0x20, 0xA2,
+0x02, 0x80, 0x02, 0x3C, 0xE2, 0x08, 0x00, 0x08, 0x25, 0x38, 0x02, 0x01,
+0x34, 0xD7, 0x22, 0x91, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x42, 0x30,
+0x13, 0x00, 0xC2, 0x10, 0x25, 0xB0, 0x04, 0x3C, 0x6A, 0x37, 0x82, 0x96,
+0x1E, 0x03, 0x84, 0x34, 0x10, 0x00, 0x42, 0x34, 0x3B, 0x00, 0x43, 0x2E,
+0x00, 0x00, 0x82, 0xA4, 0x9F, 0xFF, 0x60, 0x14, 0x6A, 0x37, 0x82, 0xA6,
+0xF6, 0x08, 0x00, 0x08, 0x39, 0x00, 0x02, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0xB0, 0x5D, 0x44, 0x8C, 0x25, 0xB0, 0x03, 0x3C, 0xB0, 0x03, 0x63, 0x34,
+0x00, 0x00, 0x64, 0xAC, 0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x85, 0x08, 0x00, 0x08, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x00, 0xA5, 0x90,
+0x34, 0xD7, 0x27, 0x91, 0x02, 0x80, 0x04, 0x3C, 0xCC, 0xE6, 0x84, 0x24,
+0xFF, 0x00, 0xA5, 0x30, 0x13, 0x58, 0x00, 0x0C, 0xFF, 0x00, 0xE7, 0x30,
+0xF6, 0x08, 0x00, 0x08, 0x39, 0x00, 0x02, 0x24, 0xC0, 0xFF, 0xBD, 0x27,
+0x34, 0x00, 0xB7, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0x21, 0xB8, 0xA0, 0x00,
+0xFF, 0xFF, 0xA5, 0x30, 0x25, 0x40, 0xA2, 0x00, 0x20, 0x00, 0xB2, 0xAF,
+0x38, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x03, 0x8D, 0xFF, 0xFF, 0xD2, 0x30,
+0x08, 0x00, 0x45, 0x26, 0x00, 0xC0, 0x02, 0x24, 0x04, 0x00, 0x06, 0x8D,
+0x24, 0x18, 0x62, 0x00, 0xFF, 0x3F, 0xA5, 0x30, 0xF0, 0xFF, 0x02, 0x3C,
+0x25, 0x18, 0x65, 0x00, 0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x80, 0x05, 0x3C, 0x25, 0x18, 0x65, 0x00, 0xFF, 0x01, 0xC6, 0x34,
+0x00, 0x00, 0x03, 0xAD, 0x04, 0x00, 0x06, 0xAD, 0x21, 0x48, 0x80, 0x00,
+0xFF, 0xFF, 0xE7, 0x30, 0x18, 0x00, 0x06, 0x25, 0x18, 0x00, 0x12, 0xA5,
+0x02, 0x00, 0xC7, 0xA0, 0x18, 0x00, 0x03, 0x8D, 0xFF, 0x7F, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00, 0x02, 0x80, 0x16, 0x3C,
+0x18, 0x00, 0x03, 0xAD, 0x60, 0x1B, 0xC5, 0x26, 0x66, 0x37, 0xA4, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x82, 0x24, 0x66, 0x37, 0xA2, 0xA0,
+0x18, 0x00, 0x03, 0x8D, 0xFF, 0x80, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x7F, 0x00, 0x84, 0x30, 0x00, 0x26, 0x04, 0x00, 0x24, 0x18, 0x62, 0x00,
+0x25, 0x18, 0x64, 0x00, 0x18, 0x00, 0x03, 0xAD, 0x02, 0x80, 0x02, 0x3C,
+0xC2, 0x5C, 0x44, 0x90, 0x20, 0x00, 0x43, 0x26, 0xFF, 0xFF, 0x72, 0x30,
+0x02, 0x00, 0x84, 0x30, 0x04, 0x00, 0x80, 0x10, 0x21, 0x18, 0x40, 0x02,
+0x1F, 0x00, 0x42, 0x32, 0x5C, 0x00, 0x40, 0x10, 0x08, 0x00, 0x42, 0x26,
+0xFF, 0xFF, 0x63, 0x30, 0x5D, 0x00, 0x43, 0x12, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0xC2, 0x8C, 0x21, 0x90, 0x60, 0x00, 0x00, 0xC0, 0x04, 0x24,
+0x01, 0x00, 0x42, 0x34, 0x04, 0x00, 0xC2, 0xAC, 0x00, 0x00, 0x03, 0x8D,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0x62, 0x30, 0x08, 0x00, 0x42, 0x24,
+0x24, 0x18, 0x64, 0x00, 0xFF, 0x3F, 0x42, 0x30, 0x25, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x03, 0xAD, 0x25, 0xB0, 0x02, 0x3C, 0xC0, 0x00, 0x42, 0x34,
+0x07, 0x00, 0x43, 0x32, 0x00, 0x00, 0x52, 0xA4, 0x03, 0x00, 0x60, 0x10,
+0xF8, 0xFF, 0x53, 0x32, 0x08, 0x00, 0x42, 0x26, 0xF8, 0xFF, 0x53, 0x30,
+0x60, 0x1B, 0xD5, 0x26, 0xEC, 0x38, 0xA6, 0x8E, 0xF0, 0x38, 0xB0, 0x8E,
+0x21, 0x10, 0xD3, 0x00, 0x2B, 0x10, 0x02, 0x02, 0x32, 0x00, 0x40, 0x10,
+0xFF, 0x00, 0x34, 0x31, 0x23, 0x80, 0x06, 0x02, 0x21, 0x28, 0xE0, 0x02,
+0xFF, 0xFF, 0x07, 0x32, 0x01, 0x00, 0x11, 0x24, 0x21, 0x20, 0x80, 0x02,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xB1, 0xAF, 0x23, 0x18, 0x70, 0x02,
+0xFF, 0xFF, 0x72, 0x30, 0x22, 0x10, 0x02, 0x3C, 0x21, 0x10, 0x42, 0x02,
+0x21, 0x20, 0x80, 0x02, 0x5B, 0x01, 0x00, 0x0C, 0xEC, 0x38, 0xA2, 0xAE,
+0x21, 0x28, 0xF0, 0x02, 0x21, 0x38, 0x40, 0x02, 0x21, 0x20, 0x80, 0x02,
+0x22, 0x10, 0x06, 0x3C, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xB1, 0xAF,
+0x60, 0x1B, 0xD1, 0x26, 0xEC, 0x38, 0x23, 0x8E, 0x25, 0xB0, 0x10, 0x3C,
+0xB0, 0x03, 0x02, 0x36, 0x21, 0x20, 0x80, 0x02, 0x00, 0x00, 0x43, 0xAC,
+0x5B, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x38, 0x25, 0x8E,
+0xEC, 0x00, 0x02, 0x36, 0xBD, 0x00, 0x04, 0x36, 0x00, 0x00, 0x45, 0xAC,
+0x00, 0x00, 0x83, 0x90, 0xC2, 0x00, 0x10, 0x36, 0x38, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0x63, 0x34, 0x00, 0x00, 0x83, 0xA0, 0x34, 0x00, 0xB7, 0x8F,
+0x00, 0x00, 0x05, 0xA6, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x40, 0x00, 0xBD, 0x27, 0x01, 0x00, 0x02, 0x24,
+0x21, 0x28, 0xE0, 0x02, 0x21, 0x20, 0x80, 0x02, 0x21, 0x38, 0x60, 0x02,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0xEC, 0x38, 0xA3, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x73, 0x00, 0xC4, 0x09, 0x00, 0x08,
+0xEC, 0x38, 0xA3, 0xAE, 0xFF, 0xFF, 0x43, 0x30, 0xFF, 0xFF, 0x63, 0x30,
+0xA5, 0xFF, 0x43, 0x16, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xC2, 0x8C,
+0xFE, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00, 0xA1, 0x09, 0x00, 0x08,
+0x04, 0x00, 0xC2, 0xAC, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x14, 0x00, 0x03, 0x8E, 0x16, 0x00, 0x02, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x0A, 0x00, 0x62, 0x10, 0x08, 0x00, 0x06, 0x24,
+0x08, 0x00, 0x02, 0x96, 0x02, 0x80, 0x04, 0x3C, 0xEC, 0x54, 0x00, 0x0C,
+0x25, 0x20, 0x44, 0x00, 0x08, 0x00, 0x05, 0x8E, 0x0C, 0x00, 0x06, 0x96,
+0x14, 0x00, 0x07, 0x96, 0x51, 0x09, 0x00, 0x0C, 0x09, 0x00, 0x04, 0x24,
+0x04, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x02, 0x8E, 0x21, 0x20, 0x00, 0x02,
+0x00, 0x00, 0x62, 0xAC, 0x04, 0x00, 0x43, 0xAC, 0x00, 0x00, 0x10, 0xAE,
+0x74, 0x21, 0x00, 0x0C, 0x04, 0x00, 0x10, 0xAE, 0x90, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xBF, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x25, 0xB0, 0x02, 0x3C,
+0xBF, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x63, 0x2C, 0x05, 0x00, 0x60, 0x10, 0x02, 0x80, 0x05, 0x3C,
+0x90, 0x54, 0xA3, 0x8C, 0x90, 0x54, 0xA2, 0x24, 0x0D, 0x00, 0x62, 0x10,
+0x21, 0x20, 0x00, 0x02, 0x90, 0x54, 0xA2, 0x24, 0x04, 0x00, 0x43, 0x8C,
+0x00, 0x00, 0x02, 0xAE, 0x04, 0x00, 0x50, 0xAC, 0x00, 0x00, 0x70, 0xAC,
+0x04, 0x00, 0x03, 0xAE, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xF5, 0x09, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xD8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x08, 0xE7, 0x84, 0x24, 0x24, 0x00, 0xBF, 0xAF,
+0x20, 0x00, 0xB2, 0xAF, 0x13, 0x58, 0x00, 0x0C, 0x1C, 0x00, 0xB1, 0xAF,
+0x00, 0x00, 0x04, 0x96, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x83, 0x24,
+0x07, 0x00, 0x62, 0x30, 0x6A, 0x00, 0x40, 0x10, 0xC2, 0x10, 0x03, 0x00,
+0x28, 0x00, 0x82, 0x24, 0xC2, 0x10, 0x02, 0x00, 0x53, 0x21, 0x00, 0x0C,
+0xC0, 0x20, 0x02, 0x00, 0x68, 0x00, 0x40, 0x10, 0x21, 0x88, 0x40, 0x00,
+0x02, 0x80, 0x12, 0x3C, 0x02, 0x00, 0x06, 0x92, 0x60, 0x1B, 0x50, 0x26,
+0x10, 0x38, 0x05, 0x8E, 0x08, 0x00, 0xC6, 0x24, 0x0A, 0x00, 0x04, 0x24,
+0x72, 0x01, 0x00, 0x0C, 0x21, 0x38, 0x40, 0x00, 0xB0, 0x1B, 0x03, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 0x30, 0x67, 0x00, 0x40, 0x14,
+0x01, 0x00, 0x62, 0x30, 0x02, 0x80, 0x02, 0x3C, 0x4B, 0xF5, 0x43, 0x90,
+0x60, 0x1B, 0x50, 0x26, 0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0xE8, 0x39, 0x00, 0xAE, 0x04, 0x3A, 0x00, 0xAE, 0xFC, 0x40, 0x00, 0xAE,
+0xBC, 0x40, 0x00, 0xAE, 0xC6, 0x40, 0x00, 0xA2, 0x8A, 0x40, 0x00, 0x0C,
+0xC6, 0x5C, 0x43, 0xA0, 0xA3, 0x6A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x87, 0x6B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C, 0xD2, 0x5C, 0x48, 0x90,
+0x25, 0xB0, 0x04, 0x3C, 0x2F, 0x00, 0x02, 0x3C, 0xD0, 0x01, 0x85, 0x34,
+0x17, 0x32, 0x42, 0x34, 0x00, 0x00, 0xA2, 0xAC, 0x5E, 0x00, 0x03, 0x3C,
+0x10, 0x00, 0x02, 0x3C, 0xDC, 0x01, 0x87, 0x34, 0xD4, 0x01, 0x86, 0x34,
+0x17, 0x43, 0x63, 0x34, 0x20, 0x53, 0x42, 0x34, 0xD8, 0x01, 0x84, 0x34,
+0x00, 0x00, 0xC3, 0xAC, 0x00, 0x00, 0x82, 0xAC, 0x44, 0xA4, 0x03, 0x34,
+0x01, 0x00, 0x02, 0x24, 0x00, 0x00, 0xE3, 0xAC, 0x52, 0x00, 0x02, 0x11,
+0xFF, 0xF7, 0x03, 0x24, 0xFC, 0x23, 0x02, 0x8E, 0xFF, 0xEF, 0x04, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x24, 0x10, 0x44, 0x00, 0xFC, 0x23, 0x02, 0xAE,
+0x60, 0x1B, 0x42, 0x8E, 0xDF, 0xFF, 0x03, 0x24, 0xFB, 0xFF, 0x04, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x24, 0x10, 0x44, 0x00, 0xFE, 0xFF, 0x03, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x50, 0x0C, 0x04, 0x24, 0x60, 0x1B, 0x50, 0x26,
+0x30, 0x5C, 0x00, 0x0C, 0x60, 0x1B, 0x42, 0xAE, 0x38, 0x3E, 0x02, 0xA2,
+0x30, 0x5C, 0x00, 0x0C, 0x58, 0x0C, 0x04, 0x24, 0x39, 0x3E, 0x02, 0xA2,
+0x50, 0x0C, 0x04, 0x24, 0x1A, 0x5C, 0x00, 0x0C, 0x17, 0x00, 0x05, 0x24,
+0x17, 0x00, 0x05, 0x24, 0x1A, 0x5C, 0x00, 0x0C, 0x58, 0x0C, 0x04, 0x24,
+0x5B, 0x01, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24, 0x08, 0x00, 0x22, 0x96,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x04, 0x3C, 0x25, 0x28, 0x45, 0x00,
+0x74, 0x03, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0xB0, 0x55, 0x84, 0x24,
+0x74, 0x21, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02, 0x98, 0x3A, 0x02, 0x8E,
+0x49, 0x4B, 0x00, 0x0C, 0xC4, 0x3D, 0x02, 0xA2, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x53, 0x21, 0x00, 0x0C, 0xC0, 0x20, 0x02, 0x00, 0x9A, 0xFF, 0x40, 0x14,
+0x21, 0x88, 0x40, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x18, 0xE7, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0xFC, 0xE6, 0xA5, 0x24,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0x20, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x87, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x05, 0x3C,
+0x4C, 0x00, 0xA2, 0x34, 0x00, 0x00, 0x40, 0xA0, 0x48, 0x00, 0xA5, 0x34,
+0xB0, 0x1B, 0x03, 0x96, 0x00, 0x00, 0xA4, 0x8C, 0x7B, 0xFF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x82, 0x00, 0xFF, 0xFE, 0x63, 0x30,
+0xB0, 0x1B, 0x03, 0xA6, 0x00, 0x00, 0xA4, 0xAC, 0x5F, 0x0A, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0xD3, 0x5C, 0x44, 0x90,
+0x02, 0x00, 0x03, 0x24, 0x06, 0x00, 0x83, 0x10, 0xFF, 0xF7, 0x03, 0x24,
+0xFC, 0x23, 0x02, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x43, 0x00,
+0x89, 0x0A, 0x00, 0x08, 0x00, 0x10, 0x42, 0x34, 0xFC, 0x23, 0x02, 0x8E,
+0xFF, 0xEF, 0x03, 0x24, 0x00, 0x08, 0x42, 0x34, 0x89, 0x0A, 0x00, 0x08,
+0x24, 0x10, 0x43, 0x00, 0x02, 0x80, 0x04, 0x3C, 0xB4, 0x55, 0x84, 0x24,
+0x1C, 0x4F, 0x00, 0x0C, 0x03, 0x00, 0x05, 0x24, 0xC6, 0x0A, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x00, 0x00, 0x84, 0x90, 0x02, 0x80, 0x06, 0x3C, 0x01, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x83, 0x30, 0x0C, 0x00, 0x62, 0x10, 0x60, 0x1B, 0xC5, 0x24,
+0x04, 0x00, 0x02, 0x24, 0x13, 0x00, 0x62, 0x10, 0x60, 0x1B, 0xC2, 0x24,
+0xC6, 0x3D, 0x45, 0x90, 0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C,
+0x24, 0xE7, 0x84, 0x24, 0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xC6, 0x3D, 0xA4, 0xA0,
+0x60, 0x1B, 0xC2, 0x24, 0xC6, 0x3D, 0x45, 0x90, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0x24, 0xE7, 0x84, 0x24, 0x10, 0x00, 0xBF, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0x60, 0x1B, 0xC3, 0x24, 0xB0, 0x1B, 0x62, 0x94, 0xC6, 0x3D, 0x64, 0xA0,
+0x02, 0x80, 0x04, 0x3C, 0x04, 0x00, 0x42, 0x34, 0xB0, 0x1B, 0x62, 0xA4,
+0x60, 0x1B, 0xC2, 0x24, 0xC6, 0x3D, 0x45, 0x90, 0x13, 0x58, 0x00, 0x0C,
+0x24, 0xE7, 0x84, 0x24, 0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27,
+0x20, 0x00, 0xB2, 0xAF, 0x02, 0x80, 0x12, 0x3C, 0x24, 0x00, 0xB3, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x2C, 0x00, 0xBF, 0xAF, 0x28, 0x00, 0xB4, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0x51, 0x26, 0xB0, 0x1B, 0x22, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x42, 0x30, 0x0A, 0x00, 0x40, 0x10,
+0x21, 0x98, 0x80, 0x00, 0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0x10, 0x00, 0xA4, 0x27, 0x8A, 0x40, 0x00, 0x0C,
+0x02, 0x80, 0x14, 0x3C, 0xEE, 0x5D, 0x82, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0x04, 0x00, 0x42, 0x28, 0x89, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x60, 0x1B, 0x42, 0x8E, 0xDF, 0xFF, 0x03, 0x24, 0xFB, 0xFF, 0x04, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x24, 0x10, 0x44, 0x00, 0xFE, 0xFF, 0x03, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x50, 0x0C, 0x04, 0x24, 0x30, 0x5C, 0x00, 0x0C,
+0x60, 0x1B, 0x42, 0xAE, 0x38, 0x3E, 0x22, 0xA2, 0x30, 0x5C, 0x00, 0x0C,
+0x58, 0x0C, 0x04, 0x24, 0x39, 0x3E, 0x22, 0xA2, 0x50, 0x0C, 0x04, 0x24,
+0x1A, 0x5C, 0x00, 0x0C, 0x17, 0x00, 0x05, 0x24, 0x17, 0x00, 0x05, 0x24,
+0x1A, 0x5C, 0x00, 0x0C, 0x58, 0x0C, 0x04, 0x24, 0xB0, 0x1B, 0x22, 0x96,
+0x02, 0x80, 0x04, 0x3C, 0x34, 0xE7, 0x84, 0x24, 0x00, 0x10, 0x42, 0x34,
+0x13, 0x58, 0x00, 0x0C, 0xB0, 0x1B, 0x22, 0xA6, 0x01, 0x00, 0x02, 0x24,
+0x25, 0xB0, 0x03, 0x3C, 0x04, 0x3E, 0x22, 0xAE, 0x4C, 0x00, 0x63, 0x34,
+0xB0, 0x1B, 0x22, 0x96, 0x00, 0x00, 0x66, 0x90, 0x08, 0x00, 0x65, 0x8E,
+0xC4, 0x3D, 0x27, 0x92, 0xC5, 0x3D, 0x28, 0x92, 0x3B, 0x41, 0x29, 0x92,
+0xD0, 0x3D, 0x2A, 0x92, 0xFF, 0x3D, 0x2B, 0x92, 0x00, 0x80, 0x42, 0x30,
+0x37, 0x3E, 0x26, 0xA2, 0x0C, 0x3E, 0x25, 0xAE, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x60, 0xA0, 0x31, 0x3E, 0x27, 0xA2, 0x32, 0x3E, 0x28, 0xA2,
+0x34, 0x3E, 0x22, 0xA6, 0x36, 0x3E, 0x29, 0xA2, 0xC4, 0x3D, 0x2A, 0xA2,
+0xC5, 0x3D, 0x2B, 0xA2, 0x3C, 0x3E, 0x20, 0xAE, 0x40, 0x3E, 0x20, 0xAE,
+0x8A, 0x40, 0x00, 0x0C, 0x33, 0x3E, 0x20, 0xA2, 0x10, 0x00, 0xA4, 0x27,
+0x90, 0x40, 0x00, 0x0C, 0x52, 0x41, 0x20, 0xA2, 0x21, 0x20, 0x00, 0x00,
+0x95, 0x0E, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x08, 0x00, 0x66, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0xC0, 0x14, 0x0C, 0x00, 0x70, 0x26,
+0x00, 0x00, 0x62, 0x8E, 0x21, 0x20, 0x20, 0x02, 0x44, 0x3E, 0x23, 0x26,
+0x08, 0x3E, 0x22, 0xAE, 0x3F, 0x00, 0x02, 0x24, 0xFF, 0xFF, 0x42, 0x24,
+0x00, 0x00, 0x60, 0xA0, 0xFD, 0xFF, 0x41, 0x04, 0x07, 0x00, 0x63, 0x24,
+0xB0, 0x1B, 0x83, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 0x30,
+0x09, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x50, 0x26, 0x01, 0x00, 0x62, 0x30,
+0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x5D, 0x82, 0x92,
+0x0C, 0x00, 0x03, 0x24, 0x0F, 0x00, 0x42, 0x30, 0x37, 0x00, 0x43, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xC4, 0x3D, 0x04, 0x92, 0x75, 0x0D, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xC4, 0x3D, 0x04, 0x92, 0x38, 0x0D, 0x00, 0x0C,
+0x01, 0x00, 0x05, 0x24, 0x25, 0xB0, 0x04, 0x3C, 0x48, 0x00, 0x84, 0x34,
+0x00, 0x00, 0x83, 0x8C, 0x08, 0x3E, 0x05, 0x8E, 0x7B, 0xFF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x83, 0xAC, 0x0C, 0x00, 0xA2, 0x10, 0x60, 0x1B, 0x43, 0x26,
+0x3C, 0x00, 0x02, 0x24, 0x94, 0x39, 0x62, 0xAC, 0x2C, 0x00, 0xBF, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0xC4, 0x3D, 0x02, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x42, 0x2C, 0xF1, 0xFF, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x12, 0x49, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x43, 0x26, 0x3C, 0x00, 0x02, 0x24, 0xA0, 0x0B, 0x00, 0x08,
+0x94, 0x39, 0x62, 0xAC, 0x02, 0x80, 0x04, 0x3C, 0x21, 0x28, 0x00, 0x02,
+0xF4, 0x54, 0x00, 0x0C, 0x70, 0x59, 0x84, 0x24, 0x02, 0x80, 0x04, 0x3C,
+0x44, 0xE7, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x02,
+0x77, 0x0B, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x24,
+0x4B, 0x2E, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0x36, 0x0B, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x51, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x8D, 0x0B, 0x00, 0x08, 0x60, 0x1B, 0x50, 0x26, 0xE8, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x00, 0x00, 0x02, 0x92, 0x02, 0x80, 0x04, 0x3C, 0x21, 0x28, 0x40, 0x00,
+0x04, 0x00, 0x42, 0x2C, 0x06, 0x00, 0x40, 0x14, 0x50, 0xE7, 0x84, 0x24,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x13, 0x58, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x92, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x02, 0x80, 0x02, 0x3C, 0x84, 0x5B, 0x43, 0xAC,
+0x18, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C, 0xD0, 0xFF, 0xBD, 0x27,
+0x18, 0x03, 0x42, 0x34, 0x80, 0x2F, 0x63, 0x24, 0x24, 0x00, 0xB3, 0xAF,
+0x28, 0x00, 0xBF, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x43, 0xAC, 0x02, 0x80, 0x04, 0x3C,
+0xEC, 0x5D, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x13, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x06, 0x5E, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x60, 0x14, 0x01, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x0F, 0x5E, 0x44, 0xA0, 0x02, 0x80, 0x03, 0x3C,
+0xED, 0x5D, 0x64, 0x90, 0x01, 0x00, 0x05, 0x24, 0x4B, 0x2E, 0x00, 0x0C,
+0xFF, 0x00, 0x84, 0x30, 0x02, 0x80, 0x02, 0x3C, 0x98, 0x54, 0x43, 0x8C,
+0x98, 0x54, 0x42, 0x24, 0xA2, 0x00, 0x62, 0x10, 0x02, 0x80, 0x13, 0x3C,
+0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x02, 0x3C,
+0x36, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x90, 0x60, 0x1B, 0x66, 0x26,
+0xF4, 0x38, 0xC5, 0x8C, 0xC0, 0x18, 0x03, 0x00, 0x23, 0xB0, 0x04, 0x3C,
+0xF0, 0x07, 0x63, 0x30, 0xFF, 0x1F, 0x02, 0x3C, 0x21, 0x18, 0x64, 0x00,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x62, 0x00, 0x23, 0x88, 0x85, 0x00,
+0x00, 0x04, 0x22, 0x26, 0x2B, 0x28, 0x85, 0x00, 0x98, 0x38, 0xC3, 0x8C,
+0x0B, 0x88, 0x45, 0x00, 0xE1, 0x01, 0x22, 0x2E, 0x94, 0x38, 0xC3, 0xAC,
+0xF8, 0x38, 0xC4, 0xAC, 0x9E, 0x38, 0xC0, 0xA4, 0x14, 0x00, 0x40, 0x14,
+0x9D, 0x38, 0xC0, 0xA0, 0x20, 0xFE, 0x82, 0x24, 0x20, 0x02, 0x83, 0x24,
+0x0A, 0x18, 0x45, 0x00, 0x23, 0x10, 0x02, 0x3C, 0xFF, 0x03, 0x42, 0x34,
+0x2B, 0x10, 0x43, 0x00, 0x21, 0x28, 0x60, 0x00, 0x32, 0x00, 0x40, 0x14,
+0xF4, 0x38, 0xC3, 0xAC, 0xF8, 0x38, 0xC2, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x18, 0x45, 0x00, 0x23, 0x88, 0x45, 0x00, 0x03, 0x00, 0x60, 0x10,
+0xE1, 0x01, 0x22, 0x2E, 0x00, 0x04, 0x31, 0x26, 0xE1, 0x01, 0x22, 0x2E,
+0x0E, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x70, 0x26, 0x60, 0x1B, 0x70, 0x26,
+0xF8, 0x38, 0x03, 0x8E, 0xF4, 0x38, 0x04, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0x83, 0x00, 0x2C, 0x00, 0x40, 0x14, 0x2B, 0x10, 0x64, 0x00,
+0x56, 0x00, 0x40, 0x14, 0x25, 0xB0, 0x02, 0x3C, 0x80, 0x00, 0x03, 0x24,
+0xD0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x60, 0x1B, 0x70, 0x26,
+0xF4, 0x38, 0x03, 0x96, 0x2A, 0xB0, 0x02, 0x3C, 0x35, 0x00, 0x42, 0x34,
+0xC2, 0x88, 0x03, 0x00, 0x00, 0x00, 0x51, 0xA0, 0x73, 0x23, 0x00, 0x74,
+0x00, 0x00, 0x00, 0x00, 0x9E, 0x38, 0x03, 0x96, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xD0, 0x1B, 0x02, 0x8E, 0x80, 0x00, 0x03, 0x3C,
+0x41, 0xB0, 0x04, 0x3C, 0x25, 0x10, 0x43, 0x00, 0x00, 0x00, 0x82, 0xAC,
+0x28, 0x00, 0xBF, 0x8F, 0xD0, 0x1B, 0x02, 0xAE, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0x00, 0xFC, 0xA5, 0x24,
+0x23, 0x0C, 0x00, 0x08, 0xF4, 0x38, 0xC5, 0xAC, 0x24, 0x2D, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xA2, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xE2, 0x2C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x0B, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0x94, 0x38, 0x05, 0x8E, 0x21, 0x30, 0x80, 0x00,
+0xFF, 0xFF, 0x27, 0x32, 0x09, 0x00, 0x04, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x94, 0x38, 0x03, 0x8E, 0x9E, 0x38, 0x05, 0x96,
+0xF4, 0x38, 0x02, 0x8E, 0x21, 0x18, 0x71, 0x00, 0x21, 0x28, 0x25, 0x02,
+0x21, 0x10, 0x51, 0x00, 0x09, 0x00, 0x04, 0x24, 0xF4, 0x38, 0x02, 0xAE,
+0x94, 0x38, 0x03, 0xAE, 0x5B, 0x01, 0x00, 0x0C, 0x9E, 0x38, 0x05, 0xA6,
+0x60, 0x1B, 0x70, 0x26, 0xF4, 0x38, 0x03, 0x96, 0x2A, 0xB0, 0x02, 0x3C,
+0x35, 0x00, 0x42, 0x34, 0xC2, 0x88, 0x03, 0x00, 0x00, 0x00, 0x51, 0xA0,
+0x73, 0x23, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x38, 0x03, 0x96,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x1B, 0x02, 0x8E,
+0x80, 0x00, 0x03, 0x3C, 0x41, 0xB0, 0x04, 0x3C, 0x25, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x82, 0xAC, 0x28, 0x00, 0xBF, 0x8F, 0xD0, 0x1B, 0x02, 0xAE,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xFC, 0x38, 0x02, 0x8E, 0x94, 0x38, 0x05, 0x8E, 0x21, 0x30, 0x80, 0x00,
+0x23, 0x88, 0x44, 0x00, 0xFF, 0xFF, 0x27, 0x32, 0x09, 0x00, 0x04, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x94, 0x38, 0x03, 0x8E,
+0x9E, 0x38, 0x02, 0x96, 0xF8, 0x38, 0x12, 0x96, 0x21, 0x18, 0x71, 0x00,
+0x21, 0x10, 0x22, 0x02, 0x23, 0x10, 0x11, 0x3C, 0x94, 0x38, 0x03, 0xAE,
+0x9E, 0x38, 0x02, 0xA6, 0x15, 0x00, 0x40, 0x16, 0xF4, 0x38, 0x11, 0xAE,
+0x09, 0x00, 0x04, 0x24, 0x5B, 0x01, 0x00, 0x0C, 0x60, 0x1B, 0x70, 0x26,
+0x71, 0x0C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x24, 0x2D, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x5C, 0xFF, 0x40, 0x10, 0x60, 0x1B, 0x63, 0x26,
+0x2A, 0x1C, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x58, 0xFF, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x4C, 0x3A, 0x64, 0x94, 0x2A, 0x1C, 0x60, 0xA0,
+0x00, 0xC0, 0x84, 0x24, 0xA3, 0x31, 0x00, 0x0C, 0xFF, 0xFF, 0x84, 0x30,
+0x01, 0x0C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x01, 0x00, 0x0C,
+0x09, 0x00, 0x04, 0x24, 0x94, 0x38, 0x05, 0x8E, 0x09, 0x00, 0x04, 0x24,
+0x23, 0x10, 0x06, 0x3C, 0x21, 0x38, 0x40, 0x02, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x94, 0x38, 0x03, 0x8E, 0x9E, 0x38, 0x02, 0x96,
+0x21, 0x20, 0x51, 0x02, 0x21, 0x18, 0x72, 0x00, 0x21, 0x10, 0x42, 0x02,
+0xF4, 0x38, 0x04, 0xAE, 0x09, 0x00, 0x04, 0x24, 0x94, 0x38, 0x03, 0xAE,
+0x9E, 0x0C, 0x00, 0x08, 0x9E, 0x38, 0x02, 0xA6, 0x08, 0x00, 0xE0, 0x03,
+0x09, 0x00, 0x02, 0x24, 0xFF, 0x00, 0x86, 0x30, 0x02, 0x80, 0x02, 0x3C,
+0x40, 0x00, 0xC3, 0x2C, 0x4A, 0xF5, 0x47, 0x90, 0x00, 0x00, 0x63, 0x38,
+0x3F, 0x00, 0x02, 0x24, 0x0A, 0x30, 0x43, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x0E, 0x04, 0x24, 0x00, 0x7F, 0x05, 0x24, 0x03, 0x00, 0xE2, 0x10,
+0x31, 0x00, 0xC3, 0x2C, 0xC1, 0x43, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x30, 0x00, 0x02, 0x24, 0xC1, 0x43, 0x00, 0x08, 0x0A, 0x30, 0x43, 0x00,
+0xC0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x03, 0x3C, 0x38, 0x00, 0xB4, 0xAF,
+0x34, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xB2, 0xAF, 0x2C, 0x00, 0xB1, 0xAF,
+0x28, 0x00, 0xB0, 0xAF, 0xA4, 0xE7, 0x62, 0x24, 0x3C, 0x00, 0xBF, 0xAF,
+0x0A, 0x00, 0x4A, 0x94, 0x02, 0x00, 0x48, 0x94, 0x06, 0x00, 0x49, 0x94,
+0xFF, 0x00, 0x84, 0x30, 0xFF, 0x00, 0xA5, 0x30, 0xA4, 0xE7, 0x6B, 0x94,
+0x04, 0x00, 0x4C, 0x94, 0x08, 0x00, 0x4D, 0x94, 0x00, 0x1C, 0x05, 0x00,
+0x00, 0x14, 0x04, 0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x36, 0x04, 0x00,
+0x25, 0x38, 0xE3, 0x00, 0x25, 0x30, 0xC2, 0x00, 0x00, 0x44, 0x08, 0x00,
+0x00, 0x12, 0x05, 0x00, 0x00, 0x4C, 0x09, 0x00, 0x00, 0x54, 0x0A, 0x00,
+0x00, 0x1A, 0x04, 0x00, 0x25, 0x38, 0xE2, 0x00, 0x25, 0x40, 0x0B, 0x01,
+0x25, 0x48, 0x2C, 0x01, 0x25, 0x50, 0x4D, 0x01, 0x25, 0x30, 0xC3, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x10, 0x00, 0xA8, 0xAF, 0x14, 0x00, 0xA9, 0xAF,
+0x18, 0x00, 0xAA, 0xAF, 0x25, 0x98, 0xE5, 0x00, 0x25, 0x90, 0xC4, 0x00,
+0x60, 0x1B, 0x54, 0x24, 0x21, 0x80, 0x00, 0x00, 0x10, 0x00, 0xB1, 0x27,
+0x02, 0x00, 0x02, 0x2E, 0x32, 0x00, 0x40, 0x10, 0x80, 0x10, 0x10, 0x00,
+0x21, 0x10, 0x54, 0x00, 0xF0, 0x1C, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x40, 0x73, 0x00, 0x21, 0x38, 0x00, 0x00, 0x7F, 0x00, 0x09, 0x24,
+0xC0, 0x20, 0x07, 0x00, 0x04, 0x10, 0x89, 0x00, 0x24, 0x10, 0x48, 0x00,
+0x06, 0x10, 0x82, 0x00, 0x01, 0x00, 0xE5, 0x24, 0xFF, 0x00, 0x43, 0x30,
+0x21, 0x30, 0x27, 0x02, 0x40, 0x00, 0x63, 0x2C, 0xFF, 0x00, 0xA7, 0x30,
+0x02, 0x00, 0x60, 0x14, 0x04, 0x00, 0xE4, 0x2C, 0x3F, 0x00, 0x02, 0x24,
+0xF3, 0xFF, 0x80, 0x14, 0x10, 0x00, 0xC2, 0xA0, 0x23, 0x00, 0xA6, 0x93,
+0x22, 0x00, 0xA2, 0x93, 0x21, 0x00, 0xA5, 0x93, 0x40, 0x18, 0x10, 0x00,
+0x00, 0x14, 0x02, 0x00, 0x21, 0x18, 0x71, 0x00, 0x20, 0x00, 0xA7, 0x93,
+0x00, 0x36, 0x06, 0x00, 0x25, 0x30, 0xC2, 0x00, 0x00, 0x2A, 0x05, 0x00,
+0x00, 0x00, 0x64, 0x94, 0x25, 0x30, 0xC5, 0x00, 0x7F, 0x7F, 0x05, 0x3C,
+0x25, 0x30, 0xC7, 0x00, 0xC1, 0x43, 0x00, 0x0C, 0x7F, 0x7F, 0xA5, 0x34,
+0x01, 0x00, 0x02, 0x26, 0xFF, 0x00, 0x50, 0x30, 0x06, 0x00, 0x03, 0x2E,
+0xD5, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0xBF, 0x8F,
+0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F,
+0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x40, 0x00, 0xBD, 0x27, 0x21, 0x10, 0x54, 0x00, 0xF0, 0x1C, 0x43, 0x8C,
+0x07, 0x0D, 0x00, 0x08, 0x21, 0x40, 0x72, 0x00, 0xD8, 0xFF, 0xBD, 0x27,
+0x14, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x02, 0x3C,
+0xC6, 0x5C, 0x43, 0x90, 0x02, 0x80, 0x07, 0x3C, 0x60, 0x1B, 0xE2, 0x24,
+0xFF, 0x00, 0x91, 0x30, 0x21, 0x20, 0x22, 0x02, 0x20, 0x00, 0x62, 0x30,
+0x10, 0x00, 0x63, 0x30, 0x63, 0x1D, 0x93, 0x90, 0x27, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x8D, 0x1D, 0x82, 0x90, 0x7F, 0x1D, 0x83, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x23, 0x10, 0x43, 0x00, 0x00, 0x36, 0x02, 0x00,
+0x03, 0x36, 0x06, 0x00, 0xFF, 0x00, 0x70, 0x30, 0x60, 0x1B, 0xE7, 0x24,
+0x21, 0x40, 0x27, 0x02, 0xB7, 0x1D, 0x02, 0x91, 0xB0, 0x1B, 0xE3, 0x84,
+0x0F, 0x00, 0x05, 0x3C, 0x0F, 0x00, 0x42, 0x30, 0x21, 0x10, 0x50, 0x00,
+0x0C, 0x08, 0x04, 0x24, 0x0F, 0x00, 0xC6, 0x30, 0x00, 0xFF, 0xA5, 0x34,
+0x06, 0x00, 0x60, 0x04, 0xFF, 0x00, 0x52, 0x30, 0xC5, 0x1D, 0x02, 0x91,
+0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x21, 0x10, 0x50, 0x00,
+0xFF, 0x00, 0x50, 0x30, 0xC1, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xC5, 0x0C, 0x00, 0x0C, 0x21, 0x20, 0x60, 0x02, 0x21, 0x20, 0x00, 0x02,
+0x21, 0x28, 0x40, 0x02, 0x21, 0x30, 0x20, 0x02, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0xD6, 0x0C, 0x00, 0x08, 0x28, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x1D, 0x82, 0x90,
+0x9B, 0x1D, 0x83, 0x90, 0x4D, 0x0D, 0x00, 0x08, 0x23, 0x10, 0x43, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x02, 0x3C,
+0x18, 0x00, 0xBF, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0xD1, 0x5C, 0x43, 0x90,
+0x01, 0x00, 0x02, 0x24, 0x09, 0x00, 0x62, 0x10, 0xFF, 0x00, 0x90, 0x30,
+0x21, 0x30, 0x00, 0x02, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x18, 0x00, 0x04, 0x24, 0xFF, 0x03, 0x05, 0x24,
+0x83, 0x45, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27, 0x0F, 0x00, 0x05, 0x3C,
+0xFF, 0xFF, 0xA5, 0x34, 0x15, 0x00, 0x04, 0x24, 0x0A, 0x00, 0x03, 0x12,
+0xF4, 0xA8, 0x06, 0x34, 0x0F, 0x00, 0x05, 0x3C, 0x0B, 0x00, 0x02, 0x24,
+0xFF, 0xFF, 0xA5, 0x34, 0x05, 0x00, 0x02, 0x12, 0xF5, 0xF8, 0x06, 0x34,
+0x0F, 0x00, 0x05, 0x3C, 0xF4, 0xF8, 0x06, 0x34, 0x15, 0x00, 0x04, 0x24,
+0xFF, 0xFF, 0xA5, 0x34, 0x83, 0x45, 0x00, 0x0C, 0x0F, 0x00, 0x11, 0x3C,
+0x02, 0x80, 0x02, 0x3C, 0x48, 0xF5, 0x46, 0x90, 0xFE, 0x00, 0x03, 0x24,
+0x15, 0x00, 0x04, 0x24, 0xE3, 0xFF, 0xC3, 0x14, 0xFF, 0xFF, 0x25, 0x36,
+0xAC, 0x45, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x46, 0x30,
+0x00, 0xFF, 0x23, 0x36, 0x24, 0x10, 0x43, 0x00, 0x01, 0x00, 0xC6, 0x24,
+0x25, 0x30, 0x46, 0x00, 0xFF, 0xFF, 0x25, 0x36, 0x83, 0x45, 0x00, 0x0C,
+0x15, 0x00, 0x04, 0x24, 0x7F, 0x0D, 0x00, 0x08, 0x21, 0x30, 0x00, 0x02,
+0xFC, 0x00, 0x84, 0x30, 0x80, 0x00, 0x02, 0x24, 0x11, 0x00, 0x82, 0x10,
+0x06, 0x00, 0x03, 0x24, 0x81, 0x00, 0x82, 0x28, 0x10, 0x00, 0x40, 0x10,
+0xB0, 0x00, 0x02, 0x24, 0x20, 0x00, 0x02, 0x24, 0x0B, 0x00, 0x82, 0x10,
+0x02, 0x00, 0x03, 0x24, 0x21, 0x00, 0x82, 0x28, 0x15, 0x00, 0x40, 0x10,
+0x40, 0x00, 0x02, 0x24, 0x06, 0x00, 0x80, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x01, 0x00, 0x03, 0x24, 0x10, 0x00, 0x02, 0x24, 0x02, 0x00, 0x82, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x60, 0x00, 0xFD, 0xFF, 0x82, 0x10, 0x09, 0x00, 0x03, 0x24,
+0xB1, 0x00, 0x82, 0x28, 0x0F, 0x00, 0x40, 0x10, 0xC8, 0x00, 0x02, 0x24,
+0x90, 0x00, 0x02, 0x24, 0xF7, 0xFF, 0x82, 0x10, 0x07, 0x00, 0x03, 0x24,
+0x08, 0x00, 0x03, 0x24, 0xB9, 0x0D, 0x00, 0x08, 0xA0, 0x00, 0x02, 0x24,
+0xF2, 0xFF, 0x82, 0x10, 0x04, 0x00, 0x03, 0x24, 0x41, 0x00, 0x82, 0x28,
+0x0F, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x24,
+0xB9, 0x0D, 0x00, 0x08, 0x30, 0x00, 0x02, 0x24, 0xEA, 0xFF, 0x82, 0x10,
+0x0C, 0x00, 0x03, 0x24, 0xC9, 0x00, 0x82, 0x28, 0x04, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x03, 0x24, 0xB9, 0x0D, 0x00, 0x08,
+0xC0, 0x00, 0x02, 0x24, 0x0B, 0x00, 0x03, 0x24, 0xB9, 0x0D, 0x00, 0x08,
+0xD0, 0x00, 0x02, 0x24, 0x05, 0x00, 0x03, 0x24, 0xB9, 0x0D, 0x00, 0x08,
+0x50, 0x00, 0x02, 0x24, 0xD0, 0xFF, 0xBD, 0x27, 0x2C, 0x00, 0xBF, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x08, 0x00, 0x83, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x08, 0x00, 0x90, 0x94, 0x02, 0x80, 0x02, 0x3C, 0x21, 0x90, 0x80, 0x00,
+0x25, 0x80, 0x02, 0x02, 0xFF, 0x00, 0xB4, 0x30, 0x21, 0x20, 0x00, 0x02,
+0xFF, 0x00, 0xD1, 0x30, 0x21, 0x28, 0x00, 0x00, 0x08, 0x00, 0x06, 0x24,
+0xEC, 0x54, 0x00, 0x0C, 0xFF, 0x00, 0xF3, 0x30, 0x04, 0x00, 0x06, 0x8E,
+0x08, 0x00, 0x05, 0x8E, 0xFF, 0xDF, 0x02, 0x3C, 0xFF, 0xE0, 0x03, 0x24,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x30, 0xC3, 0x00, 0x24, 0x28, 0xA2, 0x00,
+0x3F, 0xFF, 0x02, 0x3C, 0x10, 0x00, 0x08, 0x8E, 0xFF, 0xFF, 0x42, 0x34,
+0x00, 0x12, 0xC6, 0x34, 0x00, 0x40, 0x03, 0x3C, 0x24, 0x30, 0xC2, 0x00,
+0x05, 0x00, 0x07, 0x24, 0x04, 0x00, 0x02, 0x24, 0x0B, 0x38, 0x54, 0x00,
+0x25, 0x28, 0xA3, 0x00, 0x01, 0x00, 0x84, 0x32, 0x7F, 0xFF, 0x03, 0x24,
+0x00, 0x80, 0x02, 0x3C, 0x14, 0x00, 0x09, 0x8E, 0x24, 0x28, 0xA3, 0x00,
+0xC0, 0x21, 0x04, 0x00, 0x25, 0x40, 0x02, 0x01, 0x03, 0x00, 0x31, 0x32,
+0xFF, 0xE0, 0x02, 0x3C, 0x80, 0x8D, 0x11, 0x00, 0x25, 0x28, 0xA4, 0x00,
+0xFF, 0xFF, 0x42, 0x34, 0x0C, 0x00, 0x4A, 0x8E, 0x25, 0x30, 0xD1, 0x00,
+0xFF, 0x81, 0x03, 0x24, 0xE0, 0xFF, 0x04, 0x24, 0x24, 0x28, 0xA2, 0x00,
+0x3F, 0x00, 0x73, 0x32, 0xFB, 0xFF, 0x02, 0x3C, 0x24, 0x48, 0x23, 0x01,
+0x24, 0x30, 0xC4, 0x00, 0x00, 0x1E, 0x07, 0x00, 0x40, 0x9A, 0x13, 0x00,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x40, 0x02, 0x01, 0x25, 0x48, 0x33, 0x01,
+0x25, 0x28, 0xA3, 0x00, 0x25, 0x30, 0xC7, 0x00, 0x20, 0x00, 0x02, 0x24,
+0x08, 0x00, 0x05, 0xAE, 0x00, 0x00, 0x0A, 0xA6, 0x02, 0x00, 0x02, 0xA2,
+0x10, 0x00, 0x08, 0xAE, 0x14, 0x00, 0x09, 0xAE, 0x04, 0x00, 0x06, 0xAE,
+0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x98, 0x54, 0x42, 0x24, 0x04, 0x00, 0x43, 0x8C, 0x00, 0x00, 0x42, 0xAE,
+0x04, 0x00, 0x52, 0xAC, 0x00, 0x00, 0x72, 0xAC, 0x04, 0x00, 0x43, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x2C, 0x00, 0xBF, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0xFF, 0xFF, 0x90, 0x30, 0x10, 0x00, 0xA4, 0x27, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x24, 0x00, 0xBF, 0xAF, 0xFF, 0x00, 0xB1, 0x30,
+0x8A, 0x40, 0x00, 0x0C, 0xFF, 0x00, 0xD2, 0x30, 0x00, 0x80, 0x02, 0x34,
+0x20, 0x00, 0x02, 0x12, 0x21, 0x20, 0x20, 0x02, 0x75, 0x0D, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x03, 0x3C, 0x03, 0x02, 0x63, 0x34,
+0x00, 0x00, 0x62, 0x90, 0x00, 0x08, 0x04, 0x24, 0x01, 0x00, 0x05, 0x24,
+0x04, 0x00, 0x42, 0x34, 0x00, 0x00, 0x62, 0xA0, 0x35, 0x45, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x00, 0x09, 0x04, 0x24, 0x01, 0x00, 0x05, 0x24,
+0x35, 0x45, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x84, 0x08, 0x04, 0x24,
+0xFF, 0xFF, 0x05, 0x24, 0x35, 0x45, 0x00, 0x0C, 0x58, 0x00, 0x06, 0x24,
+0x18, 0x00, 0x04, 0x24, 0x00, 0x0C, 0x05, 0x24, 0x83, 0x45, 0x00, 0x0C,
+0x01, 0x00, 0x06, 0x24, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x01, 0x00, 0x02, 0x24, 0x02, 0x00, 0x42, 0x12, 0x02, 0x00, 0x24, 0x26,
+0xFE, 0xFF, 0x24, 0x26, 0x75, 0x0D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x07, 0x3C, 0x03, 0x02, 0xE7, 0x34, 0x00, 0x00, 0xE3, 0x90,
+0xFB, 0xFF, 0x02, 0x24, 0x00, 0x08, 0x04, 0x24, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x00, 0xE3, 0xA0, 0x01, 0x00, 0x05, 0x24, 0x35, 0x45, 0x00, 0x0C,
+0x01, 0x00, 0x06, 0x24, 0x03, 0x00, 0x50, 0x32, 0x00, 0x09, 0x04, 0x24,
+0x01, 0x00, 0x05, 0x24, 0x35, 0x45, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24,
+0x42, 0x30, 0x10, 0x00, 0x00, 0x0A, 0x04, 0x24, 0x35, 0x45, 0x00, 0x0C,
+0x10, 0x00, 0x05, 0x24, 0x21, 0x30, 0x00, 0x02, 0x00, 0x0D, 0x04, 0x24,
+0x35, 0x45, 0x00, 0x0C, 0x00, 0x0C, 0x05, 0x24, 0x84, 0x08, 0x04, 0x24,
+0xFF, 0xFF, 0x05, 0x24, 0x35, 0x45, 0x00, 0x0C, 0x18, 0x00, 0x06, 0x24,
+0x18, 0x00, 0x04, 0x24, 0x00, 0x0C, 0x05, 0x24, 0x83, 0x45, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0xD0, 0xFF, 0xBD, 0x27, 0x24, 0x00, 0xB3, 0xAF, 0x02, 0x80, 0x13, 0x3C,
+0x20, 0x00, 0xB2, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0x72, 0x26,
+0xFF, 0xFF, 0x90, 0x30, 0x10, 0x00, 0xA4, 0x27, 0x1C, 0x00, 0xB1, 0xAF,
+0x28, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0xFF, 0x00, 0xB1, 0x30,
+0xB0, 0x1B, 0x42, 0x96, 0x10, 0x00, 0xA4, 0x27, 0x00, 0x80, 0x42, 0x30,
+0x11, 0x00, 0x50, 0x10, 0x21, 0x30, 0x20, 0x02, 0xC4, 0x3D, 0x45, 0x92,
+0x3C, 0x0E, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02, 0x00, 0x80, 0x02, 0x34,
+0x14, 0x00, 0x02, 0x12, 0x00, 0x80, 0x02, 0x24, 0xB0, 0x1B, 0x42, 0x96,
+0x3B, 0x41, 0x51, 0xA2, 0xFF, 0x7F, 0x42, 0x30, 0xB0, 0x1B, 0x42, 0xA6,
+0x60, 0x1B, 0x62, 0x26, 0xB0, 0x1B, 0x45, 0x94, 0xC4, 0x3D, 0x44, 0x90,
+0x38, 0x0D, 0x00, 0x0C, 0x00, 0x10, 0xA5, 0x30, 0x10, 0x00, 0xA4, 0x27,
+0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0xBF, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xB0, 0x1B, 0x43, 0x96, 0x3B, 0x41, 0x51, 0xA2, 0x25, 0x18, 0x62, 0x00,
+0xB0, 0x0E, 0x00, 0x08, 0xB0, 0x1B, 0x43, 0xA6, 0xE0, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x14, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xBF, 0xAF, 0x53, 0x21, 0x00, 0x0C, 0x28, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0x21, 0x88, 0x40, 0x00, 0x21, 0x28, 0x00, 0x02,
+0x06, 0x00, 0x06, 0x24, 0x15, 0x00, 0x40, 0x10, 0xAC, 0xE8, 0x84, 0x24,
+0x08, 0x00, 0x44, 0x94, 0x08, 0x00, 0x02, 0x24, 0x0C, 0x00, 0x22, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0x0C, 0x00, 0x03, 0x24, 0x25, 0x20, 0x82, 0x00,
+0x14, 0x00, 0x23, 0xAE, 0xF4, 0x54, 0x00, 0x0C, 0x20, 0x00, 0x84, 0x24,
+0x17, 0x0A, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0x04, 0xE9, 0x84, 0x24, 0x21, 0x10, 0x00, 0x00,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x05, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xEC, 0xE8, 0xA5, 0x24, 0xE0, 0x0E, 0x00, 0x08,
+0xFF, 0xFF, 0x02, 0x24, 0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB3, 0xAF,
+0x21, 0x98, 0x80, 0x00, 0x2C, 0x00, 0x04, 0x24, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x21, 0x90, 0xA0, 0x00, 0x20, 0x00, 0xBF, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x04, 0x3C,
+0x02, 0x80, 0x05, 0x3C, 0x21, 0x88, 0x40, 0x00, 0x28, 0xE9, 0x84, 0x24,
+0x21, 0x30, 0x40, 0x02, 0x19, 0x00, 0x40, 0x10, 0x10, 0xE9, 0xA5, 0x24,
+0x05, 0x00, 0x65, 0x92, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x30, 0x96, 0x02, 0x80, 0x02, 0x3C, 0x0B, 0x00, 0x03, 0x24,
+0x25, 0x80, 0x02, 0x02, 0x20, 0x00, 0x10, 0x26, 0x0C, 0x00, 0x02, 0x24,
+0x21, 0x20, 0x00, 0x02, 0x0C, 0x00, 0x22, 0xAE, 0x14, 0x00, 0x23, 0xAE,
+0x21, 0x28, 0x60, 0x02, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x08, 0x00, 0x12, 0xAE, 0x21, 0x20, 0x20, 0x02, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x17, 0x0A, 0x00, 0x08, 0x28, 0x00, 0xBD, 0x27,
+0x02, 0x80, 0x04, 0x3C, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0xAC, 0xE8, 0x84, 0x24, 0x13, 0x58, 0x00, 0x08, 0x28, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90,
+0x02, 0x80, 0x11, 0x3C, 0x04, 0x00, 0x04, 0x24, 0x0F, 0x00, 0x63, 0x30,
+0x04, 0x00, 0x63, 0x28, 0x3A, 0x00, 0x60, 0x14, 0x01, 0x00, 0x05, 0x24,
+0x40, 0xDF, 0x23, 0x8E, 0x0F, 0x00, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xFF, 0xFF, 0xA5, 0x34, 0x24, 0x00, 0x04, 0x24, 0x60, 0x00, 0x06, 0x24,
+0x12, 0x00, 0x60, 0x14, 0x60, 0x1B, 0x50, 0x24, 0x83, 0x45, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x48, 0x41, 0x05, 0x92, 0xD0, 0x07, 0x02, 0x24,
+0x01, 0x00, 0x03, 0x24, 0x0A, 0x10, 0x05, 0x00, 0x3C, 0x3A, 0x02, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0xED, 0x5D, 0x44, 0x90, 0x40, 0xDF, 0x23, 0xAE,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x01, 0x00, 0x05, 0x24, 0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08,
+0x20, 0x00, 0xBD, 0x27, 0x0F, 0x00, 0x05, 0x3C, 0xFF, 0xFF, 0xA5, 0x34,
+0xAC, 0x45, 0x00, 0x0C, 0x24, 0x00, 0x04, 0x24, 0x49, 0x41, 0x04, 0x92,
+0xFF, 0x00, 0x43, 0x30, 0x00, 0x2C, 0x03, 0x00, 0x0A, 0x00, 0x64, 0x10,
+0x4A, 0x41, 0x02, 0xA2, 0x02, 0x80, 0x02, 0x3C, 0x49, 0xF5, 0x44, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x04, 0x00, 0x12, 0x27, 0x00, 0x74,
+0x25, 0x20, 0xA4, 0x00, 0x4A, 0x41, 0x03, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x49, 0x41, 0x03, 0xA2, 0x48, 0x41, 0x03, 0x92, 0x10, 0x27, 0x02, 0x24,
+0x40, 0xDF, 0x20, 0xAE, 0x0A, 0x10, 0x03, 0x00, 0x3C, 0x3A, 0x02, 0xAE,
+0x02, 0x80, 0x02, 0x3C, 0xED, 0x5D, 0x44, 0x90, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27,
+0x4B, 0x2E, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x28, 0x0F, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xC8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x34, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xBE, 0xAF,
+0x2C, 0x00, 0xB7, 0xAF, 0x28, 0x00, 0xB6, 0xAF, 0x24, 0x00, 0xB5, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x21, 0x80, 0x80, 0x00, 0x45, 0x00, 0xA0, 0x14, 0x21, 0x90, 0x00, 0x00,
+0x08, 0x00, 0x82, 0x90, 0x02, 0x80, 0x13, 0x3C, 0x60, 0x1B, 0x63, 0x26,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x40, 0x62, 0xAC, 0x25, 0xB0, 0x02, 0x3C,
+0x0A, 0x00, 0x10, 0x26, 0xD0, 0x01, 0x57, 0x34, 0x02, 0x80, 0x14, 0x3C,
+0xD8, 0x01, 0x5E, 0x34, 0xDC, 0x01, 0x55, 0x34, 0xD4, 0x01, 0x56, 0x34,
+0x03, 0x00, 0x11, 0x24, 0x00, 0x00, 0x06, 0x92, 0x60, 0x1B, 0x62, 0x26,
+0xB8, 0x40, 0x47, 0x90, 0x0F, 0x00, 0xC3, 0x30, 0x01, 0x00, 0x05, 0x92,
+0x18, 0x00, 0x67, 0x00, 0x03, 0x00, 0x04, 0x92, 0x02, 0x00, 0x02, 0x92,
+0x0F, 0x00, 0xA7, 0x30, 0x00, 0x3A, 0x07, 0x00, 0x02, 0x29, 0x05, 0x00,
+0x00, 0x22, 0x04, 0x00, 0x25, 0x20, 0x82, 0x00, 0x00, 0x2B, 0x05, 0x00,
+0x42, 0x11, 0x06, 0x00, 0x00, 0x24, 0x04, 0x00, 0x03, 0x00, 0x49, 0x30,
+0x02, 0x31, 0x06, 0x00, 0x01, 0x00, 0x02, 0x24, 0x01, 0x00, 0xC6, 0x30,
+0x12, 0x18, 0x00, 0x00, 0x0A, 0x00, 0x63, 0x24, 0xFF, 0x00, 0x63, 0x30,
+0x25, 0x18, 0x67, 0x00, 0x25, 0x18, 0x65, 0x00, 0x30, 0x00, 0x22, 0x11,
+0x25, 0x38, 0x64, 0x00, 0x02, 0x00, 0x22, 0x29, 0x3E, 0x00, 0x40, 0x14,
+0x02, 0x00, 0x02, 0x24, 0x38, 0x00, 0x22, 0x11, 0x03, 0x00, 0x02, 0x24,
+0x40, 0x00, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0x20, 0x01,
+0x64, 0xE9, 0x84, 0x26, 0x13, 0x58, 0x00, 0x0C, 0xFF, 0xFF, 0x31, 0x26,
+0xD9, 0xFF, 0x21, 0x06, 0x04, 0x00, 0x10, 0x26, 0x25, 0xB0, 0x02, 0x3C,
+0xE7, 0x01, 0x42, 0x34, 0x00, 0x00, 0x52, 0xA0, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xBE, 0x8F, 0x2C, 0x00, 0xB7, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x13, 0x3C,
+0x08, 0x00, 0x83, 0x90, 0x60, 0x1B, 0x62, 0x26, 0xC0, 0x40, 0x44, 0x8C,
+0x0F, 0x00, 0x63, 0x30, 0xBB, 0xFF, 0x83, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xBE, 0x8F, 0x2C, 0x00, 0xB7, 0x8F,
+0x28, 0x00, 0xB6, 0x8F, 0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0xA7, 0xAE, 0x21, 0x20, 0x00, 0x00, 0x25, 0xB0, 0x08, 0x3C,
+0x07, 0x10, 0x92, 0x00, 0x01, 0x00, 0x42, 0x30, 0x01, 0x00, 0x84, 0x24,
+0x02, 0x00, 0x40, 0x10, 0x03, 0x00, 0x85, 0x2C, 0xD0, 0x01, 0x07, 0xAD,
+0xF9, 0xFF, 0xA0, 0x14, 0x04, 0x00, 0x08, 0x25, 0xA3, 0x0F, 0x00, 0x08,
+0x21, 0x28, 0x20, 0x01, 0x0D, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xA2, 0x0F, 0x00, 0x08, 0x02, 0x00, 0x52, 0x36, 0xC7, 0xFF, 0x20, 0x15,
+0x21, 0x28, 0x20, 0x01, 0x0D, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xA3, 0x0F, 0x00, 0x08, 0x04, 0x00, 0x52, 0x36, 0x06, 0x00, 0xC0, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xA2, 0x0F, 0x00, 0x08, 0x01, 0x00, 0x52, 0x36,
+0x00, 0x00, 0xC7, 0xAE, 0xA3, 0x0F, 0x00, 0x08, 0x21, 0x28, 0x20, 0x01,
+0x00, 0x00, 0xE7, 0xAE, 0xA3, 0x0F, 0x00, 0x08, 0x21, 0x28, 0x20, 0x01,
+0x00, 0x00, 0xC7, 0xAF, 0xA3, 0x0F, 0x00, 0x08, 0x21, 0x28, 0x20, 0x01,
+0xB8, 0xFF, 0xBD, 0x27, 0x24, 0x00, 0xB1, 0xAF, 0x21, 0x88, 0x80, 0x00,
+0x00, 0x01, 0x04, 0x24, 0x2C, 0x00, 0xB3, 0xAF, 0x44, 0x00, 0xBF, 0xAF,
+0x40, 0x00, 0xBE, 0xAF, 0x3C, 0x00, 0xB7, 0xAF, 0x38, 0x00, 0xB6, 0xAF,
+0x34, 0x00, 0xB5, 0xAF, 0x30, 0x00, 0xB4, 0xAF, 0x28, 0x00, 0xB2, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0x20, 0x00, 0xB0, 0xAF, 0xAC, 0x00, 0x40, 0x10,
+0x21, 0x98, 0x40, 0x00, 0x08, 0x00, 0x50, 0x94, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x28, 0x20, 0x02, 0x25, 0x80, 0x02, 0x02, 0x24, 0x00, 0x04, 0x26,
+0x20, 0x00, 0x00, 0xA6, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x05, 0x3C, 0x2A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0xB4, 0x55, 0xA5, 0x24, 0x06, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x30, 0x00, 0x04, 0x26, 0x20, 0x00, 0x03, 0x96, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x54, 0x24, 0x03, 0xFF, 0x63, 0x30, 0x50, 0x00, 0x63, 0x34,
+0x20, 0x00, 0x03, 0xA6, 0xE4, 0x1D, 0x82, 0x96, 0x02, 0x80, 0x03, 0x3C,
+0xB0, 0x55, 0x63, 0x24, 0x74, 0x00, 0x72, 0x24, 0xFF, 0x0F, 0x43, 0x30,
+0x00, 0x19, 0x03, 0x00, 0x01, 0x00, 0x42, 0x24, 0x02, 0x22, 0x03, 0x00,
+0xE4, 0x1D, 0x82, 0xA6, 0x20, 0x00, 0x11, 0x26, 0x20, 0x00, 0x02, 0x24,
+0x16, 0x00, 0x23, 0xA2, 0x17, 0x00, 0x24, 0xA2, 0x21, 0x20, 0x40, 0x02,
+0xFB, 0x51, 0x00, 0x0C, 0x0C, 0x00, 0x62, 0xAE, 0x40, 0x00, 0x11, 0x26,
+0x21, 0x20, 0x20, 0x02, 0x21, 0x28, 0x40, 0x00, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x0C, 0x00, 0x63, 0x8E, 0x21, 0x20, 0x40, 0x02,
+0x42, 0x00, 0x11, 0x26, 0x02, 0x00, 0x63, 0x24, 0x16, 0x52, 0x00, 0x0C,
+0x0C, 0x00, 0x63, 0xAE, 0x21, 0x28, 0x40, 0x00, 0x21, 0x20, 0x20, 0x02,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24, 0x0C, 0x00, 0x63, 0x8E,
+0x02, 0x80, 0x02, 0x3C, 0xB0, 0x55, 0x42, 0x24, 0x02, 0x00, 0x63, 0x24,
+0x0C, 0x00, 0x63, 0xAE, 0x0C, 0x00, 0x46, 0x8C, 0x44, 0x00, 0x04, 0x26,
+0x0C, 0x00, 0x76, 0x26, 0x60, 0x00, 0x50, 0x24, 0x21, 0x28, 0x00, 0x00,
+0x10, 0x00, 0x47, 0x24, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB6, 0xAF,
+0x21, 0x20, 0x00, 0x02, 0x1B, 0x53, 0x00, 0x0C, 0x21, 0x88, 0x40, 0x00,
+0x09, 0x00, 0x43, 0x2C, 0x08, 0x00, 0x06, 0x24, 0x21, 0x20, 0x20, 0x02,
+0x0B, 0x30, 0x43, 0x00, 0x21, 0x38, 0x00, 0x02, 0x01, 0x00, 0x05, 0x24,
+0x18, 0x00, 0xA3, 0xAF, 0x21, 0xB8, 0x40, 0x00, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xB6, 0xAF, 0x21, 0x20, 0x40, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0xB0, 0x55, 0x42, 0x24, 0x03, 0x00, 0x05, 0x24, 0x01, 0x00, 0x06, 0x24,
+0x48, 0x00, 0x47, 0x24, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB6, 0xAF,
+0x21, 0x88, 0x40, 0x00, 0xC0, 0x3A, 0x82, 0x8E, 0x0C, 0x00, 0x10, 0x24,
+0x2B, 0x10, 0x02, 0x02, 0x3A, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x26, 0x56, 0x5E, 0x24, 0x68, 0x10, 0x00, 0x08, 0x21, 0xA8, 0x80, 0x02,
+0x21, 0x10, 0x12, 0x02, 0x01, 0x00, 0x43, 0x90, 0xC0, 0x3A, 0xA4, 0x8E,
+0x21, 0x18, 0x70, 0x00, 0x02, 0x00, 0x70, 0x24, 0x2B, 0x20, 0x04, 0x02,
+0x2F, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x12, 0x02,
+0x00, 0x00, 0x47, 0x90, 0x02, 0x80, 0x14, 0x3C, 0x2D, 0x00, 0x03, 0x24,
+0x21, 0x28, 0x1E, 0x02, 0x64, 0x5C, 0x84, 0x26, 0xF1, 0xFF, 0xE3, 0x14,
+0x20, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x41, 0xA3, 0x96, 0x02, 0x80, 0x02, 0x3C, 0xC6, 0x5C, 0x47, 0x90,
+0xBD, 0xFF, 0x63, 0x30, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0x0C, 0x00, 0x63, 0x34, 0x01, 0x00, 0xE7, 0x30, 0x44, 0xDF, 0xA5, 0x24,
+0x67, 0x5C, 0x44, 0x24, 0x10, 0x00, 0x06, 0x24, 0x06, 0x00, 0xE0, 0x14,
+0x04, 0x41, 0xA3, 0xA6, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x54, 0xDF, 0xA5, 0x24, 0x67, 0x5C, 0x64, 0x24, 0x10, 0x00, 0x06, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x12, 0x02,
+0x01, 0x00, 0x46, 0x90, 0x21, 0x20, 0x20, 0x02, 0x64, 0x5C, 0x87, 0x26,
+0x2D, 0x00, 0x05, 0x24, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB6, 0xAF,
+0x21, 0x88, 0x40, 0x00, 0x21, 0x10, 0x12, 0x02, 0x01, 0x00, 0x43, 0x90,
+0xC0, 0x3A, 0xA4, 0x8E, 0x21, 0x18, 0x70, 0x00, 0x02, 0x00, 0x70, 0x24,
+0x2B, 0x20, 0x04, 0x02, 0xD4, 0xFF, 0x80, 0x14, 0x21, 0x10, 0x12, 0x02,
+0x18, 0x00, 0xA2, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x40, 0x10,
+0x21, 0x20, 0x60, 0x02, 0x44, 0x00, 0xBF, 0x8F, 0x40, 0x00, 0xBE, 0x8F,
+0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F, 0x34, 0x00, 0xB5, 0x8F,
+0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F,
+0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0x21, 0x30, 0x00, 0x00, 0x21, 0x38, 0x00, 0x00, 0xDF, 0x0D, 0x00, 0x08,
+0x48, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x44, 0x00, 0xBF, 0x8F, 0x40, 0x00, 0xBE, 0x8F, 0x3C, 0x00, 0xB7, 0x8F,
+0x38, 0x00, 0xB6, 0x8F, 0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F,
+0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F,
+0x20, 0x00, 0xB0, 0x8F, 0x58, 0xE9, 0x84, 0x24, 0xAC, 0xE9, 0xA5, 0x24,
+0x13, 0x58, 0x00, 0x08, 0x48, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x03, 0x3C,
+0xB0, 0x55, 0x63, 0x24, 0x21, 0x20, 0x20, 0x02, 0xF8, 0xFF, 0xE6, 0x26,
+0x68, 0x00, 0x67, 0x24, 0x32, 0x00, 0x05, 0x24, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xB6, 0xAF, 0x21, 0x20, 0x60, 0x02, 0x44, 0x00, 0xBF, 0x8F,
+0x40, 0x00, 0xBE, 0x8F, 0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F,
+0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F,
+0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F,
+0x01, 0x00, 0x05, 0x24, 0x21, 0x30, 0x00, 0x00, 0x21, 0x38, 0x00, 0x00,
+0xDF, 0x0D, 0x00, 0x08, 0x48, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x20, 0x00, 0xBF, 0xAF,
+0x02, 0x00, 0x82, 0x90, 0x02, 0x80, 0x03, 0x3C, 0x10, 0x37, 0x65, 0x94,
+0x0F, 0x00, 0x42, 0x30, 0x00, 0x00, 0x83, 0x8C, 0xC0, 0x10, 0x02, 0x00,
+0x21, 0x20, 0x44, 0x00, 0x00, 0x10, 0xA8, 0x30, 0x02, 0x80, 0x02, 0x3C,
+0x00, 0x08, 0xA5, 0x30, 0xB0, 0x55, 0x51, 0x24, 0xFF, 0x3F, 0x63, 0x30,
+0x06, 0x00, 0xA0, 0x10, 0x18, 0x00, 0x90, 0x24, 0xE8, 0xFF, 0x67, 0x24,
+0x30, 0x00, 0x84, 0x24, 0x21, 0x28, 0x00, 0x00, 0x07, 0x00, 0x00, 0x11,
+0x10, 0x00, 0xA6, 0x27, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xAB, 0x1A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xF7, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x44, 0x24,
+0x10, 0x00, 0xA2, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40, 0x10,
+0x10, 0x00, 0x25, 0x26, 0x0C, 0x00, 0x26, 0x8E, 0x1D, 0x55, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xED, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x26, 0x53, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02, 0xEE, 0x0F, 0x00, 0x0C,
+0x21, 0x20, 0x40, 0x00, 0xE8, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0xA0, 0xFF, 0xBD, 0x27, 0x58, 0x00, 0xBE, 0xAF, 0x5C, 0x00, 0xBF, 0xAF,
+0x54, 0x00, 0xB7, 0xAF, 0x50, 0x00, 0xB6, 0xAF, 0x4C, 0x00, 0xB5, 0xAF,
+0x48, 0x00, 0xB4, 0xAF, 0x44, 0x00, 0xB3, 0xAF, 0x40, 0x00, 0xB2, 0xAF,
+0x3C, 0x00, 0xB1, 0xAF, 0x38, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0x46, 0x30, 0xE8, 0xFF, 0xC5, 0x24,
+0x01, 0x03, 0xA2, 0x2C, 0x16, 0x00, 0x40, 0x14, 0x21, 0xF0, 0x80, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x63, 0x24, 0x40, 0x3E, 0x62, 0x8C,
+0x02, 0x80, 0x04, 0x3C, 0xD0, 0xE9, 0x84, 0x24, 0x01, 0x00, 0x42, 0x24,
+0x40, 0x3E, 0x62, 0xAC, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x5C, 0x00, 0xBF, 0x8F, 0x58, 0x00, 0xBE, 0x8F, 0x54, 0x00, 0xB7, 0x8F,
+0x50, 0x00, 0xB6, 0x8F, 0x4C, 0x00, 0xB5, 0x8F, 0x48, 0x00, 0xB4, 0x8F,
+0x44, 0x00, 0xB3, 0x8F, 0x40, 0x00, 0xB2, 0x8F, 0x3C, 0x00, 0xB1, 0x8F,
+0x38, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x60, 0x00, 0xBD, 0x27,
+0x7C, 0x00, 0xC4, 0x24, 0x5C, 0x00, 0xC6, 0x24, 0x53, 0x21, 0x00, 0x0C,
+0x24, 0x00, 0xA6, 0xAF, 0x74, 0x00, 0x40, 0x10, 0x20, 0x00, 0xA2, 0xAF,
+0x20, 0x00, 0xA3, 0x8F, 0x24, 0x00, 0xA6, 0x8F, 0x21, 0x28, 0x00, 0x00,
+0x08, 0x00, 0x62, 0x94, 0x02, 0x80, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00,
+0x20, 0x00, 0x57, 0x24, 0xE3, 0x54, 0x00, 0x0C, 0x21, 0x20, 0xE0, 0x02,
+0x02, 0x80, 0x03, 0x3C, 0xE8, 0xE9, 0x62, 0x24, 0xE8, 0xE9, 0x67, 0x90,
+0x01, 0x00, 0x44, 0x90, 0x02, 0x00, 0xC3, 0x93, 0x02, 0x00, 0x45, 0x90,
+0x03, 0x00, 0x46, 0x90, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x50, 0x24,
+0x00, 0x00, 0xC2, 0x8F, 0x00, 0x22, 0x04, 0x00, 0x0F, 0x00, 0x63, 0x30,
+0x25, 0x20, 0x87, 0x00, 0x00, 0x2C, 0x05, 0x00, 0xC0, 0x18, 0x03, 0x00,
+0x4B, 0x41, 0x07, 0x92, 0x21, 0x18, 0x7E, 0x00, 0x25, 0x28, 0xA4, 0x00,
+0xFF, 0x3F, 0x42, 0x30, 0x00, 0x36, 0x06, 0x00, 0x25, 0x30, 0xC5, 0x00,
+0x30, 0x00, 0xA2, 0xAF, 0x22, 0x00, 0x64, 0x24, 0x18, 0x00, 0x62, 0x24,
+0x10, 0x00, 0xA6, 0xAF, 0x2C, 0x00, 0xA4, 0xAF, 0x28, 0x00, 0xA2, 0xAF,
+0x53, 0x00, 0xE0, 0x14, 0x28, 0x00, 0x76, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x54, 0x24, 0xA5, 0x59, 0x73, 0x24,
+0x21, 0x90, 0x00, 0x00, 0x01, 0x00, 0x15, 0x24, 0x64, 0x11, 0x00, 0x08,
+0x21, 0x80, 0x00, 0x00, 0x1D, 0x55, 0x00, 0x0C, 0x01, 0x00, 0x52, 0x26,
+0x07, 0x00, 0x10, 0x26, 0x32, 0x00, 0x40, 0x10, 0x40, 0x00, 0x43, 0x2A,
+0x0C, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0x88, 0x14, 0x02,
+0x44, 0x3E, 0x22, 0x92, 0x21, 0x20, 0x13, 0x02, 0x21, 0x28, 0xC0, 0x02,
+0xF4, 0xFF, 0x55, 0x10, 0x06, 0x00, 0x06, 0x24, 0x21, 0x20, 0x13, 0x02,
+0x21, 0x28, 0xC0, 0x02, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x44, 0x3E, 0x35, 0xA2, 0x30, 0x00, 0xA4, 0x8F, 0x74, 0x00, 0xF4, 0x26,
+0x80, 0x00, 0xF3, 0x26, 0x5C, 0x00, 0x83, 0x24, 0xE8, 0xFF, 0x82, 0x24,
+0x1C, 0x00, 0xA2, 0xAF, 0x00, 0x00, 0xE3, 0xAE, 0x28, 0x00, 0xA3, 0x8F,
+0x1C, 0x00, 0xA2, 0x8F, 0x21, 0x20, 0x80, 0x02, 0x18, 0x00, 0x65, 0x24,
+0x21, 0x30, 0x40, 0x00, 0xF4, 0x54, 0x00, 0x0C, 0x70, 0x00, 0xE2, 0xAE,
+0x70, 0x00, 0xE7, 0x8E, 0x21, 0x20, 0x60, 0x02, 0x21, 0x28, 0x00, 0x00,
+0xF4, 0xFF, 0xE7, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x1C, 0x00, 0xA6, 0x27,
+0x0F, 0x00, 0x40, 0x10, 0x21, 0x80, 0x40, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x60, 0x1B, 0x91, 0x24, 0x0C, 0x3E, 0x26, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x32, 0x00, 0xC0, 0x18, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xA2, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0xC2, 0x10, 0x02, 0x80, 0x04, 0x3C,
+0xC0, 0x10, 0x12, 0x00, 0x23, 0x10, 0x52, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x44, 0x3E, 0x40, 0xA0, 0x20, 0x00, 0xA4, 0x8F, 0x74, 0x21, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x5C, 0x00, 0xBF, 0x8F, 0x58, 0x00, 0xBE, 0x8F,
+0x54, 0x00, 0xB7, 0x8F, 0x50, 0x00, 0xB6, 0x8F, 0x4C, 0x00, 0xB5, 0x8F,
+0x48, 0x00, 0xB4, 0x8F, 0x44, 0x00, 0xB3, 0x8F, 0x40, 0x00, 0xB2, 0x8F,
+0x3C, 0x00, 0xB1, 0x8F, 0x38, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x60, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0xAC, 0xE8, 0x84, 0x24, 0x1B, 0x11, 0x00, 0x08, 0xBC, 0xE9, 0xA5, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0xAC, 0x5C, 0x84, 0x24, 0x21, 0x28, 0xC0, 0x02,
+0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0xA8, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x8A, 0x40, 0x00, 0x0C, 0x18, 0x00, 0xA4, 0x27,
+0x52, 0x41, 0x02, 0x92, 0x18, 0x00, 0xA4, 0x27, 0x01, 0x00, 0x42, 0x24,
+0x90, 0x40, 0x00, 0x0C, 0x52, 0x41, 0x02, 0xA2, 0x56, 0x11, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0x70, 0x59, 0x84, 0x24, 0x1D, 0x55, 0x00, 0x0C,
+0x02, 0x00, 0x05, 0x26, 0xD5, 0xFF, 0x40, 0x14, 0xC0, 0x10, 0x12, 0x00,
+0x01, 0x00, 0x06, 0x92, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0xC0, 0x14,
+0x10, 0x00, 0xE4, 0x26, 0x0C, 0x00, 0xE0, 0xAE, 0x02, 0x00, 0xC2, 0x97,
+0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x04, 0x00, 0x42, 0x28,
+0x5E, 0x00, 0x40, 0x10, 0x21, 0x20, 0xC0, 0x03, 0x34, 0x00, 0xE0, 0xAE,
+0x60, 0x00, 0xF1, 0x26, 0x21, 0x20, 0x20, 0x02, 0x21, 0x28, 0x00, 0x00,
+0xE3, 0x54, 0x00, 0x0C, 0x10, 0x00, 0x06, 0x24, 0x70, 0x00, 0xE7, 0x8E,
+0x21, 0x20, 0x60, 0x02, 0x01, 0x00, 0x05, 0x24, 0xF4, 0xFF, 0xE7, 0x24,
+0xAB, 0x1A, 0x00, 0x0C, 0x1C, 0x00, 0xA6, 0x27, 0x06, 0x00, 0x40, 0x10,
+0x21, 0x90, 0x00, 0x00, 0x1C, 0x00, 0xA6, 0x8F, 0x02, 0x00, 0x45, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02, 0x1C, 0x00, 0xB2, 0x8F,
+0x70, 0x00, 0xE7, 0x8E, 0x21, 0x20, 0x60, 0x02, 0x32, 0x00, 0x05, 0x24,
+0xF4, 0xFF, 0xE7, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x1C, 0x00, 0xA6, 0x27,
+0x05, 0x00, 0x40, 0x10, 0x21, 0x20, 0xF2, 0x02, 0x1C, 0x00, 0xA6, 0x8F,
+0x60, 0x00, 0x84, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x45, 0x24,
+0x1C, 0x00, 0xA5, 0x8F, 0x21, 0x20, 0x20, 0x02, 0x61, 0x53, 0x00, 0x0C,
+0x21, 0x28, 0xB2, 0x00, 0x21, 0x18, 0x40, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x40, 0x00, 0x62, 0x10, 0x03, 0x00, 0x02, 0x24, 0x38, 0x00, 0xE2, 0xAE,
+0x70, 0x00, 0xE7, 0x8E, 0x21, 0x20, 0x60, 0x02, 0x03, 0x00, 0x05, 0x24,
+0xF4, 0xFF, 0xE7, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x1C, 0x00, 0xA6, 0x27,
+0x48, 0x00, 0xE0, 0xAE, 0x04, 0x00, 0x40, 0x10, 0x3C, 0x00, 0xE0, 0xAE,
+0x02, 0x00, 0x42, 0x90, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0xE2, 0xAE,
+0xFB, 0x51, 0x00, 0x0C, 0x21, 0x20, 0x80, 0x02, 0x21, 0x28, 0x40, 0x00,
+0x40, 0x00, 0xE4, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24,
+0x18, 0x52, 0x00, 0x0C, 0x21, 0x20, 0xE0, 0x02, 0xFF, 0xFF, 0x50, 0x30,
+0x01, 0x00, 0x02, 0x32, 0x1A, 0x00, 0x40, 0x10, 0x21, 0x28, 0xC0, 0x02,
+0x01, 0x00, 0x02, 0x24, 0x5C, 0x00, 0xE2, 0xAE, 0x2C, 0x00, 0xA5, 0x8F,
+0x04, 0x00, 0xE4, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x10, 0x00, 0x02, 0x32, 0x13, 0x00, 0x40, 0x10, 0x01, 0x00, 0x02, 0x24,
+0x30, 0x00, 0xE2, 0xAE, 0x02, 0x80, 0x03, 0x3C, 0x44, 0x00, 0xE0, 0xAE,
+0x60, 0x1B, 0x62, 0x24, 0x3C, 0x3E, 0x43, 0x8C, 0x20, 0x00, 0xA4, 0x8F,
+0x01, 0x00, 0x63, 0x24, 0x3C, 0x3E, 0x43, 0xAC, 0x24, 0x00, 0xA3, 0x8F,
+0x08, 0x00, 0x02, 0x24, 0x0C, 0x00, 0x83, 0xAC, 0x20, 0x00, 0xA3, 0x8F,
+0x17, 0x0A, 0x00, 0x0C, 0x14, 0x00, 0x62, 0xAC, 0x1D, 0x11, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0x12, 0x00, 0x08, 0x5C, 0x00, 0xE0, 0xAE,
+0x11, 0x12, 0x00, 0x08, 0x30, 0x00, 0xE0, 0xAE, 0xE3, 0x17, 0x00, 0x0C,
+0x18, 0x00, 0xC5, 0x27, 0xC8, 0x11, 0x00, 0x08, 0x34, 0x00, 0xE2, 0xAE,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x05, 0x26, 0x01, 0x00, 0x03, 0x92,
+0xC1, 0x11, 0x00, 0x08, 0x0C, 0x00, 0xE3, 0xAE, 0xEF, 0x11, 0x00, 0x08,
+0x38, 0x00, 0xE3, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x44, 0x24,
+0xFC, 0x40, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x60, 0x10,
+0x01, 0x00, 0x05, 0x24, 0xB6, 0x40, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x42, 0x2C, 0x07, 0x00, 0x40, 0x10, 0x21, 0x28, 0x00, 0x00,
+0xC7, 0x3D, 0x83, 0x90, 0x01, 0x00, 0x02, 0x24, 0x03, 0x00, 0x62, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x01, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0x82, 0x24, 0x44, 0x41, 0x45, 0x8C,
+0x40, 0x41, 0x46, 0x8C, 0x21, 0x20, 0x40, 0x00, 0x40, 0x18, 0x05, 0x00,
+0x40, 0x10, 0x06, 0x00, 0x2B, 0x18, 0x66, 0x00, 0x2B, 0x38, 0x45, 0x00,
+0x04, 0x00, 0x60, 0x14, 0x21, 0x28, 0x00, 0x00, 0x01, 0x00, 0x05, 0x24,
+0x02, 0x00, 0x02, 0x24, 0x0A, 0x28, 0x47, 0x00, 0x21, 0x10, 0xA0, 0x00,
+0x40, 0x41, 0x80, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x44, 0x41, 0x80, 0xAC,
+0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF,
+0x43, 0x12, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x80, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xCE, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x12, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x12, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x24, 0x0D, 0x00, 0x43, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x16, 0x5C, 0x44, 0x90, 0x02, 0x80, 0x02, 0x3C,
+0xD4, 0xDD, 0x42, 0x24, 0x40, 0x18, 0x04, 0x00, 0x21, 0x18, 0x64, 0x00,
+0x21, 0x18, 0x70, 0x00, 0x80, 0x18, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x64, 0x8C, 0x25, 0xB0, 0x02, 0x3C, 0xD8, 0x01, 0x42, 0x34,
+0x00, 0x00, 0x44, 0xAC, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x02, 0x00, 0x84, 0x90, 0x02, 0x80, 0x05, 0x3C, 0x48, 0x37, 0xA5, 0x24,
+0x0F, 0x00, 0x84, 0x30, 0xC0, 0x20, 0x04, 0x00, 0x21, 0x20, 0x90, 0x00,
+0x1C, 0x00, 0x84, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x06, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x10, 0x37, 0x43, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x63, 0x30, 0x06, 0x00, 0x60, 0x14,
+0x21, 0x20, 0x00, 0x02, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0x02, 0x11, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0xE0, 0xFF, 0xBD, 0x27, 0x54, 0x4A, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x18, 0x00, 0xB0, 0xAF, 0x1C, 0x00, 0xBF, 0xAF, 0x00, 0x00, 0x43, 0xAC,
+0x02, 0x00, 0x82, 0x90, 0x02, 0x80, 0x05, 0x3C, 0xB4, 0x55, 0xA5, 0x24,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x10, 0x02, 0x00, 0x21, 0x10, 0x44, 0x00,
+0x28, 0x00, 0x44, 0x24, 0x06, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C,
+0x18, 0x00, 0x50, 0x24, 0x06, 0x00, 0x40, 0x10, 0x21, 0x20, 0x00, 0x02,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x39, 0x53, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x48, 0x37, 0x84, 0x24,
+0x21, 0x28, 0x40, 0x00, 0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0xF3, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x02, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x42, 0x30, 0xEE, 0xFF, 0x40, 0x10,
+0x10, 0x00, 0xA4, 0x27, 0x8A, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xEC, 0x5D, 0x43, 0x90, 0x05, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x63, 0x30, 0x05, 0x00, 0x62, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0xA9, 0x12, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x37, 0x43, 0x94, 0x02, 0x80, 0x04, 0x3C,
+0x00, 0x01, 0x63, 0x30, 0xF8, 0xFF, 0x60, 0x10, 0x01, 0x00, 0x05, 0x24,
+0x07, 0x5E, 0x83, 0x90, 0xFB, 0xFF, 0x02, 0x24, 0x24, 0x18, 0x62, 0x00,
+0x07, 0x5E, 0x83, 0xA0, 0x02, 0x80, 0x02, 0x3C, 0xED, 0x5D, 0x44, 0x90,
+0x4B, 0x2E, 0x00, 0x0C, 0xFF, 0x00, 0x84, 0x30, 0x90, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0xA9, 0x12, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0xD8, 0xFF, 0xBD, 0x27, 0x28, 0x00, 0xA4, 0xA3, 0x00, 0x01, 0x04, 0x24,
+0x18, 0x00, 0xB2, 0xAF, 0x24, 0x00, 0xBF, 0xAF, 0x20, 0x00, 0xB4, 0xAF,
+0x1C, 0x00, 0xB3, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x2C, 0x00, 0xA5, 0xA3, 0x53, 0x21, 0x00, 0x0C, 0x30, 0x00, 0xA6, 0xA7,
+0xA4, 0x00, 0x40, 0x10, 0x21, 0x90, 0x40, 0x00, 0x30, 0x00, 0xA7, 0x97,
+0x28, 0x00, 0xA5, 0x93, 0x2C, 0x00, 0xA6, 0x93, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xB0, 0xEA, 0x84, 0x24, 0x08, 0x00, 0x50, 0x96,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x11, 0x3C, 0x25, 0x80, 0x02, 0x02,
+0xB4, 0x55, 0x31, 0x26, 0x21, 0x28, 0x20, 0x02, 0x24, 0x00, 0x04, 0x26,
+0x06, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x20, 0x00, 0x00, 0xA6,
+0x02, 0x80, 0x05, 0x3C, 0x48, 0x37, 0xA5, 0x24, 0x2A, 0x00, 0x04, 0x26,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x21, 0x28, 0x20, 0x02,
+0x30, 0x00, 0x04, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x20, 0x00, 0x03, 0x96, 0x18, 0x00, 0x02, 0x24, 0x02, 0x80, 0x14, 0x3C,
+0x03, 0xFF, 0x63, 0x30, 0xD0, 0x00, 0x63, 0x34, 0x20, 0x00, 0x03, 0xA6,
+0x60, 0x1B, 0x93, 0x26, 0x0C, 0x00, 0x42, 0xAE, 0xE4, 0x1D, 0x62, 0x96,
+0x20, 0x00, 0x05, 0x26, 0x0C, 0x00, 0x51, 0x26, 0xFF, 0x0F, 0x43, 0x30,
+0x00, 0x19, 0x03, 0x00, 0x02, 0x22, 0x03, 0x00, 0x01, 0x00, 0x42, 0x24,
+0xE4, 0x1D, 0x62, 0xA6, 0x28, 0x00, 0xA6, 0x27, 0x16, 0x00, 0xA3, 0xA0,
+0x17, 0x00, 0xA4, 0xA0, 0x21, 0x38, 0x20, 0x02, 0x38, 0x00, 0x04, 0x26,
+0x4C, 0x52, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0x21, 0x20, 0x40, 0x00,
+0x01, 0x00, 0x05, 0x24, 0x2C, 0x00, 0xA6, 0x27, 0x4C, 0x52, 0x00, 0x0C,
+0x21, 0x38, 0x20, 0x02, 0x28, 0x00, 0xA3, 0x93, 0x21, 0x20, 0x40, 0x00,
+0x03, 0x00, 0x02, 0x24, 0x12, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x82, 0x26, 0xB6, 0x40, 0x43, 0x90, 0x04, 0x00, 0x07, 0x24,
+0x21, 0x20, 0x40, 0x02, 0x01, 0x00, 0x63, 0x38, 0x0B, 0x38, 0x03, 0x00,
+0x21, 0x28, 0x00, 0x00, 0xDF, 0x0D, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27, 0x2C, 0x00, 0xA3, 0x93,
+0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x60, 0x14, 0x01, 0x00, 0x02, 0x24,
+0xC5, 0x40, 0x63, 0x92, 0x21, 0x80, 0x60, 0x02, 0x01, 0x00, 0x68, 0x24,
+0xFF, 0x00, 0x02, 0x31, 0xFD, 0xFF, 0x40, 0x10, 0x21, 0x18, 0x00, 0x01,
+0x02, 0x80, 0x06, 0x3C, 0x21, 0x38, 0x20, 0x02, 0xC5, 0x40, 0x08, 0xA2,
+0x25, 0x5C, 0xC6, 0x24, 0x4C, 0x52, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24,
+0xC8, 0x40, 0x08, 0x8E, 0x30, 0x00, 0xA4, 0x97, 0xC3, 0xFF, 0x03, 0x24,
+0x02, 0x00, 0x08, 0x35, 0x0F, 0x00, 0x84, 0x30, 0x24, 0x40, 0x03, 0x01,
+0x80, 0x20, 0x04, 0x00, 0xFF, 0xFF, 0x03, 0x3C, 0x3F, 0x00, 0x63, 0x34,
+0x25, 0x40, 0x04, 0x01, 0x24, 0x40, 0x03, 0x01, 0x00, 0x08, 0x08, 0x35,
+0x02, 0x80, 0x06, 0x3C, 0x21, 0x38, 0x20, 0x02, 0xC8, 0x40, 0x08, 0xAE,
+0x28, 0x5C, 0xC6, 0x24, 0x21, 0x20, 0x40, 0x00, 0x4C, 0x52, 0x00, 0x0C,
+0x02, 0x00, 0x05, 0x24, 0x02, 0x80, 0x06, 0x3C, 0x21, 0x38, 0x20, 0x02,
+0x2A, 0x5C, 0xC6, 0x24, 0x21, 0x20, 0x40, 0x00, 0x02, 0x00, 0x05, 0x24,
+0x4C, 0x52, 0x00, 0x0C, 0xCA, 0x40, 0x00, 0xA6, 0x30, 0x00, 0xA3, 0x97,
+0x21, 0x20, 0x40, 0x00, 0x02, 0x80, 0x06, 0x3C, 0x07, 0x00, 0x63, 0x30,
+0x40, 0x18, 0x03, 0x00, 0x21, 0x18, 0x70, 0x00, 0xD4, 0x1D, 0x62, 0x94,
+0x2C, 0x5C, 0xC6, 0x24, 0x21, 0x38, 0x20, 0x02, 0x00, 0x11, 0x02, 0x00,
+0x02, 0x00, 0x05, 0x24, 0x4C, 0x52, 0x00, 0x0C, 0xCC, 0x40, 0x02, 0xA6,
+0x22, 0x13, 0x00, 0x08, 0x60, 0x1B, 0x82, 0x26, 0xB5, 0xFF, 0x62, 0x14,
+0x02, 0x80, 0x06, 0x3C, 0x21, 0x38, 0x20, 0x02, 0x24, 0x5C, 0xC6, 0x24,
+0x4C, 0x52, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0x21, 0x20, 0x40, 0x00,
+0x30, 0x00, 0xA6, 0x27, 0x21, 0x38, 0x20, 0x02, 0x4C, 0x52, 0x00, 0x0C,
+0x02, 0x00, 0x05, 0x24, 0xC8, 0x40, 0x68, 0x8E, 0xFF, 0xFF, 0x03, 0x3C,
+0x3F, 0x00, 0x63, 0x34, 0x24, 0x40, 0x03, 0x01, 0x00, 0x08, 0x08, 0x35,
+0x02, 0x80, 0x06, 0x3C, 0x21, 0x38, 0x20, 0x02, 0x21, 0x20, 0x40, 0x00,
+0x28, 0x5C, 0xC6, 0x24, 0x02, 0x00, 0x05, 0x24, 0x4C, 0x52, 0x00, 0x0C,
+0xC8, 0x40, 0x68, 0xAE, 0x02, 0x80, 0x06, 0x3C, 0x21, 0x20, 0x40, 0x00,
+0x2A, 0x5C, 0xC6, 0x24, 0x21, 0x38, 0x20, 0x02, 0x4C, 0x52, 0x00, 0x0C,
+0x02, 0x00, 0x05, 0x24, 0x22, 0x13, 0x00, 0x08, 0x60, 0x1B, 0x82, 0x26,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0xAC, 0xE8, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0xA0, 0xEA, 0xA5, 0x24, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xBF, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x82, 0x90,
+0x02, 0x80, 0x11, 0x3C, 0x21, 0x80, 0x80, 0x00, 0x60, 0x1B, 0x31, 0x26,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x00, 0x06, 0x24, 0x01, 0x00, 0x05, 0x26,
+0x28, 0x5C, 0x84, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0xC4, 0x40, 0x22, 0xA2,
+0x04, 0x00, 0x03, 0x92, 0x03, 0x00, 0x02, 0x92, 0x00, 0x1A, 0x03, 0x00,
+0x25, 0x18, 0x62, 0x00, 0xCA, 0x40, 0x23, 0xA6, 0x06, 0x00, 0x02, 0x92,
+0x05, 0x00, 0x03, 0x92, 0x00, 0x12, 0x02, 0x00, 0x25, 0x10, 0x43, 0x00,
+0xCC, 0x40, 0x22, 0xA6, 0x01, 0x00, 0x05, 0x92, 0x06, 0x00, 0x04, 0x92,
+0x05, 0x00, 0x02, 0x92, 0x82, 0x28, 0x05, 0x00, 0x00, 0x22, 0x04, 0x00,
+0x25, 0x20, 0x82, 0x00, 0x6A, 0x48, 0x00, 0x0C, 0x0F, 0x00, 0xA5, 0x30,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x03, 0x00, 0x04, 0x24, 0x01, 0x00, 0x05, 0x24, 0x21, 0x30, 0x00, 0x00,
+0xD9, 0x12, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x03, 0x42, 0x34,
+0xFC, 0x4E, 0x63, 0x24, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB2, 0xAF, 0x00, 0x00, 0x43, 0xAC,
+0x02, 0x00, 0x82, 0x90, 0x02, 0x80, 0x05, 0x3C, 0xB4, 0x55, 0xA5, 0x24,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x10, 0x02, 0x00, 0x21, 0x88, 0x44, 0x00,
+0x28, 0x00, 0x24, 0x26, 0x06, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C,
+0x18, 0x00, 0x30, 0x26, 0x08, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x39, 0x53, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02,
+0x02, 0x80, 0x04, 0x3C, 0x48, 0x37, 0x84, 0x24, 0x21, 0x28, 0x40, 0x00,
+0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0xF1, 0xFF, 0x40, 0x14,
+0x03, 0x00, 0x02, 0x24, 0x30, 0x00, 0x23, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xED, 0xFF, 0x62, 0x14, 0x30, 0x00, 0x24, 0x26, 0x02, 0x80, 0x07, 0x3C,
+0x60, 0x1B, 0xE5, 0x24, 0xFC, 0x40, 0xA2, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0xE7, 0xFF, 0x40, 0x10, 0x01, 0x00, 0x06, 0x24, 0x01, 0x00, 0x83, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x66, 0x10, 0x02, 0x00, 0x62, 0x28,
+0x2E, 0x00, 0x40, 0x14, 0x02, 0x00, 0x02, 0x24, 0xDF, 0xFF, 0x62, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x83, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x62, 0x30, 0x0A, 0x00, 0x40, 0x14, 0x02, 0x11, 0x03, 0x00,
+0xC6, 0x40, 0xA3, 0x90, 0x04, 0x10, 0x46, 0x00, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x10, 0x43, 0x00, 0xC6, 0x40, 0xA2, 0xA0, 0x05, 0x00, 0x83, 0x90,
+0x04, 0x00, 0x82, 0x90, 0x00, 0x1A, 0x03, 0x00, 0x25, 0x90, 0x62, 0x00,
+0xC6, 0x40, 0xA5, 0x90, 0x02, 0x80, 0x04, 0x3C, 0xCC, 0xEA, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x21, 0x30, 0x40, 0x02, 0xD5, 0x13, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x82, 0x90, 0x05, 0x00, 0x83, 0x90,
+0x03, 0x00, 0x84, 0x90, 0x00, 0x12, 0x02, 0x00, 0x82, 0x18, 0x03, 0x00,
+0x25, 0x10, 0x44, 0x00, 0x15, 0x00, 0x40, 0x14, 0x07, 0x00, 0x64, 0x30,
+0xC6, 0x40, 0xA3, 0x90, 0x04, 0x10, 0x86, 0x00, 0x25, 0x10, 0x43, 0x00,
+0xC6, 0x40, 0xA2, 0xA0, 0x60, 0x1B, 0xE2, 0x24, 0xF8, 0x40, 0x43, 0x90,
+0xC6, 0x40, 0x45, 0x90, 0x02, 0x80, 0x04, 0x3C, 0x21, 0x18, 0x62, 0x00,
+0xDC, 0xEA, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0xF0, 0x40, 0x60, 0xA0,
+0xD5, 0x13, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xB2, 0xFF, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x97, 0x13, 0x00, 0x0C, 0x32, 0x00, 0x24, 0x26,
+0xD5, 0x13, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x40, 0xA3, 0x90,
+0x04, 0x10, 0x86, 0x00, 0x27, 0x10, 0x02, 0x00, 0x17, 0x14, 0x00, 0x08,
+0x24, 0x10, 0x43, 0x00, 0xB8, 0xFF, 0xBD, 0x27, 0x38, 0x00, 0xB6, 0xAF,
+0xFF, 0xFF, 0x96, 0x30, 0x00, 0x01, 0x04, 0x24, 0x3C, 0x00, 0xB7, 0xAF,
+0x28, 0x00, 0xB2, 0xAF, 0x40, 0x00, 0xBF, 0xAF, 0x34, 0x00, 0xB5, 0xAF,
+0x30, 0x00, 0xB4, 0xAF, 0x2C, 0x00, 0xB3, 0xAF, 0x24, 0x00, 0xB1, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0x20, 0x00, 0xB0, 0xAF, 0x21, 0x90, 0x40, 0x00,
+0x81, 0x00, 0x40, 0x10, 0x21, 0xB8, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xF8, 0xEA, 0x84, 0x24, 0x08, 0x00, 0x50, 0x96,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x11, 0x3C, 0x25, 0x80, 0x02, 0x02,
+0xB4, 0x55, 0x31, 0x26, 0x24, 0x00, 0x04, 0x26, 0x21, 0x28, 0x20, 0x02,
+0x20, 0x00, 0x00, 0xA6, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x05, 0x3C, 0x2A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x30, 0x00, 0x04, 0x26,
+0x21, 0x28, 0x20, 0x02, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x20, 0x00, 0x03, 0x96, 0x18, 0x00, 0x02, 0x24, 0x02, 0x80, 0x15, 0x3C,
+0x03, 0xFF, 0x63, 0x30, 0xB0, 0x00, 0x63, 0x34, 0x20, 0x00, 0x03, 0xA6,
+0x60, 0x1B, 0xA8, 0x26, 0x0C, 0x00, 0x42, 0xAE, 0xE4, 0x1D, 0x02, 0x95,
+0x20, 0x00, 0x14, 0x26, 0x0C, 0x00, 0x51, 0x26, 0xFF, 0x0F, 0x43, 0x30,
+0x00, 0x19, 0x03, 0x00, 0x02, 0x22, 0x03, 0x00, 0x01, 0x00, 0x42, 0x24,
+0xE4, 0x1D, 0x02, 0xA5, 0x17, 0x00, 0x84, 0xA2, 0x16, 0x00, 0x83, 0xA2,
+0x20, 0x40, 0x04, 0x8D, 0x03, 0x00, 0x02, 0x24, 0x31, 0x00, 0x82, 0x10,
+0x38, 0x00, 0x10, 0x26, 0x60, 0x1B, 0xB3, 0x26, 0x24, 0x40, 0x62, 0x8E,
+0x21, 0x20, 0x00, 0x02, 0x02, 0x00, 0x05, 0x24, 0x01, 0x00, 0x42, 0x38,
+0x01, 0x00, 0x42, 0x2C, 0x18, 0x00, 0xA6, 0x27, 0x21, 0x38, 0x20, 0x02,
+0x4C, 0x52, 0x00, 0x0C, 0x18, 0x00, 0xA2, 0xA7, 0x20, 0x40, 0x63, 0x8E,
+0x21, 0x20, 0x40, 0x00, 0x02, 0x00, 0x05, 0x24, 0x18, 0x00, 0xA6, 0x27,
+0x21, 0x38, 0x20, 0x02, 0x4C, 0x52, 0x00, 0x0C, 0x18, 0x00, 0xA3, 0xA7,
+0x21, 0x20, 0x40, 0x00, 0x02, 0x00, 0x05, 0x24, 0x18, 0x00, 0xA6, 0x27,
+0x21, 0x38, 0x20, 0x02, 0x4C, 0x52, 0x00, 0x0C, 0x18, 0x00, 0xB6, 0xA7,
+0x20, 0x40, 0x63, 0x8E, 0x21, 0x80, 0x40, 0x00, 0x03, 0x00, 0x02, 0x24,
+0x28, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0xA2, 0x26,
+0xB6, 0x40, 0x43, 0x90, 0x04, 0x00, 0x07, 0x24, 0x21, 0x20, 0x40, 0x02,
+0x01, 0x00, 0x63, 0x38, 0x21, 0x30, 0xE0, 0x02, 0x0B, 0x38, 0x03, 0x00,
+0xDF, 0x0D, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x40, 0x00, 0xBF, 0x8F,
+0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F, 0x34, 0x00, 0xB5, 0x8F,
+0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F,
+0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x48, 0x00, 0xBD, 0x27, 0xB0, 0x1B, 0x02, 0x95, 0x00, 0x00, 0x00, 0x00,
+0x40, 0x00, 0x42, 0x30, 0xCD, 0xFF, 0x40, 0x10, 0x60, 0x1B, 0xB3, 0x26,
+0x2C, 0x40, 0x03, 0x8D, 0x30, 0x40, 0x02, 0x8D, 0x21, 0x20, 0x00, 0x02,
+0x80, 0x1F, 0x03, 0x00, 0x25, 0x18, 0x43, 0x00, 0x04, 0x00, 0x05, 0x24,
+0x01, 0x00, 0x42, 0x24, 0x1C, 0x00, 0xA6, 0x27, 0x21, 0x38, 0x20, 0x02,
+0x30, 0x40, 0x02, 0xAD, 0x4C, 0x52, 0x00, 0x0C, 0x1C, 0x00, 0xA3, 0xAF,
+0x69, 0x14, 0x00, 0x08, 0x21, 0x80, 0x40, 0x00, 0xB0, 0x1B, 0x62, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x42, 0x30, 0xD6, 0xFF, 0x40, 0x10,
+0x60, 0x1B, 0xA2, 0x26, 0x02, 0x80, 0x07, 0x3C, 0x21, 0x20, 0x00, 0x02,
+0x94, 0x5B, 0xE7, 0x24, 0x10, 0x00, 0x05, 0x24, 0x80, 0x00, 0x06, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB1, 0xAF, 0x00, 0x00, 0x83, 0x96,
+0x01, 0x00, 0x17, 0x24, 0x00, 0x40, 0x63, 0x34, 0x85, 0x14, 0x00, 0x08,
+0x00, 0x00, 0x83, 0xA6, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0xAC, 0xE8, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0xEC, 0xEA, 0xA5, 0x24,
+0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F,
+0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F,
+0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27, 0xB0, 0xFF, 0xBD, 0x27,
+0x38, 0x00, 0xB4, 0xAF, 0x34, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xB2, 0xAF,
+0x2C, 0x00, 0xB1, 0xAF, 0x28, 0x00, 0xB0, 0xAF, 0x48, 0x00, 0xBF, 0xAF,
+0x44, 0x00, 0xB7, 0xAF, 0x40, 0x00, 0xB6, 0xAF, 0x3C, 0x00, 0xB5, 0xAF,
+0x02, 0x00, 0x82, 0x90, 0x02, 0x80, 0x12, 0x3C, 0x21, 0xA0, 0x80, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x10, 0x02, 0x00, 0x21, 0x80, 0x44, 0x00,
+0x28, 0x00, 0x11, 0x26, 0xB4, 0x55, 0x45, 0x26, 0x21, 0x20, 0x20, 0x02,
+0x06, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x18, 0x00, 0x13, 0x26,
+0x9F, 0x00, 0x40, 0x10, 0x21, 0x20, 0x60, 0x02, 0x02, 0x80, 0x15, 0x3C,
+0x60, 0x1B, 0xA2, 0x26, 0x4B, 0x41, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x82, 0x00, 0x60, 0x10, 0x3C, 0x00, 0x04, 0x26, 0x60, 0x1B, 0xB0, 0x26,
+0xB0, 0x1B, 0x03, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x62, 0x30,
+0x6D, 0x00, 0x40, 0x14, 0x10, 0x00, 0x62, 0x30, 0x13, 0x00, 0x40, 0x14,
+0x10, 0x00, 0x76, 0x26, 0x60, 0x1B, 0xB0, 0x26, 0xB0, 0x1B, 0x02, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30, 0x8F, 0x00, 0x40, 0x14,
+0x21, 0x18, 0x00, 0x00, 0x48, 0x00, 0xBF, 0x8F, 0x44, 0x00, 0xB7, 0x8F,
+0x40, 0x00, 0xB6, 0x8F, 0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F,
+0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F,
+0x28, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x50, 0x00, 0xBD, 0x27, 0x21, 0x20, 0xC0, 0x02, 0xB4, 0x55, 0x45, 0x26,
+0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0xE9, 0xFF, 0x40, 0x14,
+0x07, 0x00, 0x02, 0x24, 0xB6, 0x40, 0x02, 0xA2, 0xE8, 0x39, 0x00, 0xAE,
+0x00, 0x00, 0x84, 0x8E, 0x0C, 0x00, 0x12, 0x24, 0xFF, 0x3F, 0x82, 0x30,
+0xE8, 0xFF, 0x42, 0x24, 0x2A, 0x10, 0x42, 0x02, 0x9C, 0x00, 0x40, 0x10,
+0x21, 0xB8, 0x00, 0x02, 0x1F, 0x15, 0x00, 0x08, 0x21, 0x80, 0x72, 0x02,
+0x19, 0x00, 0x03, 0x92, 0xFF, 0x3F, 0x82, 0x30, 0xE8, 0xFF, 0x42, 0x24,
+0x21, 0x18, 0x72, 0x00, 0x02, 0x00, 0x72, 0x24, 0x2A, 0x10, 0x42, 0x02,
+0x93, 0x00, 0x40, 0x10, 0x60, 0x1B, 0xB0, 0x26, 0x21, 0x80, 0x72, 0x02,
+0x18, 0x00, 0x03, 0x92, 0xDD, 0x00, 0x02, 0x24, 0xF4, 0xFF, 0x62, 0x14,
+0x1A, 0x00, 0x11, 0x26, 0x02, 0x80, 0x05, 0x3C, 0x64, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x55, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x60, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x4F, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x54, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x44, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x50, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x3E, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x4C, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x38, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x44, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x3B, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x40, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x53, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x48, 0xDE, 0xA5, 0x24,
+0x21, 0x20, 0x20, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x47, 0x01, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x21, 0x20, 0x20, 0x02,
+0x34, 0xDE, 0xA5, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x04, 0x00, 0x06, 0x24,
+0x2F, 0x01, 0x40, 0x10, 0x02, 0x00, 0x02, 0x24, 0x00, 0x00, 0x84, 0x8E,
+0x16, 0x15, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x11, 0x00, 0x0C,
+0x21, 0x20, 0x80, 0x02, 0x21, 0x18, 0x00, 0x00, 0x48, 0x00, 0xBF, 0x8F,
+0x44, 0x00, 0xB7, 0x8F, 0x40, 0x00, 0xB6, 0x8F, 0x3C, 0x00, 0xB5, 0x8F,
+0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F,
+0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x50, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x87, 0x8E,
+0x07, 0x00, 0x05, 0x24, 0xFF, 0x3F, 0xE7, 0x30, 0xDC, 0xFF, 0xE7, 0x24,
+0xAB, 0x1A, 0x00, 0x0C, 0x20, 0x00, 0xA6, 0x27, 0x78, 0xFF, 0x40, 0x10,
+0x21, 0x38, 0x40, 0x00, 0x20, 0x00, 0xA5, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x06, 0x00, 0xA2, 0x28, 0x73, 0xFF, 0x40, 0x14, 0xFD, 0xFF, 0xA5, 0x24,
+0x05, 0x00, 0xE4, 0x24, 0xE5, 0x4B, 0x00, 0x0C, 0xFF, 0x00, 0xA5, 0x30,
+0x02, 0x80, 0x04, 0x3C, 0xAC, 0x5C, 0x84, 0x24, 0x21, 0x28, 0x20, 0x02,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0xEC, 0x14, 0x00, 0x08,
+0x60, 0x1B, 0xB0, 0x26, 0xB9, 0x2B, 0x00, 0x0C, 0x21, 0x28, 0x80, 0x02,
+0xE6, 0x14, 0x00, 0x08, 0x02, 0x80, 0x15, 0x3C, 0xB4, 0x55, 0x45, 0x26,
+0x10, 0x00, 0x64, 0x26, 0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0xD4, 0xFF, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00, 0x21, 0x20, 0x80, 0x02,
+0xE3, 0x17, 0x00, 0x0C, 0x18, 0x00, 0x85, 0x26, 0x21, 0x20, 0x40, 0x00,
+0x8D, 0x17, 0x00, 0x0C, 0x05, 0x00, 0x05, 0x24, 0xB0, 0x1B, 0x03, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x62, 0x30, 0x0C, 0x00, 0x40, 0x14,
+0x04, 0x00, 0x62, 0x30, 0x4B, 0x00, 0x40, 0x14, 0x60, 0x1B, 0xB0, 0x26,
+0xB7, 0x40, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x44, 0x24,
+0xFF, 0x00, 0x83, 0x30, 0x15, 0x00, 0x02, 0x24, 0x5D, 0x00, 0x62, 0x10,
+0x21, 0x18, 0x00, 0x00, 0xF9, 0x14, 0x00, 0x08, 0xB7, 0x40, 0x04, 0xA2,
+0x8A, 0x40, 0x00, 0x0C, 0x24, 0x00, 0xA4, 0x27, 0xE8, 0x1E, 0x03, 0x8E,
+0xEC, 0x1E, 0x02, 0x8E, 0x24, 0x00, 0xA4, 0x27, 0x01, 0x00, 0x63, 0x24,
+0x01, 0x00, 0x42, 0x24, 0xEC, 0x1E, 0x02, 0xAE, 0x90, 0x40, 0x00, 0x0C,
+0xE8, 0x1E, 0x03, 0xAE, 0x9A, 0x15, 0x00, 0x08, 0x60, 0x1B, 0xB0, 0x26,
+0x60, 0x1B, 0xB0, 0x26, 0xB6, 0x40, 0x03, 0x92, 0x07, 0x00, 0x02, 0x24,
+0x21, 0x00, 0x62, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x04, 0x3C,
+0x5C, 0xEB, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xCE, 0x5C, 0x46, 0x90, 0x01, 0x00, 0x03, 0x24,
+0x0F, 0x00, 0xC3, 0x10, 0x60, 0x1B, 0xA4, 0x26, 0xD5, 0x4E, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0xBF, 0x8F, 0x44, 0x00, 0xB7, 0x8F,
+0x40, 0x00, 0xB6, 0x8F, 0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F,
+0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F,
+0x28, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x50, 0x00, 0xBD, 0x27, 0xB6, 0x40, 0x83, 0x90, 0x03, 0x00, 0x02, 0x24,
+0x2A, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x41, 0x86, 0xA0,
+0xD5, 0x4E, 0x00, 0x0C, 0x3C, 0x41, 0x80, 0xA0, 0xBF, 0x15, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x5C, 0xDE, 0xA5, 0x24, 0x21, 0x20, 0xC0, 0x02,
+0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24, 0x07, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x05, 0x3C, 0x21, 0x20, 0xC0, 0x02, 0x58, 0xDE, 0xA5, 0x24,
+0x1D, 0x55, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24, 0xD5, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x70, 0xEB, 0x84, 0x24,
+0xB6, 0x15, 0x00, 0x08, 0xB6, 0x40, 0x00, 0xA2, 0x0A, 0x00, 0x76, 0x26,
+0x1F, 0x54, 0x00, 0x0C, 0x21, 0x20, 0xC0, 0x02, 0x20, 0x00, 0x10, 0x24,
+0x37, 0x00, 0x50, 0x10, 0x21, 0x88, 0x40, 0x00, 0x8A, 0x40, 0x00, 0x0C,
+0x24, 0x00, 0xA4, 0x27, 0x40, 0x10, 0x11, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x60, 0x1B, 0xA4, 0x26, 0x00, 0x11, 0x02, 0x00, 0x21, 0x10, 0x44, 0x00,
+0xF8, 0x1D, 0x43, 0x8C, 0x24, 0x00, 0xA4, 0x27, 0x01, 0x00, 0x63, 0x24,
+0x90, 0x40, 0x00, 0x0C, 0xF8, 0x1D, 0x43, 0xAC, 0x60, 0x15, 0x00, 0x08,
+0x21, 0x18, 0x00, 0x00, 0x3C, 0x41, 0x86, 0xA0, 0xD5, 0x4E, 0x00, 0x0C,
+0x3D, 0x41, 0x80, 0xA0, 0xBF, 0x15, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x55, 0x12, 0x00, 0x0C, 0xB7, 0x40, 0x00, 0xA2, 0x02, 0x80, 0x02, 0x3C,
+0xD2, 0x5C, 0x44, 0x90, 0x02, 0x00, 0x03, 0x24, 0x5D, 0xFF, 0x83, 0x14,
+0x21, 0x18, 0x00, 0x00, 0x00, 0x00, 0x87, 0x8E, 0x24, 0x00, 0x64, 0x26,
+0x2A, 0x00, 0x05, 0x24, 0xFF, 0x3F, 0xE7, 0x30, 0xDC, 0xFF, 0xE7, 0x24,
+0xAB, 0x1A, 0x00, 0x0C, 0x20, 0x00, 0xA6, 0x27, 0x54, 0xFF, 0x40, 0x10,
+0x21, 0x18, 0x00, 0x00, 0x02, 0x00, 0x44, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x82, 0x30, 0x95, 0x00, 0x40, 0x10, 0x60, 0x1B, 0xA5, 0x26,
+0x01, 0x00, 0x82, 0x30, 0x92, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C,
+0xD3, 0x5C, 0x44, 0x90, 0x01, 0x00, 0x03, 0x24, 0x9F, 0x00, 0x83, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xFC, 0x23, 0x02, 0x8E, 0xFF, 0xEF, 0x03, 0x24,
+0x00, 0x08, 0x42, 0x34, 0x24, 0x10, 0x43, 0x00, 0xFC, 0x23, 0x02, 0xAE,
+0x60, 0x15, 0x00, 0x08, 0x21, 0x18, 0x00, 0x00, 0xFF, 0xFF, 0x04, 0x24,
+0xC7, 0x53, 0x00, 0x0C, 0x21, 0x28, 0xC0, 0x02, 0xC6, 0xFF, 0x50, 0x10,
+0x21, 0x88, 0x40, 0x00, 0x00, 0x00, 0x87, 0x8E, 0x24, 0x00, 0x77, 0x26,
+0x21, 0x20, 0xE0, 0x02, 0xFF, 0x3F, 0xE7, 0x30, 0xDC, 0xFF, 0xE7, 0x24,
+0x01, 0x00, 0x05, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x20, 0x00, 0xA6, 0x27,
+0xCB, 0xFE, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00, 0x20, 0x00, 0xA6, 0x8F,
+0x02, 0x00, 0x45, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x87, 0x8E, 0x21, 0x20, 0xE0, 0x02, 0x32, 0x00, 0x05, 0x24,
+0xFF, 0x3F, 0xE7, 0x30, 0xDC, 0xFF, 0xE7, 0x24, 0x20, 0x00, 0xB0, 0x8F,
+0xAB, 0x1A, 0x00, 0x0C, 0x20, 0x00, 0xA6, 0x27, 0x08, 0x00, 0x40, 0x10,
+0x10, 0x00, 0xA4, 0x27, 0x20, 0x00, 0xA6, 0x8F, 0x21, 0x20, 0x90, 0x00,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x45, 0x24, 0x20, 0x00, 0xA3, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x80, 0x03, 0x02, 0x10, 0x00, 0xA4, 0x27,
+0x61, 0x53, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x02, 0x21, 0x28, 0x00, 0x02,
+0x10, 0x00, 0xA4, 0x27, 0xA6, 0x53, 0x00, 0x0C, 0x0F, 0x00, 0x53, 0x30,
+0x00, 0x00, 0x87, 0x8E, 0x21, 0x20, 0xE0, 0x02, 0x2D, 0x00, 0x05, 0x24,
+0xFF, 0x3F, 0xE7, 0x30, 0xDC, 0xFF, 0xE7, 0x24, 0x20, 0x00, 0xA6, 0x27,
+0xAB, 0x1A, 0x00, 0x0C, 0x21, 0x90, 0x40, 0x00, 0x11, 0x00, 0x40, 0x10,
+0x00, 0x81, 0x11, 0x00, 0x06, 0x00, 0x44, 0x90, 0x05, 0x00, 0x43, 0x90,
+0x02, 0x80, 0x02, 0x3C, 0xC6, 0x5C, 0x45, 0x90, 0x00, 0x1B, 0x03, 0x00,
+0x00, 0x25, 0x04, 0x00, 0x25, 0x18, 0x64, 0x00, 0x10, 0x00, 0xA5, 0x30,
+0x25, 0x90, 0x43, 0x02, 0x02, 0x00, 0xA0, 0x14, 0x0F, 0x00, 0x02, 0x3C,
+0xFF, 0x0F, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34, 0x24, 0x90, 0x42, 0x02,
+0x08, 0x00, 0x73, 0x36, 0x00, 0x81, 0x11, 0x00, 0x25, 0x80, 0x13, 0x02,
+0xFF, 0xFF, 0x10, 0x32, 0x02, 0x80, 0x04, 0x3C, 0x21, 0x28, 0x20, 0x02,
+0x21, 0x30, 0x00, 0x02, 0x21, 0x38, 0x40, 0x02, 0x13, 0x58, 0x00, 0x0C,
+0x8C, 0xEB, 0x84, 0x24, 0x21, 0x20, 0x00, 0x02, 0x63, 0x5E, 0x00, 0x74,
+0x21, 0x28, 0x40, 0x02, 0x60, 0x1B, 0xA3, 0x26, 0x3A, 0x41, 0x62, 0x90,
+0x21, 0x20, 0xC0, 0x02, 0x21, 0x28, 0x20, 0x02, 0x01, 0x00, 0x42, 0x24,
+0xEA, 0x0E, 0x00, 0x0C, 0x3A, 0x41, 0x62, 0xA0, 0xEA, 0x15, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x01, 0x00, 0x02, 0x24,
+0xA0, 0xEB, 0x84, 0x24, 0xB6, 0x15, 0x00, 0x08, 0xB6, 0x40, 0xE2, 0xA2,
+0x02, 0x80, 0x04, 0x3C, 0xB8, 0xEB, 0x84, 0x24, 0xB6, 0x15, 0x00, 0x08,
+0xB6, 0x40, 0xE0, 0xA2, 0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0xA3, 0x26,
+0x03, 0x00, 0x02, 0x24, 0xCC, 0xEB, 0x84, 0x24, 0xB6, 0x15, 0x00, 0x08,
+0xB6, 0x40, 0x62, 0xA0, 0x1E, 0x00, 0x03, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x62, 0x14, 0x02, 0x80, 0x04, 0x3C, 0x20, 0x00, 0x02, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30, 0x05, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0xC8, 0xDF, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x1A, 0x00, 0x60, 0x14, 0x11, 0x00, 0x03, 0x24, 0x13, 0x58, 0x00, 0x0C,
+0xE0, 0xEB, 0x84, 0x24, 0x05, 0x00, 0x02, 0x24, 0xB8, 0x15, 0x00, 0x08,
+0xB6, 0x40, 0xE2, 0xA2, 0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0xA3, 0x26,
+0x02, 0x00, 0x02, 0x24, 0xF8, 0xEB, 0x84, 0x24, 0xB6, 0x15, 0x00, 0x08,
+0xB6, 0x40, 0x62, 0xA0, 0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0xA3, 0x26,
+0x04, 0x00, 0x02, 0x24, 0x0C, 0xEC, 0x84, 0x24, 0xB6, 0x15, 0x00, 0x08,
+0xB6, 0x40, 0x62, 0xA0, 0xFC, 0x23, 0xA2, 0x8C, 0xFF, 0xEF, 0x03, 0x24,
+0xFF, 0xF7, 0x04, 0x24, 0x24, 0x10, 0x43, 0x00, 0x24, 0x10, 0x44, 0x00,
+0x21, 0x18, 0x00, 0x00, 0x60, 0x15, 0x00, 0x08, 0xFC, 0x23, 0xA2, 0xAC,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x20, 0xEC, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0xC6, 0x5C, 0x43, 0xA0, 0x60, 0x1B, 0xA3, 0x26,
+0x06, 0x00, 0x02, 0x24, 0xB8, 0x15, 0x00, 0x08, 0xB6, 0x40, 0x62, 0xA0,
+0xFC, 0x23, 0x02, 0x8E, 0xFF, 0xF7, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x00, 0x10, 0x42, 0x34, 0x1E, 0x16, 0x00, 0x08, 0xFC, 0x23, 0x02, 0xAE,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x10, 0x3C, 0x60, 0x1B, 0x02, 0x26,
+0x14, 0x00, 0xBF, 0xAF, 0xB0, 0x1B, 0x43, 0x94, 0x21, 0x28, 0x00, 0x00,
+0x00, 0x01, 0x62, 0x30, 0x03, 0x00, 0x40, 0x10, 0x01, 0x00, 0x64, 0x30,
+0x06, 0x00, 0x80, 0x14, 0x00, 0x10, 0x62, 0x30, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0xA0, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x08, 0x00, 0x40, 0x14, 0x60, 0x1B, 0x04, 0x26,
+0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90, 0x0C, 0x00, 0x02, 0x24,
+0x0F, 0x00, 0x63, 0x30, 0x09, 0x00, 0x62, 0x10, 0x21, 0x20, 0x00, 0x00,
+0x60, 0x1B, 0x04, 0x26, 0x60, 0xEA, 0x03, 0x34, 0x04, 0x3A, 0x83, 0xAC,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0xA0, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x0E, 0x51, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x04, 0x26, 0x60, 0xEA, 0x03, 0x34,
+0xDB, 0x16, 0x00, 0x08, 0x04, 0x3A, 0x83, 0xAC, 0xD8, 0xFF, 0xBD, 0x27,
+0x1C, 0x00, 0xB1, 0xAF, 0x02, 0x80, 0x11, 0x3C, 0x18, 0x00, 0xB0, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x60, 0x1B, 0x30, 0x26, 0x04, 0x3E, 0x02, 0x8E,
+0x00, 0x10, 0x03, 0x3C, 0x24, 0x10, 0x43, 0x00, 0x12, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x33, 0x3E, 0x03, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x63, 0x24, 0xFF, 0x00, 0x62, 0x30, 0x21, 0x10, 0x50, 0x00,
+0xD0, 0x3D, 0x45, 0x90, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xA4, 0x30,
+0x18, 0x00, 0x80, 0x10, 0x33, 0x3E, 0x03, 0xA2, 0xFF, 0x3D, 0x02, 0x92,
+0xC4, 0x3D, 0x05, 0xA2, 0x75, 0x0D, 0x00, 0x0C, 0xC5, 0x3D, 0x02, 0xA2,
+0xC4, 0x3D, 0x04, 0x92, 0x38, 0x0D, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24,
+0x08, 0x3E, 0x03, 0x8E, 0x01, 0x00, 0x02, 0x24, 0x52, 0x00, 0x62, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x25, 0x26, 0x04, 0x3E, 0xA4, 0x8C,
+0x00, 0x10, 0x02, 0x3C, 0x3C, 0x00, 0x03, 0x24, 0x26, 0x20, 0x82, 0x00,
+0x94, 0x39, 0xA3, 0xAC, 0x04, 0x3E, 0xA4, 0xAC, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xB0, 0x1B, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0xEF, 0x42, 0x30, 0x00, 0x01, 0x43, 0x30, 0x49, 0x00, 0x60, 0x14,
+0xB0, 0x1B, 0x02, 0xA6, 0x31, 0x3E, 0x06, 0x92, 0x37, 0x3E, 0x03, 0x92,
+0x32, 0x3E, 0x05, 0x92, 0x25, 0xB0, 0x02, 0x3C, 0x4C, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xA0, 0xFF, 0x00, 0xC4, 0x30, 0xC5, 0x3D, 0x05, 0xA2,
+0x75, 0x0D, 0x00, 0x0C, 0xC4, 0x3D, 0x06, 0xA2, 0xC4, 0x3D, 0x04, 0x92,
+0x38, 0x0D, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0xB0, 0x1B, 0x03, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 0x30, 0x09, 0x00, 0x40, 0x10,
+0x01, 0x00, 0x62, 0x30, 0x08, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x30, 0x26,
+0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90, 0x0C, 0x00, 0x02, 0x24,
+0x0F, 0x00, 0x63, 0x30, 0x58, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x30, 0x26, 0x34, 0x3E, 0x04, 0x96, 0x36, 0x3E, 0x05, 0x92,
+0x95, 0x0E, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x11, 0x48, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xA4, 0x27, 0x8A, 0x40, 0x00, 0x0C,
+0x04, 0x3E, 0x00, 0xAE, 0xB0, 0x1B, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x42, 0x30, 0x2A, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0xEC, 0x5D, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x60, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0xEE, 0x5D, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x04, 0x00, 0x42, 0x28,
+0x3A, 0x00, 0x40, 0x14, 0x04, 0x00, 0x04, 0x24, 0x02, 0x80, 0x03, 0x3C,
+0x0E, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x42, 0x24, 0x0E, 0x5E, 0x62, 0xA0, 0x72, 0x17, 0x00, 0x08,
+0x60, 0x1B, 0x30, 0x26, 0xC4, 0x3D, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0x42, 0x2C, 0xAB, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x12, 0x49, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x07, 0x17, 0x00, 0x08,
+0x60, 0x1B, 0x25, 0x26, 0x25, 0xB0, 0x05, 0x3C, 0x48, 0x00, 0xA5, 0x34,
+0x00, 0x00, 0xA3, 0x8C, 0x60, 0x1B, 0x24, 0x8E, 0x84, 0x00, 0x02, 0x3C,
+0x25, 0x18, 0x62, 0x00, 0x25, 0x00, 0x84, 0x34, 0x00, 0x00, 0xA3, 0xAC,
+0x18, 0x17, 0x00, 0x08, 0x60, 0x1B, 0x24, 0xAE, 0x02, 0x80, 0x02, 0x3C,
+0x0E, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90,
+0x01, 0x00, 0x05, 0x24, 0x4B, 0x2E, 0x00, 0x0C, 0xFF, 0x00, 0x84, 0x30,
+0x60, 0x1B, 0x30, 0x26, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x52, 0x41, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x96, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0x2C, 0x59, 0x84, 0x24,
+0xA0, 0xDD, 0xA5, 0x24, 0x34, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x4B, 0x41, 0x00, 0xA2, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x0D, 0x17, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x2E, 0x00, 0x0C,
+0x01, 0x00, 0x05, 0x24, 0x4D, 0x17, 0x00, 0x08, 0x02, 0x80, 0x03, 0x3C,
+0x0E, 0x51, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0x33, 0x17, 0x00, 0x08,
+0x60, 0x1B, 0x30, 0x26, 0x02, 0x80, 0x09, 0x3C, 0x60, 0x1B, 0x28, 0x25,
+0x6C, 0x37, 0x06, 0x8D, 0xFF, 0xFF, 0x02, 0x34, 0x44, 0x00, 0xC2, 0x10,
+0x21, 0x38, 0x80, 0x00, 0x2B, 0x10, 0xC7, 0x00, 0x34, 0x00, 0x40, 0x10,
+0x02, 0x19, 0x06, 0x00, 0x21, 0x10, 0xC7, 0x00, 0x23, 0x10, 0x43, 0x00,
+0x10, 0x00, 0x46, 0x24, 0x6C, 0x37, 0x06, 0xAD, 0x70, 0x37, 0x02, 0xAD,
+0x60, 0x1B, 0x26, 0x25, 0x05, 0x00, 0xC4, 0x90, 0xFF, 0xFF, 0x02, 0x34,
+0xFF, 0x00, 0x83, 0x30, 0x33, 0x00, 0x62, 0x10, 0x00, 0x11, 0x07, 0x00,
+0xFF, 0x00, 0x84, 0x30, 0x2B, 0x10, 0x87, 0x00, 0x20, 0x00, 0x40, 0x10,
+0x03, 0x19, 0x04, 0x00, 0x03, 0x11, 0x04, 0x00, 0x21, 0x18, 0x87, 0x00,
+0x23, 0x18, 0x62, 0x00, 0x10, 0x00, 0x64, 0x24, 0x05, 0x00, 0xC4, 0xA0,
+0x70, 0x37, 0xC3, 0xAC, 0xC0, 0x10, 0x05, 0x00, 0x21, 0x10, 0x45, 0x00,
+0x80, 0x10, 0x02, 0x00, 0x21, 0x10, 0x45, 0x00, 0x60, 0x1B, 0x23, 0x25,
+0x80, 0x10, 0x02, 0x00, 0x21, 0x28, 0x43, 0x00, 0xF8, 0x24, 0xA6, 0x8C,
+0x00, 0x21, 0x07, 0x00, 0xFF, 0xFF, 0xC2, 0x38, 0x0A, 0x30, 0x82, 0x00,
+0x2B, 0x18, 0xC7, 0x00, 0x07, 0x00, 0x60, 0x10, 0x21, 0x10, 0xC7, 0x00,
+0x02, 0x19, 0x06, 0x00, 0x23, 0x10, 0x43, 0x00, 0x10, 0x00, 0x46, 0x24,
+0xF8, 0x24, 0xA6, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0xFC, 0x24, 0xA2, 0xAC,
+0x02, 0x19, 0x06, 0x00, 0x23, 0x10, 0x43, 0x00, 0xF8, 0x24, 0xA2, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xFC, 0x24, 0xA2, 0xAC, 0x21, 0x10, 0x87, 0x00,
+0x23, 0x10, 0x43, 0x00, 0x05, 0x00, 0xC2, 0xA0, 0xAB, 0x17, 0x00, 0x08,
+0x70, 0x37, 0xC2, 0xAC, 0x21, 0x10, 0xC7, 0x00, 0x23, 0x10, 0x43, 0x00,
+0x6C, 0x37, 0x02, 0xAD, 0x70, 0x37, 0x02, 0xAD, 0x60, 0x1B, 0x26, 0x25,
+0x05, 0x00, 0xC4, 0x90, 0xFF, 0xFF, 0x02, 0x34, 0xFF, 0x00, 0x83, 0x30,
+0xCF, 0xFF, 0x62, 0x14, 0x00, 0x11, 0x07, 0x00, 0x21, 0x20, 0x40, 0x00,
+0xA1, 0x17, 0x00, 0x08, 0x05, 0x00, 0xC2, 0xA0, 0x00, 0x31, 0x04, 0x00,
+0x93, 0x17, 0x00, 0x08, 0x6C, 0x37, 0x06, 0xAD, 0x63, 0x00, 0x82, 0x24,
+0x77, 0x00, 0x42, 0x2C, 0x00, 0x00, 0x85, 0x28, 0x04, 0x00, 0x40, 0x10,
+0x21, 0x18, 0x00, 0x00, 0x64, 0x00, 0x82, 0x24, 0x64, 0x00, 0x03, 0x24,
+0x0B, 0x18, 0x45, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF, 0x0C, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x42, 0x30, 0x04, 0x00, 0x42, 0x28,
+0x08, 0x00, 0x40, 0x14, 0x25, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0xA4, 0x8C,
+0x10, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xBD, 0x27, 0x3F, 0x00, 0x84, 0x30,
+0x40, 0x20, 0x04, 0x00, 0xD9, 0x17, 0x00, 0x08, 0x96, 0xFF, 0x84, 0x24,
+0x24, 0x08, 0x42, 0x34, 0x00, 0x00, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x02, 0x63, 0x30, 0x1B, 0x00, 0x60, 0x14, 0x01, 0x00, 0x02, 0x24,
+0x05, 0x00, 0xA3, 0x90, 0x00, 0x00, 0x00, 0x00, 0x82, 0x31, 0x03, 0x00,
+0x3C, 0x00, 0xC2, 0x10, 0x02, 0x00, 0xC2, 0x28, 0x57, 0x00, 0x40, 0x14,
+0x02, 0x00, 0x02, 0x24, 0x46, 0x00, 0xC2, 0x10, 0x03, 0x00, 0x02, 0x24,
+0x2E, 0x00, 0xC2, 0x10, 0x3E, 0x00, 0x63, 0x30, 0xD9, 0x17, 0x00, 0x0C,
+0x21, 0x20, 0xE0, 0x00, 0x06, 0x00, 0x45, 0x24, 0x65, 0x00, 0xA4, 0x2C,
+0x64, 0x00, 0x03, 0x24, 0x0A, 0x28, 0x64, 0x00, 0xDD, 0xFF, 0xA2, 0x24,
+0x08, 0x00, 0x42, 0x2C, 0x1F, 0x00, 0x40, 0x10, 0xE5, 0xFF, 0xA2, 0x24,
+0xFE, 0xFF, 0xA5, 0x24, 0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0xA0, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x05, 0x00, 0xA3, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x66, 0x30, 0x42, 0x31, 0x06, 0x00,
+0x25, 0x00, 0xC2, 0x10, 0x02, 0x00, 0xC2, 0x28, 0x36, 0x00, 0x40, 0x14,
+0x02, 0x00, 0x02, 0x24, 0x2F, 0x00, 0xC2, 0x10, 0x03, 0x00, 0x02, 0x24,
+0xE6, 0xFF, 0xC2, 0x14, 0x1F, 0x00, 0x62, 0x30, 0x40, 0x10, 0x02, 0x00,
+0xD8, 0xFF, 0x03, 0x24, 0x23, 0x38, 0x62, 0x00, 0xD9, 0x17, 0x00, 0x0C,
+0x21, 0x20, 0xE0, 0x00, 0x06, 0x00, 0x45, 0x24, 0x65, 0x00, 0xA4, 0x2C,
+0x64, 0x00, 0x03, 0x24, 0x0A, 0x28, 0x64, 0x00, 0xDD, 0xFF, 0xA2, 0x24,
+0x08, 0x00, 0x42, 0x2C, 0xE3, 0xFF, 0x40, 0x14, 0xE5, 0xFF, 0xA2, 0x24,
+0x08, 0x00, 0x42, 0x2C, 0x06, 0x00, 0x40, 0x10, 0xF1, 0xFF, 0xA2, 0x24,
+0x0E, 0x18, 0x00, 0x08, 0xFA, 0xFF, 0xA5, 0x24, 0xD8, 0xFF, 0x02, 0x24,
+0x03, 0x18, 0x00, 0x08, 0x23, 0x38, 0x43, 0x00, 0x0C, 0x00, 0x42, 0x2C,
+0x0C, 0x00, 0x40, 0x10, 0xFB, 0xFF, 0xA2, 0x24, 0x0E, 0x18, 0x00, 0x08,
+0xF8, 0xFF, 0xA5, 0x24, 0x3E, 0x00, 0x63, 0x30, 0xFE, 0xFF, 0x02, 0x24,
+0x03, 0x18, 0x00, 0x08, 0x23, 0x38, 0x43, 0x00, 0x1F, 0x00, 0x62, 0x30,
+0x40, 0x10, 0x02, 0x00, 0xFE, 0xFF, 0x03, 0x24, 0x21, 0x18, 0x00, 0x08,
+0x23, 0x38, 0x62, 0x00, 0x0A, 0x00, 0x42, 0x2C, 0xCB, 0xFF, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x18, 0x00, 0x08, 0xFC, 0xFF, 0xA5, 0x24,
+0x3E, 0x00, 0x63, 0x30, 0xEC, 0xFF, 0x02, 0x24, 0x03, 0x18, 0x00, 0x08,
+0x23, 0x38, 0x43, 0x00, 0x1F, 0x00, 0x62, 0x30, 0x40, 0x10, 0x02, 0x00,
+0xEC, 0xFF, 0x03, 0x24, 0x21, 0x18, 0x00, 0x08, 0x23, 0x38, 0x62, 0x00,
+0xB3, 0xFF, 0xC0, 0x14, 0x1F, 0x00, 0x62, 0x30, 0x40, 0x10, 0x02, 0x00,
+0x0E, 0x00, 0x03, 0x24, 0x21, 0x18, 0x00, 0x08, 0x23, 0x38, 0x62, 0x00,
+0xAD, 0xFF, 0xC0, 0x14, 0x3E, 0x00, 0x63, 0x30, 0x0E, 0x00, 0x02, 0x24,
+0x03, 0x18, 0x00, 0x08, 0x23, 0x38, 0x43, 0x00, 0x98, 0xFF, 0xBD, 0x27,
+0x64, 0x00, 0xBF, 0xAF, 0x60, 0x00, 0xBE, 0xAF, 0x5C, 0x00, 0xB7, 0xAF,
+0x58, 0x00, 0xB6, 0xAF, 0x54, 0x00, 0xB5, 0xAF, 0x50, 0x00, 0xB4, 0xAF,
+0x4C, 0x00, 0xB3, 0xAF, 0x48, 0x00, 0xB2, 0xAF, 0x44, 0x00, 0xB1, 0xAF,
+0x40, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0x88, 0x54, 0x45, 0x8C,
+0x00, 0x80, 0x04, 0x3C, 0x68, 0x61, 0x83, 0x24, 0x88, 0x54, 0x44, 0x24,
+0x25, 0xB0, 0x02, 0x3C, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x81, 0x00, 0xA4, 0x10, 0x02, 0x80, 0x02, 0x3C, 0xE8, 0xEC, 0x42, 0x24,
+0x00, 0x00, 0x5E, 0x8C, 0x02, 0x80, 0x03, 0x3C, 0xEC, 0xEC, 0x63, 0x24,
+0x00, 0x00, 0x75, 0x8C, 0x28, 0x39, 0xD6, 0x8F, 0x21, 0xB8, 0x00, 0x00,
+0x08, 0x00, 0xC2, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xAE,
+0x08, 0x00, 0xC3, 0x96, 0x02, 0x80, 0x02, 0x3C, 0x9E, 0x18, 0x00, 0x08,
+0x25, 0xA0, 0x62, 0x00, 0x17, 0x00, 0x25, 0x92, 0x16, 0x00, 0x26, 0x92,
+0xC8, 0x3D, 0xC2, 0x97, 0xFF, 0x00, 0xA3, 0x30, 0x00, 0x1A, 0x03, 0x00,
+0xFF, 0x00, 0xC4, 0x30, 0x25, 0x18, 0x64, 0x00, 0x14, 0x00, 0x43, 0x10,
+0xFF, 0x00, 0xA2, 0x30, 0xFF, 0x00, 0xC3, 0x30, 0x00, 0x12, 0x02, 0x00,
+0x25, 0x10, 0x43, 0x00, 0xC8, 0x3D, 0xC2, 0xA7, 0x01, 0x00, 0x24, 0x92,
+0x18, 0x00, 0x42, 0x92, 0x00, 0x22, 0x04, 0x00, 0xA8, 0x0D, 0x00, 0x0C,
+0x25, 0x20, 0x82, 0x00, 0x40, 0x18, 0x02, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x98, 0xDE, 0x82, 0x24, 0x80, 0x18, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x08, 0x00, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x09, 0xF8, 0x40, 0x00, 0x21, 0x20, 0x60, 0x02, 0x0C, 0x00, 0xC2, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x2B, 0x10, 0xE2, 0x02, 0x41, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x8E, 0x02, 0x80, 0x03, 0x3C,
+0x48, 0x37, 0x64, 0x24, 0x42, 0x1B, 0x02, 0x00, 0x78, 0x00, 0x63, 0x30,
+0x02, 0x2E, 0x02, 0x00, 0xFF, 0x3F, 0x42, 0x30, 0x21, 0x10, 0x43, 0x00,
+0x03, 0x00, 0xA5, 0x30, 0x21, 0x10, 0x45, 0x00, 0x18, 0x00, 0x42, 0x24,
+0xFF, 0xFF, 0x50, 0x30, 0x7F, 0x00, 0x02, 0x32, 0x21, 0x98, 0x80, 0x02,
+0x06, 0x00, 0x06, 0x24, 0x80, 0x00, 0x03, 0x26, 0x00, 0x00, 0xB0, 0xAE,
+0x02, 0x00, 0x40, 0x10, 0x80, 0xFF, 0x05, 0x32, 0x80, 0xFF, 0x65, 0x30,
+0x00, 0x00, 0xA5, 0xAE, 0x02, 0x00, 0x62, 0x96, 0x21, 0x18, 0xE5, 0x02,
+0xFF, 0xFF, 0x77, 0x30, 0x0F, 0x00, 0x42, 0x30, 0x00, 0x00, 0xA2, 0xAE,
+0x00, 0x00, 0x63, 0x8E, 0x21, 0xA0, 0x85, 0x02, 0x42, 0x13, 0x03, 0x00,
+0x78, 0x00, 0x42, 0x30, 0x02, 0x1E, 0x03, 0x00, 0x03, 0x00, 0x63, 0x30,
+0x21, 0x10, 0x53, 0x00, 0x21, 0x90, 0x43, 0x00, 0x1C, 0x00, 0x50, 0x26,
+0x18, 0x00, 0x51, 0x26, 0x21, 0x28, 0x00, 0x02, 0x00, 0x00, 0xB1, 0xAE,
+0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x21, 0x28, 0x00, 0x02, 0x06, 0x00, 0x06, 0x24, 0x0B, 0x00, 0x40, 0x14,
+0x90, 0xDE, 0x64, 0x24, 0x01, 0x00, 0x22, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x12, 0x02, 0x00, 0x00, 0x08, 0x42, 0x30, 0xAD, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x26, 0x92, 0x17, 0x00, 0x25, 0x92,
+0x86, 0x18, 0x00, 0x08, 0xFF, 0x00, 0xA2, 0x30, 0x1D, 0x55, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0xC2, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x10, 0xE2, 0x02,
+0xC1, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x40, 0x00, 0x0C,
+0x38, 0x00, 0xA4, 0x27, 0x04, 0x00, 0xC3, 0x8E, 0x00, 0x00, 0xC2, 0x8E,
+0x21, 0x20, 0xC0, 0x02, 0x00, 0x00, 0x62, 0xAC, 0x04, 0x00, 0x43, 0xAC,
+0x00, 0x00, 0xD6, 0xAE, 0x74, 0x21, 0x00, 0x0C, 0x04, 0x00, 0xD6, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x38, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x88, 0x54, 0x43, 0x8C, 0x88, 0x54, 0x42, 0x24, 0x86, 0xFF, 0x62, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C, 0xE8, 0xEC, 0x63, 0x24,
+0x00, 0x00, 0x71, 0x8C, 0x25, 0xB0, 0x10, 0x3C, 0x04, 0x01, 0x02, 0x36,
+0x00, 0x00, 0x43, 0x8C, 0xDC, 0x38, 0x27, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x77, 0x00, 0xE3, 0x10, 0xE0, 0x38, 0x23, 0xAE, 0x2B, 0x10, 0x67, 0x00,
+0x81, 0x00, 0x40, 0x14, 0x2B, 0x10, 0xE3, 0x00, 0xA9, 0x00, 0x40, 0x14,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x44, 0x24, 0xB0, 0x38, 0x83, 0x94,
+0x02, 0x80, 0x02, 0x3C, 0x21, 0x80, 0x00, 0x00, 0x34, 0x00, 0xE0, 0x1A,
+0x25, 0x90, 0x62, 0x00, 0x21, 0x88, 0x80, 0x00, 0x21, 0x18, 0x00, 0x00,
+0x01, 0x00, 0x14, 0x24, 0x00, 0xC0, 0x15, 0x3C, 0x0E, 0x19, 0x00, 0x08,
+0x03, 0x00, 0x1E, 0x24, 0x80, 0x18, 0x10, 0x00, 0x2A, 0x10, 0x77, 0x00,
+0x2A, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0x98, 0x72, 0x00,
+0x00, 0x00, 0x62, 0x8E, 0x44, 0x41, 0x23, 0x8E, 0x38, 0x00, 0xA4, 0x27,
+0xFF, 0x3F, 0x42, 0x30, 0x21, 0x18, 0x62, 0x00, 0x8A, 0x40, 0x00, 0x0C,
+0x44, 0x41, 0x23, 0xAE, 0xE8, 0x1E, 0x22, 0x8E, 0xF0, 0x1E, 0x23, 0x8E,
+0x38, 0x00, 0xA4, 0x27, 0x01, 0x00, 0x42, 0x24, 0x01, 0x00, 0x63, 0x24,
+0xE8, 0x1E, 0x22, 0xAE, 0x90, 0x40, 0x00, 0x0C, 0xF0, 0x1E, 0x23, 0xAE,
+0xEC, 0x2C, 0x00, 0x0C, 0x21, 0x20, 0x60, 0x02, 0x00, 0x00, 0x63, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x14, 0x06, 0x00, 0x02, 0x26,
+0x01, 0x00, 0x02, 0x26, 0xFF, 0xFF, 0x50, 0x30, 0x82, 0x16, 0x03, 0x00,
+0x01, 0x00, 0x42, 0x30, 0xE1, 0xFF, 0x54, 0x14, 0x02, 0x80, 0x04, 0x3C,
+0x60, 0x1B, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x42, 0x11, 0x02, 0x00,
+0x01, 0x00, 0x42, 0x30, 0x0C, 0x00, 0x54, 0x10, 0xC2, 0x13, 0x03, 0x00,
+0x1E, 0x00, 0x42, 0x30, 0x21, 0x10, 0x50, 0x00, 0xFF, 0xFF, 0x50, 0x30,
+0x80, 0x18, 0x10, 0x00, 0x2A, 0x10, 0x77, 0x00, 0xD8, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x74, 0x21, 0x00, 0x0C, 0x21, 0x20, 0xC0, 0x02,
+0x75, 0x19, 0x00, 0x08, 0x02, 0x80, 0x03, 0x3C, 0x01, 0x00, 0x22, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x63, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x02, 0x14, 0x03, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0x11, 0x00, 0x40, 0x14, 0x02, 0x17, 0x03, 0x00,
+0x03, 0x00, 0x44, 0x30, 0x07, 0x00, 0x80, 0x10, 0x24, 0x10, 0x75, 0x00,
+0x0C, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x9E, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x80, 0x28, 0x10, 0x00, 0x21, 0x28, 0xB2, 0x00, 0xE3, 0x17, 0x00, 0x0C,
+0x21, 0x20, 0x60, 0x02, 0x21, 0x20, 0x40, 0x00, 0x8D, 0x17, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x00, 0x01, 0x00, 0x22, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x7B, 0x00, 0x54, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x23, 0x92,
+0x02, 0x00, 0x02, 0x24, 0x63, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x4C, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x63, 0x30, 0x08, 0x00, 0x74, 0x10,
+0xD0, 0x02, 0x02, 0x24, 0x00, 0x00, 0x63, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0xC2, 0x13, 0x03, 0x00, 0x1E, 0x00, 0x42, 0x30, 0x21, 0x10, 0x50, 0x00,
+0x33, 0x19, 0x00, 0x08, 0xFF, 0xFF, 0x50, 0x30, 0x6C, 0x37, 0x22, 0xAE,
+0x00, 0x00, 0x63, 0x8E, 0x67, 0x19, 0x00, 0x08, 0xC2, 0x13, 0x03, 0x00,
+0x00, 0x01, 0x02, 0x36, 0x00, 0x00, 0x47, 0xAC, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x42, 0x24, 0xDC, 0x38, 0x47, 0xAC, 0x02, 0x80, 0x03, 0x3C,
+0x08, 0x04, 0x64, 0x24, 0x21, 0x28, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00,
+0x76, 0x39, 0x00, 0x0C, 0x21, 0x38, 0x00, 0x00, 0x66, 0x18, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0xE4, 0x38, 0x22, 0x8E, 0xFF, 0xFF, 0x73, 0x30,
+0x23, 0x10, 0x47, 0x00, 0xFF, 0xFF, 0x52, 0x30, 0x21, 0x18, 0x53, 0x02,
+0xFF, 0xFF, 0x77, 0x30, 0x53, 0x21, 0x00, 0x0C, 0x21, 0x20, 0xE0, 0x02,
+0xEF, 0xFF, 0x40, 0x10, 0x21, 0xB0, 0x40, 0x00, 0x08, 0x00, 0x42, 0x8C,
+0xDC, 0x38, 0x26, 0x8E, 0x21, 0x38, 0x40, 0x02, 0x21, 0x18, 0x57, 0x00,
+0xAC, 0x38, 0x23, 0xAE, 0x21, 0x28, 0x40, 0x00, 0x08, 0x00, 0x04, 0x24,
+0xB0, 0x38, 0x22, 0xAE, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF,
+0x5B, 0x01, 0x00, 0x0C, 0x08, 0x00, 0x04, 0x24, 0xB0, 0x38, 0x25, 0x8E,
+0x24, 0x10, 0x02, 0x3C, 0x00, 0x01, 0x10, 0x36, 0x00, 0x00, 0x02, 0xAE,
+0x21, 0x38, 0x60, 0x02, 0x21, 0x28, 0xB2, 0x00, 0x08, 0x00, 0x04, 0x24,
+0x24, 0x10, 0x06, 0x3C, 0xDC, 0x38, 0x22, 0xAE, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0xE0, 0x38, 0x23, 0x8E, 0x08, 0x00, 0x04, 0x24,
+0x5B, 0x01, 0x00, 0x0C, 0xDC, 0x38, 0x23, 0xAE, 0xDC, 0x38, 0x22, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xAE, 0xFE, 0x18, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0x23, 0x10, 0x67, 0x00, 0xFF, 0xFF, 0x57, 0x30,
+0x53, 0x21, 0x00, 0x0C, 0x21, 0x20, 0xE0, 0x02, 0x44, 0x00, 0x40, 0x10,
+0x21, 0xB0, 0x40, 0x00, 0x08, 0x00, 0x42, 0x8C, 0xDC, 0x38, 0x26, 0x8E,
+0x08, 0x00, 0x04, 0x24, 0x21, 0x18, 0x57, 0x00, 0xAC, 0x38, 0x23, 0xAE,
+0x21, 0x28, 0x40, 0x00, 0x21, 0x38, 0xE0, 0x02, 0xB0, 0x38, 0x22, 0xAE,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0xE0, 0x38, 0x23, 0x8E,
+0x08, 0x00, 0x04, 0x24, 0x5B, 0x01, 0x00, 0x0C, 0xDC, 0x38, 0x23, 0xAE,
+0xDC, 0x38, 0x23, 0x8E, 0x00, 0x01, 0x02, 0x36, 0x00, 0x00, 0x43, 0xAC,
+0xFE, 0x18, 0x00, 0x08, 0x02, 0x80, 0x02, 0x3C, 0x04, 0x00, 0x63, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x14, 0x03, 0x00, 0x0F, 0x00, 0x42, 0x30,
+0x08, 0x00, 0x42, 0x28, 0x99, 0xFF, 0x40, 0x10, 0x25, 0xB0, 0x02, 0x3C,
+0x02, 0x17, 0x03, 0x00, 0x03, 0x00, 0x42, 0x30, 0x94, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x80, 0x28, 0x10, 0x00, 0x21, 0x28, 0xB2, 0x00,
+0xE3, 0x17, 0x00, 0x0C, 0x21, 0x20, 0x60, 0x02, 0x21, 0x20, 0x40, 0x00,
+0x8D, 0x17, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x5E, 0x19, 0x00, 0x08,
+0x25, 0xB0, 0x02, 0x3C, 0x04, 0x00, 0x63, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x14, 0x03, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x08, 0x00, 0x42, 0x28,
+0x06, 0x00, 0x40, 0x10, 0x24, 0x10, 0x75, 0x00, 0x02, 0x17, 0x03, 0x00,
+0x03, 0x00, 0x42, 0x30, 0x0A, 0x00, 0x40, 0x10, 0x80, 0x28, 0x10, 0x00,
+0x24, 0x10, 0x75, 0x00, 0x79, 0xFF, 0x40, 0x14, 0x02, 0x17, 0x03, 0x00,
+0x03, 0x00, 0x42, 0x30, 0x76, 0xFF, 0x5E, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x74, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x80, 0x28, 0x10, 0x00,
+0x21, 0x28, 0xB2, 0x00, 0xE3, 0x17, 0x00, 0x0C, 0x21, 0x20, 0x60, 0x02,
+0x21, 0x20, 0x40, 0x00, 0x8D, 0x17, 0x00, 0x0C, 0x05, 0x00, 0x05, 0x24,
+0x59, 0x19, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x38, 0x23, 0x8E,
+0x00, 0x01, 0x02, 0x36, 0x00, 0x00, 0x43, 0xAC, 0x74, 0x19, 0x00, 0x08,
+0xDC, 0x38, 0x23, 0xAE, 0xB8, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x03, 0x3C,
+0x44, 0x00, 0xBF, 0xAF, 0x40, 0x00, 0xBE, 0xAF, 0x3C, 0x00, 0xB7, 0xAF,
+0x38, 0x00, 0xB6, 0xAF, 0x34, 0x00, 0xB5, 0xAF, 0x30, 0x00, 0xB4, 0xAF,
+0x2C, 0x00, 0xB3, 0xAF, 0x28, 0x00, 0xB2, 0xAF, 0x24, 0x00, 0xB1, 0xAF,
+0x20, 0x00, 0xB0, 0xAF, 0x44, 0x00, 0x63, 0x34, 0x00, 0x00, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x02, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x0E, 0x00, 0x40, 0x04, 0x1C, 0x00, 0xA0, 0xAF, 0x21, 0x20, 0x60, 0x00,
+0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x42, 0x30,
+0x64, 0x00, 0x43, 0x2C, 0xFD, 0xFF, 0x60, 0x14, 0x01, 0x00, 0x42, 0x24,
+0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x02, 0x00,
+0x03, 0x16, 0x02, 0x00, 0xF6, 0xFF, 0x41, 0x04, 0x21, 0x10, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x98, 0x54, 0x43, 0x8C, 0x00, 0x80, 0x06, 0x3C,
+0xD0, 0x67, 0xC2, 0x24, 0x25, 0xB0, 0x05, 0x3C, 0x02, 0x80, 0x06, 0x3C,
+0x18, 0x03, 0xA4, 0x34, 0x98, 0x54, 0xD1, 0x24, 0x00, 0x00, 0x82, 0xAC,
+0x4B, 0x00, 0x71, 0x10, 0x01, 0x00, 0x15, 0x24, 0x11, 0x11, 0x02, 0x3C,
+0x2A, 0xB0, 0x03, 0x3C, 0x22, 0x22, 0x57, 0x34, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0xB0, 0x80, 0x00, 0x06, 0x00, 0x7E, 0x34, 0x05, 0x00, 0x73, 0x34,
+0x60, 0x1B, 0x54, 0x24, 0x01, 0x00, 0x12, 0x24, 0x00, 0x00, 0xD7, 0xAE,
+0x05, 0x00, 0xA0, 0x12, 0x02, 0x80, 0x03, 0x3C, 0xEC, 0x5D, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x40, 0x14, 0x21, 0xA8, 0x00, 0x00,
+0x00, 0x00, 0xC2, 0x97, 0x38, 0x39, 0x90, 0x8E, 0x25, 0xB0, 0x03, 0x3C,
+0xB0, 0x03, 0x63, 0x34, 0x00, 0xFF, 0x42, 0x30, 0x00, 0x00, 0x70, 0xAC,
+0x0F, 0x00, 0x40, 0x18, 0x02, 0x80, 0x06, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xF0, 0xEC, 0xC6, 0x24, 0xF4, 0xEC, 0x42, 0x24, 0x00, 0x00, 0xC5, 0x8C,
+0x00, 0x00, 0x44, 0x8C, 0x02, 0x80, 0x06, 0x3C, 0xF8, 0xEC, 0xC6, 0x24,
+0x00, 0x00, 0xC3, 0x8C, 0x00, 0x00, 0xA4, 0xAC, 0x00, 0x00, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x42, 0x30, 0xFB, 0xFF, 0x40, 0x1C,
+0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x62, 0x30, 0x60, 0x00, 0x40, 0x14, 0x08, 0x00, 0x62, 0x24,
+0xC2, 0x10, 0x03, 0x00, 0x08, 0x00, 0x05, 0x8E, 0xF8, 0x37, 0x86, 0x8E,
+0xC0, 0x10, 0x02, 0x00, 0x20, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x47, 0x30,
+0x01, 0x00, 0x04, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xB2, 0xAF,
+0x5B, 0x01, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24, 0x02, 0x00, 0x02, 0x24,
+0x18, 0x00, 0xA4, 0x27, 0x00, 0x00, 0x72, 0xA2, 0x00, 0x00, 0x62, 0xA2,
+0x8A, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x8E,
+0x04, 0x00, 0x03, 0x8E, 0x21, 0x20, 0x00, 0x02, 0x00, 0x00, 0x62, 0xAC,
+0x04, 0x00, 0x43, 0xAC, 0x00, 0x00, 0x10, 0xAE, 0x74, 0x21, 0x00, 0x0C,
+0x04, 0x00, 0x10, 0xAE, 0x90, 0x40, 0x00, 0x0C, 0x18, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x51, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xA2, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0xEC, 0x5D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x40, 0x14,
+0x1C, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0x08, 0x08, 0x44, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00, 0x76, 0x39, 0x00, 0x0C,
+0x21, 0x38, 0x00, 0x00, 0x15, 0x1A, 0x00, 0x08, 0x02, 0x80, 0x02, 0x3C,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x06, 0x3C,
+0xEE, 0x5D, 0xC2, 0x90, 0x01, 0x00, 0x03, 0x24, 0x0F, 0x00, 0x42, 0x30,
+0x04, 0x00, 0x42, 0x28, 0x0F, 0x00, 0x40, 0x14, 0x1C, 0x00, 0xA3, 0xAF,
+0x02, 0x80, 0x06, 0x3C, 0xC6, 0x5C, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x42, 0x30, 0x12, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x08, 0x04, 0x24, 0x00, 0x02, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C,
+0x01, 0x00, 0x06, 0x24, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x2F, 0x1A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x24,
+0x4B, 0x2E, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0x02, 0x80, 0x06, 0x3C,
+0xC6, 0x5C, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x42, 0x30,
+0xF0, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x2D, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x8A, 0x1A, 0x00, 0x08, 0x00, 0x08, 0x04, 0x24,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x06, 0x3C,
+0xED, 0x5D, 0xC4, 0x90, 0x01, 0x00, 0x05, 0x24, 0x4B, 0x2E, 0x00, 0x0C,
+0xFF, 0x00, 0x84, 0x30, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x73, 0x1A, 0x00, 0x08, 0x02, 0x80, 0x02, 0x3C, 0x4B, 0x1A, 0x00, 0x08,
+0xC2, 0x10, 0x02, 0x00, 0x10, 0x00, 0xE0, 0x18, 0x21, 0x18, 0x00, 0x00,
+0x00, 0x00, 0xC0, 0xAC, 0x21, 0x40, 0x00, 0x00, 0x00, 0x00, 0x82, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x45, 0x10, 0x21, 0x18, 0x80, 0x00,
+0x01, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x48, 0x00,
+0x02, 0x00, 0x68, 0x24, 0x21, 0x10, 0x82, 0x00, 0x2B, 0x18, 0x07, 0x01,
+0xF5, 0xFF, 0x60, 0x14, 0x02, 0x00, 0x44, 0x24, 0x21, 0x18, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00, 0x01, 0x00, 0x82, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x60, 0x00, 0x02, 0x80, 0x07, 0x3C, 0x60, 0x1B, 0xE5, 0x24,
+0xCE, 0x40, 0xA3, 0x90, 0xFF, 0x00, 0x84, 0x30, 0x80, 0x10, 0x04, 0x00,
+0x0C, 0x00, 0x60, 0x14, 0x21, 0x30, 0x45, 0x00, 0xC8, 0x00, 0x02, 0x24,
+0x20, 0x3A, 0xA2, 0xAC, 0x01, 0x00, 0x03, 0x24, 0x60, 0x1B, 0xE2, 0x24,
+0x04, 0x18, 0x83, 0x00, 0xF8, 0x40, 0xA4, 0xA0, 0xCE, 0x40, 0x44, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x18, 0x64, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0xCE, 0x40, 0x43, 0xA0, 0x20, 0x3A, 0xA3, 0x8C, 0xC8, 0x00, 0x02, 0x24,
+0x23, 0x10, 0x43, 0x00, 0xD0, 0x40, 0xC2, 0xAC, 0x01, 0x00, 0x03, 0x24,
+0x60, 0x1B, 0xE2, 0x24, 0x04, 0x18, 0x83, 0x00, 0xCE, 0x40, 0x44, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x18, 0x64, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0xCE, 0x40, 0x43, 0xA0, 0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF,
+0x02, 0x80, 0x11, 0x3C, 0x10, 0x00, 0xB0, 0xAF, 0x18, 0x00, 0xBF, 0xAF,
+0x60, 0x1B, 0x25, 0x26, 0xF8, 0x40, 0xA6, 0x90, 0x01, 0x00, 0x02, 0x24,
+0x04, 0x10, 0xC2, 0x00, 0x06, 0x00, 0x40, 0x14, 0xC9, 0x00, 0x10, 0x24,
+0xC6, 0x40, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x23, 0x00, 0x40, 0x14, 0x21, 0x20, 0xC5, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x46, 0x24, 0x21, 0x20, 0x00, 0x00, 0xD0, 0x40, 0xC5, 0x24,
+0x00, 0x00, 0xA2, 0x8C, 0x04, 0x00, 0xA5, 0x24, 0x05, 0x00, 0x40, 0x10,
+0x2B, 0x18, 0x50, 0x00, 0x03, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x80, 0x40, 0x00, 0xF8, 0x40, 0xC4, 0xA0, 0x01, 0x00, 0x84, 0x24,
+0x08, 0x00, 0x82, 0x2C, 0xF5, 0xFF, 0x40, 0x14, 0xC9, 0x00, 0x02, 0x24,
+0x21, 0x00, 0x02, 0x12, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x45, 0x24,
+0x07, 0x00, 0x04, 0x24, 0xD0, 0x40, 0xA2, 0x8C, 0xFF, 0xFF, 0x84, 0x24,
+0x02, 0x00, 0x40, 0x10, 0x23, 0x18, 0x50, 0x00, 0xD0, 0x40, 0xA3, 0xAC,
+0xFA, 0xFF, 0x81, 0x04, 0x04, 0x00, 0xA5, 0x24, 0x60, 0x1B, 0x22, 0x26,
+0x20, 0x3A, 0x50, 0xAC, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xF0, 0x40, 0x83, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x63, 0x24,
+0xFF, 0x00, 0x62, 0x30, 0x03, 0x00, 0x42, 0x2C, 0xD8, 0xFF, 0x40, 0x10,
+0xF0, 0x40, 0x83, 0xA0, 0x80, 0x18, 0x06, 0x00, 0x21, 0x18, 0x65, 0x00,
+0xC8, 0x00, 0x02, 0x24, 0x03, 0x00, 0x04, 0x24, 0x21, 0x28, 0x00, 0x00,
+0xD9, 0x12, 0x00, 0x0C, 0xD0, 0x40, 0x62, 0xAC, 0xF2, 0x1A, 0x00, 0x08,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x22, 0x26, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x20, 0x00, 0xBD, 0x27,
+0xCE, 0x40, 0x40, 0xA0, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x3A, 0x40, 0xAC,
+0xB8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x08, 0x3C, 0x02, 0x80, 0x0B, 0x3C,
+0x02, 0x80, 0x0C, 0x3C, 0x40, 0x00, 0xBF, 0xAF, 0x3C, 0x00, 0xB5, 0xAF,
+0x38, 0x00, 0xB4, 0xAF, 0x34, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xB2, 0xAF,
+0x2C, 0x00, 0xB1, 0xAF, 0x28, 0x00, 0xB0, 0xAF, 0xE4, 0xEE, 0x63, 0x25,
+0xE0, 0xEE, 0x02, 0x25, 0xE8, 0xEE, 0x84, 0x25, 0x01, 0x00, 0x45, 0x90,
+0x01, 0x00, 0x66, 0x90, 0x01, 0x00, 0x87, 0x90, 0xE0, 0xEE, 0x0F, 0x91,
+0x02, 0x00, 0x4A, 0x90, 0xE4, 0xEE, 0x6E, 0x91, 0x02, 0x00, 0x69, 0x90,
+0xE8, 0xEE, 0x8D, 0x91, 0x02, 0x00, 0x88, 0x90, 0x03, 0x00, 0x4B, 0x90,
+0x03, 0x00, 0x6C, 0x90, 0x03, 0x00, 0x82, 0x90, 0x00, 0x2A, 0x05, 0x00,
+0x00, 0x32, 0x06, 0x00, 0x00, 0x3A, 0x07, 0x00, 0x25, 0x28, 0xAF, 0x00,
+0x25, 0x30, 0xCE, 0x00, 0x25, 0x38, 0xED, 0x00, 0x00, 0x54, 0x0A, 0x00,
+0x00, 0x4C, 0x09, 0x00, 0x00, 0x44, 0x08, 0x00, 0x25, 0x50, 0x45, 0x01,
+0x25, 0x48, 0x26, 0x01, 0x25, 0x40, 0x07, 0x01, 0x00, 0x5E, 0x0B, 0x00,
+0x00, 0x66, 0x0C, 0x00, 0x00, 0x16, 0x02, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x25, 0x58, 0x6A, 0x01, 0x25, 0x60, 0x89, 0x01, 0x25, 0x10, 0x48, 0x00,
+0xB0, 0x55, 0x84, 0x24, 0x10, 0x00, 0xAB, 0xAF, 0x18, 0x00, 0xAC, 0xAF,
+0x18, 0x52, 0x00, 0x0C, 0x20, 0x00, 0xA2, 0xAF, 0x10, 0x00, 0x42, 0x30,
+0x29, 0x00, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00, 0x02, 0x80, 0x13, 0x3C,
+0x60, 0x1B, 0x63, 0x26, 0xC0, 0x3A, 0x62, 0x8C, 0x0C, 0x00, 0x10, 0x24,
+0x2B, 0x10, 0x02, 0x02, 0x2C, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x24, 0x56, 0x51, 0x24, 0x2E, 0x56, 0x72, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x26, 0x56, 0x54, 0x24,
+0x7C, 0x1B, 0x00, 0x08, 0x32, 0x56, 0x75, 0x24, 0xDD, 0x00, 0x02, 0x24,
+0x21, 0x20, 0x14, 0x02, 0x2B, 0x00, 0x62, 0x10, 0x10, 0x00, 0xA5, 0x27,
+0x21, 0x10, 0x11, 0x02, 0x01, 0x00, 0x43, 0x90, 0x60, 0x1B, 0x64, 0x26,
+0xC0, 0x3A, 0x82, 0x8C, 0x21, 0x18, 0x70, 0x00, 0x02, 0x00, 0x70, 0x24,
+0x2B, 0x10, 0x02, 0x02, 0x17, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0x11, 0x02, 0x00, 0x00, 0x43, 0x90, 0x30, 0x00, 0x02, 0x24,
+0x21, 0x20, 0x12, 0x02, 0x20, 0x00, 0xA5, 0x27, 0xED, 0xFF, 0x62, 0x14,
+0x04, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xEE, 0xFF, 0x40, 0x14, 0x21, 0x10, 0x11, 0x02, 0x01, 0x00, 0x03, 0x24,
+0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F,
+0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F,
+0x28, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x48, 0x00, 0xBD, 0x27, 0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB5, 0x8F,
+0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F,
+0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F, 0x21, 0x18, 0x00, 0x00,
+0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27,
+0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x15, 0x02,
+0x18, 0x00, 0xA5, 0x27, 0xD1, 0xFF, 0x40, 0x14, 0x04, 0x00, 0x06, 0x24,
+0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xCE, 0xFF, 0x40, 0x14,
+0x21, 0x10, 0x11, 0x02, 0x88, 0x1B, 0x00, 0x08, 0x01, 0x00, 0x03, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x65, 0x24, 0xB0, 0x1B, 0xA2, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x34, 0x08, 0x00, 0x40, 0x10,
+0x70, 0x17, 0x04, 0x24, 0xB6, 0x40, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFB, 0xFF, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30, 0x02, 0x00, 0x42, 0x2C,
+0x0A, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x40, 0xA3, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x80, 0x18, 0x03, 0x00, 0x70, 0x17, 0x62, 0x28,
+0x04, 0x00, 0x40, 0x14, 0x70, 0x17, 0x04, 0x24, 0x21, 0x4E, 0x62, 0x28,
+0x20, 0x4E, 0x04, 0x24, 0x0B, 0x20, 0x62, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x80, 0x00, 0x21, 0x38, 0x80, 0x00, 0x08, 0x00, 0xC0, 0x10,
+0xFF, 0xFF, 0xC3, 0x24, 0xFF, 0xFF, 0x06, 0x24, 0x00, 0x00, 0xA2, 0x8C,
+0xFF, 0xFF, 0x63, 0x24, 0x04, 0x00, 0xA5, 0x24, 0x00, 0x00, 0xE2, 0xAC,
+0xFB, 0xFF, 0x66, 0x14, 0x04, 0x00, 0xE7, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x80, 0x00, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x10, 0xF0, 0x00, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x00, 0xF3,
+0x18, 0x4A, 0x2D, 0xF7, 0x19, 0x4B, 0xF9, 0x63, 0x60, 0xDA, 0x00, 0x6A,
+0x0C, 0x62, 0x0B, 0xD1, 0x0A, 0xD0, 0x07, 0xD2, 0xC9, 0xF7, 0x1B, 0x6A,
+0x4B, 0xEA, 0x40, 0x31, 0x20, 0x31, 0x10, 0xF0, 0x00, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x10, 0xF3, 0x68, 0x41, 0x2D, 0xF7, 0x19, 0x4A, 0x40, 0xDB,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x66, 0xF7, 0x48, 0xAB, 0x01, 0x4A, 0x66, 0xF7, 0x48, 0xCB, 0x00, 0x1C,
+0x9B, 0x40, 0x00, 0x65, 0xC0, 0xF0, 0x46, 0x41, 0x40, 0xAA, 0x11, 0x5A,
+0x12, 0x61, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x10, 0xF0,
+0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0xAB, 0xF5, 0x50, 0x9C, 0xCB, 0xF5,
+0x68, 0x9D, 0x6D, 0xEA, 0xAB, 0xF5, 0x50, 0xDC, 0x00, 0x6A, 0xCB, 0xF5,
+0x48, 0xDD, 0x00, 0x1C, 0x96, 0x40, 0x00, 0x65, 0x70, 0xF3, 0x60, 0x41,
+0xE0, 0x9B, 0x06, 0x27, 0x07, 0x92, 0xFF, 0xF7, 0x1F, 0x6C, 0x01, 0x4A,
+0x8C, 0xEA, 0x07, 0xD2, 0xFF, 0x6D, 0x01, 0x4D, 0xA0, 0x36, 0xC0, 0x30,
+0x4F, 0x40, 0xE3, 0xEA, 0x0D, 0x65, 0x80, 0xF0, 0x1E, 0x60, 0xFF, 0x6A,
+0x01, 0x4A, 0x4B, 0xEA, 0x40, 0x35, 0xA0, 0x35, 0xF0, 0xF0, 0x4F, 0x45,
+0x62, 0x67, 0x2A, 0x65, 0x00, 0xF3, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x34,
+0x80, 0x34, 0x47, 0x44, 0xEC, 0xEB, 0x11, 0x4A, 0x4A, 0xEB, 0x80, 0xF0,
+0x17, 0x60, 0x63, 0xEA, 0xA0, 0xF0, 0x04, 0x61, 0x01, 0xF6, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x35, 0xA0, 0x35, 0x41, 0x45, 0x4A, 0xEB, 0xC0, 0xF0,
+0x04, 0x60, 0x63, 0xEA, 0x00, 0xF1, 0x09, 0x61, 0x02, 0xF0, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x34, 0x80, 0x34, 0x43, 0x44, 0x4A, 0xEB, 0x40, 0xF1,
+0x17, 0x60, 0x63, 0xEA, 0xC0, 0xF1, 0x18, 0x61, 0x8A, 0xEB, 0x00, 0xF3,
+0x12, 0x60, 0x63, 0xEC, 0x80, 0xF3, 0x08, 0x61, 0x04, 0xF0, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x6E, 0xEA, 0xE0, 0xF3, 0x12, 0x22,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x00, 0x6B,
+0x60, 0xF3, 0x10, 0x4A, 0x60, 0xDA, 0x07, 0xD3, 0xC9, 0xF7, 0x1B, 0x68,
+0x0B, 0xE8, 0x00, 0x30, 0x00, 0x30, 0x10, 0xF0, 0x00, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x10, 0xF3, 0x68, 0x40, 0x2E, 0xF0, 0x19, 0x4A, 0x40, 0xDB,
+0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30, 0x00, 0x1C, 0x9B, 0x40,
+0xFF, 0x69, 0x63, 0xF3, 0x00, 0x48, 0x10, 0x10, 0xC9, 0xF7, 0x1B, 0x6D,
+0xAB, 0xED, 0xA0, 0x35, 0xA0, 0x35, 0x7F, 0x4D, 0x40, 0x4D, 0x40, 0xA5,
+0x2C, 0xEA, 0x04, 0x5A, 0x0F, 0x60, 0x27, 0xF1, 0x90, 0x98, 0x00, 0x1C,
+0xF5, 0x09, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x8A, 0xF4, 0x10, 0x4C, 0x00, 0x1C, 0x6A, 0x58, 0x00, 0x65, 0xE6, 0x22,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xEB, 0xF5, 0x4E, 0xA3,
+0x0F, 0x6B, 0xFF, 0x6C, 0x6C, 0xEA, 0x02, 0x72, 0x0B, 0x61, 0x10, 0xF0,
+0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0xEB, 0xF5, 0x4D, 0xA5, 0x8C, 0xEA,
+0x6C, 0xEA, 0x01, 0x72, 0x40, 0xF4, 0x00, 0x60, 0x00, 0x1C, 0x96, 0x40,
+0x00, 0x65, 0x00, 0x6D, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x02, 0xF0, 0x08, 0x4C, 0xC5, 0x67, 0x00, 0x1C, 0x76, 0x39, 0xE5, 0x67,
+0x19, 0x17, 0x07, 0x94, 0x0A, 0xF0, 0x00, 0x5C, 0xA5, 0x61, 0x00, 0x6A,
+0x40, 0xDB, 0x07, 0xD2, 0x01, 0x6A, 0x70, 0xF3, 0x64, 0x41, 0x4B, 0xEA,
+0x40, 0xDB, 0x9C, 0x17, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x0C, 0xF0, 0x00, 0x6A, 0x63, 0xF3, 0x00, 0x4D, 0x4B, 0xEA, 0x62, 0x9D,
+0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0x62, 0xDD, 0x82, 0x17,
+0xA0, 0xF0, 0x4C, 0x44, 0x4A, 0xEB, 0x00, 0xF4, 0x17, 0x60, 0x63, 0xEA,
+0x39, 0x61, 0xA0, 0xF0, 0x42, 0x44, 0x4A, 0xEB, 0x20, 0xF4, 0x0D, 0x60,
+0x63, 0xEA, 0xE0, 0xF0, 0x02, 0x61, 0x47, 0x44, 0x21, 0x4A, 0x4A, 0xEB,
+0x40, 0xF4, 0x11, 0x60, 0x63, 0xEA, 0xC0, 0xF1, 0x1D, 0x61, 0x47, 0x44,
+0x12, 0x4A, 0x6E, 0xEA, 0x7F, 0xF7, 0x06, 0x2A, 0xC9, 0xF7, 0x1B, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x00, 0x6B, 0x60, 0xF3, 0x10, 0x4A,
+0x60, 0xDA, 0x00, 0x18, 0x12, 0x27, 0x87, 0x67, 0x59, 0x17, 0x70, 0xF3,
+0x44, 0x41, 0xE0, 0x9A, 0x02, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x40, 0x32,
+0xFF, 0x4A, 0x4C, 0xEF, 0xE3, 0xEE, 0x5F, 0xF7, 0x0D, 0x60, 0x0A, 0xF0,
+0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x4D, 0xEF, 0x70, 0xF3,
+0x48, 0x41, 0xC0, 0x9A, 0xC0, 0xDF, 0x42, 0x17, 0x00, 0xF2, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x36, 0xC0, 0x36, 0x47, 0x46, 0x0B, 0x4A, 0x4A, 0xEB,
+0xC0, 0xF3, 0x17, 0x60, 0x63, 0xEA, 0xC0, 0xF0, 0x01, 0x61, 0xA0, 0xF0,
+0x4F, 0x44, 0x4A, 0xEB, 0x20, 0xF4, 0x15, 0x60, 0x63, 0xEA, 0x60, 0xF1,
+0x18, 0x61, 0xA0, 0xF0, 0x4D, 0x44, 0x6E, 0xEA, 0x60, 0xF4, 0x09, 0x22,
+0xA0, 0xF0, 0x4E, 0x44, 0x6E, 0xEA, 0x3F, 0xF7, 0x03, 0x2A, 0x1F, 0xF7,
+0x00, 0x6A, 0xE2, 0x34, 0x4C, 0xEC, 0x4C, 0xEF, 0x82, 0x34, 0x00, 0x18,
+0x3B, 0x5D, 0xE2, 0x35, 0xC9, 0xF7, 0x1B, 0x6B, 0x6B, 0xEB, 0x60, 0x33,
+0x60, 0x33, 0x60, 0xF3, 0x14, 0x4B, 0x40, 0xC3, 0x11, 0x17, 0x01, 0xF0,
+0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x35, 0xA0, 0x35, 0x47, 0x45, 0x0F, 0x4A,
+0x4A, 0xEB, 0xC0, 0xF3, 0x1A, 0x60, 0x63, 0xEA, 0xA0, 0xF0, 0x19, 0x61,
+0x01, 0xF4, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x4A, 0xEB,
+0x00, 0xF4, 0x06, 0x60, 0x63, 0xEA, 0xE0, 0xF1, 0x13, 0x61, 0x01, 0xF5,
+0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x6E, 0xEA, 0xFF, 0xF6,
+0x11, 0x2A, 0x1F, 0xF7, 0x00, 0x6A, 0xEC, 0xEA, 0x42, 0x30, 0x01, 0xF7,
+0x00, 0x6B, 0xE2, 0x32, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x6C, 0xEA, 0x63, 0xF3, 0x00, 0x4D, 0x42, 0x36, 0x28, 0xF1, 0xDB, 0xC5,
+0x20, 0xF3, 0x06, 0x26, 0xA3, 0xF3, 0x50, 0xAD, 0x10, 0xF0, 0x00, 0x6B,
+0x6B, 0xEB, 0x10, 0xF0, 0x00, 0x6C, 0x6D, 0xEA, 0xA3, 0xF3, 0x50, 0xCD,
+0x1E, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x4C, 0xEF, 0xFF, 0x6A, 0x4C, 0xE8,
+0x00, 0xF5, 0xE2, 0x31, 0x4C, 0xEE, 0x00, 0x1C, 0x3C, 0x0E, 0xB0, 0x67,
+0x90, 0x67, 0x00, 0x1C, 0x38, 0x0D, 0xB1, 0x67, 0xC9, 0xF7, 0x1B, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x60, 0xF3, 0x10, 0x4A, 0x00, 0x6B,
+0x60, 0xDA, 0xBA, 0x16, 0x1F, 0xF7, 0x00, 0x6B, 0xE2, 0x32, 0x6C, 0xEA,
+0x42, 0x32, 0xEC, 0xEB, 0x06, 0xD2, 0x62, 0x37, 0x80, 0xF3, 0x08, 0x22,
+0x01, 0x72, 0x01, 0x6C, 0x01, 0x60, 0x00, 0x6C, 0x00, 0x1C, 0xF0, 0x42,
+0x09, 0xD7, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x09, 0x97, 0x70, 0xF3, 0x24, 0x42, 0xC0, 0x99, 0x02, 0xF0, 0x00, 0x68,
+0x00, 0x30, 0x87, 0x67, 0xAF, 0x40, 0x00, 0x1C, 0x83, 0x45, 0x09, 0xD7,
+0x09, 0x97, 0xAF, 0x40, 0x00, 0x1C, 0xAC, 0x45, 0x87, 0x67, 0x40, 0xD9,
+0x91, 0x16, 0xA0, 0xF0, 0x45, 0x44, 0x4A, 0xEB, 0x60, 0xF3, 0x06, 0x60,
+0x63, 0xEA, 0x00, 0xF1, 0x0D, 0x61, 0xA0, 0xF0, 0x43, 0x44, 0x6E, 0xEA,
+0x40, 0xF1, 0x02, 0x22, 0xA0, 0xF0, 0x44, 0x44, 0x6E, 0xEA, 0x7F, 0xF6,
+0x1F, 0x2A, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0xFF, 0xF7, 0x1F, 0x6A, 0x27, 0xF1, 0x44, 0xDB, 0x74, 0x16,
+0x47, 0x46, 0x13, 0x4A, 0x4A, 0xEB, 0x80, 0xF0, 0x16, 0x60, 0x63, 0xEA,
+0x00, 0xF1, 0x1B, 0x61, 0x47, 0x46, 0x11, 0x4A, 0x6E, 0xEA, 0xE0, 0xF3,
+0x05, 0x22, 0x47, 0x46, 0x12, 0x4A, 0x6E, 0xEA, 0x7F, 0xF6, 0x02, 0x2A,
+0x00, 0x1C, 0x9B, 0x40, 0x00, 0x65, 0xC9, 0xF7, 0x1B, 0x6A, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x4B, 0xEA, 0x63, 0xF3, 0x00, 0x4B,
+0x40, 0x32, 0x23, 0xF4, 0x6A, 0xA3, 0x40, 0x32, 0x60, 0xF3, 0x14, 0x4A,
+0x60, 0xDA, 0x00, 0x1C, 0x96, 0x40, 0x00, 0x65, 0x4B, 0x16, 0x47, 0x44,
+0x4A, 0xEB, 0x80, 0xF3, 0x03, 0x60, 0x63, 0xEA, 0x00, 0xF1, 0x0C, 0x61,
+0x47, 0x45, 0x10, 0x4A, 0x6E, 0xEA, 0xC0, 0xF3, 0x11, 0x22, 0x47, 0x45,
+0x11, 0x4A, 0x6E, 0xEA, 0x3F, 0xF6, 0x1A, 0x2A, 0x00, 0x1C, 0x2B, 0x20,
+0x00, 0x65, 0x36, 0x16, 0x01, 0xF7, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x36,
+0xC0, 0x36, 0x42, 0x46, 0x4A, 0xEB, 0x3F, 0xF6, 0x0D, 0x60, 0x63, 0xEA,
+0x80, 0xF1, 0x04, 0x61, 0x47, 0x44, 0x01, 0x4A, 0x6E, 0xEA, 0xE0, 0xF1,
+0x01, 0x22, 0x43, 0x67, 0xCE, 0xEA, 0x3F, 0xF6, 0x01, 0x2A, 0xFF, 0x6A,
+0x01, 0x4A, 0x40, 0x32, 0x40, 0x32, 0x80, 0x4A, 0x80, 0x4A, 0x4C, 0xEF,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0xE2, 0x33, 0x63, 0xF3,
+0x00, 0x4C, 0xA3, 0xF3, 0x7A, 0xCC, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC,
+0x80, 0x34, 0x80, 0x34, 0x90, 0xF0, 0x44, 0x44, 0x60, 0xCA, 0x90, 0xF0,
+0xAA, 0x44, 0x00, 0xF4, 0x00, 0x6A, 0x40, 0xCD, 0x90, 0xF0, 0xA8, 0x44,
+0xA0, 0x6A, 0x40, 0xCD, 0xC9, 0xF7, 0x1A, 0x6D, 0xAB, 0xED, 0xA0, 0x35,
+0x04, 0x6E, 0x90, 0xF0, 0x46, 0x44, 0xA0, 0x35, 0xC0, 0xCA, 0x47, 0x45,
+0x73, 0x4A, 0xC0, 0xC2, 0xFF, 0xF7, 0x1F, 0x6A, 0x4C, 0xEB, 0x74, 0x33,
+0xC8, 0x43, 0xC8, 0x4E, 0xB0, 0xF3, 0x40, 0x44, 0xC0, 0xDA, 0x60, 0xF0,
+0xDC, 0xCD, 0x40, 0xF0, 0x64, 0xAC, 0x00, 0xF2, 0x01, 0x6A, 0x4B, 0xEA,
+0x6C, 0xEA, 0x40, 0xF0, 0x44, 0xCC, 0x40, 0xF0, 0x64, 0xAC, 0x00, 0xF2,
+0x00, 0x6A, 0x6D, 0xEA, 0x40, 0xF0, 0x44, 0xCC, 0xD9, 0x15, 0x0F, 0xF7,
+0x40, 0x40, 0x4C, 0xEF, 0xE2, 0x37, 0x87, 0x67, 0xFF, 0xF7, 0x1F, 0x6D,
+0xAC, 0xEC, 0x01, 0x74, 0x06, 0xD4, 0xA0, 0xF0, 0x18, 0x60, 0x02, 0x54,
+0x20, 0xF3, 0x13, 0x61, 0x06, 0x92, 0x03, 0x72, 0xE0, 0xF1, 0x19, 0x60,
+0xC9, 0xF7, 0x1B, 0x6A, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x4B, 0xEA, 0x63, 0xF3, 0x00, 0x4B, 0x40, 0x32, 0x23, 0xF4, 0x64, 0xAB,
+0x40, 0x32, 0x60, 0xF3, 0x14, 0x4A, 0x60, 0xDA, 0xB5, 0x15, 0x47, 0x46,
+0x09, 0x4A, 0x6E, 0xEA, 0xE0, 0xF2, 0x16, 0x22, 0x47, 0x46, 0x0A, 0x4A,
+0x6E, 0xEA, 0xBF, 0xF5, 0x0B, 0x2A, 0x00, 0x1C, 0x9B, 0x40, 0x09, 0xD7,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x00, 0x6A, 0x63, 0xF3,
+0x00, 0x4B, 0x23, 0xF4, 0x4A, 0xC3, 0xFF, 0x6A, 0x01, 0x4A, 0x40, 0x32,
+0x40, 0x32, 0x09, 0x97, 0x80, 0x4A, 0x80, 0x4A, 0x4C, 0xEF, 0xE0, 0x34,
+0x82, 0x34, 0x00, 0x1C, 0xA3, 0x31, 0x82, 0x34, 0x00, 0x1C, 0x96, 0x40,
+0x00, 0x65, 0x8E, 0x15, 0xA0, 0xF0, 0x40, 0x44, 0x6E, 0xEA, 0x80, 0xF0,
+0x1B, 0x22, 0xA0, 0xF0, 0x41, 0x44, 0x6E, 0xEA, 0x9F, 0xF5, 0x04, 0x2A,
+0xE2, 0x34, 0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEC, 0x00, 0x18, 0x11, 0x22,
+0x82, 0x34, 0x7C, 0x15, 0xA0, 0xF0, 0x46, 0x44, 0x6E, 0xEA, 0xC0, 0xF2,
+0x1B, 0x22, 0xA0, 0xF0, 0x47, 0x44, 0x6E, 0xEA, 0x7F, 0xF5, 0x12, 0x2A,
+0x1F, 0xF7, 0x00, 0x6A, 0xE2, 0x33, 0x4C, 0xEF, 0xE2, 0x36, 0x4C, 0xEB,
+0x01, 0x76, 0x62, 0x35, 0xA0, 0xF1, 0x17, 0x61, 0xAC, 0x32, 0xA9, 0xE2,
+0x48, 0x32, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0xA9, 0xE2,
+0xC9, 0xF7, 0x1B, 0x6B, 0x63, 0xF3, 0x00, 0x4C, 0x48, 0x32, 0x6B, 0xEB,
+0x89, 0xE2, 0x60, 0x33, 0x04, 0xF5, 0x40, 0x9A, 0x60, 0x33, 0x60, 0xF3,
+0x14, 0x4B, 0x40, 0xDB, 0x51, 0x15, 0x47, 0x45, 0x08, 0x4A, 0x6E, 0xEA,
+0x71, 0x22, 0x47, 0x45, 0x09, 0x4A, 0x6E, 0xEA, 0x5F, 0xF5, 0x08, 0x2A,
+0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEF, 0x4A, 0xEF, 0xDF, 0xF6, 0x03, 0x60,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x00, 0x6A, 0x27, 0xF1, 0x44, 0xDB, 0x38, 0x15, 0x47, 0x44, 0x0D, 0x4A,
+0x6E, 0xEA, 0x69, 0x22, 0x47, 0x44, 0x10, 0x4A, 0x6E, 0xEA, 0x3F, 0xF5,
+0x0F, 0x2A, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34,
+0x60, 0xF3, 0xA8, 0x44, 0x60, 0x9D, 0xFF, 0xF7, 0x1F, 0x6A, 0x60, 0xF3,
+0x04, 0x4C, 0x4C, 0xEB, 0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEF, 0xE0, 0x32,
+0x6D, 0xEA, 0x40, 0xDD, 0x60, 0xA4, 0xFF, 0x6A, 0x6C, 0xEA, 0x40, 0x6B,
+0x6D, 0xEA, 0x40, 0xC4, 0x15, 0x15, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x23, 0xF4, 0x42, 0xAA, 0xFF, 0xF7,
+0x1F, 0x6D, 0x70, 0xF3, 0x64, 0x41, 0xAC, 0xEA, 0x40, 0xDB, 0x06, 0x15,
+0x01, 0x4A, 0x6E, 0xEA, 0xA0, 0xF0, 0x0D, 0x22, 0x47, 0x45, 0x0E, 0x4A,
+0x6E, 0xEA, 0xFF, 0xF4, 0x1D, 0x2A, 0x00, 0x1C, 0xAE, 0x1F, 0x00, 0x65,
+0xF9, 0x14, 0x0F, 0xF7, 0x40, 0x40, 0xEC, 0xEA, 0x42, 0x37, 0x2D, 0xE7,
+0xC0, 0x9B, 0x70, 0xF3, 0x44, 0x41, 0xC0, 0xDA, 0xC0, 0x9B, 0xEE, 0x14,
+0x01, 0xF7, 0x00, 0x6A, 0x4C, 0xEF, 0xE2, 0x32, 0x01, 0x72, 0x01, 0x6C,
+0x07, 0x60, 0x02, 0x72, 0x02, 0x6C, 0x04, 0x60, 0x03, 0x72, 0x03, 0x6C,
+0x01, 0x60, 0x00, 0x6C, 0x00, 0x18, 0x92, 0x5D, 0x00, 0x65, 0xDC, 0x14,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x40, 0xF1,
+0x16, 0x4A, 0xFF, 0x6B, 0x60, 0xCA, 0x01, 0x6A, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0xEB, 0xF4, 0x50, 0xC3, 0xCB, 0x14, 0x0F, 0xF7,
+0x40, 0x40, 0xEC, 0xEA, 0xDF, 0xF4, 0x06, 0x22, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0x44, 0x9B,
+0xA9, 0x67, 0x88, 0x67, 0xAC, 0xEA, 0x8D, 0xEA, 0x00, 0xF3, 0x44, 0xDB,
+0x1F, 0xF7, 0x00, 0x6C, 0xE2, 0x32, 0x8C, 0xEA, 0x42, 0x32, 0x00, 0xF3,
+0x5C, 0xC3, 0x8C, 0xEF, 0xFB, 0x4A, 0x00, 0xF3, 0x5D, 0xC3, 0xE2, 0x32,
+0x00, 0xF3, 0x5E, 0xC3, 0xFB, 0x4A, 0x00, 0xF3, 0x5F, 0xC3, 0xA6, 0x14,
+0x44, 0x46, 0x6E, 0xEA, 0x6D, 0x22, 0x43, 0x67, 0xAE, 0xEA, 0x9F, 0xF4,
+0x1F, 0x2A, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x33, 0x60, 0x33,
+0x70, 0xF3, 0x44, 0x43, 0xE0, 0x9A, 0x02, 0xF0, 0x00, 0x6A, 0x40, 0x32,
+0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEF, 0xFF, 0x6A, 0x01, 0x4A, 0x40, 0x32,
+0xE3, 0xEA, 0x9F, 0xF4, 0x0B, 0x60, 0x0A, 0xF0, 0x00, 0x6A, 0x4B, 0xEA,
+0x40, 0x32, 0x40, 0x32, 0x4D, 0xEF, 0xC0, 0x9F, 0x70, 0xF3, 0x48, 0x43,
+0xC0, 0xDA, 0x80, 0x14, 0x41, 0x44, 0x6E, 0xEA, 0x5E, 0x22, 0x42, 0x44,
+0x6E, 0xEA, 0x7F, 0xF4, 0x19, 0x2A, 0x1F, 0xF7, 0x00, 0x6B, 0xE2, 0x32,
+0x6C, 0xEA, 0x42, 0x32, 0xEC, 0xEB, 0x06, 0xD2, 0x62, 0x37, 0x20, 0xF2,
+0x0C, 0x22, 0x01, 0x72, 0x01, 0x6C, 0x01, 0x60, 0x00, 0x6C, 0x00, 0x1C,
+0xF0, 0x42, 0x09, 0xD7, 0x09, 0x97, 0x02, 0xF0, 0x00, 0x68, 0x00, 0x30,
+0xAF, 0x40, 0x00, 0x1C, 0xAC, 0x45, 0x87, 0x67, 0xFF, 0x48, 0x4C, 0xE8,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x60, 0xF3,
+0x14, 0x4A, 0x00, 0xDA, 0x55, 0x14, 0xC9, 0xF7, 0x1B, 0x6A, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x4B, 0xEA, 0x63, 0xF3, 0x00, 0x4B,
+0x40, 0x32, 0xC4, 0xF7, 0x7C, 0xAB, 0x40, 0x32, 0x60, 0xF3, 0x14, 0x4A,
+0x60, 0xDA, 0x44, 0x14, 0x1F, 0xF7, 0x00, 0x6A, 0xEC, 0xEA, 0x42, 0x37,
+0x87, 0x67, 0x04, 0x27, 0x01, 0x77, 0x01, 0x6C, 0x01, 0x60, 0x00, 0x6C,
+0x00, 0x1C, 0xF0, 0x42, 0x00, 0x65, 0x36, 0x14, 0x1F, 0xF7, 0x00, 0x6B,
+0x47, 0x67, 0x6C, 0xEA, 0x42, 0x32, 0x06, 0xD2, 0xE2, 0x32, 0x6C, 0xEA,
+0x42, 0x36, 0x07, 0x5E, 0x3F, 0xF4, 0x0A, 0x60, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0xC8, 0x32, 0x1D, 0xF7, 0x14, 0x4B, 0x69, 0xE2,
+0x40, 0x9A, 0x00, 0xEA, 0x00, 0x65, 0x0F, 0xF7, 0x40, 0x40, 0xEC, 0xEA,
+0x42, 0x37, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x70, 0xF3, 0x64, 0x42, 0xC0, 0x9B, 0x49, 0xE7, 0xC0, 0xDA, 0xC0, 0x9A,
+0xC0, 0xDB, 0x0E, 0x14, 0x1F, 0xF7, 0x00, 0x6A, 0xEC, 0xEA, 0x42, 0x32,
+0xFF, 0x72, 0x71, 0x61, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x60, 0xF3, 0x04, 0x4A, 0x60, 0xAA, 0x88, 0x67, 0x6D, 0xEC,
+0x80, 0xCA, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x06, 0xF0,
+0x00, 0x6A, 0x63, 0xF3, 0x00, 0x4C, 0x4B, 0xEA, 0xE0, 0xF2, 0x64, 0x9C,
+0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0xE0, 0xF2, 0x64, 0xDC,
+0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEF, 0x19, 0xF4, 0x00, 0x77, 0xFF, 0xF3,
+0x05, 0x61, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x06, 0xF0,
+0x00, 0x6A, 0x63, 0xF3, 0x00, 0x4C, 0x4B, 0xEA, 0xE0, 0xF2, 0x64, 0x9C,
+0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0x02, 0xF0, 0x00, 0x6A,
+0x40, 0x32, 0x40, 0x32, 0x4D, 0xEB, 0xE0, 0xF2, 0x64, 0xDC, 0xDF, 0xF3,
+0x0D, 0x10, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xC9, 0xF7,
+0x1B, 0x6A, 0x63, 0xF3, 0x00, 0x4B, 0x4B, 0xEA, 0x23, 0xF4, 0x66, 0xAB,
+0x40, 0x32, 0x40, 0x32, 0xFF, 0xF7, 0x1F, 0x6C, 0x60, 0xF3, 0x14, 0x4A,
+0x8C, 0xEB, 0x60, 0xDA, 0xBF, 0xF3, 0x18, 0x10, 0xA3, 0xF3, 0x50, 0xAD,
+0xEF, 0xF7, 0x1F, 0x6B, 0x86, 0x67, 0x6C, 0xEA, 0xDB, 0x14, 0x02, 0x76,
+0x27, 0x61, 0xAC, 0x32, 0xA9, 0xE2, 0x48, 0x32, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0xA9, 0xE2, 0xC9, 0xF7, 0x1B, 0x6B, 0x63, 0xF3,
+0x00, 0x4C, 0x48, 0x32, 0x6B, 0xEB, 0x89, 0xE2, 0x60, 0x33, 0x04, 0xF5,
+0x44, 0x9A, 0x60, 0x33, 0x60, 0xF3, 0x14, 0x4B, 0x40, 0xDB, 0x9F, 0xF3,
+0x17, 0x10, 0xAA, 0x2A, 0xC9, 0xF7, 0x1B, 0x6B, 0x6B, 0xEB, 0x60, 0x33,
+0x60, 0x33, 0x60, 0xF3, 0x04, 0x4B, 0x80, 0xAB, 0xFF, 0x6A, 0x02, 0x4A,
+0x4B, 0xEA, 0x8C, 0xEA, 0x40, 0xCB, 0x8B, 0x17, 0x03, 0x76, 0x9F, 0xF3,
+0x05, 0x61, 0xAC, 0x32, 0xA9, 0xE2, 0x48, 0x32, 0xA9, 0xE2, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xC9, 0xF7, 0x1B, 0x6C, 0x48, 0x32,
+0x68, 0xF0, 0x08, 0x4B, 0x8B, 0xEC, 0x69, 0xE2, 0x80, 0x34, 0x40, 0x9A,
+0x80, 0x34, 0x60, 0xF3, 0x14, 0x4C, 0x40, 0xDC, 0x7F, 0xF3, 0x0E, 0x10,
+0xEB, 0xF5, 0x4D, 0xA5, 0x01, 0x6D, 0x00, 0x1C, 0x4B, 0x2E, 0x4C, 0xEC,
+0xBF, 0xF3, 0x18, 0x10, 0x00, 0x18, 0x84, 0x5C, 0x87, 0x67, 0x7F, 0xF3,
+0x01, 0x10, 0x00, 0x1C, 0x9B, 0x40, 0x09, 0xD7, 0x09, 0x97, 0x0F, 0xF7,
+0x40, 0x40, 0xFF, 0xF7, 0x1F, 0x6D, 0x4C, 0xEF, 0xE2, 0x32, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xAC, 0xEA, 0x63, 0xF3, 0x00, 0x4B,
+0x23, 0xF4, 0x4B, 0xC3, 0x00, 0x1C, 0x96, 0x40, 0x00, 0x65, 0x5F, 0xF3,
+0x09, 0x10, 0x0F, 0xF7, 0x40, 0x40, 0x4C, 0xEF, 0xE2, 0x37, 0x87, 0x67,
+0xFF, 0xF7, 0x1F, 0x6D, 0xAC, 0xEC, 0x06, 0xD4, 0x70, 0xF3, 0x04, 0x41,
+0xA0, 0x98, 0x00, 0x18, 0x63, 0x5E, 0x00, 0x65, 0xC0, 0x98, 0x06, 0x95,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x3D, 0xF7, 0x10, 0x4C,
+0x00, 0x1C, 0x13, 0x58, 0x00, 0x65, 0x3F, 0xF3, 0x0D, 0x10, 0x00, 0x1C,
+0xFA, 0x1F, 0x00, 0x65, 0x3F, 0xF3, 0x08, 0x10, 0x06, 0x94, 0x7A, 0x14,
+0xE2, 0x34, 0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEC, 0x00, 0x18, 0x8F, 0x5E,
+0x82, 0x34, 0x1F, 0xF3, 0x1D, 0x10, 0x02, 0xF0, 0x00, 0x68, 0x00, 0x30,
+0x60, 0x6E, 0xAF, 0x40, 0x00, 0x1C, 0x83, 0x45, 0x24, 0x6C, 0xE0, 0xF3,
+0x08, 0x6C, 0x00, 0x1C, 0x2C, 0x1F, 0x00, 0x65, 0x00, 0x1C, 0x9B, 0x40,
+0x00, 0x65, 0x24, 0x6C, 0x00, 0x1C, 0xAC, 0x45, 0xAF, 0x40, 0x1F, 0x6E,
+0x4C, 0xEE, 0x00, 0x1C, 0x96, 0x40, 0x08, 0xD6, 0x00, 0x1C, 0x5B, 0x1F,
+0x64, 0x6C, 0x08, 0x96, 0x70, 0xF3, 0x44, 0x41, 0xC0, 0xC2, 0xFF, 0xF2,
+0x1B, 0x10, 0x00, 0x18, 0x75, 0x5D, 0x00, 0x65, 0xFF, 0xF2, 0x16, 0x10,
+0x0F, 0xF7, 0x40, 0x40, 0x4C, 0xEF, 0xE2, 0x32, 0x01, 0x6B, 0xA2, 0x67,
+0x6C, 0xED, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x46, 0x36,
+0x6C, 0xEE, 0xDB, 0xF7, 0xA8, 0xDC, 0x4A, 0x37, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x4E, 0x32, 0x6C, 0xEA, 0x6C, 0xEF, 0xCB, 0xF4,
+0xD9, 0xC4, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x10, 0xF0,
+0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0xDB, 0xF7, 0xE4, 0xDC, 0x63, 0xF3,
+0x00, 0x4B, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0xC7, 0xF5,
+0x47, 0xC3, 0x5D, 0xF7, 0x0C, 0x4C, 0x00, 0x1C, 0x13, 0x58, 0x04, 0xD2,
+0xDF, 0xF2, 0x04, 0x10, 0x00, 0x18, 0xED, 0x60, 0x87, 0x67, 0xBF, 0xF2,
+0x1F, 0x10, 0x00, 0x18, 0x92, 0x5C, 0x87, 0x67, 0xBF, 0xF2, 0x1A, 0x10,
+0x00, 0x1C, 0x9B, 0x40, 0x09, 0xD7, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x23, 0xF4, 0x4A, 0xA3, 0x09, 0x97,
+0x5F, 0xF4, 0x1D, 0x2A, 0x01, 0x6A, 0x23, 0xF4, 0x4A, 0xC3, 0x0F, 0xF7,
+0x40, 0x40, 0x4C, 0xEF, 0xE0, 0x32, 0x42, 0x32, 0x42, 0x32, 0x23, 0xF4,
+0x4B, 0xC3, 0x82, 0x67, 0x00, 0x1C, 0xA3, 0x31, 0x06, 0xD2, 0x0A, 0x15,
+0x00, 0x18, 0x94, 0x5E, 0x00, 0x65, 0x9F, 0xF2, 0x17, 0x10, 0xDF, 0xF4,
+0x0F, 0x2C, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xC9, 0xF7,
+0x1B, 0x6A, 0x63, 0xF3, 0x00, 0x4B, 0x4B, 0xEA, 0x23, 0xF4, 0x60, 0xAB,
+0x40, 0x32, 0x40, 0x32, 0xFF, 0xF7, 0x1F, 0x6C, 0x60, 0xF3, 0x14, 0x4A,
+0x8C, 0xEB, 0xC7, 0x16, 0x00, 0x1C, 0x9B, 0x40, 0x00, 0x65, 0xC9, 0xF7,
+0x1B, 0x6A, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x4B, 0xEA,
+0x63, 0xF3, 0x00, 0x4B, 0x40, 0x32, 0x23, 0xF4, 0x6B, 0xA3, 0x40, 0x32,
+0x60, 0xF3, 0x14, 0x4A, 0x60, 0xDA, 0x1F, 0x14, 0x00, 0x1C, 0x5C, 0x20,
+0x00, 0x65, 0x7F, 0xF2, 0x09, 0x10, 0x06, 0x95, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0xC9, 0xF7, 0x1B, 0x6C, 0xB0, 0x32, 0x63, 0xF3,
+0x00, 0x4B, 0x8B, 0xEC, 0x69, 0xE2, 0x80, 0x34, 0x20, 0xF3, 0x55, 0xA2,
+0x80, 0x34, 0x60, 0xF3, 0x14, 0x4C, 0xE5, 0x16, 0x06, 0x93, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x70, 0x32, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x69, 0xE2, 0x80, 0x34, 0x20, 0xF3,
+0x54, 0xA2, 0x80, 0x34, 0x60, 0xF3, 0x14, 0x4C, 0xD2, 0x16, 0x06, 0x94,
+0xD6, 0x15, 0x06, 0x93, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x70, 0x32,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x69, 0xE2, 0x80, 0x34, 0x20, 0xF3, 0x56, 0xAA, 0x80, 0x34, 0x60, 0xF3,
+0x14, 0x4C, 0xBD, 0x16, 0x06, 0x95, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0xC9, 0xF7, 0x1B, 0x6C, 0xB0, 0x32, 0x63, 0xF3, 0x00, 0x4B,
+0x8B, 0xEC, 0x69, 0xE2, 0x80, 0x34, 0x20, 0xF3, 0x52, 0xAA, 0x80, 0x34,
+0x60, 0xF3, 0x14, 0x4C, 0xAA, 0x16, 0x06, 0x93, 0xC9, 0xF7, 0x1B, 0x6C,
+0x8B, 0xEC, 0x70, 0x32, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x63, 0xF3, 0x00, 0x4B, 0x69, 0xE2, 0x80, 0x34, 0x20, 0xF3, 0x50, 0xAA,
+0x80, 0x34, 0x60, 0xF3, 0x14, 0x4C, 0x97, 0x16, 0x06, 0x95, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0xB0, 0x32,
+0xC9, 0xF7, 0x1B, 0x6C, 0x69, 0xE2, 0x8B, 0xEC, 0x20, 0xF3, 0x4C, 0x9A,
+0x80, 0x34, 0x80, 0x34, 0x60, 0xF3, 0x14, 0x4C, 0x40, 0xF6, 0x42, 0x32,
+0x82, 0x16, 0x06, 0x93, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x70, 0x32,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x69, 0xE2, 0x20, 0xF3, 0x4F, 0xA2, 0x80, 0x34, 0x80, 0x34, 0x01, 0x6B,
+0x60, 0xF3, 0x14, 0x4C, 0x6C, 0xEA, 0x6D, 0x16, 0x00, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x18, 0x03, 0x42, 0x34, 0xB0, 0x7C, 0x63, 0x24,
+0x00, 0x00, 0x43, 0xAC, 0x02, 0x80, 0x05, 0x3C, 0xCC, 0x5D, 0xA5, 0x8C,
+0x04, 0x00, 0x02, 0x24, 0x1E, 0x00, 0xA2, 0x10, 0x05, 0x00, 0xA2, 0x2C,
+0x10, 0x00, 0x40, 0x10, 0x05, 0x00, 0x02, 0x24, 0x03, 0x00, 0x02, 0x24,
+0x08, 0x00, 0xA2, 0x10, 0x00, 0x19, 0x04, 0x00, 0x80, 0x10, 0x04, 0x00,
+0x21, 0x10, 0x44, 0x00, 0xC0, 0x10, 0x02, 0x00, 0x23, 0x10, 0x44, 0x00,
+0x00, 0x11, 0x02, 0x00, 0x21, 0x10, 0x44, 0x00, 0x40, 0x19, 0x02, 0x00,
+0xFF, 0xFF, 0x63, 0x24, 0xFE, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0xA2, 0x10,
+0x06, 0x00, 0x02, 0x24, 0xF2, 0xFF, 0xA2, 0x14, 0x80, 0x10, 0x04, 0x00,
+0x40, 0x11, 0x04, 0x00, 0x23, 0x10, 0x44, 0x00, 0x80, 0x10, 0x02, 0x00,
+0x21, 0x10, 0x44, 0x00, 0x00, 0x19, 0x02, 0x00, 0x23, 0x18, 0x62, 0x00,
+0x42, 0x1F, 0x00, 0x08, 0x00, 0x19, 0x03, 0x00, 0x80, 0x10, 0x04, 0x00,
+0x21, 0x10, 0x44, 0x00, 0xC0, 0x10, 0x02, 0x00, 0x23, 0x10, 0x44, 0x00,
+0x00, 0x11, 0x02, 0x00, 0x21, 0x10, 0x44, 0x00, 0x42, 0x1F, 0x00, 0x08,
+0x00, 0x19, 0x02, 0x00, 0x00, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x6C, 0x7D, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x02, 0x80, 0x05, 0x3C, 0xCC, 0x5D, 0xA3, 0x8C, 0x05, 0x00, 0x02, 0x24,
+0x06, 0x00, 0x62, 0x10, 0x06, 0x00, 0x62, 0x2C, 0x0C, 0x00, 0x40, 0x10,
+0x06, 0x00, 0x02, 0x24, 0x04, 0x00, 0x02, 0x24, 0x0E, 0x00, 0x62, 0x10,
+0x80, 0x10, 0x04, 0x00, 0x80, 0x10, 0x04, 0x00, 0x21, 0x10, 0x44, 0x00,
+0x80, 0x10, 0x02, 0x00, 0xFF, 0xFF, 0x42, 0x24, 0xFE, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xF7, 0xFF, 0x62, 0x14, 0x00, 0x11, 0x04, 0x00, 0x23, 0x10, 0x44, 0x00,
+0x6D, 0x1F, 0x00, 0x08, 0x40, 0x10, 0x02, 0x00, 0x21, 0x10, 0x44, 0x00,
+0x6D, 0x1F, 0x00, 0x08, 0x40, 0x10, 0x02, 0x00, 0xFF, 0xFF, 0x85, 0x30,
+0x21, 0x30, 0x00, 0x00, 0x25, 0xB0, 0x03, 0x3C, 0x2A, 0xB0, 0x04, 0x3C,
+0xB4, 0x00, 0x63, 0x34, 0x01, 0x00, 0xA2, 0x24, 0x31, 0x00, 0x84, 0x34,
+0x00, 0x00, 0x65, 0xA0, 0x00, 0x00, 0x85, 0xA0, 0xFF, 0xFF, 0x45, 0x30,
+0x12, 0x00, 0xA0, 0x10, 0x01, 0x00, 0x03, 0x24, 0x28, 0xB0, 0x07, 0x3C,
+0x8F, 0x1F, 0x00, 0x08, 0xFF, 0xFF, 0x08, 0x24, 0x00, 0x00, 0x83, 0xA0,
+0x01, 0x00, 0x63, 0x24, 0xFF, 0xFF, 0x63, 0x30, 0x2B, 0x10, 0xA3, 0x00,
+0x09, 0x00, 0x40, 0x14, 0x08, 0x00, 0xC6, 0x24, 0xF9, 0xFF, 0x65, 0x14,
+0x21, 0x20, 0xC7, 0x00, 0x01, 0x00, 0x63, 0x24, 0xFF, 0xFF, 0x63, 0x30,
+0x2B, 0x10, 0xA3, 0x00, 0x00, 0x00, 0x88, 0xA0, 0xF9, 0xFF, 0x40, 0x10,
+0x08, 0x00, 0xC6, 0x24, 0x00, 0x01, 0xA2, 0x2C, 0x13, 0x00, 0x40, 0x10,
+0x21, 0x18, 0xA0, 0x00, 0xFF, 0x00, 0x08, 0x24, 0x28, 0xB0, 0x07, 0x3C,
+0xA3, 0x1F, 0x00, 0x08, 0xFF, 0xFF, 0x09, 0x24, 0xFF, 0xFF, 0x43, 0x30,
+0x00, 0x00, 0xA2, 0xA0, 0x00, 0x01, 0x62, 0x2C, 0x0A, 0x00, 0x40, 0x10,
+0x08, 0x00, 0xC6, 0x24, 0x01, 0x00, 0x62, 0x24, 0xF9, 0xFF, 0x68, 0x14,
+0x21, 0x28, 0xC7, 0x00, 0x00, 0x01, 0x02, 0x24, 0xFF, 0xFF, 0x43, 0x30,
+0x00, 0x01, 0x62, 0x2C, 0x00, 0x00, 0xA9, 0xA0, 0xF8, 0xFF, 0x40, 0x14,
+0x08, 0x00, 0xC6, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xD0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF, 0x25, 0xB0, 0x12, 0x3C,
+0xFF, 0xFF, 0x02, 0x24, 0x28, 0x00, 0xB6, 0xAF, 0x1C, 0x00, 0xB3, 0xAF,
+0x42, 0x00, 0x56, 0x36, 0x14, 0x00, 0xB1, 0xAF, 0xFC, 0x77, 0x13, 0x24,
+0x40, 0x00, 0x51, 0x36, 0x00, 0x00, 0xC2, 0xA2, 0x10, 0x00, 0xB0, 0xAF,
+0x00, 0x00, 0x33, 0xA6, 0xFC, 0x57, 0x10, 0x24, 0x32, 0x00, 0x04, 0x24,
+0x2C, 0x00, 0xBF, 0xAF, 0x24, 0x00, 0xB5, 0xAF, 0x5B, 0x1F, 0x00, 0x0C,
+0x20, 0x00, 0xB4, 0xAF, 0x00, 0x00, 0x30, 0xA6, 0x5B, 0x1F, 0x00, 0x0C,
+0x32, 0x00, 0x04, 0x24, 0xFC, 0x37, 0x02, 0x24, 0x00, 0x00, 0x22, 0xA6,
+0x5B, 0x1F, 0x00, 0x0C, 0x32, 0x00, 0x04, 0x24, 0x00, 0x00, 0x33, 0xA6,
+0x5B, 0x1F, 0x00, 0x0C, 0x32, 0x00, 0x04, 0x24, 0x00, 0x00, 0x30, 0xA6,
+0x5B, 0x1F, 0x00, 0x0C, 0x32, 0x00, 0x04, 0x24, 0x00, 0x10, 0x02, 0x24,
+0x00, 0x00, 0x22, 0xA6, 0xD8, 0x00, 0x45, 0x36, 0x00, 0x00, 0xA2, 0x90,
+0xA0, 0x00, 0x54, 0x36, 0xA4, 0x00, 0x55, 0x36, 0x7F, 0x00, 0x42, 0x30,
+0x00, 0x00, 0xA2, 0xA0, 0xA8, 0x00, 0x53, 0x36, 0x00, 0x80, 0x02, 0x3C,
+0xFC, 0x17, 0x03, 0x24, 0x00, 0x00, 0x80, 0xAE, 0x00, 0x00, 0xA0, 0xAE,
+0x00, 0x00, 0x62, 0xAE, 0x00, 0x00, 0x23, 0xA6, 0x00, 0x00, 0xA3, 0x90,
+0x02, 0x80, 0x10, 0x3C, 0x60, 0x1B, 0x10, 0x26, 0xAA, 0x1B, 0x04, 0x92,
+0x80, 0xFF, 0x02, 0x24, 0x25, 0x18, 0x62, 0x00, 0x56, 0x01, 0x52, 0x36,
+0xFF, 0x0F, 0x02, 0x24, 0x00, 0x00, 0xA3, 0xA0, 0x00, 0x00, 0x42, 0xA6,
+0x7A, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x04, 0x8E,
+0x14, 0x1C, 0x02, 0x8E, 0x18, 0x1C, 0x03, 0x8E, 0x2C, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x82, 0xAE, 0x18, 0x00, 0xB2, 0x8F, 0x00, 0x00, 0xA3, 0xAE,
+0x20, 0x00, 0xB4, 0x8F, 0x00, 0x00, 0x64, 0xAE, 0x24, 0x00, 0xB5, 0x8F,
+0x00, 0x00, 0xC0, 0xA2, 0x1C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0xC8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0x10, 0x00, 0xA4, 0x27, 0x25, 0xB0, 0x10, 0x3C, 0x34, 0x00, 0xBF, 0xAF,
+0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF, 0x28, 0x00, 0xB4, 0xAF,
+0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x1C, 0x00, 0xB1, 0xAF, 0x40, 0x00, 0x05, 0x36, 0x00, 0x00, 0xA2, 0x94,
+0x24, 0xFA, 0x03, 0x24, 0xA8, 0x00, 0x13, 0x36, 0x24, 0x10, 0x43, 0x00,
+0x00, 0x00, 0xA2, 0xA4, 0xA0, 0x00, 0x12, 0x36, 0xA4, 0x00, 0x10, 0x36,
+0x00, 0x00, 0x55, 0x8E, 0x00, 0x00, 0x16, 0x8E, 0x00, 0x00, 0x71, 0x8E,
+0x00, 0x80, 0x14, 0x3C, 0xFC, 0x37, 0x02, 0x24, 0x00, 0x00, 0x40, 0xAE,
+0x21, 0x88, 0x34, 0x02, 0x00, 0x00, 0x00, 0xAE, 0xFD, 0x00, 0x04, 0x24,
+0x00, 0x00, 0x74, 0xAE, 0x00, 0x00, 0xA2, 0xA4, 0x7A, 0x1F, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAE, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x16, 0xAE, 0x00, 0x00, 0x71, 0xAE, 0x90, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27, 0xC8, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0x10, 0x00, 0xA4, 0x27, 0x25, 0xB0, 0x10, 0x3C,
+0x34, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x1C, 0x00, 0xB1, 0xAF, 0x40, 0x00, 0x05, 0x36,
+0x00, 0x00, 0xA2, 0x94, 0xAF, 0xFF, 0x03, 0x24, 0xA8, 0x00, 0x13, 0x36,
+0x24, 0x10, 0x43, 0x00, 0x00, 0x00, 0xA2, 0xA4, 0xA0, 0x00, 0x12, 0x36,
+0xA4, 0x00, 0x10, 0x36, 0x00, 0x00, 0x55, 0x8E, 0x00, 0x00, 0x16, 0x8E,
+0x00, 0x00, 0x71, 0x8E, 0x00, 0x80, 0x14, 0x3C, 0xFC, 0x37, 0x02, 0x24,
+0x00, 0x00, 0x40, 0xAE, 0x21, 0x88, 0x34, 0x02, 0x00, 0x00, 0x00, 0xAE,
+0xFD, 0x00, 0x04, 0x24, 0x00, 0x00, 0x74, 0xAE, 0x00, 0x00, 0xA2, 0xA4,
+0x7A, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAE,
+0x10, 0x00, 0xA4, 0x27, 0x00, 0x00, 0x16, 0xAE, 0x00, 0x00, 0x71, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x25, 0xB0, 0x05, 0x3C, 0x40, 0x00, 0xA5, 0x34,
+0x00, 0x00, 0xA2, 0x94, 0xD8, 0xFD, 0x03, 0x24, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x10, 0x43, 0x00, 0xFC, 0x37, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xA4,
+0x00, 0x00, 0xA3, 0xA4, 0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x00, 0xBF, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27, 0xFF, 0x00, 0x82, 0x30,
+0x10, 0x00, 0xA4, 0x27, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x21, 0x88, 0xC0, 0x00,
+0x21, 0x80, 0xE0, 0x00, 0xC0, 0x90, 0x02, 0x00, 0x28, 0x00, 0xBF, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0xFF, 0xFF, 0xB3, 0x30, 0x25, 0xB0, 0x02, 0x3C,
+0x40, 0x02, 0x49, 0x34, 0xF8, 0xFF, 0x10, 0x26, 0x21, 0x30, 0x00, 0x00,
+0x01, 0x00, 0x0A, 0x24, 0x44, 0x02, 0x48, 0x34, 0x99, 0x20, 0x00, 0x08,
+0x01, 0x80, 0x07, 0x3C, 0x2E, 0x00, 0xCA, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x02, 0x92, 0x00, 0x00, 0x04, 0x92, 0x02, 0x00, 0x03, 0x92,
+0x03, 0x00, 0x05, 0x92, 0x00, 0x12, 0x02, 0x00, 0x25, 0x20, 0x82, 0x00,
+0x00, 0x1C, 0x03, 0x00, 0x25, 0x20, 0x83, 0x00, 0x21, 0x10, 0x46, 0x02,
+0x00, 0x2E, 0x05, 0x00, 0x01, 0x00, 0xC6, 0x24, 0x25, 0x20, 0x85, 0x00,
+0x25, 0x10, 0x47, 0x00, 0x06, 0x00, 0xC3, 0x2C, 0x00, 0x00, 0x04, 0xAD,
+0x04, 0x00, 0x10, 0x26, 0x00, 0x00, 0x22, 0xAD, 0x12, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xEA, 0xFF, 0xC0, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x22, 0x92, 0x01, 0x00, 0x23, 0x92, 0x04, 0x00, 0x10, 0x26,
+0x00, 0x14, 0x02, 0x00, 0x25, 0x10, 0x62, 0x02, 0x00, 0x1E, 0x03, 0x00,
+0x25, 0x20, 0x43, 0x00, 0x21, 0x10, 0x46, 0x02, 0x01, 0x00, 0xC6, 0x24,
+0x25, 0x10, 0x47, 0x00, 0x06, 0x00, 0xC3, 0x2C, 0x00, 0x00, 0x04, 0xAD,
+0x00, 0x00, 0x22, 0xAD, 0xF0, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x28, 0x00, 0xBF, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0x03, 0x00, 0x22, 0x92, 0x02, 0x00, 0x24, 0x92, 0x04, 0x00, 0x23, 0x92,
+0x05, 0x00, 0x25, 0x92, 0x8B, 0x20, 0x00, 0x08, 0x00, 0x12, 0x02, 0x00,
+0xFF, 0xFF, 0x84, 0x30, 0x42, 0xB0, 0x08, 0x3C, 0x80, 0x10, 0x04, 0x00,
+0x21, 0x10, 0x48, 0x00, 0x04, 0x00, 0x46, 0xAC, 0x00, 0x00, 0x07, 0x91,
+0x40, 0x18, 0x04, 0x00, 0x03, 0x00, 0x06, 0x24, 0xFF, 0x00, 0xE7, 0x30,
+0x04, 0x30, 0x66, 0x00, 0x01, 0x00, 0x02, 0x24, 0x04, 0x10, 0x62, 0x00,
+0x25, 0x30, 0xC7, 0x00, 0xFF, 0xFF, 0xA5, 0x30, 0x25, 0x10, 0x47, 0x00,
+0x02, 0x00, 0xA0, 0x14, 0xFF, 0x00, 0xC7, 0x30, 0xFF, 0x00, 0x47, 0x30,
+0x42, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x47, 0xA0, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x83, 0x90, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x00, 0x86, 0xAC, 0x18, 0x00, 0x85, 0xAC, 0x00, 0x00, 0x84, 0xAC,
+0x03, 0x00, 0x62, 0x10, 0x04, 0x00, 0x84, 0xAC, 0x5F, 0x5C, 0x00, 0x08,
+0x0C, 0x00, 0x80, 0xAC, 0x0C, 0x00, 0x82, 0x8C, 0x5F, 0x5C, 0x00, 0x08,
+0x10, 0x00, 0x82, 0xAC, 0xC8, 0xFF, 0xBD, 0x27, 0x28, 0x00, 0xB6, 0xAF,
+0x25, 0xB0, 0x02, 0x3C, 0x02, 0x80, 0x16, 0x3C, 0x2C, 0x00, 0xB7, 0xAF,
+0x24, 0x00, 0xB5, 0xAF, 0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x30, 0x00, 0xBF, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x18, 0x03, 0x55, 0x34, 0x01, 0x80, 0x17, 0x3C,
+0x02, 0x80, 0x13, 0x3C, 0x02, 0x80, 0x14, 0x3C, 0xD0, 0xDF, 0xD2, 0x26,
+0x6C, 0x83, 0xE2, 0x26, 0x00, 0x00, 0xA2, 0xAE, 0xD0, 0xDF, 0xD0, 0x8E,
+0x9B, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x5C, 0x71, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x20, 0x12, 0x00, 0x00, 0x00, 0x00,
+0x96, 0x40, 0x00, 0x0C, 0xFC, 0x5C, 0x60, 0xAE, 0x22, 0x00, 0x12, 0x12,
+0x08, 0x0C, 0x84, 0x26, 0x14, 0x00, 0x03, 0x92, 0x01, 0x00, 0x02, 0x24,
+0x2A, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x60, 0x14,
+0x02, 0x00, 0x02, 0x24, 0x0C, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0x23, 0x02, 0x1D, 0x00, 0x40, 0x10, 0x23, 0x10, 0x71, 0x00,
+0x0C, 0x00, 0x02, 0xAE, 0x00, 0x00, 0x10, 0x8E, 0xF7, 0x20, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x60, 0x10,
+0x2B, 0x10, 0x23, 0x02, 0xF5, 0xFF, 0x40, 0x14, 0x23, 0x10, 0x71, 0x00,
+0x08, 0x00, 0x02, 0x8E, 0x18, 0x00, 0x04, 0x8E, 0x09, 0xF8, 0x40, 0x00,
+0x0C, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x10, 0x8E, 0xF7, 0x20, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x96, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x0C, 0x84, 0x26, 0x21, 0x28, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00,
+0x76, 0x39, 0x00, 0x0C, 0x21, 0x38, 0x00, 0x00, 0xED, 0x20, 0x00, 0x08,
+0x6C, 0x83, 0xE2, 0x26, 0x08, 0x00, 0x02, 0x8E, 0x18, 0x00, 0x04, 0x8E,
+0x09, 0xF8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x21, 0x00, 0x08,
+0x0C, 0x00, 0x02, 0xAE, 0x0C, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0x23, 0x02, 0xDA, 0xFF, 0x40, 0x14, 0x23, 0x10, 0x71, 0x00,
+0x08, 0x00, 0x02, 0x8E, 0x18, 0x00, 0x04, 0x8E, 0x09, 0xF8, 0x40, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0x03, 0xAE, 0x00, 0x00, 0x10, 0x8E, 0xF7, 0x20, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xD8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0xC0, 0x54, 0x42, 0x24, 0x18, 0x00, 0xB0, 0xAF, 0xC0, 0x80, 0x04, 0x00,
+0x21, 0x80, 0x02, 0x02, 0x1C, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xBF, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x00, 0x00, 0x02, 0x8E,
+0x10, 0x00, 0xA4, 0x27, 0x09, 0x00, 0x50, 0x10, 0x21, 0x88, 0x00, 0x00,
+0x04, 0x00, 0x43, 0x8C, 0x21, 0x88, 0x40, 0x00, 0x00, 0x00, 0x42, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xAC, 0x04, 0x00, 0x43, 0xAC,
+0x00, 0x00, 0x31, 0xAE, 0x04, 0x00, 0x31, 0xAE, 0x90, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x20, 0x02, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27, 0x01, 0x01, 0x82, 0x2C,
+0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x21, 0x18, 0x00, 0x00, 0x10, 0x00, 0x40, 0x14, 0x01, 0x00, 0x04, 0x24,
+0x01, 0x02, 0x02, 0x2E, 0x0D, 0x00, 0x40, 0x14, 0x02, 0x00, 0x04, 0x24,
+0x01, 0x08, 0x02, 0x2E, 0x0A, 0x00, 0x40, 0x14, 0x03, 0x00, 0x04, 0x24,
+0x01, 0x10, 0x02, 0x2E, 0x06, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x04, 0x00, 0x04, 0x24,
+0x35, 0x21, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xFF, 0x40, 0x10,
+0x21, 0x18, 0x40, 0x00, 0x0C, 0x00, 0x50, 0xAC, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x10, 0x00, 0x03, 0x8E, 0x02, 0x80, 0x02, 0x3C,
+0xC0, 0x54, 0x42, 0x24, 0xC0, 0x18, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x64, 0x8C, 0x02, 0x80, 0x06, 0x3C, 0x02, 0x80, 0x07, 0x3C,
+0x00, 0x00, 0x04, 0xAE, 0x04, 0x00, 0x90, 0xAC, 0x04, 0x00, 0x03, 0xAE,
+0xC4, 0x5D, 0xC5, 0x8C, 0x10, 0x00, 0xA4, 0x27, 0x05, 0x00, 0xA0, 0x10,
+0x00, 0x00, 0x70, 0xAC, 0xB0, 0x5D, 0xE2, 0x8C, 0xC4, 0x5D, 0xC0, 0xAC,
+0x25, 0x10, 0x45, 0x00, 0xB0, 0x5D, 0xE2, 0xAC, 0x90, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xC9, 0xF7, 0x1B, 0x6B,
+0x6B, 0xEB, 0x60, 0x33, 0xFF, 0x6A, 0x60, 0x33, 0x4C, 0xEC, 0x60, 0xF1,
+0x00, 0x4B, 0xAC, 0xEA, 0x69, 0xE2, 0x80, 0xC2, 0x20, 0xE8, 0x00, 0x65,
+0xFF, 0x6A, 0x8C, 0xEA, 0x15, 0x5A, 0x0E, 0x60, 0x01, 0x6B, 0x83, 0x67,
+0x84, 0xEA, 0x02, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0xEE, 0xF0, 0x10, 0x4A,
+0x8C, 0xEA, 0x05, 0x2A, 0x0F, 0x6A, 0x8C, 0xEA, 0x02, 0x6B, 0x01, 0x2A,
+0x00, 0x6B, 0x20, 0xE8, 0x43, 0x67, 0x00, 0x00, 0xFF, 0x63, 0x00, 0xD0,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x8C, 0x30, 0x0A, 0x65,
+0x89, 0xE0, 0x48, 0x32, 0x89, 0xE2, 0x68, 0x67, 0x63, 0xF3, 0x00, 0x4B,
+0x48, 0x32, 0x69, 0xE2, 0x01, 0xD1, 0x00, 0x6B, 0x04, 0xF5, 0x6A, 0xC2,
+0x04, 0xF5, 0x6B, 0xC2, 0x04, 0xF5, 0x64, 0x9A, 0x1C, 0x6D, 0x22, 0x67,
+0x01, 0x6F, 0xFF, 0x6E, 0x02, 0x10, 0xFF, 0x4D, 0xCC, 0xED, 0x47, 0x67,
+0x44, 0xED, 0x6C, 0xEA, 0xFA, 0x22, 0x04, 0xF5, 0xAA, 0xC1, 0x00, 0x6D,
+0x1D, 0x5D, 0x13, 0x60, 0x89, 0xE0, 0x48, 0x32, 0x68, 0x67, 0x89, 0xE2,
+0x63, 0xF3, 0x00, 0x4B, 0x48, 0x32, 0x79, 0xE2, 0x04, 0xF5, 0x44, 0x9E,
+0x01, 0x6B, 0x64, 0xED, 0x6C, 0xEA, 0x09, 0x2A, 0x01, 0x4D, 0xFF, 0x6A,
+0x4C, 0xED, 0x1D, 0x5D, 0xED, 0x61, 0x01, 0x91, 0x00, 0x90, 0x20, 0xE8,
+0x01, 0x63, 0x01, 0x91, 0x00, 0x90, 0x04, 0xF5, 0xAB, 0xC6, 0x20, 0xE8,
+0x01, 0x63, 0x00, 0x00, 0xFB, 0x63, 0x07, 0xD1, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0x00, 0x6A, 0x63, 0xF3, 0x00, 0x49, 0x08, 0x62,
+0x06, 0xD0, 0x04, 0xD2, 0x34, 0x10, 0x03, 0x54, 0x62, 0x60, 0x01, 0x74,
+0x6E, 0x60, 0x04, 0xF5, 0x88, 0x99, 0x07, 0x6A, 0xFF, 0x6B, 0x82, 0x34,
+0x86, 0x34, 0x4C, 0xEC, 0x04, 0x58, 0x6C, 0xEC, 0x12, 0x60, 0x00, 0x18,
+0xA1, 0x5C, 0xB0, 0x67, 0xC9, 0xF7, 0x1B, 0x6C, 0x04, 0xF5, 0x60, 0x99,
+0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x4C, 0xEB, 0x80, 0xF1, 0x04, 0x4C,
+0x08, 0x32, 0x89, 0xE2, 0x04, 0xF5, 0x64, 0xD9, 0x60, 0xDA, 0x00, 0x18,
+0xA5, 0x21, 0x04, 0x94, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x04, 0x93,
+0x80, 0x34, 0x80, 0x34, 0x60, 0xF1, 0x00, 0x4C, 0x89, 0xE3, 0x40, 0xA2,
+0x04, 0x92, 0x7F, 0x49, 0x15, 0x49, 0x01, 0x4A, 0x20, 0x5A, 0x04, 0xD2,
+0x48, 0x60, 0x04, 0xF5, 0xA8, 0x99, 0x01, 0x6B, 0xA2, 0x34, 0x92, 0x32,
+0x6C, 0xEA, 0xFF, 0x6B, 0x6C, 0xEA, 0xF0, 0x22, 0xE4, 0xF4, 0x78, 0x99,
+0xFF, 0x6A, 0x86, 0x34, 0x72, 0x33, 0x4C, 0xEB, 0x7F, 0x6A, 0x4C, 0xEB,
+0x07, 0x6A, 0x4C, 0xEC, 0xFF, 0x6A, 0x4C, 0xEC, 0x07, 0x68, 0xAC, 0xE8,
+0x02, 0x74, 0x4C, 0xE8, 0xB2, 0x61, 0x38, 0x5B, 0x0A, 0x61, 0x01, 0xF6,
+0x01, 0x6A, 0x4B, 0xEA, 0xAC, 0xEA, 0x00, 0xF2, 0x00, 0x6B, 0x6D, 0xEA,
+0x04, 0xF5, 0x48, 0xD9, 0xAA, 0x17, 0x14, 0x5B, 0xA8, 0x60, 0x01, 0xF6,
+0x01, 0x6A, 0x4B, 0xEA, 0xAC, 0xEA, 0x00, 0xF6, 0x00, 0x6B, 0x6D, 0xEA,
+0xF3, 0x17, 0x03, 0x74, 0x9E, 0x61, 0x1A, 0x5B, 0x9C, 0x61, 0x01, 0xF6,
+0x01, 0x6A, 0x4B, 0xEA, 0xAC, 0xEA, 0x00, 0xF4, 0x00, 0x6C, 0x8D, 0xEA,
+0x04, 0xF5, 0x48, 0xD9, 0x92, 0x17, 0x32, 0x5B, 0x90, 0x60, 0x01, 0xF6,
+0x01, 0x6A, 0x4B, 0xEA, 0xAC, 0xEA, 0x00, 0xF4, 0x00, 0x6B, 0x6D, 0xEA,
+0xDB, 0x17, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x00, 0x6A, 0x00, 0xEF,
+0x05, 0x63, 0x00, 0x00, 0x20, 0xE8, 0x00, 0x65, 0xA4, 0x67, 0xC9, 0xF7,
+0x1B, 0x6C, 0xFC, 0x63, 0x8B, 0xEC, 0x06, 0xD0, 0x80, 0x34, 0xAC, 0x30,
+0xA1, 0xE0, 0x80, 0x34, 0x07, 0x62, 0x80, 0xF1, 0x40, 0x44, 0x08, 0x30,
+0x40, 0xA2, 0xA1, 0xE0, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0x08, 0x30, 0x41, 0xE0, 0x04, 0xF5, 0x48, 0x98,
+0x07, 0x6B, 0x80, 0xF1, 0x04, 0x4C, 0x6C, 0xEA, 0x48, 0x32, 0x89, 0xE2,
+0x04, 0xF5, 0x60, 0x98, 0x40, 0x9A, 0x85, 0x67, 0x6C, 0xEA, 0x04, 0xF5,
+0x44, 0xD8, 0x00, 0x18, 0xA5, 0x21, 0x04, 0xD5, 0x04, 0x95, 0x04, 0xF5,
+0x8A, 0xA0, 0xFF, 0x6A, 0x00, 0x18, 0x93, 0x21, 0x4C, 0xED, 0x07, 0x97,
+0x06, 0x90, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x00, 0xFF, 0xF7, 0x1F, 0x6B,
+0x8C, 0xEB, 0x00, 0xF2, 0x00, 0x6A, 0x0B, 0x6C, 0x6C, 0xEA, 0x6C, 0xEC,
+0x07, 0x6B, 0x0E, 0x2A, 0x0C, 0x5C, 0x0B, 0x60, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x88, 0x32, 0x7D, 0xF7, 0x08, 0x4B, 0x69, 0xE2,
+0x40, 0x9A, 0x00, 0xEA, 0x00, 0x65, 0x07, 0x6B, 0x20, 0xE8, 0x43, 0x67,
+0x06, 0x6B, 0x20, 0xE8, 0x43, 0x67, 0x05, 0x6B, 0x20, 0xE8, 0x43, 0x67,
+0x04, 0x6B, 0x20, 0xE8, 0x43, 0x67, 0x03, 0x6B, 0x20, 0xE8, 0x43, 0x67,
+0x02, 0x6B, 0x20, 0xE8, 0x43, 0x67, 0x01, 0x6B, 0x20, 0xE8, 0x43, 0x67,
+0x00, 0x6B, 0x20, 0xE8, 0x43, 0x67, 0x00, 0x00, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0xF7, 0x63, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0x6A,
+0x0F, 0xD1, 0x23, 0x67, 0x10, 0x62, 0x0E, 0xD0, 0x04, 0xD2, 0x05, 0xD3,
+0x06, 0xD3, 0x07, 0xD3, 0x08, 0xD2, 0x09, 0xD2, 0x0A, 0xD2, 0x0B, 0xD2,
+0x0C, 0xD2, 0xE4, 0xF4, 0x08, 0x49, 0x48, 0x99, 0x01, 0x6B, 0xFF, 0x6C,
+0x42, 0x32, 0x52, 0x32, 0x6C, 0xEA, 0x8C, 0xEA, 0x80, 0xF0, 0x11, 0x22,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x04, 0x96, 0x40, 0x32,
+0x60, 0xF1, 0x00, 0x4A, 0x49, 0xE6, 0x40, 0xA2, 0xFF, 0x6B, 0x4C, 0xEC,
+0x05, 0x92, 0x0C, 0x65, 0x51, 0xE4, 0xC0, 0xF4, 0x4A, 0xA4, 0x6C, 0xEA,
+0x61, 0x99, 0x58, 0xEB, 0xE0, 0xF4, 0x47, 0xA4, 0xFF, 0x6B, 0x6C, 0xEA,
+0x62, 0x99, 0x12, 0xED, 0x00, 0x65, 0x00, 0x65, 0x58, 0xEB, 0x12, 0xEA,
+0x55, 0xE5, 0xFF, 0xF7, 0x4C, 0x99, 0xA3, 0xEA, 0x40, 0xF1, 0x0F, 0x61,
+0xAB, 0xE2, 0xFF, 0xF7, 0x4C, 0xD9, 0x61, 0x99, 0x42, 0x99, 0xC8, 0x67,
+0xFF, 0xF7, 0xEC, 0x99, 0x55, 0xE3, 0xFF, 0xF7, 0x70, 0x99, 0xFF, 0xF7,
+0x54, 0x99, 0x51, 0xE3, 0xFF, 0xF7, 0x7C, 0x99, 0x40, 0x99, 0x41, 0xE3,
+0x05, 0x93, 0x69, 0xE6, 0x20, 0xF5, 0x5E, 0xA2, 0xFF, 0x6E, 0xCC, 0xEA,
+0xC5, 0x67, 0x0F, 0x25, 0xA3, 0xEA, 0xD8, 0x67, 0x0D, 0x2E, 0x48, 0x67,
+0x07, 0x5A, 0x04, 0x61, 0x0C, 0x72, 0x02, 0x60, 0x0D, 0x72, 0x05, 0x61,
+0xAC, 0x32, 0xAB, 0xE2, 0x4E, 0x32, 0x83, 0xEA, 0x10, 0x61, 0x79, 0x26,
+0x05, 0x92, 0x68, 0x67, 0x68, 0x34, 0x51, 0xE4, 0x06, 0x92, 0x69, 0xE2,
+0x44, 0xF5, 0x66, 0xA2, 0xFF, 0x6A, 0x4C, 0xEB, 0x60, 0xF5, 0x40, 0x9C,
+0x44, 0xEB, 0xE3, 0xEA, 0x6A, 0x60, 0x01, 0x68, 0x5F, 0x99, 0x70, 0x67,
+0x88, 0x67, 0x64, 0xEC, 0x6C, 0xEA, 0x00, 0xF1, 0x1C, 0x22, 0x06, 0x96,
+0x95, 0xE6, 0x44, 0xF5, 0x66, 0xA5, 0x04, 0xF5, 0xEC, 0xA5, 0xFF, 0x6E,
+0x46, 0x67, 0xCC, 0xEB, 0x0A, 0x6C, 0xEC, 0xEA, 0x84, 0xEB, 0x82, 0xEA,
+0x00, 0xF1, 0x0D, 0x60, 0x41, 0x47, 0x04, 0xF5, 0x4C, 0xC5, 0xCC, 0xEA,
+0x8E, 0xEA, 0x02, 0x2A, 0x24, 0xF5, 0x09, 0xC5, 0x05, 0x94, 0x68, 0x67,
+0x68, 0x32, 0x89, 0xE2, 0xC0, 0xF5, 0x94, 0x9A, 0x60, 0xF5, 0x40, 0x9A,
+0x84, 0x33, 0x8D, 0xE3, 0x69, 0xE2, 0x4A, 0x37, 0xFF, 0xF7, 0xEC, 0xD9,
+0x05, 0x96, 0x27, 0xF1, 0x44, 0x9E, 0xFF, 0xF7, 0x1F, 0x72, 0xC0, 0xF0,
+0x1B, 0x61, 0x00, 0x6B, 0x61, 0xD9, 0x62, 0xD9, 0xFF, 0xF7, 0x70, 0xD9,
+0xFF, 0xF7, 0x74, 0xD9, 0xFF, 0xF7, 0x78, 0xD9, 0xFF, 0xF7, 0x7C, 0xD9,
+0x60, 0xD9, 0x04, 0x94, 0x0C, 0x96, 0x0B, 0x92, 0x01, 0x4C, 0x0A, 0x93,
+0x04, 0xD4, 0x09, 0x94, 0x7F, 0x4E, 0x7F, 0x4A, 0x7F, 0x4B, 0x15, 0x4E,
+0x15, 0x4A, 0x15, 0x4B, 0x7F, 0x4C, 0x15, 0x4C, 0x0C, 0xD6, 0x0B, 0xD2,
+0x08, 0x96, 0x07, 0x92, 0x0A, 0xD3, 0x06, 0x93, 0x09, 0xD4, 0x04, 0x94,
+0x7F, 0x4E, 0x7F, 0x4A, 0x7F, 0x4B, 0x15, 0x4E, 0x15, 0x4A, 0x15, 0x4B,
+0x7F, 0x49, 0x20, 0x54, 0x08, 0xD6, 0x07, 0xD2, 0x06, 0xD3, 0x15, 0x49,
+0x3F, 0xF7, 0x15, 0x61, 0x10, 0x97, 0x0F, 0x91, 0x0E, 0x90, 0x00, 0xEF,
+0x09, 0x63, 0xA0, 0xF0, 0x0E, 0x25, 0xA0, 0xF0, 0x0E, 0x2E, 0xA4, 0x32,
+0xA9, 0xE2, 0x4A, 0x32, 0x03, 0xEA, 0xC1, 0x60, 0x06, 0x96, 0x48, 0x67,
+0x00, 0x6B, 0x51, 0xE6, 0x04, 0xF5, 0x6C, 0xC4, 0x01, 0x6B, 0x64, 0xEA,
+0x5F, 0x99, 0x6F, 0xEB, 0x6C, 0xEA, 0x5F, 0xD9, 0x24, 0xF5, 0x49, 0xA4,
+0xFF, 0x6C, 0x8C, 0xEA, 0x01, 0x72, 0x10, 0x60, 0x09, 0x96, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x00, 0x6D, 0x63, 0xF3, 0x00, 0x4A,
+0x4D, 0xE6, 0x85, 0x67, 0xA9, 0xE3, 0x01, 0x4D, 0x1D, 0x55, 0x44, 0xF5,
+0x86, 0xC2, 0xFA, 0x61, 0x06, 0x93, 0x88, 0x67, 0x00, 0x6E, 0x89, 0xE3,
+0x24, 0xF5, 0xC9, 0xC2, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x9D, 0xF7, 0x18, 0x4A, 0x00, 0x9A, 0x10, 0xF0, 0x02, 0x6F, 0x00, 0xF4,
+0xE0, 0x37, 0x10, 0xF0, 0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x00, 0x6D,
+0x5C, 0xF4, 0x00, 0x4F, 0xDC, 0xF3, 0x0C, 0x4E, 0xA8, 0x32, 0xED, 0xE2,
+0x60, 0x9B, 0x11, 0xE2, 0xC9, 0xE2, 0xC0, 0xF5, 0x74, 0xDC, 0x40, 0x9A,
+0x01, 0x4D, 0x1D, 0x55, 0x60, 0xF5, 0x40, 0xDC, 0xF3, 0x61, 0x68, 0x67,
+0x20, 0x23, 0x07, 0x94, 0xA8, 0x67, 0xFF, 0x4D, 0x04, 0xF5, 0x4B, 0xA4,
+0xFF, 0x68, 0x42, 0xED, 0x18, 0x61, 0x08, 0x96, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x69, 0xE6, 0x04, 0xF5,
+0x8B, 0xA2, 0x04, 0xF5, 0xC4, 0x9A, 0x01, 0x6F, 0x0C, 0xEC, 0x67, 0x67,
+0x64, 0xED, 0x46, 0x67, 0x6C, 0xEA, 0x6E, 0xEA, 0x00, 0xF1, 0x03, 0x22,
+0xFF, 0x4D, 0x82, 0xED, 0xF6, 0x60, 0x88, 0x67, 0x10, 0xF0, 0x02, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x88, 0x32, 0x63, 0xF3, 0x00, 0x4E, 0xC9, 0xE2,
+0xC0, 0xF5, 0x94, 0x9A, 0x60, 0xF5, 0x40, 0x9A, 0x84, 0x33, 0x8D, 0xE3,
+0x69, 0xE2, 0x4A, 0x37, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0xCB, 0xF4, 0x46, 0xA2, 0xFF, 0x6B, 0x6C, 0xEA, 0x22, 0x72, 0xC0, 0xF0,
+0x17, 0x61, 0x88, 0x67, 0x13, 0x74, 0x3F, 0xF7, 0x0D, 0x60, 0x07, 0x96,
+0x01, 0x6B, 0x64, 0xEC, 0x64, 0xF5, 0x44, 0x9E, 0xFF, 0xF7, 0xEC, 0xD9,
+0x6D, 0xEA, 0x64, 0xF5, 0x44, 0xDE, 0x05, 0x96, 0x27, 0xF1, 0x44, 0x9E,
+0xFF, 0xF7, 0x1F, 0x72, 0x3F, 0xF7, 0x05, 0x60, 0x04, 0x95, 0xFF, 0x6A,
+0x88, 0x67, 0x00, 0x18, 0x93, 0x21, 0x4C, 0xED, 0x1E, 0x17, 0x00, 0x6B,
+0xFF, 0xF7, 0x6C, 0xD9, 0xB0, 0x16, 0x1F, 0xF7, 0x18, 0x26, 0x05, 0x94,
+0x68, 0x67, 0x68, 0x32, 0x89, 0xE2, 0xC0, 0xF5, 0x54, 0x9A, 0x43, 0xEF,
+0x4E, 0x17, 0x48, 0x67, 0x1C, 0x5A, 0xFF, 0xF6, 0x17, 0x60, 0x06, 0x94,
+0x4D, 0xE4, 0x24, 0xF5, 0x49, 0xA3, 0xFF, 0x6C, 0x01, 0x72, 0x53, 0x60,
+0x0C, 0x96, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x00, 0x6D,
+0x63, 0xF3, 0x00, 0x4A, 0x4D, 0xE6, 0x85, 0x67, 0xA9, 0xE3, 0x01, 0x4D,
+0x1D, 0x55, 0x44, 0xF5, 0x86, 0xC2, 0xFA, 0x61, 0x06, 0x93, 0x88, 0x67,
+0x00, 0x6E, 0x89, 0xE3, 0x01, 0x6C, 0x04, 0xF5, 0xCC, 0xC2, 0x24, 0xF5,
+0xC9, 0xC2, 0x64, 0x67, 0x48, 0x67, 0x64, 0xEA, 0x5F, 0x99, 0x6F, 0xEB,
+0x6C, 0xEA, 0x68, 0x67, 0x5F, 0xD9, 0x4E, 0x23, 0x20, 0xF0, 0x42, 0xA1,
+0xA8, 0x67, 0x01, 0x4D, 0xA2, 0xEA, 0xFF, 0x68, 0x17, 0x61, 0x0A, 0x93,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x63, 0xF3, 0x00, 0x4C,
+0x89, 0xE3, 0x04, 0xF5, 0x8A, 0xA2, 0x04, 0xF5, 0xC4, 0x9A, 0x01, 0x6F,
+0x0C, 0xEC, 0x67, 0x67, 0x64, 0xED, 0x46, 0x67, 0x6C, 0xEA, 0x6E, 0xEA,
+0x6F, 0x22, 0x01, 0x4D, 0xA2, 0xEC, 0xF7, 0x60, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0xCB, 0xF4, 0x46, 0xA2, 0x22, 0x72, 0xBF, 0xF6,
+0x07, 0x61, 0x48, 0x67, 0xEE, 0x4A, 0xFF, 0x6B, 0x6C, 0xEA, 0x02, 0x5A,
+0xBF, 0xF6, 0x00, 0x60, 0x18, 0x6E, 0x0E, 0x65, 0x9D, 0x16, 0xC8, 0x67,
+0x18, 0x5E, 0x3F, 0x61, 0x44, 0xF5, 0x46, 0xA3, 0x4C, 0xEC, 0x05, 0x5C,
+0x03, 0x60, 0x01, 0x4A, 0x44, 0xF5, 0x46, 0xC3, 0x06, 0x93, 0x88, 0x67,
+0x00, 0x6E, 0x89, 0xE3, 0x01, 0x6C, 0x04, 0xF5, 0xCC, 0xC2, 0x24, 0xF5,
+0xC9, 0xC2, 0x64, 0x67, 0x48, 0x67, 0x64, 0xEA, 0x5F, 0x99, 0x6F, 0xEB,
+0x6C, 0xEA, 0x68, 0x67, 0x5F, 0xD9, 0xB2, 0x2B, 0x20, 0xF0, 0x42, 0xA1,
+0xA4, 0x67, 0xFF, 0x68, 0xAD, 0x22, 0x0B, 0x94, 0x10, 0xF0, 0x02, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x63, 0xF3, 0x00, 0x4E, 0xC9, 0xE4, 0x04, 0xF5,
+0x8A, 0xA2, 0xE5, 0x67, 0x04, 0xF5, 0xC4, 0x9A, 0x0C, 0xEC, 0x67, 0x67,
+0x64, 0xED, 0x46, 0x67, 0x6C, 0xEA, 0x6E, 0xEA, 0x09, 0x22, 0x01, 0x4D,
+0xA2, 0xEC, 0x96, 0x61, 0x67, 0x67, 0x64, 0xED, 0x46, 0x67, 0x6C, 0xEA,
+0x6E, 0xEA, 0xF7, 0x2A, 0x0C, 0xED, 0x0D, 0x65, 0x8D, 0x17, 0x48, 0x67,
+0x05, 0x5A, 0x05, 0x60, 0x44, 0xF5, 0x46, 0xA3, 0x4C, 0xEC, 0x03, 0x5C,
+0xBD, 0x17, 0x44, 0xF5, 0x46, 0xA3, 0x4C, 0xEC, 0x04, 0x5C, 0xB8, 0x17,
+0x07, 0x94, 0x48, 0x67, 0x01, 0x6B, 0x64, 0xEA, 0x64, 0xF5, 0x44, 0x9C,
+0x6D, 0xEA, 0x64, 0xF5, 0x44, 0xDC, 0x50, 0x16, 0x0C, 0xED, 0x0D, 0x65,
+0x91, 0x17, 0x0C, 0xED, 0x0D, 0x65, 0xFD, 0x16, 0xFC, 0x63, 0x10, 0xF0,
+0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x05, 0xD1, 0x06, 0x62, 0x04, 0xD0,
+0x63, 0xF3, 0x00, 0x4C, 0x87, 0xF0, 0x58, 0x9C, 0x87, 0xF0, 0x7D, 0xA4,
+0x65, 0xE2, 0x87, 0xF0, 0x54, 0x9C, 0x43, 0xE9, 0xE0, 0xF0, 0x04, 0x60,
+0x04, 0x67, 0x0C, 0x10, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30,
+0x63, 0xF3, 0x00, 0x48, 0x87, 0xF0, 0x54, 0x98, 0x10, 0x49, 0x43, 0xE9,
+0xC0, 0xF0, 0x16, 0x60, 0x87, 0xF0, 0x5D, 0xA0, 0xFF, 0xF7, 0x1F, 0x6D,
+0x2C, 0xED, 0x10, 0x4A, 0x87, 0xF0, 0x5D, 0xC0, 0xEF, 0xF7, 0x1E, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4,
+0x80, 0x34, 0xAA, 0xF2, 0x14, 0x4C, 0x4D, 0xED, 0x00, 0x1C, 0xF4, 0x54,
+0x10, 0x6E, 0x46, 0xF7, 0xB8, 0x98, 0x1F, 0x6B, 0x40, 0xF4, 0xA2, 0x34,
+0x6C, 0xEC, 0x8C, 0x32, 0x89, 0xE2, 0x48, 0x32, 0x89, 0xE2, 0x48, 0x32,
+0x19, 0xE2, 0x04, 0xF5, 0x48, 0x9E, 0x01, 0x6B, 0x42, 0x32, 0x52, 0x32,
+0x6C, 0xEA, 0xFF, 0x6B, 0x6C, 0xEA, 0xC8, 0x22, 0xC9, 0xF7, 0x1B, 0x6B,
+0x6B, 0xEB, 0x60, 0x33, 0x60, 0x33, 0x60, 0xF1, 0x00, 0x4B, 0x69, 0xE4,
+0x40, 0xA2, 0xFF, 0x6B, 0xFF, 0x6F, 0x4C, 0xEB, 0x0B, 0x65, 0x46, 0xF7,
+0x74, 0x98, 0x3F, 0x68, 0x80, 0xF5, 0x62, 0x32, 0x0C, 0xEA, 0x05, 0x52,
+0x4C, 0xEF, 0x01, 0x61, 0x04, 0x6F, 0xC0, 0xF7, 0x62, 0x32, 0x0E, 0x2A,
+0xE4, 0xF4, 0x54, 0x9E, 0x04, 0x6F, 0x01, 0x4A, 0xE4, 0xF4, 0x54, 0xDE,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A,
+0x46, 0xF7, 0xB8, 0x9A, 0xA2, 0x32, 0x52, 0x32, 0x1F, 0x6B, 0x6C, 0xEA,
+0x08, 0x52, 0x52, 0x60, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x63, 0xF3, 0x00, 0x4D, 0x46, 0xF7, 0x54, 0x9D, 0x0C, 0xEA, 0x08, 0x67,
+0x0E, 0xEA, 0x46, 0x2A, 0x74, 0x27, 0x01, 0x77, 0x05, 0x61, 0xC4, 0xF4,
+0x5C, 0x9E, 0x01, 0x4A, 0xC4, 0xF4, 0x5C, 0xDE, 0x02, 0x77, 0x05, 0x61,
+0xE4, 0xF4, 0x40, 0x9E, 0x01, 0x4A, 0xE4, 0xF4, 0x40, 0xDE, 0x03, 0x77,
+0x05, 0x61, 0xE4, 0xF4, 0x44, 0x9E, 0x01, 0x4A, 0xE4, 0xF4, 0x44, 0xDE,
+0x04, 0x77, 0x05, 0x61, 0xE4, 0xF4, 0x48, 0x9E, 0x01, 0x4A, 0xE4, 0xF4,
+0x48, 0xDE, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30, 0xA8, 0x67,
+0x63, 0xF3, 0x00, 0x48, 0x09, 0xE5, 0xE4, 0xF4, 0x78, 0x9E, 0x00, 0xF5,
+0x44, 0xA2, 0xFF, 0x6D, 0x72, 0x33, 0xAC, 0xEA, 0x43, 0xEB, 0x4D, 0x61,
+0xE4, 0xF4, 0x4C, 0x9E, 0x08, 0x67, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x01, 0x4A, 0xE4, 0xF4, 0x4C, 0xDE, 0x08, 0x32, 0x63, 0xF3,
+0x00, 0x4B, 0x09, 0xE2, 0x69, 0xE2, 0xE9, 0xE2, 0xA0, 0xF3, 0x68, 0xA2,
+0xAC, 0xEB, 0xC4, 0xF4, 0x54, 0x9E, 0x69, 0xE2, 0xC4, 0xF4, 0x54, 0xDE,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x08, 0xF0, 0x54, 0x9B, 0x3F, 0xF7, 0x1E, 0x22, 0x05, 0x74, 0x3F, 0xF7,
+0x1B, 0x61, 0x46, 0xF7, 0x54, 0x9B, 0xC0, 0xF7, 0x42, 0x32, 0x3F, 0xF7,
+0x15, 0x22, 0x00, 0x6A, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30, 0x08, 0xF0, 0x54, 0xDB,
+0x9D, 0xF7, 0x1C, 0x4C, 0x63, 0xF3, 0x00, 0x48, 0x00, 0x1C, 0x13, 0x58,
+0x10, 0x49, 0x87, 0xF0, 0x54, 0x98, 0x43, 0xE9, 0x3F, 0xF7, 0x0A, 0x61,
+0x06, 0x97, 0x05, 0x91, 0x04, 0x90, 0x00, 0xEF, 0x04, 0x63, 0xC4, 0xF4,
+0x58, 0x9E, 0x01, 0x4A, 0xC4, 0xF4, 0x58, 0xDE, 0x86, 0x17, 0xE4, 0xF4,
+0x50, 0x9E, 0xA8, 0x67, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30,
+0x01, 0x4A, 0xE4, 0xF4, 0x50, 0xDE, 0xA8, 0x32, 0xA9, 0xE2, 0x63, 0xF3,
+0x00, 0x48, 0x09, 0xE2, 0xE9, 0xE2, 0x20, 0xF4, 0x79, 0xA2, 0xFF, 0x6A,
+0x4C, 0xEB, 0xB1, 0x17, 0xE0, 0x63, 0x00, 0x6A, 0x3E, 0x62, 0x3D, 0xD1,
+0x3C, 0xD0, 0xFC, 0x63, 0x1D, 0xD2, 0x62, 0x67, 0x1D, 0x94, 0x04, 0x05,
+0x07, 0x68, 0x94, 0x32, 0xA9, 0xE2, 0x1E, 0xD0, 0x60, 0xDA, 0x1E, 0x94,
+0x04, 0x4A, 0xFF, 0x4C, 0x00, 0x54, 0x1E, 0xD4, 0xF9, 0x60, 0x1D, 0x95,
+0x01, 0x4D, 0x03, 0x5D, 0x1D, 0xD5, 0xEE, 0x61, 0xC9, 0xF7, 0x1B, 0x6A,
+0x4B, 0xEA, 0x40, 0x31, 0x20, 0x31, 0xC0, 0xF2, 0x44, 0x41, 0x1D, 0xD3,
+0x60, 0xDA, 0x41, 0x99, 0x01, 0xF7, 0x00, 0x6B, 0x01, 0xF4, 0x84, 0x41,
+0x42, 0x32, 0x6C, 0xEA, 0x42, 0x32, 0x00, 0x1C, 0xFA, 0x5B, 0x33, 0xD2,
+0x01, 0xF4, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x31, 0xD2, 0x9D, 0x67,
+0x70, 0x4C, 0x00, 0x1C, 0x8A, 0x40, 0x32, 0xD2, 0x1D, 0x94, 0x10, 0x6D,
+0xA4, 0xED, 0x00, 0x1C, 0xAC, 0x45, 0xFF, 0x4D, 0x9D, 0x67, 0x70, 0x4C,
+0x00, 0x1C, 0x90, 0x40, 0x1F, 0xD2, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x00, 0x1C, 0xF0, 0x42, 0x01, 0x6C, 0x9D, 0x67, 0x00, 0x1C, 0x8A, 0x40,
+0x70, 0x4C, 0x1D, 0x94, 0x10, 0x6D, 0xA4, 0xED, 0x00, 0x1C, 0xAC, 0x45,
+0xFF, 0x4D, 0x9D, 0x67, 0x70, 0x4C, 0x00, 0x1C, 0x90, 0x40, 0x20, 0xD2,
+0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42, 0x1D, 0x94,
+0xE1, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xD1, 0xF6,
+0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x21, 0xD2, 0x71, 0xF6, 0x80, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x22, 0xD2, 0x71, 0xF6, 0x84, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x23, 0xD2, 0x71, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x24, 0xD2, 0x71, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x25, 0xD2,
+0x81, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x26, 0xD2, 0x81, 0xF6,
+0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x27, 0xD2, 0x81, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x28, 0xD2, 0x81, 0xF6, 0x8C, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x29, 0xD2, 0xD1, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x2A, 0xD2, 0xD1, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x2B, 0xD2,
+0xD1, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x2C, 0xD2, 0x2D, 0xD2,
+0xE7, 0xF7, 0x0E, 0x6A, 0x40, 0x32, 0x40, 0x32, 0xA2, 0x67, 0xE1, 0xF6,
+0x80, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x36, 0xD2,
+0x36, 0x95, 0xD1, 0xF6, 0x8C, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x71, 0xF6, 0x80, 0x41, 0xF2, 0xF2,
+0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x71, 0xF6,
+0x84, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x36, 0x95, 0x71, 0xF6, 0x88, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x71, 0xF6, 0x8C, 0x41, 0xF2, 0xF2,
+0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x81, 0xF6,
+0x80, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x36, 0x95, 0x81, 0xF6, 0x84, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x81, 0xF6, 0x88, 0x41, 0xF2, 0xF2,
+0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0x81, 0xF6,
+0x8C, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x36, 0x95, 0xD1, 0xF6, 0x80, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0xD1, 0xF6, 0x84, 0x41, 0xF2, 0xF2,
+0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x36, 0x95, 0xD1, 0xF6,
+0x88, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x33, 0x93, 0x01, 0x6A, 0x1D, 0x90, 0x4E, 0xEB, 0x43, 0xEB, 0x58, 0x67,
+0x39, 0xD2, 0x0F, 0xF7, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x10, 0xF0,
+0x00, 0x4A, 0x43, 0xD2, 0x00, 0xF5, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x1E, 0xD0, 0x37, 0xD2, 0x11, 0x67, 0x01, 0xF0, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x00, 0x6B, 0x40, 0x32, 0x1D, 0xD3, 0x38, 0xD2,
+0x33, 0x94, 0x60, 0xF1, 0x13, 0x24, 0x39, 0x95, 0xE0, 0xF1, 0x0C, 0x2D,
+0xA1, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x05, 0xF0,
+0x00, 0x6B, 0x6B, 0xEB, 0x60, 0x33, 0x60, 0x33, 0x4C, 0xEB, 0x01, 0x5B,
+0x58, 0x67, 0x91, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x35, 0xD2,
+0xE0, 0xF3, 0x1F, 0x6B, 0x60, 0x33, 0x60, 0x33, 0x6C, 0xEA, 0x42, 0x32,
+0x42, 0x32, 0xB1, 0xF6, 0x84, 0x40, 0x3D, 0xD3, 0x00, 0x1C, 0xFA, 0x5B,
+0x2E, 0xD2, 0x3D, 0x94, 0x8C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x91, 0xF6,
+0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x2F, 0xD2, 0x3D, 0x95, 0xB1, 0xF6,
+0x8C, 0x40, 0xAC, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x00, 0x1C, 0xFA, 0x5B,
+0x30, 0xD2, 0x3D, 0x93, 0x2E, 0x94, 0x4C, 0xEB, 0x62, 0x32, 0x20, 0xF1,
+0x00, 0x74, 0x42, 0x32, 0xA0, 0xF2, 0x15, 0x60, 0x2F, 0x95, 0x20, 0xF1,
+0x00, 0x75, 0xA0, 0xF2, 0x10, 0x60, 0x30, 0x93, 0x20, 0x73, 0xA0, 0xF2,
+0x0C, 0x60, 0x20, 0x72, 0x01, 0x6B, 0xA0, 0xF2, 0x08, 0x60, 0x2E, 0x94,
+0x80, 0x74, 0xA0, 0xF2, 0x02, 0x60, 0x2F, 0x95, 0x80, 0x75, 0x80, 0xF2,
+0x1E, 0x60, 0x30, 0x94, 0xE0, 0xF3, 0x00, 0x74, 0x80, 0xF2, 0x19, 0x60,
+0xE0, 0xF3, 0x00, 0x72, 0x01, 0x6A, 0x80, 0xF2, 0x14, 0x60, 0x35, 0x95,
+0x03, 0x25, 0x02, 0x23, 0x20, 0xF4, 0x19, 0x2A, 0x1D, 0x95, 0x01, 0x4D,
+0x0A, 0x5D, 0x1D, 0xD5, 0x97, 0x61, 0x1E, 0x92, 0x01, 0x4A, 0x03, 0x5A,
+0x1E, 0xD2, 0x8A, 0x61, 0x04, 0x90, 0x20, 0xF4, 0x09, 0x28, 0x0C, 0x91,
+0x03, 0x29, 0x14, 0x92, 0xFF, 0x6C, 0x2B, 0x22, 0x90, 0x67, 0x00, 0x18,
+0xA1, 0x5E, 0xB1, 0x67, 0x03, 0x5A, 0x07, 0x60, 0x05, 0x94, 0x00, 0x18,
+0xA1, 0x5E, 0x0D, 0x95, 0x03, 0x5A, 0x00, 0x6C, 0x1E, 0x61, 0x14, 0x93,
+0x90, 0x67, 0xA3, 0x67, 0x00, 0x18, 0xA1, 0x5E, 0x40, 0xD3, 0x03, 0x5A,
+0x07, 0x60, 0x05, 0x94, 0x00, 0x18, 0xA1, 0x5E, 0x15, 0x95, 0x03, 0x5A,
+0x00, 0x6C, 0x0F, 0x61, 0x40, 0x95, 0x00, 0x18, 0xA1, 0x5E, 0x91, 0x67,
+0x03, 0x5A, 0x40, 0xF2, 0x1E, 0x60, 0x0D, 0x94, 0x00, 0x18, 0xA1, 0x5E,
+0x15, 0x95, 0x03, 0x5A, 0x01, 0x6C, 0x40, 0xF2, 0x16, 0x60, 0xFF, 0x74,
+0x40, 0xF2, 0x17, 0x60, 0x04, 0x05, 0x94, 0x34, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0xB1, 0xE4, 0x63, 0xF3, 0x00, 0x49, 0x60, 0x9C,
+0x43, 0x99, 0x00, 0xF4, 0x00, 0x68, 0xE0, 0xF3, 0x1F, 0x6F, 0x0B, 0xE8,
+0xEC, 0xEB, 0x0C, 0xEA, 0x6D, 0xEA, 0x61, 0x9C, 0x02, 0xF0, 0x00, 0x6E,
+0xCB, 0xEE, 0xEC, 0xEB, 0xC0, 0x36, 0xE0, 0xF3, 0x1F, 0x4E, 0x60, 0x33,
+0x68, 0x33, 0xCC, 0xEA, 0xE7, 0xF7, 0x10, 0x6D, 0x6D, 0xEA, 0xAB, 0xED,
+0x62, 0x9C, 0xA0, 0x35, 0xA0, 0x35, 0xFF, 0x4D, 0xEC, 0xEB, 0x00, 0xF5,
+0x60, 0x33, 0xAC, 0xEA, 0x6D, 0xEA, 0x43, 0xD9, 0x63, 0x9C, 0x44, 0x99,
+0xEC, 0xEB, 0x0C, 0xEA, 0x6D, 0xEA, 0x64, 0x9C, 0xCC, 0xEA, 0xEC, 0xEB,
+0x60, 0x33, 0x68, 0x33, 0x6D, 0xEA, 0x65, 0x9C, 0xAC, 0xEA, 0xEC, 0xEB,
+0x00, 0xF5, 0x60, 0x33, 0x6D, 0xEA, 0x44, 0xD9, 0x46, 0x9C, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x4A, 0xC9,
+0x47, 0x9C, 0x4B, 0xC9, 0x44, 0x9B, 0x80, 0xF7, 0x42, 0x32, 0x01, 0x72,
+0xC0, 0xF2, 0x1E, 0x61, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x31,
+0x20, 0x31, 0xE1, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x21, 0x95,
+0xD1, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x22, 0x95, 0x71, 0xF6,
+0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x23, 0x95, 0x71, 0xF6, 0x84, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x24, 0x95, 0x71, 0xF6, 0x88, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x25, 0x95, 0x71, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x26, 0x95, 0x81, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x27, 0x95,
+0x81, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x28, 0x95, 0x81, 0xF6,
+0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x29, 0x95, 0x81, 0xF6, 0x8C, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x2A, 0x95, 0xD1, 0xF6, 0x80, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x2B, 0x95, 0xD1, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x2C, 0x95, 0x81, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x2D, 0x95,
+0x1F, 0x96, 0x10, 0x6D, 0xA4, 0xED, 0xFF, 0x4D, 0x00, 0x1C, 0x83, 0x45,
+0x00, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42,
+0x01, 0x6C, 0x20, 0x96, 0x10, 0x6D, 0xA4, 0xED, 0xFF, 0x4D, 0x00, 0x1C,
+0x83, 0x45, 0x00, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C,
+0xF0, 0x42, 0x00, 0x6C, 0x10, 0x6D, 0xA4, 0xED, 0x1E, 0x6C, 0x00, 0x1C,
+0xAC, 0x45, 0xFF, 0x4D, 0x01, 0x6E, 0x22, 0x67, 0x4D, 0xEE, 0x10, 0x6D,
+0x03, 0x6A, 0x4B, 0xEA, 0xA4, 0xED, 0x4C, 0xEE, 0xFF, 0x4D, 0x00, 0x1C,
+0x83, 0x45, 0x1E, 0x6C, 0x00, 0x1C, 0x2C, 0x1F, 0x03, 0x6C, 0x10, 0x6D,
+0x03, 0x6A, 0xD1, 0x67, 0xA4, 0xED, 0x1E, 0x6C, 0xFF, 0x4D, 0x00, 0x1C,
+0x83, 0x45, 0x4D, 0xEE, 0x04, 0x63, 0x3E, 0x97, 0x3D, 0x91, 0x3C, 0x90,
+0x00, 0xEF, 0x20, 0x63, 0xA0, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x01, 0xF4,
+0x84, 0x40, 0x2A, 0xF4, 0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x08, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x7F, 0x4D, 0x01, 0xF4, 0x88, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x65, 0x4D, 0x8F, 0xF7, 0x00, 0x6D, 0xAB, 0xED,
+0xA0, 0x35, 0x21, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0xA0, 0x35,
+0x00, 0xF2, 0x14, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x41, 0xF6, 0x80, 0x40,
+0x40, 0xF1, 0x08, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x0D, 0xF0,
+0x16, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x41, 0xF6, 0x84, 0x40, 0xA0, 0xF4,
+0x02, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x41, 0xF6, 0x8C, 0x40,
+0xC5, 0xF0, 0x11, 0x6D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0xF2,
+0x14, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x61, 0xF6, 0x80, 0x40, 0x40, 0xF1,
+0x0D, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x05, 0xF0, 0x16, 0x6D,
+0xA0, 0x35, 0xA0, 0x35, 0x61, 0xF6, 0x84, 0x40, 0xA1, 0xF0, 0x1A, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x61, 0xF6, 0x8C, 0x40, 0xC5, 0xF0,
+0x11, 0x6D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x37, 0x95, 0x41, 0xF6,
+0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x01, 0x4D, 0x38, 0x95, 0x41, 0xF6,
+0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x01, 0x4D, 0x00, 0x1C, 0x2C, 0x1F,
+0x03, 0x6C, 0xA0, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x01, 0xF4, 0x84, 0x40,
+0x2A, 0xF4, 0x13, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x01, 0xF4,
+0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0xE4, 0x6D, 0x21, 0xF6, 0x88, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x33, 0x95, 0x39, 0x95, 0x1F, 0xF6, 0x14, 0x25,
+0x21, 0xF0, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xFF, 0x6D,
+0x01, 0x4D, 0xAC, 0xEA, 0x42, 0x32, 0x34, 0xD2, 0x02, 0x22, 0x01, 0x6A,
+0x34, 0xD2, 0xA0, 0x35, 0xA0, 0x35, 0x21, 0xF0, 0x80, 0x41, 0x3A, 0xD5,
+0x00, 0xF1, 0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x3A, 0x95,
+0x21, 0xF0, 0x88, 0x41, 0x00, 0xF1, 0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xA0, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x01, 0xF4, 0x84, 0x41,
+0x2A, 0xF4, 0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x08, 0x6D,
+0xA0, 0x35, 0xA0, 0x35, 0x7F, 0x4D, 0x01, 0xF4, 0x88, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x65, 0x4D, 0x43, 0x93, 0x21, 0xF6, 0x88, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x60, 0x35, 0x3A, 0x95, 0x31, 0xF6, 0x80, 0x41, 0x0F, 0xF4,
+0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x3A, 0x95, 0x31, 0xF6,
+0x84, 0x41, 0x09, 0xF0, 0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x02, 0xF0, 0x01, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x31, 0xF6, 0x88, 0x41,
+0x3B, 0xD5, 0x1B, 0xF4, 0x1F, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x3B, 0x95, 0x31, 0xF6, 0x8C, 0x41, 0x11, 0xF4, 0x1F, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x00, 0xF2, 0x14, 0x6D, 0xA0, 0x35, 0xA0, 0x35,
+0x41, 0xF6, 0x80, 0x41, 0x00, 0xF1, 0x02, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x0D, 0xF0, 0x16, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x41, 0xF6,
+0x84, 0x41, 0xC0, 0xF4, 0x07, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x41, 0xF6, 0x8C, 0x41, 0xC5, 0xF0, 0x11, 0x6D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x61, 0xF6, 0x8C, 0x41, 0xC5, 0xF0, 0x11, 0x6D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x3A, 0x95, 0x51, 0xF6, 0x80, 0x41, 0x0F, 0xF4,
+0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x3A, 0x95, 0x51, 0xF6,
+0x84, 0x41, 0x09, 0xF0, 0x00, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x3B, 0x95, 0x51, 0xF6, 0x88, 0x41, 0x3B, 0xF4, 0x03, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x3B, 0x95, 0x51, 0xF6, 0x8C, 0x41, 0x31, 0xF4,
+0x03, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0xF2, 0x14, 0x6D,
+0xA0, 0x35, 0xA0, 0x35, 0x61, 0xF6, 0x80, 0x41, 0x00, 0xF1, 0x02, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x05, 0xF0, 0x16, 0x6D, 0xA0, 0x35,
+0xA0, 0x35, 0x61, 0xF6, 0x84, 0x41, 0x01, 0xF5, 0x07, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x41, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x37, 0x95, 0x41, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x38, 0x95,
+0x00, 0x1C, 0x2C, 0x1F, 0x03, 0x6C, 0x00, 0xF2, 0x00, 0x6A, 0x40, 0x32,
+0x40, 0x32, 0xA2, 0x67, 0x41, 0xF6, 0x8C, 0x41, 0xC5, 0xF0, 0x11, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x3C, 0xD2, 0x3C, 0x95, 0x61, 0xF6, 0x8C, 0x41,
+0xC5, 0xF0, 0x11, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x41, 0xF6,
+0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x37, 0x95, 0x41, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x38, 0x95, 0x00, 0x1C, 0x2C, 0x1F, 0x03, 0x6C,
+0x01, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x31, 0x95, 0x01, 0xF4,
+0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x32, 0x95, 0x21, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x6D, 0x34, 0x93, 0x1F, 0xF5, 0x1E, 0x2B,
+0x21, 0xF0, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x3A, 0x95, 0x21, 0xF0,
+0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x3A, 0x95, 0x13, 0x15, 0x00, 0x6A,
+0x6A, 0x15, 0x00, 0x6B, 0x56, 0x15, 0xFF, 0x6C, 0xFF, 0x74, 0xBF, 0xF5,
+0x09, 0x61, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34,
+0x41, 0xD4, 0x81, 0xF6, 0x14, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0xE0, 0xF3, 0x1F, 0x6B, 0x60, 0x31, 0x20, 0x31, 0x2C, 0xEA, 0x42, 0x32,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x63, 0xF3, 0x00, 0x4C,
+0x42, 0x32, 0x6C, 0xEA, 0x63, 0x9C, 0x00, 0xF4, 0x00, 0x6D, 0xAB, 0xED,
+0xAC, 0xEB, 0x4D, 0xEB, 0x63, 0xDC, 0x41, 0x94, 0xE0, 0xF3, 0x1F, 0x68,
+0x81, 0xF6, 0x1C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x2C, 0xEA,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x10, 0x6D, 0x63, 0xF3,
+0x00, 0x4C, 0x42, 0x32, 0xAB, 0xED, 0x63, 0x9C, 0x42, 0x32, 0xA0, 0x35,
+0x0C, 0xEA, 0xA0, 0x35, 0xE0, 0xF3, 0x1F, 0x4D, 0x40, 0x32, 0xAC, 0xEB,
+0x48, 0x32, 0x4D, 0xEB, 0x63, 0xDC, 0x41, 0x94, 0xA1, 0xF6, 0x04, 0x4C,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x2C, 0xEA, 0x42, 0x32, 0x42, 0x32,
+0x0C, 0xEA, 0xE7, 0xF7, 0x10, 0x6C, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4,
+0x00, 0x30, 0x63, 0xF3, 0x00, 0x48, 0x8B, 0xEC, 0x63, 0x98, 0x80, 0x34,
+0x80, 0x34, 0xFF, 0x4C, 0x00, 0xF5, 0x40, 0x32, 0x8C, 0xEB, 0x4D, 0xEB,
+0x63, 0xD8, 0x41, 0x94, 0xA1, 0xF6, 0x0C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x2C, 0xEA, 0x64, 0x98, 0x42, 0x32, 0x00, 0xF4, 0x00, 0x68,
+0xE0, 0xF3, 0x1F, 0x6D, 0x0B, 0xE8, 0x42, 0x32, 0xAC, 0xEA, 0x0C, 0xEB,
+0x4D, 0xEB, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3,
+0x00, 0x4A, 0x64, 0xDA, 0x41, 0x94, 0xE0, 0xF3, 0x1F, 0x68, 0xA1, 0xF6,
+0x14, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x2C, 0xEA, 0x42, 0x32,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x10, 0x6D, 0x63, 0xF3,
+0x00, 0x4C, 0xE0, 0xF3, 0x1F, 0x6B, 0x42, 0x32, 0xAB, 0xED, 0x6C, 0xEA,
+0xA0, 0x35, 0x64, 0x9C, 0xA0, 0x35, 0xE0, 0xF3, 0x1F, 0x4D, 0x40, 0x32,
+0xAC, 0xEB, 0x48, 0x32, 0x4D, 0xEB, 0x64, 0xDC, 0x41, 0x94, 0xA1, 0xF6,
+0x1C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0xE7, 0xF7, 0x10, 0x6D, 0x63, 0xF3, 0x00, 0x4C,
+0x2C, 0xEA, 0xAB, 0xED, 0x64, 0x9C, 0x42, 0x32, 0xA0, 0x35, 0x42, 0x32,
+0xA0, 0x35, 0xFF, 0x4D, 0x0C, 0xEA, 0xAC, 0xEB, 0x00, 0xF5, 0x40, 0x32,
+0x4D, 0xEB, 0x64, 0xDC, 0x41, 0x94, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4,
+0x00, 0x30, 0x63, 0xF3, 0x00, 0x48, 0xC1, 0xF6, 0x04, 0x4C, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x2C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x4A, 0xC8,
+0x41, 0x94, 0xC1, 0xF6, 0x0C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x4C, 0xE9, 0x22, 0x32, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x42, 0x32, 0x63, 0xF3, 0x00, 0x4B, 0x4B, 0xC8, 0x44, 0x9B, 0x80, 0xF7,
+0x42, 0x32, 0x01, 0x72, 0x3F, 0xF5, 0x02, 0x60, 0xC9, 0xF7, 0x1B, 0x6A,
+0x4B, 0xEA, 0x40, 0x31, 0x20, 0x31, 0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x82, 0x67, 0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4,
+0x00, 0x30, 0x40, 0x6A, 0x4B, 0xEA, 0x63, 0xF3, 0x00, 0x48, 0x40, 0x32,
+0xC3, 0x98, 0x40, 0x32, 0x8C, 0xEA, 0xE0, 0xF3, 0x1F, 0x6B, 0x80, 0xF5,
+0x42, 0x35, 0xCC, 0xEB, 0x00, 0xF2, 0x00, 0x6A, 0x6C, 0xEA, 0x04, 0x22,
+0x00, 0xF4, 0x00, 0x6A, 0x4B, 0xEA, 0x4D, 0xEB, 0xB8, 0xEB, 0xE0, 0xF3,
+0x1F, 0x68, 0x12, 0xEA, 0x42, 0x33, 0x0C, 0xEB, 0xC2, 0x30, 0xE0, 0xF3,
+0x1F, 0x6A, 0x0A, 0x30, 0x4C, 0xE8, 0x00, 0xF2, 0x00, 0x6A, 0x0C, 0xEA,
+0x04, 0x22, 0x00, 0xF4, 0x00, 0x6A, 0x4B, 0xEA, 0x4D, 0xE8, 0xB8, 0xE8,
+0xE0, 0xF3, 0x1F, 0x6D, 0x12, 0xEA, 0x42, 0x30, 0x3F, 0x6A, 0x4B, 0xEA,
+0xAC, 0xE8, 0x40, 0x32, 0x3F, 0x6D, 0x42, 0xD5, 0x40, 0x32, 0x0C, 0xED,
+0x1F, 0xF4, 0x00, 0x4A, 0xA0, 0x35, 0x4C, 0xEC, 0xA0, 0x35, 0x8D, 0xED,
+0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x6D, 0xED, 0x91, 0xF4,
+0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x02, 0xF0, 0x00, 0x6B,
+0x60, 0x33, 0x60, 0x33, 0xFF, 0x4B, 0xC0, 0xF3, 0x00, 0x6C, 0x6C, 0xEA,
+0x8C, 0xE8, 0x80, 0xF5, 0x00, 0x33, 0xA2, 0x67, 0x91, 0xF4, 0x84, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x6D, 0xED, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0xBD, 0xF7, 0x10, 0x4D, 0x82, 0x67, 0x40, 0x9D, 0x8C, 0xEA, 0x80, 0xF5,
+0x42, 0x35, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3,
+0x00, 0x4A, 0x04, 0x9A, 0xE0, 0xF3, 0x1F, 0x6A, 0x02, 0x33, 0x6A, 0x33,
+0x4C, 0xEB, 0x00, 0xF2, 0x00, 0x6A, 0x6C, 0xEA, 0x04, 0x22, 0x00, 0xF4,
+0x00, 0x6A, 0x4B, 0xEA, 0x4D, 0xEB, 0xB8, 0xEB, 0x00, 0xF5, 0x02, 0x30,
+0x12, 0xEA, 0x42, 0x33, 0xE0, 0xF3, 0x1F, 0x6A, 0x4C, 0xE8, 0x4C, 0xEB,
+0x00, 0xF2, 0x00, 0x6A, 0x0C, 0xEA, 0x04, 0x22, 0x00, 0xF4, 0x00, 0x6A,
+0x4B, 0xEA, 0x4D, 0xE8, 0xB8, 0xE8, 0xE0, 0xF3, 0x1F, 0x6D, 0x12, 0xEA,
+0x42, 0x30, 0xAC, 0xE8, 0x3F, 0x6A, 0x42, 0x95, 0x4B, 0xEA, 0x40, 0x32,
+0x0C, 0xED, 0x40, 0x32, 0x1F, 0xF4, 0x00, 0x4A, 0x42, 0xD5, 0xA0, 0x35,
+0x4C, 0xEC, 0xA0, 0x35, 0x8D, 0xED, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x6D, 0xED, 0x91, 0xF4, 0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xBD, 0xF7,
+0x14, 0x4B, 0xA0, 0x9B, 0xC0, 0xF3, 0x00, 0x6C, 0x8C, 0xE8, 0x4C, 0xED,
+0x80, 0xF5, 0x00, 0x32, 0x91, 0xF4, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x4D, 0xED, 0x58, 0x14, 0x0C, 0x91, 0xDF, 0xF3, 0x19, 0x10, 0x1E, 0x93,
+0x04, 0x04, 0x74, 0x32, 0x91, 0xE2, 0x3E, 0xD4, 0x91, 0xF6, 0x84, 0x40,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3, 0x1F, 0x6B, 0x60, 0x33,
+0x60, 0x33, 0x3E, 0x95, 0x6C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x3F, 0xD3,
+0x91, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x40, 0xDD, 0x3F, 0x93,
+0x3E, 0x94, 0x6C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x41, 0xDC, 0xA1, 0xF6,
+0x84, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x3F, 0x95, 0x3E, 0x93,
+0xA1, 0xF6, 0x8C, 0x40, 0xAC, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x00, 0x1C,
+0xFA, 0x5B, 0x42, 0xDB, 0x3F, 0x94, 0x3E, 0x95, 0x8C, 0xEA, 0x42, 0x32,
+0x42, 0x32, 0xB1, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x43, 0xDD,
+0x3F, 0x93, 0x3E, 0x94, 0x6C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x44, 0xDC,
+0xB1, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x3F, 0x95,
+0x3E, 0x93, 0xC1, 0xF6, 0x84, 0x40, 0xAC, 0xEA, 0x42, 0x32, 0x42, 0x32,
+0x00, 0x1C, 0xFA, 0x5B, 0x45, 0xDB, 0x3F, 0x94, 0x3E, 0x95, 0x8C, 0xEA,
+0x42, 0x32, 0x42, 0x32, 0xC1, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B,
+0x46, 0xDD, 0x3F, 0x93, 0x3E, 0x94, 0x4C, 0xEB, 0x62, 0x32, 0x42, 0x32,
+0x47, 0xDC, 0x7F, 0xF3, 0x0E, 0x10, 0x00, 0x00, 0xFB, 0x63, 0x07, 0xD1,
+0x0C, 0xF0, 0x00, 0x6A, 0x10, 0xF0, 0x02, 0x69, 0x00, 0xF4, 0x20, 0x31,
+0x63, 0xF3, 0x00, 0x49, 0x08, 0x62, 0x0A, 0xD4, 0x06, 0xD0, 0x4B, 0xEA,
+0x62, 0x99, 0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0xC9, 0xF7,
+0x1B, 0x6C, 0x04, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x8B, 0xEC, 0x40, 0x32,
+0x80, 0x34, 0x4D, 0xEB, 0x80, 0x34, 0x62, 0xD9, 0x04, 0xD4, 0x81, 0xF6,
+0x14, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3, 0x1F, 0x6B,
+0x60, 0x30, 0x00, 0x30, 0x0C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x6C, 0xEA,
+0x63, 0x99, 0x00, 0xF4, 0x00, 0x6C, 0x8B, 0xEC, 0x8C, 0xEB, 0x4D, 0xEB,
+0x63, 0xD9, 0x04, 0x94, 0x81, 0xF6, 0x1C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0x10, 0x6C, 0xE0, 0xF3, 0x1F, 0x6B,
+0x42, 0x32, 0x8B, 0xEC, 0x6C, 0xEA, 0x80, 0x34, 0x63, 0x99, 0x80, 0x34,
+0xE0, 0xF3, 0x1F, 0x4C, 0x40, 0x32, 0x48, 0x32, 0x8C, 0xEB, 0x4D, 0xEB,
+0x63, 0xD9, 0x04, 0x94, 0xA1, 0xF6, 0x04, 0x4C, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0xE7, 0xF7, 0x10, 0x6C, 0xE0, 0xF3,
+0x1F, 0x6B, 0x42, 0x32, 0x8B, 0xEC, 0x6C, 0xEA, 0x80, 0x34, 0x63, 0x99,
+0x80, 0x34, 0xFF, 0x4C, 0x00, 0xF5, 0x40, 0x32, 0x8C, 0xEB, 0x4D, 0xEB,
+0x63, 0xD9, 0x04, 0x94, 0xA1, 0xF6, 0x0C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0xE0, 0xF3, 0x1F, 0x6B, 0x42, 0x32,
+0x6C, 0xEA, 0x64, 0x99, 0x00, 0xF4, 0x00, 0x6C, 0x8B, 0xEC, 0x8C, 0xEB,
+0x4D, 0xEB, 0x64, 0xD9, 0x04, 0x94, 0xA1, 0xF6, 0x14, 0x4C, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0x10, 0x6C, 0xE0, 0xF3,
+0x1F, 0x6B, 0x42, 0x32, 0x8B, 0xEC, 0x6C, 0xEA, 0x80, 0x34, 0x64, 0x99,
+0x80, 0x34, 0xE0, 0xF3, 0x1F, 0x4C, 0x40, 0x32, 0x48, 0x32, 0x8C, 0xEB,
+0x4D, 0xEB, 0x64, 0xD9, 0x04, 0x94, 0xA1, 0xF6, 0x1C, 0x4C, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0xE7, 0xF7, 0x10, 0x6C,
+0xE0, 0xF3, 0x1F, 0x6B, 0x42, 0x32, 0x8B, 0xEC, 0x6C, 0xEA, 0x80, 0x34,
+0x64, 0x99, 0x80, 0x34, 0xFF, 0x4C, 0x00, 0xF5, 0x40, 0x32, 0x8C, 0xEB,
+0x4D, 0xEB, 0x64, 0xD9, 0x04, 0x94, 0xC1, 0xF6, 0x04, 0x4C, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x0C, 0xEA, 0x42, 0x32, 0x42, 0x32, 0x4A, 0xC9,
+0x04, 0x94, 0xC1, 0xF6, 0x0C, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x4C, 0xE8, 0xFF, 0x6A, 0x01, 0x4A, 0x40, 0x32, 0x40, 0x32, 0x0A, 0x93,
+0x80, 0x4A, 0x02, 0x30, 0x80, 0x4A, 0x02, 0x30, 0x6C, 0xEA, 0x0B, 0xC9,
+0x14, 0x22, 0x1F, 0xF7, 0x00, 0x6A, 0x0A, 0x94, 0x4C, 0xEB, 0x62, 0x33,
+0xC0, 0xF2, 0x63, 0xC1, 0x82, 0x33, 0x4C, 0xEB, 0x62, 0x33, 0xC0, 0xF2,
+0x67, 0xC1, 0x00, 0x18, 0x0A, 0x5F, 0x00, 0x65, 0x08, 0x97, 0x07, 0x91,
+0x06, 0x90, 0x00, 0xEF, 0x05, 0x63, 0x12, 0x6A, 0xC0, 0xF2, 0x43, 0xC1,
+0xC0, 0xF2, 0x47, 0xC1, 0x00, 0x18, 0x0A, 0x5F, 0x00, 0x65, 0x08, 0x97,
+0x07, 0x91, 0x06, 0x90, 0x00, 0xEF, 0x05, 0x63, 0xC9, 0xF7, 0x1B, 0x6A,
+0xFB, 0x63, 0x4B, 0xEA, 0x06, 0xD0, 0x40, 0x30, 0x07, 0xD1, 0x08, 0x62,
+0x00, 0x30, 0x40, 0xF0, 0x4C, 0xA0, 0x03, 0x69, 0x4C, 0xE9, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x62, 0x67, 0x04, 0xD2, 0x63, 0xF3,
+0x00, 0x4B, 0xC3, 0xF3, 0x41, 0xA3, 0x2E, 0xEA, 0x1A, 0x22, 0x05, 0x29,
+0xE0, 0xF2, 0x66, 0xA3, 0xFF, 0x6A, 0x4C, 0xEB, 0x1A, 0x23, 0x04, 0x92,
+0xC9, 0xF7, 0x17, 0x6C, 0x8B, 0xEC, 0x63, 0xF3, 0x00, 0x4A, 0x04, 0xD2,
+0xC3, 0xF3, 0x21, 0xC2, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x76, 0x9A, 0x80, 0x34, 0x80, 0x34, 0x60, 0xDC, 0x57, 0x9A,
+0x41, 0xDC, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x00, 0x6A, 0x00, 0xEF,
+0x05, 0x63, 0x51, 0xF4, 0x80, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x1C, 0x6D,
+0x51, 0xF4, 0x88, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x1C, 0x6D, 0xDB, 0x17,
+0xF9, 0x63, 0x0A, 0xD0, 0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8, 0x00, 0x30,
+0x00, 0x30, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x0B, 0xD1,
+0xA1, 0xF5, 0x82, 0x40, 0x22, 0x67, 0x63, 0xF3, 0x00, 0x49, 0x0C, 0x62,
+0x00, 0x1C, 0xFD, 0x5B, 0x06, 0xD2, 0xC0, 0xF2, 0x58, 0xC9, 0xA1, 0xF5,
+0x84, 0x40, 0x00, 0x1C, 0xFD, 0x5B, 0x00, 0x65, 0xC0, 0xF2, 0x5A, 0xC9,
+0xA1, 0xF5, 0x86, 0x40, 0x00, 0x1C, 0xFD, 0x5B, 0x00, 0x65, 0xC0, 0xF2,
+0x5C, 0xC9, 0xA1, 0xF5, 0x88, 0x40, 0x00, 0x1C, 0xFD, 0x5B, 0x00, 0x65,
+0x82, 0x67, 0xC0, 0xF2, 0x7A, 0xA9, 0xC0, 0xF2, 0x5E, 0xC9, 0xC0, 0xF2,
+0x58, 0xA9, 0x69, 0xE2, 0xC0, 0xF2, 0x7C, 0xA9, 0x69, 0xE2, 0x51, 0xE4,
+0x04, 0xD4, 0x21, 0xF2, 0x8D, 0x40, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65,
+0x00, 0xF6, 0x40, 0x35, 0x00, 0xF6, 0xA3, 0x35, 0x40, 0x6A, 0xFF, 0x6B,
+0x4D, 0xED, 0x6C, 0xED, 0x21, 0xF2, 0x8D, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0x05, 0xD3, 0x51, 0xF2, 0x8B, 0x40, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65,
+0x40, 0x32, 0x51, 0xF2, 0x8C, 0x40, 0xE0, 0xF2, 0x44, 0xC9, 0x00, 0x1C,
+0x00, 0x5C, 0x00, 0x65, 0xE0, 0xF2, 0x64, 0xA9, 0x61, 0xF4, 0x84, 0x40,
+0x75, 0xE2, 0x04, 0x93, 0xFF, 0xF7, 0x1F, 0x6A, 0xE0, 0xF2, 0xA4, 0xC9,
+0x4C, 0xED, 0x69, 0xE5, 0xE0, 0xF2, 0x40, 0xD9, 0xFF, 0xF7, 0x1F, 0x6A,
+0x00, 0x1C, 0xE6, 0x5B, 0x4C, 0xED, 0x43, 0xA9, 0xFF, 0xF7, 0x1F, 0x6B,
+0x6C, 0xEA, 0x10, 0x52, 0x05, 0x60, 0xE0, 0xF2, 0x40, 0x99, 0x1F, 0x5A,
+0xA0, 0xF0, 0x1E, 0x61, 0x00, 0x6A, 0xC0, 0xF2, 0x54, 0xC1, 0xC0, 0xF2,
+0x55, 0xA1, 0x05, 0x93, 0x01, 0x4A, 0x4C, 0xEB, 0x03, 0x53, 0xA0, 0xF0,
+0x0B, 0x60, 0xC0, 0xF2, 0x55, 0xC1, 0x06, 0x94, 0x00, 0x6A, 0x11, 0x6B,
+0x63, 0xF3, 0x00, 0x4C, 0x43, 0xCC, 0xE0, 0xF2, 0x44, 0xCC, 0x40, 0x9C,
+0x6C, 0xEA, 0x01, 0x72, 0x80, 0xF0, 0x13, 0x61, 0xE0, 0xF2, 0x44, 0x9C,
+0x03, 0x6B, 0x00, 0xF7, 0x42, 0x32, 0x6C, 0xEA, 0x80, 0xF0, 0x0B, 0x2A,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x40, 0xF0,
+0x4C, 0xA2, 0x4C, 0xEB, 0x01, 0x73, 0xA0, 0xF0, 0x04, 0x60, 0x06, 0x94,
+0x63, 0xF3, 0x00, 0x4C, 0xE0, 0xF2, 0x46, 0xA4, 0xA0, 0xF0, 0x0B, 0x2A,
+0x40, 0x9C, 0x01, 0x6B, 0x56, 0x32, 0x6C, 0xEA, 0xA0, 0xF0, 0x05, 0x22,
+0x3E, 0x6A, 0xC0, 0xF2, 0x50, 0xC4, 0x1C, 0x6A, 0xC0, 0xF2, 0x51, 0xC4,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x40, 0xF0,
+0x6C, 0xA2, 0xFF, 0x6A, 0x6C, 0xEA, 0x03, 0x6B, 0x6C, 0xEA, 0x61, 0x22,
+0x66, 0xF7, 0x4C, 0x9C, 0xFF, 0xF7, 0x1F, 0x72, 0x5C, 0x60, 0xE0, 0xF2,
+0x40, 0x9C, 0xE0, 0xF3, 0x09, 0x5A, 0x00, 0xF1, 0x03, 0x61, 0xC0, 0xF2,
+0x72, 0xA4, 0x00, 0xF6, 0x60, 0x32, 0x00, 0xF6, 0x43, 0x32, 0xFE, 0x4A,
+0xFF, 0xF7, 0x1C, 0x52, 0x04, 0x6A, 0x4B, 0xEA, 0x01, 0x61, 0x4E, 0x43,
+0xC0, 0xF2, 0x52, 0xC4, 0x06, 0x96, 0x7F, 0x6B, 0x63, 0xF3, 0x00, 0x4E,
+0x66, 0xF7, 0x4C, 0x9E, 0xC0, 0xF2, 0x8E, 0xA6, 0x52, 0x32, 0x6C, 0xEA,
+0xA7, 0x42, 0xC0, 0xF2, 0x52, 0xA6, 0x03, 0x4D, 0xFF, 0x6B, 0x4B, 0xE5,
+0x00, 0xF6, 0x40, 0x35, 0x43, 0x67, 0x00, 0xF6, 0xA3, 0x35, 0x8C, 0xEA,
+0xA2, 0xEA, 0xE0, 0xF0, 0x0C, 0x60, 0x00, 0xF6, 0x80, 0x35, 0x00, 0xF6,
+0xA3, 0x35, 0x06, 0x92, 0x63, 0xF3, 0x00, 0x4A, 0x06, 0xD2, 0xE0, 0xF2,
+0x40, 0x9A, 0x04, 0xF7, 0x11, 0x5A, 0xC0, 0xF0, 0x01, 0x61, 0x32, 0x55,
+0xA0, 0xF0, 0x1E, 0x60, 0x32, 0x6D, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA,
+0x40, 0x32, 0x40, 0x32, 0x21, 0xF4, 0x10, 0x4A, 0x44, 0x6B, 0xC9, 0xF7,
+0x1B, 0x68, 0x0B, 0xE8, 0x60, 0xC2, 0x00, 0x30, 0xFF, 0x6A, 0xAC, 0xEA,
+0x00, 0x30, 0xA2, 0x67, 0x51, 0xF4, 0x80, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0x08, 0xD2, 0x08, 0x92, 0x51, 0xF4, 0x88, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0xA2, 0x67, 0x00, 0x18, 0x08, 0x61, 0x00, 0x65, 0x0C, 0x97, 0x0B, 0x91,
+0x0A, 0x90, 0x00, 0x6A, 0x00, 0xEF, 0x07, 0x63, 0x03, 0x6A, 0xC0, 0xF2,
+0x55, 0xC1, 0x40, 0x99, 0x08, 0x6B, 0x6D, 0xEA, 0x40, 0xD9, 0x4F, 0x17,
+0x00, 0x6A, 0xC0, 0xF2, 0x55, 0xC1, 0xC0, 0xF2, 0x54, 0xA1, 0x05, 0x93,
+0x01, 0x4A, 0x4C, 0xEB, 0x03, 0x53, 0x14, 0x61, 0x03, 0x6A, 0xC0, 0xF2,
+0x54, 0xC1, 0x40, 0x99, 0x09, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA, 0x40, 0xD9,
+0x3C, 0x17, 0xE0, 0xF2, 0x66, 0xA4, 0xFF, 0x6A, 0x4C, 0xEB, 0x5F, 0xF7,
+0x16, 0x2B, 0x01, 0x6A, 0x4B, 0xEA, 0xE0, 0xF2, 0x46, 0xC4, 0x51, 0x17,
+0xC0, 0xF2, 0x54, 0xC1, 0x2E, 0x17, 0x06, 0x90, 0xFF, 0x6D, 0x63, 0xF3,
+0x00, 0x48, 0xE0, 0xF2, 0x46, 0xA0, 0xAA, 0xEA, 0xC6, 0x61, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x41, 0xF4, 0x10, 0x4C,
+0x00, 0x1C, 0x00, 0x5C, 0x09, 0xD5, 0x09, 0x95, 0x00, 0xF6, 0x40, 0x31,
+0x00, 0xF6, 0x23, 0x31, 0x7F, 0x6A, 0xAC, 0xE9, 0x4C, 0xE9, 0xE0, 0xF2,
+0x60, 0x98, 0xC0, 0xF2, 0x48, 0xA8, 0xFF, 0xF7, 0x1F, 0x6C, 0x43, 0xEB,
+0x38, 0x61, 0xC0, 0xF2, 0x4A, 0xA8, 0x8C, 0xEA, 0x43, 0xEB, 0x07, 0x61,
+0xC0, 0xF2, 0x4C, 0xA8, 0x8C, 0xEA, 0x43, 0xEB, 0x69, 0x60, 0x01, 0x49,
+0xAC, 0xE9, 0x06, 0x93, 0x63, 0xF3, 0x00, 0x4B, 0xC0, 0xF2, 0x50, 0xA3,
+0x23, 0xEA, 0x32, 0x60, 0x22, 0x67, 0x06, 0x93, 0x63, 0xF3, 0x00, 0x4B,
+0x06, 0xD3, 0xE0, 0xF2, 0x40, 0x9B, 0x04, 0xF7, 0x11, 0x5A, 0x1D, 0x61,
+0x32, 0x69, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x21, 0xF4, 0x10, 0x4A, 0x44, 0x6B, 0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8,
+0x00, 0x30, 0x00, 0x30, 0x51, 0xF4, 0x80, 0x40, 0xB1, 0x67, 0x60, 0xC2,
+0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0x51, 0xF4, 0x88, 0x40, 0x00, 0x1C,
+0xF0, 0x5B, 0xB1, 0x67, 0x74, 0x17, 0xFF, 0x49, 0xD1, 0x17, 0x3A, 0x59,
+0xE2, 0x61, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x21, 0xF4, 0x10, 0x4A, 0x48, 0x6B, 0xE1, 0x17, 0xC0, 0xF2, 0x71, 0xA3,
+0xFF, 0x6A, 0x4C, 0xEB, 0x63, 0xE9, 0xC9, 0x60, 0x23, 0x67, 0xC7, 0x17,
+0x3A, 0x55, 0x5F, 0xF7, 0x00, 0x61, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA,
+0x40, 0x32, 0x40, 0x32, 0x21, 0xF4, 0x10, 0x4A, 0x48, 0x6B, 0x3F, 0x17,
+0x80, 0xF1, 0x10, 0x5A, 0x1F, 0xF7, 0x08, 0x60, 0xC0, 0xF2, 0x72, 0xA4,
+0x00, 0xF6, 0x60, 0x32, 0x00, 0xF6, 0x43, 0x32, 0x02, 0x4A, 0x0D, 0x52,
+0x0C, 0x6A, 0xFF, 0xF6, 0x1B, 0x60, 0x42, 0x43, 0xF9, 0x16, 0xC0, 0xF2,
+0x4F, 0xA6, 0x4C, 0xEB, 0x62, 0xED, 0x1F, 0xF7, 0x12, 0x60, 0x00, 0xF6,
+0x40, 0x35, 0x0D, 0x17, 0x02, 0x49, 0x96, 0x17, 0xFB, 0x63, 0x06, 0xD0,
+0x02, 0xF0, 0x00, 0x68, 0x00, 0x30, 0xAF, 0x40, 0xFF, 0xF0, 0x10, 0x6E,
+0x15, 0x6C, 0x08, 0x62, 0x00, 0x1C, 0x83, 0x45, 0x07, 0xD1, 0x00, 0x1C,
+0x5B, 0x1F, 0x64, 0x6C, 0x1A, 0x6C, 0x46, 0xF0, 0x16, 0x6E, 0x00, 0x1C,
+0x83, 0x45, 0xAF, 0x40, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x04, 0xD2, 0x63, 0xF3, 0x40, 0x9A,
+0x01, 0x6B, 0x4E, 0x32, 0x6C, 0xEA, 0x0A, 0x22, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0x47, 0xA3,
+0x01, 0x72, 0x1C, 0x61, 0x04, 0x92, 0x63, 0xF3, 0x20, 0x9A, 0x01, 0x6A,
+0x2E, 0x31, 0x4C, 0xE9, 0x09, 0x29, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0x47, 0xA3, 0x5A, 0x2A,
+0x04, 0x93, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x63, 0xF3, 0x00, 0x4B,
+0x04, 0xD3, 0x04, 0x6A, 0x00, 0xF3, 0x44, 0xC3, 0x00, 0xEF, 0x05, 0x63,
+0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x31, 0x24, 0xF2, 0x02, 0x68,
+0x20, 0x31, 0x00, 0x30, 0x01, 0xF6, 0x88, 0x41, 0x24, 0xF2, 0x02, 0x6D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x30, 0x01, 0xF6, 0x80, 0x41, 0x24, 0xF2,
+0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x01, 0xF6, 0x84, 0x41,
+0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x11, 0xF6,
+0x80, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x11, 0xF6, 0x84, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x11, 0xF6, 0x88, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x11, 0xF6, 0x8C, 0x41, 0x24, 0xF2, 0xA2, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x01, 0x6B, 0x63, 0xF3, 0x00, 0x4A, 0x00, 0xF3, 0x67, 0xC2,
+0x04, 0x93, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x63, 0xF3, 0x00, 0x4B,
+0x04, 0xD3, 0x04, 0x6A, 0x00, 0xF3, 0x44, 0xC3, 0x00, 0xEF, 0x05, 0x63,
+0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8, 0x00, 0xF3, 0xB4, 0x9B, 0x00, 0x30,
+0x00, 0x30, 0x01, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A,
+0x00, 0xF3, 0xB4, 0x9A, 0x01, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0x00, 0xF3, 0xB8, 0x9B, 0x01, 0xF6, 0x88, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0x00, 0xF3, 0xB4, 0x9A, 0x11, 0xF6, 0x80, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0xB4, 0x9B, 0x11, 0xF6,
+0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x00, 0xF3, 0xB4, 0x9A,
+0x11, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3,
+0xB4, 0x9B, 0x11, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A,
+0x00, 0xF3, 0x27, 0xC2, 0x04, 0x93, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90,
+0x63, 0xF3, 0x00, 0x4B, 0x04, 0xD3, 0x04, 0x6A, 0x00, 0xF3, 0x44, 0xC3,
+0x00, 0xEF, 0x05, 0x63, 0xFB, 0x63, 0x06, 0xD0, 0x02, 0xF0, 0x00, 0x68,
+0x00, 0x30, 0xAF, 0x40, 0xFF, 0xF0, 0x10, 0x6E, 0x15, 0x6C, 0x08, 0x62,
+0x00, 0x1C, 0x83, 0x45, 0x07, 0xD1, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x1A, 0x6C, 0x46, 0xF0, 0x16, 0x6E, 0x00, 0x1C, 0x83, 0x45, 0xAF, 0x40,
+0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x05, 0xD2, 0x63, 0xF3, 0x40, 0x9A, 0x01, 0x6B, 0x4E, 0x32,
+0x6C, 0xEA, 0x0A, 0x22, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0x47, 0xA3, 0x01, 0x72, 0x1D, 0x61,
+0x05, 0x92, 0x63, 0xF3, 0x20, 0x9A, 0x01, 0x6A, 0x2E, 0x31, 0x4C, 0xE9,
+0x09, 0x29, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0x00, 0xF3, 0x47, 0xA3, 0x5C, 0x2A, 0x05, 0x92, 0x08, 0x97,
+0x07, 0x91, 0x63, 0xF3, 0x00, 0x4A, 0x05, 0xD2, 0x05, 0x93, 0x06, 0x90,
+0x01, 0x6A, 0x00, 0xF3, 0x44, 0xC3, 0x00, 0xEF, 0x05, 0x63, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x31, 0x24, 0xF2, 0x02, 0x68, 0x20, 0x31,
+0x00, 0x30, 0x01, 0xF6, 0x88, 0x41, 0x24, 0xF2, 0x02, 0x6D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x30, 0x01, 0xF6, 0x80, 0x41, 0x24, 0xF2, 0xA2, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x01, 0xF6, 0x84, 0x41, 0x24, 0xF2,
+0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x11, 0xF6, 0x80, 0x41,
+0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x11, 0xF6,
+0x84, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x11, 0xF6, 0x88, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x11, 0xF6, 0x8C, 0x41, 0x24, 0xF2, 0xA2, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x01, 0x6B, 0x63, 0xF3, 0x00, 0x4A, 0x00, 0xF3, 0x67, 0xC2, 0x05, 0x92,
+0x08, 0x97, 0x07, 0x91, 0x63, 0xF3, 0x00, 0x4A, 0x05, 0xD2, 0x05, 0x93,
+0x06, 0x90, 0x01, 0x6A, 0x00, 0xF3, 0x44, 0xC3, 0x00, 0xEF, 0x05, 0x63,
+0xC9, 0xF7, 0x1B, 0x68, 0x02, 0xF0, 0x10, 0x6A, 0x0B, 0xE8, 0x40, 0x32,
+0x40, 0x32, 0x00, 0x30, 0xA2, 0x67, 0x00, 0x30, 0x01, 0xF6, 0x80, 0x40,
+0x02, 0xF0, 0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x04, 0xD2, 0x04, 0x95,
+0x01, 0xF6, 0x84, 0x40, 0x02, 0xF0, 0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x01, 0xF6, 0x88, 0x40, 0x02, 0xF0, 0x10, 0x6D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x04, 0x95, 0x11, 0xF6, 0x80, 0x40, 0x02, 0xF0,
+0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x04, 0x95, 0x11, 0xF6,
+0x84, 0x40, 0x02, 0xF0, 0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x04, 0x95, 0x11, 0xF6, 0x88, 0x40, 0x02, 0xF0, 0x10, 0x4D, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x04, 0x95, 0x11, 0xF6, 0x8C, 0x40, 0x02, 0xF0,
+0x10, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x00, 0xF3, 0x27, 0xC3,
+0x05, 0x92, 0x08, 0x97, 0x07, 0x91, 0x63, 0xF3, 0x00, 0x4A, 0x05, 0xD2,
+0x05, 0x93, 0x06, 0x90, 0x01, 0x6A, 0x00, 0xF3, 0x44, 0xC3, 0x00, 0xEF,
+0x05, 0x63, 0x00, 0x00, 0xFC, 0x63, 0x05, 0xD1, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0x06, 0x62, 0x04, 0xD0, 0x63, 0xF3, 0x00, 0x49,
+0x00, 0xF3, 0xCC, 0x99, 0x02, 0xF0, 0x00, 0x68, 0x00, 0x30, 0xAF, 0x40,
+0x00, 0x1C, 0x83, 0x45, 0x15, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x00, 0xF3, 0xD0, 0x99, 0x1A, 0x6C, 0x00, 0x1C, 0x83, 0x45, 0xAF, 0x40,
+0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0xF3, 0x44, 0xA1, 0x0E, 0x2A,
+0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x01, 0xF6,
+0x00, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0x6C, 0x99,
+0x6E, 0xEA, 0x36, 0x22, 0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8, 0xE0, 0xF2,
+0xA8, 0x99, 0x00, 0x30, 0x00, 0x30, 0x01, 0xF6, 0x88, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xAC, 0x99, 0x01, 0xF6, 0x80, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xB0, 0x99, 0x01, 0xF6,
+0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xB4, 0x99,
+0x11, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2,
+0xB8, 0x99, 0x11, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0xE0, 0xF2, 0xBC, 0x99, 0x11, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x00, 0xF3, 0xA0, 0x99, 0x11, 0xF6, 0x8C, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x06, 0x97, 0x05, 0x91, 0x04, 0x90, 0x63, 0xF3, 0x00, 0x4A, 0x00, 0x6B,
+0x00, 0xF3, 0x64, 0xC2, 0x02, 0x6B, 0x00, 0xF3, 0x67, 0xC2, 0x00, 0xEF,
+0x04, 0x63, 0x00, 0x00, 0xFC, 0x63, 0x05, 0xD1, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0x06, 0x62, 0x04, 0xD0, 0x63, 0xF3, 0x00, 0x49,
+0x00, 0xF3, 0xCC, 0x99, 0x02, 0xF0, 0x00, 0x68, 0x00, 0x30, 0xAF, 0x40,
+0x00, 0x1C, 0x83, 0x45, 0x15, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x00, 0xF3, 0xD0, 0x99, 0x1A, 0x6C, 0x00, 0x1C, 0x83, 0x45, 0xAF, 0x40,
+0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0xF3, 0x44, 0xA1, 0x03, 0x72,
+0x5B, 0x60, 0xE0, 0xF2, 0xAC, 0x99, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA,
+0x40, 0x30, 0x00, 0x30, 0x01, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xE0, 0xF2, 0xB0, 0x99, 0x01, 0xF6, 0x84, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xB4, 0x99, 0x11, 0xF6, 0x80, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xB8, 0x99, 0x11, 0xF6,
+0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0xBC, 0x99,
+0x11, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0xF3,
+0xA0, 0x99, 0x11, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x00, 0xF3, 0x48, 0x99, 0xE0, 0xF2, 0x68, 0x99, 0x55, 0xE3, 0x1F, 0xF7,
+0x00, 0x6A, 0xAC, 0xEA, 0x07, 0xF7, 0x01, 0x5A, 0x16, 0x60, 0x01, 0xF6,
+0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0x06, 0x97, 0x05, 0x91, 0x04, 0x90, 0x63, 0xF3,
+0x00, 0x4A, 0x03, 0x6B, 0x00, 0xF3, 0x64, 0xC2, 0x02, 0x6B, 0x00, 0xF3,
+0x67, 0xC2, 0x00, 0xEF, 0x04, 0x63, 0xFF, 0x6A, 0x01, 0x4A, 0x4B, 0xEA,
+0x40, 0x32, 0xE0, 0xF0, 0x1F, 0x4A, 0x4C, 0xED, 0x07, 0xF7, 0x00, 0x6A,
+0x4D, 0xED, 0xDF, 0x17, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34,
+0x80, 0x34, 0x01, 0xF6, 0x00, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0xE0, 0xF2, 0xAC, 0x99, 0xAA, 0xEA, 0x99, 0x61, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0x06, 0x97, 0x05, 0x91, 0x04, 0x90, 0x63, 0xF3,
+0x00, 0x4A, 0x03, 0x6B, 0x00, 0xF3, 0x64, 0xC2, 0x02, 0x6B, 0x00, 0xF3,
+0x67, 0xC2, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x00, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x40, 0x9B, 0x10, 0x6B, 0xFB, 0x63,
+0x6D, 0xEA, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x40, 0xDB, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x07, 0xD1, 0x40, 0x31,
+0x20, 0x31, 0x51, 0xF4, 0x80, 0x41, 0x08, 0x62, 0x00, 0x1C, 0x00, 0x5C,
+0x06, 0xD0, 0x00, 0xF6, 0x40, 0x32, 0x00, 0xF6, 0x43, 0x32, 0x51, 0xF4,
+0x80, 0x41, 0x1A, 0x6D, 0x00, 0x1C, 0xF0, 0x5B, 0x04, 0xD2, 0xF1, 0xF0,
+0x88, 0x41, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65, 0x04, 0x93, 0x00, 0xF6,
+0x40, 0x32, 0x00, 0xF6, 0x43, 0x32, 0x49, 0xE3, 0x08, 0x42, 0x9A, 0x48,
+0xBF, 0xF7, 0x1B, 0x50, 0x09, 0x61, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x43, 0xAB, 0x01, 0x4A, 0x43, 0xCB,
+0x04, 0x95, 0xFF, 0x6A, 0x51, 0xF4, 0x80, 0x41, 0x00, 0x1C, 0xF0, 0x5B,
+0x4C, 0xED, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x40, 0x9B, 0x11, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x40, 0xDB, 0x0B, 0xED, 0xFF, 0x6A,
+0x91, 0xF4, 0x82, 0x41, 0x00, 0x1C, 0xF0, 0x5B, 0x4C, 0xED, 0x08, 0x97,
+0x07, 0x91, 0x06, 0x90, 0x00, 0x6A, 0x00, 0xEF, 0x05, 0x63, 0x00, 0x00,
+0xF9, 0x63, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0x0C, 0x62, 0x0B, 0xD1, 0x0A, 0xD0, 0x66, 0xF7, 0x4C, 0x9B,
+0x52, 0x32, 0x05, 0xD2, 0x05, 0x94, 0x7F, 0x6A, 0x4C, 0xEC, 0x05, 0xD4,
+0x00, 0xF3, 0x44, 0xA3, 0x06, 0xD2, 0x40, 0x9B, 0x84, 0x6B, 0x6C, 0xEA,
+0x80, 0x72, 0x2A, 0x61, 0x06, 0x93, 0x01, 0x73, 0x02, 0x60, 0x04, 0x73,
+0x1B, 0x61, 0x02, 0xF0, 0x00, 0x68, 0x00, 0xF2, 0x00, 0x6E, 0x00, 0x30,
+0xC0, 0x36, 0xAF, 0x40, 0xF3, 0xF0, 0x14, 0x4E, 0x00, 0x1C, 0x83, 0x45,
+0x15, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0xFF, 0x6E, 0x01, 0x4E,
+0xC0, 0x36, 0x1A, 0x6C, 0x46, 0xF0, 0x16, 0x4E, 0x00, 0x1C, 0x83, 0x45,
+0xAF, 0x40, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x01, 0x6A, 0x4B, 0xEA,
+0x00, 0xF3, 0x44, 0xC3, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x30,
+0x00, 0x30, 0x40, 0xF0, 0x6C, 0xA0, 0x03, 0x6A, 0x6C, 0xEA, 0x0A, 0x22,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x63, 0xF3, 0x40, 0x9C,
+0x01, 0x6B, 0x5E, 0x32, 0x6C, 0xEA, 0x7C, 0x22, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x63, 0xF3, 0x00, 0x4C, 0x00, 0xF3, 0x44, 0x9C,
+0xFF, 0xF7, 0x1F, 0x6B, 0x42, 0x32, 0x6C, 0xEA, 0x16, 0x2A, 0xC9, 0xF7,
+0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x80, 0xF1, 0x04, 0x4A,
+0x40, 0x9A, 0x0D, 0x72, 0x58, 0x61, 0x46, 0x6A, 0x00, 0xF3, 0x5C, 0xC4,
+0x41, 0x6A, 0x00, 0xF3, 0x5D, 0xC4, 0x40, 0x6A, 0x00, 0xF3, 0x5E, 0xC4,
+0x3B, 0x6A, 0x00, 0xF3, 0x5F, 0xC4, 0x10, 0xF0, 0x02, 0x69, 0x00, 0xF4,
+0x20, 0x31, 0x63, 0xF3, 0x00, 0x49, 0xE4, 0xF4, 0xB8, 0x99, 0xC9, 0xF7,
+0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x30, 0xFF, 0x6E, 0xB2, 0x35, 0x00, 0x30,
+0xCC, 0xED, 0x61, 0xF4, 0x80, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x08, 0xD6,
+0x60, 0x99, 0x84, 0x6A, 0x08, 0x96, 0x6C, 0xEA, 0x84, 0x72, 0x2B, 0x61,
+0xE4, 0xF4, 0x58, 0x99, 0xFF, 0xF7, 0x1F, 0x72, 0x26, 0x60, 0x76, 0x32,
+0x01, 0x6B, 0x6C, 0xEA, 0x22, 0x22, 0x40, 0xF0, 0x4C, 0xA0, 0x03, 0x6B,
+0xCC, 0xEA, 0x6C, 0xEA, 0x1C, 0x22, 0x06, 0x92, 0x6A, 0xEA, 0xA0, 0xF0,
+0x13, 0x60, 0x04, 0x52, 0xA0, 0xF0, 0x1B, 0x60, 0xC0, 0xF0, 0x18, 0x22,
+0x01, 0x72, 0x11, 0x61, 0x00, 0xF3, 0x5C, 0xA1, 0x05, 0x93, 0xCC, 0xEA,
+0x43, 0xEB, 0xC0, 0xF0, 0x0B, 0x60, 0x00, 0xF3, 0x5F, 0xA1, 0x05, 0x94,
+0xCC, 0xEA, 0x83, 0xEA, 0xA0, 0xF0, 0x1A, 0x61, 0x00, 0x18, 0x96, 0x29,
+0x00, 0x65, 0x0C, 0x97, 0x0B, 0x91, 0x0A, 0x90, 0x00, 0x6A, 0x00, 0xEF,
+0x07, 0x63, 0x4A, 0x6A, 0x00, 0xF3, 0x5C, 0xC4, 0x45, 0x6A, 0x00, 0xF3,
+0x5D, 0xC4, 0x46, 0x6A, 0x00, 0xF3, 0x5E, 0xC4, 0x40, 0x6A, 0x00, 0xF3,
+0x5F, 0xC4, 0xA7, 0x17, 0x01, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x0E, 0x2A, 0x11, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x27, 0xF7, 0x1F, 0x6B, 0x60, 0x33, 0x60, 0x33, 0x27, 0xF7,
+0x1F, 0x4B, 0x6E, 0xEA, 0x7F, 0xF7, 0x10, 0x22, 0x9D, 0x67, 0x00, 0x1C,
+0x8A, 0x40, 0x10, 0x4C, 0x10, 0xF0, 0x02, 0x69, 0x00, 0xF4, 0x20, 0x31,
+0x01, 0xF6, 0x88, 0x40, 0x63, 0xF3, 0x00, 0x49, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0xE0, 0xF2, 0x48, 0xD9, 0x01, 0xF6, 0x80, 0x40, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0x4C, 0xD9, 0x01, 0xF6, 0x84, 0x40,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0x50, 0xD9, 0x11, 0xF6,
+0x80, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF2, 0x54, 0xD9,
+0x11, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF2,
+0x58, 0xD9, 0x11, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0xE0, 0xF2, 0x5C, 0xD9, 0x11, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x65, 0x00, 0xF3, 0x40, 0xD9, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0xCB, 0xF4, 0x46, 0xA2, 0xFF, 0x6B, 0x6C, 0xEA, 0x22, 0x72,
+0x02, 0x60, 0x92, 0x72, 0x1A, 0x61, 0x01, 0xF0, 0x8D, 0x40, 0x00, 0x1C,
+0x00, 0x5C, 0x00, 0x65, 0x0F, 0x6B, 0x4C, 0xEB, 0x0F, 0x6A, 0x6E, 0xEA,
+0xFF, 0x6C, 0x8C, 0xEA, 0x08, 0x5B, 0xA1, 0x42, 0x0C, 0x61, 0xA0, 0x34,
+0x80, 0x33, 0x00, 0xF6, 0xA0, 0x32, 0x6D, 0xEA, 0x8D, 0xEA, 0xAD, 0xEA,
+0xAD, 0xEC, 0x00, 0xF3, 0x54, 0xD9, 0x00, 0xF3, 0x98, 0xD9, 0x9D, 0x67,
+0x00, 0x1C, 0x90, 0x40, 0x10, 0x4C, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x40, 0x9B, 0x80, 0x6B, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x6D, 0xEA, 0x63, 0xF3, 0x40, 0xDC, 0xFC, 0x16,
+0x20, 0xF3, 0x40, 0xA1, 0x05, 0x93, 0xCC, 0xEA, 0x43, 0xEB, 0x5F, 0xF7,
+0x1B, 0x60, 0x00, 0x18, 0xD2, 0x29, 0x00, 0x65, 0x5A, 0x17, 0x06, 0x93,
+0x04, 0x73, 0x12, 0x60, 0xFF, 0x73, 0x5F, 0xF7, 0x14, 0x61, 0x00, 0xF3,
+0x5E, 0xA1, 0x05, 0x94, 0xCC, 0xEA, 0x43, 0xEC, 0x24, 0x61, 0x00, 0xF3,
+0x5C, 0xA1, 0xCC, 0xEA, 0x43, 0xEC, 0x0A, 0x60, 0x00, 0x18, 0x1E, 0x29,
+0x00, 0x65, 0x45, 0x17, 0x00, 0xF3, 0x5D, 0xA1, 0x05, 0x94, 0xCC, 0xEA,
+0x83, 0xEA, 0xF6, 0x60, 0x00, 0x18, 0x9B, 0x28, 0x00, 0x65, 0x3B, 0x17,
+0x00, 0xF3, 0x5E, 0xA1, 0x05, 0x93, 0xCC, 0xEA, 0x43, 0xEB, 0xEC, 0x60,
+0x20, 0xF3, 0x41, 0xA1, 0x05, 0x94, 0xCC, 0xEA, 0x83, 0xEA, 0x3F, 0xF7,
+0x0B, 0x61, 0x00, 0x18, 0xD2, 0x29, 0x00, 0x65, 0x2A, 0x17, 0x20, 0xF3,
+0x41, 0xA1, 0x05, 0x93, 0xCC, 0xEA, 0x63, 0xEA, 0xF6, 0x60, 0x20, 0x17,
+0xFB, 0x63, 0x10, 0xF0, 0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x07, 0xD1,
+0x26, 0x67, 0x06, 0xD0, 0x08, 0x62, 0x63, 0xF3, 0x00, 0x49, 0x66, 0xF7,
+0x8C, 0x99, 0x7F, 0x6A, 0x92, 0x30, 0x4C, 0xE8, 0xE0, 0xF2, 0x46, 0xA1,
+0x0F, 0x2A, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x35, 0xA0, 0x35,
+0x40, 0xF0, 0x4C, 0xA5, 0xFF, 0x6B, 0x6C, 0xEA, 0x03, 0x6B, 0x6C, 0xEA,
+0x03, 0x22, 0xFF, 0xF7, 0x1F, 0x74, 0x06, 0x61, 0x08, 0x97, 0x07, 0x91,
+0x06, 0x90, 0x00, 0x6A, 0x00, 0xEF, 0x05, 0x63, 0x01, 0xF0, 0x80, 0x45,
+0x04, 0xD5, 0x00, 0x1C, 0x00, 0x5C, 0x05, 0xD6, 0x01, 0x6B, 0x6C, 0xEA,
+0x04, 0x95, 0x05, 0x96, 0x2C, 0x22, 0x4B, 0x58, 0x06, 0x61, 0xC0, 0xF2,
+0x53, 0xA1, 0xFF, 0x6C, 0x8C, 0xEA, 0x6A, 0xEA, 0x74, 0x61, 0x48, 0x40,
+0xE0, 0x4A, 0xFF, 0x6B, 0x6C, 0xEA, 0x1E, 0x5A, 0x07, 0x60, 0x86, 0x67,
+0x63, 0xF3, 0x00, 0x4C, 0xC0, 0xF2, 0x53, 0xA4, 0x6C, 0xEA, 0x43, 0x2A,
+0x23, 0x58, 0xD8, 0x60, 0x66, 0x67, 0x63, 0xF3, 0x00, 0x4B, 0xC0, 0xF2,
+0x53, 0xA3, 0x02, 0x72, 0xD1, 0x60, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC,
+0x80, 0x34, 0x02, 0x6A, 0x80, 0x34, 0xC0, 0xF2, 0x53, 0xC3, 0x81, 0xF4,
+0x07, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x6D, 0xC3, 0x17, 0x4B, 0x58,
+0x06, 0x61, 0xC0, 0xF2, 0x53, 0xA1, 0xFF, 0x6C, 0x8C, 0xEA, 0x01, 0x72,
+0x40, 0x61, 0x48, 0x40, 0xE0, 0x4A, 0xFF, 0x6B, 0x6C, 0xEA, 0x1E, 0x5A,
+0x07, 0x60, 0x86, 0x67, 0x63, 0xF3, 0x00, 0x4C, 0xC0, 0xF2, 0x53, 0xA4,
+0x6C, 0xEA, 0x25, 0x2A, 0x23, 0x58, 0xAC, 0x60, 0x66, 0x67, 0x63, 0xF3,
+0x00, 0x4B, 0xC0, 0xF2, 0x53, 0xA3, 0x02, 0x72, 0xA5, 0x60, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x02, 0x6A, 0x80, 0x34, 0xC0, 0xF2,
+0x53, 0xC3, 0x21, 0xF4, 0x10, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x42, 0x6D,
+0x97, 0x17, 0x00, 0x6A, 0xC0, 0xF2, 0x53, 0xC4, 0xC9, 0xF7, 0x1B, 0x6C,
+0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x81, 0xF4, 0x07, 0x4C, 0x00, 0x1C,
+0xF0, 0x5B, 0x20, 0x6D, 0x89, 0x17, 0x00, 0x6A, 0xC0, 0xF2, 0x53, 0xC4,
+0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x21, 0xF4,
+0x10, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x44, 0x6D, 0x7B, 0x17, 0x31, 0xF4,
+0x80, 0x45, 0xC0, 0xF2, 0x73, 0xC1, 0x00, 0x1C, 0xF0, 0x5B, 0x43, 0x6D,
+0x73, 0x17, 0x81, 0xF4, 0x87, 0x45, 0xC0, 0xF2, 0x73, 0xC1, 0x00, 0x1C,
+0xF0, 0x5B, 0x10, 0x6D, 0x6B, 0x17, 0x00, 0x65, 0xE8, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xBF, 0xAF, 0x24, 0x63, 0x00, 0x0C, 0x21, 0x38, 0x00, 0x00,
+0x10, 0x00, 0xBF, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0x01, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x10, 0x3C, 0x14, 0xAE, 0x42, 0x24,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x03, 0x11, 0x36, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x22, 0xAE, 0x20, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x30, 0x03, 0x10, 0x36, 0x20, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x05, 0x3C,
+0x00, 0x00, 0x02, 0xAE, 0x01, 0x80, 0x02, 0x3C, 0x15, 0xAE, 0x44, 0x24,
+0x33, 0x03, 0xA3, 0x34, 0x00, 0x00, 0x24, 0xAE, 0x00, 0x00, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x42, 0x30, 0xFB, 0xFF, 0x40, 0x10,
+0x30, 0x03, 0xA2, 0x34, 0x00, 0x00, 0x46, 0x8C, 0x0F, 0x00, 0x03, 0x3C,
+0xFF, 0xFF, 0x63, 0x34, 0x24, 0x30, 0xC3, 0x00, 0x40, 0x11, 0x06, 0x00,
+0x23, 0x10, 0x46, 0x00, 0x80, 0x10, 0x02, 0x00, 0x21, 0x10, 0x46, 0x00,
+0xAF, 0x0F, 0x05, 0x3C, 0xC0, 0x10, 0x02, 0x00, 0x00, 0xA0, 0xA5, 0x34,
+0x1B, 0x00, 0xA2, 0x00, 0x02, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x63, 0x24,
+0xC2, 0x30, 0x06, 0x00, 0x10, 0x00, 0xA4, 0x27, 0x54, 0x41, 0x66, 0xAC,
+0x12, 0x28, 0x00, 0x00, 0x90, 0x40, 0x00, 0x0C, 0x58, 0x41, 0x65, 0xAC,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27, 0xC0, 0xFF, 0xBD, 0x27,
+0x2C, 0x00, 0xB5, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x21, 0xA8, 0x80, 0x00,
+0x02, 0x80, 0x12, 0x3C, 0x10, 0x00, 0xA4, 0x27, 0x38, 0x00, 0xBE, 0xAF,
+0x30, 0x00, 0xB6, 0xAF, 0x3C, 0x00, 0xBF, 0xAF, 0x34, 0x00, 0xB7, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x44, 0x00, 0xA5, 0xAF,
+0xEC, 0x5D, 0x42, 0x92, 0x21, 0xF0, 0x00, 0x00, 0xC5, 0x00, 0x40, 0x10,
+0x21, 0xB0, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x43, 0x24,
+0xB0, 0x1B, 0x62, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30,
+0xBE, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3E, 0x62, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x40, 0x14, 0x02, 0x80, 0x17, 0x3C,
+0x0E, 0x5E, 0xE2, 0x92, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x0E, 0x5E, 0xE2, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0xFF, 0x42, 0x24, 0x0E, 0x5E, 0xE2, 0xA2, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xF2, 0x5D, 0x40, 0xA0, 0x14, 0x5E, 0x60, 0xAC,
+0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x62, 0x90, 0xFD, 0xFF, 0x03, 0x24,
+0x42, 0xB0, 0x13, 0x3C, 0x24, 0x10, 0x43, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x07, 0x5E, 0x62, 0xA0, 0x00, 0x00, 0x63, 0x92, 0xEF, 0xFF, 0x02, 0x24,
+0x03, 0x00, 0x64, 0x36, 0x24, 0x18, 0x62, 0x00, 0x40, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x63, 0xA2, 0x00, 0x00, 0x82, 0xA0, 0x02, 0x80, 0x04, 0x3C,
+0xF4, 0x5D, 0x82, 0x94, 0x20, 0x00, 0xA3, 0x96, 0xFF, 0xFF, 0x42, 0x30,
+0x0A, 0x00, 0x43, 0x10, 0x02, 0x80, 0x14, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x94, 0x00, 0x42, 0x34, 0xF4, 0x5D, 0x83, 0xA4, 0x00, 0x00, 0x43, 0xA4,
+0xF4, 0x5D, 0x83, 0x94, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x63, 0x30,
+0x80, 0x1A, 0x03, 0x00, 0xF8, 0x5D, 0x83, 0xAE, 0x25, 0xB0, 0x04, 0x3C,
+0x84, 0x00, 0x82, 0x34, 0x00, 0x00, 0x50, 0x8C, 0x80, 0x00, 0x84, 0x34,
+0x00, 0x00, 0x82, 0x8C, 0x21, 0x18, 0x00, 0x00, 0xF8, 0x5D, 0x86, 0x8E,
+0x00, 0x88, 0x10, 0x00, 0x21, 0x80, 0x00, 0x00, 0x25, 0x80, 0x02, 0x02,
+0x25, 0x88, 0x23, 0x02, 0x21, 0x20, 0x00, 0x02, 0x7D, 0x2B, 0x00, 0x0C,
+0x21, 0x28, 0x20, 0x02, 0xF8, 0x5D, 0x88, 0x8E, 0x02, 0x80, 0x0A, 0x3C,
+0xFC, 0x5D, 0x43, 0x95, 0x23, 0x48, 0x02, 0x01, 0x21, 0x20, 0x30, 0x01,
+0x21, 0x28, 0x00, 0x00, 0x2B, 0x10, 0x90, 0x00, 0xFF, 0xFF, 0x63, 0x30,
+0x21, 0x28, 0xB1, 0x00, 0x80, 0x1A, 0x03, 0x00, 0x21, 0x28, 0xA2, 0x00,
+0x21, 0x38, 0x00, 0x00, 0x2B, 0x40, 0x83, 0x00, 0x23, 0x28, 0xA7, 0x00,
+0x23, 0x20, 0x83, 0x00, 0x23, 0x28, 0xA8, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x18, 0x5E, 0x64, 0xAC, 0x1C, 0x5E, 0x65, 0xAC, 0xFC, 0x5D, 0x42, 0x95,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x42, 0x30, 0x80, 0x12, 0x02, 0x00,
+0x2B, 0x10, 0x49, 0x00, 0x97, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xFC, 0x5D, 0x42, 0x95, 0x00, 0x00, 0x64, 0x92, 0xFB, 0xFF, 0x03, 0x24,
+0xFF, 0xFF, 0x42, 0x30, 0x80, 0x12, 0x02, 0x00, 0x24, 0x20, 0x83, 0x00,
+0x23, 0x48, 0x22, 0x01, 0x00, 0x00, 0x64, 0xA2, 0x01, 0x00, 0x06, 0x24,
+0x04, 0x00, 0x20, 0x11, 0x01, 0x00, 0x04, 0x24, 0x80, 0x10, 0x09, 0x00,
+0x21, 0x10, 0x49, 0x00, 0x80, 0x30, 0x02, 0x00, 0xB9, 0x20, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x00, 0x42, 0xB0, 0x02, 0x3C, 0x22, 0x00, 0x03, 0x24,
+0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0, 0x44, 0x00, 0xA2, 0x8F,
+0x05, 0x00, 0x05, 0x24, 0x24, 0x00, 0xA4, 0x26, 0x00, 0x00, 0x47, 0x8C,
+0x14, 0x00, 0xA6, 0x27, 0xFF, 0x3F, 0xE7, 0x30, 0xAB, 0x1A, 0x00, 0x0C,
+0xDC, 0xFF, 0xE7, 0x24, 0x2C, 0x00, 0x40, 0x10, 0x21, 0x28, 0x40, 0x00,
+0xEC, 0x5D, 0x42, 0x92, 0x02, 0x00, 0x03, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x83, 0x00, 0x43, 0x10, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x00, 0xA2, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0xA3, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x62, 0x30,
+0x04, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x01, 0x00, 0x16, 0x24,
+0x0B, 0x5E, 0x56, 0xA0, 0x04, 0x00, 0xA3, 0x90, 0x14, 0x00, 0xA7, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xE2, 0x28, 0x16, 0x00, 0x40, 0x14,
+0xFE, 0x00, 0x66, 0x30, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x43, 0x24,
+0x4C, 0x3A, 0x64, 0x94, 0xC0, 0x10, 0x06, 0x00, 0x2A, 0x10, 0x82, 0x00,
+0x10, 0x00, 0x40, 0x14, 0x02, 0x80, 0x03, 0x3C, 0x21, 0x10, 0xC7, 0x00,
+0xFD, 0xFF, 0x42, 0x24, 0xC0, 0x10, 0x02, 0x00, 0x2A, 0x10, 0x44, 0x00,
+0x0A, 0x00, 0x40, 0x14, 0xC2, 0x10, 0x04, 0x00, 0x23, 0x30, 0x46, 0x00,
+0x21, 0x18, 0xA6, 0x00, 0x05, 0x00, 0x62, 0x90, 0x07, 0x00, 0x84, 0x30,
+0x01, 0x00, 0x03, 0x24, 0x07, 0x10, 0x82, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x0B, 0xF0, 0x62, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x62, 0x90,
+0xEF, 0xFF, 0x03, 0x24, 0x21, 0x20, 0xC0, 0x02, 0x24, 0x10, 0x43, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x62, 0xA0, 0xEC, 0x5D, 0x43, 0x92,
+0x02, 0x80, 0x02, 0x3C, 0xE0, 0xE4, 0x42, 0x24, 0xFF, 0x00, 0x63, 0x30,
+0x80, 0x18, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x00, 0x00, 0x66, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x09, 0xF8, 0xC0, 0x00, 0x21, 0x28, 0xC0, 0x03,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x3C, 0x00, 0xBF, 0x8F,
+0x38, 0x00, 0xBE, 0x8F, 0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x40, 0x00, 0xBD, 0x27, 0xEC, 0x5D, 0x42, 0x92,
+0x00, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x03, 0x3C,
+0x60, 0x1B, 0x70, 0x24, 0xB0, 0x1B, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x42, 0x30, 0xE9, 0xFF, 0x40, 0x10, 0x05, 0x00, 0x05, 0x24,
+0x44, 0x00, 0xA2, 0x8F, 0x24, 0x00, 0xA4, 0x26, 0x00, 0x00, 0x47, 0x8C,
+0x14, 0x00, 0xA6, 0x27, 0xFF, 0x3F, 0xE7, 0x30, 0xAB, 0x1A, 0x00, 0x0C,
+0xDC, 0xFF, 0xE7, 0x24, 0xE0, 0xFF, 0x40, 0x10, 0x21, 0x28, 0x40, 0x00,
+0x14, 0x00, 0xA7, 0x8F, 0x04, 0x00, 0x42, 0x90, 0x04, 0x00, 0xE3, 0x28,
+0xDB, 0xFF, 0x60, 0x14, 0xFE, 0x00, 0x46, 0x30, 0x4C, 0x3A, 0x04, 0x96,
+0xC0, 0x10, 0x06, 0x00, 0x2A, 0x10, 0x82, 0x00, 0xD6, 0xFF, 0x40, 0x14,
+0x21, 0x10, 0xC7, 0x00, 0xFD, 0xFF, 0x42, 0x24, 0xC0, 0x10, 0x02, 0x00,
+0x2A, 0x10, 0x44, 0x00, 0xD1, 0xFF, 0x40, 0x14, 0xC2, 0x10, 0x04, 0x00,
+0x23, 0x30, 0x46, 0x00, 0x21, 0x18, 0xA6, 0x00, 0x05, 0x00, 0x62, 0x90,
+0x07, 0x00, 0x84, 0x30, 0x07, 0x10, 0x82, 0x00, 0x01, 0x00, 0x42, 0x30,
+0xC9, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x51, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x00, 0x83, 0x2C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x0E, 0x5E, 0xE2, 0x92, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x5E, 0xE2, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x42, 0x24, 0x0E, 0x5E, 0xE2, 0xA2, 0x00, 0x00, 0x62, 0x92,
+0xFB, 0xFF, 0x03, 0x24, 0x01, 0x00, 0x06, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x62, 0xA2, 0x32, 0x2C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x03, 0x00, 0xA2, 0x90, 0x02, 0x80, 0x07, 0x3C, 0x09, 0x5E, 0xE2, 0xA0,
+0x02, 0x00, 0xA3, 0x90, 0x21, 0x30, 0x80, 0x00, 0x0A, 0x5E, 0x83, 0xA0,
+0x0A, 0x5E, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x09, 0x5E, 0xE2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x5E, 0xC2, 0xA0, 0x4C, 0x2C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x5E, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x5E, 0xC2, 0xA0,
+0x4C, 0x2C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x0D, 0x5E, 0x43, 0xA0, 0xD0, 0x07, 0x04, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0xDC, 0x5D, 0x44, 0xAC,
+0x0C, 0x5E, 0x60, 0xA0, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x04, 0x00, 0x82, 0x8C, 0x02, 0x00, 0x03, 0x24,
+0x21, 0x80, 0x80, 0x00, 0x02, 0x17, 0x02, 0x00, 0x03, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x43, 0x10, 0x02, 0x80, 0x11, 0x3C, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xEC, 0x5D, 0x22, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xF8, 0xFF, 0x40, 0x10, 0x10, 0x00, 0xA4, 0x27, 0x8A, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xEC, 0x5D, 0x23, 0x92, 0x02, 0x80, 0x02, 0x3C,
+0xB4, 0xE4, 0x42, 0x24, 0xFF, 0x00, 0x63, 0x30, 0x80, 0x18, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x00, 0x00, 0x66, 0x8C, 0x00, 0x00, 0x04, 0x8E,
+0x04, 0x00, 0x05, 0x8E, 0x09, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90, 0x0C, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x63, 0x30, 0x05, 0x00, 0x62, 0x10, 0x10, 0x00, 0xA4, 0x27,
+0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x2C, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x06, 0x5E, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x60, 0x10, 0x02, 0x80, 0x05, 0x3C,
+0x0C, 0x5E, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24,
+0x0C, 0x5E, 0xA2, 0xA0, 0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xF7, 0x2C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x04, 0x3C,
+0x28, 0x00, 0x85, 0x34, 0x02, 0x00, 0x82, 0x94, 0x04, 0x00, 0x84, 0x24,
+0x05, 0x00, 0x40, 0x14, 0x2B, 0x18, 0xA4, 0x00, 0xFB, 0xFF, 0x60, 0x10,
+0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x25, 0xB0, 0x03, 0x3C,
+0xBE, 0x00, 0x63, 0x34, 0x00, 0x00, 0x62, 0x94, 0x08, 0x00, 0xE0, 0x03,
+0x01, 0x00, 0x42, 0x2C, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x24, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x19, 0x00, 0x40, 0x10, 0x98, 0x54, 0x64, 0x24, 0x98, 0x54, 0x62, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x44, 0x14, 0x02, 0x80, 0x02, 0x3C,
+0x0D, 0x5E, 0x43, 0x90, 0x01, 0x00, 0x02, 0x24, 0xFF, 0x00, 0x63, 0x30,
+0x10, 0x00, 0x62, 0x10, 0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x05, 0x00, 0x42, 0x28,
+0x0A, 0x00, 0x40, 0x10, 0x01, 0x00, 0x04, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x64, 0x59, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x60, 0x14,
+0x21, 0x10, 0x80, 0x00, 0x10, 0x00, 0xBF, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0x8F,
+0x21, 0x20, 0x00, 0x00, 0x21, 0x10, 0x80, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x24, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x98, 0x54, 0x43, 0x8C, 0x98, 0x54, 0x42, 0x24,
+0x28, 0x00, 0x62, 0x14, 0x02, 0x80, 0x03, 0x3C, 0x05, 0x5E, 0x62, 0x90,
+0x01, 0x00, 0x04, 0x24, 0xFF, 0x00, 0x42, 0x30, 0x23, 0x00, 0x44, 0x10,
+0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0x03, 0x00, 0x42, 0x28, 0x1D, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x42, 0x30, 0x18, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x42, 0x30,
+0x13, 0x00, 0x40, 0x14, 0x02, 0x80, 0x03, 0x3C, 0x0D, 0x5E, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x42, 0x30, 0x0E, 0x00, 0x44, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x0E, 0x5E, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x60, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0x04, 0x3E, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x14,
+0x21, 0x18, 0x00, 0x00, 0x3C, 0x3A, 0x42, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x40, 0x14, 0x01, 0x00, 0x03, 0x24, 0x21, 0x18, 0x00, 0x00,
+0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x30, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x0E, 0x00, 0x40, 0x10, 0x90, 0x54, 0x65, 0x24, 0x90, 0x54, 0x62, 0x8C,
+0x02, 0x80, 0x04, 0x3C, 0x88, 0x54, 0x86, 0x24, 0x09, 0x00, 0x45, 0x14,
+0x01, 0x00, 0x03, 0x24, 0x88, 0x54, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x05, 0x00, 0x46, 0x14, 0x21, 0x10, 0x60, 0x00, 0x10, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0x10, 0x00, 0xBF, 0x8F, 0x21, 0x18, 0x00, 0x00, 0x21, 0x10, 0x60, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0xFF, 0x00, 0x90, 0x30, 0x10, 0x00, 0xA4, 0x27,
+0x20, 0x00, 0xB2, 0xAF, 0x24, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x02, 0x80, 0x12, 0x3C, 0x0F, 0x00, 0x00, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x3C, 0x5E, 0x43, 0x92, 0x01, 0x00, 0x02, 0x24,
+0x04, 0x0C, 0x04, 0x24, 0xFF, 0x00, 0x63, 0x30, 0x2A, 0x00, 0x62, 0x10,
+0x80, 0x01, 0x10, 0x3C, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x3C, 0x5E, 0x43, 0x92, 0x02, 0x00, 0x02, 0x24, 0x21, 0x28, 0x00, 0x00,
+0xFF, 0x00, 0x63, 0x30, 0xF3, 0xFF, 0x62, 0x14, 0x44, 0x08, 0x04, 0x24,
+0x03, 0x5C, 0x00, 0x0C, 0x7F, 0xFE, 0x10, 0x3C, 0x30, 0x5C, 0x00, 0x0C,
+0x04, 0x0C, 0x04, 0x24, 0xFD, 0x00, 0x45, 0x30, 0x1A, 0x5C, 0x00, 0x0C,
+0x04, 0x0C, 0x04, 0x24, 0x30, 0x5C, 0x00, 0x0C, 0x04, 0x0D, 0x04, 0x24,
+0xFD, 0x00, 0x45, 0x30, 0x1A, 0x5C, 0x00, 0x0C, 0x04, 0x0D, 0x04, 0x24,
+0x26, 0x5C, 0x00, 0x0C, 0x70, 0x0E, 0x04, 0x24, 0xFF, 0xFF, 0x10, 0x36,
+0x24, 0x28, 0x50, 0x00, 0x03, 0x5C, 0x00, 0x0C, 0x70, 0x0E, 0x04, 0x24,
+0x26, 0x5C, 0x00, 0x0C, 0x8C, 0x0E, 0x04, 0x24, 0x24, 0x28, 0x50, 0x00,
+0x03, 0x5C, 0x00, 0x0C, 0x8C, 0x0E, 0x04, 0x24, 0x01, 0x00, 0x02, 0x24,
+0x3C, 0x5E, 0x42, 0xA2, 0xB9, 0x2D, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x30, 0x5C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x42, 0x34,
+0xFF, 0x00, 0x45, 0x30, 0x1A, 0x5C, 0x00, 0x0C, 0x04, 0x0C, 0x04, 0x24,
+0x30, 0x5C, 0x00, 0x0C, 0x04, 0x0D, 0x04, 0x24, 0x02, 0x00, 0x42, 0x34,
+0xFF, 0x00, 0x45, 0x30, 0x1A, 0x5C, 0x00, 0x0C, 0x04, 0x0D, 0x04, 0x24,
+0x26, 0x5C, 0x00, 0x0C, 0x70, 0x0E, 0x04, 0x24, 0x25, 0x28, 0x50, 0x00,
+0x03, 0x5C, 0x00, 0x0C, 0x70, 0x0E, 0x04, 0x24, 0x26, 0x5C, 0x00, 0x0C,
+0x8C, 0x0E, 0x04, 0x24, 0x25, 0x28, 0x50, 0x00, 0x03, 0x5C, 0x00, 0x0C,
+0x8C, 0x0E, 0x04, 0x24, 0x03, 0x00, 0x05, 0x3C, 0x59, 0x01, 0xA5, 0x34,
+0x03, 0x5C, 0x00, 0x0C, 0x44, 0x08, 0x04, 0x24, 0x02, 0x00, 0x02, 0x24,
+0x3C, 0x5E, 0x42, 0xA2, 0xB9, 0x2D, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x42, 0x00, 0x46, 0x34, 0xFC, 0x37, 0x03, 0x24,
+0x40, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA4, 0x03, 0x08, 0x04, 0x24,
+0x03, 0x00, 0x05, 0x24, 0x00, 0x00, 0xC0, 0xA0, 0x1A, 0x5C, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x02, 0x3C, 0xEC, 0x5D, 0x43, 0x90, 0xFC, 0x57, 0x12, 0x24,
+0x0B, 0x00, 0x60, 0x10, 0xFC, 0x77, 0x11, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0xC6, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x63, 0x30,
+0x2A, 0x00, 0x60, 0x14, 0x21, 0x20, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00,
+0x00, 0x02, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C, 0x00, 0x08, 0x04, 0x24,
+0x25, 0xB0, 0x03, 0x3C, 0x21, 0x00, 0x65, 0x34, 0x00, 0x00, 0xA2, 0x90,
+0x18, 0x00, 0x66, 0x34, 0x40, 0x00, 0x70, 0x34, 0x01, 0x00, 0x42, 0x34,
+0x42, 0x00, 0x63, 0x34, 0x00, 0x00, 0xA2, 0xA0, 0xFF, 0xFF, 0x02, 0x24,
+0x00, 0x00, 0xC0, 0xA0, 0x64, 0x00, 0x04, 0x24, 0x00, 0x00, 0x62, 0xA0,
+0x00, 0x00, 0x12, 0xA6, 0x5B, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x11, 0xA6, 0x5B, 0x1F, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x1A, 0x5C, 0x00, 0x0C, 0x03, 0x08, 0x04, 0x24,
+0x5B, 0x1F, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24, 0xFC, 0x37, 0x02, 0x24,
+0x00, 0x00, 0x02, 0xA6, 0x5B, 0x1F, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24,
+0x00, 0x00, 0x11, 0xA6, 0x5B, 0x1F, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24,
+0x00, 0x00, 0x12, 0xA6, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xA8, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x30, 0x00, 0x00, 0x00, 0x02, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C,
+0x00, 0x08, 0x04, 0x24, 0x1F, 0x2E, 0x00, 0x08, 0x25, 0xB0, 0x03, 0x3C,
+0xB8, 0xFF, 0xBD, 0x27, 0x2C, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x13, 0x3C, 0xFF, 0x00, 0x90, 0x30, 0x18, 0x00, 0xA4, 0x27,
+0x30, 0x00, 0xB4, 0xAF, 0x28, 0x00, 0xB2, 0xAF, 0x24, 0x00, 0xB1, 0xAF,
+0x40, 0x00, 0xBF, 0xAF, 0x3C, 0x00, 0xB7, 0xAF, 0x38, 0x00, 0xB6, 0xAF,
+0x34, 0x00, 0xB5, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0xFF, 0x00, 0xB2, 0x30,
+0xEE, 0x5D, 0x62, 0x92, 0x0F, 0x00, 0x11, 0x32, 0x0F, 0x00, 0x42, 0x30,
+0x13, 0x00, 0x51, 0x10, 0x21, 0xA0, 0x00, 0x00, 0x04, 0x00, 0x02, 0x32,
+0x40, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x5D, 0x62, 0x92,
+0x0C, 0x00, 0x03, 0x24, 0x0F, 0x00, 0x42, 0x30, 0x8F, 0x00, 0x43, 0x10,
+0x08, 0x00, 0x02, 0x32, 0xEE, 0x5D, 0x62, 0x92, 0x04, 0x00, 0x03, 0x24,
+0x0F, 0x00, 0x42, 0x30, 0xD2, 0x01, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xEE, 0x5D, 0x62, 0x92, 0x02, 0x00, 0x03, 0x24, 0x0F, 0x00, 0x42, 0x30,
+0x9B, 0x00, 0x43, 0x10, 0x06, 0x00, 0x02, 0x32, 0x02, 0x80, 0x10, 0x3C,
+0xED, 0x5D, 0x03, 0x92, 0xEE, 0x5D, 0x62, 0x92, 0x0F, 0x00, 0x63, 0x30,
+0x0F, 0x00, 0x42, 0x30, 0x2A, 0x10, 0x43, 0x00, 0x1C, 0x00, 0x40, 0x14,
+0x02, 0x80, 0x12, 0x3C, 0xED, 0x5D, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x40, 0x00, 0x42, 0x30, 0x17, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0xC2, 0x5C, 0x42, 0x90, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x43, 0x30,
+0x52, 0x00, 0x60, 0x14, 0x04, 0x00, 0x42, 0x30, 0x10, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xEE, 0x5D, 0x43, 0x92, 0x02, 0x80, 0x06, 0x3C,
+0x14, 0xE5, 0xC5, 0x90, 0x0F, 0x00, 0x63, 0x30, 0x25, 0xB0, 0x02, 0x3C,
+0x25, 0x18, 0x65, 0x00, 0xDD, 0x02, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0,
+0xED, 0x5D, 0x04, 0x92, 0x80, 0xFF, 0x02, 0x24, 0xBF, 0xFF, 0x03, 0x24,
+0x26, 0x28, 0xA2, 0x00, 0x24, 0x20, 0x83, 0x00, 0x14, 0xE5, 0xC5, 0xA0,
+0xED, 0x5D, 0x04, 0xA2, 0x90, 0x40, 0x00, 0x0C, 0x18, 0x00, 0xA4, 0x27,
+0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F,
+0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F,
+0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27, 0xEE, 0x5D, 0x62, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x42, 0x30, 0x4C, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xEE, 0x5D, 0x62, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x42, 0x30, 0x03, 0x00, 0x40, 0x10, 0x08, 0x00, 0x02, 0x32,
+0x1B, 0x00, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C, 0xEE, 0x5D, 0x62, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x42, 0x30, 0x0C, 0x00, 0x40, 0x14,
+0x08, 0x00, 0x02, 0x32, 0x0A, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x40, 0x12, 0x02, 0x80, 0x03, 0x3C, 0x10, 0x37, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30, 0x03, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x51, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00,
+0xEE, 0x5D, 0x62, 0x92, 0xF0, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0xEE, 0x5D, 0x62, 0xA2, 0xEE, 0x5D, 0x63, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x25, 0x18, 0x23, 0x02, 0xEE, 0x5D, 0x63, 0xA2, 0x72, 0x2E, 0x00, 0x08,
+0x02, 0x80, 0x10, 0x3C, 0x10, 0x37, 0x62, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x42, 0x30, 0xF2, 0xFF, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x0D, 0x5E, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xFF, 0x60, 0x14,
+0x01, 0x00, 0x04, 0x24, 0x0E, 0x51, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xBD, 0x2E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x53, 0x21, 0x00, 0x0C,
+0x24, 0x00, 0x04, 0x24, 0x76, 0x01, 0x40, 0x10, 0x21, 0x88, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xEC, 0x5D, 0x45, 0x90, 0xEE, 0x5D, 0x44, 0x92,
+0xED, 0x5D, 0x02, 0x92, 0xBF, 0xFF, 0x03, 0x24, 0x0F, 0x00, 0x84, 0x30,
+0x24, 0x10, 0x43, 0x00, 0xED, 0x5D, 0x02, 0xA2, 0x10, 0x00, 0xA5, 0xA3,
+0x11, 0x00, 0xA4, 0xA3, 0x08, 0x00, 0x24, 0x96, 0x02, 0x80, 0x02, 0x3C,
+0x10, 0x00, 0xA5, 0x27, 0x25, 0x20, 0x82, 0x00, 0x20, 0x00, 0x84, 0x24,
+0xC2, 0x1B, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24, 0x04, 0x00, 0x03, 0x24,
+0x17, 0x00, 0x02, 0x24, 0x0C, 0x00, 0x23, 0xAE, 0x14, 0x00, 0x22, 0xAE,
+0x17, 0x0A, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02, 0x94, 0x2E, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xA6, 0x2E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x71, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x35, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x77, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x5D, 0x62, 0x92,
+0xF0, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00, 0xEE, 0x5D, 0x62, 0xA2,
+0x02, 0x80, 0x03, 0x3C, 0xEE, 0x5D, 0x62, 0x92, 0x10, 0x37, 0x64, 0x94,
+0x04, 0x00, 0x42, 0x34, 0x00, 0x01, 0x84, 0x30, 0xEE, 0x5D, 0x62, 0xA2,
+0x61, 0xFF, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x51, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x67, 0x2E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x65, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x2D, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x61, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xEE, 0x5D, 0x62, 0x92, 0xF0, 0xFF, 0x03, 0x24, 0x41, 0xB0, 0x04, 0x3C,
+0x24, 0x10, 0x43, 0x00, 0xEE, 0x5D, 0x62, 0xA2, 0xEE, 0x5D, 0x63, 0x92,
+0x08, 0x00, 0x85, 0x34, 0x82, 0x00, 0x02, 0x24, 0x01, 0x00, 0x63, 0x34,
+0x02, 0x80, 0x17, 0x3C, 0xEE, 0x5D, 0x63, 0xA2, 0x00, 0x00, 0x80, 0xAC,
+0x00, 0x00, 0xA2, 0xA4, 0x42, 0xB0, 0x04, 0x3C, 0x60, 0x1B, 0xE2, 0x26,
+0xB0, 0x1B, 0x45, 0x94, 0x00, 0x00, 0x83, 0x90, 0xBE, 0xFF, 0x02, 0x24,
+0x03, 0x00, 0x86, 0x34, 0x24, 0x18, 0x62, 0x00, 0x00, 0x01, 0xA5, 0x30,
+0x90, 0xFF, 0x02, 0x24, 0x00, 0x00, 0x83, 0xA0, 0x00, 0x00, 0xC2, 0xA0,
+0x38, 0x00, 0xA0, 0x10, 0x25, 0xB0, 0x06, 0x3C, 0x25, 0xB0, 0x04, 0x3C,
+0x84, 0x00, 0x82, 0x34, 0x00, 0x00, 0x46, 0x8C, 0x80, 0x00, 0x84, 0x34,
+0x00, 0x00, 0x82, 0x8C, 0x02, 0x80, 0x0B, 0x3C, 0x14, 0x5E, 0x64, 0x8D,
+0x00, 0x38, 0x06, 0x00, 0x21, 0x30, 0x00, 0x00, 0x25, 0xA0, 0xC2, 0x00,
+0x21, 0x18, 0x00, 0x00, 0x02, 0x80, 0x0A, 0x3C, 0x25, 0xA8, 0xE3, 0x00,
+0x21, 0x28, 0x00, 0x00, 0x1C, 0x5E, 0x42, 0x8D, 0x21, 0x20, 0x94, 0x00,
+0x2B, 0x18, 0x94, 0x00, 0x21, 0x28, 0xB5, 0x00, 0x21, 0x28, 0xA3, 0x00,
+0x2B, 0x10, 0xA2, 0x00, 0x24, 0x01, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x5E, 0x42, 0x8D, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x45, 0x10,
+0x01, 0x00, 0x05, 0x24, 0x60, 0x1B, 0xE2, 0x26, 0x58, 0x41, 0x43, 0x8C,
+0x42, 0xB0, 0x07, 0x3C, 0x00, 0x00, 0xE6, 0x90, 0x18, 0x00, 0x65, 0x00,
+0xFB, 0xFF, 0x02, 0x24, 0x24, 0x30, 0xC2, 0x00, 0x00, 0x00, 0xE6, 0xA0,
+0x67, 0x46, 0x06, 0x3C, 0xCF, 0xAC, 0xC6, 0x34, 0x01, 0x00, 0x04, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x12, 0x18, 0x00, 0x00, 0x82, 0x1A, 0x03, 0x00,
+0x40, 0x10, 0x03, 0x00, 0x21, 0x10, 0x43, 0x00, 0xC0, 0x10, 0x02, 0x00,
+0x21, 0x10, 0x43, 0x00, 0x80, 0x10, 0x02, 0x00, 0x19, 0x00, 0x46, 0x00,
+0x10, 0x30, 0x00, 0x00, 0x23, 0x10, 0x46, 0x00, 0x42, 0x10, 0x02, 0x00,
+0x21, 0x30, 0xC2, 0x00, 0x02, 0x33, 0x06, 0x00, 0x01, 0x00, 0x02, 0x24,
+0xB9, 0x20, 0x00, 0x0C, 0x0A, 0x30, 0x46, 0x00, 0x25, 0xB0, 0x06, 0x3C,
+0xF2, 0x02, 0xC3, 0x34, 0x88, 0xFF, 0x02, 0x24, 0x00, 0x00, 0x62, 0xA0,
+0x11, 0x00, 0xC7, 0x34, 0x00, 0x00, 0xE2, 0x90, 0x08, 0x00, 0xC5, 0x34,
+0x60, 0x1B, 0xE4, 0x26, 0x01, 0x00, 0x42, 0x34, 0x00, 0x00, 0xE2, 0xA0,
+0x00, 0x00, 0xA3, 0x94, 0xB0, 0x1B, 0x82, 0x94, 0xFF, 0xFF, 0x64, 0x30,
+0x10, 0x00, 0x84, 0x34, 0x00, 0x00, 0xA4, 0xA4, 0xFB, 0xFF, 0x84, 0x30,
+0x00, 0x00, 0xA4, 0xA4, 0x00, 0x01, 0x42, 0x30, 0x02, 0x00, 0x84, 0x34,
+0x00, 0x00, 0xA4, 0xA4, 0x04, 0x00, 0x40, 0x10, 0x42, 0xB0, 0x02, 0x3C,
+0x22, 0x00, 0x03, 0x24, 0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0,
+0xFF, 0xF7, 0x84, 0x30, 0x00, 0x00, 0xA4, 0xA4, 0x28, 0x00, 0xC4, 0x34,
+0x00, 0x00, 0x83, 0x94, 0xEF, 0xFE, 0x02, 0x24, 0xFE, 0xFF, 0x08, 0x24,
+0x24, 0x18, 0x62, 0x00, 0x00, 0x00, 0x83, 0xA4, 0x00, 0x00, 0x82, 0x94,
+0x26, 0x00, 0xC5, 0x34, 0x02, 0x80, 0x03, 0x3C, 0x24, 0x10, 0x48, 0x00,
+0x00, 0x00, 0x82, 0xA4, 0xC2, 0x5C, 0x64, 0x90, 0x00, 0x00, 0xA2, 0x94,
+0x04, 0x00, 0x84, 0x30, 0x00, 0x24, 0x42, 0x34, 0x00, 0x00, 0xA2, 0xA4,
+0x09, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x48, 0x00, 0x00, 0x00, 0xA2, 0xA4,
+0x00, 0x00, 0xE3, 0x90, 0xFD, 0xFF, 0x02, 0x24, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x00, 0xE3, 0xA0, 0x00, 0x68, 0x02, 0x40, 0x00, 0x08, 0x42, 0x30,
+0xFD, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x12, 0x3C,
+0x11, 0x00, 0x43, 0x36, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x42, 0x34, 0x00, 0x00, 0x62, 0xA0, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x44, 0x36, 0x00, 0x00, 0x82, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x34, 0x00, 0x00, 0x82, 0xA4,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x94,
+0xFF, 0xDB, 0x02, 0x24, 0x28, 0x00, 0x45, 0x36, 0x24, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x83, 0xA4, 0x00, 0x00, 0xA2, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x42, 0x34, 0x00, 0x00, 0xA2, 0xA4, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x01, 0x42, 0x34, 0x00, 0x00, 0xA2, 0xA4, 0x08, 0x00, 0x51, 0x36,
+0x00, 0x00, 0x23, 0x96, 0x60, 0x1B, 0xF6, 0x26, 0xB0, 0x1B, 0xC2, 0x96,
+0xFF, 0xFF, 0x70, 0x30, 0x00, 0x18, 0x10, 0x36, 0x00, 0x00, 0x30, 0xA6,
+0x00, 0x01, 0x42, 0x30, 0xFD, 0xFF, 0x10, 0x32, 0x00, 0x00, 0x30, 0xA6,
+0x05, 0x00, 0x40, 0x10, 0x42, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x43, 0x90,
+0xFB, 0xFF, 0x04, 0x24, 0x24, 0x18, 0x64, 0x00, 0x00, 0x00, 0x43, 0xA0,
+0x04, 0x00, 0x10, 0x36, 0x5B, 0x1F, 0x00, 0x0C, 0x32, 0x00, 0x04, 0x24,
+0x00, 0x00, 0x30, 0xA6, 0x22, 0x00, 0x02, 0x24, 0xF2, 0x02, 0x43, 0x36,
+0xEF, 0xFF, 0x10, 0x32, 0x00, 0x00, 0x30, 0xA6, 0xC8, 0x00, 0x04, 0x24,
+0x00, 0x00, 0x62, 0xA0, 0x5B, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xB0, 0x1B, 0xC2, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30,
+0x41, 0x00, 0x40, 0x10, 0x42, 0xB0, 0x06, 0x3C, 0x84, 0x00, 0x42, 0x36,
+0x00, 0x00, 0x44, 0x8C, 0x80, 0x00, 0x46, 0x36, 0x00, 0x00, 0xC2, 0x8C,
+0x00, 0x28, 0x04, 0x00, 0x21, 0x18, 0x00, 0x00, 0x21, 0x20, 0x00, 0x00,
+0x25, 0x30, 0x82, 0x00, 0x25, 0x38, 0xA3, 0x00, 0x58, 0x41, 0xC3, 0x8E,
+0x23, 0x28, 0xD4, 0x00, 0x80, 0x12, 0x05, 0x00, 0x1B, 0x00, 0x43, 0x00,
+0x02, 0x00, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00,
+0x02, 0x80, 0x0B, 0x3C, 0x14, 0x5E, 0x63, 0x8D, 0x12, 0x10, 0x00, 0x00,
+0x23, 0x10, 0x45, 0x00, 0x21, 0x10, 0x43, 0x00, 0x14, 0x5E, 0x62, 0xAD,
+0x14, 0x5E, 0x63, 0x8D, 0x42, 0xB0, 0x02, 0x3C, 0x03, 0x00, 0x42, 0x34,
+0x58, 0x1B, 0x63, 0x24, 0x14, 0x5E, 0x63, 0xAD, 0x00, 0x00, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x63, 0x30, 0x20, 0x00, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x5E, 0x62, 0x8D, 0x02, 0x80, 0x0A, 0x3C,
+0x1C, 0x5E, 0x44, 0x8D, 0x21, 0x40, 0x46, 0x00, 0x2B, 0x28, 0x06, 0x01,
+0x21, 0x48, 0x67, 0x00, 0x21, 0x48, 0x25, 0x01, 0x2B, 0x20, 0x24, 0x01,
+0x59, 0x00, 0x80, 0x14, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x5E, 0x42, 0x8D,
+0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x49, 0x10, 0x01, 0x00, 0x05, 0x24,
+0x42, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x43, 0x90, 0xFB, 0xFF, 0x04, 0x24,
+0x01, 0x00, 0x06, 0x24, 0x24, 0x18, 0x64, 0x00, 0x00, 0x00, 0x43, 0xA0,
+0x04, 0x00, 0xA0, 0x10, 0x01, 0x00, 0x04, 0x24, 0x80, 0x10, 0x05, 0x00,
+0x21, 0x10, 0x45, 0x00, 0x80, 0x30, 0x02, 0x00, 0xB9, 0x20, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x00, 0x42, 0xB0, 0x02, 0x3C, 0x22, 0x00, 0x03, 0x24,
+0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0, 0x42, 0xB0, 0x06, 0x3C,
+0x00, 0x00, 0xC2, 0x90, 0x60, 0x1B, 0xE5, 0x26, 0xD0, 0x1B, 0xA8, 0x8C,
+0xDC, 0x1B, 0xA7, 0x94, 0x41, 0xB0, 0x03, 0x3C, 0x41, 0x00, 0x42, 0x34,
+0x08, 0x00, 0x64, 0x34, 0x00, 0x00, 0xC2, 0xA0, 0x00, 0x00, 0x68, 0xAC,
+0x00, 0x00, 0x87, 0xA4, 0xEE, 0x5D, 0x63, 0x92, 0xF0, 0xFF, 0x02, 0x24,
+0xDC, 0x1B, 0xA7, 0xA4, 0x24, 0x18, 0x62, 0x00, 0xEE, 0x5D, 0x63, 0xA2,
+0xEE, 0x5D, 0x62, 0x92, 0xD0, 0x1B, 0xA8, 0xAC, 0x02, 0x00, 0x42, 0x34,
+0xEE, 0x5D, 0x62, 0xA2, 0x72, 0x2E, 0x00, 0x08, 0x02, 0x80, 0x10, 0x3C,
+0x59, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x31, 0xFE, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0x2E, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xEE, 0x5D, 0x62, 0x92, 0xF0, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0xEE, 0x5D, 0x62, 0xA2, 0xEE, 0x5D, 0x63, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x63, 0x34, 0xEE, 0x5D, 0x63, 0xA2, 0x6C, 0x2E, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x99, 0x99, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x97, 0x99, 0x63, 0x34, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x94, 0x2E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x18, 0x5E, 0x42, 0x8D,
+0x00, 0x00, 0x00, 0x00, 0x2B, 0x10, 0x82, 0x00, 0x0C, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x18, 0x5E, 0x42, 0x8D, 0x45, 0x2F, 0x00, 0x08,
+0x01, 0x00, 0x05, 0x24, 0x18, 0x5E, 0x42, 0x8D, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0x02, 0x01, 0x0A, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x5E, 0x42, 0x8D, 0x16, 0x30, 0x00, 0x08, 0x01, 0x00, 0x05, 0x24,
+0x18, 0x5E, 0x42, 0x8D, 0x1C, 0x5E, 0x43, 0x8D, 0x14, 0x5E, 0x64, 0x8D,
+0x23, 0x10, 0x54, 0x00, 0x45, 0x2F, 0x00, 0x08, 0x23, 0x28, 0x44, 0x00,
+0x18, 0x5E, 0x42, 0x8D, 0x1C, 0x5E, 0x43, 0x8D, 0x14, 0x5E, 0x64, 0x8D,
+0x23, 0x10, 0x46, 0x00, 0x16, 0x30, 0x00, 0x08, 0x23, 0x28, 0x44, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xEC, 0x5D, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x60, 0x10, 0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90,
+0x04, 0x00, 0x04, 0x24, 0x0F, 0x00, 0x63, 0x30, 0x04, 0x00, 0x63, 0x28,
+0x03, 0x00, 0x60, 0x14, 0x01, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x4B, 0x2E, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x03, 0x3C, 0xE0, 0xFF, 0xBD, 0x27,
+0xFC, 0xC1, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x62, 0xAC, 0x18, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x0C, 0x5E, 0x82, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x40, 0x10, 0x01, 0x00, 0x05, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0xD0, 0x07, 0x03, 0x24, 0x0C, 0x5E, 0x80, 0xA0,
+0x10, 0x00, 0xA4, 0x27, 0x90, 0x40, 0x00, 0x0C, 0xDC, 0x5D, 0x43, 0xAC,
+0x18, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x03, 0x3C, 0x01, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x0F, 0x5E, 0x44, 0xA0, 0x02, 0x80, 0x02, 0x3C,
+0x0D, 0x5E, 0x60, 0xA0, 0xED, 0x5D, 0x44, 0x90, 0x4B, 0x2E, 0x00, 0x0C,
+0xFF, 0x00, 0x84, 0x30, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x18, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x42, 0x11, 0x05, 0x00, 0x0F, 0x00, 0x46, 0x30,
+0xE8, 0xFF, 0xBD, 0x27, 0x09, 0x00, 0xC3, 0x28, 0x14, 0x00, 0xBF, 0xAF,
+0x14, 0x00, 0x60, 0x10, 0x10, 0x00, 0xB0, 0xAF, 0x82, 0x16, 0x05, 0x00,
+0x01, 0x00, 0x42, 0x30, 0x14, 0x00, 0x40, 0x10, 0x00, 0xC0, 0x02, 0x3C,
+0x24, 0x10, 0xA2, 0x00, 0x43, 0x00, 0x40, 0x14, 0xC2, 0x15, 0x04, 0x00,
+0x01, 0x00, 0x42, 0x30, 0x50, 0x00, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x0C, 0xE5, 0x63, 0x24, 0x21, 0x18, 0xC3, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x08, 0x5E, 0x85, 0x90, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x10, 0x45, 0x00, 0x47, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x24, 0x10, 0xA2, 0x00, 0x1E, 0x00, 0x40, 0x10,
+0xC2, 0x15, 0x04, 0x00, 0x02, 0x80, 0x06, 0x3C, 0x07, 0x5E, 0xC2, 0x90,
+0xFD, 0xFF, 0x03, 0x24, 0x42, 0xB0, 0x04, 0x3C, 0x24, 0x10, 0x43, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0xC2, 0xA0, 0x0B, 0x5E, 0x60, 0xA0,
+0x00, 0x00, 0x82, 0x90, 0xEF, 0xFF, 0x03, 0x24, 0x03, 0x00, 0x85, 0x34,
+0x24, 0x10, 0x43, 0x00, 0x40, 0x00, 0x03, 0x24, 0x00, 0x00, 0x82, 0xA0,
+0x00, 0x00, 0xA3, 0xA0, 0x07, 0x5E, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x42, 0x30, 0xE6, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C,
+0x05, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0x01, 0x00, 0x42, 0x30, 0x25, 0x00, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x0C, 0xE5, 0x63, 0x24, 0x21, 0x18, 0xC3, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x08, 0x5E, 0x85, 0x90, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x10, 0x45, 0x00, 0xE7, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x06, 0x3C,
+0x07, 0x5E, 0xC2, 0x90, 0xFE, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x07, 0x5E, 0xC2, 0xA0, 0xD7, 0x30, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x42, 0xB0, 0x07, 0x3C, 0x00, 0x00, 0xE3, 0x90, 0xEF, 0xFF, 0x02, 0x24,
+0x03, 0x00, 0xF0, 0x34, 0x24, 0x18, 0x62, 0x00, 0x40, 0x00, 0x02, 0x24,
+0x00, 0x00, 0xE3, 0xA0, 0x02, 0x00, 0x04, 0x24, 0x00, 0x00, 0x02, 0xA2,
+0x21, 0x28, 0x00, 0x00, 0xB9, 0x20, 0x00, 0x0C, 0x00, 0xF0, 0x06, 0x34,
+0x44, 0x00, 0x02, 0x24, 0x00, 0x00, 0x02, 0xA2, 0xC1, 0x30, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x01, 0x00, 0x04, 0x24, 0xE1, 0x51, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0x02, 0x80, 0x06, 0x3C, 0x07, 0x5E, 0xC2, 0x90, 0xFE, 0xFF, 0x03, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x07, 0x5E, 0xC2, 0xA0, 0xD7, 0x30, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x82, 0x16, 0x05, 0x00, 0xE8, 0xFF, 0xBD, 0x27,
+0x01, 0x00, 0x42, 0x30, 0x14, 0x00, 0xBF, 0xAF, 0x0E, 0x00, 0x40, 0x10,
+0x10, 0x00, 0xB0, 0xAF, 0x00, 0xC0, 0x02, 0x3C, 0x24, 0x10, 0xA2, 0x00,
+0x37, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x06, 0x5E, 0x43, 0x90,
+0x02, 0x00, 0x02, 0x24, 0xFF, 0x00, 0x63, 0x30, 0x44, 0x00, 0x62, 0x10,
+0x01, 0x00, 0x04, 0x24, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0xE1, 0x51, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0x00, 0xC0, 0x02, 0x3C,
+0x24, 0x10, 0xA2, 0x00, 0x0E, 0x00, 0x40, 0x14, 0x02, 0x80, 0x06, 0x3C,
+0x07, 0x5E, 0xC2, 0x90, 0xFE, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x07, 0x5E, 0xC2, 0xA0, 0x07, 0x5E, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x00, 0x42, 0x30, 0x18, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x07, 0x5E, 0xC2, 0x90, 0xFD, 0xFF, 0x03, 0x24,
+0x42, 0xB0, 0x04, 0x3C, 0x24, 0x10, 0x43, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x07, 0x5E, 0xC2, 0xA0, 0x0B, 0x5E, 0x60, 0xA0, 0x00, 0x00, 0x82, 0x90,
+0xEF, 0xFF, 0x03, 0x24, 0x03, 0x00, 0x85, 0x34, 0x24, 0x10, 0x43, 0x00,
+0x40, 0x00, 0x03, 0x24, 0x00, 0x00, 0x82, 0xA0, 0x00, 0x00, 0xA3, 0xA0,
+0x07, 0x5E, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x42, 0x30,
+0xEA, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x05, 0x5E, 0x40, 0xA0,
+0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x05, 0x24, 0xFF, 0x00, 0x84, 0x30,
+0x4B, 0x2E, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0x42, 0xB0, 0x07, 0x3C,
+0x00, 0x00, 0xE3, 0x90, 0xEF, 0xFF, 0x02, 0x24, 0x03, 0x00, 0xF0, 0x34,
+0x24, 0x18, 0x62, 0x00, 0x40, 0x00, 0x02, 0x24, 0x00, 0x00, 0xE3, 0xA0,
+0x02, 0x00, 0x04, 0x24, 0x00, 0x00, 0x02, 0xA2, 0x21, 0x28, 0x00, 0x00,
+0xB9, 0x20, 0x00, 0x0C, 0x00, 0xF0, 0x06, 0x34, 0x44, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x02, 0xA2, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xE2, 0x2C, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x0C, 0x00, 0x04, 0x24, 0x01, 0x00, 0x05, 0x24, 0x4B, 0x2E, 0x00, 0x08,
+0x18, 0x00, 0xBD, 0x27, 0x01, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x03, 0x3C,
+0xE8, 0xFF, 0xBD, 0x27, 0xB4, 0xC5, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34,
+0x10, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x62, 0xAC, 0x02, 0x80, 0x10, 0x3C,
+0xED, 0x5D, 0x02, 0x92, 0x14, 0x00, 0xBF, 0xAF, 0x0F, 0x00, 0x42, 0x30,
+0x03, 0x00, 0x42, 0x28, 0x05, 0x00, 0x40, 0x10, 0x01, 0x00, 0x05, 0x24,
+0x59, 0x2D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x40, 0x10,
+0x01, 0x00, 0x05, 0x24, 0xED, 0x5D, 0x04, 0x92, 0x4B, 0x2E, 0x00, 0x0C,
+0xFF, 0x00, 0x84, 0x30, 0x02, 0x80, 0x04, 0x3C, 0x60, 0x1B, 0x84, 0x24,
+0xE0, 0x1B, 0x83, 0x94, 0xDC, 0x1B, 0x85, 0x94, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x02, 0x00, 0x63, 0x30, 0x41, 0xB0, 0x02, 0x3C,
+0x25, 0x18, 0x65, 0x00, 0x08, 0x00, 0x42, 0x34, 0x18, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0x43, 0xA4, 0x08, 0x00, 0xE0, 0x03, 0xDC, 0x1B, 0x83, 0xA4,
+0xE0, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x02, 0x3C, 0x01, 0x80, 0x03, 0x3C,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x03, 0x52, 0x34, 0x40, 0xC6, 0x71, 0x24,
+0x02, 0x80, 0x10, 0x3C, 0x08, 0x14, 0x04, 0x26, 0x21, 0x28, 0x00, 0x00,
+0x21, 0x30, 0x00, 0x00, 0x21, 0x38, 0x00, 0x00, 0x00, 0x00, 0x51, 0xAE,
+0x76, 0x39, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x31, 0x00, 0x08,
+0x08, 0x14, 0x04, 0x26, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0xFF, 0xFF, 0x90, 0x30, 0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x06, 0x3C, 0x60, 0x1B, 0xCD, 0x24,
+0x2A, 0x1C, 0xA2, 0x91, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x40, 0x10,
+0x2A, 0xB0, 0x02, 0x3C, 0x25, 0xB0, 0x03, 0x3C, 0x38, 0x02, 0x64, 0x34,
+0x80, 0xFF, 0x02, 0x24, 0x00, 0x00, 0x82, 0xA0, 0x34, 0x02, 0x6A, 0x34,
+0xD2, 0x01, 0x65, 0x34, 0xD6, 0x01, 0x66, 0x34, 0xDA, 0x01, 0x67, 0x34,
+0xDE, 0x01, 0x63, 0x34, 0x00, 0x00, 0xA8, 0x94, 0x00, 0x00, 0xC9, 0x94,
+0x00, 0x00, 0xEB, 0x94, 0x00, 0x00, 0x6C, 0x94, 0x00, 0x00, 0x44, 0x95,
+0xB0, 0xFE, 0x02, 0x26, 0xFF, 0xFF, 0x50, 0x30, 0x28, 0x1C, 0xA4, 0xA5,
+0x00, 0x00, 0xA0, 0xA4, 0x10, 0x00, 0xA4, 0x27, 0x20, 0x1C, 0xA8, 0xA5,
+0x00, 0x00, 0xC0, 0xA4, 0x22, 0x1C, 0xA9, 0xA5, 0x00, 0x00, 0xE0, 0xA4,
+0x24, 0x1C, 0xAB, 0xA5, 0x00, 0x00, 0x60, 0xA4, 0x00, 0x00, 0x50, 0xA5,
+0x90, 0x40, 0x00, 0x0C, 0x26, 0x1C, 0xAC, 0xA5, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x0A, 0x00, 0x45, 0x34, 0x63, 0x00, 0x03, 0x24, 0xFF, 0xFF, 0x04, 0x34,
+0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x40, 0x10,
+0x64, 0x00, 0x02, 0x24, 0xFF, 0xFF, 0x42, 0x24, 0xFF, 0xFF, 0x42, 0x30,
+0xFE, 0xFF, 0x40, 0x14, 0xFF, 0xFF, 0x42, 0x24, 0xFF, 0xFF, 0x62, 0x24,
+0xFF, 0xFF, 0x43, 0x30, 0xF5, 0xFF, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0xC2, 0x24, 0x28, 0x1C, 0x48, 0x94, 0x26, 0x1C, 0x47, 0x94,
+0x20, 0x1C, 0x49, 0x94, 0x22, 0x1C, 0x4A, 0x94, 0x24, 0x1C, 0x4B, 0x94,
+0x25, 0xB0, 0x03, 0x3C, 0x38, 0x02, 0x6C, 0x34, 0x34, 0x02, 0x62, 0x34,
+0xD2, 0x01, 0x64, 0x34, 0xD6, 0x01, 0x65, 0x34, 0xDA, 0x01, 0x66, 0x34,
+0xDE, 0x01, 0x63, 0x34, 0x00, 0x00, 0x48, 0xA4, 0x00, 0x00, 0x89, 0xA4,
+0x00, 0x00, 0xAA, 0xA4, 0x10, 0x00, 0xA4, 0x27, 0x00, 0x00, 0xCB, 0xA4,
+0x00, 0x00, 0x67, 0xA4, 0x00, 0x00, 0x80, 0xA1, 0x90, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27,
+0x28, 0x00, 0xB4, 0xAF, 0x2C, 0x00, 0xBF, 0xAF, 0x24, 0x00, 0xB3, 0xAF,
+0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF,
+0xFF, 0xFF, 0x14, 0x24, 0x02, 0x80, 0x13, 0x3C, 0x41, 0xB0, 0x02, 0x3C,
+0x60, 0x1B, 0x63, 0x26, 0x04, 0x00, 0x42, 0x34, 0x00, 0x00, 0x45, 0x8C,
+0xD4, 0x1B, 0x64, 0x8C, 0xD0, 0x1B, 0x66, 0x8C, 0x02, 0x80, 0x02, 0x3C,
+0xF0, 0x5C, 0x47, 0x90, 0x25, 0xB0, 0x08, 0x3C, 0xB0, 0x03, 0x02, 0x35,
+0x25, 0x90, 0x85, 0x00, 0x00, 0x00, 0x52, 0xAC, 0x00, 0x00, 0x46, 0xAC,
+0x01, 0x00, 0x02, 0x24, 0x89, 0x03, 0xE2, 0x10, 0xD4, 0x1B, 0x72, 0xAC,
+0x60, 0x1B, 0x64, 0x26, 0xD0, 0x1B, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x10, 0x52, 0x00, 0x01, 0x00, 0x42, 0x30, 0x0E, 0x00, 0x40, 0x10,
+0x60, 0x1B, 0x67, 0x26, 0x25, 0xB0, 0x10, 0x3C, 0xB0, 0x03, 0x02, 0x36,
+0x01, 0x00, 0x05, 0x24, 0x00, 0x00, 0x45, 0xAC, 0x04, 0x00, 0x0B, 0x36,
+0xD4, 0x1B, 0x83, 0x8C, 0x00, 0x00, 0x69, 0x8D, 0x40, 0x00, 0x02, 0x3C,
+0x01, 0x00, 0x63, 0x38, 0x24, 0x10, 0x22, 0x01, 0x26, 0x01, 0x40, 0x10,
+0xD4, 0x1B, 0x83, 0xAC, 0x60, 0x1B, 0x67, 0x26, 0xD0, 0x1B, 0xE2, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x52, 0x00, 0x04, 0x00, 0x42, 0x30,
+0x14, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x71, 0x26, 0x25, 0xB0, 0x03, 0x3C,
+0xB0, 0x03, 0x64, 0x34, 0x04, 0x00, 0x02, 0x24, 0x00, 0x00, 0x82, 0xAC,
+0xD4, 0x1B, 0xE2, 0x8C, 0xC4, 0x38, 0xE6, 0x8C, 0xFC, 0x00, 0x63, 0x34,
+0xAC, 0x1B, 0xE4, 0x94, 0x00, 0x00, 0x65, 0x8C, 0x04, 0x00, 0x42, 0x38,
+0x21, 0x48, 0xC4, 0x00, 0x06, 0x00, 0xA9, 0x10, 0xD4, 0x1B, 0xE2, 0xAC,
+0x02, 0x80, 0x03, 0x3C, 0xB0, 0x5D, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x42, 0x34, 0xB0, 0x5D, 0x62, 0xAC, 0x60, 0x1B, 0x71, 0x26,
+0xD0, 0x1B, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x52, 0x00,
+0x08, 0x00, 0x42, 0x30, 0x0A, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xB0, 0x1B, 0x22, 0x96, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x42, 0x30,
+0x5D, 0x03, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0xD4, 0x1B, 0x22, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x42, 0x38, 0xD4, 0x1B, 0x22, 0xAE,
+0x60, 0x1B, 0x70, 0x26, 0xD0, 0x1B, 0x02, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x20, 0x52, 0x00, 0x00, 0x08, 0x83, 0x30, 0x06, 0x00, 0x60, 0x10,
+0x00, 0x10, 0x82, 0x30, 0xD4, 0x1B, 0x02, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x08, 0x42, 0x38, 0xD4, 0x1B, 0x02, 0xAE, 0x00, 0x10, 0x82, 0x30,
+0x05, 0x03, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x70, 0x26,
+0xD0, 0x1B, 0x03, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x72, 0x00,
+0x00, 0x20, 0x42, 0x30, 0xF7, 0x02, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x10, 0x72, 0x00, 0x00, 0x80, 0x42, 0x30, 0xB9, 0x01, 0x40, 0x14,
+0x01, 0x00, 0x03, 0x3C, 0x60, 0x1B, 0x70, 0x26, 0xD0, 0x1B, 0x02, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x54, 0x00,
+0x24, 0x10, 0x43, 0x00, 0xF1, 0x01, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0xD0, 0x1B, 0x02, 0x8E, 0x02, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x43, 0x00, 0x28, 0x02, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x70, 0x26, 0xD0, 0x1B, 0x02, 0x8E, 0x04, 0x00, 0x03, 0x3C,
+0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x54, 0x00, 0x24, 0x10, 0x43, 0x00,
+0x62, 0x02, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x70, 0x26,
+0xD0, 0x1B, 0x02, 0x8E, 0x08, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x43, 0x00, 0x9B, 0x02, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x70, 0x26, 0xD0, 0x1B, 0x02, 0x8E, 0x10, 0x00, 0x03, 0x3C,
+0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x54, 0x00, 0x24, 0x10, 0x43, 0x00,
+0x5A, 0x01, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x70, 0x26,
+0xD0, 0x1B, 0x02, 0x8E, 0x20, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x43, 0x00, 0x18, 0x01, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x70, 0x26, 0xD0, 0x1B, 0x02, 0x8E, 0x40, 0x00, 0x03, 0x3C,
+0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x54, 0x00, 0x24, 0x10, 0x43, 0x00,
+0xD6, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x65, 0x26,
+0xD0, 0x1B, 0xA2, 0x8C, 0x00, 0x04, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x43, 0x00, 0x3D, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x66, 0x26,
+0x2A, 0xB0, 0x02, 0x3C, 0x2C, 0x00, 0x43, 0x34, 0x00, 0x00, 0x69, 0x8C,
+0xFF, 0x00, 0x02, 0x24, 0xFF, 0x00, 0x24, 0x31, 0x29, 0x03, 0x82, 0x10,
+0x00, 0x80, 0x22, 0x31, 0xF9, 0x02, 0x40, 0x14, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0xFF, 0x02, 0x3C, 0x24, 0x10, 0x22, 0x01, 0x0B, 0x00, 0x40, 0x10,
+0xFF, 0x00, 0x02, 0x24, 0xAC, 0x37, 0xA2, 0x90, 0x20, 0xB0, 0x03, 0x3C,
+0x00, 0x12, 0x02, 0x00, 0x21, 0x10, 0x43, 0x00, 0x0C, 0x00, 0x49, 0x8C,
+0x25, 0xB0, 0x03, 0x3C, 0xB0, 0x03, 0x63, 0x34, 0x00, 0x00, 0x69, 0xAC,
+0xFF, 0x00, 0x24, 0x31, 0xFF, 0x00, 0x02, 0x24, 0x1B, 0x00, 0x82, 0x10,
+0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31, 0x7C, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x10, 0x38, 0x03, 0xAE, 0x0A, 0x00, 0x04, 0x24,
+0xAC, 0x37, 0x09, 0xA2, 0x00, 0x01, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0xD0, 0x1B, 0x05, 0x8E, 0x02, 0x80, 0x06, 0x3C,
+0xB0, 0x5D, 0xC4, 0x8C, 0x00, 0x04, 0x02, 0x3C, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x28, 0xA2, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x00, 0x80, 0x84, 0x34,
+0xB0, 0x03, 0x42, 0x34, 0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x44, 0xAC,
+0x00, 0x00, 0x65, 0xAC, 0xB0, 0x5D, 0xC4, 0xAC, 0xD0, 0x1B, 0x05, 0xAE,
+0x60, 0x1B, 0x65, 0x26, 0xD4, 0x1B, 0xA4, 0x8C, 0x00, 0x04, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x26, 0x20, 0x83, 0x00, 0xB0, 0x03, 0x42, 0x34,
+0x00, 0x00, 0x44, 0xAC, 0xD4, 0x1B, 0xA4, 0xAC, 0x60, 0x1B, 0x66, 0x26,
+0xD0, 0x1B, 0xC7, 0x8C, 0x00, 0x08, 0x04, 0x3C, 0x24, 0x28, 0xF2, 0x00,
+0x24, 0x10, 0xA4, 0x00, 0x08, 0x00, 0x40, 0x10, 0x80, 0x00, 0x08, 0x3C,
+0xD4, 0x1B, 0xC3, 0x8C, 0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34,
+0x26, 0x18, 0x64, 0x00, 0x00, 0x00, 0x44, 0xAC, 0xD4, 0x1B, 0xC3, 0xAC,
+0x80, 0x00, 0x08, 0x3C, 0x24, 0x10, 0xA8, 0x00, 0x21, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xD4, 0x1B, 0xC3, 0x8C, 0x25, 0xB0, 0x09, 0x3C,
+0xB0, 0x03, 0x2A, 0x35, 0x2A, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x43, 0xAD,
+0x36, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x90, 0x23, 0xB0, 0x04, 0x3C,
+0xFF, 0x1F, 0x02, 0x3C, 0xC0, 0x18, 0x03, 0x00, 0xF0, 0x07, 0x63, 0x30,
+0xF4, 0x38, 0xC5, 0x8C, 0x21, 0x18, 0x64, 0x00, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x18, 0x62, 0x00, 0xCE, 0x02, 0x65, 0x10, 0xF8, 0x38, 0xC3, 0xAC,
+0x02, 0x80, 0x05, 0x3C, 0xB0, 0x5D, 0xA3, 0x8C, 0x27, 0x20, 0x08, 0x00,
+0x24, 0x20, 0xE4, 0x00, 0x00, 0x10, 0x63, 0x34, 0x41, 0xB0, 0x02, 0x3C,
+0x00, 0x00, 0x43, 0xAD, 0x00, 0x00, 0x44, 0xAC, 0xB0, 0x5D, 0xA3, 0xAC,
+0xD0, 0x1B, 0xC4, 0xAC, 0x60, 0x1B, 0x62, 0x26, 0xD4, 0x1B, 0x43, 0x8C,
+0x80, 0x00, 0x04, 0x3C, 0x26, 0x18, 0x64, 0x00, 0xD4, 0x1B, 0x43, 0xAC,
+0x60, 0x1B, 0x66, 0x26, 0xD0, 0x1B, 0xC3, 0x8C, 0x00, 0x01, 0x05, 0x3C,
+0x24, 0x20, 0x72, 0x00, 0x24, 0x10, 0x85, 0x00, 0x06, 0x00, 0x40, 0x10,
+0x25, 0xB0, 0x02, 0x3C, 0xD4, 0x1B, 0xC3, 0x8C, 0xB0, 0x03, 0x42, 0x34,
+0x26, 0x18, 0x65, 0x00, 0x00, 0x00, 0x45, 0xAC, 0xD4, 0x1B, 0xC3, 0xAC,
+0x00, 0x02, 0x05, 0x3C, 0x24, 0x10, 0x85, 0x00, 0x06, 0x00, 0x40, 0x10,
+0x25, 0xB0, 0x02, 0x3C, 0xD4, 0x1B, 0xC3, 0x8C, 0xB0, 0x03, 0x42, 0x34,
+0x26, 0x18, 0x65, 0x00, 0x00, 0x00, 0x45, 0xAC, 0xD4, 0x1B, 0xC3, 0xAC,
+0x00, 0x10, 0x05, 0x3C, 0x24, 0x10, 0x85, 0x00, 0x0C, 0x00, 0x40, 0x10,
+0x60, 0x1B, 0x63, 0x26, 0xB0, 0x1B, 0xC3, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x62, 0x30, 0x02, 0x00, 0x40, 0x10, 0x00, 0x08, 0x62, 0x34,
+0xB0, 0x1B, 0xC2, 0xA4, 0xD4, 0x1B, 0xC2, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x26, 0x10, 0x45, 0x00, 0xD4, 0x1B, 0xC2, 0xAC, 0x60, 0x1B, 0x63, 0x26,
+0xD0, 0x1B, 0x62, 0x8C, 0x00, 0x20, 0x05, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x45, 0x00, 0x0B, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xB0, 0x1B, 0x64, 0x94, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x82, 0x30,
+0x02, 0x00, 0x40, 0x10, 0xFF, 0xF7, 0x82, 0x30, 0xB0, 0x1B, 0x62, 0xA4,
+0xD4, 0x1B, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x26, 0x10, 0x45, 0x00,
+0xD4, 0x1B, 0x62, 0xAC, 0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0x20, 0xBD, 0x02, 0x3C, 0xEC, 0x02, 0x03, 0x36, 0x4D, 0x00, 0x07, 0x36,
+0xF1, 0x02, 0x08, 0x36, 0x08, 0x00, 0x06, 0x24, 0x78, 0x02, 0x42, 0x34,
+0x00, 0x00, 0x45, 0xA4, 0x00, 0x00, 0xE0, 0xA0, 0x00, 0x00, 0x06, 0xA1,
+0x00, 0x00, 0x60, 0xAC, 0x00, 0x00, 0x62, 0x8C, 0xFF, 0x00, 0x04, 0x3C,
+0x00, 0x00, 0xE0, 0xA0, 0xFF, 0x00, 0x49, 0x30, 0x25, 0x48, 0x24, 0x01,
+0x00, 0x00, 0x06, 0xA1, 0xF2, 0x02, 0x05, 0x36, 0x00, 0x00, 0x64, 0xAC,
+0x0A, 0x00, 0x0A, 0x36, 0x00, 0x00, 0x69, 0xAC, 0x80, 0xFF, 0x03, 0x24,
+0x00, 0x00, 0xA0, 0xA0, 0x00, 0x00, 0x43, 0xA1, 0x00, 0x00, 0x62, 0x8D,
+0x80, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x43, 0x00, 0x02, 0x00, 0x40, 0x10,
+0x84, 0xFF, 0x02, 0x24, 0x00, 0x00, 0x42, 0xA1, 0x2C, 0x1F, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x02, 0x00, 0x02, 0x36, 0x00, 0x00, 0x43, 0x94,
+0xFF, 0xBF, 0x04, 0x24, 0x24, 0x18, 0x64, 0x00, 0x00, 0x00, 0x43, 0xA4,
+0x25, 0x32, 0x00, 0x08, 0x60, 0x1B, 0x67, 0x26, 0x70, 0x30, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x2A, 0xB0, 0x06, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0x00, 0x00, 0x54, 0xAC, 0x28, 0x00, 0xC3, 0x34,
+0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x05, 0x24, 0xFF, 0x00, 0x24, 0x31,
+0x6D, 0x03, 0x85, 0x10, 0x25, 0xBD, 0x02, 0x3C, 0x00, 0x80, 0x22, 0x31,
+0x59, 0x02, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x21, 0x00, 0x82, 0x10,
+0xFF, 0x00, 0x23, 0x31, 0x60, 0x1B, 0x70, 0x26, 0x4C, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x98, 0x37, 0x09, 0xA2, 0xE0, 0x37, 0x03, 0xAE,
+0x06, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x09, 0x3C, 0xC0, 0x5D, 0x27, 0x91,
+0x02, 0x80, 0x08, 0x3C, 0xB0, 0x5D, 0x05, 0x8D, 0xD0, 0x1B, 0x06, 0x8E,
+0x60, 0x00, 0x02, 0x3C, 0x02, 0x00, 0xE7, 0x34, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x30, 0xC2, 0x00, 0x00, 0x08, 0xA5, 0x34, 0x00, 0x26, 0x07, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x42, 0x34,
+0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x66, 0xAC,
+0xB0, 0x5D, 0x05, 0xAD, 0xC0, 0x5D, 0x27, 0xA1, 0xD0, 0x1B, 0x06, 0xAE,
+0x60, 0x1B, 0x62, 0x26, 0xD4, 0x1B, 0x43, 0x8C, 0x40, 0x00, 0x04, 0x3C,
+0x26, 0x18, 0x64, 0x00, 0x9A, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x43, 0xAC,
+0x70, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x05, 0x3C,
+0x24, 0x00, 0xA3, 0x34, 0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x06, 0x24,
+0xFF, 0x00, 0x24, 0x31, 0x48, 0x03, 0x86, 0x10, 0x25, 0xB0, 0x02, 0x3C,
+0x00, 0x80, 0x22, 0x31, 0x64, 0x02, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24,
+0x25, 0x00, 0x82, 0x10, 0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31,
+0x4C, 0x38, 0x05, 0x8E, 0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x21, 0x30, 0x60, 0x00, 0x94, 0x37, 0x09, 0xA2,
+0xE0, 0x37, 0x03, 0xAE, 0x06, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x0A, 0x3C,
+0xC0, 0x5D, 0x47, 0x91, 0x02, 0x80, 0x09, 0x3C, 0xB0, 0x5D, 0x25, 0x8D,
+0xD0, 0x1B, 0x06, 0x8E, 0x60, 0x00, 0x02, 0x3C, 0x04, 0x00, 0xE7, 0x34,
+0x27, 0x10, 0x02, 0x00, 0x24, 0x30, 0xC2, 0x00, 0x00, 0x08, 0xA5, 0x34,
+0x25, 0xB0, 0x03, 0x3C, 0x40, 0x00, 0x02, 0x3C, 0x00, 0x26, 0x07, 0x00,
+0x26, 0xA0, 0x82, 0x02, 0xB0, 0x03, 0x68, 0x34, 0x25, 0x20, 0x85, 0x00,
+0x80, 0x03, 0x63, 0x34, 0x41, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x64, 0xAC,
+0x00, 0x00, 0x46, 0xAC, 0xB0, 0x5D, 0x25, 0xAD, 0xC0, 0x5D, 0x47, 0xA1,
+0xD0, 0x1B, 0x06, 0xAE, 0x00, 0x00, 0x14, 0xAD, 0x60, 0x1B, 0x62, 0x26,
+0xD4, 0x1B, 0x43, 0x8C, 0x20, 0x00, 0x04, 0x3C, 0x26, 0x18, 0x64, 0x00,
+0x92, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x43, 0xAC, 0x70, 0x30, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x05, 0x3C, 0xB0, 0x03, 0xA2, 0x34,
+0x2A, 0xB0, 0x07, 0x3C, 0x00, 0x00, 0x54, 0xAC, 0x20, 0x00, 0xE3, 0x34,
+0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x06, 0x24, 0xFF, 0x00, 0x24, 0x31,
+0x07, 0x03, 0x86, 0x10, 0x90, 0x03, 0xA2, 0x34, 0x00, 0x80, 0x22, 0x31,
+0x05, 0x02, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x21, 0x00, 0x82, 0x10,
+0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31, 0x40, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x9C, 0x37, 0x09, 0xA2, 0xD4, 0x37, 0x03, 0xAE,
+0x05, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x09, 0x3C, 0xC0, 0x5D, 0x27, 0x91,
+0x02, 0x80, 0x08, 0x3C, 0xB0, 0x5D, 0x05, 0x8D, 0xD0, 0x1B, 0x06, 0x8E,
+0x18, 0x00, 0x02, 0x3C, 0x01, 0x00, 0xE7, 0x34, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x30, 0xC2, 0x00, 0x00, 0x04, 0xA5, 0x34, 0x00, 0x26, 0x07, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x42, 0x34,
+0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x66, 0xAC,
+0xB0, 0x5D, 0x05, 0xAD, 0xC0, 0x5D, 0x27, 0xA1, 0xD0, 0x1B, 0x06, 0xAE,
+0x60, 0x1B, 0x62, 0x26, 0xD4, 0x1B, 0x43, 0x8C, 0x10, 0x00, 0x04, 0x3C,
+0x26, 0x18, 0x64, 0x00, 0x8B, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x43, 0xAC,
+0x70, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x05, 0x3C,
+0x0C, 0x00, 0xA3, 0x34, 0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x06, 0x24,
+0xFF, 0x00, 0x24, 0x31, 0xC6, 0x02, 0x86, 0x10, 0x00, 0x80, 0x22, 0x31,
+0x54, 0x02, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x24, 0x00, 0x82, 0x10,
+0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31, 0x28, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x80, 0x37, 0x09, 0xA2, 0xBC, 0x37, 0x03, 0xAE,
+0x03, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x0A, 0x3C, 0xC0, 0x5D, 0x47, 0x91,
+0x02, 0x80, 0x09, 0x3C, 0xB0, 0x5D, 0x25, 0x8D, 0xD0, 0x1B, 0x06, 0x8E,
+0x01, 0x00, 0x08, 0x3C, 0x80, 0xFF, 0x02, 0x24, 0x25, 0x38, 0xE2, 0x00,
+0x00, 0x80, 0x03, 0x35, 0x00, 0x01, 0xA5, 0x34, 0x27, 0x18, 0x03, 0x00,
+0x00, 0x26, 0x07, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x24, 0x30, 0xC3, 0x00,
+0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x42, 0x34, 0x41, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0x44, 0xAC, 0x27, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0xAC,
+0xB0, 0x5D, 0x25, 0xAD, 0xC0, 0x5D, 0x47, 0xA1, 0xD0, 0x1B, 0x06, 0xAE,
+0x60, 0x1B, 0x63, 0x26, 0xD4, 0x1B, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x80, 0x42, 0x38, 0xD4, 0x1B, 0x62, 0xAC, 0x60, 0x1B, 0x70, 0x26,
+0xD0, 0x1B, 0x02, 0x8E, 0x01, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x54, 0x00, 0x24, 0x10, 0x43, 0x00, 0x11, 0xFE, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x70, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x2A, 0xB0, 0x05, 0x3C, 0x10, 0x00, 0xA3, 0x34, 0x00, 0x00, 0x69, 0x8C,
+0xFF, 0x00, 0x06, 0x24, 0xFF, 0x00, 0x24, 0x31, 0x7C, 0x02, 0x86, 0x10,
+0x25, 0xB0, 0x02, 0x3C, 0x00, 0x80, 0x22, 0x31, 0xD0, 0x01, 0x40, 0x10,
+0x00, 0x80, 0x02, 0x3C, 0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24,
+0x22, 0x00, 0x82, 0x10, 0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31,
+0x28, 0x38, 0x05, 0x8E, 0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x21, 0x30, 0x60, 0x00, 0x84, 0x37, 0x09, 0xA2,
+0xBC, 0x37, 0x03, 0xAE, 0x03, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x09, 0x3C,
+0xC0, 0x5D, 0x27, 0x91, 0x02, 0x80, 0x08, 0x3C, 0xB0, 0x5D, 0x05, 0x8D,
+0xD0, 0x1B, 0x06, 0x8E, 0x01, 0x00, 0x02, 0x3C, 0x00, 0x80, 0x42, 0x34,
+0x40, 0x00, 0xE7, 0x34, 0x27, 0x10, 0x02, 0x00, 0x24, 0x30, 0xC2, 0x00,
+0x00, 0x01, 0xA5, 0x34, 0x00, 0x26, 0x07, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x42, 0x34, 0x41, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x66, 0xAC, 0xB0, 0x5D, 0x05, 0xAD,
+0xC0, 0x5D, 0x27, 0xA1, 0xD0, 0x1B, 0x06, 0xAE, 0x60, 0x1B, 0x62, 0x26,
+0xD4, 0x1B, 0x43, 0x8C, 0x01, 0x00, 0x04, 0x3C, 0x60, 0x1B, 0x70, 0x26,
+0x26, 0x18, 0x64, 0x00, 0xD4, 0x1B, 0x43, 0xAC, 0xD0, 0x1B, 0x02, 0x8E,
+0x02, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x43, 0x00,
+0xDB, 0xFD, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x70, 0x30, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x05, 0x3C, 0x14, 0x00, 0xA3, 0x34,
+0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x06, 0x24, 0xFF, 0x00, 0x24, 0x31,
+0x64, 0x02, 0x86, 0x10, 0x25, 0xB0, 0x02, 0x3C, 0x00, 0x80, 0x22, 0x31,
+0xFA, 0x01, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x25, 0x00, 0x82, 0x10,
+0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31, 0x34, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x88, 0x37, 0x09, 0xA2, 0xC8, 0x37, 0x03, 0xAE,
+0x04, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x0A, 0x3C, 0xC0, 0x5D, 0x47, 0x91,
+0x02, 0x80, 0x09, 0x3C, 0xB0, 0x5D, 0x25, 0x8D, 0xD0, 0x1B, 0x06, 0x8E,
+0x06, 0x00, 0x02, 0x3C, 0x20, 0x00, 0xE7, 0x34, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x30, 0xC2, 0x00, 0x00, 0x02, 0xA5, 0x34, 0x25, 0xB0, 0x03, 0x3C,
+0x04, 0x00, 0x02, 0x3C, 0x00, 0x26, 0x07, 0x00, 0x26, 0xA0, 0x82, 0x02,
+0xB0, 0x03, 0x68, 0x34, 0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x63, 0x34,
+0x41, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x64, 0xAC, 0x00, 0x00, 0x46, 0xAC,
+0xB0, 0x5D, 0x25, 0xAD, 0xC0, 0x5D, 0x47, 0xA1, 0xD0, 0x1B, 0x06, 0xAE,
+0x00, 0x00, 0x14, 0xAD, 0x60, 0x1B, 0x62, 0x26, 0xD4, 0x1B, 0x43, 0x8C,
+0x02, 0x00, 0x04, 0x3C, 0x60, 0x1B, 0x70, 0x26, 0x26, 0x18, 0x64, 0x00,
+0xD4, 0x1B, 0x43, 0xAC, 0xD0, 0x1B, 0x02, 0x8E, 0x04, 0x00, 0x03, 0x3C,
+0x24, 0x10, 0x52, 0x00, 0x24, 0x10, 0x54, 0x00, 0x24, 0x10, 0x43, 0x00,
+0xA1, 0xFD, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x70, 0x30, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x03, 0x3C, 0xB0, 0x03, 0x62, 0x34,
+0x2A, 0xB0, 0x07, 0x3C, 0x00, 0x00, 0x54, 0xAC, 0x18, 0x00, 0xE5, 0x34,
+0x00, 0x00, 0xA9, 0x8C, 0xFF, 0x00, 0x06, 0x24, 0xFF, 0x00, 0x24, 0x31,
+0x16, 0x02, 0x86, 0x10, 0x04, 0x00, 0x02, 0x24, 0x00, 0x80, 0x22, 0x31,
+0xD6, 0x01, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0xA2, 0xAC, 0xFF, 0x00, 0x02, 0x24, 0x21, 0x00, 0x82, 0x10,
+0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31, 0x34, 0x38, 0x05, 0x8E,
+0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00,
+0x21, 0x30, 0x60, 0x00, 0x8C, 0x37, 0x09, 0xA2, 0xC8, 0x37, 0x03, 0xAE,
+0x04, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C,
+0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x09, 0x3C, 0xC0, 0x5D, 0x27, 0x91,
+0x02, 0x80, 0x08, 0x3C, 0xB0, 0x5D, 0x05, 0x8D, 0xD0, 0x1B, 0x06, 0x8E,
+0x06, 0x00, 0x02, 0x3C, 0x10, 0x00, 0xE7, 0x34, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x30, 0xC2, 0x00, 0x00, 0x02, 0xA5, 0x34, 0x00, 0x26, 0x07, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x25, 0x20, 0x85, 0x00, 0x80, 0x03, 0x42, 0x34,
+0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x66, 0xAC,
+0xB0, 0x5D, 0x05, 0xAD, 0xC0, 0x5D, 0x27, 0xA1, 0xD0, 0x1B, 0x06, 0xAE,
+0x60, 0x1B, 0x62, 0x26, 0xD4, 0x1B, 0x43, 0x8C, 0x04, 0x00, 0x04, 0x3C,
+0x60, 0x1B, 0x70, 0x26, 0x26, 0x18, 0x64, 0x00, 0xD4, 0x1B, 0x43, 0xAC,
+0xD0, 0x1B, 0x02, 0x8E, 0x08, 0x00, 0x03, 0x3C, 0x24, 0x10, 0x52, 0x00,
+0x24, 0x10, 0x43, 0x00, 0x68, 0xFD, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x70, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x05, 0x3C,
+0x1C, 0x00, 0xA3, 0x34, 0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x06, 0x24,
+0xFF, 0x00, 0x24, 0x31, 0xDD, 0x01, 0x86, 0x10, 0x25, 0xB0, 0x02, 0x3C,
+0x00, 0x80, 0x22, 0x31, 0x33, 0x01, 0x40, 0x10, 0x00, 0xFF, 0x02, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x00, 0x00, 0x62, 0xAC, 0xFF, 0x00, 0x02, 0x24,
+0x25, 0x00, 0x82, 0x10, 0x60, 0x1B, 0x70, 0x26, 0xFF, 0x00, 0x23, 0x31,
+0x40, 0x38, 0x05, 0x8E, 0x20, 0x10, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x21, 0x30, 0x60, 0x00, 0x90, 0x37, 0x09, 0xA2,
+0xD4, 0x37, 0x03, 0xAE, 0x05, 0x00, 0x04, 0x24, 0x80, 0x00, 0x07, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF, 0x02, 0x80, 0x0A, 0x3C,
+0xC0, 0x5D, 0x47, 0x91, 0x02, 0x80, 0x09, 0x3C, 0xB0, 0x5D, 0x25, 0x8D,
+0xD0, 0x1B, 0x06, 0x8E, 0x18, 0x00, 0x02, 0x3C, 0x08, 0x00, 0xE7, 0x34,
+0x27, 0x10, 0x02, 0x00, 0x24, 0x30, 0xC2, 0x00, 0x00, 0x04, 0xA5, 0x34,
+0x25, 0xB0, 0x03, 0x3C, 0x10, 0x00, 0x02, 0x3C, 0x00, 0x26, 0x07, 0x00,
+0x26, 0xA0, 0x82, 0x02, 0xB0, 0x03, 0x68, 0x34, 0x25, 0x20, 0x85, 0x00,
+0x80, 0x03, 0x63, 0x34, 0x41, 0xB0, 0x02, 0x3C, 0x00, 0x00, 0x64, 0xAC,
+0x00, 0x00, 0x46, 0xAC, 0xB0, 0x5D, 0x25, 0xAD, 0xC0, 0x5D, 0x47, 0xA1,
+0xD0, 0x1B, 0x06, 0xAE, 0x00, 0x00, 0x14, 0xAD, 0x60, 0x1B, 0x62, 0x26,
+0xD4, 0x1B, 0x43, 0x8C, 0x08, 0x00, 0x04, 0x3C, 0x26, 0x18, 0x64, 0x00,
+0x83, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x43, 0xAC, 0x70, 0x30, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xD4, 0x1B, 0x02, 0x8E, 0xD0, 0x1B, 0x03, 0x8E,
+0x00, 0x20, 0x42, 0x38, 0x62, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x02, 0xAE,
+0x70, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x2A, 0xB0, 0x02, 0x3C,
+0x08, 0x00, 0x43, 0x34, 0x00, 0x00, 0x69, 0x8C, 0xFF, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x24, 0x31, 0x2C, 0x00, 0x82, 0x10, 0x00, 0x80, 0x22, 0x31,
+0x34, 0x01, 0x40, 0x14, 0x00, 0x80, 0x02, 0x3C, 0x00, 0xFF, 0x02, 0x3C,
+0x24, 0x10, 0x22, 0x01, 0x0B, 0x00, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0xA8, 0x37, 0x02, 0x92, 0x20, 0xB0, 0x03, 0x3C, 0x00, 0x12, 0x02, 0x00,
+0x21, 0x10, 0x43, 0x00, 0x0C, 0x00, 0x49, 0x8C, 0x25, 0xB0, 0x03, 0x3C,
+0xB0, 0x03, 0x63, 0x34, 0x00, 0x00, 0x69, 0xAC, 0xFF, 0x00, 0x24, 0x31,
+0xFF, 0x00, 0x02, 0x24, 0x1A, 0x00, 0x82, 0x10, 0x60, 0x1B, 0x70, 0x26,
+0xFF, 0x00, 0x23, 0x31, 0x70, 0x38, 0x05, 0x8E, 0x20, 0x10, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x21, 0x30, 0x60, 0x00,
+0x04, 0x38, 0x03, 0xAE, 0x01, 0x00, 0x04, 0x24, 0xA8, 0x37, 0x09, 0xA2,
+0x80, 0x00, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA0, 0xAF,
+0xD0, 0x1B, 0x05, 0x8E, 0x02, 0x80, 0x06, 0x3C, 0xB0, 0x5D, 0xC4, 0x8C,
+0xFF, 0xC7, 0x02, 0x24, 0x24, 0x28, 0xA2, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x10, 0x00, 0x84, 0x34, 0x80, 0x03, 0x42, 0x34, 0x41, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x65, 0xAC, 0xB0, 0x5D, 0xC4, 0xAC,
+0xD0, 0x1B, 0x05, 0xAE, 0x60, 0x1B, 0x63, 0x26, 0xD4, 0x1B, 0x62, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x42, 0x38, 0x5B, 0x32, 0x00, 0x08,
+0xD4, 0x1B, 0x62, 0xAC, 0x56, 0x01, 0x02, 0x35, 0x00, 0x00, 0x43, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x74, 0xFC, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x7E, 0x58, 0x00, 0x0C, 0x07, 0x00, 0x04, 0x24, 0x12, 0x32, 0x00, 0x08,
+0x60, 0x1B, 0x64, 0x26, 0x00, 0x00, 0x62, 0xAC, 0xB8, 0x32, 0x00, 0x08,
+0xFF, 0x00, 0x02, 0x24, 0xE4, 0x1D, 0x24, 0x96, 0x58, 0x38, 0x26, 0x96,
+0x01, 0x00, 0x84, 0x24, 0x00, 0x19, 0x04, 0x00, 0x25, 0x30, 0xC2, 0x00,
+0xF0, 0xFF, 0x63, 0x30, 0x20, 0x00, 0xC5, 0x24, 0x02, 0x12, 0x03, 0x00,
+0xE4, 0x1D, 0x24, 0xA6, 0x17, 0x00, 0xA2, 0xA0, 0x16, 0x00, 0xA3, 0xA0,
+0x0C, 0x00, 0xC4, 0x8C, 0x00, 0xF0, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0xFF, 0x0F, 0x63, 0x30, 0x00, 0x1C, 0x03, 0x00, 0x24, 0x20, 0x82, 0x00,
+0x25, 0x20, 0x83, 0x00, 0x0C, 0x00, 0xC4, 0xAC, 0x58, 0x38, 0x25, 0x8E,
+0x01, 0x00, 0x10, 0x24, 0x01, 0x00, 0x04, 0x24, 0x31, 0x10, 0x06, 0x3C,
+0x00, 0x01, 0x07, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF,
+0x5B, 0x01, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24, 0x2A, 0xB0, 0x02, 0x3C,
+0x01, 0x00, 0x42, 0x34, 0x02, 0x00, 0x03, 0x24, 0x00, 0x00, 0x50, 0xA0,
+0x00, 0x00, 0x43, 0xA0, 0xD4, 0x1B, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x42, 0x38, 0x4D, 0x32, 0x00, 0x08, 0xD4, 0x1B, 0x22, 0xAE,
+0xD0, 0x03, 0x23, 0x35, 0x80, 0x00, 0x02, 0x24, 0x00, 0x00, 0x62, 0xAC,
+0x09, 0x33, 0x00, 0x08, 0x60, 0x1B, 0x62, 0x26, 0x25, 0xB0, 0x02, 0x3C,
+0x01, 0x00, 0x03, 0x24, 0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0xD5, 0x32, 0x00, 0x08, 0x60, 0x1B, 0x65, 0x26, 0x24, 0x10, 0x22, 0x01,
+0xA9, 0xFD, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24, 0x47, 0x00, 0xC6, 0x34,
+0x00, 0x00, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x44, 0x30,
+0x0E, 0x00, 0x85, 0x10, 0x60, 0x1B, 0x62, 0x26, 0x98, 0x37, 0x04, 0xA2,
+0x00, 0x00, 0xC2, 0x90, 0xFF, 0x00, 0x83, 0x30, 0xFF, 0x00, 0x44, 0x30,
+0x07, 0x00, 0x83, 0x10, 0x21, 0x38, 0x00, 0x02, 0x21, 0x28, 0xC0, 0x00,
+0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00, 0xFD, 0xFF, 0x62, 0x14,
+0xFF, 0x00, 0x44, 0x30, 0x98, 0x37, 0xE3, 0xA0, 0x60, 0x1B, 0x62, 0x26,
+0x98, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31, 0x00, 0x00, 0x49, 0xAC,
+0x81, 0x33, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24, 0x24, 0x10, 0x22, 0x01,
+0xFD, 0xFD, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24, 0x45, 0x00, 0xE5, 0x34,
+0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x44, 0x30,
+0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26, 0x9C, 0x37, 0x04, 0xA2,
+0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30, 0xFF, 0x00, 0x44, 0x30,
+0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26, 0x21, 0x30, 0x00, 0x02,
+0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00, 0xFD, 0xFF, 0x62, 0x14,
+0xFF, 0x00, 0x44, 0x30, 0x9C, 0x37, 0xC3, 0xA0, 0x60, 0x1B, 0x62, 0x26,
+0x9C, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31, 0x00, 0x00, 0x49, 0xAC,
+0xF6, 0x33, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24, 0x24, 0x10, 0x22, 0x01,
+0x9E, 0xFD, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24, 0x46, 0x00, 0xA5, 0x34,
+0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x44, 0x30,
+0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26, 0x94, 0x37, 0x04, 0xA2,
+0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30, 0xFF, 0x00, 0x44, 0x30,
+0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26, 0x21, 0x30, 0x00, 0x02,
+0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00, 0xFD, 0xFF, 0x62, 0x14,
+0xFF, 0x00, 0x44, 0x30, 0x94, 0x37, 0xC3, 0xA0, 0x60, 0x1B, 0x62, 0x26,
+0x94, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C, 0x00, 0x1A, 0x03, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C, 0x25, 0xB0, 0x02, 0x3C,
+0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31, 0x00, 0x00, 0x49, 0xAC,
+0xB8, 0x33, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24, 0x00, 0xFF, 0x02, 0x3C,
+0x24, 0x10, 0x22, 0x01, 0x30, 0xFE, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0x41, 0x00, 0xA5, 0x34, 0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x44, 0x30, 0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x84, 0x37, 0x04, 0xA2, 0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30,
+0xFF, 0x00, 0x44, 0x30, 0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x21, 0x30, 0x00, 0x02, 0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00,
+0xFD, 0xFF, 0x62, 0x14, 0xFF, 0x00, 0x44, 0x30, 0x84, 0x37, 0xC3, 0xA0,
+0x60, 0x1B, 0x62, 0x26, 0x84, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31,
+0x00, 0x00, 0x49, 0xAC, 0x6C, 0x34, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x24, 0x10, 0x22, 0x01, 0xCF, 0xFE, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0x44, 0x00, 0xA5, 0x34, 0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x44, 0x30, 0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x90, 0x37, 0x04, 0xA2, 0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30,
+0xFF, 0x00, 0x44, 0x30, 0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x21, 0x30, 0x00, 0x02, 0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00,
+0xFD, 0xFF, 0x62, 0x14, 0xFF, 0x00, 0x44, 0x30, 0x90, 0x37, 0xC3, 0xA0,
+0x60, 0x1B, 0x62, 0x26, 0x90, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31,
+0x00, 0x00, 0x49, 0xAC, 0x2C, 0x35, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x24, 0x10, 0x22, 0x01, 0xAE, 0xFD, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0x40, 0x00, 0xA5, 0x34, 0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x44, 0x30, 0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x80, 0x37, 0x04, 0xA2, 0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30,
+0xFF, 0x00, 0x44, 0x30, 0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x21, 0x30, 0x00, 0x02, 0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00,
+0xFD, 0xFF, 0x62, 0x14, 0xFF, 0x00, 0x44, 0x30, 0x80, 0x37, 0xC3, 0xA0,
+0x60, 0x1B, 0x62, 0x26, 0x80, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31,
+0x00, 0x00, 0x49, 0xAC, 0x2C, 0x34, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x62, 0xAC, 0x78, 0x35, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x24, 0x10, 0x22, 0x01, 0x08, 0xFE, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0x42, 0x00, 0xA5, 0x34, 0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x44, 0x30, 0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x88, 0x37, 0x04, 0xA2, 0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30,
+0xFF, 0x00, 0x44, 0x30, 0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x21, 0x30, 0x00, 0x02, 0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00,
+0xFD, 0xFF, 0x62, 0x14, 0xFF, 0x00, 0x44, 0x30, 0x88, 0x37, 0xC3, 0xA0,
+0x60, 0x1B, 0x62, 0x26, 0x88, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31,
+0x00, 0x00, 0x49, 0xAC, 0xAA, 0x34, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x24, 0x10, 0x22, 0x01, 0x2C, 0xFE, 0x40, 0x10, 0xFF, 0x00, 0x02, 0x24,
+0x43, 0x00, 0xE5, 0x34, 0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x44, 0x30, 0x0E, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x8C, 0x37, 0x04, 0xA2, 0x00, 0x00, 0xA2, 0x90, 0xFF, 0x00, 0x83, 0x30,
+0xFF, 0x00, 0x44, 0x30, 0x08, 0x00, 0x83, 0x10, 0x60, 0x1B, 0x62, 0x26,
+0x21, 0x30, 0x00, 0x02, 0x00, 0x00, 0xA2, 0x90, 0x21, 0x18, 0x80, 0x00,
+0xFD, 0xFF, 0x62, 0x14, 0xFF, 0x00, 0x44, 0x30, 0x8C, 0x37, 0xC3, 0xA0,
+0x60, 0x1B, 0x62, 0x26, 0x8C, 0x37, 0x43, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0x00, 0x1A, 0x03, 0x00, 0x21, 0x18, 0x62, 0x00, 0x0C, 0x00, 0x69, 0x8C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x03, 0x42, 0x34, 0xFF, 0x00, 0x24, 0x31,
+0x00, 0x00, 0x49, 0xAC, 0xEF, 0x34, 0x00, 0x08, 0xFF, 0x00, 0x02, 0x24,
+0x06, 0x00, 0x03, 0x24, 0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x90, 0x34, 0x00, 0x08, 0x60, 0x1B, 0x62, 0x26, 0x01, 0x00, 0x03, 0x24,
+0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0xA4, 0x33, 0x00, 0x08,
+0x60, 0x1B, 0x62, 0x26, 0x25, 0xB0, 0x02, 0x3C, 0x07, 0x00, 0x03, 0x24,
+0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x60, 0x1B, 0x63, 0x26,
+0xD4, 0x1B, 0x62, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x42, 0x38,
+0x56, 0x34, 0x00, 0x08, 0xD4, 0x1B, 0x62, 0xAC, 0x00, 0x00, 0x40, 0xAC,
+0x19, 0x34, 0x00, 0x08, 0x60, 0x1B, 0x62, 0x26, 0x02, 0x00, 0x03, 0x24,
+0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0xDF, 0x33, 0x00, 0x08,
+0x60, 0x1B, 0x62, 0x26, 0x90, 0x03, 0x63, 0x34, 0x00, 0x00, 0x62, 0xAC,
+0x12, 0x35, 0x00, 0x08, 0x60, 0x1B, 0x62, 0x26, 0x03, 0x00, 0x03, 0x24,
+0x90, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x53, 0x35, 0x00, 0x08,
+0x60, 0x1B, 0x62, 0x26, 0x05, 0x00, 0x03, 0x24, 0x90, 0x03, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0xD1, 0x34, 0x00, 0x08, 0x60, 0x1B, 0x62, 0x26,
+0xE0, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x25, 0xB0, 0x0C, 0x3C,
+0x01, 0x80, 0x02, 0x3C, 0x18, 0x03, 0x83, 0x35, 0x30, 0xDC, 0x42, 0x24,
+0x02, 0x80, 0x12, 0x3C, 0x41, 0xB0, 0x0B, 0x3C, 0x00, 0x00, 0x62, 0xAC,
+0x60, 0x1B, 0x4A, 0x26, 0x0A, 0x00, 0x62, 0x35, 0x00, 0x00, 0x44, 0x94,
+0xDE, 0x1B, 0x43, 0x95, 0xDC, 0x1B, 0x49, 0x95, 0x25, 0x30, 0x64, 0x00,
+0xFF, 0xFF, 0xD0, 0x30, 0x24, 0x10, 0x09, 0x02, 0x02, 0x00, 0x42, 0x30,
+0xC2, 0x00, 0x40, 0x10, 0xC0, 0x03, 0x83, 0x35, 0x02, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x62, 0xAC, 0x02, 0x80, 0x08, 0x3C, 0xB0, 0x5D, 0x04, 0x8D,
+0xDC, 0x02, 0x82, 0x35, 0x00, 0x00, 0x47, 0x90, 0xFD, 0xFF, 0x03, 0x24,
+0x00, 0x80, 0x02, 0x3C, 0x24, 0x18, 0x23, 0x01, 0x25, 0x20, 0x82, 0x00,
+0x02, 0x00, 0xC6, 0x38, 0x08, 0x00, 0x65, 0x35, 0x02, 0x80, 0x02, 0x3C,
+0xED, 0x5D, 0x47, 0xA0, 0xB0, 0x5D, 0x04, 0xAD, 0xDE, 0x1B, 0x46, 0xA5,
+0x21, 0x48, 0x60, 0x00, 0x00, 0x00, 0xA3, 0xA4, 0xDC, 0x1B, 0x43, 0xA5,
+0x24, 0x38, 0x09, 0x02, 0x04, 0x00, 0xE2, 0x30, 0x0A, 0x00, 0x40, 0x10,
+0x08, 0x00, 0xE2, 0x30, 0xDE, 0x1B, 0x43, 0x95, 0x0C, 0x00, 0x64, 0x35,
+0xC0, 0x03, 0x85, 0x35, 0x04, 0x00, 0x63, 0x38, 0x04, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x86, 0x90, 0x00, 0x00, 0xA2, 0xAC, 0xDE, 0x1B, 0x43, 0xA5,
+0x08, 0x00, 0xE2, 0x30, 0x08, 0x00, 0x40, 0x10, 0x10, 0x00, 0xE2, 0x30,
+0xDE, 0x1B, 0x42, 0x95, 0xC0, 0x03, 0x84, 0x35, 0x08, 0x00, 0x03, 0x24,
+0x08, 0x00, 0x42, 0x38, 0x00, 0x00, 0x83, 0xAC, 0xDE, 0x1B, 0x42, 0xA5,
+0x10, 0x00, 0xE2, 0x30, 0x08, 0x00, 0x40, 0x10, 0x20, 0x00, 0xE2, 0x30,
+0xDE, 0x1B, 0x42, 0x95, 0xC0, 0x03, 0x84, 0x35, 0x10, 0x00, 0x03, 0x24,
+0x10, 0x00, 0x42, 0x38, 0x00, 0x00, 0x83, 0xAC, 0xDE, 0x1B, 0x42, 0xA5,
+0x20, 0x00, 0xE2, 0x30, 0x08, 0x00, 0x40, 0x10, 0x80, 0x00, 0xE2, 0x30,
+0xDE, 0x1B, 0x42, 0x95, 0xC0, 0x03, 0x84, 0x35, 0x20, 0x00, 0x03, 0x24,
+0x20, 0x00, 0x42, 0x38, 0x00, 0x00, 0x83, 0xAC, 0xDE, 0x1B, 0x42, 0xA5,
+0x80, 0x00, 0xE2, 0x30, 0x74, 0x00, 0x40, 0x10, 0x60, 0x1B, 0x47, 0x26,
+0xC0, 0x03, 0x83, 0x35, 0x80, 0x00, 0x02, 0x24, 0x42, 0xB0, 0x0B, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0x03, 0x00, 0x71, 0x35, 0xDE, 0x1B, 0x42, 0x95,
+0x00, 0x00, 0x23, 0x92, 0x80, 0x00, 0x42, 0x38, 0x20, 0x00, 0x63, 0x30,
+0x59, 0x00, 0x60, 0x10, 0xDE, 0x1B, 0x42, 0xA5, 0x20, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x22, 0xA2, 0x02, 0x80, 0x03, 0x3C, 0x0F, 0x5E, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x40, 0x14, 0x21, 0x40, 0x00, 0x00,
+0xB0, 0x1B, 0x42, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30,
+0x4E, 0x00, 0x40, 0x10, 0x02, 0x80, 0x06, 0x3C, 0x02, 0x80, 0x07, 0x3C,
+0xEC, 0x5D, 0xE2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x09, 0x3C, 0x02, 0x80, 0x04, 0x3C, 0xF8, 0x5D, 0x82, 0x8C,
+0x18, 0x5E, 0x24, 0x8D, 0x1C, 0x5E, 0x25, 0x8D, 0x21, 0x18, 0x00, 0x00,
+0x21, 0x10, 0x44, 0x00, 0x2B, 0x30, 0x44, 0x00, 0x21, 0x18, 0x65, 0x00,
+0x21, 0x18, 0x66, 0x00, 0x18, 0x5E, 0x22, 0xAD, 0x1C, 0x5E, 0x23, 0xAD,
+0xEC, 0x5D, 0xE4, 0x90, 0x02, 0x00, 0x02, 0x24, 0xFF, 0x00, 0x84, 0x30,
+0x07, 0x00, 0x82, 0x10, 0x02, 0x80, 0x04, 0x3C, 0xEC, 0x5D, 0xE2, 0x90,
+0x03, 0x00, 0x03, 0x24, 0xFF, 0x00, 0x42, 0x30, 0x5A, 0x00, 0x43, 0x14,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x04, 0x3C, 0x0A, 0x5E, 0x82, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x42, 0x24, 0x0A, 0x5E, 0x82, 0xA0,
+0x0A, 0x5E, 0x83, 0x90, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x60, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0xF2, 0x5D, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x03, 0x00, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x11,
+0x80, 0x00, 0x86, 0x35, 0x0A, 0x5E, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x06, 0x00, 0x40, 0x14, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0x09, 0x5E, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x5E, 0x83, 0xA0,
+0x02, 0x80, 0x05, 0x3C, 0x07, 0x5E, 0xA2, 0x90, 0x02, 0x80, 0x03, 0x3C,
+0x02, 0x00, 0x04, 0x24, 0x10, 0x00, 0x42, 0x34, 0x07, 0x5E, 0xA2, 0xA0,
+0xF1, 0x5D, 0x62, 0x90, 0x21, 0x28, 0x00, 0x00, 0xFF, 0x00, 0x42, 0x30,
+0x80, 0x30, 0x02, 0x00, 0x21, 0x30, 0xC2, 0x00, 0xB9, 0x20, 0x00, 0x0C,
+0x00, 0x33, 0x06, 0x00, 0x42, 0xB0, 0x02, 0x3C, 0x44, 0x00, 0x04, 0x24,
+0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x44, 0xA0, 0x02, 0x80, 0x03, 0x3C,
+0xEE, 0x5D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30,
+0x04, 0x00, 0x42, 0x28, 0x05, 0x00, 0x40, 0x10, 0x02, 0x80, 0x06, 0x3C,
+0x04, 0x00, 0x04, 0x24, 0x4B, 0x2E, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24,
+0x02, 0x80, 0x06, 0x3C, 0xB0, 0x5D, 0xC4, 0x8C, 0x60, 0x1B, 0x47, 0x26,
+0xDC, 0x1B, 0xE5, 0x94, 0x10, 0x00, 0x02, 0x3C, 0x25, 0x20, 0x82, 0x00,
+0x41, 0xB0, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C, 0x7F, 0xFF, 0xA5, 0x30,
+0xB0, 0x03, 0x42, 0x34, 0x08, 0x00, 0x63, 0x34, 0x00, 0x00, 0x44, 0xAC,
+0x00, 0x00, 0x65, 0xA4, 0xB0, 0x5D, 0xC4, 0xAC, 0xDC, 0x1B, 0xE5, 0xA4,
+0x60, 0x1B, 0x47, 0x26, 0xDC, 0x1B, 0xE2, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x10, 0x50, 0x00, 0x00, 0x30, 0x42, 0x30, 0x06, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xDE, 0x1B, 0xE2, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x10, 0x42, 0x38, 0x00, 0x20, 0x42, 0x34, 0xDE, 0x1B, 0xE2, 0xA4,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x36, 0x37, 0x00, 0x08, 0xDE, 0x1B, 0x46, 0xA5, 0x01, 0x00, 0x08, 0x24,
+0x0F, 0x5E, 0x60, 0xA0, 0x72, 0x37, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x07, 0x5E, 0xA2, 0x90, 0x02, 0x80, 0x03, 0x3C, 0x02, 0x00, 0x04, 0x24,
+0x10, 0x00, 0x42, 0x34, 0x07, 0x5E, 0xA2, 0xA0, 0xF1, 0x5D, 0x62, 0x90,
+0x21, 0x28, 0x00, 0x00, 0xFF, 0x00, 0x42, 0x30, 0x80, 0x30, 0x02, 0x00,
+0x21, 0x30, 0xC2, 0x00, 0xB9, 0x20, 0x00, 0x0C, 0x00, 0x33, 0x06, 0x00,
+0x44, 0x00, 0x02, 0x24, 0x00, 0x00, 0x22, 0xA2, 0xBA, 0x37, 0x00, 0x08,
+0x02, 0x80, 0x03, 0x3C, 0x84, 0x00, 0x84, 0x35, 0x00, 0x00, 0x82, 0x8C,
+0x02, 0x80, 0x08, 0x3C, 0x00, 0x00, 0xC4, 0x8C, 0x14, 0x5E, 0x06, 0x8D,
+0x21, 0x10, 0x00, 0x00, 0x18, 0x5E, 0x28, 0x8D, 0x1C, 0x5E, 0x29, 0x8D,
+0x00, 0x00, 0x65, 0x91, 0x25, 0x10, 0x44, 0x00, 0x21, 0x10, 0x46, 0x00,
+0xFB, 0xFF, 0x04, 0x24, 0x24, 0x28, 0xA4, 0x00, 0x23, 0x40, 0x02, 0x01,
+0x00, 0x00, 0x65, 0xA1, 0x04, 0x00, 0x00, 0x11, 0x01, 0x00, 0x06, 0x24,
+0x80, 0x10, 0x08, 0x00, 0x21, 0x10, 0x48, 0x00, 0x80, 0x30, 0x02, 0x00,
+0x01, 0x00, 0x04, 0x24, 0xB9, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0x42, 0xB0, 0x02, 0x3C, 0x22, 0x00, 0x03, 0x24, 0x03, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xA0, 0xC4, 0x37, 0x00, 0x08, 0x02, 0x80, 0x06, 0x3C,
+0xF0, 0xFF, 0xBD, 0x27, 0x08, 0x00, 0xB2, 0xAF, 0x04, 0x00, 0xB1, 0xAF,
+0x00, 0x00, 0xB0, 0xAF, 0x00, 0x40, 0x09, 0x40, 0x00, 0x68, 0x0A, 0x40,
+0x00, 0x70, 0x02, 0x40, 0x00, 0x60, 0x0B, 0x40, 0x25, 0xB0, 0x05, 0x3C,
+0x18, 0x03, 0xA7, 0x34, 0x00, 0x00, 0xE6, 0x8C, 0x01, 0x80, 0x02, 0x3C,
+0x1C, 0x03, 0xA3, 0x34, 0x5C, 0xE0, 0x42, 0x24, 0x00, 0x00, 0x66, 0xAC,
+0x00, 0x00, 0xE2, 0xAC, 0x80, 0x00, 0x83, 0x8C, 0x7C, 0x02, 0xA2, 0x34,
+0x80, 0x02, 0xA6, 0x34, 0x84, 0x02, 0xA7, 0x34, 0x88, 0x02, 0xA8, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0x00, 0x00, 0xC9, 0xAC, 0x00, 0x00, 0xEA, 0xAC,
+0x00, 0x00, 0x0B, 0xAD, 0x74, 0x00, 0x83, 0x8C, 0x8C, 0x02, 0xA2, 0x34,
+0x90, 0x02, 0xA7, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x08, 0x00, 0x86, 0x8C,
+0x94, 0x02, 0xA8, 0x34, 0x98, 0x02, 0xA9, 0x34, 0x00, 0x00, 0xE6, 0xAC,
+0x0C, 0x00, 0x82, 0x8C, 0x9C, 0x02, 0xA6, 0x34, 0xA0, 0x02, 0xA7, 0x34,
+0x00, 0x00, 0x02, 0xAD, 0x10, 0x00, 0x83, 0x8C, 0xA4, 0x02, 0xA8, 0x34,
+0xA8, 0x02, 0xAA, 0x34, 0x00, 0x00, 0x23, 0xAD, 0x14, 0x00, 0x82, 0x8C,
+0xAC, 0x02, 0xA9, 0x34, 0xB0, 0x02, 0xAB, 0x34, 0x00, 0x00, 0xC2, 0xAC,
+0x18, 0x00, 0x83, 0x8C, 0xB4, 0x02, 0xAC, 0x34, 0xB8, 0x02, 0xAD, 0x34,
+0x00, 0x00, 0xE3, 0xAC, 0x1C, 0x00, 0x82, 0x8C, 0xBC, 0x02, 0xA7, 0x34,
+0xC0, 0x02, 0xAE, 0x34, 0x00, 0x00, 0x02, 0xAD, 0x20, 0x00, 0x83, 0x8C,
+0xC4, 0x02, 0xA8, 0x34, 0xC8, 0x02, 0xAF, 0x34, 0x00, 0x00, 0x43, 0xAD,
+0x24, 0x00, 0x82, 0x8C, 0xCC, 0x02, 0xAA, 0x34, 0xD0, 0x02, 0xB0, 0x34,
+0x00, 0x00, 0x22, 0xAD, 0x28, 0x00, 0x83, 0x8C, 0xD4, 0x02, 0xA9, 0x34,
+0xD8, 0x02, 0xB1, 0x34, 0x00, 0x00, 0x63, 0xAD, 0x2C, 0x00, 0x86, 0x8C,
+0x70, 0x02, 0xAB, 0x34, 0x74, 0x02, 0xB2, 0x34, 0x00, 0x00, 0x86, 0xAD,
+0x30, 0x00, 0x82, 0x8C, 0x78, 0x02, 0xA6, 0x34, 0x6C, 0x03, 0xAC, 0x34,
+0x00, 0x00, 0xA2, 0xAD, 0x34, 0x00, 0x83, 0x8C, 0x02, 0x80, 0x02, 0x3C,
+0x00, 0x00, 0xE3, 0xAC, 0x38, 0x00, 0x85, 0x8C, 0xE0, 0xC8, 0x47, 0x8C,
+0x00, 0x00, 0xC5, 0xAD, 0x3C, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x02, 0xAD, 0x40, 0x00, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xE3, 0xAD, 0x44, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x42, 0xAD, 0x48, 0x00, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x03, 0xAE, 0x4C, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x22, 0xAD, 0x50, 0x00, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x23, 0xAE, 0x54, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x62, 0xAD, 0x58, 0x00, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x43, 0xAE, 0x5C, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC2, 0xAC, 0x21, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x82, 0xAD,
+0x01, 0x00, 0xE7, 0x24, 0x21, 0x10, 0xE0, 0x00, 0x01, 0x00, 0xE7, 0x24,
+0x00, 0x00, 0x82, 0xAD, 0x82, 0x38, 0x00, 0x08, 0x21, 0x10, 0xE0, 0x00,
+0x01, 0x80, 0x1B, 0x3C, 0x24, 0xE2, 0x7B, 0x27, 0x25, 0xB0, 0x1A, 0x3C,
+0x18, 0x03, 0x5A, 0x27, 0x00, 0x00, 0x5B, 0xAF, 0x21, 0xD8, 0xA0, 0x03,
+0x82, 0xDA, 0x1B, 0x00, 0x80, 0xDA, 0x1B, 0x00, 0x08, 0x00, 0x7B, 0x27,
+0x04, 0x00, 0x61, 0xAF, 0x08, 0x00, 0x62, 0xAF, 0x0C, 0x00, 0x63, 0xAF,
+0x10, 0x00, 0x64, 0xAF, 0x14, 0x00, 0x65, 0xAF, 0x18, 0x00, 0x66, 0xAF,
+0x1C, 0x00, 0x67, 0xAF, 0x20, 0x00, 0x68, 0xAF, 0x24, 0x00, 0x69, 0xAF,
+0x28, 0x00, 0x6A, 0xAF, 0x2C, 0x00, 0x6B, 0xAF, 0x30, 0x00, 0x6C, 0xAF,
+0x34, 0x00, 0x6D, 0xAF, 0x38, 0x00, 0x6E, 0xAF, 0x3C, 0x00, 0x6F, 0xAF,
+0x12, 0x40, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x00, 0x70, 0x0A, 0x40,
+0x40, 0x00, 0x70, 0xAF, 0x44, 0x00, 0x71, 0xAF, 0x48, 0x00, 0x72, 0xAF,
+0x4C, 0x00, 0x73, 0xAF, 0x50, 0x00, 0x74, 0xAF, 0x54, 0x00, 0x75, 0xAF,
+0x58, 0x00, 0x76, 0xAF, 0x5C, 0x00, 0x77, 0xAF, 0x60, 0x00, 0x78, 0xAF,
+0x64, 0x00, 0x79, 0xAF, 0x68, 0x00, 0x7C, 0xAF, 0x6C, 0x00, 0x7D, 0xAF,
+0x70, 0x00, 0x7E, 0xAF, 0x74, 0x00, 0x7F, 0xAF, 0x78, 0x00, 0x68, 0xAF,
+0x7C, 0x00, 0x69, 0xAF, 0x80, 0x00, 0x6A, 0xAF, 0x00, 0x68, 0x1A, 0x40,
+0x25, 0xB0, 0x1B, 0x3C, 0x1C, 0x03, 0x7B, 0x37, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x7A, 0xAF, 0x7F, 0x00, 0x5B, 0x33, 0x30, 0x00, 0x60, 0x13,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x1B, 0x3C, 0x30, 0x03, 0x7B, 0x37,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0xAF, 0x00, 0x00, 0x00, 0x00,
+0x21, 0xD8, 0xA0, 0x03, 0x82, 0xDA, 0x1B, 0x00, 0x80, 0xDA, 0x1B, 0x00,
+0x08, 0x00, 0x7B, 0x27, 0x04, 0x00, 0x61, 0xAF, 0x08, 0x00, 0x62, 0xAF,
+0x0C, 0x00, 0x63, 0xAF, 0x10, 0x00, 0x64, 0xAF, 0x14, 0x00, 0x65, 0xAF,
+0x18, 0x00, 0x66, 0xAF, 0x1C, 0x00, 0x67, 0xAF, 0x20, 0x00, 0x68, 0xAF,
+0x24, 0x00, 0x69, 0xAF, 0x28, 0x00, 0x6A, 0xAF, 0x2C, 0x00, 0x6B, 0xAF,
+0x30, 0x00, 0x6C, 0xAF, 0x34, 0x00, 0x6D, 0xAF, 0x38, 0x00, 0x6E, 0xAF,
+0x3C, 0x00, 0x6F, 0xAF, 0x12, 0x40, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00,
+0x00, 0x70, 0x0A, 0x40, 0x40, 0x00, 0x70, 0xAF, 0x44, 0x00, 0x71, 0xAF,
+0x48, 0x00, 0x72, 0xAF, 0x4C, 0x00, 0x73, 0xAF, 0x50, 0x00, 0x74, 0xAF,
+0x54, 0x00, 0x75, 0xAF, 0x58, 0x00, 0x76, 0xAF, 0x5C, 0x00, 0x77, 0xAF,
+0x60, 0x00, 0x78, 0xAF, 0x64, 0x00, 0x79, 0xAF, 0x68, 0x00, 0x7C, 0xAF,
+0x6C, 0x00, 0x7D, 0xAF, 0x70, 0x00, 0x7E, 0xAF, 0x74, 0x00, 0x7F, 0xAF,
+0x78, 0x00, 0x68, 0xAF, 0x7C, 0x00, 0x69, 0xAF, 0x80, 0x00, 0x6A, 0xAF,
+0x17, 0x38, 0x00, 0x08, 0x21, 0x20, 0x60, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x08, 0x3C, 0x20, 0x03, 0x08, 0x35, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x1A, 0xAD, 0x00, 0x04, 0x5B, 0x33, 0x0A, 0x00, 0x60, 0x13,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x08, 0x3C, 0xE0, 0xC7, 0x08, 0x25,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x1B, 0x3C, 0x24, 0x03, 0x7B, 0x37,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xAF, 0x09, 0xF8, 0x00, 0x01,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5B, 0x33, 0x25, 0xB0, 0x08, 0x3C,
+0x28, 0x03, 0x08, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xAD,
+0x06, 0x00, 0x60, 0x13, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x08, 0x3C,
+0x30, 0xDC, 0x08, 0x25, 0x00, 0x00, 0x00, 0x00, 0x09, 0xF8, 0x00, 0x01,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x1A, 0x3C, 0xB0, 0x5D, 0x5A, 0x27,
+0x04, 0x00, 0x5B, 0x97, 0x25, 0xB0, 0x08, 0x3C, 0x30, 0x03, 0x08, 0x35,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xAD, 0x18, 0x00, 0x60, 0x13,
+0x00, 0x00, 0x00, 0x00, 0x08, 0xE8, 0x9B, 0x27, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x61, 0x8F, 0xFC, 0x03, 0x70, 0x7B, 0x7C, 0x00, 0x62, 0x7B,
+0xBC, 0x00, 0x64, 0x7B, 0xFC, 0x00, 0x66, 0x7B, 0x3C, 0x01, 0x68, 0x7B,
+0x13, 0x00, 0x00, 0x02, 0x11, 0x00, 0x20, 0x02, 0x7C, 0x01, 0x6A, 0x7B,
+0xBC, 0x01, 0x6C, 0x7B, 0xFC, 0x01, 0x6E, 0x7B, 0x3C, 0x02, 0x70, 0x7B,
+0x7C, 0x02, 0x72, 0x7B, 0xBC, 0x02, 0x74, 0x7B, 0xFC, 0x02, 0x76, 0x7B,
+0x3C, 0x03, 0x78, 0x7B, 0x7C, 0x03, 0x7C, 0x7B, 0xBC, 0x03, 0x7E, 0x7B,
+0x80, 0x00, 0x7B, 0x8F, 0x74, 0x39, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x21, 0xD8, 0xA0, 0x03, 0x82, 0xDA, 0x1B, 0x00, 0x80, 0xDA, 0x1B, 0x00,
+0x08, 0x00, 0x7B, 0x27, 0x08, 0x00, 0x5B, 0xAF, 0xFC, 0xEB, 0x9D, 0x27,
+0x00, 0x00, 0x4A, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x40, 0x11,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x08, 0x3C, 0x10, 0x5D, 0x08, 0x25,
+0x21, 0x48, 0x00, 0x00, 0x21, 0x58, 0x00, 0x00, 0x01, 0x00, 0x6B, 0x25,
+0x1A, 0x00, 0x40, 0x11, 0x24, 0x70, 0x4B, 0x01, 0x14, 0x00, 0xC0, 0x11,
+0x01, 0x00, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x44, 0xA3,
+0x26, 0x50, 0x4B, 0x01, 0x00, 0x00, 0x4A, 0xAF, 0x80, 0x80, 0x09, 0x00,
+0x21, 0x80, 0x08, 0x02, 0x00, 0x00, 0x10, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x09, 0xF8, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x1B, 0x3C,
+0xFC, 0xE4, 0x7B, 0x27, 0x25, 0xB0, 0x1A, 0x3C, 0x18, 0x03, 0x5A, 0x27,
+0x00, 0x00, 0x5B, 0xAF, 0x02, 0x80, 0x1A, 0x3C, 0xB0, 0x5D, 0x5A, 0x27,
+0xE1, 0xFF, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x29, 0x25,
+0x40, 0x58, 0x0B, 0x00, 0x37, 0x39, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x1B, 0x3C, 0xB0, 0x5D, 0x7B, 0x27, 0x21, 0x60, 0x00, 0x00,
+0x04, 0x00, 0x6C, 0xA7, 0x08, 0x00, 0x7A, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0xF8, 0xFF, 0x5A, 0x27, 0x00, 0x00, 0x5A, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x5A, 0x27, 0x84, 0x00, 0x44, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0xF9, 0xFF, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x41, 0x8F,
+0xFC, 0x03, 0x50, 0x7B, 0x7C, 0x00, 0x42, 0x7B, 0xBC, 0x00, 0x44, 0x7B,
+0xFC, 0x00, 0x46, 0x7B, 0x3C, 0x01, 0x48, 0x7B, 0x13, 0x00, 0x00, 0x02,
+0x11, 0x00, 0x20, 0x02, 0x7C, 0x01, 0x4A, 0x7B, 0xBC, 0x01, 0x4C, 0x7B,
+0xFC, 0x01, 0x4E, 0x7B, 0x3C, 0x02, 0x50, 0x7B, 0x7C, 0x02, 0x52, 0x7B,
+0xBC, 0x02, 0x54, 0x7B, 0xFC, 0x02, 0x56, 0x7B, 0x3C, 0x03, 0x58, 0x7B,
+0x7C, 0x03, 0x5C, 0x7B, 0xBC, 0x03, 0x5E, 0x7B, 0x80, 0x00, 0x5B, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x60, 0x03, 0x10, 0x00, 0x00, 0x42,
+0x00, 0x60, 0x05, 0x40, 0x42, 0x28, 0x05, 0x00, 0x40, 0x28, 0x05, 0x00,
+0x00, 0x60, 0x85, 0x40, 0x04, 0x00, 0x81, 0xAC, 0x08, 0x00, 0x82, 0xAC,
+0x0C, 0x00, 0x83, 0xAC, 0x20, 0x00, 0x88, 0xAC, 0x24, 0x00, 0x89, 0xAC,
+0x28, 0x00, 0x8A, 0xAC, 0x2C, 0x00, 0x8B, 0xAC, 0x30, 0x00, 0x8C, 0xAC,
+0x34, 0x00, 0x8D, 0xAC, 0x38, 0x00, 0x8E, 0xAC, 0x3C, 0x00, 0x8F, 0xAC,
+0x12, 0x40, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x40, 0x00, 0x90, 0xAC,
+0x44, 0x00, 0x91, 0xAC, 0x48, 0x00, 0x92, 0xAC, 0x4C, 0x00, 0x93, 0xAC,
+0x50, 0x00, 0x94, 0xAC, 0x54, 0x00, 0x95, 0xAC, 0x58, 0x00, 0x96, 0xAC,
+0x5C, 0x00, 0x97, 0xAC, 0x60, 0x00, 0x98, 0xAC, 0x64, 0x00, 0x99, 0xAC,
+0x68, 0x00, 0x9C, 0xAC, 0x6C, 0x00, 0x9D, 0xAC, 0x70, 0x00, 0x9E, 0xAC,
+0x74, 0x00, 0x9F, 0xAC, 0x78, 0x00, 0x88, 0xAC, 0x7C, 0x00, 0x89, 0xAC,
+0x80, 0x00, 0x9F, 0xAC, 0xF8, 0xFF, 0x84, 0x24, 0x00, 0x00, 0x84, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x84, 0x24, 0x84, 0x00, 0x86, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0xF9, 0xFF, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x21, 0xD8, 0x80, 0x00, 0x01, 0x00, 0xBA, 0x34, 0x04, 0x00, 0x61, 0x8F,
+0xFC, 0x03, 0x70, 0x7B, 0x7C, 0x00, 0x62, 0x7B, 0xBC, 0x00, 0x64, 0x7B,
+0xFC, 0x00, 0x66, 0x7B, 0x3C, 0x01, 0x68, 0x7B, 0x13, 0x00, 0x00, 0x02,
+0x11, 0x00, 0x20, 0x02, 0x7C, 0x01, 0x6A, 0x7B, 0xBC, 0x01, 0x6C, 0x7B,
+0xFC, 0x01, 0x6E, 0x7B, 0x3C, 0x02, 0x70, 0x7B, 0x7C, 0x02, 0x72, 0x7B,
+0xBC, 0x02, 0x74, 0x7B, 0xFC, 0x02, 0x76, 0x7B, 0x3C, 0x03, 0x78, 0x7B,
+0x7C, 0x03, 0x7C, 0x7B, 0xBC, 0x03, 0x7E, 0x7B, 0x80, 0x00, 0x7B, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x60, 0x03, 0x00, 0x60, 0x9A, 0x40,
+0x00, 0x60, 0x05, 0x40, 0x42, 0x28, 0x05, 0x00, 0x40, 0x28, 0x05, 0x00,
+0x00, 0x60, 0x85, 0x40, 0x04, 0x00, 0x81, 0xAC, 0x08, 0x00, 0x82, 0xAC,
+0x0C, 0x00, 0x83, 0xAC, 0x20, 0x00, 0x88, 0xAC, 0x24, 0x00, 0x89, 0xAC,
+0x28, 0x00, 0x8A, 0xAC, 0x2C, 0x00, 0x8B, 0xAC, 0x30, 0x00, 0x8C, 0xAC,
+0x34, 0x00, 0x8D, 0xAC, 0x38, 0x00, 0x8E, 0xAC, 0x3C, 0x00, 0x8F, 0xAC,
+0x12, 0x40, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x40, 0x00, 0x90, 0xAC,
+0x44, 0x00, 0x91, 0xAC, 0x48, 0x00, 0x92, 0xAC, 0x4C, 0x00, 0x93, 0xAC,
+0x50, 0x00, 0x94, 0xAC, 0x54, 0x00, 0x94, 0xAC, 0x58, 0x00, 0x96, 0xAC,
+0x5C, 0x00, 0x96, 0xAC, 0x60, 0x00, 0x98, 0xAC, 0x64, 0x00, 0x99, 0xAC,
+0x68, 0x00, 0x9C, 0xAC, 0x6C, 0x00, 0x9D, 0xAC, 0x70, 0x00, 0x9E, 0xAC,
+0x78, 0x00, 0x88, 0xAC, 0x7C, 0x00, 0x89, 0xAC, 0x80, 0x00, 0x9F, 0xAC,
+0x84, 0x00, 0x80, 0xAC, 0xF8, 0xFF, 0x84, 0x24, 0x00, 0x00, 0x84, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x84, 0x24, 0x84, 0x00, 0x86, 0x8C,
+0xFA, 0xFF, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0xD8, 0x80, 0x00,
+0x01, 0x00, 0xBA, 0x24, 0x04, 0x00, 0x61, 0x8F, 0xFC, 0x03, 0x70, 0x7B,
+0x7C, 0x00, 0x62, 0x7B, 0xBC, 0x00, 0x64, 0x7B, 0xFC, 0x00, 0x66, 0x7B,
+0x3C, 0x01, 0x68, 0x7B, 0x13, 0x00, 0x00, 0x02, 0x11, 0x00, 0x20, 0x02,
+0x7C, 0x01, 0x6A, 0x7B, 0xBC, 0x01, 0x6C, 0x7B, 0xFC, 0x01, 0x6E, 0x7B,
+0x3C, 0x02, 0x70, 0x7B, 0x7C, 0x02, 0x72, 0x7B, 0xBC, 0x02, 0x74, 0x7B,
+0xFC, 0x02, 0x76, 0x7B, 0x3C, 0x03, 0x78, 0x7B, 0x7C, 0x03, 0x7C, 0x7B,
+0xBC, 0x03, 0x7E, 0x7B, 0x80, 0x00, 0x7B, 0x8F, 0x08, 0x00, 0x60, 0x03,
+0x00, 0x60, 0x9A, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x23, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x1B, 0x3C,
+0x00, 0x00, 0x7B, 0x27, 0x25, 0xB0, 0x1A, 0x3C, 0x18, 0x03, 0x5A, 0x27,
+0x00, 0x00, 0x5B, 0xAF, 0x00, 0x00, 0x05, 0x24, 0x03, 0x00, 0xA4, 0x24,
+0x00, 0xA0, 0x80, 0x40, 0x00, 0xA0, 0x84, 0x40, 0x01, 0x80, 0x04, 0x3C,
+0x40, 0x00, 0x84, 0x24, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x80, 0x1B, 0x3C, 0x40, 0x00, 0x7B, 0x27, 0x25, 0xB0, 0x1A, 0x3C,
+0x18, 0x03, 0x5A, 0x27, 0x00, 0x00, 0x5B, 0xAF, 0x02, 0x80, 0x1A, 0x3C,
+0x00, 0x00, 0x5A, 0x27, 0xFC, 0x03, 0x5D, 0x27, 0x02, 0x80, 0x1C, 0x3C,
+0x00, 0x18, 0x9C, 0x27, 0x00, 0xF0, 0x08, 0x3C, 0x00, 0x0C, 0x08, 0x35,
+0x00, 0x60, 0x88, 0x40, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x84, 0x24,
+0xFF, 0x7F, 0x05, 0x3C, 0xFF, 0xFF, 0xA5, 0x34, 0x24, 0x20, 0x85, 0x00,
+0x00, 0x20, 0x84, 0x4C, 0xFF, 0xFF, 0x05, 0x34, 0x21, 0x28, 0xA4, 0x00,
+0x00, 0x28, 0x85, 0x4C, 0x02, 0x80, 0x08, 0x3C, 0x00, 0x00, 0x08, 0x25,
+0x00, 0x00, 0x00, 0xAD, 0x03, 0x80, 0x09, 0x3C, 0x04, 0xDD, 0x29, 0x25,
+0x04, 0x00, 0x08, 0x25, 0xFE, 0xFF, 0x09, 0x15, 0x00, 0x00, 0x00, 0xAD,
+0x00, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x84, 0x24, 0xFF, 0x7F, 0x05, 0x3C,
+0xFF, 0xFF, 0xA5, 0x34, 0x24, 0x20, 0x85, 0x00, 0x00, 0x00, 0x84, 0x4C,
+0xFF, 0xFF, 0x06, 0x34, 0x21, 0x30, 0xC4, 0x00, 0x24, 0x30, 0xC5, 0x00,
+0x00, 0x08, 0x86, 0x4C, 0x00, 0xA0, 0x04, 0x40, 0x10, 0x00, 0x84, 0x34,
+0x00, 0xA0, 0x84, 0x40, 0x01, 0x80, 0x1B, 0x3C, 0xEC, 0x00, 0x7B, 0x27,
+0x25, 0xB0, 0x1A, 0x3C, 0x18, 0x03, 0x5A, 0x27, 0x00, 0x00, 0x5B, 0xAF,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x04, 0x3C, 0x44, 0x00, 0x84, 0x34,
+0x00, 0x00, 0x85, 0x84, 0x20, 0x00, 0x06, 0x24, 0x25, 0x28, 0xA6, 0x00,
+0x00, 0x00, 0x85, 0xA4, 0x01, 0x80, 0x1B, 0x3C, 0x1C, 0x01, 0x7B, 0x27,
+0x25, 0xB0, 0x1A, 0x3C, 0x18, 0x03, 0x5A, 0x27, 0x00, 0x00, 0x5B, 0xAF,
+0x25, 0xB0, 0x04, 0x3C, 0x44, 0x00, 0x84, 0x34, 0x00, 0x00, 0x85, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xA5, 0x30, 0xFC, 0xFF, 0xA0, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0x07, 0x3C, 0xFF, 0xFF, 0xE7, 0x34,
+0x02, 0x80, 0x05, 0x3C, 0xC0, 0x5C, 0xA5, 0x24, 0xFF, 0xFF, 0xA5, 0x30,
+0x40, 0xB0, 0x04, 0x3C, 0x25, 0x28, 0xA4, 0x00, 0x24, 0x28, 0xA7, 0x00,
+0x21, 0x30, 0x00, 0x00, 0x43, 0xB0, 0x02, 0x3C, 0x00, 0x80, 0x04, 0x3C,
+0x40, 0x00, 0x84, 0x34, 0x00, 0x00, 0x45, 0xAC, 0x04, 0x00, 0x46, 0xAC,
+0x08, 0x00, 0x44, 0xAC, 0x5F, 0x67, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x04, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x64, 0x30, 0x02, 0x1C, 0x03, 0x00,
+0x08, 0x00, 0x80, 0x10, 0x0F, 0x00, 0x63, 0x30, 0x01, 0x00, 0x02, 0x24,
+0x0C, 0x00, 0x62, 0x10, 0x03, 0x00, 0x02, 0x24, 0x0E, 0x00, 0x62, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x03, 0x00, 0x60, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x08, 0x00, 0xE0, 0x03,
+0xC3, 0x5C, 0x40, 0xA0, 0x01, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0xC3, 0x5C, 0x43, 0xA0, 0x02, 0x00, 0x03, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x08, 0x00, 0xE0, 0x03, 0xC3, 0x5C, 0x43, 0xA0, 0x04, 0x00, 0x03, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x08, 0x00, 0xE0, 0x03, 0xC3, 0x5C, 0x43, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x02, 0x24,
+0xFF, 0xFF, 0x42, 0x24, 0xFF, 0xFF, 0x41, 0x04, 0xFF, 0xFF, 0x42, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x42, 0x24, 0x00, 0x60, 0x02, 0x40,
+0x01, 0x00, 0x41, 0x34, 0x01, 0x00, 0x21, 0x38, 0x00, 0x60, 0x81, 0x40,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x82, 0xAC, 0x00, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x40, 0x00, 0x00, 0x60, 0x83, 0x40,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x82, 0xAC, 0x00, 0x60, 0x01, 0x40,
+0x01, 0x00, 0x21, 0x34, 0x00, 0x60, 0x81, 0x40, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x40, 0x01, 0x00, 0x21, 0x34,
+0x01, 0x00, 0x21, 0x38, 0x00, 0x60, 0x81, 0x40, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x84, 0x02, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x04, 0x00, 0x85, 0x8C, 0x00, 0xA0, 0x03, 0x3C, 0x01, 0x00, 0x02, 0x24,
+0x25, 0x28, 0xA3, 0x00, 0x00, 0x00, 0xA4, 0x8C, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0xB4, 0x02, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x04, 0x00, 0x82, 0x8C, 0x02, 0x00, 0x83, 0x94, 0x00, 0xA0, 0x07, 0x3C,
+0x25, 0x28, 0x47, 0x00, 0x00, 0x00, 0xA2, 0x8C, 0x10, 0x00, 0x02, 0x24,
+0x13, 0x00, 0x62, 0x10, 0x11, 0x00, 0x66, 0x28, 0x06, 0x00, 0xC0, 0x10,
+0x20, 0x00, 0x02, 0x24, 0x08, 0x00, 0x02, 0x24, 0x17, 0x00, 0x62, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24,
+0xFD, 0xFF, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x83, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0xAC, 0x04, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x10, 0x47, 0x00, 0x00, 0x00, 0x42, 0x8C,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xA4, 0x04, 0x00, 0x83, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x18, 0x67, 0x00, 0x00, 0x00, 0x62, 0x94,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xA0, 0x04, 0x00, 0x83, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x18, 0x67, 0x00, 0x00, 0x00, 0x62, 0x90,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x47, 0x24, 0x24, 0x38, 0xE3, 0x90, 0xFF, 0xFF, 0xA5, 0x30,
+0x09, 0x00, 0xA3, 0x10, 0x21, 0x20, 0xC0, 0x00, 0x94, 0x38, 0xE2, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xC2, 0xAC, 0x9E, 0x38, 0xE3, 0x94,
+0x0E, 0x00, 0x02, 0x24, 0x14, 0x00, 0xC2, 0xAC, 0x17, 0x0A, 0x00, 0x08,
+0x0C, 0x00, 0xC3, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x02, 0x80, 0x11, 0x3C,
+0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB2, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x60, 0x1B, 0x31, 0x26, 0x7C, 0x38, 0x30, 0x96, 0x02, 0x80, 0x02, 0x3C,
+0x01, 0x80, 0x03, 0x3C, 0x25, 0x80, 0x02, 0x02, 0x25, 0xB0, 0x02, 0x3C,
+0xB8, 0x03, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34, 0x60, 0x00, 0x04, 0x26,
+0x80, 0x00, 0x05, 0x26, 0x00, 0x00, 0x43, 0xAC, 0xC2, 0x1B, 0x00, 0x0C,
+0x03, 0x00, 0x06, 0x24, 0x21, 0x20, 0x00, 0x02, 0x21, 0x28, 0x00, 0x00,
+0xEC, 0x54, 0x00, 0x0C, 0x08, 0x00, 0x06, 0x24, 0x7C, 0x38, 0x22, 0x8E,
+0x0C, 0x00, 0x03, 0x24, 0x0C, 0x00, 0x43, 0xAE, 0x08, 0x00, 0x42, 0xAE,
+0x12, 0x00, 0x02, 0x24, 0x14, 0x00, 0x42, 0xAE, 0x21, 0x20, 0x40, 0x02,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x17, 0x0A, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0xD8, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xB1, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x0D, 0x00, 0x03, 0x92, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x14,
+0x21, 0x88, 0x00, 0x00, 0x01, 0x00, 0x03, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0xF0, 0x5D, 0x43, 0xA0, 0x0C, 0x00, 0x02, 0x92, 0x02, 0x80, 0x05, 0x3C,
+0x06, 0x5E, 0xA2, 0xA0, 0x00, 0x00, 0x04, 0x92, 0x05, 0x00, 0x02, 0x24,
+0xFF, 0x00, 0x83, 0x30, 0x41, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x03, 0x00, 0x02, 0x24, 0x31, 0x00, 0x62, 0x10, 0xFF, 0x00, 0x84, 0x30,
+0x09, 0x00, 0x82, 0x2C, 0x25, 0x00, 0x40, 0x10, 0x02, 0x80, 0x10, 0x3C,
+0xEC, 0x5D, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x42, 0x30,
+0x21, 0x00, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00, 0x99, 0x61, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xEC, 0x5D, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x37, 0x00, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C, 0x10, 0x37, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30, 0x54, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x0E, 0x5E, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x0E, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24,
+0x0E, 0x5E, 0x62, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0xEE, 0x5D, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x04, 0x00, 0x42, 0x28,
+0x06, 0x00, 0x40, 0x10, 0x04, 0x00, 0x04, 0x24, 0x4B, 0x2E, 0x00, 0x0C,
+0x01, 0x00, 0x05, 0x24, 0x5B, 0x41, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x00, 0x11, 0x24, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x21, 0x10, 0x20, 0x02, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x0B, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x40, 0x14,
+0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x01, 0x00, 0x02, 0x24,
+0x09, 0x5E, 0x62, 0xA0, 0x09, 0x5E, 0x63, 0x90, 0x02, 0x80, 0x02, 0x3C,
+0x0A, 0x5E, 0x43, 0xA0, 0x00, 0x00, 0x04, 0x92, 0x33, 0x41, 0x00, 0x08,
+0xFF, 0x00, 0x84, 0x30, 0x06, 0x5E, 0xA0, 0xA0, 0x0C, 0x00, 0x03, 0x92,
+0x02, 0x80, 0x02, 0x3C, 0x04, 0x5E, 0x43, 0xA0, 0x00, 0x00, 0x04, 0x92,
+0x30, 0x41, 0x00, 0x08, 0xFF, 0x00, 0x83, 0x30, 0x42, 0xB0, 0x06, 0x3C,
+0x00, 0x00, 0xC3, 0x90, 0xEF, 0xFF, 0x02, 0x24, 0x03, 0x00, 0xC7, 0x34,
+0x24, 0x18, 0x62, 0x00, 0x40, 0x00, 0x02, 0x24, 0x00, 0x00, 0xC3, 0xA0,
+0x0C, 0x00, 0x04, 0x24, 0x00, 0x00, 0xE2, 0xA0, 0x4B, 0x2E, 0x00, 0x0C,
+0x01, 0x00, 0x05, 0x24, 0x02, 0x80, 0x03, 0x3C, 0xC6, 0x5C, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x42, 0x30, 0x15, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x24, 0x00, 0x02, 0x05, 0x3C,
+0xC1, 0x43, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x42, 0x24, 0x2A, 0x1C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xCA, 0xFF, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x3A, 0x44, 0x94,
+0x2A, 0x1C, 0x40, 0xA0, 0x00, 0xC0, 0x84, 0x24, 0xA3, 0x31, 0x00, 0x0C,
+0xFF, 0xFF, 0x84, 0x30, 0x5B, 0x41, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x0E, 0x5E, 0x40, 0xA0, 0x5B, 0x41, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0xA8, 0x2D, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24, 0x89, 0x41, 0x00, 0x08,
+0x00, 0x08, 0x04, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x02, 0x80, 0x11, 0x3C,
+0x10, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0x30, 0x26, 0xB0, 0x1B, 0x07, 0x96,
+0x18, 0x00, 0xBF, 0xAF, 0xFF, 0xFF, 0xE3, 0x30, 0x00, 0x01, 0x62, 0x30,
+0x0E, 0x00, 0x40, 0x10, 0x01, 0x00, 0x66, 0x30, 0x02, 0x80, 0x04, 0x3C,
+0xB4, 0x55, 0x84, 0x24, 0x03, 0x00, 0x05, 0x24, 0x1E, 0x00, 0xC0, 0x14,
+0x04, 0x00, 0x62, 0x30, 0x02, 0x00, 0x40, 0x10, 0xFB, 0xF6, 0xE3, 0x30,
+0xB0, 0x1B, 0x03, 0xA6, 0x87, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x4C, 0x00, 0x42, 0x34, 0x00, 0x00, 0x40, 0xA0,
+0x21, 0x20, 0x00, 0x00, 0x95, 0x0E, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0x25, 0xB0, 0x06, 0x3C, 0x48, 0x00, 0xC6, 0x34, 0x00, 0x00, 0xC5, 0x8C,
+0x60, 0x1B, 0x24, 0x26, 0x7B, 0xFF, 0x03, 0x3C, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xFF, 0xFF, 0x63, 0x34,
+0x21, 0x10, 0x00, 0x00, 0x24, 0x28, 0xA3, 0x00, 0x20, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0xC5, 0xAC, 0xBC, 0x40, 0x80, 0xAC, 0xE8, 0x39, 0x80, 0xAC,
+0x04, 0x3A, 0x80, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0xFC, 0x40, 0x80, 0xAC,
+0x1C, 0x4F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x1B, 0x02, 0x96,
+0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x42, 0x30, 0x87, 0x54, 0x00, 0x0C,
+0xB0, 0x1B, 0x02, 0xA6, 0x25, 0xB0, 0x02, 0x3C, 0x4C, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x40, 0xA0, 0xBB, 0x41, 0x00, 0x08, 0x21, 0x20, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x01, 0x00, 0x83, 0x90, 0x02, 0x80, 0x02, 0x3C, 0x21, 0x38, 0x80, 0x00,
+0x8C, 0x5B, 0x43, 0xAC, 0x01, 0x00, 0x84, 0x90, 0x00, 0x00, 0xE2, 0x90,
+0x02, 0x80, 0x06, 0x3C, 0xFF, 0x00, 0x85, 0x30, 0x80, 0x10, 0x02, 0x00,
+0x25, 0x28, 0xA2, 0x00, 0x88, 0xDE, 0xC6, 0x24, 0xFF, 0x00, 0x84, 0x30,
+0x00, 0x80, 0xA5, 0x34, 0x6F, 0x20, 0x00, 0x0C, 0x03, 0x00, 0xE7, 0x24,
+0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x03, 0x3C, 0x1C, 0x00, 0xBF, 0xAF, 0x10, 0x37, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x43, 0x30, 0x00, 0x01, 0x42, 0x30,
+0x04, 0x00, 0x40, 0x10, 0x21, 0x80, 0x80, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x06, 0x00, 0x60, 0x14, 0x60, 0xE7, 0x84, 0x24, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x06, 0x00, 0x07, 0x92, 0x07, 0x00, 0x02, 0x26, 0x21, 0x20, 0x00, 0x02,
+0x80, 0x38, 0x07, 0x00, 0x00, 0x80, 0xE7, 0x34, 0x05, 0x00, 0x05, 0x24,
+0x21, 0x30, 0x00, 0x00, 0x02, 0x54, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27,
+0x02, 0x80, 0x02, 0x3C, 0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF,
+0x60, 0x1B, 0x45, 0x24, 0xFC, 0x40, 0xA3, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x06, 0x00, 0x60, 0x14, 0x21, 0x80, 0x80, 0x00, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xF8, 0x40, 0xA2, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0x45, 0x00, 0xF0, 0x40, 0x40, 0xA0, 0x00, 0x00, 0x84, 0x8C,
+0xC3, 0x1A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8E,
+0x03, 0x00, 0x04, 0x24, 0xD9, 0x12, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x84, 0x90,
+0x75, 0x0D, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xD8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x10, 0x3C,
+0x20, 0x00, 0xB2, 0xAF, 0x60, 0x1B, 0x02, 0x26, 0x24, 0x00, 0xBF, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0xB0, 0x1B, 0x45, 0x94, 0x21, 0x90, 0x80, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C, 0x80, 0xE7, 0x84, 0x24,
+0x00, 0x00, 0x42, 0x96, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x43, 0x24,
+0x20, 0x00, 0x42, 0x24, 0xC2, 0x18, 0x03, 0x00, 0xC2, 0x28, 0x02, 0x00,
+0x07, 0x00, 0x42, 0x30, 0x02, 0x00, 0x40, 0x14, 0xC0, 0x20, 0x03, 0x00,
+0xC0, 0x20, 0x05, 0x00, 0x53, 0x21, 0x00, 0x0C, 0x60, 0x1B, 0x11, 0x26,
+0x02, 0x80, 0x05, 0x3C, 0x21, 0x38, 0x40, 0x00, 0x21, 0x80, 0x40, 0x00,
+0x0A, 0x00, 0x04, 0x24, 0x22, 0x00, 0x40, 0x10, 0x70, 0xE7, 0xA5, 0x24,
+0x02, 0x00, 0x46, 0x92, 0x10, 0x38, 0x25, 0x8E, 0x72, 0x01, 0x00, 0x0C,
+0x08, 0x00, 0xC6, 0x24, 0x5B, 0x01, 0x00, 0x0C, 0x0A, 0x00, 0x04, 0x24,
+0x08, 0x00, 0x02, 0x96, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x04, 0x3C,
+0x25, 0x28, 0x45, 0x00, 0x74, 0x03, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0xB0, 0x55, 0x84, 0x24, 0x74, 0x21, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02,
+0x31, 0x46, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x37, 0x26, 0x8E,
+0x58, 0x38, 0x25, 0x8E, 0x01, 0x00, 0x04, 0x24, 0x00, 0x01, 0x07, 0x24,
+0x01, 0x00, 0x02, 0x24, 0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF,
+0x5B, 0x01, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C, 0x18, 0xE7, 0x84, 0x24,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x82, 0x90, 0x02, 0x80, 0x03, 0x3C,
+0x60, 0x1B, 0x63, 0x24, 0x07, 0x00, 0x40, 0x10, 0x21, 0x20, 0x60, 0x00,
+0xD0, 0x07, 0x02, 0x24, 0x3C, 0x3A, 0x62, 0xAC, 0x01, 0x00, 0x03, 0x24,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x48, 0x41, 0x83, 0xA0,
+0x21, 0x10, 0x00, 0x00, 0x3C, 0x3A, 0x60, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x48, 0x41, 0x60, 0xA0, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x25, 0xB0, 0x10, 0x3C, 0x21, 0x28, 0x80, 0x00, 0x06, 0x00, 0x06, 0x24,
+0x14, 0x00, 0xBF, 0xAF, 0xF4, 0x54, 0x00, 0x0C, 0x50, 0x00, 0x04, 0x36,
+0x02, 0x80, 0x04, 0x3C, 0x50, 0x00, 0x05, 0x36, 0x48, 0x37, 0x84, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0x94, 0xE7, 0x84, 0x24, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x25, 0xB0, 0x05, 0x3C, 0x01, 0x80, 0x03, 0x3C,
+0xE8, 0xFF, 0xBD, 0x27, 0x21, 0x30, 0x80, 0x00, 0x18, 0x03, 0xA2, 0x34,
+0xC0, 0x0B, 0x63, 0x24, 0x01, 0x00, 0x04, 0x24, 0x14, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x43, 0xAC, 0x66, 0x00, 0xC4, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x09, 0x00, 0xC0, 0x10, 0x02, 0x00, 0x02, 0x24,
+0x36, 0x00, 0xC2, 0x10, 0x03, 0x00, 0x02, 0x24, 0x8B, 0x00, 0xC2, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x50, 0x24, 0x70, 0x08, 0x02, 0x24, 0x34, 0x1C, 0x02, 0xAE,
+0xE0, 0x08, 0x03, 0x24, 0x40, 0x08, 0x02, 0x24, 0x38, 0x1C, 0x03, 0xAE,
+0x44, 0x1C, 0x02, 0xAE, 0x78, 0x08, 0x03, 0x24, 0x0C, 0x08, 0x02, 0x24,
+0x48, 0x1C, 0x03, 0xAE, 0x4C, 0x1C, 0x02, 0xAE, 0x10, 0x08, 0x03, 0x24,
+0x20, 0x08, 0x02, 0x24, 0x50, 0x1C, 0x03, 0xAE, 0x54, 0x1C, 0x02, 0xAE,
+0x24, 0x08, 0x03, 0x24, 0x58, 0x08, 0x02, 0x24, 0x58, 0x1C, 0x03, 0xAE,
+0x5C, 0x1C, 0x02, 0xAE, 0x50, 0x0C, 0x03, 0x24, 0x54, 0x0C, 0x02, 0x24,
+0x60, 0x1C, 0x03, 0xAE, 0x64, 0x1C, 0x02, 0xAE, 0x14, 0x0C, 0x03, 0x24,
+0x10, 0x0C, 0x02, 0x24, 0x20, 0x08, 0xA4, 0x34, 0x68, 0x1C, 0x03, 0xAE,
+0x60, 0x08, 0x05, 0x24, 0x6C, 0x1C, 0x02, 0xAE, 0x80, 0x0C, 0x03, 0x24,
+0x84, 0x0C, 0x02, 0x24, 0x40, 0x1C, 0x05, 0xAE, 0x70, 0x1C, 0x03, 0xAE,
+0x74, 0x1C, 0x02, 0xAE, 0x31, 0x1C, 0x00, 0xA2, 0xFA, 0x5B, 0x00, 0x0C,
+0x3C, 0x1C, 0x05, 0xAE, 0x00, 0x01, 0x42, 0x30, 0x31, 0x00, 0x40, 0x14,
+0xB8, 0x08, 0x02, 0x24, 0xA0, 0x08, 0x02, 0x24, 0x78, 0x1C, 0x02, 0xAE,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0xA8, 0x08, 0x03, 0x24, 0x78, 0x1C, 0x43, 0xAC, 0x74, 0x08, 0x03, 0x24,
+0xE4, 0x08, 0x04, 0x24, 0x34, 0x1C, 0x43, 0xAC, 0x48, 0x08, 0x03, 0x24,
+0x38, 0x1C, 0x44, 0xAC, 0x44, 0x1C, 0x43, 0xAC, 0x7C, 0x08, 0x04, 0x24,
+0x0C, 0x08, 0x03, 0x24, 0x48, 0x1C, 0x44, 0xAC, 0x4C, 0x1C, 0x43, 0xAC,
+0x18, 0x08, 0x04, 0x24, 0x30, 0x08, 0x03, 0x24, 0x50, 0x1C, 0x44, 0xAC,
+0x54, 0x1C, 0x43, 0xAC, 0x34, 0x08, 0x04, 0x24, 0x5C, 0x08, 0x03, 0x24,
+0x58, 0x1C, 0x44, 0xAC, 0x5C, 0x1C, 0x43, 0xAC, 0x60, 0x0C, 0x04, 0x24,
+0x64, 0x0C, 0x03, 0x24, 0x60, 0x1C, 0x44, 0xAC, 0x64, 0x1C, 0x43, 0xAC,
+0x24, 0x0C, 0x04, 0x24, 0x20, 0x0C, 0x03, 0x24, 0x68, 0x08, 0x05, 0x24,
+0x68, 0x1C, 0x44, 0xAC, 0x6C, 0x1C, 0x43, 0xAC, 0x90, 0x0C, 0x04, 0x24,
+0x94, 0x0C, 0x03, 0x24, 0x31, 0x1C, 0x46, 0xA0, 0x40, 0x1C, 0x45, 0xAC,
+0x70, 0x1C, 0x44, 0xAC, 0x74, 0x1C, 0x43, 0xAC, 0x3C, 0x1C, 0x45, 0xAC,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x31, 0x43, 0x00, 0x08, 0x78, 0x1C, 0x02, 0xAE,
+0x60, 0x1B, 0x50, 0x24, 0x70, 0x08, 0x02, 0x24, 0x34, 0x1C, 0x02, 0xAE,
+0xE0, 0x08, 0x03, 0x24, 0x44, 0x08, 0x02, 0x24, 0x38, 0x1C, 0x03, 0xAE,
+0x44, 0x1C, 0x02, 0xAE, 0x78, 0x08, 0x03, 0x24, 0x0C, 0x08, 0x02, 0x24,
+0x48, 0x1C, 0x03, 0xAE, 0x4C, 0x1C, 0x02, 0xAE, 0x14, 0x08, 0x03, 0x24,
+0x28, 0x08, 0x02, 0x24, 0x50, 0x1C, 0x03, 0xAE, 0x54, 0x1C, 0x02, 0xAE,
+0x2C, 0x08, 0x03, 0x24, 0x58, 0x08, 0x02, 0x24, 0x58, 0x1C, 0x03, 0xAE,
+0x5C, 0x1C, 0x02, 0xAE, 0x58, 0x0C, 0x03, 0x24, 0x5C, 0x0C, 0x02, 0x24,
+0x60, 0x1C, 0x03, 0xAE, 0x64, 0x1C, 0x02, 0xAE, 0x1C, 0x0C, 0x03, 0x24,
+0x18, 0x0C, 0x02, 0x24, 0x28, 0x08, 0xA4, 0x34, 0x68, 0x1C, 0x03, 0xAE,
+0x64, 0x08, 0x05, 0x24, 0x6C, 0x1C, 0x02, 0xAE, 0x88, 0x0C, 0x03, 0x24,
+0x8C, 0x0C, 0x02, 0x24, 0x31, 0x1C, 0x06, 0xA2, 0x40, 0x1C, 0x05, 0xAE,
+0x70, 0x1C, 0x03, 0xAE, 0x74, 0x1C, 0x02, 0xAE, 0xFA, 0x5B, 0x00, 0x0C,
+0x3C, 0x1C, 0x05, 0xAE, 0x00, 0x01, 0x42, 0x30, 0x2B, 0x00, 0x40, 0x14,
+0xBC, 0x08, 0x02, 0x24, 0xA4, 0x08, 0x02, 0x24, 0x31, 0x43, 0x00, 0x08,
+0x78, 0x1C, 0x02, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0xAC, 0x08, 0x03, 0x24, 0x78, 0x1C, 0x43, 0xAC, 0x74, 0x08, 0x03, 0x24,
+0xE4, 0x08, 0x04, 0x24, 0x34, 0x1C, 0x43, 0xAC, 0x4C, 0x08, 0x03, 0x24,
+0x38, 0x1C, 0x44, 0xAC, 0x44, 0x1C, 0x43, 0xAC, 0x7C, 0x08, 0x04, 0x24,
+0x0C, 0x08, 0x03, 0x24, 0x48, 0x1C, 0x44, 0xAC, 0x4C, 0x1C, 0x43, 0xAC,
+0x1C, 0x08, 0x04, 0x24, 0x38, 0x08, 0x03, 0x24, 0x50, 0x1C, 0x44, 0xAC,
+0x54, 0x1C, 0x43, 0xAC, 0x3C, 0x08, 0x04, 0x24, 0x5C, 0x08, 0x03, 0x24,
+0x58, 0x1C, 0x44, 0xAC, 0x5C, 0x1C, 0x43, 0xAC, 0x68, 0x0C, 0x04, 0x24,
+0x6C, 0x0C, 0x03, 0x24, 0x60, 0x1C, 0x44, 0xAC, 0x64, 0x1C, 0x43, 0xAC,
+0x2C, 0x0C, 0x04, 0x24, 0x28, 0x0C, 0x03, 0x24, 0x6C, 0x08, 0x05, 0x24,
+0x68, 0x1C, 0x44, 0xAC, 0x6C, 0x1C, 0x43, 0xAC, 0x98, 0x0C, 0x04, 0x24,
+0x9C, 0x0C, 0x03, 0x24, 0x31, 0x1C, 0x46, 0xA0, 0x40, 0x1C, 0x45, 0xAC,
+0x70, 0x1C, 0x44, 0xAC, 0x74, 0x1C, 0x43, 0xAC, 0x5B, 0x43, 0x00, 0x08,
+0x3C, 0x1C, 0x45, 0xAC, 0x31, 0x43, 0x00, 0x08, 0x78, 0x1C, 0x02, 0xAE,
+0xBA, 0x43, 0x00, 0x08, 0x21, 0x18, 0x00, 0x00, 0x20, 0x00, 0x62, 0x2C,
+0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x64, 0x00,
+0x01, 0x00, 0x42, 0x30, 0xFA, 0xFF, 0x40, 0x10, 0x01, 0x00, 0x63, 0x24,
+0xFF, 0xFF, 0x63, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0xD8, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0xFF, 0xFF, 0x02, 0x24,
+0x21, 0x88, 0xA0, 0x00, 0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x90, 0xC0, 0x00,
+0x21, 0x28, 0xC0, 0x00, 0x0B, 0x00, 0x22, 0x12, 0x21, 0x98, 0x80, 0x00,
+0x26, 0x5C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x20, 0x02,
+0xB5, 0x43, 0x00, 0x0C, 0x21, 0x80, 0x40, 0x00, 0x27, 0x28, 0x11, 0x00,
+0x24, 0x28, 0xB0, 0x00, 0x04, 0x10, 0x52, 0x00, 0x25, 0x28, 0xA2, 0x00,
+0x21, 0x20, 0x60, 0x02, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x03, 0x5C, 0x00, 0x08, 0x28, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x30, 0x80, 0x00, 0xA4, 0x37, 0x44, 0x8C, 0xC1, 0x43, 0x00, 0x08,
+0xFF, 0xFF, 0x05, 0x24, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xBF, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x26, 0x5C, 0x00, 0x0C,
+0x21, 0x88, 0xA0, 0x00, 0x21, 0x80, 0x40, 0x00, 0xB5, 0x43, 0x00, 0x0C,
+0x21, 0x20, 0x20, 0x02, 0x24, 0x80, 0x11, 0x02, 0x06, 0x10, 0x50, 0x00,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB2, 0xAF, 0x02, 0x80, 0x12, 0x3C, 0x60, 0x1B, 0x52, 0x26,
+0x14, 0x00, 0xB1, 0xAF, 0x21, 0x88, 0x80, 0x00, 0x24, 0x08, 0x04, 0x24,
+0x24, 0x00, 0xBF, 0xAF, 0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF,
+0x26, 0x5C, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF, 0x58, 0x1C, 0x44, 0x8E,
+0x21, 0xA0, 0x40, 0x00, 0x26, 0x5C, 0x00, 0x0C, 0xC0, 0x8D, 0x11, 0x00,
+0xFF, 0x7F, 0x05, 0x3C, 0x7F, 0x80, 0x03, 0x3C, 0xFF, 0xFF, 0xA5, 0x34,
+0xFF, 0xFF, 0x63, 0x34, 0x24, 0x28, 0x85, 0x02, 0x24, 0x08, 0x04, 0x24,
+0x03, 0x5C, 0x00, 0x0C, 0x24, 0x80, 0x43, 0x00, 0x2C, 0x1F, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x00, 0x80, 0x13, 0x3C, 0x58, 0x1C, 0x44, 0x8E,
+0x25, 0x80, 0x11, 0x02, 0x25, 0x80, 0x13, 0x02, 0x03, 0x5C, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x02, 0x2C, 0x1F, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x25, 0x28, 0x93, 0x02, 0x03, 0x5C, 0x00, 0x0C, 0x24, 0x08, 0x04, 0x24,
+0x2C, 0x1F, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24, 0x78, 0x1C, 0x44, 0x8E,
+0x0F, 0x00, 0x05, 0x3C, 0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0xFF, 0xFF, 0xA5, 0x34, 0xE3, 0x43, 0x00, 0x08,
+0x28, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF,
+0x02, 0x80, 0x11, 0x3C, 0x10, 0x00, 0xB0, 0xAF, 0x18, 0x00, 0xBF, 0xAF,
+0x60, 0x1B, 0x27, 0x26, 0x33, 0x1C, 0xE5, 0x90, 0x01, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x94, 0x10, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x02, 0x00, 0x06, 0x24, 0x00, 0x00, 0x43, 0xAC, 0x34, 0x00, 0xA6, 0x10,
+0x21, 0x80, 0x80, 0x00, 0x03, 0x00, 0x03, 0x24, 0x3A, 0x00, 0xA3, 0x10,
+0x2E, 0x00, 0x02, 0x2E, 0x10, 0x00, 0x02, 0x2E, 0x07, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x04, 0x32, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xF3, 0x43, 0x00, 0x08,
+0x20, 0x00, 0xBD, 0x27, 0xFA, 0xFF, 0xA6, 0x14, 0xFF, 0x00, 0x04, 0x32,
+0x31, 0x1C, 0xE4, 0x90, 0x01, 0x00, 0x02, 0x24, 0x33, 0x00, 0x82, 0x10,
+0x02, 0x00, 0x82, 0x28, 0x38, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x38, 0x00, 0x85, 0x10, 0x60, 0x1B, 0x22, 0x26, 0x2E, 0x00, 0x83, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x24, 0xE3, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0xFF, 0xFC, 0x06, 0x3C, 0xFF, 0xFF, 0xC6, 0x34,
+0x24, 0x30, 0x46, 0x00, 0x00, 0x08, 0x04, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0x60, 0x1B, 0x22, 0x26, 0x31, 0x1C, 0x44, 0x90,
+0x01, 0x00, 0x03, 0x24, 0x07, 0x00, 0x83, 0x10, 0x02, 0x00, 0x82, 0x28,
+0x2C, 0x00, 0x40, 0x14, 0x02, 0x00, 0x02, 0x24, 0x2C, 0x00, 0x82, 0x10,
+0x03, 0x00, 0x02, 0x24, 0xDB, 0xFF, 0x82, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x22, 0x26, 0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x3C,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x3B, 0x44, 0x00, 0x08,
+0xFF, 0x00, 0x04, 0x32, 0x25, 0x00, 0x82, 0x2C, 0xCC, 0xFF, 0x40, 0x14,
+0x03, 0x00, 0x03, 0x24, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xC7, 0xFF, 0x40, 0x14, 0x10, 0x00, 0x02, 0x2E,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x60, 0x1B, 0x22, 0x26, 0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x3C,
+0xC1, 0x43, 0x00, 0x0C, 0x0F, 0x00, 0x06, 0x24, 0x4D, 0x44, 0x00, 0x08,
+0x00, 0x08, 0x04, 0x24, 0xCC, 0xFF, 0x80, 0x14, 0x60, 0x1B, 0x22, 0x26,
+0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x0F, 0x00, 0x06, 0x24, 0x4D, 0x44, 0x00, 0x08, 0x00, 0x08, 0x04, 0x24,
+0xB2, 0xFF, 0x80, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x22, 0x26,
+0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x3B, 0x44, 0x00, 0x08, 0xFF, 0x00, 0x04, 0x32,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x02, 0x80, 0x11, 0x3C,
+0x60, 0x1B, 0x28, 0x26, 0x33, 0x1C, 0x06, 0x91, 0x01, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x40, 0x12, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x02, 0x00, 0x07, 0x24, 0x18, 0x00, 0xB2, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x1C, 0x00, 0xBF, 0xAF, 0x00, 0x00, 0x43, 0xAC, 0x21, 0x90, 0xA0, 0x00,
+0x39, 0x00, 0xC7, 0x10, 0xFF, 0x00, 0x90, 0x30, 0x03, 0x00, 0x03, 0x24,
+0x3F, 0x00, 0xC3, 0x10, 0x2E, 0x00, 0x02, 0x2E, 0x10, 0x00, 0x02, 0x2E,
+0x0C, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x04, 0x3C,
+0xFF, 0xFF, 0x84, 0x34, 0x24, 0x20, 0x44, 0x02, 0x00, 0x15, 0x10, 0x00,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x25, 0x20, 0x44, 0x00, 0xDE, 0x43, 0x00, 0x08,
+0x20, 0x00, 0xBD, 0x27, 0xF5, 0xFF, 0xC7, 0x14, 0x0F, 0x00, 0x04, 0x3C,
+0x31, 0x1C, 0x04, 0x91, 0x01, 0x00, 0x02, 0x24, 0x33, 0x00, 0x82, 0x10,
+0x02, 0x00, 0x82, 0x28, 0x38, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x38, 0x00, 0x86, 0x10, 0x60, 0x1B, 0x22, 0x26, 0x2E, 0x00, 0x83, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x24, 0xE3, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0xFF, 0xFC, 0x06, 0x3C, 0xFF, 0xFF, 0xC6, 0x34,
+0x24, 0x30, 0x46, 0x00, 0x00, 0x08, 0x04, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0x60, 0x1B, 0x22, 0x26, 0x31, 0x1C, 0x44, 0x90,
+0x01, 0x00, 0x03, 0x24, 0x07, 0x00, 0x83, 0x10, 0x02, 0x00, 0x82, 0x28,
+0x2C, 0x00, 0x40, 0x14, 0x02, 0x00, 0x02, 0x24, 0x2C, 0x00, 0x82, 0x10,
+0x03, 0x00, 0x02, 0x24, 0xD6, 0xFF, 0x82, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x60, 0x1B, 0x22, 0x26, 0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x3C,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0xA8, 0x44, 0x00, 0x08,
+0x0F, 0x00, 0x04, 0x3C, 0x25, 0x00, 0x02, 0x2E, 0xC7, 0xFF, 0x40, 0x14,
+0x03, 0x00, 0x03, 0x24, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xC1, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x60, 0x1B, 0x22, 0x26, 0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x3C,
+0xC1, 0x43, 0x00, 0x0C, 0x0F, 0x00, 0x06, 0x24, 0xBF, 0x44, 0x00, 0x08,
+0x00, 0x08, 0x04, 0x24, 0xCC, 0xFF, 0x80, 0x14, 0x60, 0x1B, 0x22, 0x26,
+0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x0F, 0x00, 0x06, 0x24, 0xBF, 0x44, 0x00, 0x08, 0x00, 0x08, 0x04, 0x24,
+0xAD, 0xFF, 0x80, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x22, 0x26,
+0x34, 0x1C, 0x44, 0x8C, 0x0F, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0xA8, 0x44, 0x00, 0x08, 0x0F, 0x00, 0x04, 0x3C,
+0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x14, 0x00, 0xBF, 0xAF, 0xF3, 0x43, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00,
+0x40, 0x01, 0x44, 0x34, 0x21, 0x18, 0x40, 0x00, 0x1F, 0x00, 0x02, 0x2E,
+0x00, 0x23, 0x04, 0x00, 0x10, 0x00, 0x40, 0x10, 0x10, 0x00, 0x05, 0x2E,
+0x00, 0x01, 0x64, 0x34, 0x06, 0x00, 0xA0, 0x10, 0x00, 0x23, 0x04, 0x00,
+0x21, 0x10, 0x00, 0x02, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xDE, 0x43, 0x00, 0x0C,
+0xF1, 0xFF, 0x10, 0x26, 0x21, 0x10, 0x00, 0x02, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0xDE, 0x43, 0x00, 0x0C, 0xE2, 0xFF, 0x10, 0x26, 0x21, 0x10, 0x00, 0x02,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x02, 0x3C,
+0x18, 0x00, 0xBF, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x21, 0x20, 0x82, 0x00, 0x00, 0x00, 0x90, 0x8C, 0x21, 0x88, 0xA0, 0x00,
+0xB5, 0x43, 0x00, 0x0C, 0x21, 0x20, 0xA0, 0x00, 0x24, 0x80, 0x11, 0x02,
+0x06, 0x10, 0x50, 0x00, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xD8, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x02, 0x3C, 0x18, 0x00, 0xB2, 0xAF,
+0x21, 0x90, 0x82, 0x00, 0xFF, 0xFF, 0x02, 0x24, 0x1C, 0x00, 0xB3, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x21, 0x88, 0xA0, 0x00, 0x21, 0x20, 0xA0, 0x00, 0x21, 0x18, 0x40, 0x02,
+0x10, 0x00, 0xA2, 0x10, 0x21, 0x98, 0xC0, 0x00, 0x00, 0x00, 0x50, 0x8E,
+0xB5, 0x43, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x27, 0x18, 0x11, 0x00,
+0x24, 0x18, 0x70, 0x00, 0x04, 0x10, 0x53, 0x00, 0x25, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x43, 0xAE, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x28, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x66, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x21, 0x38, 0x82, 0x00, 0xFF, 0xFF, 0x02, 0x24, 0x27, 0x40, 0x05, 0x00,
+0x08, 0x00, 0xA2, 0x10, 0x24, 0x18, 0xC5, 0x00, 0x00, 0x00, 0xE2, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x02, 0x01, 0x25, 0x10, 0x43, 0x00,
+0x00, 0x00, 0xE2, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xE6, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0xFF, 0xFF, 0x02, 0x24,
+0x21, 0x80, 0xA0, 0x00, 0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x1C, 0x00, 0xBF, 0xAF, 0x21, 0x88, 0xC0, 0x00, 0x21, 0x28, 0xC0, 0x00,
+0x08, 0x00, 0x02, 0x12, 0x21, 0x90, 0x80, 0x00, 0x26, 0x5C, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x27, 0x28, 0x10, 0x00, 0x24, 0x28, 0xA2, 0x00,
+0x24, 0x10, 0x30, 0x02, 0x25, 0x28, 0xA2, 0x00, 0x21, 0x20, 0x40, 0x02,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x03, 0x5C, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27,
+0x01, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x03, 0x3C, 0xD0, 0xFF, 0xBD, 0x27,
+0x0C, 0x16, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34, 0x20, 0x00, 0xB2, 0xAF,
+0x00, 0x00, 0x62, 0xAC, 0x21, 0x90, 0x80, 0x00, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x00, 0xB3, 0xAF, 0x1C, 0x00, 0xB1, 0xAF, 0x21, 0x98, 0xC0, 0x00,
+0x21, 0x88, 0xA0, 0x00, 0x28, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x18, 0x00, 0xB0, 0xAF, 0x0F, 0x00, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x21, 0x20, 0x40, 0x02, 0x0A, 0x00, 0x22, 0x12, 0x21, 0x28, 0x60, 0x02,
+0x25, 0x44, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x20, 0x02,
+0xB5, 0x43, 0x00, 0x0C, 0x21, 0x80, 0x40, 0x00, 0x27, 0x28, 0x11, 0x00,
+0x24, 0x28, 0xB0, 0x00, 0x04, 0x10, 0x53, 0x00, 0x25, 0x28, 0xA2, 0x00,
+0x90, 0x44, 0x00, 0x0C, 0xFF, 0x00, 0x44, 0x32, 0x90, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0x01, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0xB0, 0x16, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0xE0, 0xFF, 0xBD, 0x27, 0x00, 0x00, 0x43, 0xAC, 0x18, 0x00, 0xBF, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x25, 0x44, 0x00, 0x0C,
+0x21, 0x88, 0xA0, 0x00, 0x21, 0x80, 0x40, 0x00, 0xB5, 0x43, 0x00, 0x0C,
+0x21, 0x20, 0x20, 0x02, 0x24, 0x80, 0x11, 0x02, 0x06, 0x10, 0x50, 0x00,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27,
+0x24, 0x00, 0xB5, 0xAF, 0xFF, 0x00, 0x84, 0x30, 0x21, 0xA8, 0xC0, 0x00,
+0x28, 0x00, 0xB6, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x2C, 0x00, 0xBF, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x21, 0xB0, 0xA0, 0x00, 0xF0, 0x42, 0x00, 0x0C,
+0x21, 0x98, 0x00, 0x00, 0x21, 0x00, 0xA0, 0x16, 0x80, 0x10, 0x13, 0x00,
+0xFF, 0x45, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x02, 0x24,
+0x23, 0x00, 0x02, 0x12, 0x05, 0x00, 0x04, 0x24, 0xFC, 0x00, 0x02, 0x24,
+0x37, 0x00, 0x02, 0x12, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x02, 0x24,
+0x30, 0x00, 0x02, 0x12, 0x32, 0x00, 0x04, 0x24, 0xFA, 0x00, 0x02, 0x24,
+0x2D, 0x00, 0x02, 0x12, 0x05, 0x00, 0x04, 0x24, 0xF9, 0x00, 0x02, 0x24,
+0x29, 0x00, 0x02, 0x12, 0x0F, 0x00, 0x05, 0x3C, 0x04, 0x00, 0xD1, 0x8C,
+0xFF, 0xFF, 0xA5, 0x34, 0x21, 0x20, 0x00, 0x02, 0x83, 0x45, 0x00, 0x0C,
+0x21, 0x30, 0x20, 0x02, 0x2C, 0x1F, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x19, 0x00, 0x02, 0x24, 0x28, 0x00, 0x02, 0x12, 0x21, 0x90, 0x00, 0x00,
+0x02, 0x00, 0x62, 0x26, 0xFF, 0x00, 0x53, 0x30, 0x2B, 0x18, 0x75, 0x02,
+0x0F, 0x00, 0x60, 0x10, 0x80, 0x10, 0x13, 0x00, 0x21, 0x30, 0x56, 0x00,
+0x00, 0x00, 0xD0, 0x8C, 0xFF, 0x00, 0x02, 0x24, 0x0A, 0x00, 0x02, 0x12,
+0xFE, 0x00, 0x02, 0x24, 0xDC, 0xFF, 0x02, 0x16, 0x32, 0x00, 0x04, 0x24,
+0x2C, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x62, 0x26,
+0xFF, 0x00, 0x53, 0x30, 0x2B, 0x18, 0x75, 0x02, 0xF3, 0xFF, 0x60, 0x14,
+0x80, 0x10, 0x13, 0x00, 0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0x01, 0x00, 0x04, 0x24, 0x5B, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xED, 0x45, 0x00, 0x08, 0x02, 0x00, 0x62, 0x26, 0x2C, 0x1F, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0xFB, 0x45, 0x00, 0x08, 0x02, 0x00, 0x62, 0x26,
+0x0F, 0x00, 0x14, 0x3C, 0x21, 0x20, 0x00, 0x02, 0xAC, 0x45, 0x00, 0x0C,
+0xFF, 0xFF, 0x85, 0x36, 0x21, 0x20, 0x00, 0x02, 0xFF, 0xFF, 0x85, 0x36,
+0xD2, 0xFF, 0x51, 0x10, 0x21, 0x30, 0x20, 0x02, 0x83, 0x45, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x2C, 0x1F, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x01, 0x00, 0x42, 0x26, 0xFF, 0x00, 0x52, 0x30, 0x0A, 0x00, 0x43, 0x2E,
+0xF2, 0xFF, 0x60, 0x14, 0x21, 0x20, 0x00, 0x02, 0xF0, 0x42, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x00, 0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xB0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x4C, 0x00, 0xBF, 0xAF,
+0x48, 0x00, 0xBE, 0xAF, 0x40, 0x00, 0xB6, 0xAF, 0x3C, 0x00, 0xB5, 0xAF,
+0x38, 0x00, 0xB4, 0xAF, 0x34, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xB2, 0xAF,
+0x2C, 0x00, 0xB1, 0xAF, 0x28, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0x55, 0x24,
+0x44, 0x00, 0xB7, 0xAF, 0x58, 0x38, 0xA3, 0x96, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x05, 0x3C, 0x25, 0x98, 0x62, 0x00, 0x90, 0xDE, 0xA5, 0x24,
+0x24, 0x00, 0x64, 0x26, 0x06, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x20, 0x00, 0x60, 0xA6, 0x02, 0x80, 0x05, 0x3C, 0x48, 0x37, 0xA5, 0x24,
+0x2A, 0x00, 0x64, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x05, 0x3C, 0xB4, 0x55, 0xA5, 0x24, 0x06, 0x00, 0x06, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x30, 0x00, 0x64, 0x26, 0x20, 0x00, 0x63, 0x96,
+0x02, 0x80, 0x02, 0x3C, 0xB0, 0x55, 0x42, 0x24, 0x03, 0xFF, 0x63, 0x30,
+0x80, 0x00, 0x63, 0x34, 0x74, 0x00, 0x54, 0x24, 0x20, 0x00, 0x63, 0xA6,
+0x21, 0x20, 0x80, 0x02, 0x20, 0x00, 0x02, 0x24, 0x40, 0x00, 0x72, 0x26,
+0xFB, 0x51, 0x00, 0x0C, 0x1C, 0x00, 0xA2, 0xAF, 0x21, 0x28, 0x40, 0x00,
+0x21, 0x20, 0x40, 0x02, 0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24,
+0x1C, 0x00, 0xA2, 0x8F, 0x21, 0x20, 0x80, 0x02, 0x42, 0x00, 0x72, 0x26,
+0x02, 0x00, 0x42, 0x24, 0x16, 0x52, 0x00, 0x0C, 0x1C, 0x00, 0xA2, 0xAF,
+0x21, 0x28, 0x40, 0x00, 0x21, 0x20, 0x40, 0x02, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x02, 0x80, 0x03, 0x3C, 0xB0, 0x55, 0x63, 0x24,
+0x1C, 0x00, 0xA2, 0x8F, 0x0C, 0x00, 0x66, 0x8C, 0x60, 0x00, 0x71, 0x24,
+0x1C, 0x00, 0xB0, 0x27, 0x10, 0x00, 0x67, 0x24, 0x21, 0x28, 0x00, 0x00,
+0x02, 0x00, 0x42, 0x24, 0x44, 0x00, 0x64, 0x26, 0x1C, 0x00, 0xA2, 0xAF,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x20, 0x20, 0x02,
+0x1B, 0x53, 0x00, 0x0C, 0x21, 0x90, 0x40, 0x00, 0x21, 0xB0, 0x40, 0x00,
+0x08, 0x00, 0x06, 0x24, 0x09, 0x00, 0x42, 0x2C, 0x21, 0x20, 0x40, 0x02,
+0x21, 0x38, 0x20, 0x02, 0x0B, 0x30, 0xC2, 0x02, 0x01, 0x00, 0x05, 0x24,
+0x20, 0x00, 0xA2, 0xAF, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x03, 0x3C, 0xB0, 0x55, 0x63, 0x24, 0x48, 0x00, 0x67, 0x24,
+0x21, 0x20, 0x40, 0x00, 0x03, 0x00, 0x05, 0x24, 0x01, 0x00, 0x06, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x20, 0x40, 0x00,
+0x06, 0x00, 0x05, 0x24, 0x02, 0x00, 0x06, 0x24, 0x18, 0x00, 0xA7, 0x27,
+0x18, 0x00, 0xA0, 0xA7, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB0, 0xAF,
+0x18, 0x00, 0xA5, 0x97, 0x02, 0x80, 0x04, 0x3C, 0x58, 0xE8, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x21, 0x90, 0x40, 0x00, 0xC0, 0x3A, 0xA2, 0x8E,
+0x0C, 0x00, 0x11, 0x24, 0x2B, 0x10, 0x22, 0x02, 0x3B, 0x00, 0x40, 0x10,
+0x21, 0xF0, 0x00, 0x02, 0x02, 0x80, 0x02, 0x3C, 0x21, 0x80, 0x80, 0x02,
+0xAA, 0x46, 0x00, 0x08, 0x26, 0x56, 0x57, 0x24, 0x21, 0x10, 0x30, 0x02,
+0x01, 0x00, 0x43, 0x90, 0xC0, 0x3A, 0xA4, 0x8E, 0x21, 0x18, 0x71, 0x00,
+0x02, 0x00, 0x71, 0x24, 0x2B, 0x20, 0x24, 0x02, 0x2F, 0x00, 0x80, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x30, 0x02, 0x00, 0x00, 0x47, 0x90,
+0x02, 0x80, 0x14, 0x3C, 0x2D, 0x00, 0x03, 0x24, 0x21, 0x28, 0x37, 0x02,
+0x64, 0x5C, 0x84, 0x26, 0xF1, 0xFF, 0xE3, 0x14, 0x20, 0x00, 0x06, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x04, 0x41, 0xA3, 0x96,
+0x02, 0x80, 0x02, 0x3C, 0xC6, 0x5C, 0x47, 0x90, 0xBD, 0xFF, 0x63, 0x30,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x0C, 0x00, 0x63, 0x34,
+0x01, 0x00, 0xE7, 0x30, 0x44, 0xDF, 0xA5, 0x24, 0x67, 0x5C, 0x44, 0x24,
+0x10, 0x00, 0x06, 0x24, 0x06, 0x00, 0xE0, 0x14, 0x04, 0x41, 0xA3, 0xA6,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x54, 0xDF, 0xA5, 0x24,
+0x67, 0x5C, 0x64, 0x24, 0x10, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x30, 0x02, 0x01, 0x00, 0x46, 0x90,
+0x21, 0x20, 0x40, 0x02, 0x64, 0x5C, 0x87, 0x26, 0x2D, 0x00, 0x05, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xBE, 0xAF, 0x21, 0x90, 0x40, 0x00,
+0x21, 0x10, 0x30, 0x02, 0x01, 0x00, 0x43, 0x90, 0xC0, 0x3A, 0xA4, 0x8E,
+0x21, 0x18, 0x71, 0x00, 0x02, 0x00, 0x71, 0x24, 0x2B, 0x20, 0x24, 0x02,
+0xD4, 0xFF, 0x80, 0x14, 0x21, 0x10, 0x30, 0x02, 0x20, 0x00, 0xA2, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x1C, 0x00, 0xA2, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x42, 0x24,
+0x01, 0x01, 0x42, 0x2C, 0x1A, 0x00, 0x40, 0x14, 0x21, 0x20, 0x60, 0x02,
+0x4C, 0x00, 0xBF, 0x8F, 0x48, 0x00, 0xBE, 0x8F, 0x44, 0x00, 0xB7, 0x8F,
+0x40, 0x00, 0xB6, 0x8F, 0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F,
+0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F,
+0x28, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x50, 0x00, 0xBD, 0x27,
+0xB0, 0x55, 0x63, 0x24, 0x21, 0x20, 0x40, 0x02, 0xF8, 0xFF, 0xC6, 0x26,
+0x68, 0x00, 0x67, 0x24, 0x32, 0x00, 0x05, 0x24, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xBE, 0xAF, 0x1C, 0x00, 0xA2, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x00, 0x42, 0x24, 0x01, 0x01, 0x42, 0x2C, 0xE8, 0xFF, 0x40, 0x10,
+0x21, 0x20, 0x60, 0x02, 0x21, 0x28, 0x00, 0x00, 0xEC, 0x54, 0x00, 0x0C,
+0x08, 0x00, 0x06, 0x24, 0x08, 0x00, 0x64, 0x8E, 0x04, 0x00, 0x65, 0x8E,
+0xFF, 0xDF, 0x02, 0x3C, 0x10, 0x00, 0x66, 0x8E, 0x14, 0x00, 0x67, 0x8E,
+0xFF, 0xFF, 0x42, 0x34, 0x1C, 0x00, 0xA8, 0x8F, 0x24, 0x20, 0x82, 0x00,
+0x00, 0x40, 0x03, 0x3C, 0xFF, 0xE0, 0x02, 0x24, 0x24, 0x28, 0xA2, 0x00,
+0x25, 0x20, 0x83, 0x00, 0x00, 0x80, 0x02, 0x3C, 0xFF, 0x81, 0x03, 0x24,
+0x25, 0x30, 0xC2, 0x00, 0x24, 0x38, 0xE3, 0x00, 0x00, 0x10, 0xA5, 0x34,
+0x02, 0x80, 0x03, 0x3C, 0x80, 0x00, 0x84, 0x34, 0x20, 0x00, 0x02, 0x24,
+0x08, 0x00, 0x64, 0xAE, 0x00, 0x00, 0x68, 0xA6, 0x02, 0x00, 0x62, 0xA2,
+0x14, 0x00, 0x67, 0xAE, 0x04, 0x00, 0x65, 0xAE, 0x10, 0x00, 0x66, 0xAE,
+0x60, 0x1B, 0x62, 0x24, 0xEC, 0x37, 0x46, 0x8C, 0x58, 0x38, 0x45, 0x8C,
+0x01, 0x00, 0x04, 0x24, 0x00, 0x01, 0x07, 0x24, 0x01, 0x00, 0x02, 0x24,
+0x1E, 0x01, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0x5B, 0x01, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x4C, 0x00, 0xBF, 0x8F, 0x48, 0x00, 0xBE, 0x8F,
+0x44, 0x00, 0xB7, 0x8F, 0x40, 0x00, 0xB6, 0x8F, 0x3C, 0x00, 0xB5, 0x8F,
+0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F, 0x30, 0x00, 0xB2, 0x8F,
+0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x50, 0x00, 0xBD, 0x27, 0xA0, 0xFF, 0xBD, 0x27, 0x5C, 0x00, 0xBF, 0xAF,
+0x58, 0x00, 0xBE, 0xAF, 0x54, 0x00, 0xB7, 0xAF, 0x50, 0x00, 0xB6, 0xAF,
+0x4C, 0x00, 0xB5, 0xAF, 0x48, 0x00, 0xB4, 0xAF, 0x44, 0x00, 0xB3, 0xAF,
+0x40, 0x00, 0xB2, 0xAF, 0x3C, 0x00, 0xB1, 0xAF, 0x38, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x0B, 0x3C, 0x64, 0xE8, 0x82, 0x24,
+0x78, 0xE8, 0x63, 0x25, 0x78, 0xE8, 0x6B, 0x91, 0x01, 0x00, 0x45, 0x90,
+0x0D, 0x00, 0x48, 0x90, 0x0C, 0x00, 0x58, 0x90, 0x64, 0xE8, 0x97, 0x90,
+0x02, 0x00, 0x54, 0x90, 0x0E, 0x00, 0x50, 0x90, 0x01, 0x00, 0x69, 0x90,
+0x30, 0x00, 0xAB, 0xAF, 0x03, 0x00, 0x4B, 0x90, 0x04, 0x00, 0x76, 0x90,
+0x05, 0x00, 0x6A, 0x90, 0x02, 0x00, 0x6F, 0x90, 0x06, 0x00, 0x64, 0x90,
+0x07, 0x00, 0x75, 0x90, 0x03, 0x00, 0x71, 0x90, 0x00, 0x2A, 0x05, 0x00,
+0x30, 0x00, 0xA3, 0x8F, 0x00, 0x42, 0x08, 0x00, 0x25, 0x40, 0x18, 0x01,
+0x25, 0x28, 0xB7, 0x00, 0x00, 0xA4, 0x14, 0x00, 0x00, 0x84, 0x10, 0x00,
+0x25, 0xA0, 0x85, 0x02, 0x25, 0x80, 0x08, 0x02, 0x00, 0x4A, 0x09, 0x00,
+0x00, 0x5E, 0x0B, 0x00, 0x02, 0x80, 0x08, 0x3C, 0x05, 0x00, 0x46, 0x90,
+0x09, 0x00, 0x47, 0x90, 0x25, 0x48, 0x23, 0x01, 0x00, 0x52, 0x0A, 0x00,
+0x60, 0x1B, 0x03, 0x25, 0x25, 0x58, 0x74, 0x01, 0x04, 0x00, 0x5E, 0x90,
+0x06, 0x00, 0x53, 0x90, 0x08, 0x00, 0x59, 0x90, 0x0A, 0x00, 0x52, 0x90,
+0x07, 0x00, 0x4C, 0x90, 0x0B, 0x00, 0x4D, 0x90, 0x0F, 0x00, 0x4E, 0x90,
+0x11, 0x00, 0x58, 0x90, 0x25, 0x50, 0x56, 0x01, 0x10, 0x00, 0x56, 0x90,
+0x10, 0x00, 0xAB, 0xAF, 0x06, 0x41, 0x62, 0x90, 0x00, 0x32, 0x06, 0x00,
+0x00, 0x3A, 0x07, 0x00, 0x00, 0x7C, 0x0F, 0x00, 0x00, 0x24, 0x04, 0x00,
+0x25, 0x30, 0xDE, 0x00, 0x25, 0x38, 0xF9, 0x00, 0x25, 0x20, 0x8A, 0x00,
+0x1C, 0x00, 0x43, 0x30, 0x00, 0x9C, 0x13, 0x00, 0x00, 0x94, 0x12, 0x00,
+0x25, 0x78, 0xE9, 0x01, 0x00, 0x8E, 0x11, 0x00, 0x00, 0xAE, 0x15, 0x00,
+0x25, 0x98, 0x66, 0x02, 0x25, 0x90, 0x47, 0x02, 0x03, 0x00, 0x46, 0x30,
+0x25, 0xA8, 0xA4, 0x02, 0x25, 0x88, 0x2F, 0x02, 0x10, 0x00, 0xA7, 0x27,
+0x83, 0x18, 0x03, 0x00, 0x02, 0x00, 0xC4, 0x24, 0x28, 0x00, 0xB1, 0xAF,
+0x2C, 0x00, 0xB5, 0xAF, 0x21, 0x18, 0xE3, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x04, 0x10, 0x82, 0x00, 0x18, 0x00, 0x65, 0x90, 0xFF, 0x00, 0x46, 0x30,
+0x00, 0x66, 0x0C, 0x00, 0x00, 0x6E, 0x0D, 0x00, 0x00, 0x76, 0x0E, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0x25, 0x60, 0x93, 0x01, 0x25, 0x68, 0xB2, 0x01,
+0x25, 0x70, 0xD0, 0x01, 0x10, 0x00, 0xC4, 0x2C, 0x37, 0x02, 0x42, 0x34,
+0x0F, 0x00, 0x03, 0x24, 0x14, 0x00, 0xAC, 0xAF, 0x18, 0x00, 0xAD, 0xAF,
+0x1C, 0x00, 0xAE, 0xAF, 0x20, 0x00, 0xB6, 0xA3, 0x21, 0x00, 0xB8, 0xA3,
+0x0A, 0x30, 0x64, 0x00, 0x00, 0x00, 0x45, 0xA0, 0x21, 0x28, 0x00, 0x00,
+0x21, 0x20, 0xE5, 0x00, 0x00, 0x00, 0x82, 0x90, 0x01, 0x00, 0xA5, 0x24,
+0x2B, 0x10, 0xC2, 0x00, 0x02, 0x00, 0x40, 0x10, 0x11, 0x00, 0xA3, 0x2C,
+0x00, 0x00, 0x86, 0xA0, 0xF9, 0xFF, 0x60, 0x14, 0x21, 0x20, 0xE5, 0x00,
+0x21, 0x30, 0xE0, 0x00, 0x21, 0x28, 0x00, 0x00, 0x25, 0xB0, 0x07, 0x3C,
+0x01, 0x00, 0xC2, 0x90, 0x00, 0x00, 0xC3, 0x90, 0x21, 0x20, 0xA7, 0x00,
+0x00, 0x11, 0x02, 0x00, 0x25, 0x10, 0x43, 0x00, 0x01, 0x00, 0xA5, 0x24,
+0xFF, 0x00, 0x42, 0x30, 0x08, 0x00, 0xA3, 0x2C, 0xA8, 0x01, 0x82, 0xA0,
+0xF6, 0xFF, 0x60, 0x14, 0x02, 0x00, 0xC6, 0x24, 0x21, 0x00, 0xA2, 0x93,
+0x20, 0x00, 0xA4, 0x93, 0x02, 0x80, 0x03, 0x3C, 0x00, 0x11, 0x02, 0x00,
+0xD9, 0x5C, 0x66, 0x90, 0x25, 0x10, 0x44, 0x00, 0xFF, 0x00, 0x42, 0x30,
+0xA7, 0x01, 0xE3, 0x34, 0x00, 0x00, 0x62, 0xA0, 0x01, 0x00, 0x02, 0x24,
+0x0F, 0x00, 0xC2, 0x10, 0x60, 0x1B, 0x07, 0x25, 0x60, 0x1B, 0x02, 0x25,
+0x00, 0x41, 0x40, 0xAC, 0x5C, 0x00, 0xBF, 0x8F, 0x58, 0x00, 0xBE, 0x8F,
+0x54, 0x00, 0xB7, 0x8F, 0x50, 0x00, 0xB6, 0x8F, 0x4C, 0x00, 0xB5, 0x8F,
+0x48, 0x00, 0xB4, 0x8F, 0x44, 0x00, 0xB3, 0x8F, 0x40, 0x00, 0xB2, 0x8F,
+0x3C, 0x00, 0xB1, 0x8F, 0x38, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x60, 0x00, 0xBD, 0x27, 0x04, 0x41, 0xE2, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x42, 0x30, 0xEF, 0xFF, 0x40, 0x10, 0x60, 0x1B, 0x02, 0x25,
+0x25, 0x41, 0xE3, 0x90, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x62, 0x30,
+0xEA, 0xFF, 0x40, 0x10, 0x60, 0x1B, 0x02, 0x25, 0x03, 0x00, 0x63, 0x30,
+0x10, 0x00, 0x66, 0x10, 0x03, 0x00, 0x02, 0x24, 0x07, 0x00, 0x62, 0x10,
+0x60, 0x1B, 0x02, 0x25, 0x00, 0x41, 0x40, 0xAC, 0x21, 0x20, 0x00, 0x00,
+0x95, 0x0E, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0xBE, 0x47, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x34, 0x02, 0x00, 0x05, 0x24,
+0x00, 0x41, 0xE6, 0xAC, 0x95, 0x0E, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xBE, 0x47, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x34,
+0x01, 0x00, 0x05, 0x24, 0xE2, 0x47, 0x00, 0x08, 0x00, 0x41, 0xE6, 0xAC,
+0xE8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x06, 0x3C, 0x14, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0xB4, 0x55, 0xC2, 0x24, 0x01, 0x00, 0x44, 0x90,
+0xB4, 0x55, 0xC3, 0x90, 0x02, 0x00, 0x45, 0x90, 0x03, 0x00, 0x46, 0x90,
+0x05, 0x00, 0x47, 0x90, 0x04, 0x00, 0x48, 0x90, 0x00, 0x22, 0x04, 0x00,
+0x25, 0x18, 0x64, 0x00, 0x00, 0x2C, 0x05, 0x00, 0x25, 0xB0, 0x10, 0x3C,
+0x25, 0x18, 0x65, 0x00, 0x00, 0x36, 0x06, 0x00, 0x00, 0x3A, 0x07, 0x00,
+0x25, 0x18, 0x66, 0x00, 0x58, 0x00, 0x02, 0x36, 0x5C, 0x00, 0x05, 0x36,
+0x25, 0x40, 0x07, 0x01, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x43, 0xAC,
+0xB0, 0x55, 0x84, 0x24, 0x00, 0x00, 0xA8, 0xAC, 0xFD, 0x51, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x03, 0x36, 0x00, 0x00, 0x62, 0xA4,
+0x48, 0x00, 0x10, 0x36, 0x00, 0x00, 0x02, 0x8E, 0x84, 0x00, 0x03, 0x3C,
+0x14, 0x00, 0xBF, 0x8F, 0x25, 0x10, 0x43, 0x00, 0x00, 0x00, 0x02, 0xAE,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0x24, 0x00, 0x04, 0x24, 0x21, 0x30, 0x40, 0x00,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x50, 0x24,
+0x21, 0x20, 0xC0, 0x00, 0x13, 0x00, 0xC0, 0x10, 0x80, 0xE8, 0xA5, 0x24,
+0x04, 0x00, 0x02, 0x24, 0x09, 0x00, 0x03, 0x24, 0x0C, 0x00, 0xC2, 0xAC,
+0x14, 0x00, 0xC3, 0xAC, 0x08, 0x00, 0xC5, 0x94, 0x3C, 0x3E, 0x03, 0x8E,
+0x02, 0x80, 0x02, 0x3C, 0x25, 0x28, 0xA2, 0x00, 0x17, 0x0A, 0x00, 0x0C,
+0x20, 0x00, 0xA3, 0xAC, 0x40, 0x3E, 0x06, 0x8E, 0x3C, 0x3E, 0x05, 0x8E,
+0x02, 0x80, 0x04, 0x3C, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x94, 0xE8, 0x84, 0x24, 0x13, 0x58, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0x02, 0x80, 0x04, 0x3C, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0xAC, 0xE8, 0x84, 0x24, 0x13, 0x58, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x02, 0x3C, 0xB0, 0x55, 0x43, 0x8C, 0x21, 0x90, 0x80, 0x00,
+0x3C, 0x00, 0x64, 0x24, 0x53, 0x21, 0x00, 0x0C, 0x1C, 0x00, 0x73, 0x24,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x04, 0x3C, 0x21, 0x88, 0x40, 0x00,
+0xB0, 0x55, 0xA5, 0x24, 0x74, 0x03, 0x06, 0x24, 0x19, 0x00, 0x40, 0x10,
+0xC8, 0xE8, 0x84, 0x24, 0x08, 0x00, 0x50, 0x94, 0x0A, 0x00, 0x02, 0x24,
+0x14, 0x00, 0x22, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x25, 0x80, 0x02, 0x02,
+0x0C, 0x00, 0x33, 0xAE, 0x3C, 0x00, 0x04, 0x26, 0xF4, 0x54, 0x00, 0x0C,
+0x20, 0x00, 0x10, 0x26, 0x18, 0x00, 0x12, 0xAE, 0x21, 0x20, 0x20, 0x02,
+0x17, 0x0A, 0x00, 0x0C, 0x14, 0x00, 0x12, 0xAE, 0x02, 0x80, 0x04, 0x3C,
+0x21, 0x28, 0x40, 0x02, 0x21, 0x30, 0x60, 0x02, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0xD8, 0xE8, 0x84, 0x24, 0x13, 0x58, 0x00, 0x08,
+0x28, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x06, 0x3C, 0x21, 0x28, 0x60, 0x02,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xB8, 0xE8, 0xC6, 0x24,
+0x13, 0x58, 0x00, 0x08, 0x28, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB2, 0xAF, 0xFF, 0xFF, 0x92, 0x30, 0x2A, 0x00, 0x04, 0x24,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x1C, 0x00, 0xBF, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0xFF, 0x00, 0xB1, 0x30, 0x02, 0x80, 0x05, 0x3C,
+0x21, 0x80, 0x40, 0x00, 0xB4, 0x55, 0xA5, 0x24, 0x13, 0x00, 0x40, 0x10,
+0x06, 0x00, 0x06, 0x24, 0x08, 0x00, 0x44, 0x94, 0x0A, 0x00, 0x02, 0x24,
+0x0C, 0x00, 0x02, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x25, 0x20, 0x82, 0x00,
+0x20, 0x00, 0x84, 0x24, 0x19, 0x00, 0x03, 0x24, 0x14, 0x00, 0x03, 0xAE,
+0x06, 0x00, 0x92, 0xA4, 0xF4, 0x54, 0x00, 0x0C, 0x08, 0x00, 0x91, 0xA0,
+0x21, 0x20, 0x00, 0x02, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x17, 0x0A, 0x00, 0x08,
+0x20, 0x00, 0xBD, 0x27, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xBF, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x02, 0x00, 0x82, 0x90,
+0x02, 0x80, 0x12, 0x3C, 0x60, 0x1B, 0x51, 0x26, 0xB0, 0x1B, 0x25, 0x96,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x10, 0x02, 0x00, 0x21, 0x80, 0x44, 0x00,
+0x00, 0x01, 0xA3, 0x30, 0x04, 0x00, 0x60, 0x10, 0x18, 0x00, 0x04, 0x26,
+0x00, 0x10, 0xA2, 0x30, 0x0B, 0x00, 0x40, 0x10, 0x04, 0x00, 0xA2, 0x30,
+0x21, 0x18, 0x00, 0x00, 0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xF5, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x39, 0x53, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x48, 0x37, 0x84, 0x24, 0x21, 0x28, 0x40, 0x00, 0x1D, 0x55, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0xED, 0xFF, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xB4, 0x55, 0x53, 0x24, 0x22, 0x00, 0x14, 0x26,
+0x21, 0x20, 0x80, 0x02, 0x21, 0x28, 0x60, 0x02, 0x1D, 0x55, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0xE4, 0xFF, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00,
+0x28, 0x00, 0x04, 0x26, 0x21, 0x28, 0x60, 0x02, 0x1D, 0x55, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0xDE, 0xFF, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C, 0x38, 0xE9, 0x84, 0x24,
+0xB0, 0x1B, 0x24, 0x96, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x83, 0x30,
+0x01, 0x00, 0x62, 0x30, 0x08, 0x00, 0x40, 0x10, 0x00, 0x20, 0x62, 0x30,
+0x1B, 0x00, 0x40, 0x10, 0xFF, 0xDE, 0x82, 0x30, 0xB0, 0x1B, 0x22, 0xA6,
+0xFE, 0xFF, 0x04, 0x24, 0xCC, 0x39, 0x20, 0xAE, 0x35, 0x48, 0x00, 0x0C,
+0xB0, 0x39, 0x20, 0xAE, 0x25, 0xB0, 0x10, 0x3C, 0x60, 0x1B, 0x51, 0x26,
+0x4C, 0x00, 0x02, 0x36, 0x00, 0x00, 0x40, 0xA0, 0x48, 0x00, 0x10, 0x36,
+0x21, 0x20, 0x00, 0x00, 0x21, 0x28, 0x00, 0x00, 0x95, 0x0E, 0x00, 0x0C,
+0x37, 0x3E, 0x20, 0xA2, 0x00, 0x00, 0x03, 0x8E, 0x7B, 0xFF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00, 0x00, 0x00, 0x03, 0xAE,
+0xBC, 0x40, 0x20, 0xAE, 0xE8, 0x39, 0x20, 0xAE, 0x04, 0x3A, 0x20, 0xAE,
+0x87, 0x54, 0x00, 0x0C, 0xFC, 0x40, 0x20, 0xAE, 0xA5, 0x48, 0x00, 0x08,
+0x21, 0x18, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x0C, 0x21, 0x20, 0x80, 0x02,
+0xB5, 0xFF, 0x40, 0x14, 0xFF, 0xFF, 0x03, 0x24, 0xB0, 0x1B, 0x22, 0x96,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x42, 0x30, 0xD8, 0x48, 0x00, 0x08,
+0xB0, 0x1B, 0x22, 0xA6, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x10, 0x3C, 0x60, 0x1B, 0x10, 0x26, 0x02, 0x00, 0x02, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0x00, 0x80, 0x06, 0x3C, 0x44, 0x3A, 0x02, 0xA2,
+0x90, 0x55, 0x84, 0x24, 0x21, 0x28, 0x00, 0x00, 0x3C, 0x3A, 0x00, 0xAE,
+0x14, 0x00, 0xBF, 0xAF, 0xCF, 0x20, 0x00, 0x0C, 0x70, 0x3C, 0xC6, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0xD1, 0x5C, 0x44, 0x90, 0x02, 0x80, 0x03, 0x3C,
+0x49, 0xF5, 0x65, 0x90, 0x10, 0x27, 0x02, 0x24, 0x0B, 0x10, 0x04, 0x00,
+0x01, 0x00, 0x84, 0x2C, 0x3C, 0x3A, 0x02, 0xAE, 0x49, 0x41, 0x05, 0xA2,
+0x48, 0x41, 0x04, 0xA2, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xB8, 0xFF, 0xBD, 0x27,
+0x00, 0x01, 0x04, 0x24, 0x3C, 0x00, 0xB3, 0xAF, 0x38, 0x00, 0xB2, 0xAF,
+0x34, 0x00, 0xB1, 0xAF, 0x40, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xB0, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0x02, 0x80, 0x13, 0x3C, 0x02, 0x80, 0x04, 0x3C,
+0x21, 0x88, 0x40, 0x00, 0x90, 0xDE, 0x65, 0x26, 0x06, 0x00, 0x06, 0x24,
+0x0C, 0x00, 0x52, 0x24, 0x4D, 0x00, 0x40, 0x10, 0x58, 0xE9, 0x84, 0x24,
+0x08, 0x00, 0x50, 0x94, 0x02, 0x80, 0x02, 0x3C, 0x25, 0x80, 0x02, 0x02,
+0x24, 0x00, 0x04, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x20, 0x00, 0x00, 0xA6,
+0x02, 0x80, 0x05, 0x3C, 0x2A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x30, 0x00, 0x04, 0x26,
+0x90, 0xDE, 0x65, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x20, 0x00, 0x03, 0x96, 0x18, 0x00, 0x02, 0x24, 0x02, 0x80, 0x04, 0x3C,
+0x03, 0xFF, 0x63, 0x30, 0x40, 0x00, 0x63, 0x34, 0x20, 0x00, 0x03, 0xA6,
+0x60, 0x1B, 0x84, 0x24, 0x0C, 0x00, 0x22, 0xAE, 0xE4, 0x1D, 0x82, 0x94,
+0x20, 0x00, 0x06, 0x26, 0x02, 0x80, 0x07, 0x3C, 0xFF, 0x0F, 0x43, 0x30,
+0x00, 0x19, 0x03, 0x00, 0x02, 0x2A, 0x03, 0x00, 0x01, 0x00, 0x42, 0x24,
+0xE4, 0x1D, 0x82, 0xA4, 0x16, 0x00, 0xC3, 0xA0, 0x17, 0x00, 0xC5, 0xA0,
+0x0C, 0x3E, 0x86, 0x8C, 0x70, 0x59, 0xE7, 0x24, 0x38, 0x00, 0x04, 0x26,
+0x21, 0x28, 0x00, 0x00, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB2, 0xAF,
+0x18, 0x00, 0xA4, 0x27, 0x28, 0x00, 0xA5, 0x27, 0x05, 0x53, 0x00, 0x0C,
+0x21, 0x80, 0x40, 0x00, 0x28, 0x00, 0xA3, 0x8F, 0x21, 0x20, 0x00, 0x02,
+0x18, 0x00, 0xA7, 0x27, 0x09, 0x00, 0x62, 0x28, 0x01, 0x00, 0x05, 0x24,
+0x13, 0x00, 0x40, 0x10, 0x08, 0x00, 0x06, 0x24, 0x21, 0x20, 0x00, 0x02,
+0x21, 0x30, 0x60, 0x00, 0x01, 0x00, 0x05, 0x24, 0x18, 0x00, 0xA7, 0x27,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB2, 0xAF, 0x21, 0x20, 0x20, 0x02,
+0x01, 0x00, 0x05, 0x24, 0x21, 0x30, 0x00, 0x00, 0xDF, 0x0D, 0x00, 0x0C,
+0x21, 0x38, 0x00, 0x00, 0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB3, 0x8F,
+0x38, 0x00, 0xB2, 0x8F, 0x34, 0x00, 0xB1, 0x8F, 0x30, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xB2, 0xAF, 0x28, 0x00, 0xA6, 0x8F, 0x21, 0x20, 0x40, 0x00,
+0x32, 0x00, 0x05, 0x24, 0xF8, 0xFF, 0xC6, 0x24, 0x58, 0x49, 0x00, 0x08,
+0x20, 0x00, 0xA7, 0x27, 0x02, 0x80, 0x05, 0x3C, 0x13, 0x58, 0x00, 0x0C,
+0x48, 0xE9, 0xA5, 0x24, 0x40, 0x00, 0xBF, 0x8F, 0x3C, 0x00, 0xB3, 0x8F,
+0x38, 0x00, 0xB2, 0x8F, 0x34, 0x00, 0xB1, 0x8F, 0x30, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0xA8, 0xFF, 0xBD, 0x27, 0x48, 0x00, 0xB6, 0xAF,
+0x3C, 0x00, 0xB3, 0xAF, 0x38, 0x00, 0xB2, 0xAF, 0x30, 0x00, 0xB0, 0xAF,
+0x54, 0x00, 0xBF, 0xAF, 0x50, 0x00, 0xBE, 0xAF, 0x4C, 0x00, 0xB7, 0xAF,
+0x44, 0x00, 0xB5, 0xAF, 0x40, 0x00, 0xB4, 0xAF, 0x34, 0x00, 0xB1, 0xAF,
+0x02, 0x00, 0x82, 0x90, 0x00, 0x00, 0x83, 0x8C, 0x21, 0xB0, 0x00, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0xC0, 0x10, 0x02, 0x00, 0x21, 0x80, 0x44, 0x00,
+0x18, 0x00, 0x12, 0x26, 0x21, 0x20, 0x40, 0x02, 0x39, 0x53, 0x00, 0x0C,
+0xFF, 0x3F, 0x73, 0x30, 0x02, 0x80, 0x04, 0x3C, 0x48, 0x37, 0x84, 0x24,
+0x21, 0x28, 0x40, 0x00, 0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x0B, 0x00, 0x40, 0x14, 0x02, 0x80, 0x15, 0x3C, 0x60, 0x1B, 0xB1, 0x26,
+0xB0, 0x1B, 0x23, 0x96, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x62, 0x30,
+0x05, 0x00, 0x40, 0x10, 0x00, 0x10, 0x62, 0x30, 0x03, 0x00, 0x40, 0x14,
+0x00, 0x01, 0x62, 0x30, 0x0E, 0x00, 0x40, 0x10, 0x20, 0x00, 0xB4, 0x27,
+0x54, 0x00, 0xBF, 0x8F, 0x50, 0x00, 0xBE, 0x8F, 0x4C, 0x00, 0xB7, 0x8F,
+0x48, 0x00, 0xB6, 0x8F, 0x44, 0x00, 0xB5, 0x8F, 0x40, 0x00, 0xB4, 0x8F,
+0x3C, 0x00, 0xB3, 0x8F, 0x38, 0x00, 0xB2, 0x8F, 0x34, 0x00, 0xB1, 0x8F,
+0x30, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x58, 0x00, 0xBD, 0x27, 0x32, 0x00, 0x05, 0x26, 0x21, 0x20, 0x80, 0x02,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24, 0x20, 0x00, 0xA5, 0x97,
+0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0xA0, 0x14, 0x02, 0x80, 0x04, 0x3C,
+0x21, 0x20, 0x80, 0x02, 0x34, 0x00, 0x05, 0x26, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x20, 0x00, 0xA2, 0x97, 0x21, 0x20, 0x80, 0x02,
+0x30, 0x00, 0x05, 0x26, 0xFF, 0x3F, 0x42, 0x30, 0x02, 0x00, 0x06, 0x24,
+0x4C, 0x3A, 0x22, 0xA6, 0xF4, 0x54, 0x00, 0x0C, 0x28, 0x00, 0xA2, 0xAF,
+0x20, 0x00, 0xA3, 0x97, 0x21, 0x40, 0x20, 0x02, 0x00, 0x04, 0x63, 0x30,
+0x02, 0x00, 0x60, 0x14, 0x09, 0x00, 0x02, 0x24, 0x14, 0x00, 0x02, 0x24,
+0x1E, 0x00, 0x5E, 0x26, 0xE2, 0xFF, 0x77, 0x26, 0x21, 0x20, 0xC0, 0x03,
+0x01, 0x00, 0x05, 0x24, 0x24, 0x00, 0xA6, 0x27, 0x21, 0x38, 0xE0, 0x02,
+0xAB, 0x1A, 0x00, 0x0C, 0xB8, 0x40, 0x02, 0xA1, 0x9E, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0xA6, 0x8F, 0x02, 0x00, 0x45, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x21, 0x20, 0xC0, 0x03,
+0x32, 0x00, 0x05, 0x24, 0x24, 0x00, 0xA6, 0x27, 0x24, 0x00, 0xB4, 0x8F,
+0xAB, 0x1A, 0x00, 0x0C, 0x21, 0x38, 0xE0, 0x02, 0x08, 0x00, 0x40, 0x10,
+0x10, 0x00, 0xA4, 0x27, 0x24, 0x00, 0xA6, 0x8F, 0x21, 0x20, 0x94, 0x00,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x45, 0x24, 0x24, 0x00, 0xA3, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x21, 0xA0, 0x83, 0x02, 0x02, 0x80, 0x02, 0x3C,
+0xD2, 0x5C, 0x44, 0x90, 0x02, 0x00, 0x03, 0x24, 0xDA, 0x00, 0x83, 0x10,
+0x21, 0x20, 0xC0, 0x03, 0x60, 0x1B, 0xA4, 0x26, 0xBC, 0x40, 0x82, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x40, 0x10, 0x60, 0x1B, 0xB1, 0x26,
+0x02, 0x80, 0x02, 0x3C, 0xCE, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x1D, 0x00, 0x60, 0x14, 0x23, 0x10, 0xD2, 0x03, 0x2B, 0x10, 0x53, 0x00,
+0x1A, 0x00, 0x40, 0x10, 0x21, 0x80, 0xC0, 0x03, 0x02, 0x80, 0x11, 0x3C,
+0x21, 0x20, 0x00, 0x02, 0xDD, 0x00, 0x05, 0x24, 0x24, 0x00, 0xA6, 0x27,
+0xAB, 0x1A, 0x00, 0x0C, 0x21, 0x38, 0xE0, 0x02, 0x21, 0x80, 0x40, 0x00,
+0x02, 0x00, 0x44, 0x24, 0x68, 0xDE, 0x25, 0x26, 0x03, 0x01, 0x40, 0x10,
+0x06, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x05, 0x01, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0xA2, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x02, 0x02, 0x02, 0x00, 0x70, 0x24,
+0x23, 0x20, 0x12, 0x02, 0xF8, 0x00, 0x40, 0x10, 0x2B, 0x20, 0x93, 0x00,
+0xEB, 0xFF, 0x80, 0x14, 0x21, 0x20, 0x00, 0x02, 0x60, 0x1B, 0xB1, 0x26,
+0xFC, 0x40, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x40, 0x14,
+0x24, 0x00, 0xA6, 0x27, 0xA9, 0x1B, 0x00, 0x0C, 0x60, 0x1B, 0xB2, 0x26,
+0xB0, 0x1B, 0x45, 0x96, 0x25, 0xB0, 0x17, 0x3C, 0x02, 0x00, 0x03, 0x24,
+0x4C, 0x00, 0xE4, 0x36, 0x00, 0x00, 0x83, 0xA0, 0x00, 0x01, 0xA5, 0x34,
+0xE8, 0x39, 0x42, 0xAE, 0x60, 0xEA, 0x02, 0x34, 0x04, 0x3A, 0x42, 0xAE,
+0xEA, 0x47, 0x00, 0x0C, 0xB0, 0x1B, 0x45, 0xA6, 0x10, 0x00, 0xA4, 0x27,
+0x61, 0x53, 0x00, 0x0C, 0x21, 0x28, 0x80, 0x02, 0x0F, 0x00, 0x50, 0x30,
+0x10, 0x00, 0xA4, 0x27, 0x7A, 0x53, 0x00, 0x0C, 0x21, 0x28, 0x80, 0x02,
+0x40, 0x02, 0x13, 0x36, 0x21, 0x20, 0x60, 0x02, 0x63, 0x5E, 0x00, 0x74,
+0x21, 0x28, 0x40, 0x00, 0x21, 0x28, 0x80, 0x02, 0xA6, 0x53, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x21, 0x88, 0x40, 0x00, 0xFC, 0x40, 0x42, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x40, 0x10, 0x50, 0x00, 0x13, 0x36,
+0x07, 0x41, 0x42, 0x92, 0x08, 0x41, 0x43, 0x92, 0xB6, 0x40, 0x44, 0x92,
+0x00, 0x13, 0x02, 0x00, 0x00, 0x1D, 0x03, 0x00, 0x25, 0x10, 0x43, 0x00,
+0x04, 0x00, 0x03, 0x24, 0x9C, 0x00, 0x83, 0x10, 0x25, 0x88, 0x22, 0x02,
+0x00, 0x41, 0x43, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x60, 0x14,
+0x01, 0x00, 0x02, 0x24, 0x04, 0x41, 0x42, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x00, 0x42, 0x30, 0x9D, 0x00, 0x40, 0x14, 0x00, 0x10, 0x02, 0x3C,
+0x01, 0x00, 0x02, 0x24, 0x94, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x94, 0xE9, 0x84, 0x24, 0x21, 0x28, 0x60, 0x02,
+0x21, 0x38, 0xC0, 0x02, 0x13, 0x58, 0x00, 0x0C, 0x21, 0x30, 0x20, 0x02,
+0x21, 0x20, 0x60, 0x02, 0x63, 0x5E, 0x00, 0x74, 0x21, 0x28, 0x20, 0x02,
+0x60, 0x1B, 0xA2, 0x26, 0xB6, 0x40, 0x43, 0x90, 0xB0, 0x1B, 0x44, 0x94,
+0x60, 0x1B, 0xA5, 0x8E, 0xFC, 0xFF, 0x63, 0x24, 0xFF, 0x00, 0x63, 0x30,
+0xFF, 0xDF, 0x84, 0x30, 0x03, 0x00, 0x63, 0x2C, 0xB0, 0x1B, 0x44, 0xA4,
+0xB0, 0x39, 0x40, 0xAC, 0xCC, 0x39, 0x40, 0xAC, 0x40, 0x41, 0x40, 0xAC,
+0x44, 0x41, 0x40, 0xAC, 0x08, 0x00, 0x60, 0x10, 0x25, 0x00, 0xA5, 0x34,
+0x28, 0x00, 0xA4, 0x8F, 0xFB, 0xFF, 0x02, 0x24, 0x24, 0x10, 0xA2, 0x00,
+0x35, 0x48, 0x00, 0x0C, 0x60, 0x1B, 0xA2, 0xAE, 0xA0, 0x49, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0xA4, 0x8F, 0x35, 0x48, 0x00, 0x0C,
+0x60, 0x1B, 0xA5, 0xAE, 0xA0, 0x49, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x13, 0x58, 0x00, 0x0C, 0x78, 0xE9, 0x84, 0x24, 0xFF, 0xFF, 0x02, 0x24,
+0x51, 0x4A, 0x00, 0x08, 0x28, 0x00, 0xA2, 0xAF, 0x21, 0x20, 0xC0, 0x03,
+0x2D, 0x00, 0x05, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x21, 0x38, 0xE0, 0x02,
+0x91, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0xAB, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x60, 0x19, 0x21, 0x40, 0x00, 0x00,
+0x02, 0x00, 0x49, 0x24, 0x21, 0x50, 0x20, 0x02, 0x02, 0x00, 0x0C, 0x24,
+0x89, 0x4A, 0x00, 0x08, 0x21, 0x68, 0x20, 0x01, 0x04, 0x41, 0x82, 0x90,
+0x00, 0x00, 0x23, 0x91, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x43, 0x00,
+0x04, 0x41, 0x82, 0xA0, 0x01, 0x00, 0x08, 0x25, 0x2A, 0x10, 0x0B, 0x01,
+0x11, 0x00, 0x40, 0x10, 0x01, 0x00, 0x29, 0x25, 0xF6, 0xFF, 0x0C, 0x15,
+0x21, 0x20, 0x0A, 0x01, 0x06, 0x41, 0x43, 0x91, 0x00, 0x00, 0x25, 0x91,
+0x02, 0x00, 0xA2, 0x91, 0x1C, 0x00, 0x64, 0x30, 0x1C, 0x00, 0xA5, 0x30,
+0x03, 0x00, 0x42, 0x30, 0x03, 0x00, 0x63, 0x30, 0x2A, 0x30, 0x43, 0x00,
+0x2A, 0x38, 0xA4, 0x00, 0x0A, 0x10, 0x66, 0x00, 0x0A, 0x20, 0xA7, 0x00,
+0x25, 0x10, 0x44, 0x00, 0x85, 0x4A, 0x00, 0x08, 0x06, 0x41, 0x42, 0xA1,
+0x02, 0x80, 0x02, 0x3C, 0xC6, 0x5C, 0x43, 0x90, 0x02, 0x80, 0x02, 0x3C,
+0x44, 0xDF, 0x47, 0x24, 0x10, 0x00, 0x65, 0x30, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x54, 0xDF, 0x66, 0x24, 0x60, 0x1B, 0x44, 0x24,
+0xAC, 0x4A, 0x00, 0x08, 0x21, 0x40, 0x00, 0x00, 0x00, 0x00, 0x43, 0x90,
+0x07, 0x41, 0x82, 0x90, 0x01, 0x00, 0x08, 0x25, 0x24, 0x10, 0x43, 0x00,
+0x07, 0x41, 0x82, 0xA0, 0x10, 0x00, 0x02, 0x29, 0x07, 0x00, 0x40, 0x10,
+0x01, 0x00, 0x84, 0x24, 0x21, 0x10, 0x07, 0x01, 0xF6, 0xFF, 0xA0, 0x14,
+0x21, 0x18, 0x06, 0x01, 0x00, 0x00, 0x63, 0x90, 0xA5, 0x4A, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0xC0, 0x03, 0x21, 0x38, 0xE0, 0x02,
+0x3D, 0x00, 0x05, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x24, 0x00, 0xA6, 0x27,
+0x48, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0xA6, 0x8F,
+0x02, 0x80, 0x04, 0x3C, 0x84, 0x5C, 0x84, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x45, 0x24, 0x2E, 0x47, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x13, 0x4A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x05, 0x24,
+0x24, 0x00, 0xA6, 0x27, 0xAB, 0x1A, 0x00, 0x0C, 0x21, 0x38, 0xE0, 0x02,
+0x30, 0x00, 0x40, 0x10, 0x60, 0x1B, 0xA5, 0x26, 0x02, 0x00, 0x42, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x42, 0x30, 0x2B, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0xD3, 0x5C, 0x44, 0x90, 0x01, 0x00, 0x03, 0x24,
+0x3E, 0x00, 0x83, 0x10, 0x60, 0x1B, 0xA2, 0x26, 0xFC, 0x23, 0x43, 0x8C,
+0xFF, 0xEF, 0x04, 0x24, 0x00, 0x08, 0x63, 0x34, 0x24, 0x18, 0x64, 0x00,
+0xE9, 0x49, 0x00, 0x08, 0xFC, 0x23, 0x43, 0xAC, 0xF6, 0x01, 0xE2, 0x36,
+0x00, 0x00, 0x40, 0xA4, 0x49, 0x4A, 0x00, 0x08, 0x02, 0x80, 0x04, 0x3C,
+0x04, 0x41, 0x42, 0x96, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x42, 0x30,
+0x6A, 0xFF, 0x40, 0x10, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x10, 0x02, 0x3C,
+0x25, 0x88, 0x22, 0x02, 0x0F, 0x00, 0x08, 0x24, 0x01, 0x00, 0x03, 0x24,
+0x0C, 0x00, 0x02, 0x25, 0x04, 0x10, 0x43, 0x00, 0x24, 0x10, 0x51, 0x00,
+0x16, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x08, 0x25,
+0xFA, 0xFF, 0x01, 0x05, 0x0C, 0x00, 0x02, 0x25, 0x00, 0x12, 0x16, 0x00,
+0x00, 0x1B, 0x16, 0x00, 0x25, 0x18, 0x62, 0x00, 0x00, 0x21, 0x16, 0x00,
+0x25, 0x18, 0x64, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x25, 0x18, 0x76, 0x00,
+0xF6, 0x01, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA4, 0x49, 0x4A, 0x00, 0x08,
+0x02, 0x80, 0x04, 0x3C, 0xFC, 0x23, 0xA2, 0x8C, 0xFF, 0xF7, 0x03, 0x24,
+0xFF, 0xEF, 0x04, 0x24, 0x24, 0x10, 0x43, 0x00, 0x24, 0x10, 0x44, 0x00,
+0xE9, 0x49, 0x00, 0x08, 0xFC, 0x23, 0xA2, 0xAC, 0xEC, 0x4A, 0x00, 0x08,
+0xFF, 0x00, 0x16, 0x31, 0x60, 0x1B, 0xA2, 0x26, 0x13, 0x4A, 0x00, 0x08,
+0xFC, 0x40, 0x40, 0xAC, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0x0E, 0x4A, 0x00, 0x08, 0xBC, 0x40, 0x40, 0xAC, 0x13, 0x4A, 0x00, 0x08,
+0xFC, 0x40, 0x20, 0xAE, 0x21, 0x20, 0x00, 0x02, 0x65, 0x0F, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x00, 0x0F, 0x4A, 0x00, 0x08, 0x60, 0x1B, 0xB1, 0x26,
+0xFC, 0x23, 0x43, 0x8C, 0xFF, 0xF7, 0x04, 0x24, 0x24, 0x18, 0x64, 0x00,
+0x00, 0x10, 0x63, 0x34, 0xE9, 0x49, 0x00, 0x08, 0xFC, 0x23, 0x43, 0xAC,
+0x02, 0x80, 0x04, 0x3C, 0xB0, 0x55, 0x84, 0x24, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xBF, 0xAF, 0xFB, 0x51, 0x00, 0x0C, 0x74, 0x00, 0x84, 0x24,
+0x21, 0x28, 0x40, 0x00, 0x10, 0x00, 0xA4, 0x27, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x10, 0x00, 0xA2, 0x97, 0x25, 0xB0, 0x04, 0x3C,
+0x94, 0x00, 0x85, 0x34, 0x9A, 0x00, 0x87, 0x34, 0x26, 0xB0, 0x06, 0x3C,
+0x00, 0x08, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xA4, 0x0A, 0x00, 0x0B, 0x24,
+0x00, 0x00, 0xE3, 0xA4, 0x98, 0x00, 0x88, 0x34, 0x96, 0x00, 0x89, 0x34,
+0x7A, 0x00, 0xCA, 0x34, 0x50, 0x00, 0x02, 0x24, 0x04, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x02, 0xA5, 0x00, 0x00, 0x2B, 0xA5, 0x00, 0x00, 0x43, 0xA1,
+0x10, 0x00, 0xA2, 0x97, 0x89, 0x00, 0x83, 0x34, 0x14, 0x00, 0x07, 0x24,
+0x40, 0x11, 0x02, 0x00, 0xA0, 0xFF, 0x42, 0x24, 0xFF, 0xFF, 0x42, 0x30,
+0x9C, 0x00, 0x85, 0x34, 0x7C, 0x00, 0xC6, 0x34, 0x00, 0x00, 0xC2, 0xA4,
+0x44, 0x00, 0x84, 0x34, 0x00, 0x00, 0x67, 0xA0, 0x00, 0x00, 0xAB, 0xA0,
+0x00, 0x00, 0x82, 0x94, 0xFF, 0xFD, 0x03, 0x24, 0x18, 0x00, 0xBF, 0x8F,
+0x24, 0x10, 0x43, 0x00, 0x00, 0x00, 0x82, 0xA4, 0x00, 0x00, 0x83, 0x94,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x00, 0x02, 0x63, 0x34,
+0x20, 0x00, 0xBD, 0x27, 0x3A, 0x41, 0x40, 0xA0, 0x00, 0x00, 0x83, 0xA4,
+0x08, 0x00, 0xE0, 0x03, 0xB8, 0x40, 0x47, 0xA0, 0xD0, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x10, 0x3C, 0xB0, 0x55, 0x04, 0x26,
+0x28, 0x00, 0xBF, 0xAF, 0x24, 0x00, 0xB5, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x52, 0x00, 0x0C,
+0x18, 0x00, 0xB2, 0xAF, 0xFF, 0xFF, 0x51, 0x30, 0xB0, 0x55, 0x04, 0x26,
+0xFD, 0x51, 0x00, 0x0C, 0x02, 0x80, 0x15, 0x3C, 0x60, 0x1B, 0xA3, 0x26,
+0x01, 0x00, 0x24, 0x32, 0xB4, 0x40, 0x62, 0xA4, 0x03, 0x00, 0x80, 0x14,
+0x02, 0x00, 0x05, 0x24, 0x40, 0x10, 0x11, 0x00, 0x04, 0x00, 0x45, 0x30,
+0x02, 0x00, 0x02, 0x24, 0x5F, 0x00, 0xA2, 0x10, 0x60, 0x1B, 0xA2, 0x26,
+0x10, 0x00, 0x80, 0x10, 0x02, 0x00, 0x03, 0x24, 0x04, 0x00, 0x02, 0x24,
+0x12, 0x00, 0x62, 0x10, 0x60, 0x1B, 0xB3, 0x26, 0x02, 0x80, 0x04, 0x3C,
+0x21, 0x28, 0x20, 0x02, 0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB5, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xEC, 0xE9, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x08, 0x30, 0x00, 0xBD, 0x27, 0x40, 0x10, 0x11, 0x00,
+0x04, 0x00, 0x43, 0x30, 0x04, 0x00, 0x02, 0x24, 0xF0, 0xFF, 0x62, 0x14,
+0x60, 0x1B, 0xB3, 0x26, 0xB4, 0x40, 0x66, 0x96, 0xC4, 0x3D, 0x65, 0x92,
+0x02, 0x80, 0x04, 0x3C, 0xB0, 0x1B, 0x63, 0xA6, 0xFC, 0xE9, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x25, 0xB0, 0x10, 0x3C, 0x50, 0x02, 0x03, 0x36,
+0x0F, 0x00, 0x02, 0x24, 0x00, 0x00, 0x62, 0xA0, 0x21, 0x28, 0x00, 0x00,
+0x95, 0x0E, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0xC4, 0x3D, 0x64, 0x92,
+0x01, 0x00, 0x14, 0x24, 0x75, 0x0D, 0x00, 0x0C, 0x4C, 0x00, 0x10, 0x36,
+0x02, 0x80, 0x11, 0x3C, 0x00, 0x00, 0x14, 0xA2, 0xEA, 0x47, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x1B, 0x53, 0x00, 0x0C, 0x10, 0x56, 0x24, 0x26,
+0x21, 0x28, 0x40, 0x00, 0x10, 0x56, 0x24, 0x26, 0x61, 0x53, 0x00, 0x0C,
+0x21, 0x90, 0x40, 0x00, 0x0F, 0x00, 0x50, 0x30, 0x10, 0x56, 0x24, 0x26,
+0x7A, 0x53, 0x00, 0x0C, 0x21, 0x28, 0x40, 0x02, 0x40, 0x02, 0x10, 0x36,
+0x02, 0x80, 0x04, 0x3C, 0x21, 0x88, 0x40, 0x00, 0x21, 0x30, 0x40, 0x00,
+0x21, 0x28, 0x00, 0x02, 0x13, 0x58, 0x00, 0x0C, 0x2C, 0xEA, 0x84, 0x24,
+0x21, 0x20, 0x00, 0x02, 0x63, 0x5E, 0x00, 0x74, 0x21, 0x28, 0x20, 0x02,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0x37, 0x3A, 0x84, 0x24,
+0xB4, 0x55, 0xA5, 0x24, 0x06, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0xD6, 0x1E, 0x74, 0xA2, 0x31, 0x46, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x4B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x1B, 0x62, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x34, 0xA9, 0x1B, 0x00, 0x0C,
+0xB0, 0x1B, 0x62, 0xA6, 0xE8, 0x39, 0x62, 0xAE, 0x35, 0x48, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0x60, 0x1B, 0xA2, 0x8E, 0x28, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x21, 0x00, 0x42, 0x34, 0x60, 0x1B, 0xA2, 0xAE,
+0x1C, 0x00, 0xB3, 0x8F, 0x24, 0x00, 0xB5, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0x24, 0x40, 0x44, 0x8C, 0x01, 0x20, 0x03, 0x24,
+0xB0, 0x1B, 0x43, 0xA4, 0x02, 0x00, 0x85, 0x10, 0x0C, 0x00, 0x03, 0x24,
+0x0F, 0x00, 0x03, 0x24, 0x25, 0xB0, 0x02, 0x3C, 0x50, 0x02, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xA0, 0x60, 0x1B, 0xB0, 0x26, 0xB0, 0x1B, 0x02, 0x96,
+0xB4, 0x40, 0x06, 0x96, 0xC4, 0x3D, 0x05, 0x92, 0x10, 0x00, 0x42, 0x34,
+0x02, 0x80, 0x04, 0x3C, 0xB0, 0x1B, 0x02, 0xA6, 0x40, 0xEA, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x14, 0x40, 0x00, 0xAE, 0x21, 0x28, 0x00, 0x00,
+0x95, 0x0E, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0xC4, 0x3D, 0x04, 0x92,
+0x75, 0x0D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x1B, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0x39, 0x02, 0xAE, 0x28, 0x00, 0xBF, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27,
+0x20, 0x00, 0xB2, 0xAF, 0x21, 0x90, 0x80, 0x00, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0xFF, 0x00, 0xB0, 0x30, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x51, 0x24, 0x10, 0x00, 0xA4, 0x27, 0x01, 0x00, 0x02, 0x24,
+0x90, 0x40, 0x00, 0x0C, 0x4B, 0x41, 0x22, 0xA2, 0x02, 0x80, 0x04, 0x3C,
+0x30, 0x59, 0x84, 0x24, 0x21, 0x28, 0x00, 0x00, 0xE3, 0x54, 0x00, 0x0C,
+0x0F, 0x00, 0x06, 0x24, 0x21, 0x40, 0x00, 0x00, 0x18, 0x00, 0x00, 0x12,
+0x21, 0x60, 0x00, 0x00, 0x21, 0x68, 0x20, 0x02, 0x21, 0x10, 0x92, 0x01,
+0x01, 0x00, 0x49, 0x90, 0x00, 0x00, 0x4A, 0x90, 0x0D, 0x00, 0x20, 0x11,
+0x21, 0x30, 0x00, 0x00, 0x21, 0x58, 0xA0, 0x01, 0x01, 0x00, 0xC2, 0x24,
+0x21, 0x38, 0x46, 0x01, 0x01, 0x00, 0x03, 0x25, 0xFF, 0x00, 0x46, 0x30,
+0x0E, 0x00, 0x02, 0x2D, 0x21, 0x28, 0x0B, 0x01, 0x2B, 0x20, 0xC9, 0x00,
+0x08, 0x00, 0x40, 0x10, 0xFF, 0x00, 0x68, 0x30, 0xF6, 0xFF, 0x80, 0x14,
+0xD0, 0x3D, 0xA7, 0xA0, 0x03, 0x00, 0x82, 0x25, 0xFF, 0x00, 0x4C, 0x30,
+0x2B, 0x18, 0x90, 0x01, 0xEC, 0xFF, 0x60, 0x14, 0x21, 0x10, 0x92, 0x01,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27,
+0x10, 0x00, 0xBF, 0xAF, 0x90, 0x48, 0x00, 0x0C, 0xFE, 0xFF, 0x05, 0x24,
+0x10, 0x00, 0xBF, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x90, 0x48, 0x00, 0x0C, 0xFF, 0xFF, 0x05, 0x24, 0x10, 0x00, 0xBF, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0x25, 0xB0, 0x03, 0x3C, 0x01, 0x80, 0x02, 0x3C, 0xB0, 0x03, 0x65, 0x34,
+0xAC, 0x30, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34, 0x00, 0x00, 0x62, 0xAC,
+0x00, 0x00, 0xA4, 0xAC, 0x00, 0x00, 0x83, 0x8C, 0x21, 0x10, 0x00, 0x00,
+0xFF, 0x3F, 0x63, 0x30, 0x00, 0x00, 0xA3, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x06, 0x3C,
+0x02, 0x80, 0x08, 0x3C, 0x78, 0x00, 0xBE, 0xAF, 0x7C, 0x00, 0xBF, 0xAF,
+0x74, 0x00, 0xB7, 0xAF, 0x70, 0x00, 0xB6, 0xAF, 0x6C, 0x00, 0xB5, 0xAF,
+0x68, 0x00, 0xB4, 0xAF, 0x64, 0x00, 0xB3, 0xAF, 0x60, 0x00, 0xB2, 0xAF,
+0x5C, 0x00, 0xB1, 0xAF, 0x58, 0x00, 0xB0, 0xAF, 0xE8, 0xE9, 0xC2, 0x24,
+0x74, 0xEA, 0x03, 0x25, 0x01, 0x00, 0x44, 0x90, 0x01, 0x00, 0x65, 0x90,
+0xE8, 0xE9, 0xCB, 0x90, 0x74, 0xEA, 0x0A, 0x91, 0x02, 0x00, 0x47, 0x90,
+0x02, 0x00, 0x66, 0x90, 0x03, 0x00, 0x48, 0x90, 0x03, 0x00, 0x69, 0x90,
+0x00, 0x22, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x25, 0x20, 0x8B, 0x00,
+0x25, 0x28, 0xAA, 0x00, 0x00, 0x3C, 0x07, 0x00, 0x00, 0x34, 0x06, 0x00,
+0x25, 0x38, 0xE4, 0x00, 0x25, 0x30, 0xC5, 0x00, 0x00, 0x46, 0x08, 0x00,
+0x00, 0x4E, 0x09, 0x00, 0x25, 0x40, 0x07, 0x01, 0x25, 0x48, 0x26, 0x01,
+0x00, 0x02, 0x04, 0x24, 0x40, 0x00, 0xA8, 0xAF, 0x53, 0x21, 0x00, 0x0C,
+0x48, 0x00, 0xA9, 0xAF, 0xCF, 0x01, 0x40, 0x10, 0x21, 0xF0, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x52, 0x24, 0xC0, 0x3A, 0x45, 0x8E,
+0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C, 0x78, 0xEA, 0x84, 0x24,
+0x08, 0x00, 0xD1, 0x97, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x10, 0x3C,
+0x25, 0x88, 0x22, 0x02, 0xB4, 0x55, 0x10, 0x26, 0x24, 0x00, 0x24, 0x26,
+0x21, 0x28, 0x00, 0x02, 0x20, 0x00, 0x20, 0xA6, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C, 0x2A, 0x00, 0x24, 0x26,
+0x48, 0x37, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x21, 0x28, 0x00, 0x02, 0x06, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x30, 0x00, 0x24, 0x26, 0x18, 0x00, 0x03, 0x24, 0x0C, 0x00, 0xC3, 0xAF,
+0xE4, 0x1D, 0x42, 0x96, 0x20, 0x00, 0x25, 0x26, 0x38, 0x00, 0x37, 0x26,
+0xFF, 0x0F, 0x43, 0x30, 0x00, 0x19, 0x03, 0x00, 0x02, 0x22, 0x03, 0x00,
+0x01, 0x00, 0x42, 0x24, 0xE4, 0x1D, 0x42, 0xA6, 0x17, 0x00, 0xA4, 0xA0,
+0x02, 0x80, 0x04, 0x3C, 0x16, 0x00, 0xA3, 0xA0, 0x16, 0x52, 0x00, 0x0C,
+0x24, 0x56, 0x84, 0x24, 0x21, 0x28, 0x40, 0x00, 0x21, 0x20, 0xE0, 0x02,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24, 0x3A, 0x00, 0x24, 0x26,
+0x18, 0x00, 0xA5, 0x27, 0x02, 0x00, 0x06, 0x24, 0x03, 0x00, 0x02, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0x18, 0x00, 0xA2, 0xA7, 0x0C, 0x00, 0xC3, 0x8F,
+0x02, 0x80, 0x07, 0x3C, 0x3C, 0x00, 0x24, 0x26, 0x04, 0x00, 0x63, 0x24,
+0x0C, 0x00, 0xC3, 0xAF, 0x5C, 0x3A, 0x46, 0x8E, 0x0C, 0x00, 0xC3, 0x27,
+0xC0, 0x55, 0xE7, 0x24, 0x21, 0x28, 0x00, 0x00, 0x54, 0x00, 0xA3, 0xAF,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF, 0x20, 0x00, 0xA4, 0x27,
+0x50, 0x00, 0xA5, 0x27, 0x05, 0x53, 0x00, 0x0C, 0x21, 0xB8, 0x40, 0x00,
+0x50, 0x00, 0xA8, 0x8F, 0x21, 0x88, 0x00, 0x00, 0x52, 0x00, 0x00, 0x11,
+0x21, 0x80, 0x00, 0x00, 0x21, 0x38, 0x40, 0x02, 0x18, 0x00, 0xA9, 0x27,
+0x21, 0x10, 0x31, 0x01, 0x08, 0x00, 0x46, 0x90, 0x21, 0x20, 0x00, 0x00,
+0x7F, 0x00, 0xC5, 0x30, 0x21, 0x10, 0x87, 0x00, 0xB0, 0x3A, 0x43, 0x90,
+0x01, 0x00, 0x84, 0x24, 0x7F, 0x00, 0x63, 0x30, 0x3D, 0x00, 0xA3, 0x10,
+0x0D, 0x00, 0x82, 0x2C, 0xFA, 0xFF, 0x40, 0x14, 0x21, 0x10, 0x87, 0x00,
+0x01, 0x00, 0x31, 0x26, 0x2B, 0x10, 0x28, 0x02, 0xF2, 0xFF, 0x40, 0x14,
+0x21, 0x10, 0x31, 0x01, 0x09, 0x00, 0x02, 0x2E, 0x3D, 0x00, 0x40, 0x14,
+0x21, 0x20, 0xE0, 0x02, 0x54, 0x00, 0xA2, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0x08, 0x00, 0x06, 0x24, 0x30, 0x00, 0xA7, 0x27, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xA2, 0xAF, 0x54, 0x00, 0xA3, 0x8F, 0x21, 0x20, 0x40, 0x00,
+0xF8, 0xFF, 0x06, 0x26, 0x32, 0x00, 0x05, 0x24, 0x38, 0x00, 0xA7, 0x27,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF, 0x21, 0xB8, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x44, 0x24, 0x24, 0x40, 0x83, 0x8C,
+0x02, 0x00, 0x02, 0x24, 0x37, 0x00, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00,
+0xC0, 0x3A, 0x83, 0x8C, 0x0C, 0x00, 0x11, 0x24, 0x2B, 0x10, 0x23, 0x02,
+0x32, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x24, 0x56, 0x46, 0x24,
+0x21, 0x20, 0x60, 0x00, 0xE0, 0x4C, 0x00, 0x08, 0x30, 0x00, 0x05, 0x24,
+0x01, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x02, 0x00, 0x51, 0x24, 0x2B, 0x18, 0x24, 0x02, 0x27, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x26, 0x02, 0x00, 0x00, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xF5, 0xFF, 0x45, 0x14, 0x02, 0x80, 0x07, 0x3C,
+0x01, 0x00, 0x66, 0x90, 0x54, 0x00, 0xA2, 0x8F, 0x26, 0x56, 0xE7, 0x24,
+0x21, 0x20, 0xE0, 0x02, 0x21, 0x38, 0x27, 0x02, 0x30, 0x00, 0x05, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0x06, 0x4D, 0x00, 0x08,
+0x21, 0xB8, 0x40, 0x00, 0x21, 0x10, 0x30, 0x01, 0x18, 0x00, 0x46, 0xA0,
+0x50, 0x00, 0xA8, 0x8F, 0x01, 0x00, 0x31, 0x26, 0x2B, 0x10, 0x28, 0x02,
+0xB4, 0xFF, 0x40, 0x14, 0x01, 0x00, 0x10, 0x26, 0xBA, 0x4C, 0x00, 0x08,
+0x09, 0x00, 0x02, 0x2E, 0x54, 0x00, 0xA3, 0x8F, 0x21, 0x20, 0xE0, 0x02,
+0x21, 0x30, 0x00, 0x02, 0x01, 0x00, 0x05, 0x24, 0x30, 0x00, 0xA7, 0x27,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF, 0x21, 0xB8, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x44, 0x24, 0x24, 0x40, 0x83, 0x8C,
+0x02, 0x00, 0x02, 0x24, 0xCB, 0xFF, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x1B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x40, 0x14,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x43, 0x24, 0xC0, 0x3A, 0x62, 0x8C,
+0x0C, 0x00, 0x11, 0x24, 0x2B, 0x10, 0x22, 0x02, 0x11, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x21, 0x80, 0x60, 0x00, 0x24, 0x56, 0x52, 0x24,
+0x21, 0xA8, 0x60, 0x00, 0x02, 0x80, 0x13, 0x3C, 0x21, 0x20, 0x32, 0x02,
+0x00, 0x00, 0x83, 0x90, 0x2D, 0x00, 0x02, 0x24, 0xD6, 0x00, 0x62, 0x10,
+0x02, 0x80, 0x05, 0x3C, 0x01, 0x00, 0x82, 0x90, 0xC0, 0x3A, 0x03, 0x8E,
+0x21, 0x10, 0x51, 0x00, 0x02, 0x00, 0x51, 0x24, 0x2B, 0x18, 0x23, 0x02,
+0xF6, 0xFF, 0x60, 0x14, 0x21, 0x20, 0x32, 0x02, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x44, 0x24, 0x24, 0x40, 0x83, 0x8C, 0x02, 0x00, 0x02, 0x24,
+0x86, 0x00, 0x62, 0x10, 0x0C, 0x00, 0x11, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x43, 0x24, 0xC0, 0x3A, 0x62, 0x8C, 0x0C, 0x00, 0x11, 0x24,
+0x2B, 0x10, 0x22, 0x02, 0x26, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x24, 0x56, 0x56, 0x24, 0x21, 0xA8, 0x60, 0x00, 0xDD, 0x00, 0x14, 0x24,
+0x39, 0x4D, 0x00, 0x08, 0x02, 0x80, 0x13, 0x3C, 0x01, 0x00, 0x02, 0x92,
+0xC0, 0x3A, 0xA3, 0x8E, 0x21, 0x10, 0x51, 0x00, 0x02, 0x00, 0x51, 0x24,
+0x2B, 0x18, 0x23, 0x02, 0x1B, 0x00, 0x60, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x21, 0x80, 0x36, 0x02, 0x00, 0x00, 0x02, 0x92, 0x02, 0x00, 0x12, 0x26,
+0x21, 0x20, 0x40, 0x02, 0x70, 0xDE, 0x65, 0x26, 0xF3, 0xFF, 0x54, 0x14,
+0x06, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xEF, 0xFF, 0x40, 0x14, 0x21, 0x20, 0xE0, 0x02, 0x54, 0x00, 0xA2, 0x8F,
+0xDD, 0x00, 0x05, 0x24, 0x21, 0x38, 0x40, 0x02, 0x07, 0x00, 0x06, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0x08, 0x00, 0x04, 0x92,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x65, 0x24, 0x21, 0xB8, 0x40, 0x00,
+0x01, 0x00, 0x03, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x08, 0x5E, 0x44, 0xA0,
+0xBC, 0x40, 0xA3, 0xAC, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x64, 0x24,
+0xC0, 0x3A, 0x82, 0x8C, 0x0C, 0x00, 0x11, 0x24, 0x2B, 0x10, 0x22, 0x02,
+0x20, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x24, 0x56, 0x56, 0x24, 0x26, 0x56, 0x75, 0x24, 0x21, 0xA0, 0x80, 0x00,
+0x66, 0x4D, 0x00, 0x08, 0xDD, 0x00, 0x13, 0x24, 0x01, 0x00, 0x02, 0x92,
+0xC0, 0x3A, 0x83, 0x8E, 0x21, 0x10, 0x51, 0x00, 0x02, 0x00, 0x51, 0x24,
+0x2B, 0x18, 0x23, 0x02, 0x14, 0x00, 0x60, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x80, 0x36, 0x02, 0x00, 0x00, 0x02, 0x92, 0x21, 0x90, 0x35, 0x02,
+0x21, 0x20, 0x40, 0x02, 0x48, 0x00, 0xA5, 0x27, 0xF3, 0xFF, 0x53, 0x14,
+0x04, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xEF, 0xFF, 0x40, 0x14, 0x21, 0x20, 0xE0, 0x02, 0x01, 0x00, 0x06, 0x92,
+0x54, 0x00, 0xA2, 0x8F, 0x21, 0x38, 0x40, 0x02, 0xDD, 0x00, 0x05, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF, 0x21, 0xB8, 0x40, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x44, 0x24, 0xFC, 0x40, 0x83, 0x8C,
+0x01, 0x00, 0x02, 0x24, 0x61, 0x00, 0x62, 0x10, 0x06, 0x00, 0x02, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x62, 0x24, 0xC0, 0x3A, 0x43, 0x8C,
+0x0C, 0x00, 0x11, 0x24, 0x2B, 0x10, 0x23, 0x02, 0x10, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x24, 0x56, 0x46, 0x24, 0x21, 0x20, 0x60, 0x00,
+0x44, 0x00, 0x05, 0x24, 0x21, 0x80, 0x26, 0x02, 0x00, 0x00, 0x02, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x45, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x02, 0x00, 0x51, 0x24, 0x2B, 0x18, 0x24, 0x02, 0xF6, 0xFF, 0x60, 0x14,
+0x21, 0x80, 0x26, 0x02, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x62, 0x24,
+0xB6, 0x40, 0x43, 0x90, 0x04, 0x00, 0x07, 0x24, 0x21, 0x20, 0xC0, 0x03,
+0x01, 0x00, 0x63, 0x38, 0x0B, 0x38, 0x03, 0x00, 0x21, 0x28, 0x00, 0x00,
+0xDF, 0x0D, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x21, 0x10, 0x00, 0x00,
+0x7C, 0x00, 0xBF, 0x8F, 0x78, 0x00, 0xBE, 0x8F, 0x74, 0x00, 0xB7, 0x8F,
+0x70, 0x00, 0xB6, 0x8F, 0x6C, 0x00, 0xB5, 0x8F, 0x68, 0x00, 0xB4, 0x8F,
+0x64, 0x00, 0xB3, 0x8F, 0x60, 0x00, 0xB2, 0x8F, 0x5C, 0x00, 0xB1, 0x8F,
+0x58, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x80, 0x00, 0xBD, 0x27,
+0xC0, 0x3A, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x10, 0x22, 0x02,
+0x77, 0xFF, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x24, 0x56, 0x56, 0x24, 0x26, 0x56, 0x75, 0x24, 0x21, 0xA0, 0x80, 0x00,
+0xBD, 0x4D, 0x00, 0x08, 0xDD, 0x00, 0x13, 0x24, 0x01, 0x00, 0x02, 0x92,
+0xC0, 0x3A, 0x83, 0x8E, 0x21, 0x10, 0x51, 0x00, 0x02, 0x00, 0x51, 0x24,
+0x2B, 0x18, 0x23, 0x02, 0x6B, 0xFF, 0x60, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x80, 0x36, 0x02, 0x00, 0x00, 0x02, 0x92, 0x21, 0x90, 0x35, 0x02,
+0x21, 0x20, 0x40, 0x02, 0x40, 0x00, 0xA5, 0x27, 0xF3, 0xFF, 0x53, 0x14,
+0x04, 0x00, 0x06, 0x24, 0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xEF, 0xFF, 0x40, 0x14, 0x21, 0x20, 0xE0, 0x02, 0x01, 0x00, 0x06, 0x92,
+0x54, 0x00, 0xA3, 0x8F, 0x21, 0x38, 0x40, 0x02, 0xDD, 0x00, 0x05, 0x24,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF, 0x26, 0x4D, 0x00, 0x08,
+0x21, 0xB8, 0x40, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C,
+0x8C, 0xEA, 0x84, 0x24, 0x01, 0x00, 0x06, 0x92, 0x54, 0x00, 0xA2, 0x8F,
+0x02, 0x80, 0x07, 0x3C, 0x26, 0x56, 0xE7, 0x24, 0x21, 0x38, 0x27, 0x02,
+0x21, 0x20, 0xE0, 0x02, 0x44, 0x00, 0x05, 0x24, 0x25, 0x52, 0x00, 0x0C,
+0x10, 0x00, 0xA2, 0xAF, 0x95, 0x4D, 0x00, 0x08, 0x02, 0x80, 0x03, 0x3C,
+0xB6, 0x40, 0x83, 0x90, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x62, 0x10,
+0x05, 0x00, 0x02, 0x24, 0x9C, 0xFF, 0x62, 0x14, 0x02, 0x80, 0x03, 0x3C,
+0x02, 0x80, 0x07, 0x3C, 0x21, 0x20, 0xE0, 0x02, 0x34, 0xDE, 0xE7, 0x24,
+0xDD, 0x00, 0x05, 0x24, 0x06, 0x00, 0x06, 0x24, 0x54, 0x00, 0xA3, 0x8F,
+0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF, 0x7E, 0x4D, 0x00, 0x08,
+0x21, 0xB8, 0x40, 0x00, 0x02, 0x80, 0x14, 0x3C, 0x26, 0x56, 0xA5, 0x24,
+0x21, 0x28, 0x25, 0x02, 0x64, 0x5C, 0x84, 0x26, 0xF4, 0x54, 0x00, 0x0C,
+0x20, 0x00, 0x06, 0x24, 0x02, 0x80, 0x03, 0x3C, 0xD9, 0x5C, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x41, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00, 0xBD, 0xFF, 0x42, 0x30,
+0x04, 0x41, 0x02, 0xA6, 0x02, 0x80, 0x02, 0x3C, 0xC4, 0xDF, 0x44, 0x8C,
+0x04, 0x41, 0xA3, 0x96, 0x20, 0x00, 0x80, 0x10, 0x0C, 0x00, 0x62, 0x34,
+0x00, 0x01, 0x42, 0x34, 0x04, 0x41, 0xA2, 0xA6, 0x02, 0x80, 0x03, 0x3C,
+0xC6, 0x5C, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x15, 0x00, 0x40, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x67, 0x5C, 0x64, 0x26, 0x44, 0xDF, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x10, 0x00, 0x06, 0x24, 0x21, 0x10, 0x32, 0x02, 0x01, 0x00, 0x46, 0x90,
+0x54, 0x00, 0xA3, 0x8F, 0x21, 0x20, 0xE0, 0x02, 0x64, 0x5C, 0x87, 0x26,
+0x2D, 0x00, 0x05, 0x24, 0x25, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA3, 0xAF,
+0x21, 0xB8, 0x40, 0x00, 0x01, 0x00, 0x02, 0x24, 0x20, 0x4D, 0x00, 0x08,
+0xFC, 0x40, 0x02, 0xAE, 0x04, 0x41, 0x02, 0x96, 0xFC, 0x4D, 0x00, 0x08,
+0x02, 0x00, 0x42, 0x34, 0x67, 0x5C, 0x64, 0x26, 0x0D, 0x4E, 0x00, 0x08,
+0x54, 0xDF, 0xA5, 0x24, 0x04, 0x4E, 0x00, 0x08, 0x04, 0x41, 0xA2, 0xA6,
+0x02, 0x80, 0x02, 0x3C, 0x34, 0xDE, 0x42, 0x24, 0x06, 0x00, 0x48, 0x90,
+0x02, 0x00, 0x03, 0x24, 0x21, 0x20, 0xE0, 0x02, 0x01, 0x00, 0x08, 0x35,
+0x21, 0x38, 0x40, 0x00, 0xDD, 0x00, 0x05, 0x24, 0x07, 0x00, 0x06, 0x24,
+0x04, 0x00, 0x43, 0xA0, 0xE9, 0x4D, 0x00, 0x08, 0x06, 0x00, 0x48, 0xA0,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0xAC, 0xE8, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x64, 0xEA, 0xA5, 0x24, 0x9F, 0x4D, 0x00, 0x08,
+0xFF, 0xFF, 0x02, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0xB0, 0x1B, 0x43, 0x94, 0x32, 0x00, 0x04, 0x24, 0xCC, 0x39, 0x44, 0xAC,
+0x9F, 0xFE, 0x63, 0x30, 0x80, 0x00, 0x63, 0x34, 0xB0, 0x1B, 0x43, 0xA4,
+0x18, 0x40, 0x40, 0xAC, 0x1C, 0x40, 0x40, 0xAC, 0x38, 0x4C, 0x00, 0x08,
+0xB0, 0x39, 0x40, 0xAC, 0xE8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF, 0x60, 0x1B, 0x50, 0x24,
+0x1C, 0x40, 0x03, 0x8E, 0xFE, 0xFF, 0x04, 0x24, 0x01, 0x00, 0x63, 0x24,
+0x03, 0x00, 0x62, 0x2C, 0x12, 0x00, 0x40, 0x10, 0x1C, 0x40, 0x03, 0xAE,
+0xB0, 0x1B, 0x02, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x42, 0x30,
+0x05, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0x38, 0x4C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x03, 0x24,
+0xCC, 0x39, 0x03, 0xAE, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xB0, 0x1B, 0x02, 0x96,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xDF, 0x42, 0x30, 0x35, 0x48, 0x00, 0x0C,
+0xB0, 0x1B, 0x02, 0xA6, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x2C, 0x00, 0xBF, 0xAF,
+0x02, 0x00, 0x82, 0x90, 0x02, 0x80, 0x14, 0x3C, 0x60, 0x1B, 0x92, 0x26,
+0xB0, 0x1B, 0x43, 0x96, 0x00, 0x00, 0x85, 0x8C, 0x0F, 0x00, 0x42, 0x30,
+0xC0, 0x10, 0x02, 0x00, 0x21, 0x80, 0x44, 0x00, 0x01, 0x00, 0x63, 0x30,
+0xFF, 0x3F, 0xB3, 0x30, 0x18, 0x00, 0x11, 0x26, 0x0A, 0x00, 0x60, 0x14,
+0x21, 0x20, 0x00, 0x00, 0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x80, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0x39, 0x53, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02,
+0x02, 0x80, 0x04, 0x3C, 0x48, 0x37, 0x84, 0x24, 0x21, 0x28, 0x40, 0x00,
+0x1D, 0x55, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0xEF, 0xFF, 0x40, 0x14,
+0x21, 0x20, 0x00, 0x00, 0xB0, 0x1B, 0x42, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x10, 0x42, 0x30, 0xEA, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x00, 0x03, 0x96, 0x04, 0x00, 0x04, 0x24, 0x21, 0x10, 0x80, 0x00,
+0x00, 0x40, 0x63, 0x30, 0x0A, 0x10, 0x03, 0x00, 0x21, 0x10, 0x22, 0x02,
+0x1C, 0x00, 0x43, 0x94, 0x1A, 0x00, 0x45, 0x94, 0x2F, 0x00, 0x60, 0x14,
+0x02, 0x00, 0x02, 0x24, 0x14, 0x00, 0xA2, 0x10, 0x01, 0x00, 0x02, 0x24,
+0x0E, 0x00, 0xA4, 0x14, 0x02, 0x80, 0x04, 0x3C, 0x24, 0x40, 0x43, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x62, 0x10, 0x60, 0x1B, 0x83, 0x26,
+0xB0, 0x1B, 0x62, 0x94, 0xFF, 0xFF, 0x04, 0x24, 0xFF, 0xDF, 0x42, 0x30,
+0x7B, 0x4E, 0x00, 0x08, 0xB0, 0x1B, 0x62, 0xA4, 0x36, 0x4E, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x7B, 0x4E, 0x00, 0x08, 0x21, 0x20, 0x00, 0x00,
+0x13, 0x58, 0x00, 0x0C, 0x04, 0xEB, 0x84, 0x24, 0xA4, 0x4E, 0x00, 0x08,
+0x60, 0x1B, 0x83, 0x26, 0x24, 0x40, 0x43, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0xF5, 0xFF, 0x62, 0x14, 0xE2, 0xFF, 0x67, 0x26, 0x36, 0x00, 0x04, 0x26,
+0x10, 0x00, 0x05, 0x24, 0xAB, 0x1A, 0x00, 0x0C, 0x10, 0x00, 0xA6, 0x27,
+0x16, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xA6, 0x8F,
+0x02, 0x80, 0x04, 0x3C, 0x94, 0x5B, 0x84, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x45, 0x24, 0xB0, 0x1B, 0x43, 0x96, 0x21, 0x20, 0x00, 0x00,
+0x03, 0x00, 0x02, 0x24, 0xDF, 0xFF, 0x63, 0x30, 0x40, 0x00, 0x63, 0x34,
+0xB0, 0x1B, 0x43, 0xA6, 0x2D, 0x14, 0x00, 0x0C, 0x20, 0x40, 0x42, 0xAE,
+0x7B, 0x4E, 0x00, 0x08, 0x21, 0x20, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x2C, 0xEB, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x21, 0x28, 0x60, 0x00,
+0xA4, 0x4E, 0x00, 0x08, 0x60, 0x1B, 0x83, 0x26, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0x48, 0xEB, 0x84, 0x24, 0xA4, 0x4E, 0x00, 0x08,
+0x60, 0x1B, 0x83, 0x26, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x63, 0x24,
+0xB0, 0x1B, 0x62, 0x94, 0x01, 0x00, 0x05, 0x24, 0x21, 0x20, 0x00, 0x00,
+0xEF, 0xFF, 0x42, 0x30, 0x20, 0x00, 0x42, 0x34, 0xB0, 0x1B, 0x62, 0xA4,
+0x32, 0x00, 0x02, 0x24, 0x20, 0x40, 0x65, 0xAC, 0xB0, 0x39, 0x62, 0xAC,
+0xCC, 0x39, 0x60, 0xAC, 0x18, 0x40, 0x60, 0xAC, 0x2D, 0x14, 0x00, 0x08,
+0x1C, 0x40, 0x60, 0xAC, 0xE8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x07, 0x3C,
+0x14, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0xE6, 0x24,
+0x18, 0x40, 0xC2, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x45, 0x24,
+0x03, 0x00, 0xA3, 0x2C, 0x0E, 0x00, 0x60, 0x14, 0x60, 0x1B, 0xF0, 0x24,
+0x24, 0x40, 0xC3, 0x8C, 0x03, 0x00, 0x02, 0x24, 0x16, 0x00, 0x62, 0x10,
+0xFF, 0xFF, 0x04, 0x24, 0xB0, 0x1B, 0xC2, 0x94, 0x18, 0x40, 0xC5, 0xAC,
+0xFF, 0xDF, 0x42, 0x30, 0x35, 0x48, 0x00, 0x0C, 0xB0, 0x1B, 0xC2, 0xA4,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xB0, 0x1B, 0x03, 0x96, 0xBF, 0xFF, 0x02, 0x24,
+0x18, 0x40, 0xC5, 0xAC, 0x24, 0x10, 0x62, 0x00, 0x80, 0x00, 0x63, 0x30,
+0x21, 0x20, 0x00, 0x00, 0x0F, 0x00, 0x60, 0x10, 0x20, 0x00, 0x45, 0x34,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xB0, 0x1B, 0x03, 0x96, 0x01, 0x00, 0x02, 0x24,
+0x24, 0x40, 0xC2, 0xAC, 0xBF, 0xFF, 0x02, 0x24, 0x24, 0x10, 0x62, 0x00,
+0x80, 0x00, 0x63, 0x30, 0x18, 0x40, 0xC0, 0xAC, 0x21, 0x20, 0x00, 0x00,
+0xF3, 0xFF, 0x60, 0x14, 0x20, 0x00, 0x45, 0x34, 0x01, 0x00, 0x02, 0x24,
+0x20, 0x40, 0x02, 0xAE, 0x2D, 0x14, 0x00, 0x0C, 0xB0, 0x1B, 0x05, 0xA6,
+0x32, 0x00, 0x03, 0x24, 0xB0, 0x39, 0x03, 0xAE, 0x14, 0x00, 0xBF, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0xD0, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xB2, 0xAF, 0x21, 0x90, 0x80, 0x00,
+0x00, 0x01, 0x04, 0x24, 0x24, 0x00, 0xB3, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x21, 0x98, 0xA0, 0x00, 0x28, 0x00, 0xBF, 0xAF, 0x53, 0x21, 0x00, 0x0C,
+0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x21, 0x88, 0x40, 0x00, 0x58, 0xEC, 0x84, 0x24, 0x38, 0x00, 0x40, 0x10,
+0x48, 0xEC, 0xA5, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x30, 0x96, 0x02, 0x80, 0x02, 0x3C, 0x21, 0x28, 0x40, 0x02,
+0x25, 0x80, 0x02, 0x02, 0x24, 0x00, 0x04, 0x26, 0x20, 0x00, 0x00, 0xA6,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0x2A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C, 0x30, 0x00, 0x04, 0x26,
+0xB4, 0x55, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x20, 0x00, 0x03, 0x96, 0x18, 0x00, 0x02, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0x03, 0xFF, 0x63, 0x30, 0xC0, 0x00, 0x63, 0x34, 0x20, 0x00, 0x03, 0xA6,
+0x60, 0x1B, 0xA5, 0x24, 0x0C, 0x00, 0x22, 0xAE, 0xE4, 0x1D, 0xA3, 0x94,
+0x20, 0x00, 0x07, 0x26, 0x38, 0x00, 0x04, 0x26, 0xFF, 0x0F, 0x62, 0x30,
+0x00, 0x11, 0x02, 0x00, 0x02, 0x32, 0x02, 0x00, 0x01, 0x00, 0x63, 0x24,
+0xE4, 0x1D, 0xA3, 0xA4, 0x17, 0x00, 0xE6, 0xA0, 0x16, 0x00, 0xE2, 0xA0,
+0x10, 0x00, 0xA6, 0x27, 0x0C, 0x00, 0x27, 0x26, 0x02, 0x00, 0x05, 0x24,
+0x4C, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB3, 0xA7, 0x21, 0x20, 0x20, 0x02,
+0x21, 0x28, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00, 0xDF, 0x0D, 0x00, 0x0C,
+0x21, 0x38, 0x00, 0x00, 0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xAC, 0xE8, 0x84, 0x24, 0x28, 0x00, 0xBF, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xD0, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB1, 0xAF, 0x21, 0x88, 0x80, 0x00,
+0x00, 0x01, 0x04, 0x24, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x21, 0x98, 0xA0, 0x00, 0x28, 0x00, 0xBF, 0xAF, 0x53, 0x21, 0x00, 0x0C,
+0x18, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x21, 0x90, 0x40, 0x00, 0x78, 0xEC, 0x84, 0x24, 0x3B, 0x00, 0x40, 0x10,
+0x68, 0xEC, 0xA5, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x50, 0x96, 0x02, 0x80, 0x02, 0x3C, 0x21, 0x28, 0x20, 0x02,
+0x25, 0x80, 0x02, 0x02, 0x24, 0x00, 0x04, 0x26, 0x20, 0x00, 0x00, 0xA6,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0x2A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C, 0x30, 0x00, 0x04, 0x26,
+0xB4, 0x55, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x20, 0x00, 0x03, 0x96, 0x18, 0x00, 0x02, 0x24, 0x02, 0x80, 0x11, 0x3C,
+0x03, 0xFF, 0x63, 0x30, 0xA0, 0x00, 0x63, 0x34, 0x20, 0x00, 0x03, 0xA6,
+0x60, 0x1B, 0x31, 0x26, 0x0C, 0x00, 0x42, 0xAE, 0xE4, 0x1D, 0x23, 0x96,
+0x20, 0x00, 0x06, 0x26, 0x38, 0x00, 0x04, 0x26, 0xFF, 0x0F, 0x62, 0x30,
+0x00, 0x11, 0x02, 0x00, 0x02, 0x2A, 0x02, 0x00, 0x01, 0x00, 0x63, 0x24,
+0xE4, 0x1D, 0x23, 0xA6, 0x0C, 0x00, 0x47, 0x26, 0x17, 0x00, 0xC5, 0xA0,
+0x16, 0x00, 0xC2, 0xA0, 0x02, 0x00, 0x05, 0x24, 0x10, 0x00, 0xA6, 0x27,
+0x4C, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xB3, 0xA7, 0xB6, 0x40, 0x23, 0x92,
+0x04, 0x00, 0x07, 0x24, 0x21, 0x20, 0x40, 0x02, 0x01, 0x00, 0x63, 0x38,
+0x0B, 0x38, 0x03, 0x00, 0x21, 0x28, 0x00, 0x00, 0xDF, 0x0D, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xAC, 0xE8, 0x84, 0x24, 0x28, 0x00, 0xBF, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xC8, 0xFF, 0xBD, 0x27, 0x2C, 0x00, 0xB1, 0xAF, 0xFF, 0xFF, 0x05, 0x24,
+0x21, 0x88, 0x80, 0x00, 0x02, 0x00, 0x06, 0x24, 0x10, 0x00, 0xA4, 0x27,
+0x34, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xB2, 0xAF, 0xEC, 0x54, 0x00, 0x0C,
+0x28, 0x00, 0xB0, 0xAF, 0x08, 0x00, 0x30, 0x96, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x28, 0x00, 0x00, 0x25, 0x80, 0x02, 0x02, 0x21, 0x20, 0x00, 0x02,
+0xEC, 0x54, 0x00, 0x0C, 0x10, 0x00, 0x06, 0x24, 0x20, 0x00, 0x02, 0x96,
+0x24, 0x00, 0x04, 0x26, 0x10, 0x00, 0xA5, 0x27, 0x03, 0xFF, 0x42, 0x30,
+0xC8, 0x00, 0x42, 0x34, 0x20, 0x00, 0x02, 0xA6, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x25, 0xB0, 0x03, 0x3C, 0x50, 0x00, 0x62, 0x34,
+0x00, 0x00, 0x44, 0x8C, 0x54, 0x00, 0x65, 0x34, 0x58, 0x00, 0x66, 0x34,
+0x18, 0x00, 0xA4, 0xAF, 0x00, 0x00, 0xA2, 0x8C, 0x5C, 0x00, 0x63, 0x34,
+0x2A, 0x00, 0x04, 0x26, 0x1C, 0x00, 0xA2, 0xAF, 0x00, 0x00, 0xC7, 0x8C,
+0x18, 0x00, 0xA5, 0x27, 0x06, 0x00, 0x06, 0x24, 0x20, 0x00, 0xA7, 0xAF,
+0x00, 0x00, 0x62, 0x8C, 0x1A, 0x00, 0x12, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x24, 0x00, 0xA2, 0xAF, 0x30, 0x00, 0x04, 0x26, 0x20, 0x00, 0xA5, 0x27,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x13, 0x00, 0x03, 0x24,
+0x14, 0x00, 0x23, 0xAE, 0x0C, 0x00, 0x32, 0xAE, 0x08, 0x00, 0x05, 0x8E,
+0x04, 0x00, 0x04, 0x8E, 0xFF, 0xDF, 0x02, 0x3C, 0x14, 0x00, 0x06, 0x8E,
+0xFF, 0xFF, 0x42, 0x34, 0x10, 0x00, 0x07, 0x8E, 0xFF, 0xE0, 0x03, 0x24,
+0x24, 0x28, 0xA2, 0x00, 0x00, 0x40, 0x02, 0x3C, 0x24, 0x20, 0x83, 0x00,
+0x25, 0x28, 0xA2, 0x00, 0xFF, 0x81, 0x03, 0x24, 0xFE, 0xFF, 0x02, 0x3C,
+0x24, 0x30, 0xC3, 0x00, 0xFF, 0xFF, 0x42, 0x34, 0x00, 0x12, 0x84, 0x34,
+0x00, 0x80, 0x03, 0x3C, 0x24, 0x20, 0x82, 0x00, 0x25, 0x38, 0xE3, 0x00,
+0x00, 0x26, 0xC6, 0x34, 0x80, 0x00, 0xA5, 0x34, 0x20, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x12, 0xA6, 0x10, 0x00, 0x07, 0xAE, 0x02, 0x00, 0x02, 0xA2,
+0x14, 0x00, 0x06, 0xAE, 0x04, 0x00, 0x04, 0xAE, 0x08, 0x00, 0x05, 0xAE,
+0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F,
+0x28, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0xB0, 0xFF, 0xBD, 0x27, 0x3C, 0x00, 0xB5, 0xAF, 0x34, 0x00, 0xB3, 0xAF,
+0xFF, 0xFF, 0xF5, 0x30, 0x25, 0xB0, 0x13, 0x3C, 0x01, 0x80, 0x02, 0x3C,
+0x2C, 0x00, 0xB1, 0xAF, 0x18, 0x03, 0x63, 0x36, 0x54, 0x40, 0x42, 0x24,
+0x20, 0x00, 0xB1, 0x26, 0x48, 0x00, 0xBE, 0xAF, 0x44, 0x00, 0xB7, 0xAF,
+0x38, 0x00, 0xB4, 0xAF, 0x64, 0x00, 0xB7, 0x93, 0x60, 0x00, 0xB4, 0x93,
+0x21, 0xF0, 0x80, 0x00, 0x00, 0x00, 0x62, 0xAC, 0x21, 0x20, 0x20, 0x02,
+0x40, 0x00, 0xB6, 0xAF, 0x30, 0x00, 0xB2, 0xAF, 0x4C, 0x00, 0xBF, 0xAF,
+0x28, 0x00, 0xB0, 0xAF, 0xFF, 0x00, 0xB6, 0x30, 0x53, 0x21, 0x00, 0x0C,
+0xFF, 0x00, 0xD2, 0x30, 0x12, 0x00, 0x40, 0x14, 0x24, 0x00, 0xA2, 0xAF,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0xAC, 0xE8, 0x84, 0x24,
+0x13, 0x58, 0x00, 0x0C, 0x88, 0xEC, 0xA5, 0x24, 0x4C, 0x00, 0xBF, 0x8F,
+0x48, 0x00, 0xBE, 0x8F, 0x44, 0x00, 0xB7, 0x8F, 0x40, 0x00, 0xB6, 0x8F,
+0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F,
+0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x50, 0x00, 0xBD, 0x27, 0x08, 0x00, 0x43, 0x8C,
+0xB0, 0x03, 0x62, 0x36, 0x02, 0x80, 0x10, 0x3C, 0x00, 0x00, 0x43, 0xAC,
+0x24, 0x00, 0xA2, 0x8F, 0x21, 0x30, 0x20, 0x02, 0x21, 0x28, 0x00, 0x00,
+0x08, 0x00, 0x44, 0x94, 0xE3, 0x54, 0x00, 0x0C, 0x25, 0x20, 0x90, 0x00,
+0x24, 0x00, 0xA3, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x88, 0x50, 0x00, 0x5C, 0x00, 0x80, 0x16,
+0x20, 0x00, 0x30, 0x26, 0x20, 0x00, 0x32, 0xA6, 0x48, 0x00, 0x02, 0x24,
+0x7A, 0x00, 0x42, 0x12, 0xC8, 0x00, 0x02, 0x24, 0x79, 0x00, 0x42, 0x12,
+0x50, 0x00, 0x62, 0x36, 0x04, 0x00, 0x02, 0x24, 0x56, 0x00, 0xC2, 0x16,
+0x21, 0x28, 0xC0, 0x03, 0xA4, 0x00, 0x02, 0x24, 0x9F, 0x00, 0x42, 0x12,
+0x02, 0x80, 0x02, 0x3C, 0x24, 0x00, 0xA2, 0x8F, 0x25, 0xB0, 0x10, 0x3C,
+0xB0, 0x03, 0x10, 0x36, 0x0C, 0x00, 0x55, 0xAC, 0x24, 0x00, 0xA2, 0x8F,
+0x12, 0x00, 0x03, 0x24, 0x21, 0x28, 0x00, 0x00, 0x14, 0x00, 0x43, 0xAC,
+0x00, 0x00, 0x15, 0xAE, 0x24, 0x00, 0xA2, 0x8F, 0x08, 0x00, 0x06, 0x24,
+0x08, 0x00, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xAE,
+0x24, 0x00, 0xA2, 0x8F, 0x02, 0x80, 0x03, 0x3C, 0x08, 0x00, 0x44, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x88, 0x83, 0x00, 0xEC, 0x54, 0x00, 0x0C,
+0x21, 0x20, 0x20, 0x02, 0x04, 0x00, 0x25, 0x8E, 0x08, 0x00, 0x24, 0x8E,
+0xFF, 0xDF, 0x02, 0x3C, 0xFF, 0xE0, 0x03, 0x24, 0xFF, 0xFF, 0x42, 0x34,
+0x14, 0x00, 0x26, 0x8E, 0x24, 0x28, 0xA3, 0x00, 0x24, 0x20, 0x82, 0x00,
+0x00, 0x40, 0x02, 0x3C, 0x10, 0x00, 0x27, 0x8E, 0x25, 0x20, 0x82, 0x00,
+0xE0, 0xFF, 0x03, 0x24, 0x00, 0x12, 0xA5, 0x34, 0xFF, 0xE0, 0x02, 0x3C,
+0x24, 0x28, 0xA3, 0x00, 0xFF, 0xFF, 0x42, 0x34, 0xFF, 0x81, 0x03, 0x24,
+0x24, 0x30, 0xC3, 0x00, 0x24, 0x20, 0x82, 0x00, 0x00, 0x05, 0x03, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x25, 0x38, 0xE2, 0x00, 0x25, 0x20, 0x83, 0x00,
+0x05, 0x00, 0xA5, 0x34, 0x20, 0x00, 0x02, 0x24, 0x08, 0x00, 0x24, 0xAE,
+0x00, 0x00, 0x35, 0xA6, 0x02, 0x00, 0x22, 0xA2, 0x14, 0x00, 0x26, 0xAE,
+0x10, 0x00, 0x27, 0xAE, 0x04, 0x00, 0x25, 0xAE, 0x8A, 0x40, 0x00, 0x0C,
+0x20, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x24, 0x00, 0xA3, 0x8F,
+0x98, 0x54, 0x42, 0x24, 0x04, 0x00, 0x44, 0x8C, 0x00, 0x00, 0x62, 0xAC,
+0x04, 0x00, 0x43, 0xAC, 0x24, 0x00, 0xA2, 0x27, 0x00, 0x00, 0x83, 0xAC,
+0x04, 0x00, 0x64, 0xAC, 0x20, 0x00, 0xA4, 0x27, 0x00, 0x00, 0x02, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x00, 0xBF, 0x8F,
+0x48, 0x00, 0xBE, 0x8F, 0x44, 0x00, 0xB7, 0x8F, 0x40, 0x00, 0xB6, 0x8F,
+0x3C, 0x00, 0xB5, 0x8F, 0x38, 0x00, 0xB4, 0x8F, 0x34, 0x00, 0xB3, 0x8F,
+0x30, 0x00, 0xB2, 0x8F, 0x2C, 0x00, 0xB1, 0x8F, 0x28, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x50, 0x00, 0xBD, 0x27, 0x00, 0x10, 0x42, 0x36,
+0x53, 0x50, 0x00, 0x08, 0x20, 0x00, 0x22, 0xA6, 0x04, 0x00, 0x04, 0x26,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0x48, 0x37, 0xA5, 0x24, 0x0A, 0x00, 0x04, 0x26, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C, 0xB4, 0x55, 0xA5, 0x24,
+0x10, 0x00, 0x04, 0x26, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x00, 0x1E, 0x12, 0x00, 0x03, 0x1E, 0x03, 0x00, 0x28, 0x00, 0x60, 0x04,
+0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24, 0xE4, 0x1D, 0xA6, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xC2, 0x24, 0x00, 0x21, 0x06, 0x00,
+0xFF, 0xFF, 0x46, 0x30, 0xFF, 0xFF, 0x84, 0x30, 0x00, 0x10, 0xC2, 0x2C,
+0x0A, 0x30, 0x02, 0x00, 0x02, 0x1A, 0x04, 0x00, 0x17, 0x00, 0x03, 0xA2,
+0x16, 0x00, 0x04, 0xA2, 0x5E, 0x50, 0x00, 0x08, 0xE4, 0x1D, 0xA6, 0xA4,
+0x50, 0x00, 0x62, 0x36, 0x00, 0x00, 0x43, 0x8C, 0x54, 0x00, 0x64, 0x36,
+0x58, 0x00, 0x65, 0x36, 0x10, 0x00, 0xA3, 0xAF, 0x00, 0x00, 0x82, 0x8C,
+0x5C, 0x00, 0x67, 0x36, 0x2A, 0x00, 0x24, 0x26, 0x14, 0x00, 0xA2, 0xAF,
+0x00, 0x00, 0xA3, 0x8C, 0x06, 0x00, 0x06, 0x24, 0x10, 0x00, 0xA5, 0x27,
+0x18, 0x00, 0xA3, 0xAF, 0x00, 0x00, 0xE2, 0x8C, 0xF4, 0x54, 0x00, 0x0C,
+0x1C, 0x00, 0xA2, 0xAF, 0x30, 0x00, 0x24, 0x26, 0x18, 0x00, 0xA5, 0x27,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x20, 0x00, 0x23, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63, 0x34, 0x58, 0x50, 0x00, 0x08,
+0x20, 0x00, 0x23, 0xA6, 0x02, 0x80, 0x02, 0x3C, 0xFF, 0xFF, 0xE3, 0x32,
+0x60, 0x1B, 0x42, 0x24, 0x40, 0x28, 0x17, 0x00, 0x18, 0x00, 0x03, 0xA2,
+0x21, 0x28, 0xA2, 0x00, 0x19, 0x00, 0x00, 0xA2, 0xD4, 0x1D, 0xA6, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xC2, 0x24, 0x00, 0x21, 0x06, 0x00,
+0xFF, 0xFF, 0x46, 0x30, 0xFF, 0xFF, 0x84, 0x30, 0x00, 0x10, 0xC2, 0x2C,
+0x0A, 0x30, 0x02, 0x00, 0x02, 0x1A, 0x04, 0x00, 0x17, 0x00, 0x03, 0xA2,
+0x16, 0x00, 0x04, 0xA2, 0x5E, 0x50, 0x00, 0x08, 0xD4, 0x1D, 0xA6, 0xA4,
+0xAC, 0x55, 0x43, 0x94, 0x02, 0x80, 0x05, 0x3C, 0x04, 0x00, 0x04, 0x26,
+0x00, 0xC0, 0x63, 0x24, 0xFF, 0xFF, 0x63, 0x30, 0x02, 0x12, 0x03, 0x00,
+0xB4, 0x55, 0xA5, 0x24, 0x03, 0x00, 0x02, 0xA2, 0x02, 0x00, 0x03, 0xA2,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x02, 0x80, 0x05, 0x3C,
+0x0A, 0x00, 0x04, 0x26, 0x48, 0x37, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x5E, 0x50, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x82, 0x30, 0x02, 0x80, 0x04, 0x3C, 0xE0, 0xFF, 0xBD, 0x27,
+0xB4, 0x55, 0x84, 0x24, 0x08, 0x00, 0x05, 0x24, 0x48, 0x00, 0x06, 0x24,
+0x18, 0x00, 0x07, 0x24, 0x18, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xA2, 0xAF,
+0x15, 0x50, 0x00, 0x0C, 0x14, 0x00, 0xA0, 0xAF, 0x18, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xC8, 0xFF, 0xBD, 0x27, 0x2C, 0x00, 0xB5, 0xAF, 0x02, 0x80, 0x15, 0x3C,
+0x1C, 0x00, 0xB1, 0xAF, 0x34, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xB6, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0xB1, 0x26, 0xB0, 0x1B, 0x23, 0x96,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x62, 0x30, 0x37, 0x00, 0x40, 0x14,
+0x00, 0x01, 0x62, 0x30, 0x2A, 0x00, 0x40, 0x10, 0x00, 0x10, 0x62, 0x30,
+0x25, 0x00, 0x40, 0x14, 0x01, 0x00, 0x62, 0x30, 0x45, 0x00, 0x40, 0x14,
+0x04, 0x00, 0x62, 0x30, 0x21, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x21, 0x98, 0x20, 0x02, 0x47, 0x39, 0x56, 0x24, 0x01, 0x00, 0x14, 0x24,
+0x20, 0x01, 0x11, 0x24, 0x3E, 0x51, 0x00, 0x08, 0x19, 0x00, 0x12, 0x24,
+0xFF, 0xFF, 0x52, 0x26, 0x18, 0x00, 0x40, 0x06, 0x30, 0x00, 0x31, 0x26,
+0x21, 0x80, 0x33, 0x02, 0xE6, 0x1D, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xF9, 0xFF, 0x54, 0x14, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1D, 0x02, 0x8E,
+0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x40, 0x14, 0x10, 0x00, 0xA4, 0x27,
+0x3A, 0x41, 0x62, 0x92, 0x21, 0x20, 0x36, 0x02, 0xFF, 0xFF, 0x42, 0x24,
+0x3A, 0x41, 0x62, 0xA2, 0xC4, 0x0E, 0x00, 0x0C, 0xE6, 0x1D, 0x00, 0xA2,
+0x3C, 0x51, 0x00, 0x08, 0xFF, 0xFF, 0x52, 0x26, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x10, 0x00, 0xA4, 0x27, 0x14, 0x40, 0x20, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0xE8, 0x1E, 0x20, 0xAE, 0xA9, 0x1B, 0x00, 0x0C,
+0x60, 0x1B, 0xB0, 0x26, 0xE8, 0x39, 0x02, 0xAE, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F,
+0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x38, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C,
+0x98, 0xEC, 0x84, 0x24, 0xB0, 0x1B, 0x22, 0x96, 0xE8, 0x39, 0x20, 0xAE,
+0xFD, 0xFF, 0x04, 0x24, 0xEF, 0xDF, 0x42, 0x30, 0x35, 0x48, 0x00, 0x0C,
+0xB0, 0x1B, 0x22, 0xA6, 0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xB6, 0x8F,
+0x2C, 0x00, 0xB5, 0x8F, 0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F,
+0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0xE8, 0x1E, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00, 0xD5, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x40, 0x22, 0x8E, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x00, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0xEE, 0x5D, 0x43, 0x90,
+0x01, 0x00, 0x04, 0x24, 0x0F, 0x00, 0x63, 0x30, 0x05, 0x00, 0x63, 0x28,
+0x0E, 0x00, 0x60, 0x10, 0x14, 0x40, 0x24, 0xAE, 0x0E, 0x51, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xA9, 0x1B, 0x00, 0x0C, 0x60, 0x1B, 0xB0, 0x26,
+0x58, 0x51, 0x00, 0x08, 0xE8, 0x39, 0x02, 0xAE, 0x8A, 0x40, 0x00, 0x0C,
+0xFF, 0xFF, 0x52, 0x26, 0x10, 0x00, 0xA4, 0x27, 0x90, 0x40, 0x00, 0x0C,
+0xF8, 0x1D, 0x00, 0xAE, 0x3C, 0x51, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x0E, 0x51, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0x87, 0x51, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C,
+0xB8, 0xEC, 0x84, 0x24, 0x25, 0xB0, 0x06, 0x3C, 0x4C, 0x00, 0xC2, 0x34,
+0x00, 0x00, 0x40, 0xA0, 0x48, 0x00, 0xC6, 0x34, 0x00, 0x00, 0xC3, 0x8C,
+0xB0, 0x1B, 0x27, 0x96, 0x7B, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x18, 0x62, 0x00, 0xFE, 0xFE, 0xE7, 0x30, 0x00, 0x00, 0xC3, 0xAC,
+0x21, 0x28, 0x00, 0x00, 0xB0, 0x1B, 0x27, 0xA6, 0x21, 0x20, 0x00, 0x00,
+0x37, 0x3E, 0x20, 0xA2, 0x95, 0x0E, 0x00, 0x0C, 0xD6, 0x1E, 0x20, 0xA2,
+0x02, 0x80, 0x04, 0x3C, 0xC4, 0x0E, 0x00, 0x0C, 0xB4, 0x55, 0x84, 0x24,
+0xA9, 0x1B, 0x00, 0x0C, 0x60, 0x1B, 0xB0, 0x26, 0x58, 0x51, 0x00, 0x08,
+0xE8, 0x39, 0x02, 0xAE, 0xFF, 0x00, 0x84, 0x30, 0x02, 0x00, 0x02, 0x24,
+0x03, 0x00, 0x83, 0x28, 0x0D, 0x00, 0x82, 0x10, 0x21, 0x28, 0x00, 0x00,
+0x06, 0x00, 0x60, 0x10, 0x04, 0x00, 0x02, 0x24, 0x01, 0x00, 0x02, 0x24,
+0x0B, 0x00, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0xA0, 0x00, 0xFD, 0xFF, 0x82, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x04, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x06, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB1, 0xAF, 0xFF, 0x00, 0x91, 0x30,
+0x02, 0x80, 0x04, 0x3C, 0x18, 0x00, 0xB0, 0xAF, 0xD4, 0xEC, 0x84, 0x24,
+0xFF, 0x00, 0xB0, 0x30, 0x20, 0x00, 0xBF, 0xAF, 0x13, 0x58, 0x00, 0x0C,
+0x21, 0x28, 0x20, 0x02, 0xB1, 0x51, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02,
+0x02, 0x80, 0x04, 0x3C, 0xB4, 0x55, 0x84, 0x24, 0x08, 0x00, 0x05, 0x24,
+0xC8, 0x00, 0x06, 0x24, 0x1A, 0x00, 0x07, 0x24, 0x10, 0x00, 0xB1, 0xAF,
+0x15, 0x50, 0x00, 0x0C, 0x14, 0x00, 0xA2, 0xAF, 0x20, 0x00, 0xBF, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x05, 0x3C,
+0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x60, 0x1B, 0xA5, 0x24,
+0x4C, 0x3A, 0xA2, 0x94, 0x01, 0x00, 0x03, 0x24, 0xFF, 0x00, 0x90, 0x30,
+0x00, 0xC0, 0x42, 0x24, 0xFF, 0xFF, 0x44, 0x30, 0xA3, 0x31, 0x00, 0x0C,
+0x2A, 0x1C, 0xA3, 0xA0, 0x02, 0x80, 0x04, 0x3C, 0xB4, 0x55, 0x84, 0x24,
+0x04, 0x00, 0x05, 0x24, 0xA4, 0x00, 0x06, 0x24, 0x10, 0x00, 0x07, 0x24,
+0x10, 0x00, 0xB0, 0xAF, 0x15, 0x50, 0x00, 0x0C, 0x14, 0x00, 0xA0, 0xAF,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x80, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x08, 0x00, 0x82, 0x24, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xBF, 0xAF, 0xFB, 0x51, 0x00, 0x0C, 0x74, 0x00, 0x84, 0x24,
+0x21, 0x28, 0x40, 0x00, 0x10, 0x00, 0xA4, 0x27, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x10, 0x00, 0xA2, 0x97, 0x18, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xBF, 0xAF, 0xFB, 0x51, 0x00, 0x0C,
+0x10, 0x00, 0xA5, 0xA7, 0x21, 0x20, 0x40, 0x00, 0x10, 0x00, 0xA5, 0x27,
+0xF4, 0x54, 0x00, 0x0C, 0x02, 0x00, 0x06, 0x24, 0x18, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0xE0, 0x03, 0x0A, 0x00, 0x82, 0x24, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xBF, 0xAF, 0x16, 0x52, 0x00, 0x0C, 0x74, 0x00, 0x84, 0x24,
+0x21, 0x28, 0x40, 0x00, 0x10, 0x00, 0xA4, 0x27, 0xF4, 0x54, 0x00, 0x0C,
+0x02, 0x00, 0x06, 0x24, 0x10, 0x00, 0xA2, 0x97, 0x18, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x00, 0x00, 0x05, 0xA2, 0x01, 0x00, 0x06, 0xA2, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF, 0x21, 0x88, 0xC0, 0x00,
+0x02, 0x00, 0x84, 0x24, 0x30, 0x00, 0xB2, 0x8F, 0x0D, 0x00, 0xC0, 0x14,
+0x21, 0x28, 0xE0, 0x00, 0x00, 0x00, 0x43, 0x8E, 0x21, 0x10, 0x11, 0x02,
+0x1C, 0x00, 0xBF, 0x8F, 0x21, 0x18, 0x71, 0x00, 0x02, 0x00, 0x63, 0x24,
+0x00, 0x00, 0x43, 0xAE, 0x14, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x02, 0x00, 0x42, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xF4, 0x54, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x43, 0x8E, 0x21, 0x10, 0x11, 0x02, 0x1C, 0x00, 0xBF, 0x8F,
+0x21, 0x18, 0x71, 0x00, 0x02, 0x00, 0x63, 0x24, 0x00, 0x00, 0x43, 0xAE,
+0x14, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x02, 0x00, 0x42, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0xA0, 0x00,
+0x18, 0x00, 0xB2, 0xAF, 0x21, 0x28, 0xC0, 0x00, 0x21, 0x90, 0xE0, 0x00,
+0x21, 0x30, 0x00, 0x02, 0x1C, 0x00, 0xBF, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0xF4, 0x54, 0x00, 0x0C, 0x21, 0x88, 0x80, 0x00, 0x00, 0x00, 0x43, 0x8E,
+0x21, 0x10, 0x30, 0x02, 0x1C, 0x00, 0xBF, 0x8F, 0x21, 0x18, 0x70, 0x00,
+0x00, 0x00, 0x43, 0xAE, 0x14, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x7F, 0x00, 0x84, 0x30, 0x6D, 0x00, 0x82, 0x2C, 0x0A, 0x00, 0x40, 0x10,
+0x21, 0x28, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x80, 0x10, 0x04, 0x00,
+0xFC, 0xEC, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x28, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x0B, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x0A, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x09, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x08, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x07, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x06, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x03, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x05, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x04, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x02, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x01, 0x00, 0x05, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x7F, 0x00, 0x84, 0x30, 0x0C, 0x00, 0x82, 0x2C, 0x0A, 0x00, 0x40, 0x10,
+0x21, 0x18, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x80, 0x10, 0x04, 0x00,
+0xB0, 0xEE, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x6C, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x60, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x48, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x30, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x24, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x18, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x12, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x0C, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x16, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x0B, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x04, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x02, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0xC8, 0xFF, 0xBD, 0x27, 0x24, 0x00, 0xB5, 0xAF, 0x02, 0x80, 0x15, 0x3C,
+0x2C, 0x00, 0xB7, 0xAF, 0x28, 0x00, 0xB6, 0xAF, 0x20, 0x00, 0xB4, 0xAF,
+0x1C, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0xB8, 0x80, 0x00,
+0x21, 0xA0, 0x00, 0x00, 0x21, 0x98, 0x00, 0x00, 0x60, 0x1B, 0xB6, 0x26,
+0x60, 0x1B, 0xA2, 0x26, 0x21, 0x10, 0x62, 0x02, 0xFB, 0x1B, 0x51, 0x90,
+0xFE, 0x00, 0x03, 0x24, 0x1E, 0x00, 0x23, 0x12, 0xFF, 0x00, 0x02, 0x24,
+0x21, 0x00, 0x22, 0x12, 0x21, 0x10, 0x80, 0x02, 0x91, 0x52, 0x00, 0x0C,
+0x21, 0x20, 0x20, 0x02, 0x21, 0x88, 0x40, 0x00, 0x21, 0x80, 0x00, 0x00,
+0x21, 0x90, 0xC0, 0x02, 0x21, 0x10, 0x12, 0x02, 0xEE, 0x1B, 0x44, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x82, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x02, 0x00, 0x42, 0x2C, 0x05, 0x00, 0x40, 0x14, 0x01, 0x00, 0x10, 0x26,
+0x91, 0x52, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x51, 0x10,
+0x01, 0x00, 0x03, 0x24, 0x0D, 0x00, 0x02, 0x2A, 0xF3, 0xFF, 0x40, 0x14,
+0x21, 0x10, 0x12, 0x02, 0x21, 0x18, 0x00, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x14, 0x00, 0x62, 0x10, 0xFF, 0x00, 0x22, 0x32, 0x21, 0x10, 0xF4, 0x02,
+0x00, 0x00, 0x51, 0xA0, 0x01, 0x00, 0x94, 0x26, 0x01, 0x00, 0x73, 0x26,
+0x0D, 0x00, 0x62, 0x2A, 0xDB, 0xFF, 0x40, 0x14, 0x60, 0x1B, 0xA2, 0x26,
+0x21, 0x10, 0x80, 0x02, 0x30, 0x00, 0xBF, 0x8F, 0x2C, 0x00, 0xB7, 0x8F,
+0x28, 0x00, 0xB6, 0x8F, 0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27,
+0xF0, 0x52, 0x00, 0x08, 0x80, 0x00, 0x51, 0x34, 0xD0, 0xFF, 0xBD, 0x27,
+0x24, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xB0, 0xAF, 0x21, 0x88, 0x80, 0x00,
+0x21, 0x80, 0xA0, 0x00, 0x0D, 0x00, 0x06, 0x24, 0x21, 0x28, 0x00, 0x00,
+0x28, 0x00, 0xBF, 0xAF, 0xE3, 0x54, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0xC1, 0x52, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x00, 0x00, 0x02, 0xAE,
+0x21, 0x20, 0x20, 0x02, 0x10, 0x00, 0xA5, 0x27, 0xF4, 0x54, 0x00, 0x0C,
+0x21, 0x30, 0x40, 0x00, 0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB1, 0x8F,
+0x20, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0x21, 0x28, 0x00, 0x00, 0x21, 0x10, 0x85, 0x00, 0x00, 0x00, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x60, 0x10, 0x0D, 0x00, 0xA2, 0x2C,
+0xFA, 0xFF, 0x40, 0x14, 0x01, 0x00, 0xA5, 0x24, 0xFF, 0xFF, 0xA5, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00, 0x00, 0x00, 0x82, 0x94,
+0x21, 0x30, 0x80, 0x00, 0x10, 0x00, 0x85, 0x24, 0x42, 0x1A, 0x02, 0x00,
+0xC2, 0x11, 0x02, 0x00, 0x02, 0x00, 0x42, 0x30, 0x01, 0x00, 0x63, 0x30,
+0x25, 0x18, 0x43, 0x00, 0x01, 0x00, 0x04, 0x24, 0x07, 0x00, 0x64, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x60, 0x10, 0x0A, 0x00, 0xC5, 0x24,
+0x02, 0x00, 0x02, 0x24, 0x02, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x00, 0xC5, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xA0, 0x00,
+0x00, 0x00, 0x82, 0x94, 0x21, 0x30, 0x80, 0x00, 0x04, 0x00, 0x85, 0x24,
+0x42, 0x1A, 0x02, 0x00, 0xC2, 0x11, 0x02, 0x00, 0x02, 0x00, 0x42, 0x30,
+0x01, 0x00, 0x63, 0x30, 0x25, 0x18, 0x43, 0x00, 0x01, 0x00, 0x04, 0x24,
+0x04, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xC5, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0xA0, 0x00, 0x13, 0x00, 0xA0, 0x18, 0x21, 0x30, 0x00, 0x00,
+0x02, 0x00, 0x07, 0x24, 0x04, 0x00, 0x08, 0x24, 0x0B, 0x00, 0x09, 0x24,
+0x16, 0x00, 0x0A, 0x24, 0x21, 0x10, 0x86, 0x00, 0x00, 0x00, 0x43, 0x90,
+0x01, 0x00, 0xC6, 0x24, 0x7F, 0x00, 0x63, 0x30, 0x07, 0x00, 0x67, 0x10,
+0x2A, 0x10, 0xC5, 0x00, 0x05, 0x00, 0x68, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x03, 0x00, 0x69, 0x10, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x6A, 0x14,
+0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x14, 0x00, 0xBF, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0x5C, 0x5C, 0x43, 0x8C,
+0x08, 0x00, 0x10, 0x24, 0x06, 0x00, 0xA0, 0x14, 0x0A, 0x80, 0x03, 0x00,
+0x21, 0x10, 0x00, 0x02, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x49, 0x53, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x36, 0x01, 0x00, 0x42, 0x38,
+0x03, 0x00, 0x04, 0x36, 0x21, 0x80, 0x60, 0x00, 0x0B, 0x80, 0x82, 0x00,
+0x21, 0x10, 0x00, 0x02, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27,
+0x14, 0x00, 0xB1, 0xAF, 0x0E, 0x00, 0xA3, 0x2C, 0x21, 0x88, 0xA0, 0x00,
+0x0D, 0x00, 0x02, 0x24, 0x0A, 0x88, 0x43, 0x00, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xBF, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x21, 0x98, 0x80, 0x00, 0x21, 0x90, 0x00, 0x00,
+0x15, 0x00, 0x20, 0x12, 0x21, 0x80, 0x00, 0x00, 0x8E, 0x53, 0x00, 0x08,
+0x01, 0x00, 0x14, 0x24, 0x2B, 0x10, 0x11, 0x02, 0x11, 0x00, 0x40, 0x10,
+0x21, 0x10, 0x40, 0x02, 0x21, 0x18, 0x70, 0x02, 0x00, 0x00, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x44, 0x30, 0x00, 0x16, 0x02, 0x00,
+0x03, 0x16, 0x02, 0x00, 0xF6, 0xFF, 0x41, 0x04, 0x01, 0x00, 0x10, 0x26,
+0x61, 0x52, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x54, 0x00,
+0x25, 0x90, 0x42, 0x02, 0x2B, 0x10, 0x11, 0x02, 0xF3, 0xFF, 0x40, 0x14,
+0x21, 0x18, 0x70, 0x02, 0x21, 0x10, 0x40, 0x02, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF,
+0x0E, 0x00, 0xA3, 0x2C, 0x21, 0x88, 0xA0, 0x00, 0x0D, 0x00, 0x02, 0x24,
+0x0A, 0x88, 0x43, 0x00, 0x20, 0x00, 0xB4, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB3, 0xAF,
+0x21, 0xA0, 0x80, 0x00, 0x21, 0x90, 0x00, 0x00, 0x0A, 0x00, 0x20, 0x12,
+0x21, 0x80, 0x00, 0x00, 0x01, 0x00, 0x13, 0x24, 0x21, 0x10, 0x90, 0x02,
+0x00, 0x00, 0x44, 0x90, 0x61, 0x52, 0x00, 0x0C, 0x01, 0x00, 0x10, 0x26,
+0x04, 0x10, 0x53, 0x00, 0x2B, 0x18, 0x11, 0x02, 0xF9, 0xFF, 0x60, 0x14,
+0x25, 0x90, 0x42, 0x02, 0x21, 0x10, 0x40, 0x02, 0x24, 0x00, 0xBF, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xE8, 0xFF, 0xBD, 0x27, 0xFF, 0xFF, 0x02, 0x24,
+0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF, 0x21, 0x30, 0xA0, 0x00,
+0x1B, 0x00, 0x82, 0x10, 0x20, 0x00, 0x10, 0x24, 0x20, 0x00, 0x82, 0x28,
+0x06, 0x00, 0x40, 0x14, 0x40, 0x18, 0x04, 0x00, 0x21, 0x10, 0x00, 0x02,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x21, 0x18, 0x64, 0x00, 0x21, 0x80, 0x80, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x19, 0x03, 0x00,
+0x60, 0x1B, 0x42, 0x24, 0x47, 0x39, 0x84, 0x24, 0x21, 0x20, 0x64, 0x00,
+0x21, 0x18, 0x62, 0x00, 0x01, 0x00, 0x02, 0x24, 0x06, 0x00, 0x06, 0x24,
+0xF4, 0x54, 0x00, 0x0C, 0xE6, 0x1D, 0x62, 0xA0, 0x21, 0x10, 0x00, 0x02,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0xF0, 0x00, 0x47, 0x24, 0x05, 0x00, 0x10, 0x24, 0xD6, 0x1E, 0x43, 0x24,
+0xF4, 0x53, 0x00, 0x08, 0xF0, 0x00, 0x05, 0x24, 0x01, 0x00, 0x10, 0x26,
+0x20, 0x00, 0x02, 0x2E, 0x30, 0x00, 0xA5, 0x24, 0xDE, 0xFF, 0x40, 0x10,
+0x30, 0x00, 0xE7, 0x24, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xF8, 0xFF, 0x40, 0x14, 0x30, 0x00, 0x63, 0x24, 0x02, 0x80, 0x04, 0x3C,
+0x47, 0x39, 0x84, 0x24, 0x01, 0x00, 0x02, 0x24, 0x21, 0x20, 0xA4, 0x00,
+0xE6, 0x1D, 0xE2, 0xA0, 0x21, 0x28, 0xC0, 0x00, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0xE4, 0x53, 0x00, 0x08, 0x21, 0x10, 0x00, 0x02,
+0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x30, 0x00, 0xB2, 0x8F, 0x21, 0x88, 0x80, 0x00, 0x21, 0x20, 0xA0, 0x00,
+0x21, 0x28, 0x20, 0x02, 0x10, 0x00, 0xB0, 0xAF, 0x1C, 0x00, 0xBF, 0xAF,
+0xC7, 0x53, 0x00, 0x0C, 0xFF, 0xFF, 0xF0, 0x30, 0x20, 0x00, 0x03, 0x24,
+0xFF, 0x00, 0x44, 0x30, 0x21, 0x28, 0x00, 0x02, 0x21, 0x30, 0x20, 0x02,
+0x07, 0x00, 0x43, 0x10, 0x21, 0x38, 0x40, 0x02, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x6F, 0x20, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xD0, 0xFF, 0xBD, 0x27,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x24, 0x00, 0xB5, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0x21, 0xA8, 0x80, 0x00,
+0x60, 0x1B, 0x54, 0x24, 0x47, 0x39, 0x73, 0x24, 0x05, 0x00, 0x11, 0x24,
+0x01, 0x00, 0x12, 0x24, 0xF0, 0x00, 0x10, 0x24, 0x34, 0x54, 0x00, 0x08,
+0x28, 0x00, 0xBF, 0xAF, 0x01, 0x00, 0x31, 0x26, 0x20, 0x00, 0x22, 0x2A,
+0x0E, 0x00, 0x40, 0x10, 0x21, 0x10, 0x20, 0x02, 0x21, 0x10, 0x14, 0x02,
+0xE6, 0x1D, 0x43, 0x90, 0x21, 0x20, 0x13, 0x02, 0x21, 0x28, 0xA0, 0x02,
+0x06, 0x00, 0x06, 0x24, 0xF6, 0xFF, 0x72, 0x14, 0x30, 0x00, 0x10, 0x26,
+0x1D, 0x55, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x31, 0x26, 0xFF, 0xFF, 0x31, 0x26, 0x21, 0x10, 0x20, 0x02,
+0x28, 0x00, 0xBF, 0x8F, 0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x30, 0x00, 0xBD, 0x27,
+0xD0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x28, 0x00, 0xB6, 0xAF, 0x24, 0x00, 0xB5, 0xAF, 0x20, 0x00, 0xB4, 0xAF,
+0x1C, 0x00, 0xB3, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x21, 0x98, 0x80, 0x00, 0x60, 0x1B, 0x56, 0x24, 0x47, 0x39, 0x75, 0x24,
+0x21, 0x88, 0x00, 0x00, 0x01, 0x00, 0x14, 0x24, 0x21, 0x80, 0x00, 0x00,
+0x2C, 0x00, 0xBF, 0xAF, 0x60, 0x54, 0x00, 0x08, 0x18, 0x00, 0xB2, 0xAF,
+0x01, 0x00, 0x31, 0x26, 0x20, 0x00, 0x22, 0x2A, 0x1E, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x90, 0x16, 0x02, 0xE6, 0x1D, 0x42, 0x92,
+0x21, 0x20, 0x15, 0x02, 0x21, 0x28, 0x60, 0x02, 0x06, 0x00, 0x06, 0x24,
+0xF6, 0xFF, 0x54, 0x14, 0x30, 0x00, 0x10, 0x26, 0x1D, 0x55, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0x40, 0x14, 0x01, 0x00, 0x31, 0x26,
+0xFF, 0xFF, 0x31, 0x26, 0x02, 0x80, 0x06, 0x3C, 0x02, 0x80, 0x07, 0x3C,
+0xFF, 0x00, 0x24, 0x32, 0xE6, 0x1D, 0x40, 0xA2, 0x2C, 0x00, 0xBF, 0x8F,
+0x28, 0x00, 0xB6, 0x8F, 0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F,
+0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x88, 0xDE, 0xC6, 0x24, 0x78, 0xDE, 0xE7, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x6F, 0x20, 0x00, 0x08, 0x30, 0x00, 0xBD, 0x27,
+0x2C, 0x00, 0xBF, 0x8F, 0x28, 0x00, 0xB6, 0x8F, 0x24, 0x00, 0xB5, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x30, 0x00, 0xBD, 0x27, 0xC8, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x18, 0x00, 0xB2, 0xAF, 0x60, 0x1B, 0x52, 0x24, 0x30, 0x00, 0xBE, 0xAF,
+0x2C, 0x00, 0xB7, 0xAF, 0x28, 0x00, 0xB6, 0xAF, 0x24, 0x00, 0xB5, 0xAF,
+0x20, 0x00, 0xB4, 0xAF, 0x1C, 0x00, 0xB3, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x34, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x00, 0x00,
+0x02, 0x80, 0x1E, 0x3C, 0x02, 0x80, 0x17, 0x3C, 0x02, 0x80, 0x16, 0x3C,
+0x01, 0x00, 0x13, 0x24, 0xFF, 0xF7, 0x15, 0x24, 0xFF, 0xEF, 0x14, 0x24,
+0x21, 0x88, 0x40, 0x02, 0xE6, 0x1D, 0x22, 0x92, 0xC0, 0x48, 0x10, 0x00,
+0xD2, 0x5C, 0xC7, 0x93, 0x41, 0x00, 0x53, 0x10, 0x21, 0x30, 0x32, 0x01,
+0xD4, 0x23, 0xC2, 0x8C, 0xBF, 0xFF, 0x03, 0x24, 0x24, 0x28, 0x43, 0x00,
+0x80, 0x07, 0xA3, 0x34, 0x24, 0x10, 0x75, 0x00, 0x31, 0x00, 0xF3, 0x10,
+0x24, 0x10, 0x54, 0x00, 0xD4, 0x23, 0xC2, 0xAC, 0x21, 0x48, 0x32, 0x01,
+0xD4, 0x23, 0x23, 0x8D, 0xFD, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x18, 0x62, 0x00, 0xFB, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x18, 0x62, 0x00, 0xE7, 0xFF, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0x24, 0x18, 0x62, 0x00, 0xFF, 0xFD, 0x02, 0x3C, 0xFF, 0xFF, 0x42, 0x34,
+0xD8, 0x23, 0x28, 0x8D, 0x24, 0x18, 0x62, 0x00, 0xFF, 0xFB, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x18, 0x62, 0x00, 0xFF, 0xE7, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x1F, 0x00, 0x06, 0x3C, 0x00, 0x80, 0x08, 0x35,
+0x24, 0x18, 0x62, 0x00, 0x25, 0x40, 0x06, 0x01, 0xFF, 0x00, 0x04, 0x32,
+0x21, 0x28, 0x00, 0x00, 0x01, 0x00, 0x10, 0x26, 0x88, 0xDE, 0xE6, 0x26,
+0x78, 0xDE, 0xC7, 0x26, 0xD8, 0x23, 0x28, 0xAD, 0x6F, 0x20, 0x00, 0x0C,
+0xD4, 0x23, 0x23, 0xAD, 0x20, 0x00, 0x02, 0x2A, 0xD1, 0xFF, 0x40, 0x14,
+0x30, 0x00, 0x31, 0x26, 0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xBE, 0x8F,
+0x2C, 0x00, 0xB7, 0x8F, 0x28, 0x00, 0xB6, 0x8F, 0x24, 0x00, 0xB5, 0x8F,
+0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x38, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0xD3, 0x5C, 0x44, 0x90,
+0x24, 0x18, 0x75, 0x00, 0x80, 0x0F, 0xA2, 0x34, 0x00, 0x10, 0x63, 0x34,
+0xCA, 0xFF, 0x87, 0x14, 0x24, 0x10, 0x54, 0x00, 0xA9, 0x54, 0x00, 0x08,
+0xD4, 0x23, 0xC3, 0xAC, 0xA1, 0x54, 0x00, 0x08, 0xE6, 0x1D, 0x20, 0xA2,
+0xE8, 0x54, 0x00, 0x08, 0xFF, 0x00, 0xA5, 0x30, 0x00, 0x00, 0x85, 0xA0,
+0xFF, 0xFF, 0xC6, 0x24, 0x01, 0x00, 0x84, 0x24, 0xFC, 0xFF, 0xC0, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x05, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0xAC,
+0xFF, 0xFF, 0xC6, 0x24, 0xFD, 0xFF, 0xC0, 0x14, 0x04, 0x00, 0x84, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x21, 0x38, 0x80, 0x00,
+0x08, 0x00, 0xC0, 0x10, 0xFF, 0xFF, 0xC3, 0x24, 0xFF, 0xFF, 0x06, 0x24,
+0x00, 0x00, 0xA2, 0x90, 0xFF, 0xFF, 0x63, 0x24, 0x01, 0x00, 0xA5, 0x24,
+0x00, 0x00, 0xE2, 0xA0, 0xFB, 0xFF, 0x66, 0x14, 0x01, 0x00, 0xE7, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x80, 0x00, 0x2B, 0x10, 0xA4, 0x00,
+0x0D, 0x00, 0x40, 0x14, 0xFF, 0xFF, 0x02, 0x24, 0xFF, 0xFF, 0xC6, 0x24,
+0x08, 0x00, 0xC2, 0x10, 0x21, 0x18, 0x80, 0x00, 0xFF, 0xFF, 0x07, 0x24,
+0x00, 0x00, 0xA2, 0x90, 0xFF, 0xFF, 0xC6, 0x24, 0x01, 0x00, 0xA5, 0x24,
+0x00, 0x00, 0x62, 0xA0, 0xFB, 0xFF, 0xC7, 0x14, 0x01, 0x00, 0x63, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x80, 0x00, 0x21, 0x28, 0xA6, 0x00,
+0x21, 0x18, 0x86, 0x00, 0xFF, 0xFF, 0xC6, 0x24, 0xFA, 0xFF, 0xC2, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x24, 0xFF, 0xFF, 0xA5, 0x24,
+0x00, 0x00, 0xA2, 0x90, 0xFF, 0xFF, 0x63, 0x24, 0xFF, 0xFF, 0xC6, 0x24,
+0xFB, 0xFF, 0xC7, 0x14, 0x00, 0x00, 0x62, 0xA0, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x80, 0x00, 0x0C, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0xA3, 0x90, 0x01, 0x00, 0x84, 0x24,
+0x23, 0x10, 0x43, 0x00, 0x00, 0x16, 0x02, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x04, 0x00, 0x40, 0x14, 0x01, 0x00, 0xA5, 0x24, 0xFF, 0xFF, 0xC6, 0x24,
+0xF6, 0xFF, 0xC0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0xC0, 0x00, 0x33, 0x55, 0x00, 0x08, 0x21, 0x18, 0x86, 0x00,
+0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x45, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x84, 0x24, 0xFA, 0xFF, 0x83, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x80, 0x00,
+0x09, 0x00, 0xC0, 0x10, 0xFF, 0xFF, 0xC3, 0x24, 0xFF, 0x00, 0xA5, 0x30,
+0xFF, 0xFF, 0x06, 0x24, 0x00, 0x00, 0x82, 0x90, 0xFF, 0xFF, 0x63, 0x24,
+0x05, 0x00, 0x45, 0x10, 0x01, 0x00, 0x84, 0x24, 0xFB, 0xFF, 0x66, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0xFF, 0xFF, 0x82, 0x24, 0x21, 0x38, 0x00, 0x00,
+0x1F, 0x00, 0xC0, 0x10, 0x21, 0x18, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x40, 0xF4, 0x4B, 0x24, 0x00, 0x00, 0x87, 0x90, 0x00, 0x00, 0xA3, 0x90,
+0xFF, 0xFF, 0xC6, 0x24, 0x01, 0x00, 0x84, 0x24, 0x21, 0x10, 0xEB, 0x00,
+0x16, 0x00, 0xE0, 0x10, 0x01, 0x00, 0xA5, 0x24, 0x14, 0x00, 0x60, 0x10,
+0x21, 0x48, 0x6B, 0x00, 0x10, 0x00, 0xE3, 0x10, 0x20, 0x00, 0xE8, 0x24,
+0x00, 0x00, 0x42, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x02, 0x00, 0x40, 0x10, 0x20, 0x00, 0x6A, 0x24, 0xFF, 0x00, 0x07, 0x31,
+0x00, 0x00, 0x22, 0x91, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x02, 0x00, 0x40, 0x10, 0xFF, 0x00, 0xE7, 0x30, 0xFF, 0x00, 0x43, 0x31,
+0xFF, 0x00, 0x63, 0x30, 0x03, 0x00, 0xE3, 0x14, 0x00, 0x00, 0x00, 0x00,
+0xE5, 0xFF, 0xC0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x23, 0x10, 0xE3, 0x00, 0x21, 0x18, 0x80, 0x00, 0x00, 0x00, 0xA2, 0x90,
+0x01, 0x00, 0xA5, 0x24, 0x00, 0x00, 0x82, 0xA0, 0xFC, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x84, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x21, 0x38, 0x80, 0x00, 0xFF, 0xFF, 0x03, 0x24, 0xFF, 0xFF, 0xC6, 0x24,
+0x06, 0x00, 0xC3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x90,
+0x01, 0x00, 0xA5, 0x24, 0x00, 0x00, 0x82, 0xA0, 0xF9, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x84, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xE0, 0x00,
+0x00, 0x00, 0x82, 0x80, 0x82, 0x55, 0x00, 0x08, 0x21, 0x18, 0x80, 0x00,
+0x01, 0x00, 0x84, 0x24, 0x00, 0x00, 0x82, 0x80, 0x00, 0x00, 0x00, 0x00,
+0xFC, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x90,
+0x01, 0x00, 0xA5, 0x24, 0x00, 0x00, 0x82, 0xA0, 0xFC, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x84, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x12, 0x00, 0xC0, 0x10, 0x21, 0x18, 0x80, 0x00, 0x00, 0x00, 0x82, 0x80,
+0x93, 0x55, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x84, 0x24,
+0x00, 0x00, 0x82, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x90, 0x01, 0x00, 0xA5, 0x24,
+0x00, 0x00, 0x82, 0xA0, 0x05, 0x00, 0x40, 0x10, 0x01, 0x00, 0x84, 0x24,
+0xFF, 0xFF, 0xC6, 0x24, 0xF9, 0xFF, 0xC0, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x80, 0xA0, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x00, 0x00, 0x83, 0x90, 0x00, 0x00, 0xA2, 0x90, 0x01, 0x00, 0x84, 0x24,
+0x23, 0x10, 0x62, 0x00, 0x00, 0x16, 0x02, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x03, 0x00, 0x40, 0x14, 0x01, 0x00, 0xA5, 0x24, 0xF7, 0xFF, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0x00, 0x00, 0x0B, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xA2, 0x90, 0x00, 0x00, 0x83, 0x90, 0xFF, 0xFF, 0xC6, 0x24,
+0x23, 0x10, 0x62, 0x00, 0x00, 0x16, 0x02, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x03, 0x00, 0x40, 0x14, 0x01, 0x00, 0xA5, 0x24, 0xF5, 0xFF, 0x60, 0x14,
+0x01, 0x00, 0x84, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x83, 0x80, 0x00, 0x2E, 0x05, 0x00, 0x21, 0x10, 0x80, 0x00,
+0xC4, 0x55, 0x00, 0x08, 0x03, 0x2E, 0x05, 0x00, 0x07, 0x00, 0x60, 0x10,
+0x01, 0x00, 0x42, 0x24, 0x00, 0x00, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00,
+0xFB, 0xFF, 0x65, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0x00, 0x00, 0x82, 0x80, 0xD0, 0x55, 0x00, 0x08, 0x21, 0x18, 0x80, 0x00,
+0x01, 0x00, 0x63, 0x24, 0x00, 0x00, 0x62, 0x80, 0x00, 0x00, 0x00, 0x00,
+0xFC, 0xFF, 0x40, 0x14, 0x23, 0x10, 0x64, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x21, 0x80, 0xA0, 0x00, 0x14, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xBF, 0xAF,
+0x21, 0x88, 0x80, 0x00, 0xCA, 0x55, 0x00, 0x0C, 0x00, 0x86, 0x10, 0x00,
+0x21, 0x18, 0x51, 0x00, 0x03, 0x86, 0x10, 0x00, 0x00, 0x00, 0x62, 0x80,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x50, 0x10, 0x21, 0x10, 0x60, 0x00,
+0xFF, 0xFF, 0x63, 0x24, 0x2B, 0x10, 0x71, 0x00, 0xF9, 0xFF, 0x40, 0x10,
+0x21, 0x10, 0x00, 0x00, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x21, 0x30, 0x80, 0x00,
+0x0D, 0x00, 0xA0, 0x10, 0xFF, 0xFF, 0xA3, 0x24, 0x00, 0x00, 0x82, 0x80,
+0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0xFF, 0x05, 0x24, 0xFF, 0xFF, 0x63, 0x24, 0x05, 0x00, 0x65, 0x10,
+0x01, 0x00, 0xC6, 0x24, 0x00, 0x00, 0xC2, 0x80, 0x00, 0x00, 0x00, 0x00,
+0xFA, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x23, 0x10, 0xC4, 0x00, 0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x19, 0x00, 0x40, 0x10, 0x21, 0x40, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x80,
+0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x20, 0x11, 0x21, 0x30, 0xA0, 0x00,
+0x00, 0x3E, 0x02, 0x00, 0x03, 0x3E, 0x07, 0x00, 0x21, 0x18, 0x20, 0x01,
+0x15, 0x00, 0xE3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xC6, 0x24,
+0x00, 0x00, 0xC2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x02, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0xF8, 0xFF, 0x60, 0x14, 0x00, 0x16, 0x02, 0x00,
+0x03, 0x16, 0x02, 0x00, 0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x84, 0x24, 0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xEB, 0xFF, 0x40, 0x14, 0x01, 0x00, 0x08, 0x25, 0x08, 0x00, 0xE0, 0x03,
+0x21, 0x10, 0x00, 0x01, 0x00, 0x00, 0xA2, 0x90, 0x15, 0x56, 0x00, 0x08,
+0x00, 0x16, 0x02, 0x00, 0x00, 0x00, 0xC2, 0x90, 0x15, 0x56, 0x00, 0x08,
+0x00, 0x16, 0x02, 0x00, 0x00, 0x00, 0x87, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x00, 0xE0, 0x10, 0x21, 0x10, 0x80, 0x00, 0x00, 0x00, 0xA4, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x04, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x09, 0x00, 0x60, 0x10, 0x21, 0x30, 0xA0, 0x00, 0x00, 0x3E, 0x07, 0x00,
+0x03, 0x3E, 0x07, 0x00, 0x0B, 0x00, 0xE3, 0x10, 0x01, 0x00, 0xC6, 0x24,
+0x00, 0x00, 0xC3, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFB, 0xFF, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0x00, 0x00, 0x47, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xE0, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x18, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x1D, 0x00, 0x80, 0x10,
+0x21, 0x88, 0xA0, 0x00, 0x01, 0x56, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02,
+0x21, 0x80, 0x02, 0x02, 0x00, 0x00, 0x02, 0x82, 0x21, 0x28, 0x20, 0x02,
+0x21, 0x20, 0x00, 0x02, 0x22, 0x00, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x25, 0x56, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x40, 0x10,
+0x21, 0x18, 0x40, 0x00, 0x00, 0x00, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x58, 0xF5, 0x43, 0xAC, 0x21, 0x18, 0x00, 0x02, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x60, 0xA0,
+0x56, 0x56, 0x00, 0x08, 0x01, 0x00, 0x63, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x58, 0xF5, 0x50, 0x8C, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xFF, 0x00, 0x12,
+0x21, 0x18, 0x00, 0x00, 0x01, 0x56, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x02,
+0x21, 0x80, 0x02, 0x02, 0x00, 0x00, 0x02, 0x82, 0x21, 0x28, 0x20, 0x02,
+0x21, 0x20, 0x00, 0x02, 0xE0, 0xFF, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00,
+0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x02, 0x80, 0x02, 0x3C, 0x58, 0xF5, 0x40, 0xAC, 0x20, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x90, 0x8C, 0x21, 0x90, 0x80, 0x00,
+0x21, 0x88, 0xA0, 0x00, 0x21, 0x18, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x12,
+0x21, 0x20, 0x00, 0x02, 0x01, 0x56, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x80, 0x02, 0x02, 0x00, 0x00, 0x02, 0x82, 0x21, 0x28, 0x20, 0x02,
+0x21, 0x20, 0x00, 0x02, 0x07, 0x00, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x25, 0x56, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x18, 0x40, 0x00,
+0x09, 0x00, 0x40, 0x14, 0x00, 0x00, 0x42, 0xAE, 0x21, 0x18, 0x00, 0x02,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00,
+0xF5, 0xFF, 0x40, 0x10, 0x01, 0x00, 0x64, 0x24, 0x00, 0x00, 0x60, 0xA0,
+0x8F, 0x56, 0x00, 0x08, 0x00, 0x00, 0x44, 0xAE, 0xD8, 0xFF, 0xBD, 0x27,
+0x14, 0x00, 0xB1, 0xAF, 0x21, 0x88, 0x80, 0x00, 0x21, 0x20, 0xA0, 0x00,
+0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x00, 0xB2, 0xAF, 0x20, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0xCA, 0x55, 0x00, 0x0C, 0x21, 0x98, 0xA0, 0x00,
+0x21, 0x90, 0x40, 0x00, 0x08, 0x00, 0x40, 0x16, 0x21, 0x10, 0x20, 0x02,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xCA, 0x55, 0x00, 0x0C, 0x21, 0x20, 0x20, 0x02,
+0x21, 0x80, 0x40, 0x00, 0x2A, 0x10, 0x52, 0x00, 0x0A, 0x00, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x20, 0x02, 0x21, 0x28, 0x60, 0x02,
+0x21, 0x30, 0x40, 0x02, 0x1D, 0x55, 0x00, 0x0C, 0xFF, 0xFF, 0x10, 0x26,
+0x0B, 0x00, 0x40, 0x10, 0x2A, 0x18, 0x12, 0x02, 0xF8, 0xFF, 0x60, 0x10,
+0x01, 0x00, 0x31, 0x26, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0xAB, 0x56, 0x00, 0x08, 0x21, 0x10, 0x20, 0x02, 0x00, 0x00, 0x87, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0xE0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xA6, 0x90, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0xC0, 0x10,
+0xDF, 0xFF, 0x02, 0x24, 0x24, 0x18, 0xC2, 0x00, 0x24, 0x10, 0xE2, 0x00,
+0x00, 0x16, 0x02, 0x00, 0x00, 0x1E, 0x03, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0x0A, 0x00, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00,
+0xDF, 0xFF, 0x02, 0x24, 0x24, 0x18, 0xC2, 0x00, 0x24, 0x10, 0xE2, 0x00,
+0x00, 0x16, 0x02, 0x00, 0x00, 0x1E, 0x03, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x03, 0x16, 0x02, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x23, 0x10, 0x43, 0x00,
+0xEE, 0x56, 0x00, 0x08, 0xDF, 0xFF, 0x08, 0x24, 0x00, 0x00, 0xA6, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x06, 0x01, 0x00, 0x16, 0x02, 0x00,
+0xF0, 0xFF, 0xC0, 0x10, 0x03, 0x16, 0x02, 0x00, 0xEF, 0xFF, 0x62, 0x14,
+0xDF, 0xFF, 0x02, 0x24, 0x01, 0x00, 0x84, 0x24, 0x00, 0x00, 0x87, 0x90,
+0x01, 0x00, 0xA5, 0x24, 0x24, 0x10, 0x07, 0x01, 0x00, 0x1E, 0x02, 0x00,
+0xF2, 0xFF, 0xE0, 0x14, 0x03, 0x1E, 0x03, 0x00, 0x00, 0x00, 0xA6, 0x90,
+0xDF, 0xFF, 0x02, 0x24, 0x24, 0x18, 0xC2, 0x00, 0x24, 0x10, 0xE2, 0x00,
+0x00, 0x16, 0x02, 0x00, 0x00, 0x1E, 0x03, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x03, 0x16, 0x02, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x23, 0x10, 0x43, 0x00,
+0xA8, 0xFF, 0xBD, 0x27, 0x44, 0x00, 0xB5, 0xAF, 0x40, 0x00, 0xB4, 0xAF,
+0x38, 0x00, 0xB2, 0xAF, 0x34, 0x00, 0xB1, 0xAF, 0x54, 0x00, 0xBF, 0xAF,
+0x50, 0x00, 0xBE, 0xAF, 0x4C, 0x00, 0xB7, 0xAF, 0x48, 0x00, 0xB6, 0xAF,
+0x3C, 0x00, 0xB3, 0xAF, 0x30, 0x00, 0xB0, 0xAF, 0x21, 0x90, 0xA0, 0x00,
+0x00, 0x00, 0xA5, 0x90, 0x21, 0xA0, 0x80, 0x00, 0x21, 0xA8, 0xC0, 0x00,
+0x00, 0x26, 0x05, 0x00, 0x03, 0x26, 0x04, 0x00, 0x11, 0x00, 0x80, 0x10,
+0x21, 0x88, 0x80, 0x02, 0x25, 0x00, 0x02, 0x24, 0x29, 0x00, 0x82, 0x10,
+0x0A, 0x00, 0x02, 0x24, 0x1B, 0x00, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x1E, 0x00, 0x80, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0xA2,
+0x01, 0x00, 0x31, 0x26, 0x01, 0x00, 0x52, 0x26, 0x00, 0x00, 0x45, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x05, 0x00, 0x03, 0x26, 0x04, 0x00,
+0xF2, 0xFF, 0x80, 0x14, 0x25, 0x00, 0x02, 0x24, 0x02, 0x00, 0x80, 0x12,
+0x23, 0x10, 0x34, 0x02, 0x00, 0x00, 0x20, 0xA2, 0x54, 0x00, 0xBF, 0x8F,
+0x50, 0x00, 0xBE, 0x8F, 0x4C, 0x00, 0xB7, 0x8F, 0x48, 0x00, 0xB6, 0x8F,
+0x44, 0x00, 0xB5, 0x8F, 0x40, 0x00, 0xB4, 0x8F, 0x3C, 0x00, 0xB3, 0x8F,
+0x38, 0x00, 0xB2, 0x8F, 0x34, 0x00, 0xB1, 0x8F, 0x30, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x58, 0x00, 0xBD, 0x27, 0xE7, 0xFF, 0x80, 0x16,
+0x00, 0x00, 0x00, 0x00, 0x57, 0x58, 0x00, 0x0C, 0x0D, 0x00, 0x04, 0x24,
+0x0A, 0x00, 0x04, 0x24, 0x57, 0x58, 0x00, 0x0C, 0x01, 0x00, 0x52, 0x26,
+0x00, 0x00, 0x45, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x05, 0x00,
+0x20, 0x57, 0x00, 0x08, 0x03, 0x26, 0x04, 0x00, 0x01, 0x00, 0x52, 0x26,
+0x00, 0x00, 0x45, 0x92, 0x73, 0x00, 0x02, 0x24, 0x00, 0x1E, 0x05, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0x2C, 0x00, 0x62, 0x10, 0x10, 0x00, 0xB3, 0x27,
+0x23, 0x00, 0x02, 0x24, 0x21, 0xF0, 0x60, 0x02, 0x21, 0x38, 0x00, 0x00,
+0x34, 0x00, 0x62, 0x10, 0x1C, 0x00, 0x04, 0x24, 0x00, 0x16, 0x05, 0x00,
+0x03, 0x16, 0x02, 0x00, 0x68, 0x00, 0x03, 0x24, 0x36, 0x00, 0x43, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x05, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x39, 0x00, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0xA2, 0x34,
+0x00, 0x16, 0x02, 0x00, 0x03, 0x16, 0x02, 0x00, 0x78, 0x00, 0x03, 0x24,
+0x3C, 0x00, 0x43, 0x10, 0x20, 0x00, 0xA6, 0x30, 0x00, 0x1E, 0x05, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0x64, 0x00, 0x02, 0x24, 0x49, 0x00, 0x62, 0x10,
+0x40, 0x00, 0x02, 0x24, 0x81, 0x00, 0x62, 0x10, 0x21, 0x00, 0x02, 0x24,
+0x92, 0x00, 0x62, 0x10, 0x63, 0x00, 0x02, 0x24, 0xA2, 0x00, 0x62, 0x10,
+0x11, 0x00, 0xB3, 0x27, 0x10, 0x00, 0xA5, 0xA3, 0x21, 0x80, 0xC0, 0x03,
+0x2B, 0x10, 0x13, 0x02, 0xB4, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x6C, 0x00, 0x80, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x92,
+0x01, 0x00, 0x10, 0x26, 0x00, 0x00, 0x22, 0xA2, 0x65, 0x57, 0x00, 0x08,
+0x01, 0x00, 0x31, 0x26, 0x00, 0x00, 0xA2, 0x8E, 0x04, 0x00, 0xB5, 0x26,
+0x21, 0x80, 0x40, 0x00, 0x00, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xA6, 0xFF, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x80, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xA2, 0x01, 0x00, 0x10, 0x26,
+0x72, 0x57, 0x00, 0x08, 0x01, 0x00, 0x31, 0x26, 0x01, 0x00, 0x52, 0x26,
+0x00, 0x00, 0x45, 0x92, 0x68, 0x00, 0x03, 0x24, 0x00, 0x16, 0x05, 0x00,
+0x03, 0x16, 0x02, 0x00, 0xCC, 0xFF, 0x43, 0x14, 0x01, 0x00, 0x07, 0x24,
+0x01, 0x00, 0x52, 0x26, 0x00, 0x00, 0x45, 0x92, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x16, 0x05, 0x00, 0x03, 0x16, 0x02, 0x00, 0xC9, 0xFF, 0x43, 0x14,
+0x0C, 0x00, 0x04, 0x24, 0x01, 0x00, 0x52, 0x26, 0x00, 0x00, 0x45, 0x92,
+0x78, 0x00, 0x03, 0x24, 0x20, 0x00, 0xA2, 0x34, 0x00, 0x16, 0x02, 0x00,
+0x03, 0x16, 0x02, 0x00, 0xC7, 0xFF, 0x43, 0x14, 0x04, 0x00, 0x04, 0x24,
+0x20, 0x00, 0xA6, 0x30, 0x00, 0x00, 0xA5, 0x8E, 0x35, 0x00, 0xE0, 0x14,
+0x04, 0x00, 0xB5, 0x26, 0xCD, 0xFF, 0x80, 0x04, 0x02, 0x80, 0x02, 0x3C,
+0x0C, 0xEF, 0x42, 0x24, 0x00, 0x00, 0x47, 0x8C, 0x07, 0x10, 0x85, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0x21, 0x10, 0x47, 0x00, 0x00, 0x00, 0x43, 0x90,
+0xFC, 0xFF, 0x84, 0x24, 0x25, 0x18, 0xC3, 0x00, 0x00, 0x00, 0x63, 0xA2,
+0xF8, 0xFF, 0x81, 0x04, 0x01, 0x00, 0x73, 0x26, 0x65, 0x57, 0x00, 0x08,
+0x21, 0x80, 0xC0, 0x03, 0x00, 0x00, 0xA2, 0x8E, 0x04, 0x00, 0xB5, 0x26,
+0x28, 0x00, 0x40, 0x04, 0x21, 0x28, 0x40, 0x00, 0x21, 0x80, 0x60, 0x02,
+0x02, 0x80, 0x02, 0x3C, 0x10, 0xEF, 0x42, 0x24, 0x00, 0x00, 0x46, 0x8C,
+0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xA6, 0x00, 0xC3, 0x27, 0x05, 0x00,
+0x10, 0x10, 0x00, 0x00, 0x83, 0x10, 0x02, 0x00, 0x23, 0x10, 0x44, 0x00,
+0x80, 0x18, 0x02, 0x00, 0x21, 0x18, 0x62, 0x00, 0x40, 0x18, 0x03, 0x00,
+0x23, 0x18, 0xA3, 0x00, 0x30, 0x00, 0x63, 0x24, 0x00, 0x00, 0x63, 0xA2,
+0x21, 0x28, 0x40, 0x00, 0xF3, 0xFF, 0x40, 0x14, 0x01, 0x00, 0x73, 0x26,
+0xC5, 0x57, 0x00, 0x08, 0xFF, 0xFF, 0x63, 0x26, 0x00, 0x00, 0x65, 0x80,
+0x00, 0x00, 0x02, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xA0,
+0x00, 0x00, 0x05, 0xA2, 0xFF, 0xFF, 0x63, 0x24, 0x01, 0x00, 0x10, 0x26,
+0x2B, 0x10, 0x03, 0x02, 0xF7, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x65, 0x57, 0x00, 0x08, 0x21, 0x80, 0xC0, 0x03, 0x58, 0x00, 0xC3, 0x34,
+0x30, 0x00, 0x02, 0x24, 0x12, 0x00, 0xB3, 0x27, 0x10, 0x00, 0xA2, 0xA3,
+0x96, 0x57, 0x00, 0x08, 0x11, 0x00, 0xA3, 0xA3, 0x2D, 0x00, 0x02, 0x24,
+0x23, 0x28, 0x05, 0x00, 0x11, 0x00, 0xB3, 0x27, 0xA9, 0x57, 0x00, 0x08,
+0x10, 0x00, 0xA2, 0xA3, 0x00, 0x00, 0x04, 0x82, 0x57, 0x58, 0x00, 0x0C,
+0x01, 0x00, 0x10, 0x26, 0x66, 0x57, 0x00, 0x08, 0x2B, 0x10, 0x13, 0x02,
+0x00, 0x00, 0x04, 0x82, 0x57, 0x58, 0x00, 0x0C, 0x01, 0x00, 0x10, 0x26,
+0x72, 0x57, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x8E,
+0x28, 0x00, 0xB0, 0x27, 0x2C, 0x00, 0xA4, 0x27, 0x2B, 0x10, 0x04, 0x02,
+0x28, 0x00, 0xA3, 0xAF, 0x0B, 0x00, 0x40, 0x10, 0x04, 0x00, 0xB5, 0x26,
+0x21, 0xB8, 0x80, 0x00, 0x02, 0x80, 0x16, 0x3C, 0x00, 0x00, 0x06, 0x92,
+0x21, 0x20, 0x60, 0x02, 0x01, 0x00, 0x10, 0x26, 0x08, 0x58, 0x00, 0x0C,
+0x00, 0xEF, 0xC5, 0x26, 0x2B, 0x18, 0x17, 0x02, 0xF9, 0xFF, 0x60, 0x14,
+0x21, 0x98, 0x62, 0x02, 0x64, 0x57, 0x00, 0x08, 0xFF, 0xFF, 0x73, 0x26,
+0x00, 0x00, 0xA2, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x56, 0x24,
+0x21, 0x80, 0x40, 0x00, 0x2B, 0x10, 0x56, 0x00, 0xF8, 0xFF, 0x40, 0x10,
+0x04, 0x00, 0xB5, 0x26, 0x02, 0x80, 0x17, 0x3C, 0x00, 0x00, 0x06, 0x82,
+0x21, 0x20, 0x60, 0x02, 0x01, 0x00, 0x10, 0x26, 0x08, 0x58, 0x00, 0x0C,
+0x04, 0xEF, 0xE5, 0x26, 0x2B, 0x18, 0x16, 0x02, 0xF9, 0xFF, 0x60, 0x14,
+0x21, 0x98, 0x62, 0x02, 0x64, 0x57, 0x00, 0x08, 0xFF, 0xFF, 0x73, 0x26,
+0x00, 0x00, 0xA2, 0x8E, 0x04, 0x00, 0xB5, 0x26, 0x64, 0x57, 0x00, 0x08,
+0x10, 0x00, 0xA2, 0xA3, 0xE8, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xA6, 0xAF,
+0x20, 0x00, 0xA6, 0x27, 0x10, 0x00, 0xBF, 0xAF, 0x24, 0x00, 0xA7, 0xAF,
+0xFF, 0x56, 0x00, 0x0C, 0x1C, 0x00, 0xA5, 0xAF, 0x10, 0x00, 0xBF, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xA4, 0xAF, 0x10, 0x00, 0xA4, 0x27,
+0x1C, 0x00, 0xBF, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xA5, 0xAF,
+0x28, 0x00, 0xA6, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x2C, 0x00, 0xA7, 0xAF,
+0x53, 0x21, 0x00, 0x0C, 0xA0, 0x00, 0x04, 0x24, 0x1F, 0x00, 0x40, 0x10,
+0x21, 0x80, 0x40, 0x00, 0x08, 0x00, 0x44, 0x94, 0x20, 0x00, 0xA5, 0x8F,
+0x02, 0x80, 0x02, 0x3C, 0x25, 0x20, 0x82, 0x00, 0x20, 0x00, 0x84, 0x24,
+0xFF, 0x56, 0x00, 0x0C, 0x24, 0x00, 0xA6, 0x27, 0x01, 0x00, 0x42, 0x24,
+0x13, 0x00, 0x03, 0x24, 0x81, 0x00, 0x44, 0x2C, 0x14, 0x00, 0x03, 0xAE,
+0x0A, 0x00, 0x80, 0x14, 0x0C, 0x00, 0x02, 0xAE, 0x9B, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x88, 0x88, 0x63, 0x34, 0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x34, 0x58, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x17, 0x0A, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x02, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x99, 0x99, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C, 0x99, 0x99, 0x63, 0x34,
+0x18, 0x03, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC, 0x3A, 0x58, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x02, 0x80, 0x06, 0x3C, 0x5C, 0xF5, 0xC5, 0x8C, 0x02, 0x80, 0x02, 0x3C,
+0x40, 0xF5, 0x42, 0x24, 0x03, 0x00, 0xA3, 0x30, 0x21, 0x18, 0x62, 0x00,
+0x00, 0x00, 0x64, 0x80, 0x01, 0x00, 0xA5, 0x24, 0x57, 0x58, 0x00, 0x0C,
+0x5C, 0xF5, 0xC5, 0xAC, 0x10, 0x00, 0xBF, 0x8F, 0x08, 0x00, 0x04, 0x24,
+0x57, 0x58, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0x00, 0x26, 0x04, 0x00,
+0x03, 0x26, 0x04, 0x00, 0x00, 0x00, 0x84, 0x48, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x04, 0x00, 0x03, 0x26, 0x04, 0x00,
+0xF7, 0xFF, 0x82, 0x24, 0x05, 0x00, 0x42, 0x2C, 0x06, 0x00, 0x40, 0x14,
+0x21, 0x18, 0x00, 0x00, 0x20, 0x00, 0x02, 0x24, 0x03, 0x00, 0x82, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x01, 0x00, 0x03, 0x24, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x60, 0x00,
+0x00, 0x00, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x26, 0x10, 0x44, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x42, 0x2C, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xBF, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x10, 0x00, 0xA4, 0x27,
+0x02, 0x80, 0x02, 0x3C, 0xCC, 0x5D, 0x50, 0xAC, 0x90, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0x25, 0xB0, 0x05, 0x3C,
+0x01, 0x00, 0x06, 0x24, 0x01, 0x80, 0x02, 0x3C, 0x04, 0x30, 0x86, 0x00,
+0xF1, 0x02, 0xA7, 0x34, 0xED, 0x02, 0xA4, 0x34, 0xF8, 0x61, 0x42, 0x24,
+0x18, 0x03, 0xA5, 0x34, 0x08, 0x00, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xAC,
+0x00, 0x00, 0xE3, 0xA0, 0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0x86, 0xA0,
+0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0x86, 0xA0, 0x00, 0x00, 0x80, 0xA0,
+0x00, 0x00, 0x86, 0xA0, 0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0x86, 0xA0,
+0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0xE0, 0xA0, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF,
+0xFF, 0xFF, 0x90, 0x30, 0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C,
+0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x63, 0x24,
+0x6A, 0x37, 0x62, 0x94, 0x10, 0x00, 0xA4, 0x27, 0x25, 0x80, 0x02, 0x02,
+0x25, 0xB0, 0x02, 0x3C, 0x1E, 0x03, 0x42, 0x34, 0x00, 0x00, 0x50, 0xA4,
+0x90, 0x40, 0x00, 0x0C, 0x6A, 0x37, 0x70, 0xA4, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF, 0xFF, 0xFF, 0x90, 0x30,
+0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24, 0x6A, 0x37, 0xA2, 0x94,
+0x78, 0x37, 0xA3, 0x94, 0x27, 0x80, 0x10, 0x00, 0x10, 0x00, 0xA4, 0x27,
+0x24, 0x18, 0x03, 0x02, 0x24, 0x80, 0x02, 0x02, 0x25, 0xB0, 0x02, 0x3C,
+0x1E, 0x03, 0x42, 0x34, 0x78, 0x37, 0xA3, 0xA4, 0x00, 0x00, 0x50, 0xA4,
+0x90, 0x40, 0x00, 0x0C, 0x6A, 0x37, 0xB0, 0xA4, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xC8, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x03, 0x3C, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x34, 0x00, 0xBF, 0xAF, 0x30, 0x00, 0xBE, 0xAF, 0x2C, 0x00, 0xB7, 0xAF,
+0x28, 0x00, 0xB6, 0xAF, 0x24, 0x00, 0xB5, 0xAF, 0x20, 0x00, 0xB4, 0xAF,
+0x0A, 0x00, 0x67, 0x34, 0x00, 0x00, 0xE2, 0x90, 0xFF, 0xFF, 0xB2, 0x30,
+0x21, 0x98, 0xC0, 0x00, 0xFF, 0x00, 0x91, 0x30, 0x20, 0x00, 0x40, 0x12,
+0xFF, 0x00, 0x50, 0x30, 0x21, 0xA0, 0xE0, 0x00, 0x0C, 0x00, 0x77, 0x34,
+0x0B, 0x00, 0x76, 0x34, 0x21, 0xF0, 0xE0, 0x00, 0xC0, 0xFF, 0x15, 0x24,
+0x25, 0x10, 0x15, 0x02, 0xFF, 0x00, 0x50, 0x30, 0x00, 0x00, 0xD1, 0xA2,
+0x00, 0x00, 0x90, 0xA2, 0x00, 0x00, 0x82, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x50, 0x30, 0xC0, 0x00, 0x03, 0x32, 0x07, 0x00, 0x60, 0x10,
+0x21, 0x20, 0xC0, 0x03, 0x00, 0x00, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0x50, 0x30, 0xC0, 0x00, 0x03, 0x32, 0xFB, 0xFF, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x8E, 0x04, 0x00, 0x23, 0x26,
+0x64, 0x00, 0x04, 0x24, 0x00, 0x00, 0x62, 0xAE, 0x2C, 0x1F, 0x00, 0x0C,
+0xFF, 0x00, 0x71, 0x30, 0xFC, 0xFF, 0x42, 0x26, 0xFF, 0xFF, 0x52, 0x30,
+0xE7, 0xFF, 0x40, 0x16, 0x04, 0x00, 0x73, 0x26, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xBE, 0x8F, 0x2C, 0x00, 0xB7, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x38, 0x00, 0xBD, 0x27, 0x25, 0xB0, 0x06, 0x3C,
+0x31, 0x00, 0xC2, 0x34, 0xFF, 0xFF, 0x84, 0x30, 0x00, 0x00, 0x44, 0xA0,
+0x32, 0x00, 0xC7, 0x34, 0x00, 0x00, 0xE3, 0x90, 0xFC, 0xFF, 0x02, 0x24,
+0x02, 0x22, 0x04, 0x00, 0x24, 0x18, 0x62, 0x00, 0x03, 0x00, 0x84, 0x30,
+0x25, 0x20, 0x83, 0x00, 0x33, 0x00, 0xC6, 0x34, 0x72, 0x00, 0x02, 0x24,
+0x00, 0x00, 0xE4, 0xA0, 0x00, 0x00, 0xC2, 0xA0, 0x00, 0x00, 0xC3, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x03, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x05, 0x00, 0x61, 0x04, 0x21, 0x10, 0x00, 0x00, 0x23, 0x59, 0x00, 0x08,
+0x25, 0xB0, 0x02, 0x3C, 0x11, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC3, 0x90, 0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x00, 0x1E, 0x03, 0x00, 0x03, 0x1E, 0x03, 0x00, 0xF8, 0xFF, 0x61, 0x04,
+0x64, 0x00, 0x44, 0x2C, 0x64, 0x00, 0x44, 0x2C, 0x07, 0x00, 0x80, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x30, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x43, 0x90, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0xA3, 0xA0, 0xFF, 0xFF, 0x02, 0x24, 0x00, 0x00, 0xA2, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x25, 0xB0, 0x06, 0x3C,
+0x31, 0x00, 0xC2, 0x34, 0xFF, 0xFF, 0x84, 0x30, 0x00, 0x00, 0x44, 0xA0,
+0x32, 0x00, 0xC3, 0x34, 0x00, 0x00, 0x62, 0x90, 0x02, 0x22, 0x04, 0x00,
+0x03, 0x00, 0x84, 0x30, 0x25, 0x20, 0x82, 0x00, 0x00, 0x00, 0x64, 0xA0,
+0x33, 0x00, 0xC7, 0x34, 0xFF, 0x00, 0xA5, 0x30, 0x30, 0x00, 0xC6, 0x34,
+0xF2, 0xFF, 0x03, 0x24, 0x00, 0x00, 0xC5, 0xA0, 0x00, 0x00, 0xE3, 0xA0,
+0x00, 0x00, 0xE2, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x02, 0x00,
+0x03, 0x16, 0x02, 0x00, 0x03, 0x00, 0x40, 0x04, 0x21, 0x20, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x01, 0x00, 0x02, 0x24, 0x48, 0x59, 0x00, 0x08,
+0x21, 0x30, 0xE0, 0x00, 0x0B, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC3, 0x90, 0x01, 0x00, 0x82, 0x24, 0xFF, 0x00, 0x44, 0x30,
+0x00, 0x1E, 0x03, 0x00, 0x03, 0x1E, 0x03, 0x00, 0xF8, 0xFF, 0x60, 0x04,
+0x64, 0x00, 0x82, 0x2C, 0x64, 0x00, 0x82, 0x2C, 0xF1, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x25, 0xB0, 0x02, 0x3C, 0x18, 0x00, 0xB0, 0xAF,
+0xF8, 0x02, 0x45, 0x34, 0x25, 0xB0, 0x10, 0x3C, 0xFF, 0x00, 0x83, 0x30,
+0x01, 0x00, 0x02, 0x24, 0x1C, 0x00, 0xBF, 0xAF, 0x03, 0x00, 0x06, 0x36,
+0x0A, 0x00, 0x62, 0x10, 0x0A, 0x00, 0x04, 0x24, 0x00, 0x00, 0xA2, 0x90,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0xFE, 0xFF, 0x03, 0x24,
+0x24, 0x10, 0x43, 0x00, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0xA2, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x42, 0x30, 0x20, 0x00, 0x43, 0x34,
+0x20, 0x00, 0x42, 0x30, 0x02, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC3, 0xA0, 0x2C, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x04, 0x36, 0x00, 0x00, 0x82, 0x90, 0xFE, 0xFF, 0x03, 0x24,
+0xF8, 0x02, 0x06, 0x36, 0x24, 0x10, 0x43, 0x00, 0x00, 0x00, 0x82, 0xA0,
+0x00, 0x00, 0xC3, 0x90, 0x10, 0x00, 0xA5, 0x27, 0x21, 0x20, 0x00, 0x00,
+0x03, 0x00, 0x63, 0x34, 0x00, 0x00, 0xC3, 0xA0, 0xFF, 0x58, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xFF, 0x00, 0x84, 0x30,
+0x21, 0x38, 0x00, 0x00, 0x21, 0x28, 0x00, 0x00, 0x01, 0x00, 0xA3, 0x24,
+0x07, 0x10, 0xA4, 0x00, 0x01, 0x00, 0x42, 0x30, 0xFF, 0x00, 0x65, 0x30,
+0x01, 0x00, 0xE6, 0x24, 0x02, 0x00, 0x40, 0x14, 0x04, 0x00, 0xA3, 0x2C,
+0xFF, 0x00, 0xC7, 0x30, 0xF7, 0xFF, 0x60, 0x14, 0x21, 0x10, 0xE0, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x8C, 0x30,
+0x21, 0x48, 0x00, 0x00, 0x21, 0x38, 0x00, 0x00, 0x40, 0x10, 0x07, 0x00,
+0xFF, 0x00, 0x42, 0x30, 0x21, 0x50, 0x46, 0x00, 0x01, 0x00, 0xE3, 0x24,
+0x07, 0x10, 0xEC, 0x00, 0x01, 0x00, 0x42, 0x30, 0xFF, 0x00, 0x67, 0x30,
+0x21, 0x58, 0x25, 0x01, 0x01, 0x00, 0x24, 0x25, 0x09, 0x00, 0x40, 0x14,
+0x04, 0x00, 0xE8, 0x2C, 0x00, 0x00, 0x63, 0x91, 0xFF, 0x00, 0x89, 0x30,
+0x21, 0x20, 0x25, 0x01, 0x00, 0x00, 0x43, 0xA1, 0x00, 0x00, 0x83, 0x90,
+0x01, 0x00, 0x22, 0x25, 0xFF, 0x00, 0x49, 0x30, 0x01, 0x00, 0x43, 0xA1,
+0xED, 0xFF, 0x00, 0x15, 0x40, 0x10, 0x07, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xD8, 0xFF, 0xBD, 0x27, 0x20, 0x00, 0xB2, 0xAF,
+0x1C, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xBF, 0xAF,
+0x01, 0x00, 0x12, 0x24, 0x21, 0x80, 0x00, 0x00, 0xC5, 0x59, 0x00, 0x08,
+0xFF, 0x00, 0x11, 0x24, 0xFF, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x00, 0x40, 0x10, 0x00, 0x02, 0x03, 0x2E, 0x0F, 0x00, 0x60, 0x10,
+0x21, 0x10, 0x00, 0x02, 0x10, 0x00, 0xA2, 0x93, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x51, 0x10, 0x0F, 0x00, 0x44, 0x30, 0x83, 0x59, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x02, 0x00, 0x21, 0x10, 0x50, 0x00,
+0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x50, 0x30, 0x21, 0x20, 0x00, 0x02,
+0xEE, 0xFF, 0x40, 0x16, 0x10, 0x00, 0xA5, 0x27, 0x21, 0x10, 0x00, 0x02,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0xB8, 0xFF, 0xBD, 0x27, 0x3C, 0x00, 0xB7, 0xAF, 0x38, 0x00, 0xB6, 0xAF,
+0x34, 0x00, 0xB5, 0xAF, 0x30, 0x00, 0xB4, 0xAF, 0x2C, 0x00, 0xB3, 0xAF,
+0x24, 0x00, 0xB1, 0xAF, 0x20, 0x00, 0xB0, 0xAF, 0x44, 0x00, 0xBF, 0xAF,
+0x40, 0x00, 0xBE, 0xAF, 0x28, 0x00, 0xB2, 0xAF, 0x21, 0x98, 0xA0, 0x00,
+0xFF, 0x00, 0x96, 0x30, 0x01, 0x00, 0x10, 0x24, 0x01, 0x00, 0x17, 0x24,
+0x21, 0xA0, 0x00, 0x00, 0x21, 0x88, 0x00, 0x00, 0x21, 0xA8, 0x00, 0x00,
+0x04, 0x00, 0xA0, 0x10, 0x21, 0x18, 0x00, 0x00, 0x10, 0x00, 0xC2, 0x2E,
+0x0E, 0x00, 0x40, 0x14, 0x21, 0x20, 0xA0, 0x00, 0x44, 0x00, 0xBF, 0x8F,
+0x40, 0x00, 0xBE, 0x8F, 0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F,
+0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F,
+0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F,
+0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0x06, 0x24, 0xE3, 0x54, 0x00, 0x0C, 0xFF, 0x00, 0x05, 0x24,
+0x18, 0x00, 0xA4, 0x27, 0xFF, 0x00, 0x05, 0x24, 0xE3, 0x54, 0x00, 0x0C,
+0x08, 0x00, 0x06, 0x24, 0x54, 0x59, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x04, 0x5A, 0x00, 0x08, 0x10, 0x00, 0xBE, 0x27, 0x1C, 0x00, 0x40, 0x14,
+0x21, 0x20, 0xA0, 0x02, 0x37, 0x00, 0xE0, 0x12, 0x00, 0x02, 0x22, 0x2E,
+0x35, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x32,
+0xF8, 0xFF, 0x40, 0x10, 0x20, 0x00, 0x02, 0x32, 0x21, 0x20, 0x20, 0x02,
+0xFF, 0x58, 0x00, 0x0C, 0x10, 0x00, 0xA5, 0x27, 0x2D, 0x00, 0x40, 0x10,
+0xFF, 0x00, 0x02, 0x24, 0x10, 0x00, 0xB0, 0x93, 0x00, 0x00, 0x00, 0x00,
+0x29, 0x00, 0x02, 0x12, 0x0F, 0x00, 0x15, 0x32, 0x83, 0x59, 0x00, 0x0C,
+0x21, 0x20, 0xA0, 0x02, 0x02, 0x81, 0x10, 0x00, 0x10, 0x00, 0x16, 0x12,
+0x21, 0xA0, 0x40, 0x00, 0x40, 0x10, 0x14, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x51, 0x30, 0x00, 0x5A, 0x00, 0x08,
+0x01, 0x00, 0x10, 0x24, 0x18, 0x00, 0xA5, 0x27, 0x92, 0x59, 0x00, 0x0C,
+0x21, 0x30, 0x60, 0x02, 0x40, 0x10, 0x14, 0x00, 0x21, 0x10, 0x51, 0x00,
+0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x51, 0x30, 0x00, 0x5A, 0x00, 0x08,
+0x01, 0x00, 0x10, 0x24, 0x40, 0x90, 0x02, 0x00, 0x10, 0x00, 0x40, 0x1A,
+0x21, 0x80, 0x00, 0x00, 0x21, 0x20, 0x30, 0x02, 0x01, 0x00, 0x84, 0x24,
+0xFF, 0xFF, 0x84, 0x30, 0xFF, 0x58, 0x00, 0x0C, 0x10, 0x00, 0xA5, 0x27,
+0x01, 0x00, 0x03, 0x26, 0x21, 0x20, 0xD0, 0x03, 0xFF, 0x00, 0x70, 0x30,
+0x04, 0x00, 0x40, 0x10, 0x2A, 0x18, 0x12, 0x02, 0x10, 0x00, 0xA2, 0x93,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x82, 0xA0, 0xF3, 0xFF, 0x60, 0x14,
+0x21, 0x20, 0x30, 0x02, 0x00, 0x5A, 0x00, 0x08, 0x20, 0x00, 0x10, 0x24,
+0x54, 0x59, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0x00, 0x00, 0x63, 0x92,
+0xFF, 0x00, 0x02, 0x24, 0x0F, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x03, 0x24, 0x44, 0x00, 0xBF, 0x8F, 0x40, 0x00, 0xBE, 0x8F,
+0x3C, 0x00, 0xB7, 0x8F, 0x38, 0x00, 0xB6, 0x8F, 0x34, 0x00, 0xB5, 0x8F,
+0x30, 0x00, 0xB4, 0x8F, 0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F,
+0x24, 0x00, 0xB1, 0x8F, 0x20, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x48, 0x00, 0xBD, 0x27, 0x01, 0x00, 0x62, 0x92,
+0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x43, 0x14, 0x01, 0x00, 0x03, 0x24,
+0x02, 0x00, 0x63, 0x92, 0x00, 0x00, 0x00, 0x00, 0xEB, 0xFF, 0x62, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x62, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xE8, 0xFF, 0x43, 0x14, 0x01, 0x00, 0x03, 0x24, 0x04, 0x00, 0x63, 0x92,
+0x00, 0x00, 0x00, 0x00, 0xE3, 0xFF, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x05, 0x00, 0x62, 0x92, 0x00, 0x00, 0x00, 0x00, 0xDF, 0xFF, 0x43, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x67, 0x92, 0x00, 0x00, 0x00, 0x00,
+0xDC, 0xFF, 0xE2, 0x14, 0x01, 0x00, 0x03, 0x24, 0x07, 0x00, 0x62, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x47, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x3F, 0x5A, 0x00, 0x08, 0x01, 0x00, 0x03, 0x24, 0xC0, 0xFF, 0xBD, 0x27,
+0x38, 0x00, 0xBE, 0xAF, 0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF,
+0x21, 0xF0, 0xC0, 0x00, 0xFF, 0x00, 0xB6, 0x30, 0xFF, 0xFF, 0x95, 0x30,
+0xFF, 0x00, 0x05, 0x24, 0x10, 0x00, 0xA4, 0x27, 0x08, 0x00, 0x06, 0x24,
+0x34, 0x00, 0xB7, 0xAF, 0x24, 0x00, 0xB3, 0xAF, 0x3C, 0x00, 0xBF, 0xAF,
+0x28, 0x00, 0xB4, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0xE3, 0x54, 0x00, 0x0C, 0x0F, 0x00, 0x17, 0x24,
+0x21, 0x98, 0x00, 0x00, 0x40, 0x10, 0x13, 0x00, 0xFF, 0x00, 0x52, 0x30,
+0x07, 0x10, 0x76, 0x02, 0x01, 0x00, 0x42, 0x30, 0x21, 0xA0, 0x5E, 0x02,
+0x21, 0x88, 0xA0, 0x02, 0x21, 0x20, 0xA0, 0x02, 0x13, 0x00, 0x40, 0x10,
+0x01, 0x00, 0xA3, 0x26, 0x01, 0x00, 0x62, 0x26, 0xFF, 0x00, 0x53, 0x30,
+0x04, 0x00, 0x63, 0x2E, 0xF4, 0xFF, 0x60, 0x14, 0x40, 0x10, 0x13, 0x00,
+0x21, 0x10, 0xE0, 0x02, 0x3C, 0x00, 0xBF, 0x8F, 0x38, 0x00, 0xBE, 0x8F,
+0x34, 0x00, 0xB7, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x40, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x85, 0x92, 0xFF, 0xFF, 0x75, 0x30,
+0x2C, 0x59, 0x00, 0x0C, 0x21, 0x80, 0xA0, 0x02, 0x01, 0x00, 0x85, 0x92,
+0x21, 0x20, 0xA0, 0x02, 0x01, 0x00, 0xA2, 0x26, 0x2C, 0x59, 0x00, 0x0C,
+0xFF, 0xFF, 0x55, 0x30, 0x10, 0x00, 0xA3, 0x27, 0x21, 0x90, 0x72, 0x00,
+0x21, 0x20, 0x20, 0x02, 0xFF, 0x58, 0x00, 0x0C, 0x21, 0x28, 0x40, 0x02,
+0x21, 0x20, 0x00, 0x02, 0xFF, 0x58, 0x00, 0x0C, 0x01, 0x00, 0x45, 0x26,
+0x00, 0x00, 0x84, 0x92, 0x00, 0x00, 0x42, 0x92, 0x01, 0x00, 0x03, 0x24,
+0x04, 0x18, 0x63, 0x02, 0x03, 0x00, 0x82, 0x10, 0x27, 0x30, 0x03, 0x00,
+0x87, 0x5A, 0x00, 0x08, 0x24, 0xB8, 0xD7, 0x00, 0x01, 0x00, 0x83, 0x92,
+0x01, 0x00, 0x42, 0x92, 0x00, 0x00, 0x00, 0x00, 0xD2, 0xFF, 0x62, 0x10,
+0x01, 0x00, 0x62, 0x26, 0x88, 0x5A, 0x00, 0x08, 0x24, 0xB8, 0xD7, 0x00,
+0x98, 0xFF, 0xBD, 0x27, 0x50, 0x00, 0xB4, 0xAF, 0xFF, 0x00, 0x94, 0x30,
+0x01, 0x00, 0x04, 0x24, 0x64, 0x00, 0xBF, 0xAF, 0x60, 0x00, 0xBE, 0xAF,
+0x5C, 0x00, 0xB7, 0xAF, 0x58, 0x00, 0xB6, 0xAF, 0x4C, 0x00, 0xB3, 0xAF,
+0x48, 0x00, 0xB2, 0xAF, 0x44, 0x00, 0xB1, 0xAF, 0x21, 0x98, 0xC0, 0x00,
+0xFF, 0x00, 0xB1, 0x30, 0x54, 0x00, 0xB5, 0xAF, 0x54, 0x59, 0x00, 0x0C,
+0x40, 0x00, 0xB0, 0xAF, 0xAC, 0x59, 0x00, 0x0C, 0x01, 0x00, 0x16, 0x24,
+0x21, 0x18, 0x40, 0x00, 0xFF, 0x01, 0x42, 0x2C, 0x01, 0x00, 0x17, 0x24,
+0x01, 0x00, 0x1E, 0x24, 0x21, 0x90, 0x00, 0x00, 0x0E, 0x00, 0x40, 0x14,
+0x21, 0x20, 0x00, 0x00, 0x64, 0x00, 0xBF, 0x8F, 0x60, 0x00, 0xBE, 0x8F,
+0x5C, 0x00, 0xB7, 0x8F, 0x58, 0x00, 0xB6, 0x8F, 0x54, 0x00, 0xB5, 0x8F,
+0x50, 0x00, 0xB4, 0x8F, 0x4C, 0x00, 0xB3, 0x8F, 0x48, 0x00, 0xB2, 0x8F,
+0x44, 0x00, 0xB1, 0x8F, 0x40, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x80, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x68, 0x00, 0xBD, 0x27, 0xFF, 0x01, 0x02, 0x24,
+0x23, 0x10, 0x43, 0x00, 0x1A, 0x00, 0xA4, 0x27, 0xFF, 0x00, 0x05, 0x24,
+0x08, 0x00, 0x06, 0x24, 0xFF, 0xFF, 0x50, 0x30, 0x18, 0x00, 0xB4, 0xA3,
+0xE3, 0x54, 0x00, 0x0C, 0x19, 0x00, 0xB1, 0xA3, 0x21, 0x20, 0x20, 0x02,
+0x21, 0x28, 0x60, 0x02, 0x92, 0x59, 0x00, 0x0C, 0x1A, 0x00, 0xA6, 0x27,
+0x19, 0x00, 0xA4, 0x93, 0x83, 0x59, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x21, 0xA8, 0x40, 0x00, 0xFF, 0xFF, 0x42, 0x30, 0x2B, 0x10, 0x02, 0x02,
+0xDF, 0xFF, 0x40, 0x14, 0x21, 0x20, 0x00, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x09, 0x00, 0xC2, 0x12, 0x20, 0x00, 0x02, 0x24, 0x22, 0x00, 0xC2, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x3B, 0x00, 0xE0, 0x12, 0x00, 0x02, 0x42, 0x2E,
+0x39, 0x00, 0x40, 0x10, 0x01, 0x00, 0x02, 0x24, 0xF9, 0xFF, 0xC2, 0x16,
+0x20, 0x00, 0x02, 0x24, 0x21, 0x20, 0x40, 0x02, 0x10, 0x00, 0xA5, 0x27,
+0xFF, 0x58, 0x00, 0x0C, 0x01, 0x00, 0x13, 0x24, 0x41, 0x00, 0x40, 0x10,
+0xFF, 0x00, 0x02, 0x24, 0x10, 0x00, 0xA5, 0x93, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0xA4, 0x30, 0x3C, 0x00, 0x82, 0x10, 0x0F, 0x00, 0xA3, 0x30,
+0x02, 0x11, 0x04, 0x00, 0x21, 0x20, 0x60, 0x00, 0x29, 0x00, 0xA3, 0xA3,
+0x28, 0x00, 0xA2, 0xA3, 0x83, 0x59, 0x00, 0x0C, 0x11, 0x00, 0xA5, 0xA3,
+0x21, 0x80, 0x40, 0x00, 0x28, 0x00, 0xA3, 0x93, 0x18, 0x00, 0xA2, 0x93,
+0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x62, 0x10, 0x40, 0x10, 0x10, 0x00,
+0x21, 0x10, 0x52, 0x00, 0x01, 0x00, 0x42, 0x24, 0xF9, 0x5A, 0x00, 0x08,
+0xFF, 0xFF, 0x52, 0x30, 0x19, 0x00, 0xA5, 0x93, 0x01, 0x00, 0x44, 0x26,
+0xFF, 0xFF, 0x84, 0x30, 0x6A, 0x5A, 0x00, 0x0C, 0x1A, 0x00, 0xA6, 0x27,
+0x21, 0x28, 0x40, 0x00, 0x0F, 0x00, 0x43, 0x30, 0x0F, 0x00, 0x02, 0x24,
+0x12, 0x00, 0x62, 0x10, 0x40, 0x10, 0x15, 0x00, 0x21, 0x10, 0x52, 0x00,
+0x01, 0x00, 0x42, 0x24, 0x21, 0x20, 0xA0, 0x00, 0xFF, 0xFF, 0x52, 0x30,
+0x18, 0x00, 0xB4, 0xA3, 0x83, 0x59, 0x00, 0x0C, 0x19, 0x00, 0xA5, 0xA3,
+0x21, 0xA8, 0x40, 0x00, 0x02, 0x80, 0x03, 0x3C, 0xCC, 0xDF, 0x62, 0x8C,
+0x02, 0x80, 0x04, 0x3C, 0x01, 0x00, 0x16, 0x24, 0x01, 0x00, 0x42, 0x24,
+0x04, 0x00, 0x43, 0x28, 0xC6, 0xFF, 0x60, 0x14, 0xCC, 0xDF, 0x82, 0xAC,
+0x21, 0xF0, 0x00, 0x00, 0x54, 0x59, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00,
+0x21, 0x20, 0xC0, 0x03, 0x64, 0x00, 0xBF, 0x8F, 0x60, 0x00, 0xBE, 0x8F,
+0x5C, 0x00, 0xB7, 0x8F, 0x58, 0x00, 0xB6, 0x8F, 0x54, 0x00, 0xB5, 0x8F,
+0x50, 0x00, 0xB4, 0x8F, 0x4C, 0x00, 0xB3, 0x8F, 0x48, 0x00, 0xB2, 0x8F,
+0x44, 0x00, 0xB1, 0x8F, 0x40, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x80, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x68, 0x00, 0xBD, 0x27, 0xAC, 0x59, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x03, 0x24, 0x23, 0x18, 0x62, 0x00,
+0xFF, 0xFF, 0x70, 0x30, 0xFF, 0xFF, 0xA2, 0x32, 0x2B, 0x10, 0x02, 0x02,
+0xE7, 0xFF, 0x40, 0x14, 0x21, 0x20, 0x40, 0x02, 0x18, 0x00, 0xB0, 0x93,
+0x19, 0x00, 0xA2, 0x93, 0x00, 0x81, 0x10, 0x00, 0x25, 0x80, 0x02, 0x02,
+0xFF, 0x00, 0x10, 0x32, 0x2C, 0x59, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x02,
+0x21, 0x20, 0x40, 0x02, 0xFF, 0x58, 0x00, 0x0C, 0x11, 0x00, 0xA5, 0x27,
+0x11, 0x00, 0xA3, 0x93, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x64, 0x30,
+0x9D, 0xFF, 0x90, 0x10, 0x20, 0x00, 0x16, 0x24, 0xFF, 0x00, 0x02, 0x24,
+0xCD, 0xFF, 0x82, 0x10, 0x0F, 0x00, 0x63, 0x30, 0x02, 0x11, 0x04, 0x00,
+0x21, 0x20, 0x60, 0x00, 0x29, 0x00, 0xA3, 0xA3, 0x83, 0x59, 0x00, 0x0C,
+0x28, 0x00, 0xA2, 0xA3, 0x38, 0x00, 0xA4, 0x27, 0xFF, 0x00, 0x05, 0x24,
+0x08, 0x00, 0x06, 0x24, 0xE3, 0x54, 0x00, 0x0C, 0x21, 0x80, 0x40, 0x00,
+0x28, 0x00, 0xA4, 0x93, 0xCF, 0x59, 0x00, 0x0C, 0x38, 0x00, 0xA5, 0x27,
+0x1F, 0x00, 0x40, 0x14, 0x01, 0x00, 0x44, 0x26, 0x40, 0x10, 0x10, 0x00,
+0x21, 0x10, 0x52, 0x00, 0x01, 0x00, 0x42, 0x24, 0x2C, 0x5B, 0x00, 0x08,
+0xFF, 0xFF, 0x52, 0x30, 0x40, 0x88, 0x10, 0x00, 0x27, 0x00, 0x20, 0x1A,
+0x21, 0x80, 0x00, 0x00, 0xFF, 0x00, 0x16, 0x24, 0x21, 0x20, 0x50, 0x02,
+0x01, 0x00, 0x84, 0x24, 0xFF, 0xFF, 0x84, 0x30, 0xFF, 0x58, 0x00, 0x0C,
+0x10, 0x00, 0xA5, 0x27, 0x01, 0x00, 0x03, 0x26, 0xFF, 0x00, 0x70, 0x30,
+0x05, 0x00, 0x40, 0x10, 0x2A, 0x18, 0x11, 0x02, 0x10, 0x00, 0xA2, 0x93,
+0x00, 0x00, 0x00, 0x00, 0x26, 0x10, 0x56, 0x00, 0x0B, 0x98, 0x02, 0x00,
+0xF3, 0xFF, 0x60, 0x14, 0x21, 0x20, 0x50, 0x02, 0x15, 0x00, 0x60, 0x16,
+0x21, 0x10, 0x32, 0x02, 0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x52, 0x30,
+0xF9, 0x5A, 0x00, 0x08, 0x01, 0x00, 0x16, 0x24, 0x29, 0x00, 0xA5, 0x93,
+0xFF, 0xFF, 0x84, 0x30, 0x6A, 0x5A, 0x00, 0x0C, 0x38, 0x00, 0xA6, 0x27,
+0x21, 0x28, 0x40, 0x00, 0x0F, 0x00, 0x43, 0x30, 0x0F, 0x00, 0x02, 0x24,
+0xDB, 0xFF, 0x62, 0x10, 0x40, 0x10, 0x10, 0x00, 0x28, 0x00, 0xA4, 0x93,
+0xB9, 0x5A, 0x00, 0x0C, 0x38, 0x00, 0xA6, 0x27, 0xAC, 0x59, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x2C, 0x5B, 0x00, 0x08, 0x21, 0x90, 0x40, 0x00,
+0x19, 0x00, 0xA3, 0x93, 0x29, 0x00, 0xA6, 0x93, 0x0F, 0x00, 0x13, 0x24,
+0x0E, 0x00, 0x10, 0x24, 0x25, 0x18, 0x66, 0x00, 0x01, 0x00, 0x62, 0x30,
+0x0A, 0x98, 0x02, 0x02, 0x02, 0x00, 0x64, 0x30, 0xFD, 0x00, 0x62, 0x32,
+0x0A, 0x98, 0x44, 0x00, 0x04, 0x00, 0x65, 0x30, 0xFB, 0x00, 0x62, 0x32,
+0x0A, 0x98, 0x45, 0x00, 0x08, 0x00, 0x63, 0x30, 0xF7, 0x00, 0x62, 0x32,
+0x0A, 0x98, 0x43, 0x00, 0x0F, 0x00, 0x64, 0x32, 0x0F, 0x00, 0x16, 0x24,
+0x25, 0x00, 0x96, 0x10, 0x21, 0x28, 0xC0, 0x00, 0x01, 0x00, 0x44, 0x26,
+0xFF, 0xFF, 0x84, 0x30, 0x6A, 0x5A, 0x00, 0x0C, 0x1A, 0x00, 0xA6, 0x27,
+0x21, 0x28, 0x40, 0x00, 0x0F, 0x00, 0x42, 0x30, 0x03, 0x00, 0x56, 0x10,
+0x21, 0x20, 0x80, 0x02, 0xB9, 0x5A, 0x00, 0x0C, 0x38, 0x00, 0xA6, 0x27,
+0x19, 0x00, 0xA5, 0x93, 0x00, 0x00, 0x00, 0x00, 0x26, 0x10, 0x65, 0x02,
+0x01, 0x00, 0x42, 0x30, 0x0A, 0x80, 0xC2, 0x02, 0x26, 0x18, 0x65, 0x02,
+0x02, 0x00, 0x63, 0x30, 0xFD, 0x00, 0x04, 0x32, 0x0B, 0x80, 0x83, 0x00,
+0x26, 0x10, 0x65, 0x02, 0x04, 0x00, 0x42, 0x30, 0xFB, 0x00, 0x03, 0x32,
+0x0B, 0x80, 0x62, 0x00, 0x26, 0x28, 0x65, 0x02, 0x08, 0x00, 0xA5, 0x30,
+0xF7, 0x00, 0x02, 0x32, 0x0B, 0x80, 0x45, 0x00, 0x0F, 0x00, 0x03, 0x32,
+0x0D, 0x00, 0x76, 0x10, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x59, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x90, 0x40, 0x00, 0x19, 0x00, 0xB0, 0xA3,
+0x2C, 0x5B, 0x00, 0x08, 0x18, 0x00, 0xB4, 0xA3, 0x21, 0x10, 0x32, 0x02,
+0x01, 0x00, 0x42, 0x24, 0xFF, 0xFF, 0x52, 0x30, 0x01, 0x00, 0x16, 0x24,
+0xF9, 0x5A, 0x00, 0x08, 0x18, 0x00, 0xB4, 0xA3, 0x2C, 0x5B, 0x00, 0x08,
+0x21, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x85, 0xAC, 0x21, 0x10, 0x00, 0x00,
+0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30, 0x06, 0x00, 0x43, 0x2C,
+0xFC, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xA5, 0x30, 0x00, 0x00, 0x85, 0xA4,
+0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x43, 0x2C, 0xFC, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xA5, 0x30,
+0x00, 0x00, 0x85, 0xA0, 0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24,
+0xFF, 0x00, 0x42, 0x30, 0x06, 0x00, 0x43, 0x2C, 0xFC, 0xFF, 0x60, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x82, 0x8C, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x82, 0x94, 0x08, 0x00, 0xE0, 0x03, 0xFF, 0xFF, 0x42, 0x30,
+0x00, 0x00, 0x82, 0x90, 0x08, 0x00, 0xE0, 0x03, 0xFF, 0x00, 0x42, 0x30,
+0x25, 0xB0, 0x02, 0x3C, 0x21, 0x20, 0x82, 0x00, 0x00, 0x00, 0x85, 0xAC,
+0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x43, 0x2C, 0xFC, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x21, 0x20, 0x82, 0x00, 0xFF, 0xFF, 0xA5, 0x30, 0x00, 0x00, 0x85, 0xA4,
+0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x43, 0x2C, 0xFC, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x21, 0x20, 0x82, 0x00, 0xFF, 0x00, 0xA5, 0x30, 0x00, 0x00, 0x85, 0xA0,
+0x21, 0x10, 0x00, 0x00, 0x01, 0x00, 0x42, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x06, 0x00, 0x43, 0x2C, 0xFC, 0xFF, 0x60, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C,
+0x21, 0x20, 0x82, 0x00, 0x00, 0x00, 0x82, 0x8C, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0x21, 0x20, 0x82, 0x00,
+0x00, 0x00, 0x82, 0x94, 0x08, 0x00, 0xE0, 0x03, 0xFF, 0xFF, 0x42, 0x30,
+0x25, 0xB0, 0x02, 0x3C, 0x21, 0x20, 0x82, 0x00, 0x00, 0x00, 0x82, 0x90,
+0x08, 0x00, 0xE0, 0x03, 0xFF, 0x00, 0x42, 0x30, 0x01, 0x80, 0x02, 0x3C,
+0x25, 0xB0, 0x03, 0x3C, 0xD4, 0x70, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34,
+0x00, 0x00, 0x62, 0xAC, 0x00, 0x00, 0x83, 0x90, 0x30, 0x00, 0x02, 0x24,
+0x05, 0x00, 0x62, 0x10, 0x21, 0x20, 0x00, 0x00, 0x31, 0x00, 0x02, 0x24,
+0x02, 0x00, 0x62, 0x10, 0x01, 0x00, 0x04, 0x24, 0x07, 0x00, 0x04, 0x24,
+0x7E, 0x58, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x3C,
+0x25, 0xB0, 0x03, 0x3C, 0x10, 0x71, 0x42, 0x24, 0x18, 0x03, 0x63, 0x34,
+0x02, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x62, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xFC, 0x5C, 0x80, 0xAC, 0x42, 0xB0, 0x02, 0x3C, 0x03, 0x00, 0x47, 0x34,
+0x00, 0x00, 0xE3, 0x90, 0xFF, 0x00, 0x84, 0x30, 0x04, 0x00, 0x84, 0x24,
+0xFF, 0x00, 0x65, 0x30, 0x01, 0x00, 0x02, 0x24, 0x04, 0x30, 0x82, 0x00,
+0x07, 0x18, 0x85, 0x00, 0x25, 0xB0, 0x02, 0x3C, 0xE8, 0x03, 0x42, 0x34,
+0x01, 0x00, 0x63, 0x30, 0x21, 0x20, 0xC0, 0x00, 0x00, 0x00, 0x45, 0xA0,
+0x02, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x24, 0x10, 0x85, 0x00, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x1C, 0x00, 0xBF, 0xAF,
+0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0xD0, 0xDF, 0x42, 0x24, 0x04, 0x00, 0x43, 0x8C, 0x00, 0x00, 0x02, 0xAE,
+0x04, 0x00, 0x50, 0xAC, 0x00, 0x00, 0x70, 0xAC, 0x04, 0x00, 0x03, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB0, 0xAF, 0x21, 0x80, 0x80, 0x00,
+0x1C, 0x00, 0xBF, 0xAF, 0x8A, 0x40, 0x00, 0x0C, 0x10, 0x00, 0xA4, 0x27,
+0x04, 0x00, 0x03, 0x8E, 0x00, 0x00, 0x02, 0x8E, 0x10, 0x00, 0xA4, 0x27,
+0x00, 0x00, 0x62, 0xAC, 0x04, 0x00, 0x43, 0xAC, 0x00, 0x00, 0x10, 0xAE,
+0x90, 0x40, 0x00, 0x0C, 0x04, 0x00, 0x10, 0xAE, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x1F, 0xF7, 0x00, 0x6A, 0x82, 0x34, 0x4C, 0xEC, 0x82, 0x34, 0x8C, 0x32,
+0x89, 0xE2, 0x48, 0x32, 0x89, 0xE2, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0x48, 0x32, 0x69, 0xE2, 0x04, 0xF5,
+0x68, 0x9A, 0x01, 0xF6, 0x01, 0x6C, 0x8B, 0xEC, 0x8C, 0xEB, 0x04, 0xF5,
+0x68, 0xDA, 0x20, 0xE8, 0x00, 0x65, 0x00, 0x00, 0x1F, 0xF7, 0x00, 0x6A,
+0x82, 0x34, 0x4C, 0xEC, 0x82, 0x34, 0x8C, 0x32, 0x89, 0xE2, 0x48, 0x32,
+0x89, 0xE2, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0x48, 0x32, 0x69, 0xE2, 0x04, 0xF5, 0x68, 0x9A, 0x01, 0xF6,
+0x01, 0x6C, 0x8B, 0xEC, 0x8C, 0xEB, 0x00, 0xF2, 0x00, 0x6C, 0x8D, 0xEB,
+0x04, 0xF5, 0x68, 0xDA, 0x20, 0xE8, 0x00, 0x65, 0xFF, 0x6B, 0x6C, 0xED,
+0x04, 0x5D, 0x6C, 0xEC, 0x69, 0x60, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0xCB, 0xF4, 0x46, 0xA2, 0xEF, 0x4A, 0x6C, 0xEA, 0x02, 0x5A,
+0x0C, 0x60, 0x02, 0x74, 0x38, 0x60, 0x03, 0x54, 0x1D, 0x61, 0x03, 0x74,
+0x2C, 0x60, 0x04, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x40, 0x32, 0x20, 0xE8,
+0xFF, 0x4A, 0x02, 0x74, 0x3D, 0x60, 0x03, 0x54, 0x18, 0x61, 0x03, 0x74,
+0xF4, 0x61, 0x01, 0x75, 0x43, 0x60, 0x02, 0x55, 0x31, 0x61, 0x02, 0x75,
+0x42, 0x60, 0x03, 0x75, 0xEC, 0x61, 0x02, 0xF0, 0x00, 0x6A, 0x40, 0x32,
+0x1E, 0xF0, 0x00, 0x4A, 0x20, 0xE8, 0x00, 0x65, 0x01, 0x74, 0xE3, 0x61,
+0x02, 0xF0, 0x0F, 0x6A, 0x40, 0x32, 0x20, 0xE8, 0x40, 0x32, 0x01, 0x74,
+0xDC, 0x61, 0x03, 0xF7, 0x10, 0x6A, 0x40, 0x32, 0x40, 0x32, 0x10, 0xF0,
+0x00, 0x4A, 0x20, 0xE8, 0x00, 0x65, 0x01, 0x75, 0x1B, 0x60, 0x02, 0x55,
+0x08, 0x61, 0x02, 0x75, 0x29, 0x60, 0x03, 0x75, 0xCC, 0x61, 0x02, 0xF0,
+0x10, 0x6A, 0x40, 0x32, 0xDE, 0x17, 0xC7, 0x2D, 0x02, 0xF0, 0x10, 0x6A,
+0x40, 0x32, 0x40, 0x32, 0x1E, 0xF0, 0x15, 0x4A, 0x20, 0xE8, 0x00, 0x65,
+0xBE, 0x2D, 0x02, 0xF0, 0x00, 0x6A, 0xF7, 0x17, 0x03, 0xF7, 0x10, 0x6A,
+0x40, 0x32, 0xCD, 0x17, 0x02, 0xF0, 0x10, 0x6A, 0x40, 0x32, 0x40, 0x32,
+0x1E, 0xF0, 0x10, 0x4A, 0x20, 0xE8, 0x00, 0x65, 0x02, 0xF0, 0x00, 0x6A,
+0xF8, 0x17, 0x02, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x1E, 0xF0, 0x05, 0x4A,
+0x20, 0xE8, 0x00, 0x65, 0x02, 0xF0, 0x10, 0x6A, 0x40, 0x32, 0xF7, 0x17,
+0xFC, 0x63, 0x06, 0xD0, 0x8C, 0x30, 0x81, 0xE0, 0x08, 0x30, 0x81, 0xE0,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A,
+0x08, 0x30, 0x41, 0xE0, 0xC9, 0xF7, 0x1B, 0x6D, 0x04, 0xF0, 0x00, 0x6A,
+0x40, 0x32, 0xAB, 0xED, 0x40, 0x32, 0xA0, 0x35, 0xA0, 0x35, 0xFF, 0x4A,
+0x04, 0xF5, 0x40, 0xD8, 0x07, 0x62, 0x80, 0xF1, 0x44, 0x45, 0x40, 0x9A,
+0x08, 0x6B, 0x6B, 0xEB, 0x04, 0xF5, 0x44, 0xD8, 0x04, 0xF5, 0x48, 0x98,
+0xC4, 0x67, 0x6C, 0xEA, 0xFF, 0x6B, 0x02, 0x4B, 0x6B, 0xEB, 0x6C, 0xEA,
+0x02, 0xF0, 0x01, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA, 0x04, 0xF5, 0x48, 0xD8,
+0x04, 0xD5, 0x00, 0x18, 0xA5, 0x21, 0x05, 0xD6, 0x04, 0x95, 0x05, 0x96,
+0x04, 0xF5, 0x4A, 0xA0, 0x60, 0xF1, 0x00, 0x4D, 0xB9, 0xE6, 0x40, 0xC6,
+0x00, 0x6A, 0xC4, 0xF4, 0x58, 0xD8, 0xC4, 0xF4, 0x5C, 0xD8, 0xE4, 0xF4,
+0x40, 0xD8, 0xE4, 0xF4, 0x44, 0xD8, 0xE4, 0xF4, 0x48, 0xD8, 0xE4, 0xF4,
+0x4C, 0xD8, 0xE4, 0xF4, 0x50, 0xD8, 0xE4, 0xF4, 0x54, 0xD8, 0x07, 0x97,
+0x06, 0x90, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x00, 0xFF, 0x63, 0x00, 0xD0,
+0x04, 0x67, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0xFF, 0x6F,
+0x80, 0x34, 0xA0, 0xF1, 0x4F, 0x44, 0xEC, 0xEE, 0x01, 0xD1, 0x59, 0xE6,
+0x40, 0xA6, 0xEC, 0xED, 0xC7, 0x67, 0x4C, 0xEE, 0xAC, 0x32, 0xA9, 0xE2,
+0x48, 0x32, 0xA9, 0xE2, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x63, 0xF3, 0x00, 0x4B, 0x48, 0x32, 0x69, 0xE2, 0x04, 0xF5, 0x48, 0x9A,
+0x07, 0x6B, 0x80, 0xF1, 0x04, 0x4C, 0x6C, 0xEA, 0xEC, 0xEA, 0x48, 0x32,
+0xEC, 0xE8, 0x89, 0xE2, 0x00, 0x6D, 0x80, 0x9A, 0x0D, 0x65, 0x70, 0x67,
+0x2E, 0x26, 0x32, 0x24, 0x65, 0x67, 0x01, 0x69, 0x51, 0x67, 0x44, 0xEB,
+0x8C, 0xEA, 0x36, 0x2A, 0x01, 0x4B, 0xEC, 0xEB, 0x1D, 0x5B, 0xF8, 0x61,
+0x6F, 0x40, 0xFF, 0x6A, 0x4C, 0xEB, 0xE8, 0x67, 0xE3, 0xEB, 0x10, 0x61,
+0x01, 0x69, 0xE2, 0x67, 0x51, 0x67, 0x44, 0xEB, 0x8C, 0xEA, 0x05, 0x22,
+0xCA, 0xED, 0x26, 0x60, 0x01, 0x4D, 0xEC, 0xED, 0x03, 0x67, 0xFF, 0x4B,
+0xEC, 0xEB, 0x48, 0x67, 0x43, 0xEB, 0xF2, 0x60, 0xC3, 0xED, 0x70, 0x67,
+0x0A, 0x60, 0x68, 0x67, 0xAB, 0xE6, 0x42, 0xEB, 0x00, 0x6B, 0x05, 0x61,
+0xE8, 0x67, 0xCB, 0xE7, 0xAD, 0xE2, 0xFF, 0x6A, 0x4C, 0xEB, 0x01, 0x91,
+0x00, 0x90, 0x43, 0x67, 0x20, 0xE8, 0x01, 0x63, 0xC3, 0xE8, 0x65, 0x67,
+0xF8, 0x61, 0xCF, 0xE0, 0x01, 0x91, 0x00, 0x90, 0xEC, 0xEB, 0x43, 0x67,
+0x20, 0xE8, 0x01, 0x63, 0x0B, 0x65, 0xCC, 0x17, 0x70, 0x67, 0xED, 0x17,
+0xC9, 0xF7, 0x1B, 0x6E, 0xCB, 0xEE, 0xC0, 0x36, 0xFF, 0x6F, 0xC0, 0x36,
+0xEC, 0xEC, 0xFF, 0x63, 0x60, 0xF1, 0x40, 0x46, 0x01, 0xD1, 0x00, 0xD0,
+0x49, 0xE4, 0x40, 0xA2, 0x07, 0x67, 0xEC, 0xED, 0x4C, 0xE8, 0xA0, 0xF1,
+0x4F, 0x46, 0x55, 0xE5, 0x40, 0xA5, 0x27, 0x67, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x4C, 0xE9, 0x8C, 0x32, 0x89, 0xE2, 0x48, 0x32,
+0x89, 0xE2, 0x63, 0xF3, 0x00, 0x4B, 0x48, 0x32, 0x69, 0xE2, 0x04, 0xF5,
+0x48, 0x9A, 0x07, 0x6B, 0x80, 0xF1, 0x04, 0x4E, 0x6C, 0xEA, 0xEC, 0xEA,
+0x48, 0x32, 0xC9, 0xE2, 0x00, 0x6D, 0x80, 0x9A, 0x2D, 0x65, 0x70, 0x67,
+0x30, 0x21, 0x34, 0x24, 0x01, 0x6A, 0x65, 0x67, 0x0A, 0x65, 0xC7, 0x67,
+0x48, 0x67, 0x44, 0xEB, 0x8C, 0xEA, 0x36, 0x2A, 0x01, 0x4B, 0xCC, 0xEB,
+0x1D, 0x5B, 0xF8, 0x61, 0x6F, 0x40, 0xFF, 0x6A, 0x4C, 0xEB, 0xC9, 0x67,
+0xC3, 0xEB, 0x10, 0x61, 0x01, 0x6F, 0xC2, 0x67, 0x47, 0x67, 0x44, 0xEB,
+0x8C, 0xEA, 0x05, 0x22, 0x2A, 0xED, 0x26, 0x60, 0x01, 0x4D, 0xCC, 0xED,
+0x03, 0x67, 0xFF, 0x4B, 0xCC, 0xEB, 0x49, 0x67, 0x43, 0xEB, 0xF2, 0x60,
+0x23, 0xED, 0x70, 0x67, 0x0A, 0x60, 0x69, 0x67, 0xAB, 0xE1, 0x42, 0xEB,
+0x00, 0x6B, 0x05, 0x61, 0xC9, 0x67, 0x2B, 0xE6, 0xAD, 0xE2, 0xFF, 0x6A,
+0x4C, 0xEB, 0x01, 0x91, 0x00, 0x90, 0x43, 0x67, 0x20, 0xE8, 0x01, 0x63,
+0x23, 0xE8, 0x65, 0x67, 0xF8, 0x61, 0x2F, 0xE0, 0x01, 0x91, 0x00, 0x90,
+0xEC, 0xEB, 0x43, 0x67, 0x20, 0xE8, 0x01, 0x63, 0x2B, 0x65, 0xCC, 0x17,
+0x70, 0x67, 0xED, 0x17, 0x10, 0xF0, 0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36,
+0xFB, 0x63, 0x00, 0x6D, 0x63, 0xF3, 0x00, 0x4E, 0x07, 0xD1, 0x06, 0xD0,
+0x08, 0x62, 0x05, 0x67, 0x26, 0x67, 0x85, 0x67, 0x04, 0xD5, 0x00, 0x18,
+0xDB, 0x5C, 0x05, 0xD6, 0x04, 0xF5, 0x4A, 0xA1, 0xFF, 0x6B, 0x05, 0x96,
+0x6C, 0xEA, 0x48, 0x32, 0xC9, 0xE2, 0xC0, 0xF5, 0x74, 0x9A, 0x60, 0xF5,
+0x40, 0x9A, 0x4D, 0xE3, 0x66, 0x33, 0xC4, 0xF4, 0x74, 0xD9, 0x04, 0x95,
+0x00, 0x6B, 0x69, 0xE1, 0x01, 0x4B, 0x1D, 0x53, 0x04, 0xF5, 0x0C, 0xC2,
+0x24, 0xF5, 0x09, 0xC2, 0x44, 0xF5, 0x06, 0xC2, 0xF6, 0x61, 0x00, 0x6A,
+0x01, 0x4D, 0x64, 0xF5, 0x44, 0xD9, 0x20, 0x55, 0x7F, 0x49, 0x15, 0x49,
+0xD8, 0x61, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x00, 0xEF, 0x05, 0x63,
+0xF8, 0x63, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x07, 0xD2,
+0x0E, 0x62, 0x0D, 0xD1, 0x0C, 0xD0, 0x63, 0xF3, 0x00, 0x4A, 0x27, 0xF1,
+0x44, 0x9A, 0xFF, 0x6B, 0x6C, 0xEC, 0x6C, 0x65, 0xFF, 0xF7, 0x1F, 0x72,
+0x00, 0x6C, 0x05, 0xD4, 0x01, 0x61, 0x05, 0xD3, 0x07, 0x93, 0xFF, 0xF7,
+0x1F, 0x6A, 0x8B, 0x67, 0x63, 0xF3, 0x00, 0x4B, 0x27, 0xF1, 0x44, 0xDB,
+0x00, 0x6A, 0x04, 0xD2, 0x00, 0xF1, 0x18, 0x24, 0x10, 0xF0, 0x02, 0x6D,
+0x00, 0xF4, 0xA0, 0x35, 0x22, 0x67, 0xBC, 0xF3, 0x0C, 0x4D, 0xFF, 0x6E,
+0x00, 0xF5, 0x84, 0x43, 0x05, 0x10, 0x01, 0x49, 0x1D, 0x51, 0x60, 0xC4,
+0x01, 0x4C, 0x0B, 0x60, 0xA9, 0xE1, 0x60, 0xA2, 0x46, 0x67, 0x6C, 0xEA,
+0xF6, 0x22, 0x01, 0x49, 0x4D, 0x43, 0x1D, 0x51, 0x40, 0xC4, 0x01, 0x4C,
+0xF5, 0x61, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4,
+0x80, 0x34, 0x00, 0x69, 0x63, 0xF3, 0x00, 0x4A, 0x5C, 0xF1, 0x04, 0x4B,
+0xDC, 0xF0, 0x0C, 0x4C, 0x0A, 0x65, 0x4B, 0x65, 0x2C, 0x65, 0x11, 0x67,
+0x48, 0x67, 0x6A, 0x67, 0x00, 0x6D, 0x5D, 0xE0, 0x79, 0xE0, 0xAD, 0xE6,
+0x40, 0xA3, 0xB1, 0xE7, 0x01, 0x4D, 0xA0, 0xF3, 0x48, 0xC4, 0x80, 0xF0,
+0x51, 0xA3, 0x05, 0x55, 0x20, 0xF4, 0x59, 0xC4, 0xF4, 0x61, 0x48, 0x67,
+0x51, 0xE1, 0x49, 0x67, 0x4D, 0xE1, 0x40, 0xA3, 0x01, 0x49, 0x1D, 0x51,
+0xC0, 0xF4, 0x4A, 0xC4, 0x5D, 0xA3, 0x05, 0x48, 0xE0, 0xF4, 0x47, 0xC4,
+0xE1, 0x61, 0x6B, 0x67, 0x00, 0xF1, 0x0A, 0x23, 0x10, 0xF0, 0x02, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x10, 0xF0, 0x02, 0x6F, 0x00, 0xF4, 0xE0, 0x37,
+0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0x00, 0x69, 0x63, 0xF3,
+0x00, 0x4E, 0x5C, 0xF4, 0x00, 0x4F, 0xDC, 0xF3, 0x0C, 0x4D, 0x28, 0x32,
+0xED, 0xE2, 0x60, 0x9B, 0xD1, 0xE2, 0xA9, 0xE2, 0xC0, 0xF5, 0x74, 0xDC,
+0x40, 0x9A, 0x01, 0x49, 0x04, 0x51, 0x60, 0xF5, 0x40, 0xDC, 0xF3, 0x61,
+0x10, 0xF0, 0x02, 0x6F, 0x00, 0xF4, 0xE0, 0x37, 0x10, 0xF0, 0x02, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x04, 0x69, 0x63, 0xF3, 0x00, 0x4F, 0x5C, 0xF4, 0x00, 0x4E, 0xDC, 0xF3,
+0x0C, 0x4D, 0x28, 0x33, 0xC9, 0xE3, 0x40, 0x9A, 0xF1, 0xE3, 0xAD, 0xE3,
+0x4A, 0x32, 0xC0, 0xF5, 0x54, 0xDC, 0x40, 0x9B, 0x01, 0x49, 0x1D, 0x51,
+0x4A, 0x32, 0x60, 0xF5, 0x40, 0xDC, 0xF1, 0x61, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x63, 0xF3, 0x00, 0x4C, 0x00, 0x69, 0x04, 0x67,
+0xD1, 0x67, 0xC4, 0xF4, 0x14, 0x48, 0x06, 0xD4, 0x08, 0xD1, 0x09, 0x10,
+0x08, 0x94, 0x01, 0x49, 0x7F, 0x48, 0x7F, 0x4C, 0x15, 0x4C, 0x20, 0x51,
+0x15, 0x48, 0x08, 0xD4, 0x5E, 0x60, 0x8D, 0x98, 0x01, 0x6B, 0x82, 0x32,
+0x52, 0x32, 0x6C, 0xEA, 0xFF, 0x6B, 0x6C, 0xEA, 0xEF, 0x22, 0x07, 0x6A,
+0x4C, 0xEC, 0x6C, 0xEC, 0x88, 0x32, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC,
+0x80, 0x34, 0x80, 0x34, 0x80, 0xF1, 0x04, 0x4C, 0x89, 0xE2, 0x6B, 0x98,
+0x40, 0x9A, 0x91, 0x67, 0x6C, 0xEA, 0x4C, 0xD8, 0x00, 0x18, 0xA5, 0x21,
+0x0A, 0xD6, 0x20, 0xF0, 0x96, 0xA0, 0xFF, 0x6A, 0xA2, 0x67, 0x4C, 0xEC,
+0x00, 0x18, 0x93, 0x21, 0x2C, 0xED, 0x20, 0xF0, 0x56, 0xA0, 0x04, 0x94,
+0xFF, 0x6B, 0x6C, 0xEA, 0x43, 0xEC, 0x0A, 0x96, 0x01, 0x60, 0x04, 0xD2,
+0xC1, 0xD8, 0xC2, 0xD8, 0xC3, 0xD8, 0xC4, 0xD8, 0xC5, 0xD8, 0xC6, 0xD8,
+0xC7, 0xD8, 0xC8, 0xD8, 0x06, 0x93, 0x48, 0x32, 0xA6, 0x67, 0x69, 0xE2,
+0xC0, 0xF5, 0x74, 0x9A, 0x60, 0xF5, 0x40, 0x9A, 0x4D, 0xE3, 0x66, 0x33,
+0x60, 0xD8, 0x08, 0x92, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33,
+0x63, 0xF3, 0x00, 0x4B, 0x71, 0xE2, 0x66, 0x67, 0xA9, 0xE4, 0x01, 0x4D,
+0x1D, 0x55, 0x04, 0xF5, 0x6C, 0xC2, 0x24, 0xF5, 0x69, 0xC2, 0x44, 0xF5,
+0x66, 0xC2, 0xF6, 0x61, 0x64, 0xF5, 0xC4, 0xDC, 0x08, 0x94, 0x01, 0x49,
+0x7F, 0x48, 0x7F, 0x4C, 0x15, 0x4C, 0x20, 0x51, 0x15, 0x48, 0x08, 0xD4,
+0xA2, 0x61, 0x05, 0x92, 0x06, 0x2A, 0x07, 0x93, 0x63, 0xF3, 0x00, 0x4B,
+0x07, 0xD3, 0x27, 0xF1, 0x44, 0xDB, 0x0E, 0x97, 0x0D, 0x91, 0x0C, 0x90,
+0x00, 0xEF, 0x08, 0x63, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x22, 0x67, 0xBC, 0xF3, 0x0C, 0x4C, 0x00, 0xF5, 0x04, 0x4B, 0x89, 0xE1,
+0x40, 0xA2, 0x01, 0x49, 0x1D, 0x51, 0x40, 0xC3, 0x01, 0x4B, 0xF9, 0x61,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x00, 0x69, 0x63, 0xF3, 0x00, 0x4B, 0x7C, 0xF2, 0x08, 0x4C, 0x1C, 0xF1,
+0x08, 0x4A, 0x0B, 0x65, 0x4C, 0x65, 0x2A, 0x65, 0x11, 0x67, 0x68, 0x67,
+0x8A, 0x67, 0x00, 0x6D, 0x7D, 0xE0, 0x99, 0xE0, 0xAD, 0xE6, 0x40, 0xA3,
+0xB1, 0xE7, 0x01, 0x4D, 0xA0, 0xF3, 0x48, 0xC4, 0x80, 0xF0, 0x51, 0xA3,
+0x05, 0x55, 0x20, 0xF4, 0x59, 0xC4, 0xF4, 0x61, 0x48, 0x67, 0x51, 0xE1,
+0x49, 0x67, 0x4D, 0xE1, 0x40, 0xA3, 0x01, 0x49, 0x1D, 0x51, 0xC0, 0xF4,
+0x4A, 0xC4, 0x5D, 0xA3, 0x05, 0x48, 0xE0, 0xF4, 0x47, 0xC4, 0xE1, 0x61,
+0x10, 0xF0, 0x02, 0x6F, 0x00, 0xF4, 0xE0, 0x37, 0x10, 0xF0, 0x02, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x2B, 0x67, 0x63, 0xF3, 0x00, 0x4F, 0x5C, 0xF4, 0x00, 0x4E, 0xDC, 0xF3,
+0x0C, 0x4D, 0x28, 0x32, 0xCD, 0xE2, 0x60, 0x9B, 0xF1, 0xE2, 0xA9, 0xE2,
+0xC0, 0xF5, 0x74, 0xDC, 0x40, 0x9A, 0x01, 0x49, 0x1D, 0x51, 0x60, 0xF5,
+0x40, 0xDC, 0xF3, 0x61, 0x17, 0x17, 0x00, 0x00, 0xFF, 0xF7, 0x1F, 0x6F,
+0x8C, 0xEF, 0xE0, 0xF1, 0x10, 0x6E, 0xEC, 0xEE, 0xFB, 0x63, 0xD2, 0x36,
+0x06, 0xD0, 0xCC, 0x30, 0xC1, 0xE0, 0x08, 0x30, 0xC1, 0xE0, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x08, 0x30,
+0x41, 0xE0, 0x08, 0x62, 0x07, 0xD1, 0x25, 0x67, 0x04, 0xF5, 0xA8, 0x98,
+0x02, 0xF0, 0x00, 0x6A, 0xFF, 0x6B, 0x4D, 0xED, 0x00, 0xF2, 0x00, 0x6A,
+0xEC, 0xEA, 0x43, 0x32, 0x02, 0x4B, 0x6B, 0xEB, 0x47, 0x32, 0x6C, 0xED,
+0x40, 0x32, 0x4D, 0xED, 0x04, 0xF5, 0x20, 0xD8, 0x04, 0xF5, 0xA8, 0xD8,
+0x87, 0x67, 0x04, 0xD5, 0x00, 0x18, 0x2C, 0x22, 0x05, 0xD6, 0x04, 0x95,
+0x08, 0x6B, 0x07, 0x6C, 0x6B, 0xEB, 0x8C, 0xEA, 0xAC, 0xEB, 0x4D, 0xEB,
+0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x04, 0xF5, 0x68, 0xD8,
+0x40, 0x32, 0x8C, 0xEB, 0x80, 0xF1, 0x04, 0x4A, 0x68, 0x33, 0x4D, 0xE3,
+0x40, 0x9B, 0x2C, 0xEA, 0x04, 0xF5, 0x44, 0xD8, 0x05, 0x96, 0x00, 0x18,
+0xA5, 0x21, 0x86, 0x67, 0x05, 0x96, 0x04, 0xF5, 0x8A, 0xA0, 0x00, 0x18,
+0x93, 0x21, 0xA6, 0x67, 0x08, 0x97, 0x07, 0x91, 0x06, 0x90, 0x00, 0xEF,
+0x05, 0x63, 0x00, 0x00, 0xFF, 0x6A, 0xFD, 0x63, 0x04, 0x62, 0x00, 0x18,
+0xDB, 0x5C, 0x4C, 0xEC, 0x04, 0x97, 0x00, 0xEF, 0x03, 0x63, 0x00, 0x00,
+0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x02, 0xF0, 0x00, 0x6D,
+0x63, 0xF3, 0x00, 0x4C, 0x1F, 0x6B, 0x04, 0xF5, 0x48, 0x9C, 0xFF, 0x4B,
+0x00, 0x53, 0xAD, 0xEA, 0x04, 0xF5, 0x48, 0xDC, 0x7F, 0x4C, 0x15, 0x4C,
+0xF6, 0x60, 0x20, 0xE8, 0x00, 0x65, 0x00, 0x65, 0x00, 0x1C, 0xA1, 0x5E,
+0x00, 0x65, 0x00, 0x65, 0x83, 0xED, 0xAB, 0xE4, 0x01, 0x61, 0x8B, 0xE5,
+0x20, 0xE8, 0x00, 0x65, 0xC9, 0xF7, 0x1B, 0x6A, 0xF9, 0x63, 0x4B, 0xEA,
+0x0A, 0xD0, 0x40, 0x30, 0x00, 0x30, 0x01, 0xF5, 0x83, 0x40, 0x0C, 0x62,
+0x00, 0x1C, 0x00, 0x5C, 0x0B, 0xD1, 0x05, 0xD2, 0x05, 0x93, 0x70, 0x6A,
+0x6C, 0xEA, 0x3A, 0x2A, 0x67, 0x40, 0x3B, 0x4B, 0x01, 0x6A, 0x4B, 0xEA,
+0x40, 0xC3, 0x05, 0x93, 0x70, 0x6A, 0x4C, 0xEB, 0x08, 0xD3, 0x3C, 0x2B,
+0x9D, 0x67, 0x00, 0x1C, 0x8A, 0x40, 0x10, 0x4C, 0x02, 0xF0, 0x00, 0x6A,
+0x40, 0x31, 0xAF, 0x41, 0x00, 0x1C, 0xAC, 0x45, 0x18, 0x6C, 0x9D, 0x67,
+0x10, 0x4C, 0x00, 0x1C, 0x90, 0x40, 0x02, 0x67, 0x00, 0x1C, 0x5B, 0x1F,
+0x64, 0x6C, 0x10, 0xF0, 0x00, 0x6A, 0xD0, 0x67, 0x4D, 0xEE, 0x18, 0x6C,
+0x00, 0x1C, 0x83, 0x45, 0xAF, 0x41, 0x00, 0x1C, 0x2C, 0x1F, 0x03, 0x6C,
+0x08, 0x92, 0x6A, 0x2A, 0xC9, 0xF7, 0x1B, 0x6A, 0x7D, 0x67, 0x4B, 0xEA,
+0x40, 0x32, 0x20, 0xF0, 0x60, 0xA3, 0x0C, 0x97, 0x0B, 0x91, 0x0A, 0x90,
+0x40, 0x32, 0x42, 0x4A, 0x07, 0x63, 0x60, 0xC2, 0x00, 0xEF, 0x00, 0x65,
+0x8F, 0x6A, 0xA3, 0x67, 0x01, 0xF5, 0x83, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0x4C, 0xED, 0x05, 0x93, 0x70, 0x6A, 0x4C, 0xEB, 0x08, 0xD3, 0xC4, 0x23,
+0x9D, 0x67, 0x00, 0x1C, 0x8A, 0x40, 0x10, 0x4C, 0x02, 0xF0, 0x00, 0x6D,
+0xA0, 0x31, 0xAF, 0x41, 0x00, 0x1C, 0xAC, 0x45, 0x00, 0x6C, 0x9D, 0x67,
+0x10, 0x4C, 0x00, 0x1C, 0x90, 0x40, 0x06, 0xD2, 0x00, 0x1C, 0x5B, 0x1F,
+0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42, 0x01, 0x6C, 0x9D, 0x67, 0x00, 0x1C,
+0x8A, 0x40, 0x10, 0x4C, 0xAF, 0x41, 0x00, 0x1C, 0xAC, 0x45, 0x00, 0x6C,
+0x9D, 0x67, 0x10, 0x4C, 0x00, 0x1C, 0x90, 0x40, 0x07, 0xD2, 0x00, 0x1C,
+0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42, 0x00, 0x6C, 0x01, 0xF1,
+0x00, 0x68, 0x06, 0x96, 0x00, 0x30, 0x01, 0x6A, 0xFF, 0x48, 0x40, 0x32,
+0x40, 0x32, 0x0C, 0xEE, 0x4D, 0xEE, 0xAF, 0x41, 0x00, 0x1C, 0x83, 0x45,
+0x00, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42,
+0x01, 0x6C, 0x07, 0x93, 0x01, 0x6E, 0xC0, 0x36, 0x6C, 0xE8, 0xC0, 0x36,
+0xAF, 0x41, 0x0D, 0xEE, 0x00, 0x1C, 0x83, 0x45, 0x00, 0x6C, 0x00, 0x1C,
+0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C, 0xF0, 0x42, 0x00, 0x6C, 0x76, 0x17,
+0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x01, 0xF5,
+0x03, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x05, 0x95, 0x06, 0x96, 0xAF, 0x41,
+0x00, 0x1C, 0x83, 0x45, 0x00, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x00, 0x1C, 0xF0, 0x42, 0x01, 0x6C, 0x07, 0x96, 0xAF, 0x41, 0x00, 0x1C,
+0x83, 0x45, 0x00, 0x6C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C, 0x00, 0x1C,
+0xF0, 0x42, 0x00, 0x6C, 0x0C, 0x97, 0x0B, 0x91, 0x0A, 0x90, 0x00, 0xEF,
+0x07, 0x63, 0x00, 0x00, 0xF8, 0x63, 0x0D, 0xD1, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0x0E, 0x62, 0x0C, 0xD0, 0x63, 0xF3, 0x00, 0x49,
+0x03, 0x99, 0x01, 0x6A, 0x80, 0xF7, 0x02, 0x30, 0x4C, 0xE8, 0x08, 0x28,
+0x42, 0x99, 0x03, 0x6B, 0x40, 0xF7, 0x42, 0x32, 0x6C, 0xEA, 0x01, 0x72,
+0x00, 0xF2, 0x07, 0x60, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x63, 0xF3, 0x00, 0x4D, 0x43, 0x9D, 0x01, 0x6B, 0x80, 0xF7, 0x42, 0x32,
+0x6C, 0xEA, 0xE0, 0xF1, 0x14, 0x22, 0x42, 0x9D, 0x03, 0x6B, 0x40, 0xF7,
+0x42, 0x32, 0x6C, 0xEA, 0x01, 0x72, 0xE0, 0xF1, 0x0C, 0x61, 0x44, 0x9D,
+0x80, 0xF7, 0x42, 0x32, 0x01, 0x72, 0xA0, 0xF2, 0x00, 0x60, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0xC0, 0xF2, 0xA7, 0xA5, 0x80, 0x34, 0x80, 0x34,
+0x61, 0xF4, 0x02, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x06, 0xD5, 0x10, 0xF0,
+0x02, 0x69, 0x00, 0xF4, 0x20, 0x31, 0x63, 0xF3, 0x00, 0x49, 0xC0, 0xF2,
+0x46, 0xA1, 0x07, 0x2A, 0xBD, 0x67, 0xAC, 0xAD, 0x01, 0x6A, 0xC0, 0xF2,
+0x46, 0xC1, 0xC0, 0xF2, 0xA4, 0xC9, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA,
+0x40, 0x30, 0x00, 0x30, 0x01, 0xF5, 0x83, 0x40, 0x00, 0x1C, 0x00, 0x5C,
+0x00, 0x65, 0x70, 0x6B, 0x4C, 0xEB, 0x80, 0xF2, 0x16, 0x2B, 0xC0, 0xF2,
+0x44, 0xA9, 0x06, 0x93, 0x53, 0xE3, 0x63, 0xEA, 0x07, 0xD4, 0x02, 0x61,
+0x6B, 0xE2, 0x07, 0xD2, 0x07, 0x95, 0x03, 0x5D, 0x80, 0xF2, 0x0D, 0x60,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0xC9, 0xF7, 0x1B, 0x6C,
+0x63, 0xF3, 0x00, 0x4A, 0x8B, 0xEC, 0x80, 0x34, 0xC0, 0xF2, 0xA4, 0xA2,
+0x80, 0x34, 0x61, 0xF4, 0x03, 0x4C, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0x63, 0xF3, 0x00, 0x4D,
+0x9D, 0x67, 0x62, 0x9D, 0x98, 0xA4, 0x3F, 0x6E, 0x24, 0x6A, 0xC0, 0xF2,
+0x82, 0xC5, 0x83, 0x67, 0x62, 0x33, 0xCC, 0xEC, 0x62, 0x33, 0xCC, 0xEB,
+0x93, 0xE2, 0x20, 0x6A, 0x7B, 0xE2, 0xC0, 0xF2, 0x43, 0xA5, 0x06, 0x95,
+0x4F, 0xE5, 0x43, 0xED, 0x07, 0xD3, 0x02, 0x60, 0xAB, 0xE2, 0x07, 0xD2,
+0x07, 0x95, 0x60, 0xF1, 0x1C, 0x25, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B, 0xC0, 0xF2, 0x43, 0xA3, 0x06, 0x95,
+0x43, 0xED, 0x16, 0x60, 0x07, 0x92, 0x24, 0x68, 0x83, 0xEA, 0x40, 0xF2,
+0x18, 0x61, 0x07, 0x94, 0x20, 0x6D, 0x08, 0xD5, 0xC3, 0xEC, 0x24, 0x60,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A,
+0x45, 0xAA, 0x3F, 0x6B, 0x6C, 0xEA, 0x89, 0xE2, 0x08, 0xD2, 0x18, 0x10,
+0x42, 0x9B, 0x3F, 0x6B, 0x6C, 0xEA, 0x07, 0x93, 0x43, 0xEB, 0x63, 0xE2,
+0x01, 0x61, 0x00, 0x68, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0x45, 0xAA, 0x07, 0x94, 0x3F, 0x6B, 0x6C, 0xEA,
+0x43, 0xEC, 0x8B, 0xE2, 0x08, 0xD2, 0x02, 0x61, 0x00, 0x6D, 0x08, 0xD5,
+0x06, 0x6A, 0x03, 0xEA, 0x80, 0xF2, 0x06, 0x60, 0x10, 0xF0, 0x02, 0x6B,
+0x00, 0xF4, 0x60, 0x33, 0x08, 0x32, 0x63, 0xF3, 0x00, 0x4B, 0x69, 0xE2,
+0xA6, 0x9A, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3,
+0x00, 0x4B, 0xC3, 0x9B, 0xE0, 0xF3, 0x1F, 0x6F, 0x80, 0xF5, 0xA2, 0x35,
+0x86, 0x67, 0xEC, 0xEC, 0x40, 0xF2, 0x17, 0x24, 0x00, 0xF2, 0x00, 0x68,
+0x44, 0x67, 0x0C, 0xEA, 0x04, 0x22, 0x00, 0xF4, 0x00, 0x6A, 0x4B, 0xEA,
+0x4D, 0xEC, 0xB8, 0xEC, 0xC2, 0x33, 0x6A, 0x33, 0xEC, 0xEB, 0x12, 0xEA,
+0x42, 0x34, 0x43, 0x67, 0x0C, 0xEA, 0xEC, 0xEC, 0x04, 0x22, 0x00, 0xF4,
+0x00, 0x6A, 0x4B, 0xEA, 0x4D, 0xEB, 0xB8, 0xEB, 0xC9, 0xF7, 0x1B, 0x68,
+0x0B, 0xE8, 0x80, 0xF5, 0xA0, 0x35, 0x00, 0x30, 0x00, 0x30, 0x12, 0xEA,
+0x42, 0x31, 0xEC, 0xE9, 0x3F, 0x6A, 0x2C, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x4D, 0xED, 0x8D, 0xED, 0x81, 0xF4, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x04, 0xD5, 0x91, 0xF4, 0x84, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x02, 0xF0, 0x00, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0xFF, 0x4D, 0x4C, 0xED,
+0xC0, 0xF3, 0x00, 0x6A, 0x4C, 0xE9, 0x80, 0xF5, 0x20, 0x32, 0x4D, 0xED,
+0x04, 0xD5, 0x91, 0xF4, 0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0x42, 0x9B, 0xC0, 0xF7, 0x42, 0x32, 0xC0, 0xF1, 0x0A, 0x2A, 0x08, 0x94,
+0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8, 0x8C, 0x32, 0x65, 0xE2, 0xA0, 0xF0,
+0xAC, 0xA1, 0x00, 0x30, 0x00, 0x30, 0x21, 0xF2, 0x82, 0x40, 0x00, 0x1C,
+0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF0, 0xAD, 0xA1, 0x21, 0xF2, 0x83, 0x40,
+0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF0, 0xAE, 0xA1, 0x21, 0xF2,
+0x84, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF0, 0xAF, 0xA1,
+0x21, 0xF2, 0x85, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF0,
+0xB0, 0xA1, 0x21, 0xF2, 0x86, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65,
+0xA0, 0xF0, 0xB1, 0xA1, 0x21, 0xF2, 0x87, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0x00, 0x65, 0xA0, 0xF0, 0xB2, 0xA1, 0x21, 0xF2, 0x88, 0x40, 0x00, 0x1C,
+0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF0, 0xB3, 0xA1, 0x21, 0xF2, 0x89, 0x40,
+0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0xCB, 0xF4, 0x46, 0xA2, 0x22, 0x72, 0x03, 0x60, 0x92, 0x72,
+0x80, 0xF0, 0x0D, 0x61, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0x42, 0x9A, 0x3F, 0x6B, 0x42, 0x32, 0x6C, 0xEA,
+0x24, 0x6B, 0x53, 0xE3, 0x07, 0x92, 0x01, 0x6B, 0x6E, 0xEA, 0x6C, 0xEA,
+0x00, 0xF2, 0x0F, 0x22, 0x07, 0x95, 0xA6, 0x33, 0x64, 0x32, 0x69, 0xE2,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x07, 0xD2, 0x63, 0xF3,
+0x00, 0x4B, 0xC0, 0xF2, 0x43, 0xA3, 0x06, 0x95, 0x43, 0xED, 0xA0, 0xF1,
+0x19, 0x60, 0x07, 0x92, 0x24, 0x68, 0x83, 0xEA, 0x06, 0x60, 0x42, 0x9B,
+0x3F, 0x6B, 0x42, 0x32, 0x6C, 0xEA, 0x07, 0x93, 0x61, 0xE2, 0x06, 0x6D,
+0x03, 0xED, 0xA0, 0xF1, 0x16, 0x60, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x08, 0x32, 0x63, 0xF3, 0x00, 0x4B, 0x69, 0xE2, 0xA6, 0x9A,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x63, 0xF3, 0x00, 0x4B,
+0xC4, 0x9B, 0xE0, 0xF3, 0x1F, 0x6F, 0x80, 0xF5, 0xA2, 0x35, 0xC2, 0x34,
+0x8A, 0x34, 0xEC, 0xEC, 0xA0, 0xF1, 0x1E, 0x24, 0x00, 0xF2, 0x00, 0x68,
+0x44, 0x67, 0x0C, 0xEA, 0x04, 0x22, 0x00, 0xF4, 0x00, 0x6A, 0x4B, 0xEA,
+0x4D, 0xEC, 0xB8, 0xEC, 0x00, 0xF5, 0xC2, 0x33, 0xEC, 0xEB, 0x12, 0xEA,
+0x42, 0x34, 0x43, 0x67, 0x0C, 0xEA, 0xEC, 0xEC, 0x04, 0x22, 0x00, 0xF4,
+0x00, 0x6A, 0x4B, 0xEA, 0x4D, 0xEB, 0xB8, 0xEB, 0xC9, 0xF7, 0x1B, 0x68,
+0x0B, 0xE8, 0x80, 0xF5, 0xA0, 0x35, 0x00, 0x30, 0x00, 0x30, 0x12, 0xEA,
+0x42, 0x31, 0xEC, 0xE9, 0x3F, 0x6A, 0x2C, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0x4D, 0xED, 0x8D, 0xED, 0x81, 0xF4, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x04, 0xD5, 0x91, 0xF4, 0x8C, 0x40, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x02, 0xF0, 0x00, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0xFF, 0x4D, 0x4C, 0xED,
+0xC0, 0xF3, 0x00, 0x6A, 0x4C, 0xE9, 0x80, 0xF5, 0x20, 0x32, 0x4D, 0xED,
+0x91, 0xF4, 0x8C, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x04, 0xD5, 0x0E, 0x97,
+0x0D, 0x91, 0x0C, 0x90, 0x00, 0x6A, 0x00, 0xEF, 0x08, 0x63, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x81, 0xF4, 0x00, 0x4C,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x08, 0xF0, 0x00, 0x6B, 0x6B, 0xEB,
+0x60, 0x33, 0xA2, 0x67, 0x6C, 0xED, 0xD1, 0x67, 0x03, 0x10, 0x01, 0x48,
+0x25, 0x58, 0x0E, 0x60, 0x08, 0x32, 0xC9, 0xE2, 0x46, 0x9A, 0x6C, 0xEA,
+0xAE, 0xEA, 0xF7, 0x2A, 0x62, 0x9E, 0x40, 0x6C, 0x3F, 0x6A, 0x8B, 0xEC,
+0x0C, 0xEA, 0x8C, 0xEB, 0x4D, 0xEB, 0x62, 0xDE, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0xCB, 0xF4, 0x46, 0xA2, 0x22, 0x72, 0x02, 0x60,
+0x92, 0x72, 0x2A, 0x61, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34,
+0x80, 0x34, 0x81, 0xF4, 0x08, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x68,
+0x08, 0xF0, 0x00, 0x6B, 0x6B, 0xEB, 0x60, 0x33, 0xA2, 0x67, 0x10, 0xF0,
+0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x6C, 0xED, 0x63, 0xF3, 0x00, 0x4E,
+0x03, 0x10, 0x01, 0x48, 0x25, 0x58, 0x10, 0x60, 0x08, 0x32, 0xC9, 0xE2,
+0x46, 0x9A, 0x6C, 0xEA, 0xAE, 0xEA, 0xF7, 0x2A, 0x62, 0x9E, 0x3F, 0x6A,
+0x07, 0xF7, 0x01, 0x6C, 0x0C, 0xEA, 0x8B, 0xEC, 0x40, 0x32, 0x8C, 0xEB,
+0x4D, 0xEB, 0x62, 0xDE, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34,
+0x80, 0x34, 0x21, 0xF2, 0x04, 0x4C, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x68,
+0x27, 0xF7, 0x1F, 0x6B, 0x60, 0x33, 0x60, 0x33, 0x27, 0xF7, 0x1F, 0x4B,
+0x4C, 0xEB, 0x04, 0xD3, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x03, 0xF4, 0x0E, 0x4A,
+0x03, 0xF5, 0x16, 0x4B, 0x09, 0xD2, 0x0A, 0xD3, 0x0C, 0x10, 0x0A, 0x93,
+0x9D, 0x67, 0x10, 0x4C, 0x75, 0xE1, 0x00, 0x1C, 0x1D, 0x55, 0x04, 0x6E,
+0xC0, 0xF0, 0x1B, 0x22, 0x01, 0x48, 0x21, 0x58, 0x22, 0x60, 0x09, 0x92,
+0x0C, 0x31, 0x9D, 0x67, 0x10, 0x4C, 0x55, 0xE1, 0x00, 0x1C, 0x1D, 0x55,
+0x04, 0x6E, 0xEB, 0x2A, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35,
+0x63, 0xF3, 0x00, 0x4D, 0x07, 0xF7, 0x00, 0x6A, 0x62, 0x9D, 0x4B, 0xEA,
+0x40, 0x32, 0xFF, 0x4A, 0x3F, 0x6C, 0x4C, 0xEB, 0x0C, 0xEC, 0x10, 0xF0,
+0x00, 0x6A, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x40, 0x32, 0x8D, 0xEB,
+0xFF, 0x4A, 0x4C, 0xEB, 0x62, 0xDD, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4,
+0x80, 0x34, 0x63, 0xF3, 0x00, 0x4C, 0x63, 0x9C, 0x08, 0xF0, 0x00, 0x6A,
+0x40, 0x32, 0x40, 0x32, 0x4D, 0xEB, 0x63, 0xDC, 0x45, 0x15, 0x02, 0xF0,
+0x00, 0x68, 0x00, 0x30, 0x60, 0x6E, 0xAF, 0x40, 0x00, 0x1C, 0x83, 0x45,
+0x24, 0x6C, 0xE0, 0xF3, 0x08, 0x6C, 0x00, 0x1C, 0x2C, 0x1F, 0x00, 0x65,
+0x9D, 0x67, 0x00, 0x1C, 0x8A, 0x40, 0x14, 0x4C, 0xAF, 0x40, 0x00, 0x1C,
+0xAC, 0x45, 0x24, 0x6C, 0x1F, 0x6C, 0x4C, 0xEC, 0x06, 0xD4, 0x9D, 0x67,
+0x00, 0x1C, 0x90, 0x40, 0x14, 0x4C, 0x00, 0x1C, 0x5B, 0x1F, 0x64, 0x6C,
+0x4C, 0x15, 0x61, 0xF4, 0x83, 0x40, 0xCC, 0x6D, 0x82, 0x15, 0x00, 0x18,
+0xA4, 0x5E, 0x00, 0x65, 0x7D, 0x67, 0x6C, 0xAB, 0x10, 0xF0, 0x02, 0x6A,
+0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0xC0, 0xF2, 0x64, 0xCA,
+0x65, 0x15, 0x42, 0x9B, 0x3F, 0x6B, 0x6C, 0xEA, 0x07, 0x93, 0x61, 0xE2,
+0xA2, 0x15, 0x08, 0x95, 0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8, 0xAC, 0x32,
+0x65, 0xE2, 0xA0, 0xF1, 0xB4, 0xA1, 0x00, 0x30, 0x00, 0x30, 0x21, 0xF2,
+0x82, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF1, 0xB5, 0xA1,
+0x21, 0xF2, 0x83, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF1,
+0xB6, 0xA1, 0x21, 0xF2, 0x84, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65,
+0xA0, 0xF1, 0xB7, 0xA1, 0x21, 0xF2, 0x85, 0x40, 0x00, 0x1C, 0xF0, 0x5B,
+0x00, 0x65, 0xA0, 0xF1, 0xB8, 0xA1, 0x21, 0xF2, 0x86, 0x40, 0x00, 0x1C,
+0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF1, 0xB9, 0xA1, 0x21, 0xF2, 0x87, 0x40,
+0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF1, 0xBA, 0xA1, 0x21, 0xF2,
+0x88, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x00, 0x65, 0xA0, 0xF1, 0xBB, 0xA1,
+0x21, 0xF2, 0x89, 0x40, 0x35, 0x16, 0x6A, 0x60, 0x08, 0x32, 0xC9, 0xF7,
+0x1B, 0x6C, 0x69, 0xE2, 0x8B, 0xEC, 0x80, 0x34, 0xA6, 0x9A, 0x80, 0x34,
+0x81, 0xF4, 0x00, 0x4C, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x81, 0xF4, 0x14, 0x4C,
+0x00, 0x6D, 0xD3, 0x15, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0xAC, 0x9A, 0x7B, 0x15, 0x42, 0x9B, 0x07, 0x94,
+0x3F, 0x6B, 0x42, 0x32, 0x6C, 0xEA, 0x43, 0xEC, 0x83, 0xE2, 0x5F, 0xF6,
+0x08, 0x61, 0x00, 0x68, 0x18, 0x65, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0xAC, 0x9A, 0x4B, 0x16, 0x10, 0xF0,
+0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0x63, 0xF3, 0x00, 0x4D, 0x07, 0xF7,
+0x00, 0x6A, 0x62, 0x9D, 0x4B, 0xEA, 0x3F, 0x6C, 0x40, 0x32, 0xFF, 0x4A,
+0x0C, 0xEC, 0x4C, 0xEB, 0x80, 0x34, 0x10, 0xF0, 0x00, 0x6A, 0x4B, 0xEA,
+0x80, 0x34, 0x40, 0x32, 0x8D, 0xEB, 0x40, 0x32, 0x4D, 0xEB, 0x30, 0x17,
+0x28, 0x60, 0x08, 0x32, 0xC9, 0xF7, 0x1B, 0x6C, 0x69, 0xE2, 0x8B, 0xEC,
+0x80, 0x34, 0xA6, 0x9A, 0x80, 0x34, 0x81, 0xF4, 0x08, 0x4C, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34,
+0x80, 0x34, 0x81, 0xF4, 0x1C, 0x4C, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x6D,
+0x6C, 0x16, 0x07, 0x93, 0xFF, 0x4B, 0x66, 0x33, 0x64, 0x32, 0x69, 0xE2,
+0x01, 0x4A, 0xEE, 0x15, 0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34,
+0xAC, 0x9B, 0x80, 0x34, 0x81, 0xF4, 0x00, 0x4C, 0x97, 0x17, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0xAC, 0x9B, 0x80, 0x34, 0x81, 0xF4,
+0x08, 0x4C, 0xD9, 0x17, 0x82, 0x34, 0x1F, 0xF7, 0x00, 0x6A, 0x4C, 0xEC,
+0x82, 0x35, 0x20, 0x5D, 0x1B, 0x60, 0xAC, 0x32, 0xA9, 0xE2, 0x48, 0x32,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xA9, 0xE2, 0x63, 0xF3,
+0x00, 0x4B, 0x48, 0x32, 0x69, 0xE2, 0xE4, 0xF4, 0x58, 0x9A, 0xC9, 0xF7,
+0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x52, 0x32, 0x7F, 0x6B,
+0x60, 0xF3, 0x14, 0x4C, 0x6C, 0xEA, 0x40, 0xDC, 0x20, 0xE8, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0xCA, 0xF2, 0x4C, 0x9A,
+0xC9, 0xF7, 0x1B, 0x6C, 0x8B, 0xEC, 0x80, 0x34, 0x80, 0x34, 0x52, 0x32,
+0x7F, 0x6B, 0x60, 0xF3, 0x14, 0x4C, 0x6C, 0xEA, 0x40, 0xDC, 0x20, 0xE8,
+0x00, 0x65, 0x00, 0x00, 0xFC, 0x63, 0x04, 0xD0, 0xC9, 0xF7, 0x1B, 0x68,
+0x0B, 0xE8, 0x00, 0x30, 0x00, 0x30, 0x01, 0xF5, 0x83, 0x40, 0x06, 0x62,
+0x00, 0x1C, 0x00, 0x5C, 0x05, 0xD1, 0x08, 0x6D, 0x4D, 0xED, 0xFF, 0x69,
+0x01, 0xF5, 0x83, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x2C, 0xED, 0x01, 0xF5,
+0x83, 0x40, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65, 0xA2, 0x67, 0xF7, 0x6B,
+0x01, 0xF5, 0x83, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x6C, 0xED, 0x21, 0xF2,
+0x8D, 0x40, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65, 0xA2, 0x67, 0x3F, 0x6B,
+0x21, 0xF2, 0x8D, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x6C, 0xED, 0x21, 0xF2,
+0x8D, 0x40, 0x00, 0x1C, 0x00, 0x5C, 0x00, 0x65, 0x80, 0x6D, 0xAB, 0xED,
+0x4D, 0xED, 0x21, 0xF2, 0x8D, 0x40, 0x00, 0x1C, 0xF0, 0x5B, 0x2C, 0xED,
+0x06, 0x97, 0x05, 0x91, 0x04, 0x90, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x65,
+0x00, 0x1C, 0x2A, 0x61, 0x00, 0x65, 0x00, 0x65, 0x00, 0x1C, 0x2C, 0x61,
+0x00, 0x65, 0x00, 0x65, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x30, 0xF2, 0x63, 0x42, 0x90, 0x34, 0x80, 0xC3, 0x20, 0xF2,
+0x10, 0x4A, 0x40, 0x9A, 0x02, 0xF0, 0x00, 0x6B, 0x60, 0x33, 0xFF, 0x4B,
+0x20, 0xE8, 0x6C, 0xEA, 0xC9, 0xF7, 0x1B, 0x6A, 0x4B, 0xEA, 0xFF, 0x6D,
+0x40, 0x32, 0x8C, 0xED, 0x40, 0x32, 0x30, 0xF2, 0x83, 0x42, 0xB0, 0x33,
+0x60, 0xC4, 0x20, 0xF2, 0x10, 0x4A, 0x60, 0x9A, 0x02, 0xF0, 0x00, 0x6A,
+0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0x83, 0x67, 0x05, 0x23, 0x01, 0x6C,
+0x84, 0xED, 0xFF, 0xF7, 0x1F, 0x6A, 0x4C, 0xEC, 0x20, 0xE8, 0x44, 0x67,
+0xC9, 0xF7, 0x1B, 0x6A, 0xFB, 0x63, 0x4B, 0xEA, 0x07, 0xD1, 0x40, 0x31,
+0x08, 0x62, 0x06, 0xD0, 0x20, 0x31, 0x40, 0xF0, 0x4C, 0xA1, 0xFF, 0x6C,
+0x8C, 0xEA, 0x02, 0x72, 0x14, 0x61, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x04, 0xD2, 0x66, 0xF7, 0x56, 0xAA,
+0x01, 0x72, 0x09, 0x61, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0xEB, 0xF5, 0x4C, 0xA2, 0x04, 0x67, 0x4C, 0xE8, 0x05, 0x20, 0x08, 0x97,
+0x07, 0x91, 0x06, 0x90, 0x00, 0xEF, 0x05, 0x63, 0x00, 0x18, 0x2C, 0x61,
+0x04, 0x6C, 0x04, 0x94, 0x08, 0xF0, 0x64, 0x9C, 0x4D, 0xE3, 0x08, 0xF0,
+0x64, 0xDC, 0x00, 0x18, 0x2C, 0x61, 0x06, 0x6C, 0x04, 0x94, 0x08, 0xF0,
+0x68, 0x9C, 0x4D, 0xE3, 0x08, 0xF0, 0x68, 0xDC, 0x00, 0x18, 0x2C, 0x61,
+0x07, 0x6C, 0x04, 0x94, 0x08, 0xF0, 0x6C, 0x9C, 0x4D, 0xE3, 0x08, 0xF0,
+0x6C, 0xDC, 0x00, 0x18, 0x2C, 0x61, 0x05, 0x6C, 0x04, 0x94, 0x08, 0xF0,
+0x70, 0x9C, 0x4D, 0xE3, 0x08, 0xF0, 0x70, 0xDC, 0x00, 0x18, 0x35, 0x61,
+0x90, 0x67, 0x04, 0x6C, 0x00, 0x18, 0x35, 0x61, 0x02, 0x67, 0x4D, 0xE8,
+0xFF, 0xF7, 0x1F, 0x6A, 0x4C, 0xE8, 0x30, 0xF2, 0x63, 0x41, 0x08, 0x6A,
+0x40, 0xC3, 0xC7, 0x28, 0x40, 0xF0, 0x40, 0xA9, 0xFF, 0xF7, 0x1F, 0x6B,
+0x6C, 0xEA, 0xFB, 0xF7, 0x1F, 0x6B, 0x6C, 0xEA, 0x04, 0xF0, 0x00, 0x6B,
+0x40, 0xF0, 0x40, 0xC9, 0x6D, 0xEA, 0x40, 0xF0, 0x40, 0xC9, 0x04, 0x94,
+0xFF, 0xF7, 0x1F, 0x6A, 0x66, 0xF7, 0xB4, 0xAC, 0x01, 0x4D, 0x66, 0xF7,
+0xB4, 0xCC, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x7E, 0xF2,
+0x08, 0x4C, 0x00, 0x1C, 0x13, 0x58, 0x4C, 0xED, 0xA6, 0x17, 0x00, 0x65,
+0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF, 0x85, 0x2B, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xBF, 0x8F, 0x02, 0x80, 0x02, 0x3C,
+0xE8, 0x03, 0x03, 0x24, 0x2C, 0x5E, 0x43, 0xAC, 0x18, 0x00, 0xBD, 0x27,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x0B, 0x5E, 0x40, 0xA0, 0xFF, 0x00, 0x85, 0x30,
+0xF2, 0x5D, 0x60, 0xA0, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x05, 0x5E, 0x40, 0xA0, 0x08, 0x00, 0xA4, 0x2C, 0x07, 0x5E, 0x60, 0xA0,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x0F, 0x5E, 0x40, 0xA0,
+0xEC, 0x5D, 0x65, 0xA0, 0x2C, 0x00, 0x80, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x80, 0x10, 0x05, 0x00, 0x78, 0xF2, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x44, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24,
+0xD0, 0x1B, 0xA4, 0x8C, 0x00, 0x70, 0x02, 0x3C, 0x02, 0x00, 0x42, 0x34,
+0x25, 0x20, 0x82, 0x00, 0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x64, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0xD0, 0x1B, 0xA4, 0xAC, 0x02, 0x80, 0x05, 0x3C,
+0x60, 0x1B, 0xA5, 0x24, 0xD0, 0x1B, 0xA4, 0x8C, 0x00, 0x70, 0x02, 0x3C,
+0x02, 0x00, 0x42, 0x34, 0x27, 0x10, 0x02, 0x00, 0x24, 0x20, 0x82, 0x00,
+0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x64, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xD0, 0x1B, 0xA4, 0xAC, 0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24,
+0xD0, 0x1B, 0xA4, 0x8C, 0x00, 0x70, 0x02, 0x3C, 0x27, 0x10, 0x02, 0x00,
+0x24, 0x20, 0x82, 0x00, 0x02, 0x80, 0x07, 0x3C, 0x41, 0xB0, 0x02, 0x3C,
+0x01, 0x00, 0x03, 0x24, 0x00, 0x00, 0x44, 0xAC, 0x09, 0x5E, 0xE3, 0xA0,
+0x09, 0x5E, 0xE6, 0x90, 0x02, 0x80, 0x02, 0x3C, 0xD0, 0x1B, 0xA4, 0xAC,
+0x0A, 0x5E, 0x46, 0xA0, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x05, 0x3C, 0x60, 0x1B, 0xA5, 0x24, 0xD0, 0x1B, 0xA4, 0x8C,
+0x00, 0x70, 0x02, 0x3C, 0x27, 0x10, 0x02, 0x00, 0x24, 0x20, 0x82, 0x00,
+0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x64, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0xD0, 0x1B, 0xA4, 0xAC, 0xE0, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x10, 0x3C, 0xEC, 0x5D, 0x02, 0x92, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF, 0x21, 0x90, 0x80, 0x00,
+0x1C, 0x00, 0x40, 0x10, 0xFF, 0x00, 0xB1, 0x30, 0x02, 0x80, 0x03, 0x3C,
+0xC6, 0x5C, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x42, 0x30,
+0x1C, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x24,
+0x00, 0x02, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0xEE, 0x5D, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x0F, 0x00, 0x42, 0x30, 0x0C, 0x00, 0x42, 0x28, 0x06, 0x00, 0x40, 0x10,
+0x08, 0x00, 0x02, 0x24, 0x00, 0x00, 0x44, 0x96, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0x83, 0x30, 0x1B, 0x00, 0x62, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0xEC, 0x5D, 0x02, 0x92, 0x05, 0x00, 0x03, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x0B, 0x00, 0x43, 0x10, 0x02, 0x80, 0x03, 0x3C, 0x1C, 0x00, 0xBF, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27, 0xA8, 0x2D, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0xF1, 0x61, 0x00, 0x08, 0x00, 0x08, 0x04, 0x24,
+0x08, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x24, 0x10, 0x22, 0x02,
+0xF2, 0xFF, 0x40, 0x10, 0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x62, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x42, 0x34, 0x07, 0x5E, 0x62, 0xA0,
+0x05, 0x62, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5E, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x60, 0x14, 0x00, 0x10, 0x82, 0x34,
+0x00, 0x62, 0x00, 0x08, 0x00, 0x00, 0x42, 0xA6, 0x0C, 0x00, 0x04, 0x24,
+0x4B, 0x2E, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x00, 0x62, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x02, 0x80, 0x03, 0x3C, 0x0B, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x00, 0x40, 0x10, 0x02, 0x80, 0x04, 0x3C, 0x0B, 0x5E, 0x60, 0xA0,
+0x02, 0x80, 0x04, 0x3C, 0x07, 0x5E, 0x83, 0x90, 0xFD, 0xFF, 0x02, 0x24,
+0x24, 0x18, 0x62, 0x00, 0x07, 0x5E, 0x83, 0xA0, 0x07, 0x5E, 0x82, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x42, 0x30, 0x49, 0x00, 0x40, 0x10,
+0x02, 0x80, 0x02, 0x3C, 0x10, 0x00, 0xBF, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0xF2, 0x5D, 0x82, 0x90,
+0x02, 0x80, 0x05, 0x3C, 0x01, 0x00, 0x42, 0x24, 0xF2, 0x5D, 0x82, 0xA0,
+0x07, 0x5E, 0xA3, 0x90, 0xEF, 0xFF, 0x02, 0x24, 0x24, 0x18, 0x62, 0x00,
+0x07, 0x5E, 0xA3, 0xA0, 0xF2, 0x5D, 0x82, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0x42, 0x2C, 0x13, 0x00, 0x40, 0x14, 0x25, 0xB0, 0x06, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x10, 0x37, 0x62, 0x94, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x42, 0x30, 0x3A, 0x00, 0x40, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x0E, 0x5E, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00,
+0xE5, 0xFF, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x5E, 0x62, 0x90,
+0x10, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xBD, 0x27, 0x01, 0x00, 0x42, 0x24,
+0x0E, 0x5E, 0x62, 0xA0, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x84, 0x00, 0xC4, 0x34, 0x80, 0x00, 0xC6, 0x34, 0x00, 0x00, 0x82, 0x8C,
+0x00, 0x00, 0xC4, 0x8C, 0x02, 0x80, 0x08, 0x3C, 0x21, 0x10, 0x00, 0x00,
+0x14, 0x5E, 0x06, 0x8D, 0x42, 0xB0, 0x0A, 0x3C, 0x25, 0x10, 0x44, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x18, 0x5E, 0x88, 0x8C, 0x1C, 0x5E, 0x89, 0x8C,
+0x00, 0x00, 0x45, 0x91, 0x21, 0x10, 0x46, 0x00, 0xFB, 0xFF, 0x04, 0x24,
+0x24, 0x28, 0xA4, 0x00, 0x23, 0x40, 0x02, 0x01, 0x00, 0x00, 0x45, 0xA1,
+0x04, 0x00, 0x00, 0x11, 0x01, 0x00, 0x06, 0x24, 0x80, 0x10, 0x08, 0x00,
+0x21, 0x10, 0x48, 0x00, 0x80, 0x30, 0x02, 0x00, 0x01, 0x00, 0x04, 0x24,
+0xB9, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x42, 0xB0, 0x02, 0x3C,
+0x22, 0x00, 0x04, 0x24, 0x03, 0x00, 0x42, 0x34, 0x00, 0x00, 0x44, 0xA0,
+0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90, 0x10, 0x00, 0xBF, 0x8F,
+0x01, 0x00, 0x05, 0x24, 0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08,
+0x18, 0x00, 0xBD, 0x27, 0x05, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C,
+0xED, 0x5D, 0x64, 0x90, 0x10, 0x00, 0xBF, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0x10, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xBD, 0x27, 0x0E, 0x5E, 0x40, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27,
+0xFF, 0x00, 0xA5, 0x30, 0x10, 0x00, 0xB0, 0xAF, 0x14, 0x00, 0xBF, 0xAF,
+0x18, 0x00, 0xA0, 0x14, 0xFF, 0x00, 0x90, 0x30, 0x35, 0x00, 0x00, 0x12,
+0x01, 0x00, 0x05, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x01, 0x00, 0x05, 0x24,
+0x05, 0x5E, 0x45, 0xA0, 0x02, 0x80, 0x07, 0x3C, 0x07, 0x5E, 0xE3, 0x90,
+0x02, 0x00, 0x04, 0x24, 0x21, 0x28, 0x00, 0x00, 0x02, 0x00, 0x63, 0x34,
+0x00, 0xF0, 0x06, 0x34, 0x07, 0x5E, 0xE3, 0xA0, 0xB9, 0x20, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x42, 0xB0, 0x02, 0x3C, 0x44, 0x00, 0x03, 0x24, 0x03, 0x00, 0x42, 0x34,
+0x18, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x43, 0xA0, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x05, 0x5E, 0x44, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0x08, 0x5E, 0x65, 0x90,
+0x0F, 0x00, 0x02, 0x24, 0x02, 0x80, 0x06, 0x3C, 0x0F, 0x00, 0xA5, 0x30,
+0x0D, 0x00, 0xA2, 0x10, 0x01, 0x00, 0x04, 0x24, 0x07, 0x5E, 0xC2, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x34, 0x07, 0x5E, 0xC2, 0xA0,
+0xE1, 0x51, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xDB, 0xFF, 0x00, 0x16,
+0x02, 0x80, 0x02, 0x3C, 0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x18, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C,
+0x04, 0x5E, 0x43, 0x90, 0x01, 0x00, 0x04, 0x24, 0xF6, 0xFF, 0x60, 0x10,
+0x01, 0x00, 0x05, 0x24, 0xC8, 0x51, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xB9, 0x62, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x05, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xFF, 0x00, 0x84, 0x30,
+0x4B, 0x2E, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27,
+0xFF, 0x00, 0xA5, 0x30, 0x14, 0x00, 0xB1, 0xAF, 0x18, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x03, 0x00, 0xA0, 0x14, 0xFF, 0x00, 0x91, 0x30,
+0x3A, 0x00, 0x20, 0x12, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x10, 0x3C,
+0x07, 0x5E, 0x02, 0x92, 0xFB, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x07, 0x5E, 0x02, 0xA2, 0x10, 0x00, 0xA0, 0x14, 0x02, 0x80, 0x03, 0x3C,
+0x07, 0x5E, 0x02, 0x92, 0xFE, 0xFF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00,
+0x07, 0x5E, 0x02, 0xA2, 0x19, 0x00, 0x20, 0x16, 0x02, 0x80, 0x02, 0x3C,
+0x07, 0x5E, 0x02, 0x92, 0xFD, 0xFF, 0x03, 0x24, 0x18, 0x00, 0xBF, 0x8F,
+0x24, 0x10, 0x43, 0x00, 0x07, 0x5E, 0x02, 0xA2, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x01, 0x00, 0x04, 0x24, 0x05, 0x5E, 0x64, 0xA0, 0x07, 0x5E, 0x02, 0x92,
+0x02, 0x80, 0x03, 0x3C, 0x01, 0x00, 0x42, 0x34, 0x07, 0x5E, 0x02, 0xA2,
+0x06, 0x5E, 0x62, 0x90, 0x02, 0x00, 0x03, 0x24, 0xFF, 0x00, 0x42, 0x30,
+0x23, 0x00, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x51, 0x00, 0x0C,
+0x01, 0x00, 0x04, 0x24, 0xE9, 0xFF, 0x20, 0x12, 0x02, 0x80, 0x02, 0x3C,
+0x01, 0x00, 0x04, 0x24, 0x05, 0x5E, 0x44, 0xA0, 0x07, 0x5E, 0x03, 0x92,
+0x02, 0x00, 0x04, 0x24, 0x21, 0x28, 0x00, 0x00, 0x02, 0x00, 0x63, 0x34,
+0x00, 0xF0, 0x06, 0x34, 0x07, 0x5E, 0x03, 0xA2, 0xB9, 0x20, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xBF, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x42, 0xB0, 0x02, 0x3C, 0x44, 0x00, 0x03, 0x24,
+0x03, 0x00, 0x42, 0x34, 0x20, 0x00, 0xBD, 0x27, 0x00, 0x00, 0x43, 0xA0,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x05, 0x5E, 0x40, 0xA0,
+0x02, 0x80, 0x03, 0x3C, 0xED, 0x5D, 0x64, 0x90, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x05, 0x24,
+0xFF, 0x00, 0x84, 0x30, 0x4B, 0x2E, 0x00, 0x08, 0x20, 0x00, 0xBD, 0x27,
+0xE2, 0x2C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x04, 0x24,
+0x4B, 0x2E, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0xE5, 0x62, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB2, 0xAF,
+0x0C, 0x00, 0xB1, 0xAF, 0x08, 0x00, 0xB0, 0xAF, 0x21, 0x40, 0xE0, 0x00,
+0x21, 0x90, 0xA0, 0x03, 0x21, 0x60, 0xC0, 0x00, 0x21, 0x78, 0x80, 0x00,
+0x45, 0x00, 0xE0, 0x14, 0x21, 0x50, 0xA0, 0x00, 0x2B, 0x10, 0xA6, 0x00,
+0x78, 0x00, 0x40, 0x10, 0xFF, 0xFF, 0x02, 0x34, 0x2B, 0x10, 0x46, 0x00,
+0x8F, 0x01, 0x40, 0x10, 0x21, 0x28, 0xC0, 0x00, 0xFF, 0x00, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x10, 0x00, 0x03, 0x24, 0x2B, 0x10, 0x46, 0x00,
+0x18, 0x00, 0x04, 0x24, 0x21, 0x30, 0x60, 0x00, 0x0B, 0x30, 0x82, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x06, 0x10, 0xC5, 0x00, 0x98, 0xF2, 0x63, 0x24,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x90, 0x20, 0x00, 0x02, 0x24,
+0x21, 0x20, 0x86, 0x00, 0x23, 0x30, 0x44, 0x00, 0x08, 0x00, 0xC0, 0x10,
+0x02, 0x4C, 0x0C, 0x00, 0x23, 0x10, 0x46, 0x00, 0x06, 0x10, 0x4F, 0x00,
+0x04, 0x18, 0xCA, 0x00, 0x25, 0x50, 0x62, 0x00, 0x04, 0x60, 0xCC, 0x00,
+0x04, 0x78, 0xCF, 0x00, 0x02, 0x4C, 0x0C, 0x00, 0x1B, 0x00, 0x49, 0x01,
+0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00,
+0xFF, 0xFF, 0x87, 0x31, 0x02, 0x24, 0x0F, 0x00, 0x12, 0x18, 0x00, 0x00,
+0x10, 0x28, 0x00, 0x00, 0x00, 0x14, 0x05, 0x00, 0x25, 0x28, 0x44, 0x00,
+0x18, 0x00, 0x67, 0x00, 0x12, 0x58, 0x00, 0x00, 0x2B, 0x18, 0xAB, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x49, 0x01, 0x02, 0x00, 0x20, 0x15,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00, 0x08, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0xAC, 0x00, 0x2B, 0x10, 0xAC, 0x00,
+0x04, 0x00, 0x40, 0x14, 0x2B, 0x10, 0xAB, 0x00, 0x00, 0x00, 0x42, 0x38,
+0x21, 0x18, 0xAC, 0x00, 0x0B, 0x28, 0x62, 0x00, 0x23, 0x28, 0xAB, 0x00,
+0x1B, 0x00, 0xA9, 0x00, 0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0xE4, 0x31, 0x12, 0x18, 0x00, 0x00,
+0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x63, 0x00, 0x08,
+0x18, 0x00, 0x67, 0x00, 0x2B, 0x10, 0xA7, 0x00, 0x0A, 0x00, 0x40, 0x10,
+0xFF, 0xFF, 0x02, 0x34, 0x10, 0x00, 0xB2, 0x8F, 0x0C, 0x00, 0xB1, 0x8F,
+0x08, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x80, 0x00, 0x21, 0x18, 0xA0, 0x00,
+0x00, 0x00, 0xA4, 0xAF, 0x04, 0x00, 0xA5, 0xAF, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x2B, 0x10, 0x47, 0x00, 0xD2, 0x00, 0x40, 0x10,
+0x00, 0x01, 0xE3, 0x2C, 0xFF, 0x00, 0x02, 0x3C, 0x10, 0x00, 0x03, 0x24,
+0xFF, 0xFF, 0x42, 0x34, 0x2B, 0x10, 0x47, 0x00, 0x18, 0x00, 0x04, 0x24,
+0x21, 0x28, 0x60, 0x00, 0x0B, 0x28, 0x82, 0x00, 0x06, 0x10, 0xA8, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x98, 0xF2, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x44, 0x90, 0x20, 0x00, 0x02, 0x24, 0x21, 0x20, 0x85, 0x00,
+0x23, 0x30, 0x44, 0x00, 0xCE, 0x00, 0xC0, 0x14, 0x23, 0x38, 0x46, 0x00,
+0x2B, 0x10, 0x0A, 0x01, 0x04, 0x00, 0x40, 0x14, 0x23, 0x20, 0xEC, 0x01,
+0x2B, 0x10, 0xEC, 0x01, 0x05, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0xE4, 0x01, 0x23, 0x18, 0x48, 0x01, 0x23, 0x50, 0x62, 0x00,
+0x21, 0x78, 0x80, 0x00, 0x04, 0x00, 0x40, 0x12, 0x21, 0xC0, 0xE0, 0x01,
+0x21, 0xC8, 0x40, 0x01, 0x00, 0x00, 0x58, 0xAE, 0x04, 0x00, 0x59, 0xAE,
+0x00, 0x00, 0xA2, 0x8F, 0x04, 0x00, 0xA3, 0x8F, 0x10, 0x00, 0xB2, 0x8F,
+0x0C, 0x00, 0xB1, 0x8F, 0x08, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x53, 0x00, 0xC0, 0x10, 0x01, 0x00, 0x02, 0x24,
+0xFF, 0xFF, 0x02, 0x34, 0x2B, 0x10, 0x4C, 0x00, 0x59, 0x00, 0x40, 0x14,
+0xFF, 0x00, 0x02, 0x3C, 0x00, 0x01, 0x83, 0x2D, 0x08, 0x00, 0x02, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x0A, 0x28, 0x43, 0x00, 0x06, 0x10, 0xAC, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x98, 0xF2, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x44, 0x90, 0x20, 0x00, 0x02, 0x24, 0x21, 0x20, 0x85, 0x00,
+0x23, 0x30, 0x44, 0x00, 0x5B, 0x00, 0xC0, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x23, 0x50, 0x4C, 0x01, 0x02, 0x4C, 0x0C, 0x00, 0xFF, 0xFF, 0x8D, 0x31,
+0x1B, 0x00, 0x49, 0x01, 0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0x02, 0x24, 0x0F, 0x00, 0x12, 0x18, 0x00, 0x00,
+0x10, 0x28, 0x00, 0x00, 0x00, 0x14, 0x05, 0x00, 0x25, 0x28, 0x44, 0x00,
+0x18, 0x00, 0x6D, 0x00, 0x12, 0x58, 0x00, 0x00, 0x2B, 0x18, 0xAB, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x49, 0x01, 0x02, 0x00, 0x20, 0x15,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00, 0x08, 0x00, 0x60, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0xAC, 0x00, 0x2B, 0x10, 0xAC, 0x00,
+0x04, 0x00, 0x40, 0x14, 0x2B, 0x10, 0xAB, 0x00, 0x00, 0x00, 0x42, 0x38,
+0x21, 0x18, 0xAC, 0x00, 0x0B, 0x28, 0x62, 0x00, 0x23, 0x28, 0xAB, 0x00,
+0x1B, 0x00, 0xA9, 0x00, 0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0xE4, 0x31, 0x12, 0x18, 0x00, 0x00,
+0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x00, 0x6D, 0x00, 0x00, 0x14, 0x08, 0x00, 0x12, 0x58, 0x00, 0x00,
+0x25, 0x40, 0x44, 0x00, 0x2B, 0x18, 0x0B, 0x01, 0x1B, 0x00, 0xA9, 0x00,
+0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00,
+0x08, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x21, 0x40, 0x0C, 0x01,
+0x2B, 0x10, 0x0C, 0x01, 0x04, 0x00, 0x40, 0x14, 0x2B, 0x10, 0x0B, 0x01,
+0x21, 0x18, 0x0C, 0x01, 0x00, 0x00, 0x42, 0x38, 0x0B, 0x40, 0x62, 0x00,
+0xAB, 0xFF, 0x40, 0x12, 0x23, 0x78, 0x0B, 0x01, 0x06, 0xC0, 0xCF, 0x00,
+0x21, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x58, 0xAE, 0xA1, 0x63, 0x00, 0x08,
+0x04, 0x00, 0x59, 0xAE, 0x1B, 0x00, 0x47, 0x00, 0x02, 0x00, 0xE0, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0x02, 0x34,
+0x12, 0x60, 0x00, 0x00, 0x2B, 0x10, 0x4C, 0x00, 0xAB, 0xFF, 0x40, 0x10,
+0x00, 0x01, 0x83, 0x2D, 0xFF, 0x00, 0x02, 0x3C, 0x10, 0x00, 0x03, 0x24,
+0xFF, 0xFF, 0x42, 0x34, 0x2B, 0x10, 0x4C, 0x00, 0x18, 0x00, 0x04, 0x24,
+0x21, 0x28, 0x60, 0x00, 0x0B, 0x28, 0x82, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x06, 0x10, 0xAC, 0x00, 0x98, 0xF2, 0x63, 0x24, 0x21, 0x10, 0x43, 0x00,
+0x00, 0x00, 0x44, 0x90, 0x20, 0x00, 0x02, 0x24, 0x21, 0x20, 0x85, 0x00,
+0x23, 0x30, 0x44, 0x00, 0xA7, 0xFF, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x23, 0x38, 0x46, 0x00, 0x04, 0x60, 0xCC, 0x00, 0x06, 0x58, 0xEA, 0x00,
+0x02, 0x4C, 0x0C, 0x00, 0x1B, 0x00, 0x69, 0x01, 0x02, 0x00, 0x20, 0x15,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0x8D, 0x31,
+0x06, 0x18, 0xEF, 0x00, 0x04, 0x10, 0xCA, 0x00, 0x25, 0x50, 0x43, 0x00,
+0x02, 0x24, 0x0A, 0x00, 0x12, 0x28, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
+0x00, 0x14, 0x08, 0x00, 0x25, 0x40, 0x44, 0x00, 0x18, 0x00, 0xAD, 0x00,
+0x12, 0x28, 0x00, 0x00, 0x2B, 0x18, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
+0x1B, 0x00, 0x69, 0x01, 0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0x05, 0x00, 0x60, 0x10, 0x04, 0x78, 0xCF, 0x00,
+0x21, 0x40, 0x0C, 0x01, 0x2B, 0x10, 0x0C, 0x01, 0x93, 0x00, 0x40, 0x10,
+0x2B, 0x10, 0x05, 0x01, 0x23, 0x40, 0x05, 0x01, 0x1B, 0x00, 0x09, 0x01,
+0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00,
+0xFF, 0xFF, 0x44, 0x31, 0x12, 0x18, 0x00, 0x00, 0x10, 0x58, 0x00, 0x00,
+0x00, 0x14, 0x0B, 0x00, 0x25, 0x58, 0x44, 0x00, 0x18, 0x00, 0x6D, 0x00,
+0x12, 0x28, 0x00, 0x00, 0x2B, 0x18, 0x65, 0x01, 0x00, 0x00, 0x00, 0x00,
+0x1B, 0x00, 0x09, 0x01, 0x02, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0x77, 0xFF, 0x60, 0x10, 0x23, 0x50, 0x65, 0x01,
+0x21, 0x58, 0x6C, 0x01, 0x2B, 0x10, 0x6C, 0x01, 0x04, 0x00, 0x40, 0x14,
+0x2B, 0x10, 0x65, 0x01, 0x00, 0x00, 0x42, 0x38, 0x21, 0x18, 0x6C, 0x01,
+0x0B, 0x58, 0x62, 0x00, 0xBF, 0x63, 0x00, 0x08, 0x23, 0x50, 0x65, 0x01,
+0x08, 0x00, 0x02, 0x24, 0x21, 0x28, 0x00, 0x00, 0x0A, 0x28, 0x43, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x06, 0x10, 0xA8, 0x00, 0x98, 0xF2, 0x63, 0x24,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x90, 0x20, 0x00, 0x02, 0x24,
+0x21, 0x20, 0x85, 0x00, 0x23, 0x30, 0x44, 0x00, 0x34, 0xFF, 0xC0, 0x10,
+0x23, 0x38, 0x46, 0x00, 0x06, 0x10, 0xEC, 0x00, 0x04, 0x18, 0xC8, 0x00,
+0x25, 0x40, 0x62, 0x00, 0x06, 0x58, 0xEA, 0x00, 0x02, 0x6C, 0x08, 0x00,
+0x1B, 0x00, 0x6D, 0x01, 0x02, 0x00, 0xA0, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0x11, 0x31, 0x06, 0x10, 0xEF, 0x00,
+0x04, 0x18, 0xCA, 0x00, 0x25, 0x50, 0x62, 0x00, 0x02, 0x24, 0x0A, 0x00,
+0x04, 0x60, 0xCC, 0x00, 0x12, 0x80, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00,
+0x00, 0x14, 0x09, 0x00, 0x25, 0x48, 0x44, 0x00, 0x12, 0x28, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x11, 0x02,
+0x12, 0x70, 0x00, 0x00, 0x2B, 0x18, 0x2E, 0x01, 0x00, 0x00, 0x00, 0x00,
+0x1B, 0x00, 0x6D, 0x01, 0x02, 0x00, 0xA0, 0x15, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x07, 0x00, 0x0A, 0x00, 0x60, 0x10, 0x04, 0x78, 0xCF, 0x00,
+0x21, 0x48, 0x28, 0x01, 0x2B, 0x10, 0x28, 0x01, 0x06, 0x00, 0x40, 0x14,
+0xFF, 0xFF, 0xB0, 0x24, 0x2B, 0x10, 0x2E, 0x01, 0x03, 0x00, 0x40, 0x10,
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0x26, 0x21, 0x48, 0x28, 0x01,
+0x23, 0x48, 0x2E, 0x01, 0x1B, 0x00, 0x2D, 0x01, 0x02, 0x00, 0xA0, 0x15,
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0x44, 0x31,
+0x12, 0x28, 0x00, 0x00, 0x10, 0x58, 0x00, 0x00, 0x00, 0x14, 0x0B, 0x00,
+0x25, 0x58, 0x44, 0x00, 0x18, 0x00, 0xB1, 0x00, 0x12, 0x70, 0x00, 0x00,
+0x2B, 0x18, 0x6E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x2D, 0x01,
+0x02, 0x00, 0xA0, 0x15, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x07, 0x00,
+0x0B, 0x00, 0x60, 0x10, 0x00, 0x14, 0x10, 0x00, 0x21, 0x58, 0x68, 0x01,
+0x2B, 0x10, 0x68, 0x01, 0x06, 0x00, 0x40, 0x14, 0xFF, 0xFF, 0xA5, 0x24,
+0x2B, 0x10, 0x6E, 0x01, 0x04, 0x00, 0x40, 0x10, 0x00, 0x14, 0x10, 0x00,
+0xFF, 0xFF, 0xA5, 0x24, 0x21, 0x58, 0x68, 0x01, 0x00, 0x14, 0x10, 0x00,
+0x25, 0x10, 0x45, 0x00, 0x23, 0x58, 0x6E, 0x01, 0x19, 0x00, 0x4C, 0x00,
+0x10, 0x28, 0x00, 0x00, 0x2B, 0x18, 0x65, 0x01, 0x12, 0x48, 0x00, 0x00,
+0x05, 0x00, 0x60, 0x14, 0x23, 0x20, 0x2C, 0x01, 0x07, 0x00, 0xAB, 0x14,
+0x2B, 0x10, 0xE9, 0x01, 0x05, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
+0x2B, 0x10, 0x24, 0x01, 0x23, 0x18, 0xA8, 0x00, 0x23, 0x28, 0x62, 0x00,
+0x21, 0x48, 0x80, 0x00, 0xEA, 0xFE, 0x40, 0x12, 0x23, 0x18, 0xE9, 0x01,
+0x23, 0x20, 0x65, 0x01, 0x2B, 0x10, 0xE3, 0x01, 0x23, 0x50, 0x82, 0x00,
+0x04, 0x28, 0xEA, 0x00, 0x06, 0x18, 0xC3, 0x00, 0x25, 0xC0, 0xA3, 0x00,
+0x06, 0xC8, 0xCA, 0x00, 0x00, 0x00, 0x58, 0xAE, 0xA1, 0x63, 0x00, 0x08,
+0x04, 0x00, 0x59, 0xAE, 0x00, 0x01, 0xC3, 0x2C, 0x08, 0x00, 0x02, 0x24,
+0x21, 0x30, 0x00, 0x00, 0x3B, 0x63, 0x00, 0x08, 0x0A, 0x30, 0x43, 0x00,
+0x00, 0x00, 0x42, 0x38, 0x21, 0x18, 0x0C, 0x01, 0x35, 0x64, 0x00, 0x08,
+0x0B, 0x40, 0x62, 0x00, 0x25, 0xB0, 0x03, 0x3C, 0x4D, 0x00, 0x64, 0x34,
+0xF1, 0x02, 0x65, 0x34, 0x08, 0x00, 0x02, 0x24, 0x00, 0x00, 0x80, 0xA0,
+0xEC, 0x02, 0x66, 0x34, 0x00, 0x00, 0xA2, 0xA0, 0xF0, 0x02, 0x63, 0x34,
+0xFF, 0x00, 0x02, 0x3C, 0x00, 0x00, 0x60, 0xA0, 0x00, 0x00, 0xC2, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x60, 0x93, 0x63, 0x24, 0x18, 0x03, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x7F, 0x00, 0x02, 0x3C, 0x0D, 0xB8, 0x44, 0x34, 0x80, 0x04, 0x03, 0x3C,
+0x25, 0x20, 0x83, 0x00, 0x00, 0x08, 0x02, 0x3C, 0x25, 0x20, 0x82, 0x00,
+0x00, 0x30, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0x25, 0x20, 0x83, 0x00, 0x41, 0xB0, 0x03, 0x3C, 0x00, 0x00, 0x64, 0xAC,
+0xD8, 0x1B, 0x44, 0xAC, 0xD0, 0x1B, 0x44, 0xAC, 0x08, 0x00, 0x63, 0x34,
+0x86, 0x00, 0x04, 0x24, 0x00, 0x00, 0x64, 0xA4, 0xDC, 0x1B, 0x44, 0xA4,
+0xD4, 0x1B, 0x40, 0xAC, 0xDE, 0x1B, 0x40, 0xA4, 0x08, 0x00, 0xE0, 0x03,
+0xE0, 0x1B, 0x44, 0xA4, 0xF5, 0x64, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x42, 0xB0, 0x03, 0x3C, 0x01, 0x00, 0x63, 0x34, 0x02, 0x00, 0x02, 0x24,
+0xE8, 0xFF, 0xBD, 0x27, 0x00, 0x00, 0x62, 0xA0, 0x10, 0x00, 0xBF, 0xAF,
+0x85, 0x2B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x00, 0x00,
+0x01, 0x00, 0x05, 0x24, 0xB9, 0x20, 0x00, 0x0C, 0x00, 0x50, 0x06, 0x24,
+0x1F, 0x00, 0x06, 0x3C, 0x10, 0x00, 0xBF, 0x8F, 0x00, 0x40, 0xC6, 0x34,
+0x03, 0x00, 0x04, 0x24, 0x01, 0x00, 0x05, 0x24, 0xB9, 0x20, 0x00, 0x08,
+0x18, 0x00, 0xBD, 0x27, 0x25, 0xB0, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xC8, 0xFF, 0xBD, 0x27, 0x18, 0x03, 0x64, 0x34, 0x28, 0x94, 0x42, 0x24,
+0x00, 0x00, 0x82, 0xAC, 0x30, 0x00, 0xBE, 0xAF, 0x2C, 0x00, 0xB7, 0xAF,
+0x28, 0x00, 0xB6, 0xAF, 0x24, 0x00, 0xB5, 0xAF, 0x20, 0x00, 0xB4, 0xAF,
+0x1C, 0x00, 0xB3, 0xAF, 0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF,
+0x34, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF, 0xB6, 0x00, 0x63, 0x34,
+0x00, 0x00, 0x64, 0x90, 0x02, 0x80, 0x03, 0x3C, 0x60, 0x1B, 0x62, 0x24,
+0x48, 0x01, 0x03, 0x24, 0x70, 0x37, 0x43, 0xAC, 0x6C, 0x37, 0x43, 0xAC,
+0xAB, 0x1B, 0x44, 0xA0, 0xC6, 0x3D, 0x40, 0xA0, 0x66, 0x37, 0x40, 0xA0,
+0x84, 0x6C, 0x00, 0x0C, 0x21, 0x98, 0x40, 0x00, 0xFD, 0xFF, 0x02, 0x3C,
+0xFB, 0xFF, 0x03, 0x3C, 0x21, 0xA0, 0x60, 0x02, 0xFF, 0xFF, 0x55, 0x34,
+0xFF, 0xFF, 0x76, 0x34, 0x21, 0x88, 0x00, 0x00, 0x02, 0x80, 0x1E, 0x3C,
+0x02, 0x80, 0x17, 0x3C, 0x21, 0x90, 0x60, 0x02, 0x40, 0x10, 0x11, 0x00,
+0x21, 0x10, 0x51, 0x00, 0x00, 0x11, 0x02, 0x00, 0x21, 0x10, 0x53, 0x00,
+0xD4, 0x1D, 0x42, 0x24, 0x07, 0x00, 0x03, 0x24, 0xFF, 0xFF, 0x63, 0x24,
+0x00, 0x00, 0x40, 0xA4, 0xFD, 0xFF, 0x61, 0x04, 0x02, 0x00, 0x42, 0x24,
+0xC0, 0x80, 0x11, 0x00, 0x34, 0x3F, 0xC4, 0x27, 0x21, 0x20, 0x04, 0x02,
+0x21, 0x28, 0x00, 0x00, 0x02, 0x00, 0x06, 0x24, 0xE4, 0x1D, 0x40, 0xA6,
+0xEC, 0x54, 0x00, 0x0C, 0xE6, 0x1D, 0x40, 0xA2, 0x21, 0x20, 0x13, 0x02,
+0xD4, 0x23, 0x83, 0x8C, 0xD2, 0x5C, 0xE7, 0x92, 0xBF, 0xFF, 0x02, 0x24,
+0x24, 0x28, 0x62, 0x00, 0x01, 0x00, 0x02, 0x24, 0x63, 0x00, 0xE2, 0x10,
+0x80, 0x07, 0xA6, 0x34, 0xFF, 0xF7, 0x03, 0x24, 0x24, 0x10, 0xC3, 0x00,
+0xFF, 0xEF, 0x03, 0x24, 0x24, 0x10, 0x43, 0x00, 0xD4, 0x23, 0x82, 0xAC,
+0x21, 0x30, 0x14, 0x02, 0xD4, 0x23, 0xC4, 0x8C, 0xE7, 0xFF, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x24, 0x20, 0x95, 0x00, 0x24, 0x20, 0x96, 0x00,
+0xFF, 0xFD, 0x03, 0x3C, 0x24, 0x20, 0x82, 0x00, 0xFF, 0xFF, 0x63, 0x34,
+0xFF, 0xFB, 0x02, 0x3C, 0x24, 0x20, 0x83, 0x00, 0xD8, 0x23, 0xC5, 0x8C,
+0xFF, 0xFF, 0x42, 0x34, 0xFF, 0xE7, 0x03, 0x3C, 0x24, 0x20, 0x82, 0x00,
+0xFF, 0xFF, 0x63, 0x34, 0xFF, 0xFF, 0x02, 0x3C, 0x24, 0x20, 0x83, 0x00,
+0xFF, 0x7F, 0x42, 0x34, 0xC0, 0xFF, 0x03, 0x24, 0x24, 0x28, 0xA2, 0x00,
+0x24, 0x20, 0x83, 0x00, 0x1F, 0x00, 0x02, 0x3C, 0x01, 0x00, 0x31, 0x26,
+0x25, 0x28, 0xA2, 0x00, 0x08, 0x00, 0x84, 0x34, 0x20, 0x00, 0x22, 0x2A,
+0xD4, 0x23, 0xC4, 0xAC, 0xD8, 0x23, 0xC5, 0xAC, 0xC3, 0xFF, 0x40, 0x14,
+0x30, 0x00, 0x52, 0x26, 0x25, 0xB0, 0x02, 0x3C, 0x10, 0x00, 0x03, 0x24,
+0xB0, 0x03, 0x42, 0x34, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x43, 0xAC,
+0x88, 0x1E, 0x84, 0x24, 0x21, 0x28, 0x00, 0x00, 0xEC, 0x54, 0x00, 0x0C,
+0x20, 0x00, 0x06, 0x24, 0x02, 0x80, 0x02, 0x3C, 0xD1, 0x5C, 0x43, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x60, 0x10, 0x02, 0x80, 0x03, 0x3C,
+0x60, 0x1B, 0x62, 0x24, 0x25, 0x03, 0x40, 0xA0, 0xC2, 0x6F, 0x00, 0x74,
+0x24, 0x03, 0x40, 0xA0, 0xD8, 0x70, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x47, 0x6C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0xBF, 0x8F,
+0x30, 0x00, 0xBE, 0x8F, 0x2C, 0x00, 0xB7, 0x8F, 0x28, 0x00, 0xB6, 0x8F,
+0x24, 0x00, 0xB5, 0x8F, 0x20, 0x00, 0xB4, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x02, 0x80, 0x09, 0x3C, 0x02, 0x80, 0x0A, 0x3C, 0x02, 0x80, 0x0B, 0x3C,
+0x02, 0x80, 0x0C, 0x3C, 0x02, 0x80, 0x0D, 0x3C, 0x02, 0x80, 0x0E, 0x3C,
+0x02, 0x80, 0x0F, 0x3C, 0x88, 0x54, 0x22, 0x25, 0x90, 0x54, 0x43, 0x25,
+0x98, 0x54, 0x64, 0x25, 0xA0, 0x54, 0x85, 0x25, 0xA8, 0x54, 0xA6, 0x25,
+0xB0, 0x54, 0xC7, 0x25, 0xB8, 0x54, 0xE8, 0x25, 0x38, 0x00, 0xBD, 0x27,
+0x04, 0x00, 0x42, 0xAC, 0x88, 0x54, 0x22, 0xAD, 0x04, 0x00, 0x63, 0xAC,
+0x90, 0x54, 0x43, 0xAD, 0x04, 0x00, 0x84, 0xAC, 0x98, 0x54, 0x64, 0xAD,
+0x04, 0x00, 0xA5, 0xAC, 0xA0, 0x54, 0x85, 0xAD, 0x04, 0x00, 0xC6, 0xAC,
+0xA8, 0x54, 0xA6, 0xAD, 0x04, 0x00, 0xE7, 0xAC, 0xB0, 0x54, 0xC7, 0xAD,
+0xB8, 0x54, 0xE8, 0xAD, 0x08, 0x00, 0xE0, 0x03, 0x04, 0x00, 0x08, 0xAD,
+0x02, 0x80, 0x02, 0x3C, 0xD3, 0x5C, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x9C, 0xFF, 0x67, 0x14, 0x80, 0x0F, 0xA2, 0x34, 0xFF, 0xF7, 0x03, 0x24,
+0x24, 0x10, 0xC3, 0x00, 0x4D, 0x65, 0x00, 0x08, 0x00, 0x10, 0x42, 0x34,
+0x7A, 0x6D, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x6F, 0x00, 0x74,
+0x24, 0x39, 0x80, 0xAE, 0x26, 0x70, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0xC6, 0x5C, 0x64, 0x90, 0x92, 0x00, 0x02, 0x24,
+0x03, 0x00, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00, 0x60, 0x70, 0x00, 0x74,
+0x00, 0x00, 0x00, 0x00, 0xC1, 0x70, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00,
+0x7B, 0x65, 0x00, 0x08, 0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0xC8, 0xFF, 0xBD, 0x27, 0x14, 0x97, 0x63, 0x24,
+0x18, 0x03, 0x42, 0x34, 0x18, 0x00, 0xB0, 0xAF, 0x34, 0x00, 0xBF, 0xAF,
+0x30, 0x00, 0xB6, 0xAF, 0x2C, 0x00, 0xB5, 0xAF, 0x28, 0x00, 0xB4, 0xAF,
+0x24, 0x00, 0xB3, 0xAF, 0x20, 0x00, 0xB2, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x00, 0x00, 0x43, 0xAC, 0x21, 0x80, 0x00, 0x00, 0x01, 0x00, 0x02, 0x26,
+0xFF, 0xFF, 0x50, 0x30, 0x64, 0x00, 0x03, 0x2E, 0xFD, 0xFF, 0x60, 0x14,
+0x01, 0x00, 0x02, 0x26, 0x64, 0x40, 0x00, 0x0C, 0x02, 0x80, 0x14, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xC3, 0x5C, 0x68, 0x90, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xC0, 0x5C, 0x4B, 0x94, 0xDB, 0x5C, 0x6A, 0x90,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0xE2, 0x5C, 0x67, 0x90,
+0xD0, 0x5C, 0x49, 0x90, 0xC2, 0x5C, 0x83, 0x92, 0x02, 0x80, 0x0C, 0x3C,
+0x02, 0x80, 0x02, 0x3C, 0xDD, 0x5C, 0x46, 0x90, 0xE0, 0x5C, 0x85, 0x91,
+0x25, 0xB0, 0x04, 0x3C, 0xB0, 0x03, 0x82, 0x34, 0x00, 0x00, 0x4B, 0xAC,
+0x00, 0x00, 0x48, 0xAC, 0x00, 0x00, 0x49, 0xAC, 0x00, 0x00, 0x43, 0xAC,
+0x02, 0x80, 0x03, 0x3C, 0x00, 0x00, 0x4A, 0xAC, 0x0A, 0x00, 0x88, 0x34,
+0x00, 0x00, 0x46, 0xAC, 0x00, 0x00, 0x45, 0xAC, 0x00, 0x00, 0x47, 0xAC,
+0x0C, 0x5D, 0x60, 0xA4, 0x00, 0x00, 0x06, 0x91, 0x02, 0x80, 0x02, 0x3C,
+0x0B, 0x00, 0x04, 0x24, 0x02, 0x80, 0x13, 0x3C, 0xCD, 0x5C, 0x44, 0xA0,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x65, 0x26, 0x00, 0x70, 0x03, 0x24,
+0xF0, 0x5C, 0x40, 0xA0, 0xF0, 0xFF, 0x02, 0x24, 0x01, 0x00, 0x07, 0x24,
+0x02, 0x80, 0x16, 0x3C, 0xAC, 0x1B, 0xA3, 0xA4, 0xAA, 0x1B, 0xA2, 0xA0,
+0xFF, 0x07, 0x03, 0x24, 0xFF, 0xFF, 0x02, 0x24, 0x20, 0x00, 0xC6, 0x30,
+0xE0, 0x5C, 0x87, 0xA1, 0xA8, 0x1B, 0xA7, 0xA0, 0xAE, 0x1B, 0xA3, 0xA4,
+0x48, 0xF5, 0xC2, 0xA2, 0x9A, 0x00, 0xC0, 0x10, 0xB0, 0x1B, 0xA0, 0xA4,
+0x00, 0x00, 0x02, 0x91, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x42, 0x30,
+0x0B, 0x01, 0x40, 0x14, 0x02, 0x80, 0x15, 0x3C, 0x21, 0x80, 0x00, 0x00,
+0x21, 0x88, 0x00, 0x00, 0x98, 0xF3, 0xB2, 0x26, 0xFF, 0x00, 0x24, 0x32,
+0xCF, 0x59, 0x00, 0x0C, 0x21, 0x28, 0x12, 0x02, 0x08, 0x00, 0x03, 0x26,
+0xFF, 0xFF, 0x70, 0x30, 0x01, 0x00, 0x22, 0x26, 0x80, 0x00, 0x03, 0x2E,
+0xF8, 0xFF, 0x60, 0x14, 0xFF, 0xFF, 0x51, 0x30, 0xC2, 0x5C, 0x83, 0x92,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x62, 0x30, 0xCA, 0x00, 0x40, 0x14,
+0x04, 0x00, 0x62, 0x30, 0x83, 0x00, 0x40, 0x10, 0x25, 0xB0, 0x03, 0x3C,
+0x25, 0xB0, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0x50, 0x00, 0x84, 0x34,
+0xE7, 0xF3, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24,
+0x98, 0xF3, 0xA3, 0x26, 0x7B, 0x00, 0x67, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x02, 0x00, 0xE2, 0x2C, 0x04, 0x00, 0x40, 0x14, 0x02, 0x00, 0x0B, 0x24,
+0x79, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x4B, 0x30,
+0x04, 0x00, 0xE2, 0x2C, 0xEC, 0x00, 0x40, 0x10, 0x98, 0xF3, 0xA2, 0x26,
+0x60, 0x1B, 0x62, 0x8E, 0xBF, 0xFF, 0x03, 0x24, 0x02, 0x80, 0x12, 0x3C,
+0x24, 0x10, 0x43, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x4A, 0xF5, 0x60, 0xA0,
+0x60, 0x1B, 0x62, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0xCF, 0x5C, 0x43, 0x90,
+0x01, 0x00, 0x02, 0x24, 0x02, 0x00, 0x62, 0x10, 0xFC, 0xFF, 0x08, 0x24,
+0x21, 0x40, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x98, 0xF3, 0x4A, 0x24, 0x60, 0x1B, 0x69, 0x24, 0x21, 0x60, 0x00, 0x00,
+0x21, 0x80, 0x00, 0x00, 0x01, 0x00, 0x02, 0x26, 0x21, 0x30, 0x30, 0x01,
+0x03, 0x00, 0x03, 0x2E, 0x08, 0x00, 0x04, 0x2E, 0xFF, 0xFF, 0x50, 0x30,
+0x0E, 0x00, 0x07, 0x2E, 0x04, 0x00, 0x60, 0x14, 0x21, 0x88, 0x00, 0x00,
+0x01, 0x00, 0x11, 0x24, 0x02, 0x00, 0x02, 0x24, 0x0A, 0x88, 0x44, 0x00,
+0x21, 0x10, 0x51, 0x01, 0x61, 0x00, 0x43, 0x90, 0x55, 0x00, 0x44, 0x90,
+0x5B, 0x00, 0x45, 0x90, 0x21, 0x18, 0x03, 0x01, 0x21, 0x20, 0x04, 0x01,
+0x21, 0x28, 0x05, 0x01, 0x9C, 0x1D, 0xC3, 0xA0, 0x64, 0x1D, 0xC4, 0xA0,
+0xEB, 0xFF, 0xE0, 0x14, 0x80, 0x1D, 0xC5, 0xA0, 0x01, 0x00, 0x8C, 0x25,
+0x02, 0x00, 0x82, 0x2D, 0x0E, 0x00, 0x29, 0x25, 0xE5, 0xFF, 0x40, 0x14,
+0x03, 0x00, 0x4A, 0x25, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x60, 0x1B, 0x47, 0x24, 0x98, 0xF3, 0x66, 0x24, 0x21, 0x80, 0x00, 0x00,
+0x03, 0x00, 0x02, 0x2E, 0x21, 0x20, 0x07, 0x02, 0xD1, 0x00, 0x40, 0x10,
+0x08, 0x00, 0x03, 0x2E, 0x71, 0x00, 0xC3, 0x90, 0x6E, 0x00, 0xC2, 0x90,
+0x00, 0x00, 0x00, 0x00, 0xC6, 0x1D, 0x82, 0xA0, 0xB8, 0x1D, 0x83, 0xA0,
+0x01, 0x00, 0x02, 0x26, 0xFF, 0xFF, 0x50, 0x30, 0x0E, 0x00, 0x03, 0x2E,
+0xF4, 0xFF, 0x60, 0x14, 0x03, 0x00, 0x02, 0x2E, 0x03, 0x00, 0x02, 0x24,
+0x51, 0x00, 0x62, 0x15, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x98, 0xF3, 0x4E, 0x24, 0xC0, 0xD9, 0x6F, 0x24, 0x21, 0x60, 0x00, 0x00,
+0x21, 0x68, 0x00, 0x00, 0x21, 0x10, 0xAE, 0x01, 0x74, 0x00, 0x43, 0x90,
+0x21, 0x80, 0x00, 0x00, 0x0F, 0x00, 0x6A, 0x30, 0x02, 0x49, 0x03, 0x00,
+0x21, 0x10, 0xB0, 0x01, 0x00, 0x11, 0x02, 0x00, 0x21, 0x58, 0x4F, 0x00,
+0x21, 0x38, 0x00, 0x00, 0x21, 0x40, 0x67, 0x01, 0x00, 0x00, 0x03, 0x91,
+0x00, 0x31, 0x09, 0x00, 0x01, 0x00, 0xE7, 0x24, 0x02, 0x11, 0x03, 0x00,
+0x00, 0x21, 0x02, 0x00, 0x0F, 0x00, 0x63, 0x30, 0x2B, 0x10, 0x49, 0x00,
+0x0A, 0x20, 0xC2, 0x00, 0x2B, 0x28, 0x6A, 0x00, 0x00, 0x00, 0xA5, 0x38,
+0x25, 0x18, 0x83, 0x00, 0xFF, 0xFF, 0xE7, 0x30, 0x25, 0x20, 0x8A, 0x00,
+0x0A, 0x18, 0x85, 0x00, 0x10, 0x00, 0xE2, 0x2C, 0xEF, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x03, 0xA1, 0x01, 0x00, 0x02, 0x26, 0xFF, 0xFF, 0x50, 0x30,
+0x03, 0x00, 0x03, 0x2E, 0xE7, 0xFF, 0x60, 0x14, 0x21, 0x10, 0xB0, 0x01,
+0x01, 0x00, 0x8C, 0x25, 0x02, 0x00, 0x82, 0x2D, 0xDD, 0xFF, 0x40, 0x14,
+0x03, 0x00, 0xAD, 0x25, 0xCC, 0x66, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x03, 0x3C, 0x4C, 0x87, 0x02, 0x3C, 0x54, 0x00, 0x65, 0x34,
+0x00, 0xE0, 0x42, 0x34, 0x50, 0x00, 0x63, 0x34, 0x00, 0x00, 0x62, 0xAC,
+0x12, 0x01, 0x04, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x00, 0x00, 0xA4, 0xAC,
+0x60, 0x1B, 0x46, 0x24, 0x21, 0x60, 0x00, 0x00, 0x10, 0x00, 0x05, 0x24,
+0x21, 0x80, 0x00, 0x00, 0x01, 0x00, 0x02, 0x26, 0x21, 0x18, 0xD0, 0x00,
+0xFF, 0xFF, 0x50, 0x30, 0x0E, 0x00, 0x04, 0x2E, 0x80, 0x1D, 0x65, 0xA0,
+0x64, 0x1D, 0x65, 0xA0, 0xF9, 0xFF, 0x80, 0x14, 0x9C, 0x1D, 0x65, 0xA0,
+0x01, 0x00, 0x8C, 0x25, 0x02, 0x00, 0x82, 0x2D, 0xF4, 0xFF, 0x40, 0x14,
+0x0E, 0x00, 0xC6, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x46, 0x24,
+0x21, 0x80, 0x00, 0x00, 0x04, 0x00, 0x05, 0x24, 0x01, 0x00, 0x02, 0x26,
+0x21, 0x18, 0x06, 0x02, 0xFF, 0xFF, 0x50, 0x30, 0x0E, 0x00, 0x04, 0x2E,
+0xC6, 0x1D, 0x60, 0xA0, 0xFA, 0xFF, 0x80, 0x14, 0xB8, 0x1D, 0x65, 0xA0,
+0x02, 0x80, 0x12, 0x3C, 0xC6, 0x5C, 0x43, 0x92, 0x01, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x54, 0x59, 0x00, 0x0C, 0x4B, 0xF5, 0x43, 0xA0,
+0x48, 0xF5, 0xC5, 0x26, 0xFF, 0x58, 0x00, 0x0C, 0xFA, 0x01, 0x04, 0x24,
+0x54, 0x59, 0x00, 0x0C, 0x21, 0x20, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x25, 0xB0, 0x05, 0x3C, 0x48, 0x37, 0x84, 0x24, 0x50, 0x00, 0xA5, 0x34,
+0xF4, 0x54, 0x00, 0x0C, 0x06, 0x00, 0x06, 0x24, 0x60, 0x1B, 0x65, 0x26,
+0x01, 0x00, 0x02, 0x24, 0x06, 0x00, 0x03, 0x24, 0x05, 0x00, 0x04, 0x24,
+0x33, 0x1C, 0xA2, 0xA0, 0x6F, 0x58, 0x00, 0x0C, 0xC4, 0x3D, 0xA3, 0xA0,
+0x34, 0x00, 0xBF, 0x8F, 0x30, 0x00, 0xB6, 0x8F, 0x2C, 0x00, 0xB5, 0x8F,
+0x28, 0x00, 0xB4, 0x8F, 0x24, 0x00, 0xB3, 0x8F, 0x20, 0x00, 0xB2, 0x8F,
+0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x38, 0x00, 0xBD, 0x27, 0x25, 0xB0, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x50, 0x00, 0x84, 0x34, 0xAA, 0xF3, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C,
+0x06, 0x00, 0x06, 0x24, 0x98, 0xF3, 0xA2, 0x92, 0x98, 0xF3, 0xA5, 0x26,
+0x01, 0x00, 0xA4, 0x90, 0x21, 0x18, 0x40, 0x00, 0x10, 0x00, 0xA2, 0xA3,
+0x29, 0x00, 0x02, 0x24, 0x11, 0x00, 0xA4, 0xA3, 0x50, 0x00, 0xA7, 0x90,
+0x4F, 0x00, 0x62, 0x10, 0x02, 0x80, 0x12, 0x3C, 0x98, 0xF3, 0xA6, 0x26,
+0x68, 0x00, 0xC2, 0x90, 0x02, 0x80, 0x03, 0x3C, 0x04, 0x00, 0xE4, 0x2C,
+0x1F, 0x00, 0x42, 0x30, 0x34, 0x00, 0x80, 0x14, 0x49, 0xF5, 0x62, 0xA0,
+0x7A, 0x00, 0xC4, 0x90, 0x60, 0x1B, 0x65, 0x8E, 0x79, 0x00, 0xC6, 0x90,
+0x01, 0x00, 0x83, 0x30, 0xBF, 0xFF, 0x02, 0x24, 0x24, 0x28, 0xA2, 0x00,
+0x80, 0x19, 0x03, 0x00, 0x04, 0x00, 0x84, 0x30, 0x25, 0x28, 0xA3, 0x00,
+0x83, 0x20, 0x04, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x03, 0x00, 0xCB, 0x30,
+0x4A, 0xF5, 0x44, 0xA0, 0x60, 0x1B, 0x65, 0xAE, 0x06, 0x00, 0xE2, 0x2C,
+0x2C, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x98, 0xF3, 0xA3, 0x26,
+0x69, 0x00, 0x62, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x42, 0x30,
+0x26, 0xFF, 0x40, 0x14, 0x02, 0x80, 0x02, 0x3C, 0x45, 0x66, 0x00, 0x08,
+0x21, 0x40, 0x00, 0x00, 0x21, 0x20, 0x00, 0x00, 0x80, 0x00, 0x05, 0x24,
+0xC1, 0x58, 0x00, 0x0C, 0x98, 0xF3, 0xA6, 0x26, 0x1F, 0x66, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x43, 0x90, 0x69, 0x00, 0x46, 0x90,
+0x7D, 0x00, 0x44, 0x90, 0x60, 0x1B, 0x65, 0x8E, 0xBF, 0xFF, 0x02, 0x24,
+0x01, 0x00, 0x63, 0x30, 0x24, 0x28, 0xA2, 0x00, 0x01, 0x00, 0xC6, 0x30,
+0x04, 0x00, 0x84, 0x30, 0x80, 0x19, 0x03, 0x00, 0x25, 0x28, 0xA3, 0x00,
+0x83, 0x20, 0x04, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x01, 0x00, 0xC6, 0x2C,
+0x4A, 0xF5, 0x44, 0xA0, 0x60, 0x1B, 0x65, 0xAE, 0x0B, 0xFF, 0xC0, 0x10,
+0x02, 0x80, 0x12, 0x3C, 0x45, 0x66, 0x00, 0x08, 0x21, 0x40, 0x00, 0x00,
+0x60, 0x1B, 0x62, 0x8E, 0xBF, 0xFF, 0x03, 0x24, 0x02, 0x80, 0x04, 0x3C,
+0x24, 0x10, 0x43, 0x00, 0x02, 0x00, 0x0B, 0x24, 0x4A, 0xF5, 0x80, 0xA0,
+0x12, 0x67, 0x00, 0x08, 0x60, 0x1B, 0x62, 0xAE, 0x21, 0x28, 0x07, 0x02,
+0x06, 0x00, 0x60, 0x10, 0x21, 0x20, 0xA0, 0x00, 0x67, 0x00, 0xC3, 0x90,
+0x6F, 0x00, 0xC2, 0x90, 0xB8, 0x1D, 0xA3, 0xA0, 0x74, 0x66, 0x00, 0x08,
+0xC6, 0x1D, 0xA2, 0xA0, 0x72, 0x00, 0xC3, 0x90, 0x70, 0x00, 0xC2, 0x90,
+0x73, 0x66, 0x00, 0x08, 0xC6, 0x1D, 0x82, 0xA0, 0xFF, 0x00, 0x83, 0x30,
+0x81, 0x00, 0x02, 0x24, 0xB0, 0xFF, 0x62, 0x14, 0x98, 0xF3, 0xA6, 0x26,
+0x54, 0x00, 0xA3, 0x90, 0x01, 0x00, 0x02, 0x24, 0x09, 0x00, 0x62, 0x10,
+0x02, 0x00, 0x02, 0x24, 0x04, 0x00, 0x62, 0x10, 0x11, 0x00, 0x02, 0x24,
+0x02, 0x80, 0x12, 0x3C, 0xFE, 0x66, 0x00, 0x08, 0xC6, 0x5C, 0x42, 0xA2,
+0x22, 0x00, 0x02, 0x24, 0xFD, 0x66, 0x00, 0x08, 0xC6, 0x5C, 0x42, 0xA2,
+0x02, 0x80, 0x12, 0x3C, 0x12, 0x00, 0x02, 0x24, 0xFD, 0x66, 0x00, 0x08,
+0xC6, 0x5C, 0x42, 0xA2, 0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB1, 0xAF,
+0x02, 0x80, 0x02, 0x3C, 0x25, 0xB0, 0x11, 0x3C, 0x18, 0x03, 0x23, 0x36,
+0x7C, 0x9D, 0x42, 0x24, 0x20, 0x00, 0xB2, 0xAF, 0x02, 0x80, 0x12, 0x3C,
+0x00, 0x00, 0x62, 0xAC, 0x18, 0x00, 0xB0, 0xAF, 0x24, 0x00, 0xBF, 0xAF,
+0xC5, 0x65, 0x00, 0x0C, 0x60, 0x1B, 0x50, 0x26, 0x08, 0x68, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xA3, 0x6A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x87, 0x6B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x6D, 0x00, 0x74,
+0x00, 0x00, 0x00, 0x00, 0xEF, 0x6A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xC4, 0x3D, 0x04, 0x92, 0x38, 0x0D, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0xC4, 0x3D, 0x04, 0x92, 0x75, 0x0D, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0xCB, 0x64, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x82, 0x40, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x23, 0x36, 0x00, 0x00, 0x62, 0x94,
+0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x42, 0x34, 0x00, 0x00, 0x62, 0xA4,
+0x0A, 0x65, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x64, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0xF7, 0x64, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x53, 0x6B, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6B, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x3C, 0x68, 0x61, 0x84, 0x24,
+0x70, 0x6B, 0x00, 0x0C, 0x01, 0x00, 0x05, 0x24, 0x00, 0x80, 0x04, 0x3C,
+0xD0, 0x67, 0x84, 0x24, 0x70, 0x6B, 0x00, 0x0C, 0x02, 0x00, 0x05, 0x24,
+0x00, 0x80, 0x04, 0x3C, 0x39, 0x6F, 0x84, 0x24, 0x70, 0x6B, 0x00, 0x0C,
+0x04, 0x00, 0x05, 0x24, 0x44, 0x5C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x01, 0x80, 0x04, 0x3C, 0x6C, 0x83, 0x84, 0x24, 0x70, 0x6B, 0x00, 0x0C,
+0x03, 0x00, 0x05, 0x24, 0x02, 0x80, 0x03, 0x3C, 0xD0, 0x5C, 0x63, 0x90,
+0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x60, 0x10, 0x43, 0x00, 0x22, 0x36,
+0x07, 0x00, 0x02, 0x24, 0x0C, 0x00, 0x62, 0x10, 0x03, 0x00, 0x02, 0x24,
+0x25, 0xB0, 0x04, 0x3C, 0x43, 0x00, 0x85, 0x34, 0x10, 0x02, 0x86, 0x34,
+0x10, 0x00, 0x03, 0x24, 0x00, 0x00, 0xA2, 0xA0, 0xD8, 0x00, 0x84, 0x34,
+0x00, 0x00, 0xC3, 0xA0, 0x00, 0x00, 0x82, 0x90, 0x80, 0xFF, 0x03, 0x24,
+0x25, 0x10, 0x43, 0x00, 0x00, 0x00, 0x82, 0xA0, 0xDF, 0x64, 0x00, 0x0C,
+0x25, 0xB0, 0x10, 0x3C, 0x44, 0x00, 0x03, 0x36, 0x00, 0x00, 0x62, 0x94,
+0x02, 0x80, 0x04, 0x3C, 0x18, 0xE5, 0x84, 0x24, 0xC0, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x62, 0xA4, 0x13, 0x58, 0x00, 0x0C, 0xF2, 0x00, 0x05, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0xC3, 0x5C, 0x45, 0x90, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0x5C, 0xE5, 0x84, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xC2, 0x5C, 0x45, 0x90, 0xC7, 0x5C, 0x66, 0x90,
+0x02, 0x80, 0x04, 0x3C, 0x13, 0x58, 0x00, 0x0C, 0x6C, 0xE5, 0x84, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0xC6, 0x5C, 0x45, 0x90,
+0x48, 0xF5, 0x66, 0x90, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0xCF, 0x5C, 0x47, 0x90, 0x4A, 0xF5, 0x62, 0x90, 0x02, 0x80, 0x04, 0x3C,
+0x80, 0xE5, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C, 0x10, 0x00, 0xA2, 0xAF,
+0xFA, 0x5B, 0x00, 0x0C, 0x80, 0x0C, 0x04, 0x36, 0x02, 0x80, 0x03, 0x3C,
+0x02, 0x80, 0x04, 0x3C, 0xD1, 0x5C, 0x65, 0x90, 0xCE, 0x5C, 0x86, 0x90,
+0x02, 0x80, 0x04, 0x3C, 0x21, 0x38, 0x40, 0x00, 0x13, 0x58, 0x00, 0x0C,
+0x9C, 0xE5, 0x84, 0x24, 0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xD3, 0x5C, 0x66, 0x90, 0xD2, 0x5C, 0x45, 0x90, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xB8, 0xE5, 0x84, 0x24, 0x60, 0x1B, 0x42, 0x26,
+0x54, 0x41, 0x46, 0x8C, 0x58, 0x41, 0x45, 0x8C, 0x02, 0x80, 0x04, 0x3C,
+0x13, 0x58, 0x00, 0x0C, 0xCC, 0xE5, 0x84, 0x24, 0x60, 0x1B, 0x46, 0x8E,
+0x02, 0x80, 0x02, 0x3C, 0x49, 0xF5, 0x45, 0x90, 0x82, 0x31, 0x06, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0xEC, 0xE5, 0x84, 0x24, 0x13, 0x58, 0x00, 0x0C,
+0x01, 0x00, 0xC6, 0x30, 0x02, 0x80, 0x04, 0x3C, 0x08, 0x00, 0x84, 0x24,
+0x21, 0x28, 0x00, 0x00, 0x21, 0x30, 0x00, 0x00, 0x76, 0x39, 0x00, 0x0C,
+0x21, 0x38, 0x00, 0x00, 0xF5, 0x64, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x24, 0x00, 0xBF, 0x8F, 0x20, 0x00, 0xB2, 0x8F, 0x1C, 0x00, 0xB1, 0x8F,
+0x18, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0xD8, 0x00, 0x24, 0x36, 0x00, 0x00, 0x40, 0xA0,
+0xB0, 0x67, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xB8, 0xFF, 0xBD, 0x27,
+0x24, 0x00, 0xB1, 0xAF, 0x44, 0x00, 0xBF, 0xAF, 0x40, 0x00, 0xBE, 0xAF,
+0x3C, 0x00, 0xB7, 0xAF, 0x38, 0x00, 0xB6, 0xAF, 0x34, 0x00, 0xB5, 0xAF,
+0x30, 0x00, 0xB4, 0xAF, 0x2C, 0x00, 0xB3, 0xAF, 0x28, 0x00, 0xB2, 0xAF,
+0x20, 0x00, 0xB0, 0xAF, 0x02, 0x80, 0x02, 0x3C, 0xC2, 0x5C, 0x42, 0x90,
+0x25, 0xB0, 0x11, 0x3C, 0x58, 0x00, 0x25, 0x36, 0x10, 0x00, 0xA2, 0xAF,
+0x4C, 0x81, 0x02, 0x3C, 0x00, 0xE0, 0x42, 0x34, 0x00, 0x00, 0xA2, 0xAC,
+0xFF, 0xFF, 0x04, 0x24, 0x96, 0x01, 0x03, 0x24, 0x28, 0x28, 0x02, 0x24,
+0x5C, 0x00, 0x26, 0x36, 0x60, 0x00, 0x27, 0x36, 0x64, 0x00, 0x28, 0x36,
+0x8A, 0x00, 0x29, 0x36, 0x00, 0x00, 0xC3, 0xAC, 0x00, 0x00, 0xE4, 0xAC,
+0x00, 0x00, 0x04, 0xAD, 0x00, 0x00, 0x22, 0xA5, 0x0E, 0x0E, 0x02, 0x3C,
+0x09, 0x00, 0x03, 0x24, 0x0A, 0x0A, 0x42, 0x34, 0x89, 0x00, 0x2A, 0x36,
+0x8C, 0x00, 0x2B, 0x36, 0x00, 0x00, 0x43, 0xA1, 0x90, 0x00, 0x2C, 0x36,
+0x00, 0x00, 0x62, 0xAD, 0x13, 0x00, 0x03, 0x24, 0x40, 0x00, 0x02, 0x24,
+0x91, 0x00, 0x2D, 0x36, 0x00, 0x00, 0x83, 0xA1, 0x92, 0x00, 0x2E, 0x36,
+0x00, 0x00, 0xA2, 0xA1, 0x3A, 0x01, 0x03, 0x24, 0x21, 0x00, 0x02, 0x24,
+0xB5, 0x00, 0x2F, 0x36, 0x00, 0x00, 0xC3, 0xA5, 0x00, 0x00, 0xE2, 0xA1,
+0x10, 0x00, 0xA2, 0x8F, 0x12, 0x00, 0x03, 0x24, 0x87, 0x01, 0x43, 0x10,
+0x07, 0x07, 0x02, 0x3C, 0x07, 0x07, 0x42, 0x34, 0xA0, 0x00, 0x24, 0x36,
+0x00, 0x00, 0x82, 0xAC, 0xA4, 0x00, 0x25, 0x36, 0x00, 0x07, 0x03, 0x24,
+0x00, 0xC0, 0x02, 0x3C, 0xA8, 0x00, 0x26, 0x36, 0x00, 0x00, 0xA3, 0xAC,
+0x00, 0xC4, 0x42, 0x34, 0x02, 0x80, 0x03, 0x3C, 0x00, 0x00, 0xC2, 0xAC,
+0x60, 0x1B, 0x62, 0x24, 0xAC, 0x1B, 0x45, 0x94, 0xAE, 0x1B, 0x46, 0x94,
+0xAA, 0x1B, 0x42, 0x90, 0x02, 0x80, 0x03, 0x3C, 0x21, 0xB0, 0x07, 0x3C,
+0x14, 0x00, 0xA2, 0xA3, 0xD1, 0x5C, 0x63, 0x90, 0x20, 0xB0, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x18, 0x00, 0xA3, 0xAF, 0x23, 0xB0, 0x03, 0x3C,
+0xFF, 0xFF, 0x63, 0x34, 0x24, 0xB0, 0x08, 0x3C, 0xFF, 0x1F, 0x04, 0x3C,
+0x25, 0xB0, 0x1E, 0x3C, 0xFF, 0xFF, 0x84, 0x34, 0x21, 0x38, 0xA7, 0x00,
+0x21, 0x40, 0xC8, 0x00, 0x21, 0x28, 0xA2, 0x00, 0x21, 0x30, 0xC3, 0x00,
+0x24, 0x40, 0x04, 0x01, 0x24, 0x28, 0xA4, 0x00, 0x24, 0x38, 0xE4, 0x00,
+0x24, 0x30, 0xC4, 0x00, 0x35, 0x00, 0x02, 0x24, 0x20, 0x00, 0xC4, 0x37,
+0x00, 0x00, 0x82, 0xA0, 0x22, 0x00, 0x03, 0x24, 0x09, 0x00, 0x02, 0x24,
+0x03, 0x05, 0xC9, 0x37, 0x60, 0x05, 0xCA, 0x37, 0xAC, 0x00, 0xCB, 0x37,
+0xF8, 0x00, 0xCC, 0x37, 0xB0, 0x00, 0xCD, 0x37, 0x08, 0x01, 0xCE, 0x37,
+0xD8, 0x00, 0xCF, 0x37, 0x00, 0x00, 0x23, 0xA1, 0x00, 0x00, 0x42, 0xA1,
+0x00, 0x00, 0x65, 0xAD, 0x00, 0x00, 0x87, 0xAD, 0x00, 0x00, 0xA6, 0xAD,
+0x00, 0x00, 0xC8, 0xAD, 0x00, 0x00, 0xE0, 0xA1, 0x14, 0x00, 0xA3, 0x93,
+0x25, 0xB0, 0x02, 0x3C, 0xB4, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0xA0,
+0xB6, 0x00, 0xD1, 0x37, 0x04, 0x00, 0x02, 0x24, 0x25, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0x22, 0xA2, 0xB9, 0x00, 0x63, 0x34, 0xFF, 0xFF, 0x02, 0x24,
+0x00, 0x00, 0x62, 0xA0, 0x25, 0xB0, 0x03, 0x3C, 0x0F, 0x00, 0x02, 0x24,
+0xBA, 0x00, 0x63, 0x34, 0x00, 0x00, 0x62, 0xA4, 0xDC, 0x00, 0xD4, 0x37,
+0xFF, 0xCF, 0x03, 0x24, 0x3F, 0x3F, 0x02, 0x24, 0x16, 0x01, 0xD5, 0x37,
+0x00, 0x00, 0x83, 0xAE, 0x00, 0x00, 0xA2, 0xA6, 0x2F, 0x00, 0x02, 0x3C,
+0x00, 0x10, 0x03, 0x24, 0x17, 0x32, 0x42, 0x34, 0x18, 0x01, 0xD6, 0x37,
+0x1A, 0x01, 0xD7, 0x37, 0xD0, 0x01, 0xD8, 0x37, 0x00, 0x00, 0xC0, 0xA6,
+0x00, 0x00, 0xE3, 0xA6, 0x00, 0x00, 0x02, 0xAF, 0x5E, 0x00, 0x03, 0x3C,
+0x25, 0xB0, 0x02, 0x3C, 0x17, 0x43, 0x63, 0x34, 0xD4, 0x01, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xAC, 0x10, 0x00, 0x02, 0x3C, 0x20, 0x53, 0x42, 0x34,
+0xD8, 0x01, 0xDF, 0x37, 0x00, 0x00, 0xE2, 0xAF, 0x25, 0xB0, 0x02, 0x3C,
+0x44, 0xA4, 0x03, 0x34, 0xDC, 0x01, 0x42, 0x34, 0x00, 0x00, 0x43, 0xAC,
+0x25, 0xB0, 0x03, 0x3C, 0x1A, 0x06, 0x02, 0x24, 0xE0, 0x01, 0x63, 0x34,
+0x00, 0x00, 0x62, 0xA4, 0xC2, 0x00, 0x02, 0x3C, 0x30, 0x30, 0x03, 0x24,
+0x51, 0x10, 0x42, 0x34, 0xF4, 0x01, 0xD0, 0x37, 0xF8, 0x01, 0xD3, 0x37,
+0x00, 0x00, 0x03, 0xA6, 0x00, 0x02, 0xD2, 0x37, 0x00, 0x00, 0x62, 0xAE,
+0x26, 0x00, 0x03, 0x24, 0x03, 0x02, 0xD9, 0x37, 0x04, 0x00, 0x02, 0x24,
+0x00, 0x00, 0x43, 0xA6, 0x00, 0x00, 0x22, 0xA3, 0x18, 0x00, 0xA3, 0x8F,
+0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x60, 0x14, 0x36, 0x02, 0xC2, 0x37,
+0x04, 0x00, 0x03, 0x24, 0x00, 0x00, 0x43, 0xA0, 0x02, 0x80, 0x0B, 0x3C,
+0xC6, 0x5C, 0x66, 0x91, 0x25, 0xB0, 0x09, 0x3C, 0x34, 0x02, 0x23, 0x35,
+0x80, 0x00, 0x02, 0x24, 0x00, 0x00, 0x62, 0xA4, 0x38, 0x02, 0x24, 0x35,
+0x37, 0x02, 0x25, 0x35, 0x07, 0x00, 0x02, 0x24, 0x22, 0x00, 0x03, 0x24,
+0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0xA2, 0xA0, 0xE1, 0x00, 0xC3, 0x10,
+0x1B, 0x1B, 0x02, 0x3C, 0x13, 0x13, 0x02, 0x3C, 0x13, 0x13, 0x42, 0x34,
+0x60, 0x01, 0x23, 0x35, 0x64, 0x01, 0x24, 0x35, 0x68, 0x01, 0x25, 0x35,
+0x7C, 0x01, 0x2A, 0x35, 0x6C, 0x01, 0x26, 0x35, 0x70, 0x01, 0x27, 0x35,
+0x74, 0x01, 0x28, 0x35, 0x78, 0x01, 0x29, 0x35, 0x00, 0x00, 0x62, 0xAC,
+0x00, 0x00, 0x82, 0xAC, 0x00, 0x00, 0xA2, 0xAC, 0x00, 0x00, 0xC2, 0xAC,
+0x00, 0x00, 0xE2, 0xAC, 0x00, 0x00, 0x02, 0xAD, 0x00, 0x00, 0x22, 0xAD,
+0x00, 0x00, 0x42, 0xAD, 0xC6, 0x5C, 0x65, 0x91, 0x25, 0xB0, 0x0C, 0x3C,
+0x01, 0x00, 0x03, 0x3C, 0x80, 0x01, 0x82, 0x35, 0x08, 0x5F, 0x63, 0x34,
+0x22, 0x00, 0x04, 0x24, 0x00, 0x00, 0x43, 0xAC, 0xE0, 0x00, 0xA4, 0x10,
+0x0F, 0x1F, 0x02, 0x3C, 0x92, 0x00, 0x02, 0x24, 0xDD, 0x00, 0xA2, 0x10,
+0x0F, 0x1F, 0x02, 0x3C, 0x0F, 0x10, 0x02, 0x3C, 0x00, 0xF0, 0x4F, 0x34,
+0xF7, 0x01, 0x91, 0x35, 0x15, 0xF0, 0x4D, 0x34, 0x77, 0x00, 0x0E, 0x24,
+0x84, 0x01, 0x87, 0x35, 0x88, 0x01, 0x88, 0x35, 0x10, 0xF0, 0x44, 0x34,
+0x8C, 0x01, 0x85, 0x35, 0x05, 0xF0, 0x42, 0x34, 0x00, 0x00, 0xED, 0xAC,
+0x90, 0x01, 0x83, 0x35, 0x00, 0x00, 0x04, 0xAD, 0x94, 0x01, 0x86, 0x35,
+0x00, 0x00, 0xA2, 0xAC, 0xF5, 0x0F, 0x02, 0x24, 0x00, 0x00, 0x6F, 0xAC,
+0x98, 0x01, 0x89, 0x35, 0x00, 0x00, 0xC2, 0xAC, 0x9C, 0x01, 0x8A, 0x35,
+0xA0, 0x01, 0x8B, 0x35, 0xF0, 0x0F, 0x03, 0x24, 0xF6, 0x01, 0x8C, 0x35,
+0x0D, 0x00, 0x02, 0x24, 0x00, 0x00, 0x23, 0xAD, 0x00, 0x00, 0x42, 0xAD,
+0x00, 0x00, 0x6D, 0xAD, 0x02, 0x80, 0x02, 0x3C, 0x00, 0x00, 0x8E, 0xA1,
+0x00, 0x00, 0x2E, 0xA2, 0xE3, 0x5C, 0x42, 0x90, 0x25, 0xB0, 0x1F, 0x3C,
+0xA7, 0x01, 0xE7, 0x37, 0x1C, 0x00, 0xA2, 0xAF, 0xFF, 0xFF, 0x02, 0x24,
+0x00, 0x00, 0xE2, 0xA0, 0x05, 0x06, 0x03, 0x3C, 0x25, 0xB0, 0x02, 0x3C,
+0x03, 0x04, 0x63, 0x34, 0x0C, 0x00, 0x04, 0x24, 0xFF, 0xFF, 0x05, 0x24,
+0x01, 0x02, 0x06, 0x3C, 0xC2, 0x01, 0x42, 0x34, 0xA8, 0x01, 0xE8, 0x37,
+0xAC, 0x01, 0xE9, 0x37, 0xB0, 0x01, 0xEA, 0x37, 0xB4, 0x01, 0xEB, 0x37,
+0xB8, 0x01, 0xEC, 0x37, 0xBC, 0x01, 0xED, 0x37, 0xC0, 0x01, 0xEE, 0x37,
+0xC1, 0x01, 0xEF, 0x37, 0x00, 0x00, 0x05, 0xAD, 0x00, 0x00, 0x25, 0xAD,
+0x00, 0x00, 0x46, 0xAD, 0x00, 0x00, 0x63, 0xAD, 0x00, 0x00, 0x86, 0xAD,
+0x00, 0x00, 0xA3, 0xAD, 0x00, 0x00, 0xC4, 0xA1, 0x25, 0xB0, 0x03, 0x3C,
+0x00, 0x00, 0xE4, 0xA1, 0x00, 0x00, 0x44, 0xA0, 0x25, 0xB0, 0x02, 0x3C,
+0x0D, 0x00, 0x17, 0x24, 0x0E, 0x00, 0x18, 0x24, 0xC4, 0x01, 0x63, 0x34,
+0xC5, 0x01, 0x42, 0x34, 0xC3, 0x01, 0xF1, 0x37, 0x00, 0x00, 0x37, 0xA2,
+0xC6, 0x01, 0xF4, 0x37, 0x00, 0x00, 0x77, 0xA0, 0xC7, 0x01, 0xF5, 0x37,
+0x00, 0x00, 0x58, 0xA0, 0x0F, 0x00, 0x02, 0x24, 0x00, 0x00, 0x98, 0xA2,
+0x00, 0x00, 0xA2, 0xA2, 0x53, 0x01, 0x02, 0x3C, 0x46, 0x00, 0xF6, 0x37,
+0x48, 0x00, 0xFE, 0x37, 0x0E, 0xF0, 0x42, 0x34, 0x00, 0x00, 0xC0, 0xA6,
+0x00, 0x00, 0xC2, 0xAF, 0x1C, 0x00, 0xA3, 0x8F, 0x00, 0x00, 0x00, 0x00,
+0x09, 0x00, 0x60, 0x10, 0x44, 0x00, 0xF7, 0x37, 0x00, 0x00, 0xE2, 0x8E,
+0x00, 0x02, 0x03, 0x3C, 0x25, 0x10, 0x43, 0x00, 0x00, 0x00, 0xE2, 0xAE,
+0x00, 0x00, 0xC3, 0x8F, 0x00, 0x04, 0x02, 0x3C, 0x25, 0x18, 0x62, 0x00,
+0x00, 0x00, 0xC3, 0xAF, 0x4C, 0x00, 0xE2, 0x37, 0x00, 0x00, 0x40, 0xA0,
+0x40, 0x00, 0xE4, 0x37, 0xBC, 0x00, 0x03, 0x24, 0xFC, 0x37, 0x02, 0x24,
+0x00, 0x00, 0x83, 0xA4, 0x00, 0x00, 0x82, 0xA4, 0x02, 0x80, 0x02, 0x3C,
+0xD8, 0x00, 0xE9, 0x37, 0x60, 0x1B, 0x43, 0x24, 0x00, 0x00, 0x26, 0x91,
+0xAA, 0x1B, 0x64, 0x90, 0x2A, 0xB0, 0x05, 0x3C, 0xA0, 0xFF, 0x02, 0x24,
+0x26, 0xB0, 0x07, 0x3C, 0x25, 0x30, 0xC2, 0x00, 0x30, 0x00, 0xAD, 0x34,
+0x34, 0x00, 0xA8, 0x34, 0x01, 0x00, 0x83, 0x24, 0x38, 0x00, 0xA5, 0x34,
+0x20, 0x20, 0x02, 0x24, 0x00, 0x00, 0x26, 0xA1, 0x79, 0x00, 0xEA, 0x34,
+0x00, 0x00, 0x03, 0xA1, 0x00, 0x00, 0xA2, 0xA4, 0x40, 0x00, 0x03, 0x24,
+0x16, 0x00, 0x02, 0x24, 0x00, 0x00, 0xA3, 0xA1, 0x94, 0x00, 0xEB, 0x37,
+0x00, 0x00, 0x42, 0xA1, 0x98, 0x00, 0xEC, 0x37, 0x64, 0x00, 0x03, 0x24,
+0x22, 0x00, 0x02, 0x24, 0x00, 0x00, 0x63, 0xA5, 0x7C, 0x00, 0xF4, 0x34,
+0x00, 0x00, 0x82, 0xA5, 0x7A, 0x00, 0xE7, 0x34, 0x04, 0x00, 0x03, 0x24,
+0x20, 0x0C, 0x02, 0x24, 0x00, 0x00, 0xE3, 0xA0, 0x9C, 0x00, 0xEE, 0x37,
+0x00, 0x00, 0x82, 0xA6, 0x9A, 0x00, 0xEF, 0x37, 0x0A, 0x00, 0x03, 0x24,
+0xFF, 0x03, 0x02, 0x24, 0x00, 0x00, 0xC3, 0xA1, 0x00, 0x00, 0xE2, 0xA5,
+0x25, 0xB0, 0x02, 0x3C, 0x02, 0x00, 0x03, 0x24, 0x96, 0x00, 0x42, 0x34,
+0x00, 0x00, 0x43, 0xA4, 0x89, 0x00, 0xF5, 0x37, 0xB7, 0x00, 0xF1, 0x37,
+0x20, 0x00, 0x02, 0x24, 0x09, 0x00, 0x03, 0x24, 0x00, 0x00, 0x22, 0xA2,
+0x00, 0x00, 0xA3, 0xA2, 0x00, 0x00, 0xE2, 0x96, 0xFF, 0xFD, 0x03, 0x24,
+0x04, 0x02, 0x05, 0x24, 0x24, 0x10, 0x43, 0x00, 0x00, 0x00, 0xE2, 0xA6,
+0x00, 0x00, 0xE3, 0x96, 0x29, 0xB0, 0x02, 0x3C, 0x40, 0x00, 0x42, 0x34,
+0x00, 0x02, 0x63, 0x34, 0x00, 0x00, 0xE3, 0xA6, 0xFF, 0x00, 0x84, 0x30,
+0x00, 0x00, 0x45, 0xA4, 0x7A, 0x1F, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x44, 0x00, 0xBF, 0x8F, 0x40, 0x00, 0xBE, 0x8F, 0x3C, 0x00, 0xB7, 0x8F,
+0x38, 0x00, 0xB6, 0x8F, 0x34, 0x00, 0xB5, 0x8F, 0x30, 0x00, 0xB4, 0x8F,
+0x2C, 0x00, 0xB3, 0x8F, 0x28, 0x00, 0xB2, 0x8F, 0x24, 0x00, 0xB1, 0x8F,
+0x20, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x02, 0x24, 0x08, 0x00, 0xE0, 0x03,
+0x48, 0x00, 0xBD, 0x27, 0xFF, 0xFF, 0x03, 0x24, 0x00, 0x00, 0x43, 0xA0,
+0x02, 0x80, 0x0B, 0x3C, 0xC6, 0x5C, 0x66, 0x91, 0x25, 0xB0, 0x09, 0x3C,
+0x34, 0x02, 0x23, 0x35, 0x80, 0x00, 0x02, 0x24, 0x00, 0x00, 0x62, 0xA4,
+0x38, 0x02, 0x24, 0x35, 0x37, 0x02, 0x25, 0x35, 0x07, 0x00, 0x02, 0x24,
+0x22, 0x00, 0x03, 0x24, 0x00, 0x00, 0x80, 0xA0, 0x00, 0x00, 0xA2, 0xA0,
+0x23, 0xFF, 0xC3, 0x14, 0x13, 0x13, 0x02, 0x3C, 0x1B, 0x1B, 0x02, 0x3C,
+0x1B, 0x1B, 0x42, 0x34, 0x60, 0x01, 0x23, 0x35, 0x64, 0x01, 0x24, 0x35,
+0x68, 0x01, 0x25, 0x35, 0x7C, 0x01, 0x2A, 0x35, 0x6C, 0x01, 0x26, 0x35,
+0x70, 0x01, 0x27, 0x35, 0x74, 0x01, 0x28, 0x35, 0x78, 0x01, 0x29, 0x35,
+0x00, 0x00, 0x62, 0xAC, 0x00, 0x00, 0x82, 0xAC, 0x00, 0x00, 0xA2, 0xAC,
+0x00, 0x00, 0xC2, 0xAC, 0x00, 0x00, 0xE2, 0xAC, 0x00, 0x00, 0x02, 0xAD,
+0x00, 0x00, 0x22, 0xAD, 0x00, 0x00, 0x42, 0xAD, 0xC6, 0x5C, 0x65, 0x91,
+0x25, 0xB0, 0x0C, 0x3C, 0x01, 0x00, 0x03, 0x3C, 0x80, 0x01, 0x82, 0x35,
+0x08, 0x5F, 0x63, 0x34, 0x22, 0x00, 0x04, 0x24, 0x00, 0x00, 0x43, 0xAC,
+0x22, 0xFF, 0xA4, 0x14, 0x0F, 0x1F, 0x02, 0x3C, 0x00, 0xF0, 0x4F, 0x34,
+0xF7, 0x01, 0x91, 0x35, 0x15, 0xF0, 0x4D, 0x34, 0xE7, 0x68, 0x00, 0x08,
+0xFF, 0xFF, 0x0E, 0x24, 0x02, 0x80, 0x02, 0x3C, 0xC7, 0x5C, 0x44, 0x90,
+0x06, 0x00, 0x03, 0x24, 0x0C, 0x00, 0x83, 0x10, 0xA0, 0x00, 0x24, 0x36,
+0x00, 0x15, 0x02, 0x3C, 0x00, 0x07, 0x42, 0x34, 0x00, 0x00, 0x82, 0xAC,
+0x04, 0xE0, 0x02, 0x3C, 0xA4, 0x00, 0x25, 0x36, 0x00, 0x22, 0x03, 0x24,
+0xA8, 0x00, 0x26, 0x36, 0x00, 0xAE, 0x42, 0x34, 0x00, 0x00, 0xA3, 0xAC,
+0x47, 0x68, 0x00, 0x08, 0x02, 0x80, 0x03, 0x3C, 0x00, 0x15, 0x02, 0x3C,
+0x00, 0x07, 0x42, 0x34, 0x00, 0x00, 0x82, 0xAC, 0x04, 0xC0, 0x02, 0x3C,
+0xA4, 0x00, 0x25, 0x36, 0x00, 0x22, 0x03, 0x24, 0xA8, 0x00, 0x26, 0x36,
+0x00, 0xB0, 0x42, 0x34, 0x00, 0x00, 0xA3, 0xAC, 0x47, 0x68, 0x00, 0x08,
+0x02, 0x80, 0x03, 0x3C, 0xE8, 0xFF, 0xBD, 0x27, 0x01, 0x00, 0x06, 0x24,
+0xE8, 0x0E, 0x04, 0x24, 0x10, 0x00, 0xBF, 0xAF, 0xC1, 0x43, 0x00, 0x0C,
+0x00, 0x10, 0x05, 0x3C, 0x60, 0x08, 0x04, 0x24, 0xE3, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0x20, 0x04, 0x06, 0x3C, 0x20, 0x04, 0xC6, 0x34,
+0x25, 0x30, 0x46, 0x00, 0x60, 0x08, 0x04, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0x70, 0x08, 0x04, 0x24, 0x00, 0x04, 0x05, 0x24,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x00, 0x20, 0x06, 0x3C,
+0x80, 0x00, 0xC6, 0x34, 0x80, 0x0C, 0x04, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0xFF, 0xFF, 0x05, 0x24, 0x00, 0x40, 0x06, 0x3C, 0x10, 0x00, 0xBF, 0x8F,
+0x00, 0x01, 0xC6, 0x34, 0x88, 0x0C, 0x04, 0x24, 0xFF, 0xFF, 0x05, 0x24,
+0xC1, 0x43, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF,
+0x10, 0x00, 0xB0, 0xAF, 0x21, 0x90, 0xA0, 0x00, 0x0A, 0x00, 0xA0, 0x10,
+0x21, 0x88, 0x00, 0x00, 0x21, 0x80, 0x80, 0x00, 0x00, 0x00, 0x04, 0x8E,
+0x04, 0x00, 0x05, 0x8E, 0x02, 0x00, 0x31, 0x26, 0x03, 0x5C, 0x00, 0x0C,
+0x08, 0x00, 0x10, 0x26, 0x2B, 0x10, 0x32, 0x02, 0xF9, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0xE0, 0xFF, 0xBD, 0x27, 0x18, 0x00, 0xB2, 0xAF,
+0x14, 0x00, 0xB1, 0xAF, 0x1C, 0x00, 0xBF, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x21, 0x90, 0xA0, 0x00, 0x0B, 0x00, 0xA0, 0x10, 0x21, 0x88, 0x00, 0x00,
+0x21, 0x80, 0x80, 0x00, 0x00, 0x00, 0x04, 0x8E, 0x04, 0x00, 0x05, 0x8E,
+0x08, 0x00, 0x06, 0x8E, 0x03, 0x00, 0x31, 0x26, 0xC1, 0x43, 0x00, 0x0C,
+0x0C, 0x00, 0x10, 0x26, 0x2B, 0x10, 0x32, 0x02, 0xF8, 0xFF, 0x40, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x21, 0x40, 0x80, 0x00, 0x21, 0x48, 0x00, 0x00,
+0x1E, 0x00, 0xA0, 0x10, 0x21, 0x38, 0x00, 0x00, 0x80, 0x30, 0x07, 0x00,
+0x21, 0x10, 0xC8, 0x00, 0x00, 0x00, 0x43, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x00, 0xF2, 0x63, 0x24, 0x1D, 0x00, 0x62, 0x2C, 0x12, 0x00, 0x40, 0x10,
+0x80, 0x10, 0x03, 0x00, 0x02, 0x80, 0x03, 0x3C, 0x14, 0xE6, 0x63, 0x24,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0xC8, 0x00,
+0xC0, 0x18, 0x09, 0x00, 0x23, 0x18, 0x69, 0x00, 0x08, 0x00, 0x44, 0x8C,
+0x02, 0x80, 0x02, 0x3C, 0x80, 0x18, 0x03, 0x00, 0x60, 0x1B, 0x42, 0x24,
+0x21, 0x18, 0x62, 0x00, 0x04, 0x1D, 0x64, 0xAC, 0x01, 0x00, 0x29, 0x25,
+0x03, 0x00, 0xE7, 0x24, 0x2B, 0x10, 0xE5, 0x00, 0xE5, 0xFF, 0x40, 0x14,
+0x80, 0x30, 0x07, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0xC8, 0x00, 0xC0, 0x18, 0x09, 0x00, 0x08, 0x00, 0x44, 0x8C,
+0x23, 0x18, 0x69, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0x80, 0x18, 0x03, 0x00, 0x03, 0x00, 0xE7, 0x24, 0x21, 0x18, 0x62, 0x00,
+0x2B, 0x10, 0xE5, 0x00, 0xD6, 0xFF, 0x40, 0x14, 0x00, 0x1D, 0x64, 0xAC,
+0x4D, 0x6A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0xC8, 0x00,
+0xC0, 0x18, 0x09, 0x00, 0x08, 0x00, 0x44, 0x8C, 0x23, 0x18, 0x69, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x80, 0x18, 0x03, 0x00,
+0x03, 0x00, 0xE7, 0x24, 0x21, 0x18, 0x62, 0x00, 0x2B, 0x10, 0xE5, 0x00,
+0xC8, 0xFF, 0x40, 0x14, 0xFC, 0x1C, 0x64, 0xAC, 0x4D, 0x6A, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0xC8, 0x00, 0xC0, 0x18, 0x09, 0x00,
+0x08, 0x00, 0x44, 0x8C, 0x23, 0x18, 0x69, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x42, 0x24, 0x80, 0x18, 0x03, 0x00, 0x03, 0x00, 0xE7, 0x24,
+0x21, 0x18, 0x62, 0x00, 0x2B, 0x10, 0xE5, 0x00, 0xBA, 0xFF, 0x40, 0x14,
+0xF8, 0x1C, 0x64, 0xAC, 0x4D, 0x6A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x21, 0x10, 0xC8, 0x00, 0xC0, 0x18, 0x09, 0x00, 0x08, 0x00, 0x44, 0x8C,
+0x23, 0x18, 0x69, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24,
+0x80, 0x18, 0x03, 0x00, 0x03, 0x00, 0xE7, 0x24, 0x21, 0x18, 0x62, 0x00,
+0x2B, 0x10, 0xE5, 0x00, 0xAC, 0xFF, 0x40, 0x14, 0x08, 0x1D, 0x64, 0xAC,
+0x4D, 0x6A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0xC8, 0x00,
+0xC0, 0x18, 0x09, 0x00, 0x08, 0x00, 0x44, 0x8C, 0x23, 0x18, 0x69, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x80, 0x18, 0x03, 0x00,
+0x03, 0x00, 0xE7, 0x24, 0x21, 0x18, 0x62, 0x00, 0x2B, 0x10, 0xE5, 0x00,
+0x9E, 0xFF, 0x40, 0x14, 0xF4, 0x1C, 0x64, 0xAC, 0x4D, 0x6A, 0x00, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x21, 0x10, 0xC8, 0x00, 0xC0, 0x18, 0x09, 0x00,
+0x08, 0x00, 0x44, 0x8C, 0x23, 0x18, 0x69, 0x00, 0x02, 0x80, 0x02, 0x3C,
+0x60, 0x1B, 0x42, 0x24, 0x80, 0x18, 0x03, 0x00, 0x03, 0x00, 0xE7, 0x24,
+0x21, 0x18, 0x62, 0x00, 0x2B, 0x10, 0xE5, 0x00, 0x90, 0xFF, 0x40, 0x14,
+0xF0, 0x1C, 0x64, 0xAC, 0x4D, 0x6A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x25, 0xB0, 0x02, 0x3C, 0xFC, 0x37, 0x03, 0x24, 0x40, 0x00, 0x42, 0x34,
+0x02, 0x80, 0x04, 0x3C, 0x00, 0x00, 0x43, 0xA4, 0xE8, 0xFF, 0xBD, 0x27,
+0x5C, 0xD1, 0x84, 0x24, 0x10, 0x00, 0xBF, 0xAF, 0xFD, 0x69, 0x00, 0x0C,
+0x74, 0x01, 0x05, 0x24, 0x02, 0x80, 0x02, 0x3C, 0xC6, 0x5C, 0x44, 0x90,
+0x12, 0x00, 0x03, 0x24, 0x34, 0x00, 0x83, 0x10, 0x13, 0x00, 0x82, 0x28,
+0x17, 0x00, 0x40, 0x14, 0x11, 0x00, 0x02, 0x24, 0x22, 0x00, 0x02, 0x24,
+0x36, 0x00, 0x82, 0x10, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x04, 0x3C,
+0xE4, 0xCD, 0x84, 0x24, 0x2C, 0x6A, 0x00, 0x0C, 0x54, 0x00, 0x05, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0x4A, 0xF5, 0x44, 0x90, 0x01, 0x00, 0x03, 0x24,
+0x1A, 0x00, 0x83, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0xE4, 0xC8, 0x84, 0x24, 0xFD, 0x69, 0x00, 0x0C, 0x40, 0x01, 0x05, 0x24,
+0x10, 0x00, 0xBF, 0x8F, 0x84, 0x08, 0x04, 0x24, 0xFF, 0x00, 0x05, 0x24,
+0x58, 0x00, 0x06, 0x24, 0x35, 0x45, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0xED, 0xFF, 0x82, 0x14, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x04, 0x3C,
+0x9C, 0xD0, 0x84, 0x24, 0x14, 0x6A, 0x00, 0x0C, 0x30, 0x00, 0x05, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0xE4, 0xCD, 0x84, 0x24, 0x2C, 0x6A, 0x00, 0x0C,
+0x54, 0x00, 0x05, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x4A, 0xF5, 0x44, 0x90,
+0x01, 0x00, 0x03, 0x24, 0xE8, 0xFF, 0x83, 0x14, 0x00, 0x00, 0x00, 0x00,
+0xDE, 0x69, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0xE4, 0xC8, 0x84, 0x24, 0xFD, 0x69, 0x00, 0x0C, 0x40, 0x01, 0x05, 0x24,
+0x10, 0x00, 0xBF, 0x8F, 0x84, 0x08, 0x04, 0x24, 0xFF, 0x00, 0x05, 0x24,
+0x58, 0x00, 0x06, 0x24, 0x35, 0x45, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0x02, 0x80, 0x04, 0x3C, 0xE8, 0xCF, 0x84, 0x24, 0x2D, 0x00, 0x05, 0x24,
+0x14, 0x6A, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x6A, 0x00, 0x08,
+0x02, 0x80, 0x04, 0x3C, 0x34, 0xCF, 0x84, 0x24, 0xE8, 0x6A, 0x00, 0x08,
+0x2D, 0x00, 0x05, 0x24, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xB0, 0xAF,
+0x50, 0x0C, 0x04, 0x24, 0xFF, 0x00, 0x05, 0x24, 0x02, 0x80, 0x10, 0x3C,
+0x14, 0x00, 0xBF, 0xAF, 0x24, 0x45, 0x00, 0x0C, 0x60, 0x1B, 0x10, 0x26,
+0x60, 0x1D, 0x02, 0xA2, 0x58, 0x0C, 0x04, 0x24, 0x24, 0x45, 0x00, 0x0C,
+0xFF, 0x00, 0x05, 0x24, 0x61, 0x1D, 0x02, 0xA2, 0x60, 0x0C, 0x04, 0x24,
+0x24, 0x45, 0x00, 0x0C, 0xFF, 0x00, 0x05, 0x24, 0x62, 0x1D, 0x02, 0xA2,
+0x68, 0x0C, 0x04, 0x24, 0x24, 0x45, 0x00, 0x0C, 0xFF, 0x00, 0x05, 0x24,
+0x63, 0x1D, 0x02, 0xA2, 0x38, 0x0C, 0x04, 0x24, 0x24, 0x45, 0x00, 0x0C,
+0xFF, 0x00, 0x05, 0x24, 0xE8, 0x1C, 0x02, 0xA2, 0x34, 0x0C, 0x04, 0x24,
+0x24, 0x45, 0x00, 0x0C, 0xFF, 0xFF, 0x05, 0x24, 0xEC, 0x1C, 0x02, 0xAE,
+0x14, 0x00, 0xBF, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x38, 0xAD, 0x42, 0x24, 0xB0, 0x5D, 0x60, 0xAC,
+0x10, 0x5D, 0xA2, 0xAC, 0x02, 0x80, 0x03, 0x3C, 0x00, 0x80, 0x02, 0x3C,
+0xB4, 0x5D, 0x60, 0xA4, 0x10, 0x5D, 0xA4, 0x24, 0x64, 0x11, 0x42, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0xB6, 0x5D, 0x60, 0xA4, 0x08, 0x00, 0x82, 0xAC,
+0x00, 0x80, 0x03, 0x3C, 0x00, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x06, 0x3C,
+0x4C, 0x14, 0x42, 0x24, 0x80, 0x11, 0x63, 0x24, 0xB8, 0x5D, 0xC7, 0x24,
+0x14, 0x00, 0x82, 0xAC, 0x10, 0x00, 0x83, 0xAC, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xB8, 0x5D, 0xC0, 0xAC, 0x04, 0x00, 0xE0, 0xAC,
+0xC0, 0x5D, 0x40, 0xA0, 0xC4, 0x5D, 0x60, 0xAC, 0x01, 0x80, 0x02, 0x3C,
+0xB4, 0xC5, 0x42, 0x24, 0x7C, 0x00, 0x82, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x68, 0x14, 0x63, 0x24, 0x08, 0x17, 0x42, 0x24,
+0x20, 0x00, 0x83, 0xAC, 0x24, 0x00, 0x82, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0xB0, 0x19, 0x63, 0x24, 0x54, 0x1C, 0x42, 0x24,
+0x28, 0x00, 0x83, 0xAC, 0x2C, 0x00, 0x82, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x01, 0x80, 0x02, 0x3C, 0x80, 0x2F, 0x63, 0x24, 0x10, 0x02, 0x42, 0x24,
+0x30, 0x00, 0x83, 0xAC, 0x54, 0x00, 0x82, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x58, 0x1F, 0x63, 0x24, 0x38, 0x21, 0x42, 0x24,
+0x0C, 0x00, 0x83, 0xAC, 0x3C, 0x00, 0x82, 0xAC, 0x00, 0x80, 0x03, 0x3C,
+0x00, 0x80, 0x02, 0x3C, 0x00, 0x03, 0x63, 0x24, 0xF8, 0x1E, 0x42, 0x24,
+0x50, 0x00, 0x83, 0xAC, 0x08, 0x00, 0xE0, 0x03, 0x40, 0x00, 0x82, 0xAC,
+0x25, 0xB0, 0x02, 0x3C, 0x08, 0x00, 0x42, 0x34, 0x00, 0x00, 0x43, 0x8C,
+0x08, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x0E, 0x3C,
+0x02, 0x80, 0x08, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0xF8, 0x03, 0x4D, 0x24, 0x00, 0x18, 0x6C, 0x24, 0x01, 0x00, 0x07, 0x24,
+0x00, 0x00, 0xCB, 0x25, 0xFF, 0xFF, 0x0A, 0x24, 0x00, 0x04, 0x09, 0x25,
+0x80, 0x1A, 0x07, 0x00, 0x21, 0x10, 0x6B, 0x00, 0x00, 0x00, 0x42, 0xAC,
+0x90, 0x00, 0x4A, 0xAC, 0x00, 0x04, 0x04, 0x8D, 0x01, 0x00, 0xE7, 0x24,
+0x08, 0x00, 0x45, 0x24, 0x21, 0x18, 0x6D, 0x00, 0x06, 0x00, 0xE6, 0x28,
+0x04, 0x00, 0x82, 0xAC, 0x00, 0x00, 0x44, 0xAC, 0x04, 0x00, 0x49, 0xAC,
+0x00, 0x04, 0x02, 0xAD, 0x8C, 0x00, 0x40, 0xAC, 0x6C, 0x00, 0xA3, 0xAC,
+0xF0, 0xFF, 0xC0, 0x14, 0x68, 0x00, 0xAC, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0xC9, 0xAD, 0x06, 0x00, 0xA2, 0x2C, 0x13, 0x00, 0x40, 0x10,
+0xFF, 0xFF, 0x07, 0x24, 0x02, 0x80, 0x02, 0x3C, 0x80, 0x1A, 0x05, 0x00,
+0x00, 0x00, 0x42, 0x24, 0x0E, 0x00, 0xA0, 0x10, 0x21, 0x30, 0x62, 0x00,
+0x90, 0x00, 0xC3, 0x8C, 0xFF, 0xFF, 0x02, 0x24, 0x0A, 0x00, 0x62, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x8C, 0x00, 0xC2, 0x8C, 0x00, 0x00, 0x00, 0x00,
+0x06, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x24,
+0x88, 0x00, 0xC4, 0xAC, 0x8C, 0x00, 0xC2, 0xAC, 0x90, 0x00, 0xC5, 0xAC,
+0x21, 0x38, 0xA0, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0xE0, 0x00,
+0xE0, 0xFF, 0xBD, 0x27, 0x02, 0x80, 0x02, 0x3C, 0x1C, 0x00, 0xBF, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0xC3, 0x5C, 0x46, 0x90, 0x25, 0xB0, 0x07, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xDB, 0xFF, 0x03, 0x24, 0x18, 0x03, 0xE4, 0x34, 0x27, 0x00, 0xE5, 0x34,
+0x1C, 0xAE, 0x42, 0x24, 0x00, 0x00, 0x82, 0xAC, 0x00, 0x00, 0xA3, 0xA0,
+0x02, 0x00, 0xC0, 0x10, 0x1B, 0x00, 0xE3, 0x34, 0x1F, 0x00, 0xE3, 0x34,
+0x07, 0x00, 0x02, 0x24, 0x00, 0x00, 0x62, 0xA0, 0xF0, 0x42, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x00, 0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x50, 0x24,
+0x34, 0x1C, 0x04, 0x8E, 0xE3, 0x43, 0x00, 0x0C, 0x10, 0x00, 0x05, 0x24,
+0x40, 0x1C, 0x04, 0x8E, 0x10, 0x00, 0x05, 0x3C, 0x01, 0x00, 0x06, 0x24,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x90, 0x40, 0x00, 0x3C, 0x1C, 0x04, 0x8E,
+0x10, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24,
+0x58, 0x1C, 0x04, 0x8E, 0x00, 0x04, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x58, 0x1C, 0x04, 0x8E, 0x00, 0x08, 0x05, 0x24,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x02, 0x80, 0x05, 0x3C,
+0x78, 0xDA, 0xA5, 0x24, 0x21, 0x20, 0x00, 0x00, 0xC1, 0x45, 0x00, 0x0C,
+0xCA, 0x00, 0x06, 0x24, 0x31, 0x00, 0x40, 0x10, 0x21, 0x18, 0x00, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xCF, 0x5C, 0x43, 0x90, 0x01, 0x00, 0x11, 0x24,
+0x53, 0x00, 0x71, 0x10, 0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0x4A, 0xF5, 0x43, 0x90, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x71, 0x10,
+0x02, 0x80, 0x05, 0x3C, 0x34, 0x1C, 0x04, 0x8E, 0x21, 0x30, 0x40, 0x02,
+0x10, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C, 0x02, 0x80, 0x11, 0x3C,
+0xC6, 0x5C, 0x23, 0x92, 0x11, 0x00, 0x02, 0x24, 0x2A, 0x00, 0x62, 0x10,
+0x00, 0x08, 0x04, 0x24, 0xF0, 0x42, 0x00, 0x0C, 0x01, 0x00, 0x04, 0x24,
+0x34, 0x1C, 0x04, 0x8E, 0xE3, 0x43, 0x00, 0x0C, 0x10, 0x00, 0x05, 0x3C,
+0x40, 0x1C, 0x04, 0x8E, 0x10, 0x00, 0x05, 0x3C, 0x01, 0x00, 0x06, 0x24,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x90, 0x40, 0x00, 0x3C, 0x1C, 0x04, 0x8E,
+0x10, 0x00, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24,
+0x58, 0x1C, 0x04, 0x8E, 0x00, 0x04, 0x05, 0x24, 0xC1, 0x43, 0x00, 0x0C,
+0x21, 0x30, 0x00, 0x00, 0x58, 0x1C, 0x04, 0x8E, 0x00, 0x08, 0x05, 0x24,
+0xC1, 0x43, 0x00, 0x0C, 0x21, 0x30, 0x00, 0x00, 0x02, 0x80, 0x05, 0x3C,
+0x20, 0xDA, 0xA5, 0x24, 0x01, 0x00, 0x04, 0x24, 0xC1, 0x45, 0x00, 0x0C,
+0x16, 0x00, 0x06, 0x24, 0x08, 0x00, 0x40, 0x14, 0x21, 0x18, 0x00, 0x00,
+0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F,
+0x10, 0x00, 0xB0, 0x8F, 0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x34, 0x1C, 0x04, 0x8E, 0x21, 0x30, 0x40, 0x02,
+0xC1, 0x43, 0x00, 0x0C, 0x10, 0x00, 0x05, 0x3C, 0x00, 0x08, 0x04, 0x24,
+0x00, 0x01, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x24,
+0x00, 0x08, 0x04, 0x24, 0x00, 0x02, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C,
+0x01, 0x00, 0x06, 0x24, 0xC6, 0x5C, 0x23, 0x92, 0x11, 0x00, 0x02, 0x24,
+0x1D, 0x00, 0x62, 0x10, 0x00, 0x08, 0x04, 0x24, 0xF0, 0x42, 0x00, 0x0C,
+0x21, 0x20, 0x00, 0x00, 0x0F, 0x00, 0x05, 0x3C, 0x0C, 0x00, 0x06, 0x3C,
+0xFF, 0xFF, 0xA5, 0x34, 0x00, 0xB4, 0xC6, 0x34, 0x83, 0x45, 0x00, 0x0C,
+0x08, 0x00, 0x04, 0x24, 0x1C, 0x00, 0xBF, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x01, 0x00, 0x03, 0x24,
+0x21, 0x10, 0x60, 0x00, 0x08, 0x00, 0xE0, 0x03, 0x20, 0x00, 0xBD, 0x27,
+0x10, 0xD9, 0xA5, 0x24, 0x21, 0x20, 0x00, 0x00, 0xC1, 0x45, 0x00, 0x0C,
+0x16, 0x00, 0x06, 0x24, 0xC0, 0x6B, 0x00, 0x08, 0x02, 0x80, 0x02, 0x3C,
+0x68, 0xD9, 0xA5, 0x24, 0x21, 0x20, 0x00, 0x00, 0xC1, 0x45, 0x00, 0x0C,
+0x16, 0x00, 0x06, 0x24, 0xC4, 0x6B, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+0x00, 0xFF, 0x05, 0x3C, 0xC1, 0x43, 0x00, 0x0C, 0x03, 0x00, 0x06, 0x24,
+0x01, 0x6C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x02, 0x80, 0x02, 0x3C, 0x25, 0x59, 0x47, 0x90, 0x02, 0x80, 0x04, 0x3C,
+0x02, 0x80, 0x05, 0x3C, 0x03, 0x00, 0x03, 0x24, 0x4E, 0x37, 0x84, 0x24,
+0xB4, 0xDF, 0xA5, 0x24, 0x0F, 0x00, 0xE3, 0x10, 0x0D, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0x4E, 0x37, 0x84, 0x24,
+0x64, 0xDF, 0xA5, 0x24, 0xF4, 0x54, 0x00, 0x0C, 0x0D, 0x00, 0x06, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C, 0x10, 0x00, 0xBF, 0x8F,
+0x5B, 0x37, 0x84, 0x24, 0x74, 0xDF, 0xA5, 0x24, 0x0D, 0x00, 0x06, 0x24,
+0xF4, 0x54, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27, 0xF4, 0x54, 0x00, 0x0C,
+0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x02, 0x80, 0x05, 0x3C,
+0x10, 0x00, 0xBF, 0x8F, 0x5B, 0x37, 0x84, 0x24, 0xA4, 0xDF, 0xA5, 0x24,
+0x0D, 0x00, 0x06, 0x24, 0xF4, 0x54, 0x00, 0x08, 0x18, 0x00, 0xBD, 0x27,
+0xE0, 0xFF, 0xBD, 0x27, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x02, 0x80, 0x05, 0x3C, 0x02, 0x80, 0x10, 0x3C, 0x02, 0x80, 0x11, 0x3C,
+0x60, 0x1B, 0x31, 0x26, 0x2C, 0x59, 0x04, 0x26, 0xA0, 0xDD, 0xA5, 0x24,
+0x34, 0x00, 0x06, 0x24, 0x18, 0x00, 0xBF, 0xAF, 0xF4, 0x54, 0x00, 0x0C,
+0x2C, 0x59, 0x10, 0x26, 0x24, 0x6C, 0x00, 0x0C, 0x00, 0x3E, 0x30, 0xAE,
+0x02, 0x00, 0x10, 0x24, 0x02, 0x80, 0x04, 0x3C, 0x00, 0x80, 0x06, 0x3C,
+0x9C, 0x39, 0x30, 0xA2, 0xE8, 0x54, 0x84, 0x24, 0x98, 0x5B, 0xC6, 0x24,
+0xCF, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x01, 0x80, 0x06, 0x3C, 0xB8, 0x39, 0x30, 0xA2, 0x04, 0x55, 0x84, 0x24,
+0x90, 0x3B, 0xC6, 0x24, 0xCF, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0x02, 0x80, 0x04, 0x3C, 0x01, 0x80, 0x06, 0x3C, 0xD4, 0x39, 0x30, 0xA2,
+0x20, 0x55, 0x84, 0x24, 0x08, 0x39, 0xC6, 0x24, 0xCF, 0x20, 0x00, 0x0C,
+0x21, 0x28, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C, 0x01, 0x80, 0x06, 0x3C,
+0xF0, 0x39, 0x30, 0xA2, 0x3C, 0x55, 0x84, 0x24, 0x74, 0x44, 0xC6, 0x24,
+0xCF, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00, 0x02, 0x80, 0x04, 0x3C,
+0x00, 0x80, 0x06, 0x3C, 0x0C, 0x3A, 0x30, 0xA2, 0x58, 0x55, 0x84, 0x24,
+0xFC, 0x5A, 0xC6, 0x24, 0xCF, 0x20, 0x00, 0x0C, 0x21, 0x28, 0x00, 0x00,
+0x09, 0x00, 0x02, 0x24, 0xB8, 0x40, 0x22, 0xA2, 0xC7, 0x3D, 0x20, 0xA2,
+0x3A, 0x41, 0x20, 0xA2, 0xC8, 0x3D, 0x20, 0xA6, 0x18, 0x00, 0xBF, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x20, 0x00, 0xBD, 0x27, 0x03, 0x80, 0x05, 0x3C, 0x00, 0x80, 0xA5, 0x24,
+0xD8, 0xFF, 0xBD, 0x27, 0x40, 0x10, 0x0D, 0x3C, 0xFF, 0xFF, 0xA5, 0x30,
+0x02, 0x80, 0x02, 0x3C, 0x60, 0x1B, 0x42, 0x24, 0x20, 0x00, 0xBE, 0xAF,
+0x25, 0xF0, 0xAD, 0x00, 0x2C, 0x38, 0x5E, 0xAC, 0x00, 0x01, 0xDE, 0x27,
+0x38, 0x38, 0x5E, 0xAC, 0x00, 0x01, 0xDE, 0x27, 0x1C, 0x00, 0xB7, 0xAF,
+0x18, 0x00, 0xB6, 0xAF, 0x14, 0x00, 0xB5, 0xAF, 0x10, 0x00, 0xB4, 0xAF,
+0x0C, 0x00, 0xB3, 0xAF, 0x08, 0x00, 0xB2, 0xAF, 0x04, 0x00, 0xB1, 0xAF,
+0x00, 0x00, 0xB0, 0xAF, 0x44, 0x38, 0x5E, 0xAC, 0x00, 0x01, 0xDE, 0x27,
+0x50, 0x38, 0x5E, 0xAC, 0xAA, 0x1B, 0x44, 0x90, 0x00, 0x01, 0xDE, 0x27,
+0x5C, 0x38, 0x5E, 0xAC, 0x00, 0x01, 0xDE, 0x27, 0x68, 0x38, 0x5E, 0xAC,
+0x20, 0xB0, 0x06, 0x3C, 0x38, 0x38, 0x48, 0x8C, 0x44, 0x38, 0x49, 0x8C,
+0x50, 0x38, 0x4A, 0x8C, 0x5C, 0x38, 0x4B, 0x8C, 0x68, 0x38, 0x4C, 0x8C,
+0x00, 0x22, 0x04, 0x00, 0x00, 0x01, 0xC7, 0x34, 0xFF, 0x1F, 0x03, 0x3C,
+0x00, 0x01, 0xDE, 0x27, 0xFF, 0xFF, 0x63, 0x34, 0x21, 0x38, 0x87, 0x00,
+0x21, 0x20, 0x86, 0x00, 0x24, 0x38, 0xE3, 0x00, 0x20, 0x10, 0x06, 0x3C,
+0x24, 0x20, 0x83, 0x00, 0x74, 0x38, 0x5E, 0xAC, 0x21, 0x70, 0xC0, 0x03,
+0x25, 0x28, 0xAD, 0x00, 0x25, 0xB0, 0x0F, 0x3C, 0x00, 0x01, 0xDE, 0x27,
+0x28, 0x38, 0x45, 0xAC, 0x34, 0x38, 0x48, 0xAC, 0x40, 0x38, 0x49, 0xAC,
+0x4C, 0x38, 0x4A, 0xAC, 0xEC, 0x37, 0x44, 0xAC, 0x58, 0x38, 0x4B, 0xAC,
+0xF8, 0x37, 0x47, 0xAC, 0x64, 0x38, 0x4C, 0xAC, 0xAC, 0x00, 0xE3, 0x35,
+0xC0, 0x37, 0x46, 0xAC, 0xBC, 0x37, 0x46, 0xAC, 0xCC, 0x37, 0x46, 0xAC,
+0xC8, 0x37, 0x46, 0xAC, 0x80, 0x38, 0x5E, 0xAC, 0xF0, 0x37, 0x44, 0xAC,
+0xFC, 0x37, 0x47, 0xAC, 0x70, 0x38, 0x4E, 0xAC, 0xD8, 0x37, 0x46, 0xAC,
+0xD4, 0x37, 0x46, 0xAC, 0xE4, 0x37, 0x46, 0xAC, 0xE0, 0x37, 0x46, 0xAC,
+0x08, 0x38, 0x46, 0xAC, 0x04, 0x38, 0x46, 0xAC, 0xAC, 0x1B, 0x47, 0x94,
+0x00, 0x02, 0xDE, 0x27, 0x00, 0x00, 0x69, 0x8C, 0x21, 0x10, 0x05, 0x3C,
+0x98, 0x38, 0x5E, 0xAC, 0xB0, 0x00, 0xE3, 0x35, 0x00, 0x00, 0x79, 0x8C,
+0x80, 0x38, 0x54, 0x8C, 0x00, 0x80, 0xA4, 0x34, 0x23, 0x10, 0x0D, 0x3C,
+0x22, 0x10, 0x10, 0x3C, 0x02, 0x80, 0x16, 0x3C, 0x02, 0x80, 0x17, 0x3C,
+0x02, 0x80, 0x18, 0x3C, 0x02, 0x80, 0x13, 0x3C, 0x23, 0x20, 0x87, 0x00,
+0x02, 0x80, 0x03, 0x3C, 0x24, 0x10, 0x07, 0x3C, 0xC0, 0x54, 0x68, 0x24,
+0xCC, 0x38, 0x44, 0xAC, 0x21, 0xA8, 0xC0, 0x03, 0xC8, 0x54, 0xCE, 0x26,
+0x00, 0x04, 0xDE, 0x27, 0xD0, 0x54, 0xEA, 0x26, 0xD8, 0x54, 0x0B, 0x27,
+0xE0, 0x54, 0x6C, 0x26, 0x00, 0x04, 0xB1, 0x35, 0x01, 0x00, 0x29, 0x25,
+0x00, 0x40, 0x12, 0x36, 0x00, 0x01, 0xEF, 0x35, 0x01, 0x00, 0x03, 0x24,
+0x02, 0x80, 0x04, 0x3C, 0x7C, 0x38, 0x54, 0xAC, 0x85, 0x38, 0x43, 0xA0,
+0x94, 0x38, 0x55, 0xAC, 0xFC, 0x38, 0x51, 0xAC, 0xC0, 0x38, 0x49, 0xAC,
+0xF0, 0x38, 0x52, 0xAC, 0xE4, 0x38, 0x59, 0xAC, 0x00, 0x00, 0xE7, 0xAD,
+0xE0, 0x38, 0x47, 0xAC, 0x00, 0x39, 0x46, 0xAC, 0x14, 0x38, 0x46, 0xAC,
+0x10, 0x38, 0x46, 0xAC, 0x9E, 0x38, 0x40, 0xA4, 0x9D, 0x38, 0x40, 0xA0,
+0x9C, 0x38, 0x40, 0xA0, 0xF4, 0x38, 0x4D, 0xAC, 0xF8, 0x38, 0x4D, 0xAC,
+0xB8, 0x38, 0x45, 0xAC, 0xBC, 0x38, 0x45, 0xAC, 0xC4, 0x38, 0x45, 0xAC,
+0xC8, 0x38, 0x45, 0xAC, 0xE8, 0x38, 0x50, 0xAC, 0xEC, 0x38, 0x50, 0xAC,
+0xDC, 0x38, 0x47, 0xAC, 0x04, 0x39, 0x46, 0xAC, 0x10, 0x39, 0x5E, 0xAC,
+0x0C, 0x39, 0x5E, 0xAC, 0x04, 0x00, 0x4A, 0xAD, 0xC8, 0x54, 0xCE, 0xAE,
+0x04, 0x00, 0x6B, 0xAD, 0xD0, 0x54, 0xEA, 0xAE, 0x04, 0x00, 0x8C, 0xAD,
+0xD8, 0x54, 0x0B, 0xAF, 0x04, 0x00, 0x08, 0xAD, 0xE0, 0x54, 0x6C, 0xAE,
+0xC0, 0x54, 0x88, 0xAC, 0x04, 0x00, 0xCE, 0xAD, 0x02, 0x80, 0x04, 0x3C,
+0x18, 0x18, 0x83, 0x24, 0x02, 0x80, 0x05, 0x3C, 0x00, 0x18, 0xA2, 0x24,
+0x18, 0x18, 0x83, 0xAC, 0x02, 0x80, 0x04, 0x3C, 0x04, 0x00, 0x02, 0xAD,
+0x00, 0x18, 0xA8, 0xAC, 0xC0, 0x54, 0x82, 0xAC, 0x21, 0x48, 0x60, 0x00,
+0x08, 0x00, 0x5E, 0xAC, 0x01, 0x00, 0x07, 0x24, 0x04, 0x00, 0x63, 0xAC,
+0x00, 0x01, 0xDE, 0x27, 0x04, 0x00, 0x48, 0xAC, 0x10, 0x00, 0x40, 0xAC,
+0x21, 0x40, 0x40, 0x00, 0x21, 0x18, 0xC0, 0x01, 0x21, 0x28, 0x00, 0x00,
+0x0F, 0x00, 0x06, 0x24, 0x21, 0x20, 0xA9, 0x00, 0x21, 0x10, 0xA8, 0x00,
+0xFF, 0xFF, 0xC6, 0x24, 0x20, 0x00, 0x5E, 0xAC, 0x28, 0x00, 0x47, 0xAC,
+0x18, 0x00, 0xA5, 0x24, 0x00, 0x00, 0x8E, 0xAC, 0x04, 0x00, 0x83, 0xAC,
+0x00, 0x00, 0x64, 0xAC, 0x00, 0x01, 0xDE, 0x27, 0xF5, 0xFF, 0xC1, 0x04,
+0x21, 0x18, 0x80, 0x00, 0x02, 0x80, 0x02, 0x3C, 0xD0, 0x54, 0x48, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0x04, 0x00, 0x07, 0x8D,
+0x98, 0x19, 0x4B, 0x24, 0x04, 0x00, 0xC4, 0xAD, 0x00, 0x18, 0x6A, 0x24,
+0x02, 0x00, 0x09, 0x24, 0x21, 0x28, 0x00, 0x00, 0x0F, 0x00, 0x06, 0x24,
+0x21, 0x20, 0xAB, 0x00, 0x21, 0x10, 0xAA, 0x00, 0xFF, 0xFF, 0xC6, 0x24,
+0xA0, 0x01, 0x5E, 0xAC, 0xA8, 0x01, 0x49, 0xAC, 0x18, 0x00, 0xA5, 0x24,
+0x00, 0x00, 0x88, 0xAC, 0x04, 0x00, 0x87, 0xAC, 0x00, 0x00, 0xE4, 0xAC,
+0x00, 0x02, 0xDE, 0x27, 0xF5, 0xFF, 0xC1, 0x04, 0x21, 0x38, 0x80, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xD8, 0x54, 0x49, 0x24, 0x02, 0x80, 0x03, 0x3C,
+0x02, 0x80, 0x02, 0x3C, 0x04, 0x00, 0x25, 0x8D, 0x18, 0x1B, 0x4B, 0x24,
+0x04, 0x00, 0x04, 0xAD, 0x00, 0x18, 0x6A, 0x24, 0x03, 0x00, 0x07, 0x24,
+0x21, 0x20, 0x00, 0x00, 0x01, 0x00, 0x06, 0x24, 0x21, 0x40, 0x8B, 0x00,
+0x21, 0x10, 0x8A, 0x00, 0xFF, 0xFF, 0xC6, 0x24, 0x20, 0x03, 0x5E, 0xAC,
+0x28, 0x03, 0x47, 0xAC, 0x18, 0x00, 0x84, 0x24, 0x00, 0x00, 0x09, 0xAD,
+0x04, 0x00, 0x05, 0xAD, 0x00, 0x00, 0xA8, 0xAC, 0x00, 0x08, 0xDE, 0x27,
+0xF5, 0xFF, 0xC1, 0x04, 0x21, 0x28, 0x00, 0x01, 0x02, 0x80, 0x05, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0xE0, 0x54, 0xA5, 0x24, 0x00, 0x18, 0x63, 0x24,
+0x04, 0x00, 0xA6, 0x8C, 0x1C, 0x00, 0xB7, 0x8F, 0x50, 0x03, 0x7E, 0xAC,
+0x18, 0x00, 0xB6, 0x8F, 0x20, 0x00, 0xBE, 0x8F, 0x14, 0x00, 0xB5, 0x8F,
+0x10, 0x00, 0xB4, 0x8F, 0x0C, 0x00, 0xB3, 0x8F, 0x08, 0x00, 0xB2, 0x8F,
+0x04, 0x00, 0xB1, 0x8F, 0x00, 0x00, 0xB0, 0x8F, 0x02, 0x80, 0x07, 0x3C,
+0x48, 0x1B, 0xE4, 0x24, 0x04, 0x00, 0x02, 0x24, 0x28, 0x00, 0xBD, 0x27,
+0x04, 0x00, 0x28, 0xAD, 0x04, 0x00, 0xA4, 0xAC, 0x58, 0x03, 0x62, 0xAC,
+0x48, 0x1B, 0xE5, 0xAC, 0x04, 0x00, 0x86, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0xC4, 0xAC, 0xFA, 0x63, 0x00, 0x6A, 0x09, 0xD1, 0x0A, 0x62,
+0x08, 0xD0, 0x06, 0xD2, 0x7D, 0x67, 0x18, 0xA3, 0x10, 0xF0, 0x02, 0x69,
+0x00, 0xF4, 0x20, 0x31, 0x63, 0xF3, 0x00, 0x49, 0x00, 0x18, 0xDB, 0x5C,
+0x06, 0x94, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0x5C, 0xF4, 0x00, 0x4A, 0xDC, 0xF3,
+0x0C, 0x4B, 0x7B, 0x9B, 0x5B, 0x9A, 0x00, 0x6D, 0x69, 0xE2, 0x46, 0x32,
+0xC4, 0xF4, 0x54, 0xD9, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0xBC, 0xF3, 0x0C, 0x4A, 0x5B, 0xA2, 0x01, 0xF6, 0x01, 0x6B, 0x6B, 0xEB,
+0x50, 0x32, 0xE4, 0xF4, 0x5C, 0xD9, 0xE4, 0xF4, 0x58, 0xD9, 0x04, 0xF5,
+0x48, 0x99, 0x6C, 0xEA, 0x00, 0xF2, 0x00, 0x6B, 0x6D, 0xEA, 0x04, 0xF5,
+0x48, 0xD9, 0xA9, 0xE1, 0x01, 0x4D, 0x1D, 0x55, 0x04, 0xF5, 0x0C, 0xC2,
+0x44, 0xF5, 0x06, 0xC2, 0x24, 0xF5, 0x09, 0xC2, 0xF6, 0x61, 0x00, 0x6A,
+0x64, 0xF5, 0x44, 0xD9, 0x06, 0x94, 0x7F, 0x49, 0x15, 0x49, 0x01, 0x4C,
+0x20, 0x54, 0x06, 0xD4, 0xBF, 0x61, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4,
+0xA0, 0x35, 0x10, 0xF0, 0x02, 0x69, 0x00, 0xF4, 0x20, 0x31, 0x10, 0xF0,
+0x02, 0x68, 0x00, 0xF4, 0x00, 0x30, 0x10, 0xF0, 0x02, 0x6F, 0x00, 0xF4,
+0xE0, 0x37, 0x10, 0xF0, 0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x06, 0xD2,
+0x63, 0xF3, 0x00, 0x4D, 0x5C, 0xF4, 0x00, 0x49, 0xDC, 0xF3, 0x0C, 0x48,
+0xBC, 0xF3, 0x0C, 0x4F, 0x9C, 0xF3, 0x0C, 0x4E, 0x06, 0x93, 0x68, 0x32,
+0x2D, 0xE2, 0x60, 0x9B, 0xB1, 0xE2, 0x09, 0xE2, 0xC0, 0xF5, 0x74, 0xDC,
+0x40, 0x9A, 0x60, 0xF5, 0x40, 0xDC, 0x06, 0x94, 0xE9, 0xE4, 0x40, 0xA2,
+0xAD, 0xE4, 0x00, 0xF5, 0x44, 0xC3, 0xC9, 0xE4, 0x40, 0xA2, 0x01, 0x4C,
+0x1D, 0x54, 0x20, 0xF5, 0x5E, 0xC3, 0x06, 0xD4, 0xE7, 0x61, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4,
+0x60, 0x33, 0x00, 0x6D, 0x10, 0xF0, 0x02, 0x69, 0x00, 0xF4, 0x20, 0x31,
+0x7C, 0xF2, 0x08, 0x4A, 0x1C, 0xF1, 0x08, 0x4B, 0x06, 0xD5, 0x63, 0xF3,
+0x00, 0x49, 0x2A, 0x65, 0x0B, 0x65, 0x05, 0x67, 0x89, 0x67, 0x00, 0x6D,
+0x3D, 0xE0, 0x99, 0xE0, 0xAD, 0xE6, 0x40, 0xA3, 0xB1, 0xE7, 0x01, 0x4D,
+0xA0, 0xF3, 0x48, 0xC4, 0x80, 0xF0, 0x51, 0xA3, 0x05, 0x55, 0x20, 0xF4,
+0x59, 0xC4, 0xF4, 0x61, 0x06, 0x95, 0x48, 0x67, 0x05, 0x48, 0x4D, 0xE5,
+0x40, 0xA3, 0x31, 0xE5, 0x01, 0x4D, 0xC0, 0xF4, 0x4A, 0xC4, 0x5D, 0xA3,
+0x1D, 0x55, 0xE0, 0xF4, 0x47, 0xC4, 0x06, 0xD5, 0xE1, 0x61, 0x9D, 0x67,
+0x52, 0x6A, 0x50, 0xC4, 0x41, 0x6A, 0x51, 0xC4, 0x00, 0x6B, 0x4D, 0x6A,
+0x52, 0xC4, 0x73, 0xC4, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x7E, 0xF5, 0x00, 0x4C, 0xE0, 0xF3, 0x08, 0x6A, 0x43, 0xDC, 0xBD, 0x67,
+0x01, 0x6A, 0x10, 0xF0, 0x01, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x54, 0xC4,
+0x30, 0xF7, 0x01, 0x4E, 0x00, 0x1C, 0xCF, 0x20, 0x10, 0x4D, 0x0A, 0x97,
+0x09, 0x91, 0x08, 0x90, 0x00, 0xEF, 0x06, 0x63, 0xC9, 0xF7, 0x1B, 0x6C,
+0xF1, 0x63, 0x8B, 0xEC, 0x1B, 0xD1, 0x80, 0x31, 0x20, 0x31, 0xE1, 0xF6,
+0x80, 0x41, 0x1C, 0x62, 0x00, 0x1C, 0xFA, 0x5B, 0x1A, 0xD0, 0xD1, 0xF6,
+0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x07, 0xD2, 0x71, 0xF6, 0x80, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x08, 0xD2, 0x71, 0xF6, 0x84, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x09, 0xD2, 0x71, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x0A, 0xD2, 0x71, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x0B, 0xD2,
+0x81, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x0C, 0xD2, 0x81, 0xF6,
+0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x0D, 0xD2, 0x81, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x0E, 0xD2, 0x81, 0xF6, 0x8C, 0x41, 0xE7, 0xF7,
+0x0E, 0x68, 0x00, 0x1C, 0xFA, 0x5B, 0x0F, 0xD2, 0xD1, 0xF6, 0x80, 0x41,
+0x10, 0xD2, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x30, 0xD1, 0xF6, 0x84, 0x41,
+0x00, 0x30, 0x00, 0x1C, 0xFA, 0x5B, 0x11, 0xD2, 0xD1, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x12, 0xD2, 0xB0, 0x67, 0xE1, 0xF6, 0x80, 0x41,
+0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x13, 0xD2, 0xB0, 0x67,
+0xD1, 0xF6, 0x8C, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xB0, 0x67, 0x71, 0xF6, 0x80, 0x41, 0xF2, 0xF2, 0x1B, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67, 0x71, 0xF6, 0x84, 0x41,
+0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67,
+0x71, 0xF6, 0x88, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xB0, 0x67, 0x71, 0xF6, 0x8C, 0x41, 0xF2, 0xF2, 0x1B, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67, 0x81, 0xF6, 0x80, 0x41,
+0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67,
+0x81, 0xF6, 0x84, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xB0, 0x67, 0x81, 0xF6, 0x88, 0x41, 0xF2, 0xF2, 0x1B, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67, 0x81, 0xF6, 0x8C, 0x41,
+0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67,
+0xD1, 0xF6, 0x80, 0x41, 0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xB0, 0x67, 0xD1, 0xF6, 0x84, 0x41, 0xF2, 0xF2, 0x1B, 0x4D,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0xB0, 0x67, 0xD1, 0xF6, 0x88, 0x41,
+0xF2, 0xF2, 0x1B, 0x4D, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0x6A,
+0x04, 0xD2, 0xFF, 0x6A, 0x01, 0x4A, 0x40, 0x30, 0x00, 0xF5, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x15, 0xD2, 0x01, 0xF0, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0x00, 0x30, 0x16, 0xD2, 0x21, 0xF0,
+0x80, 0x41, 0x00, 0xF1, 0xA0, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65,
+0x21, 0xF0, 0x88, 0x41, 0x00, 0xF1, 0xA0, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0xA0, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x2A, 0xF4, 0x10, 0x4D,
+0x01, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0x1C,
+0x5B, 0x1F, 0x05, 0x6C, 0x01, 0xF0, 0x00, 0x6D, 0xA0, 0x35, 0x7F, 0x4D,
+0x01, 0xF4, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x65, 0x4D, 0x00, 0x1C,
+0x5B, 0x1F, 0x05, 0x6C, 0x8F, 0xF7, 0x00, 0x6D, 0xAB, 0xED, 0xA0, 0x35,
+0x21, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0xA0, 0x35, 0x00, 0x1C,
+0x5B, 0x1F, 0x05, 0x6C, 0x00, 0xF2, 0x14, 0x6D, 0xA0, 0x35, 0xA0, 0x35,
+0x00, 0xF1, 0x02, 0x4D, 0x41, 0xF6, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x0D, 0xF0, 0x16, 0x6D,
+0xA0, 0x35, 0xA0, 0x35, 0xC0, 0xF4, 0x02, 0x4D, 0x41, 0xF6, 0x84, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C,
+0xC5, 0xF0, 0x11, 0x6D, 0x41, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x00, 0xF2, 0x14, 0x6D,
+0xA0, 0x35, 0xA0, 0x35, 0x00, 0xF1, 0x02, 0x4D, 0x61, 0xF6, 0x80, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C,
+0x05, 0xF0, 0x16, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0x01, 0xF5, 0x05, 0x4D,
+0x61, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x65, 0x00, 0x1C,
+0x5B, 0x1F, 0x05, 0x6C, 0x41, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x15, 0x95, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x41, 0xF6, 0x88, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0x16, 0x95, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C,
+0x00, 0x1C, 0x2C, 0x1F, 0x02, 0x6C, 0x00, 0xF2, 0x00, 0x6D, 0xA0, 0x35,
+0xA0, 0x35, 0xC5, 0xF0, 0x11, 0x4D, 0x61, 0xF6, 0x8C, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x41, 0xF6,
+0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x15, 0x95, 0x00, 0x1C, 0x5B, 0x1F,
+0x05, 0x6C, 0x41, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x16, 0x95,
+0x00, 0x1C, 0x2C, 0x1F, 0x02, 0x6C, 0xA0, 0x6D, 0xA0, 0x35, 0xA0, 0x35,
+0x2A, 0xF4, 0x13, 0x4D, 0x01, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x00, 0x65, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x01, 0xF4, 0x88, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0xE4, 0x6D, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C,
+0x21, 0xF6, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x00, 0x6D, 0x21, 0xF0,
+0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0xB0, 0x67, 0x21, 0xF0, 0x88, 0x41,
+0x00, 0x1C, 0xDD, 0x5B, 0xB0, 0x67, 0xA1, 0xF6, 0x8C, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x05, 0xF0, 0x00, 0x6B, 0x6B, 0xEB, 0x60, 0x33,
+0x60, 0x33, 0x4C, 0xEB, 0x51, 0x23, 0x04, 0x95, 0x01, 0x4D, 0x0A, 0x5D,
+0x04, 0xD5, 0x3F, 0xF7, 0x04, 0x61, 0xC9, 0xF7, 0x1B, 0x68, 0x0B, 0xE8,
+0x00, 0x30, 0x00, 0x30, 0xE1, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x07, 0x95, 0xD1, 0xF6, 0x8C, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x08, 0x95,
+0x71, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x09, 0x95, 0x71, 0xF6,
+0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x0A, 0x95, 0x71, 0xF6, 0x88, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x0B, 0x95, 0x71, 0xF6, 0x8C, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x0C, 0x95, 0x81, 0xF6, 0x80, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x0D, 0x95, 0x81, 0xF6, 0x84, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x0E, 0x95,
+0x81, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x0F, 0x95, 0x81, 0xF6,
+0x8C, 0x40, 0x00, 0x1C, 0xDD, 0x5B, 0x10, 0x95, 0xD1, 0xF6, 0x80, 0x40,
+0x00, 0x1C, 0xDD, 0x5B, 0x11, 0x95, 0xD1, 0xF6, 0x84, 0x40, 0x00, 0x1C,
+0xDD, 0x5B, 0x12, 0x95, 0x81, 0xF6, 0x88, 0x40, 0x00, 0x1C, 0xDD, 0x5B,
+0x13, 0x95, 0x1C, 0x97, 0x1B, 0x91, 0x1A, 0x90, 0x00, 0xEF, 0x0F, 0x63,
+0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3,
+0x1F, 0x6B, 0x4C, 0xEB, 0x91, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x14, 0xD3, 0xE0, 0xF3, 0x1F, 0x6C, 0x80, 0x34, 0x80, 0x34, 0x8C, 0xEA,
+0x42, 0x33, 0x14, 0x92, 0x62, 0x33, 0x10, 0xF0, 0x02, 0x6D, 0x00, 0xF4,
+0xA0, 0x35, 0x58, 0xEB, 0x63, 0xF3, 0x00, 0x4D, 0x17, 0xD5, 0xE0, 0xF3,
+0x1F, 0x6D, 0x07, 0xF7, 0x00, 0x68, 0x12, 0xEC, 0x82, 0x33, 0x17, 0x94,
+0xAC, 0xEB, 0x00, 0xF4, 0x00, 0x6D, 0x43, 0x9C, 0xAB, 0xED, 0xAC, 0xEA,
+0x6D, 0xEA, 0x43, 0xDC, 0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x00, 0x30, 0x17, 0x94, 0x00, 0xF4, 0x00, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA,
+0x63, 0x9C, 0xE0, 0xF3, 0x1F, 0x6D, 0x81, 0xF4, 0x80, 0x41, 0xAC, 0xEB,
+0xA2, 0x67, 0x00, 0x1C, 0xDD, 0x5B, 0x6D, 0xED, 0x00, 0x1C, 0x5B, 0x1F,
+0x05, 0x6C, 0x91, 0xF6, 0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0xE0, 0xF3, 0x1F, 0x6B, 0x60, 0x33, 0x60, 0x33, 0x6C, 0xEA, 0x14, 0x93,
+0x42, 0x32, 0x42, 0x32, 0x78, 0xEA, 0xE0, 0xF3, 0x1F, 0x6C, 0x80, 0x33,
+0x17, 0x94, 0x06, 0xD2, 0x43, 0x9C, 0x12, 0xED, 0xAC, 0xEB, 0x10, 0x6D,
+0xAB, 0xED, 0xA0, 0x35, 0xA0, 0x35, 0xE0, 0xF3, 0x1F, 0x4D, 0x68, 0x33,
+0xAC, 0xEA, 0x6D, 0xEA, 0x43, 0xDC, 0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x3F, 0x6B, 0x6B, 0xEB, 0x17, 0x94, 0x60, 0x33,
+0x60, 0x33, 0xFF, 0x4B, 0x6C, 0xEA, 0x63, 0x9C, 0xE0, 0xF3, 0x1F, 0x6D,
+0x3F, 0x6C, 0x62, 0x33, 0x6A, 0x33, 0xAC, 0xEB, 0x8C, 0xEB, 0x60, 0x33,
+0x60, 0x33, 0xA2, 0x67, 0x81, 0xF4, 0x80, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x6D, 0xED, 0x91, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x02, 0xF0, 0x00, 0x6D, 0x06, 0x93, 0xA0, 0x35, 0xA0, 0x35, 0xFF, 0x4D,
+0xC0, 0xF3, 0x00, 0x6C, 0xAC, 0xEA, 0x8C, 0xEB, 0xA2, 0x67, 0x06, 0xD3,
+0x80, 0xF5, 0x60, 0x33, 0x91, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x6D, 0xED, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x11, 0xF4, 0x84, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xA1, 0xF6, 0x84, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x05, 0xD2, 0xE0, 0xF3, 0x1F, 0x6D, 0xA0, 0x35, 0xA0, 0x35,
+0xAC, 0xEA, 0x42, 0x33, 0x05, 0x92, 0x00, 0xF4, 0x00, 0x6C, 0x8B, 0xEC,
+0x62, 0x33, 0x8C, 0xEA, 0x6D, 0xEA, 0x11, 0xF4, 0x84, 0x41, 0xA2, 0x67,
+0x00, 0x1C, 0xDD, 0x5B, 0x05, 0xD2, 0xA1, 0xF6, 0x8C, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0x01, 0x6B, 0x6B, 0xEB, 0x05, 0x95, 0x60, 0x33,
+0x60, 0x33, 0xE0, 0xF3, 0x1F, 0x4B, 0x0C, 0xEA, 0x6C, 0xED, 0x5A, 0x32,
+0x05, 0xD5, 0x11, 0xF4, 0x84, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x4D, 0xED,
+0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3, 0x1F, 0x6C, 0x4C, 0xEC, 0x14, 0xD4,
+0xB1, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3,
+0x1F, 0x6D, 0xA0, 0x35, 0xA0, 0x35, 0xAC, 0xEA, 0x42, 0x33, 0x62, 0x33,
+0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x18, 0xD3, 0x18, 0x93,
+0x14, 0x94, 0x98, 0xEB, 0xE0, 0xF3, 0x1F, 0x6B, 0x12, 0xED, 0xA2, 0x34,
+0x17, 0x95, 0x6C, 0xEC, 0x63, 0x9D, 0x00, 0xF4, 0x00, 0x6D, 0xAB, 0xED,
+0xAC, 0xEB, 0x8D, 0xEB, 0x17, 0x94, 0xAC, 0xEA, 0xE0, 0xF3, 0x1F, 0x6D,
+0x63, 0xDC, 0xAC, 0xEB, 0xA2, 0x67, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C,
+0xDD, 0x5B, 0x6D, 0xED, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0xB1, 0xF6,
+0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0xE0, 0xF3, 0x1F, 0x6B,
+0x60, 0x33, 0x60, 0x33, 0x6C, 0xEA, 0x14, 0x93, 0x42, 0x32, 0x42, 0x32,
+0x78, 0xEA, 0xE0, 0xF3, 0x1F, 0x6C, 0x80, 0x33, 0x17, 0x94, 0x06, 0xD2,
+0x43, 0x9C, 0x12, 0xED, 0xAC, 0xEB, 0x10, 0x6D, 0xAB, 0xED, 0xA0, 0x35,
+0xA0, 0x35, 0xE0, 0xF3, 0x1F, 0x4D, 0x68, 0x33, 0xAC, 0xEA, 0x6D, 0xEA,
+0x43, 0xDC, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65,
+0x10, 0xF0, 0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xBD, 0xF7, 0x18, 0x4B,
+0x17, 0x94, 0xA0, 0x9B, 0xE0, 0xF3, 0x1F, 0x6B, 0x4C, 0xED, 0x43, 0x9C,
+0x3F, 0x6C, 0x42, 0x32, 0x4A, 0x32, 0x6C, 0xEA, 0x8C, 0xEA, 0x40, 0x32,
+0x40, 0x32, 0x81, 0xF4, 0x88, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x4D, 0xED,
+0x91, 0xF4, 0x8C, 0x41, 0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x10, 0xF0,
+0x02, 0x6B, 0x00, 0xF4, 0x60, 0x33, 0xBD, 0xF7, 0x1C, 0x4B, 0xA0, 0x9B,
+0x06, 0x94, 0x4C, 0xED, 0xC0, 0xF3, 0x00, 0x6A, 0x4C, 0xEC, 0x80, 0xF5,
+0x80, 0x32, 0x91, 0xF4, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B, 0x4D, 0xED,
+0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x11, 0xF4, 0x8C, 0x41, 0x00, 0x1C,
+0xFA, 0x5B, 0x00, 0x65, 0xC1, 0xF6, 0x84, 0x41, 0x00, 0x1C, 0xFA, 0x5B,
+0x05, 0xD2, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0xDD, 0xF7,
+0x00, 0x4C, 0x60, 0x9C, 0x05, 0x95, 0x11, 0xF4, 0x8C, 0x41, 0x4C, 0xEB,
+0x00, 0xF4, 0x00, 0x6A, 0x4B, 0xEA, 0x62, 0x33, 0x62, 0x33, 0x4C, 0xED,
+0x6D, 0xED, 0x00, 0x1C, 0xDD, 0x5B, 0x05, 0xD5, 0xC1, 0xF6, 0x8C, 0x41,
+0x00, 0x1C, 0xFA, 0x5B, 0x00, 0x65, 0x01, 0x6C, 0x8B, 0xEC, 0x05, 0x93,
+0x80, 0x34, 0x80, 0x34, 0xE0, 0xF3, 0x1F, 0x4C, 0x8C, 0xEB, 0x4C, 0xE8,
+0xA3, 0x67, 0x1A, 0x30, 0x11, 0xF4, 0x8C, 0x41, 0x00, 0x1C, 0xDD, 0x5B,
+0x0D, 0xED, 0x00, 0x1C, 0x5B, 0x1F, 0x05, 0x6C, 0x1E, 0x16, 0x00, 0x00,
+0xFC, 0x63, 0x00, 0x6B, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x9D, 0x67, 0x26, 0xF7, 0x61, 0xC2, 0x42, 0x6A, 0x50, 0xC4, 0x43, 0x6A,
+0x51, 0xC4, 0x4E, 0x6A, 0x52, 0xC4, 0x73, 0xC4, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x9E, 0xF5, 0x18, 0x4C, 0xC0, 0xF7, 0x10, 0x6A,
+0x43, 0xDC, 0xBD, 0x67, 0x01, 0x6A, 0x10, 0xF0, 0x01, 0x6E, 0x00, 0xF4,
+0xC0, 0x36, 0x54, 0xC4, 0x13, 0xF6, 0x11, 0x4E, 0x06, 0x62, 0x00, 0x1C,
+0xCF, 0x20, 0x10, 0x4D, 0x06, 0x97, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x00,
+0xE0, 0x63, 0x3E, 0x62, 0x3C, 0xD0, 0x3D, 0xD1, 0x10, 0xF0, 0x02, 0x6D,
+0x00, 0xF4, 0xA0, 0x35, 0xC7, 0x63, 0x04, 0x04, 0xDD, 0xF7, 0x04, 0x4D,
+0x00, 0x1C, 0xF4, 0x54, 0x94, 0x6E, 0x9D, 0x67, 0x7F, 0x4C, 0x10, 0xF0,
+0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0xFF, 0x6E, 0x29, 0x4C, 0x5E, 0xF0,
+0x18, 0x4D, 0x00, 0x1C, 0xF4, 0x54, 0x09, 0x4E, 0x9D, 0x67, 0x10, 0xF0,
+0x02, 0x6D, 0x00, 0xF4, 0xA0, 0x35, 0xFF, 0x6E, 0xA0, 0xF1, 0x10, 0x4C,
+0x7E, 0xF1, 0x00, 0x4D, 0x00, 0x1C, 0xF4, 0x54, 0x09, 0x4E, 0x10, 0xF0,
+0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x00, 0x6B,
+0x63, 0xC2, 0x00, 0x68, 0xA2, 0x67, 0xFF, 0x6C, 0x08, 0x32, 0x04, 0x06,
+0xAD, 0xE2, 0xC9, 0xE2, 0x40, 0x9A, 0x01, 0x48, 0x8C, 0xE8, 0x25, 0x58,
+0x46, 0xDB, 0xF6, 0x61, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32,
+0x63, 0xF3, 0x00, 0x4A, 0x00, 0x68, 0x0A, 0x65, 0xFF, 0x69, 0x0C, 0x32,
+0x68, 0x67, 0x04, 0x04, 0x00, 0x6D, 0x7D, 0xE2, 0x99, 0xE2, 0xAD, 0xE6,
+0x80, 0xF0, 0x58, 0xA3, 0xB1, 0xE7, 0x01, 0x4D, 0xA0, 0xF0, 0x4C, 0xC4,
+0xA0, 0xF1, 0x40, 0xA3, 0x2C, 0xED, 0x08, 0x5D, 0xA0, 0xF1, 0x54, 0xC4,
+0xF2, 0x61, 0x01, 0x48, 0x2C, 0xE8, 0x21, 0x58, 0xE8, 0x61, 0xC8, 0x67,
+0x1F, 0x6A, 0xA0, 0xF2, 0x5E, 0xC6, 0x00, 0x6F, 0x01, 0x6A, 0x62, 0x9E,
+0xA0, 0xF2, 0xFF, 0xC6, 0xC0, 0xF2, 0x40, 0xC6, 0x10, 0xF0, 0x00, 0x6E,
+0xC0, 0x36, 0xC0, 0x36, 0xFF, 0x4E, 0x40, 0x6A, 0xCC, 0xEB, 0x4B, 0xEA,
+0x4C, 0xEB, 0x0C, 0x6A, 0x4D, 0xEB, 0x07, 0xF7, 0x01, 0x6A, 0x4B, 0xEA,
+0x4C, 0xEB, 0x03, 0xF0, 0x00, 0x6A, 0x4D, 0xEB, 0x07, 0xF7, 0x00, 0x6A,
+0x4B, 0xEA, 0x08, 0xF0, 0x00, 0x6C, 0x40, 0x32, 0x8B, 0xEC, 0xFF, 0x4A,
+0x80, 0x34, 0x4C, 0xEB, 0x4F, 0x44, 0x4C, 0xEB, 0x10, 0xF0, 0x00, 0x6A,
+0x4B, 0xEA, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB, 0x40, 0x6A, 0x4D, 0xEB,
+0x08, 0xF0, 0x00, 0x6D, 0x81, 0x6A, 0xAD, 0xEB, 0x4B, 0xEA, 0x4C, 0xEB,
+0xFF, 0x6A, 0x01, 0x4A, 0x4B, 0xEA, 0x40, 0x32, 0xEF, 0xF7, 0x1F, 0x4A,
+0x4C, 0xEB, 0x0C, 0xF0, 0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32,
+0xFF, 0x4A, 0x4C, 0xEB, 0x48, 0x67, 0x62, 0xDA, 0xA0, 0x35, 0x63, 0x9A,
+0x44, 0x9A, 0x80, 0x34, 0xA0, 0x35, 0xFF, 0x4C, 0xFF, 0x4D, 0xAC, 0xEA,
+0x8C, 0xEB, 0x88, 0x67, 0x44, 0xDC, 0x01, 0x6A, 0x4B, 0xEA, 0xC0, 0xF2,
+0x42, 0xC4, 0xFF, 0x6A, 0xCC, 0xEB, 0xC0, 0xF2, 0x44, 0xCC, 0x12, 0x6A,
+0xC0, 0xF2, 0xE6, 0xC4, 0x63, 0xDC, 0xC0, 0xF2, 0x47, 0xC4, 0x00, 0x1C,
+0xF6, 0x48, 0x00, 0x65, 0x39, 0x63, 0x3E, 0x97, 0x3D, 0x91, 0x3C, 0x90,
+0x00, 0xEF, 0x20, 0x63, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34,
+0x63, 0xF3, 0x00, 0x4C, 0xFF, 0xF7, 0x1F, 0x6A, 0x66, 0xF7, 0x4C, 0xDC,
+0x01, 0x6A, 0x4B, 0xEA, 0xFC, 0x63, 0x45, 0xC4, 0x1C, 0x6A, 0x06, 0x62,
+0xC0, 0xF2, 0x4F, 0xC4, 0xC0, 0xF2, 0x51, 0xC4, 0x0A, 0x6A, 0x3E, 0x6B,
+0xC0, 0xF2, 0x52, 0xC4, 0x40, 0x9C, 0xC0, 0xF2, 0x6E, 0xC4, 0xC0, 0xF2,
+0x70, 0xC4, 0x02, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA, 0x21, 0x6B, 0x6B, 0xEB,
+0x6C, 0xEA, 0x00, 0x6D, 0x40, 0xDC, 0x06, 0xF0, 0x00, 0x6A, 0xE0, 0xF2,
+0xA6, 0xC4, 0x4B, 0xEA, 0xE0, 0xF2, 0x64, 0x9C, 0x40, 0x32, 0x40, 0x32,
+0xFF, 0x4A, 0x4C, 0xEB, 0x20, 0x6A, 0xC0, 0xF2, 0x57, 0xC4, 0x08, 0xF0,
+0x00, 0x6A, 0x4B, 0xEA, 0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB,
+0x10, 0xF0, 0x00, 0x6A, 0x40, 0x32, 0x40, 0x32, 0xFF, 0x4A, 0x4C, 0xEB,
+0x20, 0x6A, 0xC0, 0xF2, 0x48, 0xCC, 0xFF, 0x6A, 0x01, 0x4A, 0xE0, 0xF2,
+0x64, 0xDC, 0xC0, 0xF2, 0x4A, 0xCC, 0x01, 0x6B, 0x00, 0xF2, 0x00, 0x6A,
+0xC0, 0xF2, 0xB6, 0xC4, 0xC0, 0xF2, 0xB4, 0xC4, 0xC0, 0xF2, 0xB5, 0xC4,
+0xC0, 0xF2, 0x4C, 0xCC, 0x61, 0xC4, 0x44, 0x6A, 0x9D, 0x67, 0x50, 0xC4,
+0x49, 0x6A, 0x51, 0xC4, 0x47, 0x6A, 0x52, 0xC4, 0xB3, 0xC4, 0x10, 0xF0,
+0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x7E, 0xF5, 0x1C, 0x4C, 0xC0, 0xF7,
+0x10, 0x6A, 0xBD, 0x67, 0x10, 0xF0, 0x01, 0x6E, 0x00, 0xF4, 0xC0, 0x36,
+0x43, 0xDC, 0x74, 0xC4, 0x93, 0xF6, 0x19, 0x4E, 0x00, 0x1C, 0xCF, 0x20,
+0x10, 0x4D, 0x06, 0x97, 0x00, 0xEF, 0x04, 0x63, 0xFA, 0x63, 0x08, 0xD0,
+0x10, 0xF0, 0x02, 0x68, 0x00, 0xF4, 0x00, 0x30, 0x63, 0xF3, 0x00, 0x48,
+0x40, 0x98, 0x11, 0x6B, 0x6B, 0xEB, 0x6C, 0xEA, 0x09, 0x6B, 0x6B, 0xEB,
+0x6C, 0xEA, 0x40, 0xD8, 0x7D, 0x67, 0x44, 0x6A, 0x50, 0xC3, 0x49, 0x6A,
+0x09, 0xD1, 0x51, 0xC3, 0x00, 0x69, 0x47, 0x6A, 0x10, 0xF0, 0x02, 0x6C,
+0x00, 0xF4, 0x80, 0x34, 0x1E, 0xF6, 0x08, 0x4C, 0x52, 0xC3, 0x33, 0xC3,
+0x14, 0x6A, 0x01, 0x6B, 0xBD, 0x67, 0x10, 0xF0, 0x01, 0x6E, 0x00, 0xF4,
+0xC0, 0x36, 0x43, 0xDC, 0x74, 0xC4, 0x10, 0x4D, 0x95, 0xF0, 0x05, 0x4E,
+0x0A, 0x62, 0x00, 0x1C, 0xCF, 0x20, 0x23, 0xC8, 0x5D, 0x67, 0x47, 0x6B,
+0x78, 0xC2, 0x7D, 0x67, 0x3B, 0x6A, 0x59, 0xC3, 0x43, 0x6A, 0x5A, 0xC3,
+0x01, 0x6A, 0x4B, 0xEA, 0x00, 0xF3, 0x44, 0xC0, 0xFF, 0x6A, 0x01, 0x4A,
+0x3B, 0xC3, 0x4B, 0xEA, 0x00, 0xF3, 0x64, 0x98, 0x40, 0x32, 0x40, 0x32,
+0xE0, 0xF0, 0x1F, 0x4A, 0x4C, 0xEB, 0x00, 0xF2, 0x00, 0x6A, 0x40, 0x32,
+0xF3, 0xF0, 0x14, 0x4A, 0x00, 0xF3, 0x4C, 0xD8, 0xFF, 0x6A, 0x01, 0x4A,
+0x40, 0x32, 0x46, 0xF0, 0x16, 0x4A, 0x00, 0xF3, 0x64, 0xD8, 0x00, 0xF3,
+0x50, 0xD8, 0x60, 0x98, 0x02, 0x6A, 0x00, 0xF3, 0x47, 0xC0, 0x05, 0x6A,
+0x4B, 0xEA, 0x00, 0x6C, 0x4C, 0xEB, 0x81, 0x6A, 0x00, 0xF3, 0x88, 0xD8,
+0x00, 0xF3, 0x94, 0xD8, 0x00, 0xF3, 0x98, 0xD8, 0x4B, 0xEA, 0x10, 0xF0,
+0x02, 0x6C, 0x00, 0xF4, 0x80, 0x34, 0x4C, 0xEB, 0xBE, 0xF5, 0x14, 0x4C,
+0xC0, 0xF7, 0x10, 0x6A, 0x60, 0xD8, 0xBD, 0x67, 0x43, 0xDC, 0x10, 0xF0,
+0x01, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0x01, 0x6A, 0x54, 0xC4, 0x55, 0xF1,
+0x09, 0x4E, 0x00, 0x1C, 0xCF, 0x20, 0x18, 0x4D, 0x4A, 0x6A, 0x00, 0xF3,
+0x5C, 0xC0, 0x45, 0x6A, 0x00, 0xF3, 0x5D, 0xC0, 0x46, 0x6A, 0x00, 0xF3,
+0x5E, 0xC0, 0x40, 0x6A, 0x00, 0xF3, 0x5F, 0xC0, 0x23, 0x6A, 0x20, 0xF3,
+0x40, 0xC0, 0x1E, 0x6A, 0x20, 0xF3, 0x41, 0xC0, 0x0A, 0x97, 0x09, 0x91,
+0x08, 0x90, 0x00, 0xEF, 0x06, 0x63, 0x00, 0x00, 0xFC, 0x63, 0x7D, 0x67,
+0x3B, 0x6A, 0x50, 0xC3, 0x43, 0x6A, 0x51, 0xC3, 0x36, 0x6A, 0x52, 0xC3,
+0x00, 0x6B, 0x5D, 0x67, 0x73, 0xC2, 0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4,
+0x40, 0x32, 0x63, 0xF3, 0x00, 0x4A, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4,
+0x80, 0x34, 0xDE, 0xF5, 0x10, 0x4C, 0xC0, 0xF2, 0x73, 0xC2, 0xC0, 0xF7,
+0x10, 0x6A, 0x43, 0xDC, 0xBD, 0x67, 0x01, 0x6A, 0x10, 0xF0, 0x01, 0x6E,
+0x00, 0xF4, 0xC0, 0x36, 0x54, 0xC4, 0x95, 0xF4, 0x05, 0x4E, 0x06, 0x62,
+0x00, 0x1C, 0xCF, 0x20, 0x10, 0x4D, 0x06, 0x97, 0x00, 0xEF, 0x04, 0x63,
+0x10, 0xF0, 0x02, 0x6A, 0x00, 0xF4, 0x40, 0x32, 0xFC, 0x63, 0x63, 0xF3,
+0x00, 0x4A, 0x01, 0x6D, 0x00, 0x6B, 0x9D, 0x67, 0x66, 0xF7, 0xB6, 0xCA,
+0x66, 0xF7, 0x74, 0xCA, 0x52, 0x6A, 0x50, 0xC4, 0x53, 0x6A, 0x51, 0xC4,
+0x54, 0x6A, 0x52, 0xC4, 0x73, 0xC4, 0x10, 0xF0, 0x02, 0x6C, 0x00, 0xF4,
+0x80, 0x34, 0x3E, 0xF6, 0x04, 0x4C, 0xE0, 0xF1, 0x14, 0x6A, 0xB4, 0xC4,
+0x10, 0xF0, 0x02, 0x6E, 0x00, 0xF4, 0xC0, 0x36, 0xBD, 0x67, 0x43, 0xDC,
+0x10, 0xF5, 0x0D, 0x4E, 0x06, 0x62, 0x00, 0x1C, 0xCF, 0x20, 0x10, 0x4D,
+0x06, 0x97, 0x00, 0xEF, 0x04, 0x63, 0x00, 0x65, 0xD8, 0xFF, 0xBD, 0x27,
+0x02, 0x80, 0x03, 0x3C, 0x20, 0x00, 0xBF, 0xAF, 0x1C, 0x00, 0xB1, 0xAF,
+0x18, 0x00, 0xB0, 0xAF, 0x74, 0xF2, 0x62, 0x24, 0x02, 0x00, 0x48, 0x90,
+0x74, 0xF2, 0x67, 0x94, 0x02, 0x80, 0x02, 0x3C, 0xD0, 0x5D, 0x42, 0x24,
+0x02, 0x00, 0x10, 0x24, 0x01, 0x80, 0x06, 0x3C, 0x21, 0x20, 0x40, 0x00,
+0x14, 0x00, 0x50, 0xA0, 0x10, 0x00, 0xA5, 0x27, 0xFC, 0xC1, 0xC6, 0x24,
+0x02, 0x80, 0x11, 0x3C, 0x20, 0x5E, 0x31, 0x26, 0x10, 0x00, 0xA7, 0xA7,
+0x12, 0x00, 0xA8, 0xA3, 0xCF, 0x20, 0x00, 0x0C, 0x13, 0x00, 0xA0, 0xA3,
+0x02, 0x80, 0x06, 0x3C, 0x21, 0x20, 0x20, 0x02, 0x10, 0x00, 0xA5, 0x27,
+0x14, 0x00, 0x30, 0xA2, 0xCF, 0x20, 0x00, 0x0C, 0x08, 0x86, 0xC6, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0xEC, 0x5D, 0x40, 0xA0, 0x0C, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0xED, 0x5D, 0x64, 0xA0,
+0xEE, 0x5D, 0x44, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0x04, 0x5E, 0x60, 0xA0, 0x06, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C,
+0x02, 0x80, 0x02, 0x3C, 0x0C, 0x5E, 0x60, 0xA0, 0x01, 0x00, 0x06, 0x24,
+0x0D, 0x5E, 0x40, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C,
+0xF0, 0x5D, 0x66, 0xA0, 0x12, 0x00, 0x04, 0x24, 0x0E, 0x5E, 0x40, 0xA0,
+0x02, 0x80, 0x03, 0x3C, 0x02, 0x80, 0x02, 0x3C, 0xEF, 0x5D, 0x66, 0xA0,
+0xF1, 0x5D, 0x44, 0xA0, 0x02, 0x80, 0x03, 0x3C, 0x0C, 0x00, 0x04, 0x24,
+0x02, 0x80, 0x02, 0x3C, 0xF2, 0x5D, 0x60, 0xA0, 0x02, 0x80, 0x05, 0x3C,
+0xFC, 0x5D, 0x44, 0xA4, 0x64, 0x00, 0x03, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0xF4, 0x5D, 0xA3, 0xA4, 0xC6, 0x5C, 0x43, 0x90, 0xF4, 0x5D, 0xA4, 0x94,
+0x02, 0x00, 0x05, 0x24, 0x02, 0x00, 0x63, 0x30, 0x01, 0x00, 0x63, 0x2C,
+0xFF, 0xFF, 0x84, 0x30, 0x23, 0x28, 0xA3, 0x00, 0x80, 0x22, 0x04, 0x00,
+0x02, 0x80, 0x02, 0x3C, 0xE8, 0x03, 0x03, 0x24, 0xF8, 0x5D, 0x44, 0xAC,
+0x0C, 0x00, 0x23, 0xAE, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x00, 0x5E, 0x40, 0xAC, 0x05, 0x5E, 0x60, 0xA0, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x07, 0x5E, 0x40, 0xA0, 0x0F, 0x5E, 0x60, 0xA0,
+0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C, 0x3C, 0x5E, 0x45, 0xA0,
+0x20, 0x00, 0xBF, 0x8F, 0x08, 0x5E, 0x60, 0xA0, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x1C, 0x00, 0xB1, 0x8F, 0x18, 0x00, 0xB0, 0x8F,
+0x09, 0x5E, 0x46, 0xA0, 0x0A, 0x5E, 0x66, 0xA0, 0x02, 0x80, 0x02, 0x3C,
+0x02, 0x80, 0x03, 0x3C, 0x0B, 0x5E, 0x40, 0xA0, 0x21, 0x20, 0x00, 0x00,
+0x10, 0x5E, 0x60, 0xAC, 0x02, 0x80, 0x02, 0x3C, 0x02, 0x80, 0x03, 0x3C,
+0x21, 0x28, 0x00, 0x00, 0x28, 0x00, 0xBD, 0x27, 0x14, 0x5E, 0x40, 0xAC,
+0x18, 0x5E, 0x64, 0xAC, 0x1C, 0x5E, 0x65, 0xAC, 0x08, 0x00, 0xE0, 0x03,
+0x00, 0x00, 0x00, 0x00, 0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x21, 0x98, 0xA0, 0x00,
+0x21, 0x88, 0xC0, 0x00, 0x21, 0x90, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82,
+0x5C, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x10, 0x26, 0xFF, 0xFF, 0x10, 0x26, 0x00, 0x00, 0x04, 0x92,
+0x2B, 0x00, 0x02, 0x24, 0x00, 0x1E, 0x04, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x41, 0x00, 0x62, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x24,
+0x30, 0x00, 0x22, 0x12, 0x00, 0x1E, 0x04, 0x00, 0x07, 0x00, 0x20, 0x16,
+0x21, 0x18, 0x80, 0x00, 0x00, 0x1E, 0x04, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x30, 0x00, 0x02, 0x24, 0x3B, 0x00, 0x62, 0x10, 0x0A, 0x00, 0x11, 0x24,
+0x21, 0x18, 0x80, 0x00, 0x00, 0x16, 0x03, 0x00, 0x03, 0x16, 0x02, 0x00,
+0x1A, 0x00, 0x40, 0x10, 0xFF, 0x00, 0x64, 0x30, 0xA9, 0xFF, 0x82, 0x24,
+0x61, 0x00, 0x83, 0x2C, 0xFF, 0x00, 0x45, 0x30, 0x09, 0x00, 0x60, 0x10,
+0x41, 0x00, 0x86, 0x2C, 0xC9, 0xFF, 0x82, 0x24, 0xFF, 0x00, 0x45, 0x30,
+0x05, 0x00, 0xC0, 0x10, 0x3A, 0x00, 0x87, 0x2C, 0xD0, 0xFF, 0x82, 0x24,
+0x02, 0x00, 0xE0, 0x10, 0xFF, 0x00, 0x05, 0x24, 0xFF, 0x00, 0x45, 0x30,
+0x2A, 0x10, 0xB1, 0x00, 0x0A, 0x00, 0x40, 0x10, 0x18, 0x00, 0x51, 0x02,
+0x01, 0x00, 0x10, 0x26, 0x12, 0x10, 0x00, 0x00, 0x2B, 0x18, 0x52, 0x00,
+0x23, 0x00, 0x60, 0x14, 0x21, 0x90, 0xA2, 0x00, 0x00, 0x00, 0x03, 0x92,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0x60, 0x14, 0xFF, 0x00, 0x64, 0x30,
+0x02, 0x00, 0x60, 0x12, 0x21, 0x10, 0x40, 0x02, 0x00, 0x00, 0x70, 0xAE,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0x08, 0x00, 0xE0, 0x03,
+0x28, 0x00, 0xBD, 0x27, 0x03, 0x1E, 0x03, 0x00, 0x30, 0x00, 0x02, 0x24,
+0xCE, 0xFF, 0x62, 0x14, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x82,
+0x78, 0x00, 0x02, 0x24, 0x03, 0x00, 0x62, 0x10, 0x58, 0x00, 0x02, 0x24,
+0xD0, 0xFF, 0x62, 0x14, 0x21, 0x18, 0x80, 0x00, 0x02, 0x00, 0x10, 0x26,
+0x00, 0x00, 0x04, 0x92, 0x63, 0x71, 0x00, 0x08, 0x10, 0x00, 0x11, 0x24,
+0x01, 0x00, 0x10, 0x26, 0x00, 0x00, 0x04, 0x92, 0x5A, 0x71, 0x00, 0x08,
+0x10, 0x00, 0x02, 0x24, 0x8F, 0x71, 0x00, 0x08, 0x08, 0x00, 0x11, 0x24,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xFF, 0xFF, 0x02, 0x24,
+0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27, 0x21, 0x48, 0x80, 0x00,
+0x31, 0x00, 0xC0, 0x14, 0x21, 0x50, 0x00, 0x00, 0x00, 0x00, 0x87, 0x90,
+0x30, 0x00, 0x02, 0x24, 0x00, 0x1E, 0x07, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x2E, 0x00, 0x62, 0x10, 0x0A, 0x00, 0x06, 0x24, 0x02, 0x80, 0x02, 0x3C,
+0x40, 0xF4, 0x4B, 0x24, 0xFF, 0x00, 0xE8, 0x30, 0x21, 0x10, 0x0B, 0x01,
+0x00, 0x00, 0x44, 0x90, 0x00, 0x1E, 0x07, 0x00, 0x03, 0x1E, 0x03, 0x00,
+0x44, 0x00, 0x82, 0x30, 0x02, 0x00, 0x87, 0x30, 0xD0, 0xFF, 0x63, 0x24,
+0x1A, 0x00, 0x40, 0x10, 0x04, 0x00, 0x84, 0x30, 0x07, 0x00, 0x80, 0x14,
+0x2B, 0x10, 0x66, 0x00, 0x21, 0x10, 0x00, 0x01, 0x02, 0x00, 0xE0, 0x10,
+0xE0, 0xFF, 0x03, 0x25, 0xFF, 0x00, 0x62, 0x30, 0xC9, 0xFF, 0x43, 0x24,
+0x2B, 0x10, 0x66, 0x00, 0x10, 0x00, 0x40, 0x10, 0x18, 0x00, 0x46, 0x01,
+0x01, 0x00, 0x29, 0x25, 0x00, 0x00, 0x27, 0x91, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0x00, 0xE8, 0x30, 0x12, 0x10, 0x00, 0x00, 0x21, 0x50, 0x43, 0x00,
+0x21, 0x10, 0x0B, 0x01, 0x00, 0x00, 0x44, 0x90, 0x00, 0x1E, 0x07, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0x44, 0x00, 0x82, 0x30, 0x02, 0x00, 0x87, 0x30,
+0xD0, 0xFF, 0x63, 0x24, 0xE8, 0xFF, 0x40, 0x14, 0x04, 0x00, 0x84, 0x30,
+0x02, 0x00, 0xA0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0xAC,
+0x08, 0x00, 0xE0, 0x03, 0x21, 0x10, 0x40, 0x01, 0x00, 0x00, 0x87, 0x90,
+0xB1, 0x71, 0x00, 0x08, 0x02, 0x80, 0x02, 0x3C, 0x01, 0x00, 0x89, 0x24,
+0x00, 0x00, 0x27, 0x91, 0x78, 0x00, 0x02, 0x24, 0x00, 0x1E, 0x07, 0x00,
+0x03, 0x1E, 0x03, 0x00, 0xCD, 0xFF, 0x62, 0x14, 0x08, 0x00, 0x06, 0x24,
+0x01, 0x00, 0x22, 0x91, 0x02, 0x80, 0x03, 0x3C, 0x40, 0xF4, 0x63, 0x24,
+0x21, 0x10, 0x43, 0x00, 0x00, 0x00, 0x44, 0x90, 0x00, 0x00, 0x00, 0x00,
+0x44, 0x00, 0x84, 0x30, 0xC5, 0xFF, 0x80, 0x10, 0x02, 0x80, 0x02, 0x3C,
+0x01, 0x00, 0x29, 0x25, 0x00, 0x00, 0x27, 0x91, 0xB1, 0x71, 0x00, 0x08,
+0x10, 0x00, 0x06, 0x24, 0xE8, 0xFF, 0xBD, 0x27, 0x10, 0x00, 0xBF, 0xAF,
+0x00, 0x00, 0x83, 0x80, 0x2D, 0x00, 0x02, 0x24, 0x04, 0x00, 0x62, 0x10,
+0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xBF, 0x8F, 0xA7, 0x71, 0x00, 0x08,
+0x18, 0x00, 0xBD, 0x27, 0xA7, 0x71, 0x00, 0x0C, 0x01, 0x00, 0x84, 0x24,
+0x10, 0x00, 0xBF, 0x8F, 0x23, 0x10, 0x02, 0x00, 0x08, 0x00, 0xE0, 0x03,
+0x18, 0x00, 0xBD, 0x27, 0xD8, 0xFF, 0xBD, 0x27, 0x1C, 0x00, 0xB3, 0xAF,
+0x18, 0x00, 0xB2, 0xAF, 0x14, 0x00, 0xB1, 0xAF, 0x10, 0x00, 0xB0, 0xAF,
+0x20, 0x00, 0xBF, 0xAF, 0x21, 0x80, 0x80, 0x00, 0x21, 0x90, 0xA0, 0x00,
+0x21, 0x98, 0xC0, 0x00, 0x21, 0x88, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82,
+0x5C, 0x58, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x40, 0x14,
+0x01, 0x00, 0x10, 0x26, 0xFF, 0xFF, 0x10, 0x26, 0x00, 0x00, 0x03, 0x82,
+0x2D, 0x00, 0x02, 0x24, 0x0F, 0x00, 0x62, 0x10, 0x21, 0x20, 0x00, 0x02,
+0x21, 0x28, 0x40, 0x02, 0x43, 0x71, 0x00, 0x0C, 0x21, 0x30, 0x60, 0x02,
+0x12, 0x00, 0x40, 0x04, 0x21, 0x18, 0x40, 0x00, 0x23, 0x10, 0x02, 0x00,
+0x0A, 0x10, 0x71, 0x00, 0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F,
+0x18, 0x00, 0xB2, 0x8F, 0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F,
+0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27, 0x01, 0x00, 0x10, 0x26,
+0x21, 0x20, 0x00, 0x02, 0x21, 0x28, 0x40, 0x02, 0x43, 0x71, 0x00, 0x0C,
+0x21, 0x30, 0x60, 0x02, 0xFF, 0xFF, 0x11, 0x24, 0xF0, 0xFF, 0x41, 0x04,
+0x21, 0x18, 0x40, 0x00, 0xF0, 0xFF, 0x20, 0x16, 0x00, 0x80, 0x02, 0x3C,
+0x20, 0x00, 0xBF, 0x8F, 0x1C, 0x00, 0xB3, 0x8F, 0x18, 0x00, 0xB2, 0x8F,
+0x14, 0x00, 0xB1, 0x8F, 0x10, 0x00, 0xB0, 0x8F, 0xFF, 0x7F, 0x02, 0x3C,
+0xFF, 0xFF, 0x42, 0x34, 0x08, 0x00, 0xE0, 0x03, 0x28, 0x00, 0xBD, 0x27,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x7F,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x02, 0x7E, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x03, 0x7D,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x04, 0x7C, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x05, 0x7B, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x06, 0x7A,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x07, 0x79, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x08, 0x78, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x09, 0x77,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x0A, 0x76, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x0B, 0x75, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x0C, 0x74,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x0D, 0x73, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x0E, 0x72, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x0F, 0x71,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x10, 0x70, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x11, 0x6F, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x12, 0x6F,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x13, 0x6E, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x14, 0x6D, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x15, 0x6D,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x16, 0x6C, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x17, 0x6B, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x18, 0x6A,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x19, 0x6A, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x1A, 0x69, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x1B, 0x68,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x1C, 0x67, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x1D, 0x66, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x1E, 0x65,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x1F, 0x64, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x20, 0x63, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x21, 0x4C,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x22, 0x4B, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x23, 0x4A, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x24, 0x49,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x25, 0x48, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x26, 0x47, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x27, 0x46,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x28, 0x45, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x29, 0x44, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x2A, 0x2C,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x2B, 0x2B, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x2C, 0x2A, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x2D, 0x29,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x2E, 0x28, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x2F, 0x27, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x30, 0x26,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x31, 0x25, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x32, 0x24, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x33, 0x23,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x34, 0x22, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x35, 0x09, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x36, 0x08,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x37, 0x07, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x38, 0x06, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x39, 0x05,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x3A, 0x04, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x3B, 0x03, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x3C, 0x02,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x3D, 0x01, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x3E, 0x00, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x3F, 0x00,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x40, 0x7F, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x41, 0x7F, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x42, 0x7E,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x43, 0x7D, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x44, 0x7C, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x45, 0x7B,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x46, 0x7A, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x47, 0x79, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x48, 0x78,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x49, 0x77, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x4A, 0x76, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x4B, 0x75,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x4C, 0x74, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x4D, 0x73, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x4E, 0x72,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x4F, 0x71, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x50, 0x70, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x51, 0x6F,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x52, 0x6F, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x53, 0x6E, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x54, 0x6D,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x55, 0x6D, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x56, 0x6C, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x57, 0x6B,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x58, 0x6A, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x59, 0x6A, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x5A, 0x69,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x5B, 0x68, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x5C, 0x67, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x5D, 0x66,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x5E, 0x65, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x5F, 0x64, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x60, 0x63,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x61, 0x4C, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x62, 0x4B, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x63, 0x4A,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x64, 0x49, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x65, 0x48, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x66, 0x47,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x67, 0x46, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x68, 0x45, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x69, 0x44,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x6A, 0x2C, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x6B, 0x2B, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x6C, 0x2A,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x6D, 0x29, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x6E, 0x28, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x6F, 0x27,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x70, 0x26, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x71, 0x25, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x72, 0x24,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x73, 0x23, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x74, 0x22, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x75, 0x09,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x76, 0x08, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x77, 0x07, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x78, 0x06,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x79, 0x05, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x7A, 0x04, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x7B, 0x03,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x7C, 0x02, 0x78, 0x0C, 0x00, 0x00,
+0x01, 0x00, 0x7D, 0x01, 0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x7E, 0x00,
+0x78, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x7F, 0x00, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x00, 0x30, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x01, 0x30,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x02, 0x30, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x03, 0x30, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x04, 0x30,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x05, 0x34, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x06, 0x38, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x07, 0x3E,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x08, 0x3E, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x09, 0x44, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x0A, 0x46,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x0B, 0x48, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x0C, 0x48, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x0D, 0x4E,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x0E, 0x56, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x0F, 0x5A, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x10, 0x5E,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x11, 0x62, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x12, 0x6C, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x13, 0x72,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x14, 0x72, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x15, 0x72, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x16, 0x72,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x17, 0x72, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x18, 0x72, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x19, 0x72,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x1A, 0x72, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x1B, 0x72, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x1C, 0x72,
+0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x1D, 0x72, 0x78, 0x0C, 0x00, 0x00,
+0x1E, 0x00, 0x1E, 0x72, 0x78, 0x0C, 0x00, 0x00, 0x1E, 0x00, 0x1F, 0x72,
+0x00, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x06, 0x06, 0x04,
+0x04, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x02, 0x02, 0x00,
+0x08, 0x0E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x08, 0x08, 0x04,
+0x14, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x02, 0x02, 0x00,
+0x18, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x08, 0x08, 0x04,
+0x1C, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x02, 0x02, 0x00,
+0x00, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x0E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x0E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x0E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x14, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x18, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x1C, 0x0E, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+0x04, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
+0x24, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x04, 0x00, 0x30, 0x00,
+0x2C, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x04, 0x00, 0x30, 0x00,
+0x70, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00,
+0x64, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+0x78, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x02, 0x00,
+0x74, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x06, 0x00, 0x00, 0x00,
+0x78, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x06, 0x00, 0x00, 0x00,
+0x7C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x06, 0x00, 0x00, 0x00,
+0x80, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x06, 0x00, 0x00, 0x00,
+0x0C, 0x09, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
+0x04, 0x0C, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
+0x04, 0x0D, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
+0xF4, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
+0x34, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x13, 0x00, 0x00, 0x00,
+0x04, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
+0x24, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x04, 0x00, 0x30, 0x00,
+0x2C, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x02, 0x00, 0x30, 0x00,
+0x70, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00,
+0x64, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x78, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x00, 0x00,
+0x74, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x78, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x7C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x80, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x0C, 0x09, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
+0x04, 0x0C, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
+0x04, 0x0D, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
+0xF4, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x77, 0x77, 0x00, 0x00,
+0x34, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0A, 0x00, 0x00, 0x00,
+0x44, 0x08, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00,
+0x04, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+0x24, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x04, 0x00, 0x30, 0x00,
+0x2C, 0x08, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x02, 0x00, 0x10, 0x00,
+0x70, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00,
+0x64, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x78, 0x08, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x00, 0x00,
+0x74, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x78, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x7C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x80, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x02, 0x00, 0x00, 0x00,
+0x0C, 0x09, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
+0x04, 0x0C, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
+0x04, 0x0D, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+0xF4, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x77, 0x77, 0x00, 0x00,
+0x34, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x0A, 0x00, 0x00, 0x00,
+0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00,
+0x00, 0x00, 0x04, 0x00, 0x04, 0x08, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00,
+0x08, 0x08, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x0C, 0x08, 0x00, 0x00,
+0x0A, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x88, 0x50, 0x00, 0x10,
+0x14, 0x08, 0x00, 0x00, 0x10, 0x3D, 0x0C, 0x02, 0x18, 0x08, 0x00, 0x00,
+0x85, 0x01, 0x20, 0x00, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x08, 0x00, 0x00,
+0x04, 0x00, 0x39, 0x00, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+0x2C, 0x08, 0x00, 0x00, 0x04, 0x00, 0x39, 0x00, 0x30, 0x08, 0x00, 0x00,
+0x04, 0x00, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x00, 0x02, 0x69, 0x00,
+0x38, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3C, 0x08, 0x00, 0x00,
+0x00, 0x02, 0x69, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
+0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x48, 0x08, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x4C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x50, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x08, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x58, 0x08, 0x00, 0x00, 0x48, 0x48, 0x48, 0x48,
+0x5C, 0x08, 0x00, 0x00, 0xA9, 0x65, 0xA9, 0x65, 0x60, 0x08, 0x00, 0x00,
+0x30, 0x01, 0x7F, 0x0F, 0x64, 0x08, 0x00, 0x00, 0x30, 0x01, 0x7F, 0x0F,
+0x68, 0x08, 0x00, 0x00, 0x30, 0x01, 0x7F, 0x0F, 0x6C, 0x08, 0x00, 0x00,
+0x30, 0x01, 0x7F, 0x0F, 0x70, 0x08, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03,
+0x74, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x78, 0x08, 0x00, 0x00,
+0x02, 0x00, 0x02, 0x00, 0x7C, 0x08, 0x00, 0x00, 0x01, 0x02, 0x4F, 0x00,
+0x80, 0x08, 0x00, 0x00, 0xC1, 0x0A, 0x30, 0xA8, 0x84, 0x08, 0x00, 0x00,
+0x58, 0x00, 0x00, 0x00, 0x88, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+0x8C, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x90, 0x08, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x94, 0x08, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
+0x98, 0x08, 0x00, 0x00, 0x10, 0x20, 0x30, 0x40, 0x9C, 0x08, 0x00, 0x00,
+0x50, 0x60, 0x70, 0x00, 0xB0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xE0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x08, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x33, 0x33, 0x33, 0x30,
+0x04, 0x0E, 0x00, 0x00, 0x2F, 0x2E, 0x2D, 0x2A, 0x08, 0x0E, 0x00, 0x00,
+0x32, 0x32, 0x00, 0x00, 0x10, 0x0E, 0x00, 0x00, 0x33, 0x33, 0x33, 0x30,
+0x14, 0x0E, 0x00, 0x00, 0x2F, 0x2E, 0x2D, 0x2A, 0x18, 0x0E, 0x00, 0x00,
+0x33, 0x33, 0x33, 0x30, 0x1C, 0x0E, 0x00, 0x00, 0x2F, 0x2E, 0x2D, 0x2A,
+0x30, 0x0E, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x01, 0x34, 0x0E, 0x00, 0x00,
+0x00, 0x48, 0x00, 0x01, 0x38, 0x0E, 0x00, 0x00, 0x1F, 0xDC, 0x00, 0x10,
+0x3C, 0x0E, 0x00, 0x00, 0x1F, 0x8C, 0x00, 0x10, 0x40, 0x0E, 0x00, 0x00,
+0xA0, 0x00, 0x14, 0x02, 0x44, 0x0E, 0x00, 0x00, 0xA0, 0x00, 0x16, 0x28,
+0x48, 0x0E, 0x00, 0x00, 0x01, 0x00, 0x00, 0xF8, 0x4C, 0x0E, 0x00, 0x00,
+0x10, 0x29, 0x00, 0x00, 0x50, 0x0E, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x01,
+0x54, 0x0E, 0x00, 0x00, 0x00, 0x48, 0x00, 0x01, 0x58, 0x0E, 0x00, 0x00,
+0x1F, 0xDC, 0x00, 0x10, 0x5C, 0x0E, 0x00, 0x00, 0x1F, 0x8C, 0x00, 0x10,
+0x60, 0x0E, 0x00, 0x00, 0xA0, 0x00, 0x14, 0x02, 0x64, 0x0E, 0x00, 0x00,
+0xA0, 0x00, 0x16, 0x28, 0x6C, 0x0E, 0x00, 0x00, 0x10, 0x29, 0x00, 0x00,
+0x70, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0xED, 0x31, 0x74, 0x0E, 0x00, 0x00,
+0xFB, 0x36, 0x15, 0x36, 0x78, 0x0E, 0x00, 0x00, 0xFB, 0x36, 0x15, 0x36,
+0x7C, 0x0E, 0x00, 0x00, 0xFB, 0x36, 0x15, 0x36, 0x80, 0x0E, 0x00, 0x00,
+0xFB, 0x36, 0x15, 0x36, 0x84, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0x0D, 0x00,
+0x88, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0x0D, 0x00, 0x8C, 0x0E, 0x00, 0x00,
+0xFB, 0x92, 0xED, 0x31, 0xD0, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0xED, 0x31,
+0xD4, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0xED, 0x31, 0xD8, 0x0E, 0x00, 0x00,
+0xFB, 0x92, 0x0D, 0x00, 0xDC, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0x0D, 0x00,
+0xE0, 0x0E, 0x00, 0x00, 0xFB, 0x92, 0x0D, 0x00, 0xE4, 0x0E, 0x00, 0x00,
+0x48, 0x54, 0x5E, 0x01, 0xE8, 0x0E, 0x00, 0x00, 0x48, 0x54, 0x55, 0x21,
+0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x00,
+0x23, 0x00, 0x00, 0x00, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x0C, 0x09, 0x00, 0x00, 0x13, 0x13, 0x12, 0x01, 0x00, 0x0A, 0x00, 0x00,
+0xC8, 0x47, 0xD0, 0x00, 0x04, 0x0A, 0x00, 0x00, 0x08, 0x00, 0xFF, 0x80,
+0x08, 0x0A, 0x00, 0x00, 0x00, 0x83, 0xCD, 0x88, 0x0C, 0x0A, 0x00, 0x00,
+0x0F, 0x12, 0x62, 0x2E, 0x10, 0x0A, 0x00, 0x00, 0x78, 0xBB, 0x00, 0x95,
+0x14, 0x0A, 0x00, 0x00, 0x28, 0x40, 0x14, 0x11, 0x18, 0x0A, 0x00, 0x00,
+0x17, 0x11, 0x88, 0x00, 0x1C, 0x0A, 0x00, 0x00, 0x00, 0x0F, 0x14, 0x89,
+0x20, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x1A, 0x24, 0x0A, 0x00, 0x00,
+0x17, 0x13, 0x0E, 0x09, 0x28, 0x0A, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00,
+0x2C, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xD3, 0x10, 0x00, 0x0C, 0x00, 0x00,
+0x40, 0x1D, 0x07, 0x40, 0x04, 0x0C, 0x00, 0x00, 0x33, 0x56, 0xA0, 0x00,
+0x08, 0x0C, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00,
+0x6C, 0x6C, 0x6C, 0x6C, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08,
+0x14, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x18, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x08, 0x1C, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40,
+0x20, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x24, 0x0C, 0x00, 0x00,
+0x00, 0x01, 0x00, 0x40, 0x28, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
+0x2C, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x30, 0x0C, 0x00, 0x00,
+0x44, 0xAC, 0xE9, 0x6D, 0x34, 0x0C, 0x00, 0x00, 0xCF, 0x52, 0x96, 0x46,
+0x38, 0x0C, 0x00, 0x00, 0x94, 0x59, 0x79, 0x49, 0x3C, 0x0C, 0x00, 0x00,
+0x64, 0x97, 0x97, 0x0A, 0x40, 0x0C, 0x00, 0x00, 0x3F, 0x40, 0x7C, 0x1F,
+0x44, 0x0C, 0x00, 0x00, 0xB7, 0x00, 0x01, 0x00, 0x48, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x02, 0xEC, 0x4C, 0x0C, 0x00, 0x00, 0x7F, 0x03, 0x7F, 0x00,
+0x50, 0x0C, 0x00, 0x00, 0x20, 0x34, 0x54, 0x69, 0x54, 0x0C, 0x00, 0x00,
+0x94, 0x00, 0x3C, 0x43, 0x58, 0x0C, 0x00, 0x00, 0x20, 0x34, 0x54, 0x69,
+0x5C, 0x0C, 0x00, 0x00, 0x94, 0x00, 0x3C, 0x43, 0x60, 0x0C, 0x00, 0x00,
+0x20, 0x34, 0x54, 0x69, 0x64, 0x0C, 0x00, 0x00, 0x94, 0x00, 0x3C, 0x43,
+0x68, 0x0C, 0x00, 0x00, 0x20, 0x34, 0x54, 0x69, 0x6C, 0x0C, 0x00, 0x00,
+0x94, 0x00, 0x3C, 0x43, 0x70, 0x0C, 0x00, 0x00, 0x0D, 0x00, 0x7F, 0x2C,
+0x74, 0x0C, 0x00, 0x00, 0x5B, 0x17, 0x86, 0x01, 0x78, 0x0C, 0x00, 0x00,
+0x1F, 0x00, 0x00, 0x00, 0x7C, 0x0C, 0x00, 0x00, 0x12, 0x16, 0xB9, 0x00,
+0x80, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x84, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0xF6, 0x20, 0x88, 0x0C, 0x00, 0x00, 0x80, 0x00, 0x00, 0x20,
+0x8C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x90, 0x0C, 0x00, 0x00,
+0x00, 0x01, 0x00, 0x40, 0x94, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x98, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x9C, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xA0, 0x0C, 0x00, 0x00, 0x92, 0x24, 0x49, 0x00,
+0xA4, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xAC, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xB0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xB8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xBC, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xC0, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xC4, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xC8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xD0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xD4, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x0C, 0x00, 0x00,
+0x27, 0x24, 0xB2, 0x64, 0xDC, 0x0C, 0x00, 0x00, 0x32, 0x69, 0x76, 0x00,
+0xE0, 0x0C, 0x00, 0x00, 0x22, 0x22, 0x22, 0x00, 0xE4, 0x0C, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xE8, 0x0C, 0x00, 0x00, 0x02, 0x43, 0x64, 0x37,
+0xEC, 0x0C, 0x00, 0x00, 0x0C, 0xD4, 0x97, 0x2F, 0x00, 0x0D, 0x00, 0x00,
+0x50, 0x07, 0x00, 0x00, 0x04, 0x0D, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00,
+0x08, 0x0D, 0x00, 0x00, 0x7F, 0x90, 0x00, 0x00, 0x0C, 0x0D, 0x00, 0x00,
+0x01, 0x00, 0x00, 0x00, 0x10, 0x0D, 0x00, 0x00, 0x33, 0x33, 0x63, 0xA0,
+0x14, 0x0D, 0x00, 0x00, 0x63, 0x3C, 0x33, 0x33, 0x18, 0x0D, 0x00, 0x00,
+0x6B, 0x5B, 0x8F, 0x6A, 0x1C, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x0D, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x28, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x2C, 0x0D, 0x00, 0x00, 0x75, 0x99, 0x97, 0xCC, 0x30, 0x0D, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x34, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x38, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x0D, 0x00, 0x00,
+0x93, 0x72, 0x02, 0x00, 0x40, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x44, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x0D, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x50, 0x0D, 0x00, 0x00, 0x0A, 0x14, 0x37, 0x64,
+0x54, 0x0D, 0x00, 0x00, 0x02, 0xBD, 0x4D, 0x02, 0x58, 0x0D, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x5C, 0x0D, 0x00, 0x00, 0x64, 0x20, 0x03, 0x30,
+0x60, 0x0D, 0x00, 0x00, 0x68, 0xDE, 0x53, 0x46, 0x64, 0x0D, 0x00, 0x00,
+0x3C, 0x8A, 0x51, 0x00, 0x68, 0x0D, 0x00, 0x00, 0x01, 0x21, 0x00, 0x00,
+0x14, 0x0F, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x4C, 0x0F, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+0x40, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
+0x10, 0x00, 0x00, 0x00, 0x84, 0x02, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00,
+0xB4, 0x02, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0xC0, 0x08, 0x01, 0x80,
+0x10, 0x00, 0x00, 0x00, 0xC8, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00,
+0xD0, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0xD8, 0x08, 0x01, 0x80,
+0x10, 0x00, 0x00, 0x00, 0xB0, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00,
+0xB8, 0x08, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0x10, 0x09, 0x01, 0x80,
+0x10, 0x00, 0x00, 0x00, 0x18, 0x09, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00,
+0x58, 0x04, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0x50, 0x04, 0x01, 0x80,
+0x10, 0x00, 0x00, 0x00, 0x20, 0x09, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00,
+0x28, 0x09, 0x01, 0x80, 0x74, 0x03, 0x00, 0x00, 0xF0, 0x28, 0x00, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x88, 0x06, 0x01, 0x80, 0x74, 0x03, 0x00, 0x00,
+0xF0, 0x28, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0xAC, 0x2B, 0x00, 0x80,
+0x30, 0x00, 0x00, 0x00, 0x58, 0x2C, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00,
+0x1C, 0x2F, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x7C, 0x07, 0x01, 0x80,
+0x17, 0x00, 0x00, 0x00, 0xD0, 0x07, 0x01, 0x80, 0x06, 0x00, 0x00, 0x00,
+0x58, 0x08, 0x01, 0x80, 0x06, 0x00, 0x00, 0x00, 0x60, 0x08, 0x01, 0x80,
+0x08, 0x00, 0x00, 0x00, 0x68, 0x08, 0x01, 0x80, 0x0C, 0x00, 0x00, 0x00,
+0x70, 0x08, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0x78, 0x08, 0x01, 0x80,
+0x0E, 0x00, 0x00, 0x00, 0x80, 0x08, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
+0x88, 0x08, 0x01, 0x80, 0x38, 0x00, 0x00, 0x00, 0x90, 0x08, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x98, 0x08, 0x01, 0x80, 0x02, 0x00, 0x00, 0x00,
+0xA0, 0x08, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0xA8, 0x08, 0x01, 0x80,
+0x01, 0x00, 0x00, 0x00, 0xE8, 0x08, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00,
+0xF0, 0x08, 0x01, 0x80, 0x0C, 0x00, 0x00, 0x00, 0x60, 0x04, 0x01, 0x80,
+0x0E, 0x00, 0x00, 0x00, 0x68, 0x04, 0x01, 0x80, 0x0C, 0x00, 0x00, 0x00,
+0x80, 0x06, 0x01, 0x80, 0x34, 0x00, 0x00, 0x00, 0xF8, 0x08, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00,
+0x30, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0x38, 0x09, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x40, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00,
+0x08, 0x09, 0x01, 0x80, 0x08, 0x00, 0x00, 0x00, 0xB8, 0x03, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x48, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00,
+0xC0, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0xCC, 0x09, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0xD4, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00,
+0xDC, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0xE4, 0x09, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0xEC, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00,
+0xF4, 0x09, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0xFC, 0x09, 0x01, 0x80,
+0x04, 0x00, 0x00, 0x00, 0x04, 0x0A, 0x01, 0x80, 0x74, 0x03, 0x00, 0x00,
+0x0C, 0x0A, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x30, 0x0B, 0x01, 0x80,
+0x10, 0x00, 0x00, 0x00, 0x0C, 0x33, 0x00, 0x80, 0x06, 0x00, 0x00, 0x00,
+0x6C, 0x0B, 0x01, 0x80, 0x13, 0x00, 0x00, 0x00, 0xF8, 0x9E, 0x02, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xC8, 0x5E, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xF8, 0x0E, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0xC8, 0xCE, 0x01, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xD4, 0x8E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xA4, 0x4E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00, 0xD0, 0x0E, 0x01, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xA0, 0xCE, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xD0, 0x86, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0xA0, 0x46, 0x00, 0x00,
+0x13, 0x00, 0x00, 0x00, 0x70, 0x06, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xA4, 0x9E, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00, 0x74, 0x5E, 0x02, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xA4, 0x0E, 0x02, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xD0, 0xCE, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00, 0x40, 0x9F, 0x01, 0x00,
+0x13, 0x00, 0x00, 0x00, 0x70, 0x4E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00,
+0xA0, 0x06, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00, 0x70, 0xC6, 0x00, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xA0, 0x82, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+0x70, 0x42, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00,
+0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44,
+0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00,
+0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44,
+0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00,
+0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44,
+0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00,
+0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44,
+0x44, 0x22, 0x22, 0x00, 0xAA, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x59, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
+0x41, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00,
+0x05, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x08, 0x00, 0x07, 0x00, 0x00, 0x00,
+0x03, 0xC8, 0x0F, 0x00, 0x13, 0x00, 0x00, 0x00, 0xB0, 0x7C, 0x01, 0x00,
+0x13, 0x00, 0x00, 0x00, 0xC0, 0x1C, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00,
+0x60, 0xDC, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x60, 0x8C, 0x00, 0x00,
+0x13, 0x00, 0x00, 0x00, 0x50, 0x44, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x01, 0x03, 0x00,
+0x01, 0x00, 0x00, 0x00, 0x50, 0x02, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x08, 0x00,
+0x11, 0x00, 0x00, 0x00, 0xFC, 0x31, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00,
+0x0F, 0x00, 0x0C, 0x00, 0x11, 0x00, 0x00, 0x00, 0xF8, 0xF9, 0x03, 0x00,
+0x10, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x02, 0x00, 0x11, 0x00, 0x00, 0x00,
+0x01, 0x01, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3E, 0x09, 0x01, 0x00,
+0x14, 0x00, 0x00, 0x00, 0x3E, 0x09, 0x09, 0x00, 0x15, 0x00, 0x00, 0x00,
+0xF4, 0x98, 0x01, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0F, 0x00,
+0x1A, 0x00, 0x00, 0x00, 0x56, 0x30, 0x01, 0x00, 0x1B, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x06, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+0x1E, 0x00, 0x00, 0x00, 0x59, 0x10, 0x03, 0x00, 0x21, 0x00, 0x00, 0x00,
+0x00, 0x40, 0x05, 0x00, 0x22, 0x00, 0x00, 0x00, 0x3C, 0x08, 0x00, 0x00,
+0x23, 0x00, 0x00, 0x00, 0x58, 0x15, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
+0x60, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x83, 0x25, 0x02, 0x00,
+0x26, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00,
+0xF1, 0xAC, 0x0E, 0x00, 0x28, 0x00, 0x00, 0x00, 0x54, 0xBD, 0x09, 0x00,
+0x29, 0x00, 0x00, 0x00, 0x82, 0x45, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x34, 0x13, 0x02, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x0A, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x33, 0x33, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x08, 0x08, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x33, 0xB3, 0x05, 0x00,
+0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x03, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x33, 0x33, 0x06, 0x00, 0x2C, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x33, 0xB3, 0x06, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x09, 0x07, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x33, 0x33, 0x05, 0x00,
+0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x06, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x09, 0x07, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x33, 0xB3, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x09, 0x07, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x33, 0x33, 0x06, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x09, 0x07, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x33, 0xB3, 0x06, 0x00,
+0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x09, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x0A, 0x06, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x33, 0x33, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x0A, 0x06, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x33, 0xB3, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x0A, 0x06, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x33, 0x33, 0x06, 0x00,
+0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x0C, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x0A, 0x06, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x33, 0xB3, 0x06, 0x00, 0x2C, 0x00, 0x00, 0x00,
+0x0D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
+0x2B, 0x00, 0x00, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x33, 0x33, 0x05, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00,
+0x2A, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00,
+0x0B, 0x05, 0x00, 0x00, 0x2B, 0x00, 0x00, 0x00, 0x23, 0x66, 0x06, 0x00,
+0x2C, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
+0x00, 0x40, 0x0E, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+0x31, 0x00, 0x00, 0x00, 0x31, 0x96, 0x0B, 0x00, 0x32, 0x00, 0x00, 0x00,
+0x0D, 0x13, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x00,
+0x13, 0x00, 0x00, 0x00, 0x6C, 0x9E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x00,
+0x94, 0x5E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x01, 0x01, 0x00,
+0x18, 0x00, 0x00, 0x00, 0x01, 0xF4, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x5B, 0x10, 0x03, 0x00,
+0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x59, 0x01, 0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x04, 0x00,
+0x11, 0x00, 0x00, 0x00, 0xF9, 0x03, 0x02, 0x00, 0x6C, 0x09, 0x00, 0x00,
+0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
+0x0D, 0x00, 0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x17, 0x05, 0x03,
+0x22, 0x43, 0x5E, 0x00, 0x4F, 0xA4, 0x00, 0x00, 0x4F, 0xA4, 0x00, 0x00,
+0x22, 0x43, 0x5E, 0x00, 0x4F, 0xA4, 0x00, 0x00, 0x22, 0x43, 0x5E, 0x00,
+0x4F, 0xA4, 0x3E, 0x00, 0x30, 0xA6, 0x00, 0x00, 0x4F, 0xA4, 0x3E, 0x00,
+0x2B, 0xA4, 0x5E, 0x00, 0x2B, 0xA4, 0x00, 0x00, 0x2B, 0xA4, 0x5E, 0x00,
+0x22, 0xA4, 0x5E, 0x00, 0x4F, 0xA4, 0x00, 0x00, 0x4F, 0xA4, 0x00, 0x00,
+0x4F, 0xA4, 0x5E, 0x00, 0x4F, 0xA4, 0x5E, 0x00, 0x4F, 0xA4, 0x5E, 0x00,
+0x1C, 0x42, 0x2F, 0x00, 0x4F, 0x64, 0x5E, 0x00, 0x4F, 0xA4, 0x5E, 0x00,
+0x4F, 0xA4, 0x5E, 0x00, 0x4F, 0xA4, 0x00, 0x00, 0x4F, 0xA4, 0x5E, 0x00,
+0x00, 0xE0, 0x4C, 0x02, 0x01, 0x20, 0x00, 0x00, 0x00, 0xE0, 0x4C, 0x00,
+0x00, 0x0C, 0x43, 0x00, 0x00, 0x50, 0x43, 0x00, 0x00, 0x40, 0x96, 0x00,
+0x00, 0x05, 0xB5, 0x00, 0x00, 0x0A, 0xF7, 0x00, 0x00, 0x10, 0x18, 0x00,
+0x00, 0x21, 0x91, 0x00, 0x00, 0x1C, 0xF0, 0x00, 0x00, 0x13, 0x74, 0x00,
+0x00, 0x03, 0x7F, 0x00, 0x00, 0x50, 0xF2, 0x02, 0x01, 0x01, 0x00, 0x00,
+0x00, 0x50, 0xF2, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0xE7, 0x01, 0x80,
+0xE0, 0x25, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00, 0xBC, 0xE7, 0x01, 0x80,
+0xE8, 0x25, 0x01, 0x80, 0x20, 0x00, 0x00, 0x00, 0xC8, 0xE7, 0x01, 0x80,
+0xE0, 0x25, 0x01, 0x80, 0x30, 0x00, 0x00, 0x00, 0xD8, 0xE7, 0x01, 0x80,
+0xE8, 0x25, 0x01, 0x80, 0x40, 0x00, 0x00, 0x00, 0xE8, 0xE7, 0x01, 0x80,
+0x44, 0x43, 0x00, 0x80, 0x50, 0x00, 0x00, 0x00, 0xF4, 0xE7, 0x01, 0x80,
+0xD4, 0x49, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x01, 0x80,
+0x34, 0x53, 0x00, 0x80, 0x90, 0x00, 0x00, 0x00, 0x0C, 0xE8, 0x01, 0x80,
+0x64, 0x30, 0x01, 0x80, 0xA0, 0x00, 0x00, 0x00, 0x14, 0xE8, 0x01, 0x80,
+0x6C, 0x30, 0x01, 0x80, 0xB0, 0x00, 0x00, 0x00, 0x20, 0xE8, 0x01, 0x80,
+0x9C, 0x39, 0x01, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x28, 0xE8, 0x01, 0x80,
+0x8C, 0x30, 0x01, 0x80, 0xD0, 0x00, 0x00, 0x00, 0x34, 0xE8, 0x01, 0x80,
+0xFC, 0x4E, 0x00, 0x80, 0xC8, 0x00, 0x00, 0x00, 0x40, 0xE8, 0x01, 0x80,
+0x54, 0x4A, 0x00, 0x80, 0x0D, 0x00, 0x00, 0x00, 0x4C, 0xE8, 0x01, 0x80,
+0xAC, 0x30, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
+0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0xFF, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
+0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x00, 0x00, 0x00,
+0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
+0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x01, 0x01, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xD0, 0xDF, 0x01, 0x80, 0xD0, 0xDF, 0x01, 0x80,
+0x31, 0x10, 0x10, 0x00, 0x00, 0x30, 0x00, 0x00, 0x31, 0x20, 0x10, 0x00,
+0x00, 0x30, 0x00, 0x00, 0x31, 0x28, 0x10, 0x00, 0x00, 0x30, 0x00, 0x00,
+0x31, 0x2C, 0x10, 0x10, 0x00, 0x30, 0x00, 0x00, 0x31, 0x2F, 0x10, 0x10,
+0x00, 0x30, 0x00, 0x00, 0x31, 0x30, 0x18, 0x00, 0x00, 0x30, 0x00, 0x00,
+0x31, 0x30, 0x20, 0x10, 0x00, 0x30, 0x00, 0x00, 0x22, 0x20, 0x18, 0x08,
+0x00, 0x20, 0x00, 0x00, 0x22, 0x21, 0x14, 0x08, 0x00, 0x20, 0x00, 0x00,
+0x22, 0x21, 0x1C, 0x08, 0x00, 0x20, 0x00, 0x00, 0x22, 0x21, 0x20, 0x08,
+0x00, 0x20, 0x00, 0x00, 0x22, 0x21, 0x20, 0x10, 0x00, 0x20, 0x00, 0x00,
+0x22, 0x21, 0x20, 0x18, 0x00, 0x20, 0x00, 0x00, 0x1A, 0x19, 0x18, 0x10,
+0x00, 0x18, 0x00, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x10, 0x00, 0x00,
+0x0A, 0x09, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x02,
+0x00, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x08, 0x00, 0x00,
+0x0A, 0x09, 0x08, 0x06, 0x00, 0x08, 0x00, 0x00, 0x08, 0x07, 0x06, 0x04,
+0x00, 0x06, 0x00, 0x00, 0x06, 0x05, 0x04, 0x02, 0x00, 0x04, 0x00, 0x00,
+0x06, 0x05, 0x04, 0x03, 0x00, 0x04, 0x00, 0x00, 0x05, 0x04, 0x03, 0x02,
+0x00, 0x03, 0x00, 0x00, 0x09, 0x08, 0x07, 0x06, 0x07, 0x06, 0x06, 0x05,
+0x05, 0x04, 0x04, 0x03, 0x06, 0x05, 0x05, 0x04, 0x04, 0x03, 0x03, 0x03,
+0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x00, 0x09, 0x08, 0x07,
+0x06, 0x07, 0x06, 0x06, 0x05, 0x05, 0x04, 0x04, 0x03, 0x05, 0x04, 0x04,
+0x03, 0x03, 0x02, 0x02, 0x02, 0x04, 0x03, 0x03, 0x02, 0x02, 0x01, 0x01,
+0x01, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x10, 0x10, 0x20, 0x08, 0x08, 0x08, 0x08, 0x20, 0x20, 0x20, 0x20,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x20, 0x20, 0x20, 0x30, 0x08, 0x08, 0x08,
+0x08, 0x18, 0x18, 0x18, 0x18, 0x18, 0x20, 0x30, 0x30, 0x10, 0x20, 0x20,
+0x20, 0x20, 0x20, 0x30, 0x30, 0x08, 0x10, 0x20, 0x30, 0x30, 0x30, 0x30,
+0x30, 0x30, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x10, 0x10, 0x20, 0x08, 0x08, 0x08, 0x08, 0x08, 0x20, 0x20, 0x20,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x20, 0x20, 0x20, 0x20, 0x08, 0x08, 0x08,
+0x08, 0x18, 0x18, 0x18, 0x18, 0x18, 0x20, 0x30, 0x30, 0x10, 0x20, 0x20,
+0x20, 0x20, 0x20, 0x30, 0x30, 0x08, 0x10, 0x20, 0x30, 0x30, 0x30, 0x30,
+0x30, 0x30, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08,
+0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00,
+0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09,
+0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00,
+0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x22,
+0x21, 0x20, 0x18, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08,
+0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00,
+0x22, 0x21, 0x20, 0x18, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00, 0x22, 0x21,
+0x1C, 0x08, 0x00, 0x22, 0x20, 0x18, 0x08, 0x00, 0x0A, 0x09, 0x08, 0x02,
+0x00, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A,
+0x09, 0x08, 0x02, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x22, 0x21, 0x20,
+0x10, 0x00, 0x22, 0x21, 0x20, 0x08, 0x00, 0x22, 0x21, 0x1C, 0x08, 0x00,
+0x31, 0x30, 0x18, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09,
+0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x04,
+0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x1A,
+0x19, 0x18, 0x10, 0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x1A, 0x19, 0x18,
+0x10, 0x00, 0x22, 0x21, 0x20, 0x08, 0x00, 0x31, 0x2C, 0x10, 0x10, 0x00,
+0x31, 0x28, 0x10, 0x00, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x22, 0x21,
+0x20, 0x18, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00, 0x22, 0x21, 0x20, 0x08,
+0x00, 0x22, 0x21, 0x14, 0x08, 0x00, 0x22, 0x20, 0x18, 0x08, 0x00, 0x31,
+0x30, 0x20, 0x10, 0x00, 0x31, 0x2C, 0x10, 0x10, 0x00, 0x0A, 0x09, 0x08,
+0x00, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00,
+0x22, 0x21, 0x20, 0x18, 0x00, 0x31, 0x30, 0x20, 0x10, 0x00, 0x31, 0x2F,
+0x10, 0x10, 0x00, 0x31, 0x2F, 0x10, 0x10, 0x00, 0x31, 0x10, 0x10, 0x00,
+0x00, 0x31, 0x2C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x04,
+0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A,
+0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08,
+0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00,
+0x0A, 0x09, 0x08, 0x00, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x12, 0x11,
+0x10, 0x08, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00, 0x0A, 0x09, 0x08, 0x04,
+0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A,
+0x09, 0x08, 0x00, 0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x22, 0x21, 0x20,
+0x18, 0x00, 0x22, 0x21, 0x1C, 0x08, 0x00, 0x22, 0x21, 0x14, 0x08, 0x00,
+0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A, 0x09,
+0x08, 0x02, 0x00, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x0A, 0x09, 0x08, 0x00,
+0x00, 0x22, 0x21, 0x20, 0x10, 0x00, 0x22, 0x21, 0x20, 0x08, 0x00, 0x22,
+0x21, 0x14, 0x08, 0x00, 0x22, 0x21, 0x14, 0x08, 0x00, 0x0A, 0x09, 0x08,
+0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00, 0x0A, 0x09, 0x08, 0x04, 0x00,
+0x0A, 0x09, 0x08, 0x04, 0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x1A, 0x19,
+0x18, 0x10, 0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x1A, 0x19, 0x18, 0x10,
+0x00, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x22, 0x21, 0x20, 0x08, 0x00, 0x31,
+0x2C, 0x10, 0x10, 0x00, 0x31, 0x28, 0x10, 0x00, 0x00, 0x12, 0x11, 0x10,
+0x08, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00,
+0x22, 0x21, 0x20, 0x08, 0x00, 0x22, 0x21, 0x14, 0x08, 0x00, 0x22, 0x20,
+0x18, 0x08, 0x00, 0x31, 0x30, 0x20, 0x10, 0x00, 0x31, 0x2C, 0x10, 0x10,
+0x00, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x12, 0x11, 0x10, 0x08, 0x00, 0x22,
+0x21, 0x20, 0x18, 0x00, 0x22, 0x21, 0x20, 0x18, 0x00, 0x31, 0x30, 0x20,
+0x10, 0x00, 0x31, 0x2F, 0x10, 0x10, 0x00, 0x31, 0x2F, 0x10, 0x10, 0x00,
+0x31, 0x10, 0x10, 0x00, 0x00, 0x31, 0x2C, 0x10, 0x10, 0x00, 0x00, 0x00,
+0x01, 0x02, 0x04, 0x08, 0x02, 0x04, 0x08, 0x0C, 0x10, 0x18, 0x20, 0x30,
+0x02, 0x04, 0x08, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x06, 0x0C, 0x10, 0x18,
+0x24, 0x30, 0x3C, 0x48, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x27, 0x2C, 0x19, 0x1B, 0x1E, 0x20,
+0x23, 0x29, 0x2A, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x25, 0x29, 0x2B, 0x2E,
+0x2E, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
+0x24, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
+0x60, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
+0xD8, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
+0xA0, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00,
+0x90, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00,
+0x2C, 0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00,
+0xD0, 0x02, 0x00, 0x00, 0x80, 0x0C, 0x00, 0x00, 0x80, 0x0C, 0x00, 0x00,
+0x80, 0x0C, 0x00, 0x00, 0xA0, 0x0F, 0x00, 0x00, 0xA0, 0x0F, 0x00, 0x00,
+0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
+0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
+0x18, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+0x48, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00,
+0x28, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
+0x64, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00,
+0xF0, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
+0xA0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00,
+0x40, 0x06, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00,
+0xD0, 0x07, 0x00, 0x00, 0xD0, 0x07, 0x00, 0x00, 0x54, 0x86, 0x01, 0x80,
+0x4C, 0xC4, 0x00, 0x80, 0x4C, 0xC4, 0x00, 0x80, 0x4C, 0xC4, 0x00, 0x80,
+0x4C, 0xC4, 0x00, 0x80, 0x9C, 0xC2, 0x00, 0x80, 0x5C, 0x86, 0x01, 0x80,
+0x54, 0x86, 0x01, 0x80, 0x54, 0x86, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x01, 0x80, 0x44, 0x8B, 0x01, 0x80,
+0x44, 0x8B, 0x01, 0x80, 0x44, 0x8B, 0x01, 0x80, 0x34, 0x86, 0x01, 0x80,
+0x30, 0x8A, 0x01, 0x80, 0x3C, 0x86, 0x01, 0x80, 0x44, 0x86, 0x01, 0x80,
+0x4C, 0x86, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x08, 0x04, 0x04, 0x08, 0x02, 0x02, 0x01, 0x01, 0x80, 0x00, 0x00, 0x00,
+0x52, 0x54, 0x4C, 0x38, 0x37, 0x31, 0x32, 0x20, 0x46, 0x57, 0x20, 0x76,
+0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x30, 0x2E, 0x30, 0x2E, 0x31,
+0x23, 0x20, 0xE4, 0xB8, 0x80, 0x20, 0x35, 0xE6, 0x9C, 0x88, 0x20, 0x33,
+0x31, 0x20, 0x31, 0x35, 0x3A, 0x32, 0x35, 0x3A, 0x33, 0x39, 0x20, 0x43,
+0x53, 0x54, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x20, 0x53, 0x56, 0x4E,
+0x3A, 0x20, 0x25, 0x64, 0x00, 0x00, 0x00, 0x00, 0x43, 0x68, 0x69, 0x70,
+0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3A, 0x25, 0x78, 0x00,
+0x48, 0x43, 0x49, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x25, 0x78,
+0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x00, 0x72, 0x66, 0x5F, 0x63,
+0x6F, 0x66, 0x69, 0x67, 0x3A, 0x20, 0x25, 0x78, 0x28, 0x25, 0x78, 0x2C,
+0x20, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x00,
+0x6D, 0x70, 0x5F, 0x6D, 0x6F, 0x64, 0x65, 0x3A, 0x20, 0x25, 0x78, 0x28,
+0x25, 0x78, 0x29, 0x2C, 0x20, 0x49, 0x51, 0x4B, 0x3A, 0x20, 0x25, 0x78,
+0x0A, 0x00, 0x00, 0x00, 0x76, 0x63, 0x73, 0x20, 0x74, 0x79, 0x70, 0x65,
+0x3A, 0x20, 0x25, 0x78, 0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x00,
+0x33, 0x32, 0x6B, 0x20, 0x63, 0x61, 0x6C, 0x69, 0x62, 0x72, 0x61, 0x3A,
+0x20, 0x25, 0x64, 0x2C, 0x20, 0x33, 0x32, 0x4B, 0x20, 0x54, 0x53, 0x46,
+0x3A, 0x20, 0x25, 0x78, 0x00, 0x00, 0x00, 0x00, 0x74, 0x61, 0x72, 0x67,
+0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x72, 0x6D, 0x61, 0x6C, 0x3A, 0x20,
+0x25, 0x78, 0x2C, 0x20, 0x20, 0x62, 0x74, 0x5F, 0x63, 0x6F, 0x65, 0x78,
+0x69, 0x73, 0x74, 0x3A, 0x20, 0x25, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00,
+0x54, 0xAA, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x1C, 0xAA, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0xE4, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0xAC, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x74, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x3C, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80, 0x24, 0xA9, 0x01, 0x80,
+0x24, 0xA9, 0x01, 0x80, 0xFC, 0xA8, 0x01, 0x80, 0x64, 0x05, 0x00, 0x80,
+0x58, 0x05, 0x00, 0x80, 0x4C, 0x05, 0x00, 0x80, 0x40, 0x05, 0x00, 0x80,
+0x34, 0x05, 0x00, 0x80, 0x28, 0x05, 0x00, 0x80, 0x1C, 0x05, 0x00, 0x80,
+0x10, 0x05, 0x00, 0x80, 0x04, 0x05, 0x00, 0x80, 0xF8, 0x04, 0x00, 0x80,
+0xB0, 0x04, 0x00, 0x80, 0x60, 0x1B, 0x02, 0x80, 0xB0, 0x03, 0x25, 0xB0,
+0x60, 0x1B, 0x02, 0x80, 0x60, 0x1B, 0x02, 0x80, 0x60, 0x1B, 0x02, 0x80,
+0x60, 0x1B, 0x02, 0x80, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64,
+0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x49, 0x44, 0x3A,
+0x20, 0x25, 0x78, 0x2C, 0x20, 0x63, 0x6D, 0x64, 0x20, 0x73, 0x65, 0x71,
+0x3D, 0x25, 0x78, 0x2C, 0x20, 0x68, 0x32, 0x64, 0x73, 0x65, 0x71, 0x3D,
+0x25, 0x78, 0x0A, 0x00, 0x6A, 0x6F, 0x69, 0x6E, 0x62, 0x73, 0x73, 0x5F,
+0x68, 0x64, 0x6C, 0x00, 0x67, 0x65, 0x74, 0x20, 0x6A, 0x6F, 0x69, 0x6E,
+0x20, 0x63, 0x6D, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x20, 0x69,
+0x72, 0x70, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x00, 0x73, 0x65, 0x74, 0x20,
+0x6F, 0x70, 0x6D, 0x6F, 0x64, 0x65, 0x3A, 0x20, 0x25, 0x78, 0x0A, 0x00,
+0x67, 0x65, 0x74, 0x20, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x20, 0x63,
+0x6D, 0x64, 0x0A, 0x00, 0x53, 0x53, 0x49, 0x44, 0x3A, 0x20, 0x25, 0x73,
+0x0A, 0x00, 0x00, 0x00, 0x73, 0x65, 0x74, 0x41, 0x75, 0x74, 0x68, 0x3A,
+0x20, 0x25, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x72, 0x63, 0x76, 0x20,
+0x73, 0x65, 0x74, 0x5F, 0x73, 0x74, 0x61, 0x6B, 0x65, 0x79, 0x0A, 0x00,
+0x54, 0x78, 0x5F, 0x42, 0x65, 0x61, 0x63, 0x6F, 0x6E, 0x5F, 0x68, 0x64,
+0x6C, 0x00, 0x00, 0x00, 0x74, 0x78, 0x20, 0x62, 0x65, 0x61, 0x63, 0x6F,
+0x6E, 0x20, 0x63, 0x6D, 0x64, 0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00,
+0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x4D, 0x61, 0x63, 0x41, 0x64,
+0x64, 0x72, 0x0A, 0x00, 0x00, 0x0E, 0x04, 0x0E, 0x10, 0x0E, 0x14, 0x0E,
+0x18, 0x0E, 0x1C, 0x0E, 0x4F, 0x6E, 0x41, 0x73, 0x73, 0x6F, 0x63, 0x52,
+0x65, 0x71, 0x00, 0x00, 0x4F, 0x6E, 0x41, 0x73, 0x73, 0x6F, 0x63, 0x52,
+0x73, 0x70, 0x00, 0x00, 0x4F, 0x6E, 0x52, 0x65, 0x41, 0x73, 0x73, 0x6F,
+0x63, 0x52, 0x65, 0x71, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6E, 0x52, 0x65,
+0x41, 0x73, 0x73, 0x6F, 0x63, 0x52, 0x73, 0x70, 0x00, 0x00, 0x00, 0x00,
+0x4F, 0x6E, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x52, 0x65, 0x71, 0x00, 0x00,
+0x4F, 0x6E, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x52, 0x73, 0x70, 0x00, 0x00,
+0x4F, 0x6E, 0x42, 0x65, 0x61, 0x63, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x00,
+0x4F, 0x6E, 0x41, 0x54, 0x49, 0x4D, 0x00, 0x00, 0x4F, 0x6E, 0x44, 0x69,
+0x73, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x00, 0x00, 0x4F, 0x6E, 0x41, 0x75,
+0x74, 0x68, 0x00, 0x00, 0x4F, 0x6E, 0x44, 0x65, 0x41, 0x75, 0x74, 0x68,
+0x00, 0x00, 0x00, 0x00, 0x4F, 0x6E, 0x41, 0x63, 0x74, 0x69, 0x6F, 0x6E,
+0x00, 0x00, 0x00, 0x00, 0x4F, 0x6E, 0x51, 0x6F, 0x73, 0x4E, 0x75, 0x6C,
+0x6C, 0x00, 0x00, 0x00, 0x4F, 0x6E, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74,
+0x69, 0x6F, 0x6E, 0x00, 0x41, 0x54, 0x49, 0x4D, 0x3A, 0x20, 0x25, 0x78,
+0x0A, 0x00, 0x00, 0x00, 0x02, 0x04, 0x04, 0x07, 0x07, 0x0D, 0x0D, 0x0D,
+0x02, 0x07, 0x07, 0x0D, 0x0D, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00,
+0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x08, 0x10, 0x72, 0x65, 0x70, 0x6F,
+0x72, 0x74, 0x5F, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x5F, 0x64, 0x6F,
+0x6E, 0x65, 0x00, 0x00, 0x73, 0x75, 0x72, 0x76, 0x65, 0x79, 0x20, 0x64,
+0x6F, 0x6E, 0x65, 0x28, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x29, 0x0A,
+0x00, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x20, 0x69, 0x72, 0x70, 0x20, 0x25,
+0x73, 0x0A, 0x00, 0x00, 0x72, 0x65, 0x70, 0x6F, 0x72, 0x74, 0x5F, 0x6A,
+0x6F, 0x69, 0x6E, 0x5F, 0x72, 0x65, 0x73, 0x00, 0x4E, 0x6F, 0x20, 0x69,
+0x72, 0x70, 0x28, 0x25, 0x78, 0x29, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x00,
+0x6A, 0x6F, 0x69, 0x6E, 0x20, 0x72, 0x65, 0x73, 0x28, 0x25, 0x78, 0x2C,
+0x20, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x00, 0x72, 0x65, 0x70, 0x6F,
+0x72, 0x74, 0x5F, 0x64, 0x65, 0x6C, 0x5F, 0x73, 0x74, 0x61, 0x5F, 0x65,
+0x76, 0x65, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x64, 0x65, 0x6C, 0x20,
+0x73, 0x74, 0x61, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x72, 0x65, 0x70, 0x6F,
+0x72, 0x74, 0x5F, 0x61, 0x64, 0x64, 0x5F, 0x73, 0x74, 0x61, 0x5F, 0x65,
+0x76, 0x65, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x61, 0x64, 0x64, 0x20,
+0x73, 0x74, 0x61, 0x3A, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x0A, 0x00,
+0x72, 0x63, 0x76, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6F, 0x6E, 0x6E, 0x65,
+0x63, 0x74, 0x0A, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x70, 0x72,
+0x6F, 0x62, 0x65, 0x72, 0x65, 0x71, 0x00, 0x00, 0x4E, 0x6F, 0x20, 0x69,
+0x72, 0x70, 0x20, 0x40, 0x25, 0x73, 0x0A, 0x00, 0x57, 0x4D, 0x4D, 0x28,
+0x25, 0x78, 0x29, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x0A,
+0x00, 0x00, 0x00, 0x00, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x20, 0x72, 0x65,
+0x6A, 0x65, 0x63, 0x74, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
+0x3A, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x63, 0x20,
+0x69, 0x64, 0x20, 0x23, 0x35, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25,
+0x78, 0x2C, 0x20, 0x25, 0x78, 0x0A, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75,
+0x65, 0x5F, 0x70, 0x72, 0x6F, 0x62, 0x65, 0x72, 0x73, 0x70, 0x00, 0x00,
+0x72, 0x65, 0x70, 0x6F, 0x72, 0x74, 0x5F, 0x42, 0x53, 0x53, 0x49, 0x44,
+0x5F, 0x69, 0x6E, 0x66, 0x6F, 0x00, 0x00, 0x00, 0x70, 0x61, 0x63, 0x6B,
+0x65, 0x74, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65,
+0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x50, 0xF2, 0x01,
+0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x63, 0x61, 0x70, 0x3A,
+0x25, 0x78, 0x0A, 0x00, 0x49, 0x42, 0x53, 0x53, 0x20, 0x6D, 0x6F, 0x64,
+0x65, 0x2C, 0x20, 0x63, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E,
+0x65, 0x6C, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x62, 0x63, 0x6E, 0x20,
+0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x3A, 0x20, 0x25, 0x78,
+0x0A, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x63, 0x20, 0x69, 0x64, 0x20, 0x23,
+0x34, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x0A, 0x00, 0x00,
+0x63, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x3A,
+0x20, 0x25, 0x78, 0x2C, 0x20, 0x62, 0x63, 0x6E, 0x20, 0x69, 0x6E, 0x74,
+0x65, 0x72, 0x76, 0x61, 0x6C, 0x3A, 0x20, 0x25, 0x78, 0x0A, 0x00, 0x00,
+0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x72,
+0x65, 0x71, 0x00, 0x00, 0x00, 0x50, 0xF2, 0x04, 0x69, 0x73, 0x73, 0x75,
+0x65, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x72, 0x65, 0x71, 0x28, 0x25,
+0x78, 0x29, 0x0A, 0x00, 0x5B, 0x57, 0x41, 0x50, 0x49, 0x5D, 0x20, 0x67,
+0x65, 0x74, 0x20, 0x77, 0x61, 0x70, 0x69, 0x20, 0x49, 0x45, 0x0A, 0x00,
+0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E,
+0x00, 0x00, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x20, 0x61, 0x63,
+0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78,
+0x2C, 0x20, 0x25, 0x78, 0x20, 0x0A, 0x00, 0x00, 0x44, 0x45, 0x4C, 0x42,
+0x41, 0x3A, 0x20, 0x25, 0x78, 0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00,
+0x41, 0x44, 0x44, 0x42, 0x41, 0x20, 0x52, 0x53, 0x50, 0x3A, 0x20, 0x25,
+0x78, 0x0A, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x61, 0x75,
+0x74, 0x68, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x20, 0x61, 0x75,
+0x74, 0x68, 0x0A, 0x00, 0x63, 0x6C, 0x6E, 0x74, 0x20, 0x61, 0x75, 0x74,
+0x68, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x64, 0x75, 0x65,
+0x20, 0x74, 0x6F, 0x20, 0x69, 0x6C, 0x6C, 0x65, 0x67, 0x61, 0x6C, 0x20,
+0x73, 0x65, 0x71, 0x3D, 0x25, 0x78, 0x0A, 0x00, 0x63, 0x6C, 0x6E, 0x74,
+0x20, 0x61, 0x75, 0x74, 0x68, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x2C, 0x20,
+0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3A, 0x20, 0x25, 0x64, 0x0A, 0x00,
+0x6E, 0x6F, 0x20, 0x63, 0x68, 0x61, 0x6C, 0x6C, 0x65, 0x6E, 0x67, 0x65,
+0x20, 0x74, 0x65, 0x78, 0x74, 0x3F, 0x0A, 0x00, 0x6C, 0x69, 0x6E, 0x6B,
+0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20,
+0x41, 0x50, 0x0A, 0x00, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20,
+0x41, 0x74, 0x68, 0x65, 0x72, 0x6F, 0x73, 0x20, 0x41, 0x50, 0x28, 0x4D,
+0x41, 0x43, 0x29, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x63, 0x20,
+0x69, 0x64, 0x20, 0x23, 0x25, 0x78, 0x3A, 0x20, 0x25, 0x78, 0x2C, 0x20,
+0x25, 0x78, 0x0A, 0x00, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20,
+0x42, 0x72, 0x6F, 0x61, 0x64, 0x63, 0x6F, 0x6D, 0x20, 0x41, 0x50, 0x0A,
+0x00, 0x00, 0x00, 0x00, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20,
+0x41, 0x74, 0x68, 0x65, 0x72, 0x6F, 0x73, 0x20, 0x41, 0x50, 0x0A, 0x00,
+0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x4D, 0x61, 0x72, 0x76,
+0x65, 0x6C, 0x6C, 0x20, 0x41, 0x50, 0x0A, 0x00, 0x6C, 0x69, 0x6E, 0x6B,
+0x20, 0x74, 0x6F, 0x20, 0x52, 0x65, 0x61, 0x6C, 0x74, 0x65, 0x6B, 0x20,
+0x39, 0x36, 0x42, 0x20, 0x41, 0x50, 0x0A, 0x00, 0x6C, 0x69, 0x6E, 0x6B,
+0x20, 0x74, 0x6F, 0x20, 0x43, 0x69, 0x73, 0x63, 0x6F, 0x20, 0x41, 0x50,
+0x0A, 0x00, 0x00, 0x00, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20,
+0x52, 0x61, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x41, 0x50, 0x0A, 0x00, 0x00,
+0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x74, 0x6F, 0x20, 0x52, 0x65, 0x61, 0x6C,
+0x74, 0x65, 0x6B, 0x20, 0x39, 0x36, 0x42, 0x20, 0x41, 0x50, 0x20, 0x77,
+0x69, 0x74, 0x68, 0x20, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x20, 0x6D, 0x6F,
+0x64, 0x65, 0x0A, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x64, 0x65,
+0x61, 0x75, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75,
+0x65, 0x5F, 0x64, 0x65, 0x61, 0x75, 0x74, 0x68, 0x0A, 0x00, 0x00, 0x00,
+0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x64, 0x69, 0x73, 0x61, 0x73, 0x73,
+0x6F, 0x63, 0x00, 0x00, 0x69, 0x73, 0x73, 0x75, 0x65, 0x5F, 0x64, 0x69,
+0x73, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x0A, 0x00, 0x69, 0x73, 0x73, 0x75,
+0x65, 0x5F, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x5F, 0x6C, 0x65, 0x6E, 0x00,
+0x64, 0x69, 0x73, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x74,
+0x69, 0x6D, 0x65, 0x72, 0x3A, 0x20, 0x6E, 0x6F, 0x20, 0x62, 0x65, 0x61,
+0x63, 0x6F, 0x6E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x64, 0x69, 0x73, 0x63,
+0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x28, 0x6E, 0x6F, 0x20, 0x64, 0x61,
+0x74, 0x61, 0x20, 0x72, 0x63, 0x76, 0x64, 0x29, 0x0A, 0x00, 0x00, 0x00,
+0x69, 0x73, 0x73, 0x75, 0x65, 0x20, 0x51, 0x6F, 0x73, 0x4E, 0x75, 0x6C,
+0x6C, 0x28, 0x25, 0x64, 0x29, 0x00, 0x00, 0x00, 0x60, 0x1B, 0x02, 0x80,
+0xB0, 0x03, 0x25, 0xB0, 0x18, 0x03, 0x25, 0xB0, 0x44, 0x44, 0x33, 0x33,
+0x06, 0x00, 0x2A, 0xB0, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB4, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0x38, 0x4A, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0x2C, 0x4A, 0x01, 0x80, 0x20, 0x4A, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0x14, 0x4A, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0x08, 0x4A, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xFC, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xF0, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xE4, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xD8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xCC, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80, 0xB8, 0x49, 0x01, 0x80,
+0xB8, 0x49, 0x01, 0x80, 0xC0, 0x49, 0x01, 0x80, 0xF8, 0x4A, 0x01, 0x80,
+0xEC, 0x4A, 0x01, 0x80, 0xE0, 0x4A, 0x01, 0x80, 0xD4, 0x4A, 0x01, 0x80,
+0xC8, 0x4A, 0x01, 0x80, 0xBC, 0x4A, 0x01, 0x80, 0xB0, 0x4A, 0x01, 0x80,
+0xA4, 0x4A, 0x01, 0x80, 0x98, 0x4A, 0x01, 0x80, 0x8C, 0x4A, 0x01, 0x80,
+0x80, 0x4A, 0x01, 0x80, 0x74, 0x4A, 0x01, 0x80, 0x00, 0x50, 0xF2, 0x01,
+0x00, 0x50, 0xF2, 0x02, 0x00, 0x0F, 0xAC, 0x02, 0x30, 0x31, 0x32, 0x33,
+0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
+0x00, 0x00, 0x00, 0x00, 0x25, 0x64, 0x2E, 0x00, 0x25, 0x68, 0x68, 0x58,
+0x3A, 0x00, 0x00, 0x00, 0xEC, 0xEE, 0x01, 0x80, 0x67, 0x66, 0x66, 0x66,
+0x87, 0x7C, 0x00, 0x80, 0x5D, 0x7C, 0x00, 0x80, 0x37, 0x7C, 0x00, 0x80,
+0x11, 0x7C, 0x00, 0x80, 0xC1, 0x7B, 0x00, 0x80, 0x9B, 0x7B, 0x00, 0x80,
+0xEB, 0x7B, 0x00, 0x80, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x63,
+0x61, 0x6D, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x28, 0x25, 0x78,
+0x2C, 0x20, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00, 0x2D, 0x3E, 0x28, 0x25,
+0x78, 0x2C, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25, 0x78, 0x2C, 0x20, 0x25,
+0x78, 0x29, 0x0A, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x09, 0x00, 0x00,
+0xDF, 0x88, 0x00, 0x80, 0xE5, 0x88, 0x00, 0x80, 0xEB, 0x88, 0x00, 0x80,
+0xF1, 0x88, 0x00, 0x80, 0xDF, 0x88, 0x00, 0x80, 0xDF, 0x88, 0x00, 0x80,
+0xDF, 0x88, 0x00, 0x80, 0xDF, 0x88, 0x00, 0x80, 0xF7, 0x88, 0x00, 0x80,
+0xFD, 0x88, 0x00, 0x80, 0x03, 0x89, 0x00, 0x80, 0x09, 0x89, 0x00, 0x80,
+0x60, 0x1B, 0x02, 0x80, 0x55, 0x6E, 0x69, 0x20, 0x4F, 0x6B, 0x3A, 0x20,
+0x41, 0x50, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xC0, 0xFF,
+0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0x03, 0xFE, 0x01, 0x80, 0x7F,
+0xE2, 0x01, 0x80, 0x78, 0xC7, 0x01, 0xC0, 0x71, 0xAE, 0x01, 0x80, 0x6B,
+0x95, 0x01, 0x40, 0x65, 0x7F, 0x01, 0xC0, 0x5F, 0x69, 0x01, 0x40, 0x5A,
+0x55, 0x01, 0x40, 0x55, 0x42, 0x01, 0x80, 0x50, 0x30, 0x01, 0x00, 0x4C,
+0x1F, 0x01, 0xC0, 0x47, 0x0F, 0x01, 0xC0, 0x43, 0x00, 0x01, 0x00, 0x40,
+0xF2, 0x00, 0x80, 0x3C, 0xE4, 0x00, 0x00, 0x39, 0xD7, 0x00, 0xC0, 0x35,
+0xCB, 0x00, 0xC0, 0x32, 0xC0, 0x00, 0x00, 0x30, 0xB5, 0x00, 0x40, 0x2D,
+0xAB, 0x00, 0xC0, 0x2A, 0xA2, 0x00, 0x80, 0x28, 0x98, 0x00, 0x00, 0x26,
+0x90, 0x00, 0x00, 0x24, 0x88, 0x00, 0x00, 0x22, 0x80, 0x00, 0x00, 0x20,
+0x79, 0x00, 0x40, 0x1E, 0x72, 0x00, 0x80, 0x1C, 0x6C, 0x00, 0x00, 0x1B,
+0x66, 0x00, 0x80, 0x19, 0x60, 0x00, 0x00, 0x18, 0x5B, 0x00, 0xC0, 0x16,
+0x56, 0x00, 0x80, 0x15, 0x51, 0x00, 0x40, 0x14, 0x4C, 0x00, 0x00, 0x13,
+0x48, 0x00, 0x00, 0x12, 0x44, 0x00, 0x00, 0x11, 0x40, 0x00, 0x00, 0x10,
+0x36, 0x35, 0x2E, 0x25, 0x1C, 0x12, 0x09, 0x04, 0x33, 0x32, 0x2B, 0x23,
+0x1A, 0x11, 0x08, 0x04, 0x30, 0x2F, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03,
+0x2D, 0x2D, 0x27, 0x1F, 0x18, 0x0F, 0x08, 0x03, 0x2B, 0x2A, 0x25, 0x1E,
+0x16, 0x0E, 0x07, 0x03, 0x28, 0x28, 0x22, 0x1C, 0x15, 0x0D, 0x07, 0x03,
+0x26, 0x25, 0x21, 0x1B, 0x14, 0x0D, 0x06, 0x03, 0x24, 0x23, 0x1F, 0x19,
+0x13, 0x0C, 0x06, 0x03, 0x22, 0x21, 0x1D, 0x18, 0x11, 0x0B, 0x06, 0x02,
+0x20, 0x20, 0x1B, 0x16, 0x11, 0x08, 0x05, 0x02, 0x1F, 0x1E, 0x1A, 0x15,
+0x10, 0x0A, 0x05, 0x02, 0x1D, 0x1C, 0x18, 0x14, 0x0F, 0x0A, 0x05, 0x02,
+0x1B, 0x1A, 0x17, 0x13, 0x0E, 0x09, 0x04, 0x02, 0x1A, 0x19, 0x16, 0x12,
+0x0D, 0x09, 0x04, 0x02, 0x18, 0x17, 0x15, 0x11, 0x0C, 0x08, 0x04, 0x02,
+0x17, 0x16, 0x13, 0x10, 0x0C, 0x08, 0x04, 0x02, 0x16, 0x15, 0x12, 0x0F,
+0x0B, 0x07, 0x04, 0x01, 0x14, 0x14, 0x11, 0x0E, 0x0B, 0x07, 0x03, 0x02,
+0x13, 0x13, 0x10, 0x0D, 0x0A, 0x06, 0x03, 0x01, 0x12, 0x12, 0x0F, 0x0C,
+0x09, 0x06, 0x03, 0x01, 0x11, 0x11, 0x0F, 0x0C, 0x09, 0x06, 0x03, 0x01,
+0x10, 0x10, 0x0E, 0x0B, 0x08, 0x05, 0x03, 0x01, 0x0F, 0x0F, 0x0D, 0x0B,
+0x08, 0x05, 0x03, 0x01, 0x0E, 0x0E, 0x0C, 0x0A, 0x08, 0x05, 0x02, 0x01,
+0x0D, 0x0D, 0x0C, 0x0A, 0x07, 0x05, 0x02, 0x01, 0x0D, 0x0C, 0x0B, 0x09,
+0x07, 0x04, 0x02, 0x01, 0x0C, 0x0C, 0x0A, 0x09, 0x06, 0x04, 0x02, 0x01,
+0x0B, 0x0B, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x01, 0x0B, 0x0A, 0x09, 0x08,
+0x06, 0x04, 0x02, 0x01, 0x0A, 0x0A, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01,
+0x0A, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01, 0x09, 0x09, 0x08, 0x06,
+0x05, 0x03, 0x01, 0x01, 0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01,
+0x36, 0x35, 0x2E, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x33, 0x32, 0x2B, 0x19,
+0x00, 0x00, 0x00, 0x00, 0x30, 0x2F, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00,
+0x2D, 0x2D, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x2A, 0x25, 0x15,
+0x00, 0x00, 0x00, 0x00, 0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00,
+0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00, 0x24, 0x23, 0x1F, 0x12,
+0x00, 0x00, 0x00, 0x00, 0x22, 0x21, 0x1D, 0x11, 0x00, 0x00, 0x00, 0x00,
+0x20, 0x20, 0x1B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1E, 0x1A, 0x0F,
+0x00, 0x00, 0x00, 0x00, 0x1D, 0x1C, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
+0x1B, 0x1A, 0x17, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x19, 0x16, 0x0D,
+0x00, 0x00, 0x00, 0x00, 0x18, 0x17, 0x15, 0x0C, 0x00, 0x00, 0x00, 0x00,
+0x17, 0x16, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x16, 0x15, 0x12, 0x0B,
+0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x11, 0x0A, 0x00, 0x00, 0x00, 0x00,
+0x13, 0x13, 0x10, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x0F, 0x09,
+0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x0F, 0x09, 0x00, 0x00, 0x00, 0x00,
+0x10, 0x10, 0x0E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0D, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0C, 0x07, 0x00, 0x00, 0x00, 0x00,
+0x0D, 0x0D, 0x0C, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x0C, 0x0B, 0x06,
+0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0A, 0x06, 0x00, 0x00, 0x00, 0x00,
+0x0B, 0x0B, 0x0A, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0A, 0x09, 0x05,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00,
+0x0A, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x08, 0x05,
+0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00,
+0x72, 0x65, 0x73, 0x65, 0x74, 0x28, 0x25, 0x78, 0x29, 0x0A, 0x00, 0x00,
+0x50, 0x53, 0x00, 0x00, 0xE8, 0x86, 0x01, 0x80, 0x58, 0x87, 0x01, 0x80,
+0x14, 0x87, 0x01, 0x80, 0x58, 0x87, 0x01, 0x80, 0x58, 0x87, 0x01, 0x80,
+0x58, 0x87, 0x01, 0x80, 0x58, 0x87, 0x01, 0x80, 0xC0, 0x86, 0x01, 0x80,
+0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04,
+0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
+0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x28, 0x28, 0x28, 0x28, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+0xA0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x10, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+0x04, 0x04, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x41, 0x41, 0x41,
+0x41, 0x41, 0x41, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10,
+0x10, 0x10, 0x10, 0x10, 0x10, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x02,
+0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10, 0x10, 0x10, 0x10, 0x08,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+0x10, 0x10, 0x10, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
+0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10,
+0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x2D, 0x5C, 0x7C, 0x2F,
+0x00, 0x00, 0x00, 0x00, 0x0A, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0xF0, 0xF4, 0x5E, 0x00, 0xF0, 0xF4, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xE5, 0x5E, 0x00,
+0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xB8, 0xA0, 0xFC, 0x08, 0xFF, 0xFF, 0xFF, 0xFF,
+};
diff --git a/drivers/staging/rtl8712/generic.h b/drivers/staging/rtl8712/generic.h
new file mode 100644
index 0000000..8868c9f
--- /dev/null
+++ b/drivers/staging/rtl8712/generic.h
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+
+
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+extern __u32			ntohl(__u32);
+extern __u32			htonl(__u32);
+extern unsigned short int	ntohs(unsigned short int);
+extern unsigned short int	htons(unsigned short int);
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
+
diff --git a/drivers/staging/rtl8712/hal_init.c b/drivers/staging/rtl8712/hal_init.c
new file mode 100644
index 0000000..cc893c0
--- /dev/null
+++ b/drivers/staging/rtl8712/hal_init.c
@@ -0,0 +1,404 @@
+/******************************************************************************
+ * hal_init.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HAL_INIT_C_
+
+#include <linux/usb.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/firmware.h>
+#include <linux/module.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "usb_osintf.h"
+
+#define FWBUFF_ALIGN_SZ 512
+#define MAX_DUMP_FWSZ	49152 /*default = 49152 (48k)*/
+
+static void rtl871x_load_fw_cb(const struct firmware *firmware, void *context)
+{
+	struct _adapter *padapter = context;
+
+	complete(&padapter->rtl8712_fw_ready);
+	if (!firmware) {
+		struct usb_device *udev = padapter->dvobjpriv.pusbdev;
+		struct usb_interface *pusb_intf = padapter->pusb_intf;
+		printk(KERN_ERR "r8712u: Firmware request failed\n");
+		padapter->fw_found = false;
+		usb_put_dev(udev);
+		usb_set_intfdata(pusb_intf, NULL);
+		return;
+	}
+	padapter->fw = firmware;
+	padapter->fw_found = true;
+	/* firmware available - start netdev */
+	register_netdev(padapter->pnetdev);
+}
+
+static const char firmware_file[] = "rtlwifi/rtl8712u.bin";
+
+int rtl871x_load_fw(struct _adapter *padapter)
+{
+	struct device *dev = &padapter->dvobjpriv.pusbdev->dev;
+	int rc;
+
+	init_completion(&padapter->rtl8712_fw_ready);
+	printk(KERN_INFO "r8712u: Loading firmware from \"%s\"\n",
+	       firmware_file);
+	rc = request_firmware_nowait(THIS_MODULE, 1, firmware_file, dev,
+				     GFP_KERNEL, padapter, rtl871x_load_fw_cb);
+	if (rc)
+		printk(KERN_ERR "r8712u: Firmware request error %d\n", rc);
+	return rc;
+}
+MODULE_FIRMWARE("rtlwifi/rtl8712u.bin");
+
+static u32 rtl871x_open_fw(struct _adapter *padapter, const u8 **ppmappedfw)
+{
+	const struct firmware **praw = &padapter->fw;
+
+	if (padapter->fw->size > 200000) {
+		printk(KERN_ERR "r8172u: Badfw->size of %d\n",
+		       (int)padapter->fw->size);
+		return 0;
+	}
+	*ppmappedfw = (u8 *)((*praw)->data);
+	return (*praw)->size;
+}
+
+static void fill_fwpriv(struct _adapter *padapter, struct fw_priv *pfwpriv)
+{
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	memset(pfwpriv, 0, sizeof(struct fw_priv));
+	/* todo: check if needs endian conversion */
+	pfwpriv->hci_sel =  RTL8712_HCI_TYPE_72USB;
+	pfwpriv->usb_ep_num = (u8)pdvobj->nr_endpoint;
+	pfwpriv->bw_40MHz_en = pregpriv->cbw40_enable;
+	switch (pregpriv->rf_config) {
+	case RTL8712_RF_1T1R:
+		pfwpriv->rf_config = RTL8712_RFC_1T1R;
+		break;
+	case RTL8712_RF_2T2R:
+		pfwpriv->rf_config = RTL8712_RFC_2T2R;
+		break;
+	case RTL8712_RF_1T2R:
+	default:
+		pfwpriv->rf_config = RTL8712_RFC_1T2R;
+	}
+	pfwpriv->mp_mode = (pregpriv->mp_mode == 1) ? 1 : 0;
+	pfwpriv->vcsType = pregpriv->vrtl_carrier_sense; /* 0:off 1:on 2:auto */
+	pfwpriv->vcsMode = pregpriv->vcs_type; /* 1:RTS/CTS 2:CTS to self */
+	/* default enable turboMode */
+	pfwpriv->turboMode = ((pregpriv->wifi_test == 1) ? 0 : 1);
+	pfwpriv->lowPowerMode = pregpriv->low_power;
+}
+
+static void update_fwhdr(struct fw_hdr	*pfwhdr, const u8 *pmappedfw)
+{
+	pfwhdr->signature = le16_to_cpu(*(u16 *)pmappedfw);
+	pfwhdr->version = le16_to_cpu(*(u16 *)(pmappedfw+2));
+	/* define the size of boot loader */
+	pfwhdr->dmem_size = le32_to_cpu(*(uint *)(pmappedfw+4));
+	/* define the size of FW in IMEM */
+	pfwhdr->img_IMEM_size = le32_to_cpu(*(uint *)(pmappedfw+8));
+	/* define the size of FW in SRAM */
+	pfwhdr->img_SRAM_size = le32_to_cpu(*(uint *)(pmappedfw+12));
+	/* define the size of DMEM variable */
+	pfwhdr->fw_priv_sz = le32_to_cpu(*(uint *)(pmappedfw+16));
+}
+
+static u8 chk_fwhdr(struct fw_hdr *pfwhdr, u32 ulfilelength)
+{
+	u32	fwhdrsz, fw_sz;
+	u8 intf, rfconf;
+
+	/* check signature */
+	if ((pfwhdr->signature != 0x8712) && (pfwhdr->signature != 0x8192))
+		return _FAIL;
+	/* check interface */
+	intf = (u8)((pfwhdr->version&0x3000) >> 12);
+	/* check rf_conf */
+	rfconf = (u8)((pfwhdr->version&0xC000) >> 14);
+	/* check fw_priv_sze & sizeof(struct fw_priv) */
+	if (pfwhdr->fw_priv_sz != sizeof(struct fw_priv))
+		return _FAIL;
+	/* check fw_sz & image_fw_sz */
+	fwhdrsz = FIELD_OFFSET(struct fw_hdr, fwpriv) + pfwhdr->fw_priv_sz;
+	fw_sz =  fwhdrsz + pfwhdr->img_IMEM_size + pfwhdr->img_SRAM_size +
+		 pfwhdr->dmem_size;
+	if (fw_sz != ulfilelength)
+		return _FAIL;
+	return _SUCCESS;
+}
+
+static u8 rtl8712_dl_fw(struct _adapter *padapter)
+{
+	sint i;
+	u8 tmp8, tmp8_a;
+	u16 tmp16;
+	u32 maxlen = 0, tmp32; /* for compare usage */
+	uint dump_imem_sz, imem_sz, dump_emem_sz, emem_sz; /* max = 49152; */
+	struct fw_hdr fwhdr;
+	u32 ulfilelength;	/* FW file size */
+	const u8 *pmappedfw = NULL;
+	u8 *ptmpchar = NULL, *ppayload, *ptr;
+	struct tx_desc *ptx_desc;
+	u32 txdscp_sz = sizeof(struct tx_desc);
+	u8 ret = _FAIL;
+
+	ulfilelength = rtl871x_open_fw(padapter, &pmappedfw);
+	if (pmappedfw && (ulfilelength > 0)) {
+		update_fwhdr(&fwhdr, pmappedfw);
+		if (chk_fwhdr(&fwhdr, ulfilelength) == _FAIL)
+			return ret;
+		fill_fwpriv(padapter, &fwhdr.fwpriv);
+		/* firmware check ok */
+		maxlen = (fwhdr.img_IMEM_size > fwhdr.img_SRAM_size) ?
+			  fwhdr.img_IMEM_size : fwhdr.img_SRAM_size;
+		maxlen += txdscp_sz;
+		ptmpchar = _malloc(maxlen + FWBUFF_ALIGN_SZ);
+		if (ptmpchar == NULL)
+			return ret;
+
+		ptx_desc = (struct tx_desc *)(ptmpchar + FWBUFF_ALIGN_SZ -
+			    ((addr_t)(ptmpchar) & (FWBUFF_ALIGN_SZ - 1)));
+		ppayload = (u8 *)(ptx_desc) + txdscp_sz;
+		ptr = (u8 *)pmappedfw + FIELD_OFFSET(struct fw_hdr, fwpriv) +
+		      fwhdr.fw_priv_sz;
+		/* Download FirmWare */
+		/* 1. determine IMEM code size and Load IMEM Code Section */
+		imem_sz = fwhdr.img_IMEM_size;
+		do {
+			memset(ptx_desc, 0, TXDESC_SIZE);
+			if (imem_sz >  MAX_DUMP_FWSZ/*49152*/)
+				dump_imem_sz = MAX_DUMP_FWSZ;
+			else {
+				dump_imem_sz = imem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+			}
+			ptx_desc->txdw0 |= cpu_to_le32(dump_imem_sz &
+						       0x0000ffff);
+			memcpy(ppayload, ptr, dump_imem_sz);
+			r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+				  dump_imem_sz + TXDESC_SIZE,
+				  (u8 *)ptx_desc);
+			ptr += dump_imem_sz;
+			imem_sz -= dump_imem_sz;
+		} while (imem_sz > 0);
+		i = 10;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _IMEM_CODE_DONE) == 0) && (i > 0)) {
+			udelay(10);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0 || (tmp16 & _IMEM_CHK_RPT) == 0)
+			goto exit_fail;
+
+		/* 2.Download EMEM code size and Load EMEM Code Section */
+		emem_sz = fwhdr.img_SRAM_size;
+		do {
+			memset(ptx_desc, 0, TXDESC_SIZE);
+			if (emem_sz >  MAX_DUMP_FWSZ) /* max=48k */
+				dump_emem_sz = MAX_DUMP_FWSZ;
+			else {
+				dump_emem_sz = emem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+			}
+			ptx_desc->txdw0 |= cpu_to_le32(dump_emem_sz &
+						       0x0000ffff);
+			memcpy(ppayload, ptr, dump_emem_sz);
+			r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+				  dump_emem_sz+TXDESC_SIZE, (u8 *)ptx_desc);
+			ptr += dump_emem_sz;
+			emem_sz -= dump_emem_sz;
+		} while (emem_sz > 0);
+		i = 5;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _EMEM_CODE_DONE) == 0) && (i > 0)) {
+			udelay(10);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0 || (tmp16 & _EMEM_CHK_RPT) == 0)
+			goto exit_fail;
+
+		/* 3.Enable CPU */
+		tmp8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, tmp8|BIT(2));
+		tmp8_a = r8712_read8(padapter, SYS_CLKR);
+		if (tmp8_a != (tmp8|BIT(2)))
+			goto exit_fail;
+
+		tmp8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN+1, tmp8|BIT(2));
+		tmp8_a = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		if (tmp8_a != (tmp8|BIT(2)))
+			goto exit_fail;
+
+		tmp32 = r8712_read32(padapter, TCR);
+
+		/* 4.polling IMEM Ready */
+		i = 100;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _IMEM_RDY) == 0) && (i > 0)) {
+			msleep(20);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0) {
+			r8712_write16(padapter, 0x10250348, 0xc000);
+			r8712_write16(padapter, 0x10250348, 0xc001);
+			r8712_write16(padapter, 0x10250348, 0x2000);
+			r8712_write16(padapter, 0x10250348, 0x2001);
+			r8712_write16(padapter, 0x10250348, 0x2002);
+			r8712_write16(padapter, 0x10250348, 0x2003);
+			goto exit_fail;
+		}
+		/* 5.Download DMEM code size and Load EMEM Code Section */
+		memset(ptx_desc, 0, TXDESC_SIZE);
+		ptx_desc->txdw0 |= cpu_to_le32(fwhdr.fw_priv_sz&0x0000ffff);
+		ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+		memcpy(ppayload, &fwhdr.fwpriv, fwhdr.fw_priv_sz);
+		r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+			  fwhdr.fw_priv_sz + TXDESC_SIZE, (u8 *)ptx_desc);
+
+		/* polling dmem code done */
+		i = 100;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _DMEM_CODE_DONE) == 0) && (i > 0)) {
+			msleep(20);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0)
+			goto exit_fail;
+
+		tmp8 = r8712_read8(padapter, 0x1025000A);
+		if (tmp8 & BIT(4)) /* When boot from EEPROM,
+				    & FW need more time to read EEPROM */
+			i = 60;
+		else			/* boot from EFUSE */
+			i = 30;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _FWRDY) == 0) && (i > 0)) {
+			msleep(100);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0)
+			goto exit_fail;
+	} else
+		goto exit_fail;
+	ret = _SUCCESS;
+
+exit_fail:
+	kfree(ptmpchar);
+	return ret;
+}
+
+uint rtl8712_hal_init(struct _adapter *padapter)
+{
+	u32 val32;
+	int i;
+
+	/* r8712 firmware download */
+	if (rtl8712_dl_fw(padapter) != _SUCCESS)
+		return _FAIL;
+
+	printk(KERN_INFO "r8712u: 1 RCR=0x%x\n",  r8712_read32(padapter, RCR));
+	val32 = r8712_read32(padapter, RCR);
+	r8712_write32(padapter, RCR, (val32 | BIT(26))); /* Enable RX TCP
+							    Checksum offload */
+	printk(KERN_INFO "r8712u: 2 RCR=0x%x\n", r8712_read32(padapter, RCR));
+	val32 = r8712_read32(padapter, RCR);
+	r8712_write32(padapter, RCR, (val32|BIT(25))); /* Append PHY status */
+	val32 = 0;
+	val32 = r8712_read32(padapter, 0x10250040);
+	r8712_write32(padapter,  0x10250040, (val32&0x00FFFFFF));
+	/* for usb rx aggregation */
+	r8712_write8(padapter, 0x102500B5, r8712_read8(padapter, 0x102500B5) |
+	       BIT(0)); /* page = 128bytes */
+	r8712_write8(padapter, 0x102500BD, r8712_read8(padapter, 0x102500BD) |
+	       BIT(7)); /* enable usb rx aggregation */
+	r8712_write8(padapter, 0x102500D9, 1); /* TH=1 => means that invalidate
+						*  usb rx aggregation */
+	r8712_write8(padapter, 0x1025FE5B, 0x04); /* 1.7ms/4 */
+	/* Fix the RX FIFO issue(USB error) */
+	r8712_write8(padapter, 0x1025fe5C, r8712_read8(padapter, 0x1025fe5C)
+		     | BIT(7));
+	for (i = 0; i < 6; i++)
+		padapter->eeprompriv.mac_addr[i] = r8712_read8(padapter,
+							       MACID + i);
+	return _SUCCESS;
+}
+
+uint rtl8712_hal_deinit(struct _adapter *padapter)
+{
+	r8712_write8(padapter, RF_CTRL, 0x00);
+	/* Turn off BB */
+	msleep(20);
+	/* Turn off MAC	*/
+	r8712_write8(padapter, SYS_CLKR+1, 0x38); /* Switch Control Path */
+	r8712_write8(padapter, SYS_FUNC_EN+1, 0x70);
+	r8712_write8(padapter, PMC_FSM, 0x06);  /* Enable Loader Data Keep */
+	r8712_write8(padapter, SYS_ISO_CTRL, 0xF9); /* Isolation signals from
+						     * CORE, PLL */
+	r8712_write8(padapter, SYS_ISO_CTRL+1, 0xe8); /* Enable EFUSE 1.2V */
+	r8712_write8(padapter, AFE_PLL_CTRL, 0x00); /* Disable AFE PLL. */
+	r8712_write8(padapter, LDOA15_CTRL, 0x54);  /* Disable A15V */
+	r8712_write8(padapter, SYS_FUNC_EN+1, 0x50); /* Disable E-Fuse 1.2V */
+	r8712_write8(padapter, LDOV12D_CTRL, 0x24); /* Disable LDO12(for CE) */
+	r8712_write8(padapter, AFE_MISC, 0x30); /* Disable AFE BG&MB */
+	/* Option for Disable 1.6V LDO.	*/
+	r8712_write8(padapter, SPS0_CTRL, 0x56); /* Disable 1.6V LDO */
+	r8712_write8(padapter, SPS0_CTRL+1, 0x43);  /* Set SW PFM */
+	return _SUCCESS;
+}
+
+uint rtl871x_hal_init(struct _adapter *padapter)
+{
+	padapter->hw_init_completed = false;
+	if (padapter->halpriv.hal_bus_init == NULL)
+		return _FAIL;
+	else {
+		if (padapter->halpriv.hal_bus_init(padapter) != _SUCCESS)
+			return _FAIL;
+	}
+	if (rtl8712_hal_init(padapter) == _SUCCESS)
+		padapter->hw_init_completed = true;
+	else {
+		padapter->hw_init_completed = false;
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/hex_to_bin.c b/drivers/staging/rtl8712/hex_to_bin.c
new file mode 100644
index 0000000..c713958
--- /dev/null
+++ b/drivers/staging/rtl8712/hex_to_bin.c
@@ -0,0 +1,23 @@
+/*
+ * rtl8712/hex_to_bin.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This is a backport of necessary functionf from lib/hexdump.c in the 
+ * Kernel version 3.4
+ */
+
+#include <linux/ctype.h>
+
+int hex_to_bin(char ch)
+{
+        if ((ch >= '0') && (ch <= '9'))
+                return ch - '0';
+        ch = tolower(ch);
+        if ((ch >= 'a') && (ch <= 'f'))
+                return ch - 'a' + 10;
+         return -1;
+}
+
diff --git a/drivers/staging/rtl8712/hex_to_bin.h b/drivers/staging/rtl8712/hex_to_bin.h
new file mode 100644
index 0000000..592e397
--- /dev/null
+++ b/drivers/staging/rtl8712/hex_to_bin.h
@@ -0,0 +1,16 @@
+/*
+ * rtl8712/hex_to_bin.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This is a backport of necessary functionf from lib/hexdump.c in the 
+ * Kernel version 3.4
+ */
+#ifndef _HEX_TO_BIN_H_
+#define _HEX_TO_BIN_H_
+
+int hex_to_bin(char ch);
+
+#endif //_HEX_TO_BIN_H_
diff --git a/drivers/staging/rtl8712/ieee80211.c b/drivers/staging/rtl8712/ieee80211.c
new file mode 100644
index 0000000..cc68d97
--- /dev/null
+++ b/drivers/staging/rtl8712/ieee80211.c
@@ -0,0 +1,421 @@
+/******************************************************************************
+ * ieee80211.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _IEEE80211_C
+
+#include "drv_types.h"
+#include "ieee80211.h"
+#include "wifi.h"
+#include "osdep_service.h"
+#include "wlan_bssdef.h"
+
+static const u8 WPA_OUI_TYPE[] = {0x00, 0x50, 0xf2, 1};
+static const u8 WPA_CIPHER_SUITE_NONE[] = {0x00, 0x50, 0xf2, 0};
+static const u8 WPA_CIPHER_SUITE_WEP40[] = {0x00, 0x50, 0xf2, 1};
+static const u8 WPA_CIPHER_SUITE_TKIP[] = {0x00, 0x50, 0xf2, 2};
+static const u8 WPA_CIPHER_SUITE_CCMP[] = {0x00, 0x50, 0xf2, 4};
+static const u8 WPA_CIPHER_SUITE_WEP104[] = {0x00, 0x50, 0xf2, 5};
+
+static const u8 RSN_CIPHER_SUITE_NONE[] = {0x00, 0x0f, 0xac, 0};
+static const u8 RSN_CIPHER_SUITE_WEP40[] = {0x00, 0x0f, 0xac, 1};
+static const u8 RSN_CIPHER_SUITE_TKIP[] = {0x00, 0x0f, 0xac, 2};
+static const u8 RSN_CIPHER_SUITE_CCMP[] = {0x00, 0x0f, 0xac, 4};
+static const u8 RSN_CIPHER_SUITE_WEP104[] = {0x00, 0x0f, 0xac, 5};
+
+/*-----------------------------------------------------------
+ * for adhoc-master to generate ie and provide supported-rate to fw
+ *-----------------------------------------------------------
+ */
+
+static u8 WIFI_CCKRATES[] =  {
+	(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)
+};
+
+static u8 WIFI_OFDMRATES[] = {
+	(IEEE80211_OFDM_RATE_6MB),
+	(IEEE80211_OFDM_RATE_9MB),
+	(IEEE80211_OFDM_RATE_12MB),
+	(IEEE80211_OFDM_RATE_18MB),
+	(IEEE80211_OFDM_RATE_24MB),
+	(IEEE80211_OFDM_RATE_36MB),
+	(IEEE80211_OFDM_RATE_48MB),
+	(IEEE80211_OFDM_RATE_54MB)
+};
+
+uint r8712_is_cckrates_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0) {
+		if ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||
+		    (((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))
+			return true;
+			i++;
+		}
+		return false;
+}
+
+uint r8712_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0) {
+		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
+			return false;
+		i++;
+	}
+	return true;
+}
+
+/* r8712_set_ie will update frame length */
+u8 *r8712_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen)
+{
+	*pbuf = (u8)index;
+	*(pbuf + 1) = (u8)len;
+	if (len > 0)
+		memcpy((void *)(pbuf + 2), (void *)source, len);
+	*frlen = *frlen + (len + 2);
+	return pbuf + len + 2;
+}
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+u8 *r8712_get_ie(u8 *pbuf, sint index, sint *len, sint limit)
+{
+	sint tmp, i;
+	u8 *p;
+
+	if (limit < 1)
+		return NULL;
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while (1) {
+		if (*p == index) {
+			*len = *(p + 1);
+			return p;
+		} else {
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+	return NULL;
+}
+
+static void set_supported_rate(u8 *SupportedRates, uint mode)
+{
+	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+	switch (mode) {
+	case WIRELESS_11B:
+		memcpy(SupportedRates, WIFI_CCKRATES,
+			IEEE80211_CCK_RATE_LEN);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11A:
+		memcpy(SupportedRates, WIFI_OFDMRATES,
+			IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	case WIRELESS_11BG:
+		memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+		memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES,
+			IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	}
+}
+
+static uint r8712_get_rateset_len(u8 *rateset)
+{
+	uint i = 0;
+
+	while (1) {
+		if ((rateset[i]) == 0)
+			break;
+		if (i > 12)
+			break;
+		i++;
+	}
+	return i;
+}
+
+int r8712_generate_ie(struct registry_priv *pregistrypriv)
+{
+	int sz = 0, rateLen;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *ie = pdev_network->IEs;
+
+	/*timestamp will be inserted by hardware*/
+	sz += 8;
+	ie += sz;
+	/*beacon interval : 2bytes*/
+	*(u16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);
+	sz += 2;
+	ie += 2;
+	/*capability info*/
+	*(u16 *)ie = 0;
+	*(u16 *)ie |= cpu_to_le16(cap_IBSS);
+	if (pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(u16 *)ie |= cpu_to_le16(cap_ShortPremble);
+	if (pdev_network->Privacy)
+		*(u16 *)ie |= cpu_to_le16(cap_Privacy);
+	sz += 2;
+	ie += 2;
+	/*SSID*/
+	ie = r8712_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength,
+		    pdev_network->Ssid.Ssid, &sz);
+	/*supported rates*/
+	set_supported_rate(pdev_network->SupportedRates,
+			   pregistrypriv->wireless_mode);
+	rateLen = r8712_get_rateset_len(pdev_network->SupportedRates);
+	if (rateLen > 8) {
+		ie = r8712_set_ie(ie, _SUPPORTEDRATES_IE_, 8,
+			    pdev_network->SupportedRates, &sz);
+		ie = r8712_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8),
+			    (pdev_network->SupportedRates + 8), &sz);
+	} else
+		ie = r8712_set_ie(ie, _SUPPORTEDRATES_IE_,
+			    rateLen, pdev_network->SupportedRates, &sz);
+	/*DS parameter set*/
+	ie = r8712_set_ie(ie, _DSSET_IE_, 1,
+		    (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
+	/*IBSS Parameter Set*/
+	ie = r8712_set_ie(ie, _IBSS_PARA_IE_, 2,
+		    (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
+	return sz;
+}
+
+unsigned char *r8712_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{
+	int len;
+	u16 val16;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
+	u8 *pbuf = pie;
+
+	while (1) {
+		pbuf = r8712_get_ie(pbuf, _WPA_IE_ID_, &len, limit);
+		if (pbuf) {
+			/*check if oui matches...*/
+			if (memcmp((pbuf + 2), wpa_oui_type,
+			    sizeof(wpa_oui_type)))
+				goto check_next_ie;
+			/*check version...*/
+			memcpy((u8 *)&val16, (pbuf + 6), sizeof(val16));
+			val16 = le16_to_cpu(val16);
+			if (val16 != 0x0001)
+				goto check_next_ie;
+			*wpa_ie_len = *(pbuf + 1);
+			return pbuf;
+		} else {
+			*wpa_ie_len = 0;
+			return NULL;
+		}
+check_next_ie:
+		limit = limit - (pbuf - pie) - 2 - len;
+		if (limit <= 0)
+			break;
+		pbuf += (2 + len);
+	}
+	*wpa_ie_len = 0;
+	return NULL;
+}
+
+unsigned char *r8712_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{
+	return r8712_get_ie(pie, _WPA2_IE_ID_, rsn_ie_len, limit);
+}
+
+static int r8712_get_wpa_cipher_suite(u8 *s)
+{
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_NONE;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_WEP40;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_TKIP;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_CCMP;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_WEP104;
+	return 0;
+}
+
+static int r8712_get_wpa2_cipher_suite(u8 *s)
+{
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_NONE;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_WEP40;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_TKIP;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_CCMP;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_WEP104;
+	return 0;
+}
+
+int r8712_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+		 int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie + 1) != (u8)(wpa_ie_len - 2))
+	     || (memcmp(wpa_ie + 2, (void *)WPA_OUI_TYPE, WPA_SELECTOR_LEN)))
+		return _FAIL;
+	pos = wpa_ie;
+	pos += 8;
+	left = wpa_ie_len - 8;
+	/*group_cipher*/
+	if (left >= WPA_SELECTOR_LEN) {
+		*group_cipher = r8712_get_wpa_cipher_suite(pos);
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+	} else if (left > 0)
+		return _FAIL;
+	/*pairwise_cipher*/
+	if (left >= 2) {
+		count = le16_to_cpu(*(u16 *)pos);
+		pos += 2;
+		left -= 2;
+		if (count == 0 || left < count * WPA_SELECTOR_LEN)
+			return _FAIL;
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= r8712_get_wpa_cipher_suite(pos);
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+	} else if (left == 1)
+		return _FAIL;
+	return ret;
+}
+
+int r8712_parse_wpa2_ie(u8 *rsn_ie, int rsn_ie_len, int *group_cipher,
+		  int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+	if ((*rsn_ie != _WPA2_IE_ID_) || (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
+		return _FAIL;
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;
+	/*group_cipher*/
+	if (left >= RSN_SELECTOR_LEN) {
+		*group_cipher = r8712_get_wpa2_cipher_suite(pos);
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+	} else if (left > 0)
+		return _FAIL;
+	/*pairwise_cipher*/
+	if (left >= 2) {
+		count = le16_to_cpu(*(u16 *)pos);
+		pos += 2;
+		left -= 2;
+		if (count == 0 || left < count * RSN_SELECTOR_LEN)
+			return _FAIL;
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= r8712_get_wpa2_cipher_suite(pos);
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+	} else if (left == 1)
+		return _FAIL;
+	return ret;
+}
+
+int r8712_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len,
+	       u8 *wpa_ie, u16 *wpa_len)
+{
+	u8 authmode, sec_idx;
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint cnt;
+
+	/*Search required WPA or WPA2 IE and copy to sec_ie[ ]*/
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+	sec_idx = 0;
+	while (cnt < in_len) {
+		authmode = in_ie[cnt];
+		if ((authmode == _WPA_IE_ID_) &&
+		    (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {
+			memcpy(wpa_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
+			*wpa_len = in_ie[cnt+1]+2;
+			cnt += in_ie[cnt + 1] + 2;  /*get next */
+		} else {
+			if (authmode == _WPA2_IE_ID_) {
+				memcpy(rsn_ie, &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				*rsn_len = in_ie[cnt+1] + 2;
+				cnt += in_ie[cnt+1] + 2;  /*get next*/
+			} else
+				cnt += in_ie[cnt+1] + 2;   /*get next*/
+		}
+	}
+	return *rsn_len + *wpa_len;
+}
+
+int r8712_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
+{
+	int match;
+	uint cnt;
+	u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+	cnt = 12;
+	match = false;
+	while (cnt < in_len) {
+		eid = in_ie[cnt];
+		if ((eid == _WPA_IE_ID_) &&
+		    (!memcmp(&in_ie[cnt+2], wps_oui, 4))) {
+			memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			*wps_ielen = in_ie[cnt+1]+2;
+			cnt += in_ie[cnt+1]+2;
+			match = true;
+			break;
+		} else
+			cnt += in_ie[cnt+1]+2; /* goto next */
+	}
+	return match;
+}
diff --git a/drivers/staging/rtl8712/ieee80211.h b/drivers/staging/rtl8712/ieee80211.h
new file mode 100644
index 0000000..3c0092b
--- /dev/null
+++ b/drivers/staging/rtl8712/ieee80211.h
@@ -0,0 +1,796 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include <linux/compiler.h>
+#include <linux/wireless.h>
+
+#define MGMT_QUEUE_NUM 5
+#define ETH_ALEN	6
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE			2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME				4
+
+#define IEEE_PARAM_WPA_ENABLED			1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED		3
+#define IEEE_PARAM_PRIVACY_INVOKED		4
+#define IEEE_PARAM_AUTH_ALGS			5
+#define IEEE_PARAM_IEEE_802_1X			6
+#define IEEE_PARAM_WPAX_SELECT			7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH			1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG		2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR		3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED	4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED		5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED	6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE				BIT(0)
+#define WPA_CIPHER_WEP40			BIT(1)
+#define WPA_CIPHER_WEP104			BIT(2)
+#define WPA_CIPHER_TKIP				BIT(3)
+#define WPA_CIPHER_CCMP				BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN			4
+#define RSN_HEADER_LEN				4
+
+#define RSN_SELECTOR_LEN 4
+
+enum NETWORK_TYPE {
+	WIRELESS_INVALID	= 0,
+	WIRELESS_11B		= 1,
+	WIRELESS_11G		= 2,
+	WIRELESS_11BG		= (WIRELESS_11B | WIRELESS_11G),
+	WIRELESS_11A		= 4,
+	WIRELESS_11N		= 8,
+	WIRELESS_11GN		= (WIRELESS_11G | WIRELESS_11N),
+	WIRELESS_11BGN		= (WIRELESS_11B | WIRELESS_11G | WIRELESS_11N),
+};
+
+
+struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+		struct {
+			int command;
+			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+	} u;
+};
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	struct list_head list;
+};
+
+struct ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __packed;
+
+struct ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __packed;
+
+
+struct	ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	u16	qc;
+}  __packed;
+
+struct  ieee80211_hdr_3addr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8  addr1[ETH_ALEN];
+	u8  addr2[ETH_ALEN];
+	u8  addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u16 qc;
+}  __packed;
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __packed;
+
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define IEEE80211_FCTL_VERS		0x0002
+#define IEEE80211_FCTL_FTYPE		0x000c
+#define IEEE80211_FCTL_STYPE		0x00f0
+#define IEEE80211_FCTL_TODS		0x0100
+#define IEEE80211_FCTL_FROMDS		0x0200
+#define IEEE80211_FCTL_MOREFRAGS	0x0400
+#define IEEE80211_FCTL_RETRY		0x0800
+#define IEEE80211_FCTL_PM		0x1000
+#define IEEE80211_FCTL_MOREDATA	0x2000
+#define IEEE80211_FCTL_WEP		0x4000
+#define IEEE80211_FCTL_ORDER		0x8000
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+
+/* management */
+#define IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define IEEE80211_STYPE_ASSOC_RESP	0x0010
+#define IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define IEEE80211_STYPE_PROBE_REQ	0x0040
+#define IEEE80211_STYPE_PROBE_RESP	0x0050
+#define IEEE80211_STYPE_BEACON		0x0080
+#define IEEE80211_STYPE_ATIM		0x0090
+#define IEEE80211_STYPE_DISASSOC	0x00A0
+#define IEEE80211_STYPE_AUTH		0x00B0
+#define IEEE80211_STYPE_DEAUTH		0x00C0
+
+/* control */
+#define IEEE80211_STYPE_PSPOLL		0x00A0
+#define IEEE80211_STYPE_RTS		0x00B0
+#define IEEE80211_STYPE_CTS		0x00C0
+#define IEEE80211_STYPE_ACK		0x00D0
+#define IEEE80211_STYPE_CFEND		0x00E0
+#define IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define IEEE80211_STYPE_DATA		0x0000
+#define IEEE80211_STYPE_DATA_CFACK	0x0010
+#define IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define IEEE80211_STYPE_NULLFUNC	0x0040
+#define IEEE80211_STYPE_CFACK		0x0050
+#define IEEE80211_STYPE_CFPOLL		0x0060
+#define IEEE80211_STYPE_CFACKPOLL	0x0070
+#define IEEE80211_QOS_DATAGRP		0x0080
+#define IEEE80211_QoS_DATAGRP		IEEE80211_QOS_DATAGRP
+
+#define IEEE80211_SCTL_FRAG		0x000F
+#define IEEE80211_SCTL_SEQ		0xFFF0
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+struct ieee80211_snap_hdr {
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+} __packed;
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+#define WLAN_EID_RSN 48
+#define WLAN_EID_GENERIC 221
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN			4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN			8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK		(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK   (IEEE80211_CCK_BASIC_RATES_MASK | \
+					   IEEE80211_CCK_RATE_5MB_MASK | \
+					   IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK  (IEEE80211_OFDM_BASIC_RATES_MASK | \
+					   IEEE80211_OFDM_RATE_9MB_MASK  | \
+					   IEEE80211_OFDM_RATE_18MB_MASK | \
+					   IEEE80211_OFDM_RATE_36MB_MASK | \
+					   IEEE80211_OFDM_RATE_48MB_MASK | \
+					   IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+				     IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   /*jackson*/
+	uint tid;	/*jackson*/
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats {
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+struct ieee80211_security {
+	u16 active_key:2,
+	    enabled:1,
+	    auth_mode:2,
+	    auth_algo:4,
+	    unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __packed;
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __packed;
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __packed;
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __packed;
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+} __packed;
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __packed;
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+} __packed;
+
+struct ieee80211_assoc_request_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	struct ieee80211_info_element_hdr info_element;
+} __packed;
+
+struct ieee80211_assoc_response_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+} __packed;
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+/*(HZ / 2)*/
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN 128
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+/*
+ * join_res:
+ * -1: authentication fail
+ * -2: association fail
+ * > 0: TID
+ */
+
+enum ieee80211_state {
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+	return 1;
+}
+
+extern inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case IEEE80211_FTYPE_DATA:
+		if (fc & IEEE80211_QOS_DATAGRP)
+			hdrlen += 2;
+		if ((fc & IEEE80211_FCTL_FROMDS) && (fc & IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case IEEE80211_STYPE_CTS:
+		case IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+	return hdrlen;
+}
+
+struct registry_priv;
+
+u8 *r8712_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+u8 *r8712_get_ie(u8*pbuf, sint index, sint *len, sint limit);
+unsigned char *r8712_get_wpa_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+unsigned char *r8712_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len,
+				 int limit);
+int r8712_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+			int *pairwise_cipher);
+int r8712_parse_wpa2_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+			int *pairwise_cipher);
+int r8712_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len,
+		     u8 *wpa_ie, u16 *wpa_len);
+int r8712_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+int r8712_generate_ie(struct registry_priv *pregistrypriv);
+uint r8712_is_cckrates_included(u8 *rate);
+uint r8712_is_cckratesonly_included(u8 *rate);
+
+#endif /* IEEE80211_H */
+
diff --git a/drivers/staging/rtl8712/if_ether.h b/drivers/staging/rtl8712/if_ether.h
new file mode 100644
index 0000000..2bbe527
--- /dev/null
+++ b/drivers/staging/rtl8712/if_ether.h
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet
+					 * [ NOT AN OFFICIAL ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr
+					 * Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames			*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011i		/* 802.2 frames			*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+	unsigned short  h_vlan_TCI;	/* Encapsulates priority and VLAN ID*/
+	unsigned short  h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short)\
+				 pvlan->h_vlan_TCI)) >> 13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short)\
+				    pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
+
diff --git a/drivers/staging/rtl8712/ip.h b/drivers/staging/rtl8712/ip.h
new file mode 100644
index 0000000..f37b0f8
--- /dev/null
+++ b/drivers/staging/rtl8712/ip.h
@@ -0,0 +1,137 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+
+#include "rtl871x_byteorder.h"
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 | IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 | IPOPT_CONTROL)
+#define IPOPT_SEC	(2 | IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 | IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 | IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 | IPOPT_CONTROL)
+#define IPOPT_SID	(8 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_SSRR	(9 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_RA	(20 | IPOPT_CONTROL | IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+ *
+ * REASONS: it is clear that nobody used them because:
+ * - MAX_ROUTES value was wrong.
+ * - "struct route" was wrong.
+ * - "struct timestamp" had fatally misaligned bitfields and was completely
+ *   unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+struct ip_options {
+	__u32		faddr;			/* Saved first hop address */
+	unsigned char	optlen;
+	unsigned char srr;
+	unsigned char rr;
+	unsigned char ts;
+	unsigned char is_setbyuser:1,	/* Set by setsockopt?		      */
+		      is_data:1,	/* Options in __data, rather than skb */
+		      is_strictroute:1, /* Strict source route		      */
+		      srr_is_hit:1,	/* Packet destination addr was our one*/
+		      is_changed:1,	/* IP checksum more not valid	      */
+		      rr_needaddr:1,	/* Need to record addr of outgoing dev*/
+		      ts_needtime:1,	/* Need to record timestamp	      */
+		      ts_needaddr:1;	/* Need to record addr of outgoing dev*/
+	unsigned char router_alert;
+	unsigned char __pad1;
+	unsigned char __pad2;
+	unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
+
diff --git a/drivers/staging/rtl8712/little_endian.h b/drivers/staging/rtl8712/little_endian.h
new file mode 100644
index 0000000..cd57d6c
--- /dev/null
+++ b/drivers/staging/rtl8712/little_endian.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include "swab.h"
+
+#define __constant_htonl(x) ___constant_swab32((x))
+#define __constant_ntohl(x) ___constant_swab32((x))
+#define __constant_htons(x) ___constant_swab16((x))
+#define __constant_ntohs(x) ___constant_swab16((x))
+#define __constant_cpu_to_le64(x) ((__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_le32(x) ((__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_le16(x) ((__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(x))
+#define __constant_cpu_to_be64(x) ___constant_swab64((x))
+#define __constant_be64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_be32(x) ___constant_swab32((x))
+#define __constant_be32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_be16(x) ___constant_swab16((x))
+#define __constant_be16_to_cpu(x) ___constant_swab16((x))
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64 *)(x))
+#define __le64_to_cpup(x) (*(__u64 *)(x))
+#define __cpu_to_le32p(x) (*(__u32 *)(x))
+#define __le32_to_cpup(x) (*(__u32 *)(x))
+#define __cpu_to_le16p(x) (*(__u16 *)(x))
+#define __le16_to_cpup(x) (*(__u16 *)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+#include "generic.h"
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
+
diff --git a/drivers/staging/rtl8712/mlme_linux.c b/drivers/staging/rtl8712/mlme_linux.c
new file mode 100644
index 0000000..abf96c1
--- /dev/null
+++ b/drivers/staging/rtl8712/mlme_linux.c
@@ -0,0 +1,170 @@
+/******************************************************************************
+ * mlme_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _MLME_OSDEP_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mlme_osdep.h"
+
+static void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+
+	_r8712_sitesurvey_ctrl_handler(adapter);
+	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer,
+		   3000);
+}
+
+static void join_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_r8712_join_timeout_handler(adapter);
+}
+
+static void _scan_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	r8712_scan_timeout_handler(adapter);
+}
+
+static void dhcp_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_r8712_dhcp_timeout_handler(adapter);
+}
+
+static void wdg_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+
+	_r8712_wdg_timeout_handler(adapter);
+
+	_set_timer(&adapter->mlmepriv.wdg_timer, 2000);
+}
+
+void r8712_init_mlme_timer(struct _adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev,
+		    join_timeout_handler, (pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer),
+		    padapter->pnetdev, sitesurvey_ctrl_handler,
+		    (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev,
+		    _scan_timeout_handler, (pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->dhcp_timer), padapter->pnetdev,
+		    dhcp_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->wdg_timer), padapter->pnetdev,
+		    wdg_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+}
+
+void r8712_os_indicate_connect(struct _adapter *adapter)
+{
+	r8712_indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+}
+
+static struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
+void r8712_os_indicate_disconnect(struct _adapter *adapter)
+{
+	u8 backupPMKIDIndex = 0;
+	u8 backupTKIPCountermeasure = 0x00;
+
+	r8712_indicate_wx_disassoc_event(adapter);
+	netif_carrier_off(adapter->pnetdev);
+	if (adapter->securitypriv.AuthAlgrthm == 2) { /*/802.1x*/
+		/* We have to backup the PMK information for WiFi PMK Caching
+		 * test item. Backup the btkip_countermeasure information.
+		 * When the countermeasure is trigger, the driver have to
+		 * disconnect with AP for 60 seconds.
+		 */
+
+		memset(&backupPMKIDList[0], 0x00, sizeof(
+			struct RT_PMKID_LIST) *	NUM_PMKID_CACHE);
+		memcpy(&backupPMKIDList[0], &adapter->securitypriv.
+			PMKIDList[0], sizeof(struct RT_PMKID_LIST) *
+			NUM_PMKID_CACHE);
+		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = adapter->securitypriv.
+					   btkip_countermeasure;
+		memset((unsigned char *)&adapter->securitypriv, 0,
+			 sizeof(struct security_priv));
+		_init_timer(&(adapter->securitypriv.tkip_timer),
+			    adapter->pnetdev, r8712_use_tkipkey_handler,
+			    adapter);
+		/* Restore the PMK information to securitypriv structure
+		 * for the following connection. */
+		memcpy(&adapter->securitypriv.PMKIDList[0],
+			&backupPMKIDList[0],
+			sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		adapter->securitypriv.btkip_countermeasure =
+					 backupTKIPCountermeasure;
+	} else { /*reset values in securitypriv*/
+		struct security_priv *psec_priv = &adapter->securitypriv;
+
+		psec_priv->AuthAlgrthm = 0; /*open system*/
+		psec_priv->PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->PrivacyKeyIndex = 0;
+		psec_priv->XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->XGrpKeyid = 1;
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
+		psec_priv->wps_phase = false;
+	}
+}
+
+void r8712_report_sec_ie(struct _adapter *adapter, u8 authmode, u8 *sec_ie)
+{
+	uint len;
+	u8 *buff, *p, i;
+	union iwreq_data wrqu;
+
+	buff = NULL;
+	if (authmode == _WPA_IE_ID_) {
+		buff = _malloc(IW_CUSTOM_MAX);
+		if (buff == NULL)
+			return;
+		memset(buff, 0, IW_CUSTOM_MAX);
+		p = buff;
+		p += sprintf(p, "ASSOCINFO(ReqIEs=");
+		len = sec_ie[1] + 2;
+		len =  (len < IW_CUSTOM_MAX) ? len : IW_CUSTOM_MAX;
+		for (i = 0; i < len; i++)
+			p += sprintf(p, "%02x", sec_ie[i]);
+		p += sprintf(p, ")");
+		memset(&wrqu, 0, sizeof(wrqu));
+		wrqu.data.length = p-buff;
+		wrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ?
+				   wrqu.data.length : IW_CUSTOM_MAX;
+		wireless_send_event(adapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+		kfree(buff);
+	}
+}
diff --git a/drivers/staging/rtl8712/mlme_osdep.h b/drivers/staging/rtl8712/mlme_osdep.h
new file mode 100644
index 0000000..a20fe81
--- /dev/null
+++ b/drivers/staging/rtl8712/mlme_osdep.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+void r8712_init_mlme_timer(struct _adapter *padapter);
+void r8712_os_indicate_disconnect(struct _adapter *adapter);
+void r8712_os_indicate_connect(struct _adapter *adapter);
+void r8712_report_sec_ie(struct _adapter *adapter, u8 authmode, u8 *sec_ie);
+int r8712_recv_indicatepkts_in_order(struct _adapter *adapter,
+				struct recv_reorder_ctrl *precvreorder_ctrl,
+				int bforced);
+void r8712_indicate_wx_assoc_event(struct _adapter *padapter);
+void r8712_indicate_wx_disassoc_event(struct _adapter *padapter);
+
+#endif	/*_MLME_OSDEP_H_*/
+
diff --git a/drivers/staging/rtl8712/mp_custom_oid.h b/drivers/staging/rtl8712/mp_custom_oid.h
new file mode 100644
index 0000000..4051008
--- /dev/null
+++ b/drivers/staging/rtl8712/mp_custom_oid.h
@@ -0,0 +1,299 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+/* 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+ * 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+ * 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
+ *
+ * by Owen for Production Kit
+ * For Production Kit with Agilent Equipments
+ * in order to make our custom oids hopefully somewhat unique
+ * we will use 0xFF (indicating implementation specific OID)
+ *	 81(first byte of non zero Realtek unique identifier)
+ *	 80 (second byte of non zero Realtek unique identifier)
+ *	 XX (the custom OID number - providing 255 possible custom oids)
+ */
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST				0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS		0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE		0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER		0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS			0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS	0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS \
+							0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS	0xFF818586
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+#define OID_RT_GET_CONNECT_STATE			0xFF030001
+#define OID_RT_RESCAN					0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE				0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY			0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100
+#define OID_RT_PRO_READ_REGISTER			0xFF871101
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103
+#define OID_RT_PRO_BURST_WRITE_REGISTER			0xFF871104
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D
+/*Method 2 for H2C/C2H*/
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E
+#define OID_RT_POLL_RX_STATUS				0xFF87111F
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122
+#define OID_RT_PRO_READ_TSSI				0xFF871123
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151
+/*Method 2 , using workitem */
+#define OID_RT_SET_READ_REG				0xFF871181
+#define OID_RT_SET_WRITE_REG				0xFF871182
+#define OID_RT_SET_BURST_READ_REG			0xFF871183
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185
+#define OID_RT_SET_READ16_EEPROM			0xFF871186
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188
+
+/*For SDIO INTERFACE only*/
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0
+#define OID_RT_PRO_871X_DRV_EXT				0xFF8711A1
+
+/*For USB INTERFACE only*/
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201
+#define OID_RT_PRO_DELE_STA_INFO			0xFF871202
+#define OID_RT_PRO_QUERY_DR_VARIABLE			0xFF871203
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A
+
+#define OID_RT_SET_RX_PACKET_TYPE			0xFF87120B
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214
+
+#define OID_RT_GET_POWER_MODE				0xFF871215
+
+#define OID_RT_PRO_EFUSE				0xFF871216
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217
+
+#endif /*#ifndef __CUSTOM_OID_H */
+
diff --git a/drivers/staging/rtl8712/os_intfs.c b/drivers/staging/rtl8712/os_intfs.c
new file mode 100644
index 0000000..4bb2797
--- /dev/null
+++ b/drivers/staging/rtl8712/os_intfs.c
@@ -0,0 +1,482 @@
+/******************************************************************************
+ * os_intfs.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _OS_INTFS_C_
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/firmware.h>
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "xmit_osdep.h"
+#include "recv_osdep.h"
+#include "rtl871x_ioctl.h"
+#include "usb_osintf.h"
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("rtl871x wireless lan driver");
+MODULE_AUTHOR("Larry Finger");
+
+static char ifname[IFNAMSIZ] = "wlan%d";
+
+/* module param defaults */
+static int chip_version = RTL8712_2ndCUT;
+static int rfintfs = HWPI;
+static int lbkmode = RTL8712_AIR_TRX;
+static int hci = RTL8712_USB;
+static int ampdu_enable = 1;/*for enable tx_ampdu*/
+
+/* The video_mode variable is for vedio mode.*/
+/* It may be specify when inserting module with video_mode=1 parameter.*/
+static int video_mode = 1;   /* enable video mode*/
+
+/*Ndis802_11Infrastructure; infra, ad-hoc, auto*/
+static int network_mode = Ndis802_11IBSS;
+static int channel = 1;/*ad-hoc support requirement*/
+static int wireless_mode = WIRELESS_11BG;
+static int vrtl_carrier_sense = AUTO_VCS;
+static int vcs_type = RTS_CTS;
+static int frag_thresh = 2346;
+static int preamble = PREAMBLE_LONG;/*long, short, auto*/
+static int scan_mode = 1;/*active, passive*/
+static int adhoc_tx_pwr = 1;
+static int soft_ap;
+static int smart_ps = 1;
+static int power_mgnt = PS_MODE_ACTIVE;
+static int radio_enable = 1;
+static int long_retry_lmt = 7;
+static int short_retry_lmt = 7;
+static int busy_thresh = 40;
+static int ack_policy = NORMAL_ACK;
+static int mp_mode;
+static int software_encrypt;
+static int software_decrypt;
+
+static int wmm_enable;/* default is set to disable the wmm.*/
+static int uapsd_enable;
+static int uapsd_max_sp = NO_LIMIT;
+static int uapsd_acbk_en;
+static int uapsd_acbe_en;
+static int uapsd_acvi_en;
+static int uapsd_acvo_en;
+
+static int ht_enable = 1;
+static int cbw40_enable = 1;
+static int rf_config = RTL8712_RF_1T2R;  /* 1T2R*/
+static int low_power;
+/* mac address to use instead of the one stored in Efuse */
+char *r8712_initmac;
+static char *initmac;
+/* if wifi_test = 1, driver will disable the turbo mode and pass it to
+ * firmware private.
+ */
+static int wifi_test = 0;
+
+module_param_string(ifname, ifname, sizeof(ifname), S_IRUGO|S_IWUSR);
+module_param(wifi_test, int, 0644);
+module_param(initmac, charp, 0644);
+module_param(video_mode, int, 0644);
+module_param(chip_version, int, 0644);
+module_param(rfintfs, int, 0644);
+module_param(lbkmode, int, 0644);
+module_param(hci, int, 0644);
+module_param(network_mode, int, 0644);
+module_param(channel, int, 0644);
+module_param(mp_mode, int, 0644);
+module_param(wmm_enable, int, 0644);
+module_param(vrtl_carrier_sense, int, 0644);
+module_param(vcs_type, int, 0644);
+module_param(busy_thresh, int, 0644);
+module_param(ht_enable, int, 0644);
+module_param(cbw40_enable, int, 0644);
+module_param(ampdu_enable, int, 0644);
+module_param(rf_config, int, 0644);
+module_param(power_mgnt, int, 0644);
+module_param(low_power, int, 0644);
+
+MODULE_PARM_DESC(ifname, " Net interface name, wlan%d=default");
+MODULE_PARM_DESC(initmac, "MAC-Address, default: use FUSE");
+
+static uint loadparam(struct _adapter *padapter, struct  net_device *pnetdev);
+static int netdev_open(struct net_device *pnetdev);
+static int netdev_close(struct net_device *pnetdev);
+
+static uint loadparam(struct _adapter *padapter, struct  net_device *pnetdev)
+{
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+	registry_par->chip_version = (u8)chip_version;
+	registry_par->rfintfs = (u8)rfintfs;
+	registry_par->lbkmode = (u8)lbkmode;
+	registry_par->hci = (u8)hci;
+	registry_par->network_mode  = (u8)network_mode;
+	memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+	registry_par->channel = (u8)channel;
+	registry_par->wireless_mode = (u8)wireless_mode;
+	registry_par->vrtl_carrier_sense = (u8)vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)vcs_type;
+	registry_par->frag_thresh = (u16)frag_thresh;
+	registry_par->preamble = (u8)preamble;
+	registry_par->scan_mode = (u8)scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)adhoc_tx_pwr;
+	registry_par->soft_ap = (u8)soft_ap;
+	registry_par->smart_ps = (u8)smart_ps;
+	registry_par->power_mgnt = (u8)power_mgnt;
+	registry_par->radio_enable = (u8)radio_enable;
+	registry_par->long_retry_lmt = (u8)long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)short_retry_lmt;
+	registry_par->busy_thresh = (u16)busy_thresh;
+	registry_par->ack_policy = (u8)ack_policy;
+	registry_par->mp_mode = (u8)mp_mode;
+	registry_par->software_encrypt = (u8)software_encrypt;
+	registry_par->software_decrypt = (u8)software_decrypt;
+	/*UAPSD*/
+	registry_par->wmm_enable = (u8)wmm_enable;
+	registry_par->uapsd_enable = (u8)uapsd_enable;
+	registry_par->uapsd_max_sp = (u8)uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)uapsd_acvo_en;
+	registry_par->ht_enable = (u8)ht_enable;
+	registry_par->cbw40_enable = (u8)cbw40_enable;
+	registry_par->ampdu_enable = (u8)ampdu_enable;
+	registry_par->rf_config = (u8)rf_config;
+	registry_par->low_power = (u8)low_power;
+	registry_par->wifi_test = (u8) wifi_test;
+	r8712_initmac = initmac;
+	return status;
+}
+
+static int r871x_net_set_mac_address(struct net_device *pnetdev, void *p)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+	struct sockaddr *addr = p;
+
+	if (padapter->bup == false)
+		memcpy(pnetdev->dev_addr, addr->sa_data, ETH_ALEN);
+	return 0;
+}
+
+static struct net_device_stats *r871x_net_get_stats(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;
+	padapter->stats.rx_packets = precvpriv->rx_pkts;
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+	return &padapter->stats;
+}
+
+static const struct net_device_ops rtl8712_netdev_ops = {
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_close,
+	.ndo_start_xmit = r8712_xmit_entry,
+	.ndo_set_mac_address = r871x_net_set_mac_address,
+	.ndo_get_stats = r871x_net_get_stats,
+	.ndo_do_ioctl = r871x_ioctl,
+};
+
+struct net_device *r8712_init_netdev(void)
+{
+	struct _adapter *padapter;
+	struct net_device *pnetdev;
+
+	pnetdev = alloc_etherdev(sizeof(struct _adapter));
+	if (!pnetdev)
+		return NULL;
+	if (dev_alloc_name(pnetdev, ifname) < 0) {
+		strcpy(ifname, "wlan%d");
+		dev_alloc_name(pnetdev, ifname);
+	}
+	padapter = (struct _adapter *) netdev_priv(pnetdev);
+	padapter->pnetdev = pnetdev;
+	printk(KERN_INFO "r8712u: register rtl8712_netdev_ops to"
+	       " netdev_ops\n");
+	pnetdev->netdev_ops = &rtl8712_netdev_ops;
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
+	pnetdev->wireless_handlers = (struct iw_handler_def *)
+				     &r871x_handlers_def;
+	/*step 2.*/
+	loadparam(padapter, pnetdev);
+	netif_carrier_off(pnetdev);
+	padapter->pid = 0;  /* Initial the PID value used for HW PBC.*/
+	return pnetdev;
+}
+
+static u32 start_drv_threads(struct _adapter *padapter)
+{
+	padapter->cmdThread = kthread_run(r8712_cmd_thread, padapter,
+			      padapter->pnetdev->name);
+	if (IS_ERR(padapter->cmdThread) < 0)
+		return _FAIL;
+	return _SUCCESS;
+}
+
+void r8712_stop_drv_threads(struct _adapter *padapter)
+{
+	/*Below is to termindate r8712_cmd_thread & event_thread...*/
+	up(&padapter->cmdpriv.cmd_queue_sema);
+	if (padapter->cmdThread)
+		_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
+	padapter->cmdpriv.cmd_seq = 1;
+}
+
+static void start_drv_timers(struct _adapter *padapter)
+{
+	_set_timer(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer,
+		   5000);
+	_set_timer(&padapter->mlmepriv.wdg_timer, 2000);
+}
+
+void r8712_stop_drv_timers(struct _adapter *padapter)
+{
+	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
+	_cancel_timer_ex(&padapter->securitypriv.tkip_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.dhcp_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.wdg_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.sitesurveyctrl.
+			 sitesurvey_ctrl_timer);
+}
+
+static u8 init_default_value(struct _adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	/*xmit_priv*/
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+	/* mlme_priv */
+	/* Maybe someday we should rename this variable to "active_mode"(Jeff)*/
+	pmlmepriv->passive_mode = 1; /* 1: active, 0: passive. */
+	/*ht_priv*/
+	{
+		int i;
+		struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+
+		phtpriv->ampdu_enable = false;/*set to disabled*/
+		for (i = 0; i < 16; i++)
+			phtpriv->baddbareq_issued[i] = false;
+	}
+	/*security_priv*/
+	psecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;
+	psecuritypriv->binstallGrpkey = _FAIL;
+	/*pwrctrl_priv*/
+	/*registry_priv*/
+	r8712_init_registrypriv_dev_network(padapter);
+	r8712_update_registrypriv_dev_network(padapter);
+	/*misc.*/
+	return ret;
+}
+
+u8 r8712_init_drv_sw(struct _adapter *padapter)
+{
+	if ((r8712_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+		return _FAIL;
+	padapter->cmdpriv.padapter = padapter;
+	if ((r8712_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+		return _FAIL;
+	if (r8712_init_mlme_priv(padapter) == _FAIL)
+		return _FAIL;
+	_r8712_init_xmit_priv(&padapter->xmitpriv, padapter);
+	_r8712_init_recv_priv(&padapter->recvpriv, padapter);
+	memset((unsigned char *)&padapter->securitypriv, 0,
+	       sizeof(struct security_priv));
+	_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pnetdev,
+		    r8712_use_tkipkey_handler, padapter);
+	_r8712_init_sta_priv(&padapter->stapriv);
+	padapter->stapriv.padapter = padapter;
+	r8712_init_bcmc_stainfo(padapter);
+	r8712_init_pwrctrl_priv(padapter);
+	sema_init(&(padapter->pwrctrlpriv.pnp_pwr_mgnt_sema), 0);
+	mp871xinit(padapter);
+	if (init_default_value(padapter) != _SUCCESS)
+		return _FAIL;
+	r8712_InitSwLeds(padapter);
+	return _SUCCESS;
+}
+
+u8 r8712_free_drv_sw(struct _adapter *padapter)
+{
+	struct net_device *pnetdev = (struct net_device *)padapter->pnetdev;
+
+	r8712_free_cmd_priv(&padapter->cmdpriv);
+	r8712_free_evt_priv(&padapter->evtpriv);
+	r8712_DeInitSwLeds(padapter);
+	r8712_free_mlme_priv(&padapter->mlmepriv);
+	r8712_free_io_queue(padapter);
+	_free_xmit_priv(&padapter->xmitpriv);
+	if (padapter->fw_found)
+		_r8712_free_sta_priv(&padapter->stapriv);
+	_r8712_free_recv_priv(&padapter->recvpriv);
+	mp871xdeinit(padapter);
+	if (pnetdev)
+		free_netdev(pnetdev);
+	return _SUCCESS;
+}
+
+
+static void enable_video_mode(struct _adapter *padapter, int cbw40_value)
+{
+	/*   bit 8:
+	 *   1 -> enable video mode to 96B AP
+	 *   0 -> disable video mode to 96B AP
+	 *   bit 9:
+	 *   1 -> enable 40MHz mode
+	 *   0 -> disable 40MHz mode
+	 *   bit 10:
+	 *   1 -> enable STBC
+	 *   0 -> disable STBC
+	 */
+	u32  intcmd = 0xf4000500;   /* enable bit8, bit10*/
+
+	if (cbw40_value) {
+		/* if the driver supports the 40M bandwidth,
+		 * we can enable the bit 9.*/
+		intcmd |= 0x200;
+	}
+	r8712_fw_cmd(padapter, intcmd);
+}
+
+/**
+ *
+ * This function intends to handle the activation of an interface
+ * i.e. when it is brought Up/Active from a Down state.
+ *
+ */
+static int netdev_open(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+
+	mutex_lock(&padapter->mutex_start);
+	if (padapter->bup == false) {
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bup = true;
+		if (rtl871x_hal_init(padapter) != _SUCCESS)
+			goto netdev_open_error;
+		if (r8712_initmac == NULL)
+			/* Use the mac address stored in the Efuse */
+			memcpy(pnetdev->dev_addr,
+				padapter->eeprompriv.mac_addr, ETH_ALEN);
+		else {
+			/* We have to inform f/w to use user-supplied MAC
+			 * address.
+			 */
+			msleep(200);
+			r8712_setMacAddr_cmd(padapter, (u8 *)pnetdev->dev_addr);
+			/*
+			 * The "myid" function will get the wifi mac address
+			 * from eeprompriv structure instead of netdev
+			 * structure. So, we have to overwrite the mac_addr
+			 * stored in the eeprompriv structure. In this case,
+			 * the real mac address won't be used anymore. So that,
+			 * the eeprompriv.mac_addr should store the mac which
+			 * users specify.
+			 */
+			memcpy(padapter->eeprompriv.mac_addr,
+				pnetdev->dev_addr, ETH_ALEN);
+		}
+		if (start_drv_threads(padapter) != _SUCCESS)
+			goto netdev_open_error;
+		if (padapter->dvobjpriv.inirp_init == NULL)
+			goto netdev_open_error;
+		else
+			padapter->dvobjpriv.inirp_init(padapter);
+		r8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,
+				  padapter->registrypriv.smart_ps);
+	}
+	if (!netif_queue_stopped(pnetdev))
+		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+
+	 if (video_mode)
+		enable_video_mode(padapter, cbw40_enable);
+	/* start driver mlme relation timer */
+	start_drv_timers(padapter);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+	mutex_unlock(&padapter->mutex_start);
+	return 0;
+netdev_open_error:
+	padapter->bup = false;
+	netif_carrier_off(pnetdev);
+	netif_stop_queue(pnetdev);
+	mutex_unlock(&padapter->mutex_start);
+	return -1;
+}
+
+/**
+ *
+ * This function intends to handle the shutdown of an interface
+ * i.e. when it is brought Down from an Up/Active state.
+ *
+ */
+static int netdev_close(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(pnetdev);
+
+	/* Close LED*/
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_POWER_OFF);
+	msleep(200);
+
+	/*s1.*/
+	if (pnetdev) {
+		if (!netif_queue_stopped(pnetdev))
+			netif_stop_queue(pnetdev);
+	}
+	/*s2.*/
+	/*s2-1.  issue disassoc_cmd to fw*/
+	r8712_disassoc_cmd(padapter);
+	/*s2-2.  indicate disconnect to os*/
+	r8712_ind_disconnect(padapter);
+	/*s2-3.*/
+	r8712_free_assoc_resources(padapter);
+	/*s2-4.*/
+	r8712_free_network_queue(padapter);
+	return 0;
+}
+
+#include "mlme_osdep.h"
diff --git a/drivers/staging/rtl8712/osdep_intf.h b/drivers/staging/rtl8712/osdep_intf.h
new file mode 100644
index 0000000..aa0ec74
--- /dev/null
+++ b/drivers/staging/rtl8712/osdep_intf.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0 : 1)) << 2)
+
+struct intf_priv {
+	u8 *intf_dev;
+	/* when in USB, IO is through interrupt in/out endpoints */
+	struct usb_device *udev;
+	struct urb *piorw_urb;
+	struct semaphore io_retevt;
+};
+
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+#endif	/*_OSDEP_INTF_H_*/
diff --git a/drivers/staging/rtl8712/osdep_service.h b/drivers/staging/rtl8712/osdep_service.h
new file mode 100644
index 0000000..1ee943a
--- /dev/null
+++ b/drivers/staging/rtl8712/osdep_service.h
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#define _SUCCESS	1
+#define _FAIL		0
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/sem.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <linux/proc_fs.h>      /* Necessary because we use the proc fs */
+
+#include "basic_types.h"
+
+struct	__queue	{
+	struct	list_head	queue;
+	spinlock_t lock;
+};
+
+#define _pkt struct sk_buff
+#define _buffer unsigned char
+#define thread_exit() complete_and_exit(NULL, 0)
+#define _workitem struct work_struct
+
+#define _init_queue(pqueue)				\
+	do {						\
+		_init_listhead(&((pqueue)->queue));	\
+		spin_lock_init(&((pqueue)->lock));	\
+	} while (0)
+
+static inline struct list_head *get_next(struct list_head *list)
+{
+	return list->next;
+}
+
+static inline struct list_head *get_list_head(struct  __queue *queue)
+{
+	return &(queue->queue);
+}
+
+#define LIST_CONTAINOR(ptr, type, member) \
+	((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+
+static inline void _enter_hwio_critical(struct semaphore *prwlock,
+					unsigned long *pirqL)
+{
+	down(prwlock);
+}
+
+static inline void _exit_hwio_critical(struct semaphore *prwlock,
+				       unsigned long *pirqL)
+{
+	up(prwlock);
+}
+
+static inline void list_delete(struct list_head *plist)
+{
+	list_del_init(plist);
+}
+
+static inline void _init_timer(struct timer_list *ptimer,
+			       struct  net_device *padapter,
+			       void *pfunc, void *cntx)
+{
+	ptimer->function = pfunc;
+	ptimer->data = (addr_t)cntx;
+	init_timer(ptimer);
+}
+
+static inline void _set_timer(struct timer_list *ptimer, u32 delay_time)
+{
+	mod_timer(ptimer, (jiffies+(delay_time*HZ/1000)));
+}
+
+static inline void _cancel_timer(struct timer_list *ptimer, u8 *bcancelled)
+{
+	del_timer(ptimer);
+	*bcancelled = true; /*true ==1; false==0*/
+}
+
+static inline void _init_workitem(_workitem *pwork, void *pfunc, void *cntx)
+{
+	INIT_WORK(pwork, pfunc);
+}
+
+static inline void _set_workitem(_workitem *pwork)
+{
+	schedule_work(pwork);
+}
+
+#include "rtl871x_byteorder.h"
+
+#ifndef BIT
+	#define BIT(x)	(1 << (x))
+#endif
+
+/*
+For the following list_xxx operations,
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+static inline u32 is_list_empty(struct list_head *phead)
+{
+	if (list_empty(phead))
+		return true;
+	else
+		return false;
+}
+
+static inline void list_insert_tail(struct list_head *plist,
+				    struct list_head *phead)
+{
+	list_add_tail(plist, phead);
+}
+
+static inline u32 _down_sema(struct semaphore *sema)
+{
+	if (down_interruptible(sema))
+		return _FAIL;
+	else
+		return _SUCCESS;
+}
+
+static inline void _rtl_rwlock_init(struct semaphore *prwlock)
+{
+	sema_init(prwlock, 1);
+}
+
+static inline void _init_listhead(struct list_head *list)
+{
+	INIT_LIST_HEAD(list);
+}
+
+static inline u32 _queue_empty(struct  __queue *pqueue)
+{
+	return is_list_empty(&(pqueue->queue));
+}
+
+static inline u32 end_of_queue_search(struct list_head *head, struct list_head *plist)
+{
+	if (head == plist)
+		return true;
+	else
+		return false;
+}
+
+static inline void sleep_schedulable(int ms)
+{
+	u32 delta;
+
+	delta = (ms * HZ) / 1000;/*(ms)*/
+	if (delta == 0)
+		delta = 1;/* 1 ms */
+	set_current_state(TASK_INTERRUPTIBLE);
+	if (schedule_timeout(delta) != 0)
+		return ;
+}
+
+static inline u8 *_malloc(u32 sz)
+{
+	return	kmalloc(sz, GFP_ATOMIC);
+}
+
+static inline unsigned char _cancel_timer_ex(struct timer_list *ptimer)
+{
+	return del_timer(ptimer);
+}
+
+static inline void thread_enter(void *context)
+{
+	allow_signal(SIGTERM);
+}
+
+static inline void flush_signals_thread(void)
+{
+	if (signal_pending(current))
+		flush_signals(current);
+}
+
+static inline u32 _RND8(u32 sz)
+{
+	return ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;
+}
+
+static inline u32 _RND128(u32 sz)
+{
+	return ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;
+}
+
+static inline u32 _RND256(u32 sz)
+{
+	return ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;
+}
+
+static inline u32 _RND512(u32 sz)
+{
+	return ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;
+}
+
+#endif
+
diff --git a/drivers/staging/rtl8712/recv_linux.c b/drivers/staging/rtl8712/recv_linux.c
new file mode 100644
index 0000000..0e26d5f
--- /dev/null
+++ b/drivers/staging/rtl8712/recv_linux.c
@@ -0,0 +1,173 @@
+/******************************************************************************
+ * recv_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RECV_OSDEP_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include "recv_osdep.h"
+#include "osdep_intf.h"
+#include "ethernet.h"
+#include <linux/if_arp.h>
+#include "usb_ops.h"
+
+/*init os related resource in struct recv_priv*/
+/*alloc os related resource in union recv_frame*/
+int r8712_os_recv_resource_alloc(struct _adapter *padapter,
+				 union recv_frame *precvframe)
+{
+	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
+	return _SUCCESS;
+}
+
+/*alloc os related resource in struct recv_buf*/
+int r8712_os_recvbuf_resource_alloc(struct _adapter *padapter,
+				    struct recv_buf *precvbuf)
+{
+	int res = _SUCCESS;
+
+	precvbuf->irp_pending = false;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if (precvbuf->purb == NULL)
+		res = _FAIL;
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = false;
+	precvbuf->pallocated_buf = NULL;
+	precvbuf->pbuf = NULL;
+	precvbuf->pdata = NULL;
+	precvbuf->phead = NULL;
+	precvbuf->ptail = NULL;
+	precvbuf->pend = NULL;
+	precvbuf->transfer_len = 0;
+	precvbuf->len = 0;
+	return res;
+}
+
+/*free os related resource in struct recv_buf*/
+int r8712_os_recvbuf_resource_free(struct _adapter *padapter,
+			     struct recv_buf *precvbuf)
+{
+	if (precvbuf->pskb)
+		dev_kfree_skb_any(precvbuf->pskb);
+	if (precvbuf->purb) {
+		usb_kill_urb(precvbuf->purb);
+		usb_free_urb(precvbuf->purb);
+	}
+	return _SUCCESS;
+}
+
+void r8712_handle_tkip_mic_err(struct _adapter *padapter, u8 bgroup)
+{
+	union iwreq_data wrqu;
+	struct iw_michaelmicfailure ev;
+	struct mlme_priv *pmlmepriv  = &padapter->mlmepriv;
+
+	memset(&ev, 0x00, sizeof(ev));
+	if (bgroup)
+		ev.flags |= IW_MICFAILURE_GROUP;
+	else
+		ev.flags |= IW_MICFAILURE_PAIRWISE;
+	ev.src_addr.sa_family = ARPHRD_ETHER;
+	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
+	memset(&wrqu, 0x00, sizeof(wrqu));
+	wrqu.data.length = sizeof(ev);
+	wireless_send_event(padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu,
+			    (char *)&ev);
+}
+
+void r8712_recv_indicatepkt(struct _adapter *padapter,
+			    union recv_frame *precv_frame)
+{
+	struct recv_priv *precvpriv;
+	struct  __queue	*pfree_recv_queue;
+	_pkt *skb;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	skb = precv_frame->u.hdr.pkt;
+	if (skb == NULL)
+		goto _recv_indicatepkt_drop;
+	skb->data = precv_frame->u.hdr.rx_data;
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+	skb->tail = (sk_buff_data_t)(precv_frame->u.hdr.rx_tail -
+		     precv_frame->u.hdr.rx_head);
+#else
+	skb->tail = (sk_buff_data_t)precv_frame->u.hdr.rx_tail;
+#endif
+	skb->len = precv_frame->u.hdr.len;
+	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	else
+		skb->ip_summed = CHECKSUM_NONE;
+	skb->dev = padapter->pnetdev;
+	skb->protocol = eth_type_trans(skb, padapter->pnetdev);
+	netif_rx(skb);
+	precv_frame->u.hdr.pkt = NULL; /* pointers to NULL before
+					* r8712_free_recvframe() */
+	r8712_free_recvframe(precv_frame, pfree_recv_queue);
+	return;
+_recv_indicatepkt_drop:
+	 /*enqueue back to free_recv_queue*/
+	 if (precv_frame)
+		r8712_free_recvframe(precv_frame, pfree_recv_queue);
+	 precvpriv->rx_drop++;
+}
+
+void r8712_os_read_port(struct _adapter *padapter, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	precvbuf->ref_cnt--;
+	/*free skb in recv_buf*/
+	dev_kfree_skb_any(precvbuf->pskb);
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = false;
+	if (precvbuf->irp_pending == false)
+		r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+			 (unsigned char *)precvbuf);
+}
+
+static void _r8712_reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl =
+			 (struct recv_reorder_ctrl *)FunctionContext;
+
+	r8712_reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	struct _adapter *padapter = preorder_ctrl->padapter;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev,
+		    _r8712_reordering_ctrl_timeout_handler, preorder_ctrl);
+}
diff --git a/drivers/staging/rtl8712/recv_osdep.h b/drivers/staging/rtl8712/recv_osdep.h
new file mode 100644
index 0000000..f4384ef
--- /dev/null
+++ b/drivers/staging/rtl8712/recv_osdep.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include <linux/skbuff.h>
+
+sint _r8712_init_recv_priv(struct recv_priv *precvpriv,
+			   struct _adapter *padapter);
+void _r8712_free_recv_priv(struct recv_priv *precvpriv);
+s32  r8712_recv_entry(union recv_frame *precv_frame);
+void r8712_recv_indicatepkt(struct _adapter *adapter,
+			    union recv_frame *precv_frame);
+void r8712_handle_tkip_mic_err(struct _adapter *padapter, u8 bgroup);
+int r8712_init_recv_priv(struct recv_priv *precvpriv,
+			 struct _adapter *padapter);
+void r8712_free_recv_priv(struct recv_priv *precvpriv);
+int r8712_os_recv_resource_alloc(struct _adapter *padapter,
+				 union recv_frame *precvframe);
+int r8712_os_recvbuf_resource_alloc(struct _adapter *padapter,
+				    struct recv_buf *precvbuf);
+int r8712_os_recvbuf_resource_free(struct _adapter *padapter,
+				   struct recv_buf *precvbuf);
+void r8712_os_read_port(struct _adapter *padapter, struct recv_buf *precvbuf);
+void r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl8712_bitdef.h b/drivers/staging/rtl8712/rtl8712_bitdef.h
new file mode 100644
index 0000000..bff57a8
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_bitdef.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __RTL8712_BITDEF_H__
+#define __RTL8712_BITDEF_H__
+
+#include "rtl8712_cmdctrl_bitdef.h"
+#include "rtl8712_syscfg_bitdef.h"
+#include "rtl8712_macsetting_bitdef.h"
+#include "rtl8712_timectrl_bitdef.h"
+#include "rtl8712_fifoctrl_bitdef.h"
+#include "rtl8712_ratectrl_bitdef.h"
+#include "rtl8712_edcasetting_bitdef.h"
+#include "rtl8712_wmac_bitdef.h"
+#include "rtl8712_security_bitdef.h"
+#include "rtl8712_powersave_bitdef.h"
+#include "rtl8712_gp_bitdef.h"
+#include "rtl8712_interrupt_bitdef.h"
+#include "rtl8712_debugctrl_bitdef.h"
+
+#endif /* __RTL8712_BITDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_cmd.c b/drivers/staging/rtl8712/rtl8712_cmd.c
new file mode 100644
index 0000000..a9d4c9b
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_cmd.c
@@ -0,0 +1,483 @@
+/******************************************************************************
+ * rtl8712_cmd.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_CMD_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/rtnetlink.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "rtl871x_byteorder.h"
+#include "rtl871x_ioctl_set.h"
+
+static void check_hw_pbc(struct _adapter *padapter)
+{
+	u8	tmp1byte;
+
+	r8712_write8(padapter, MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));
+	tmp1byte = r8712_read8(padapter, GPIO_IO_SEL);
+	tmp1byte &= ~(HAL_8192S_HW_GPIO_WPS_BIT);
+	r8712_write8(padapter, GPIO_IO_SEL, tmp1byte);
+	tmp1byte = r8712_read8(padapter, GPIO_CTRL);
+	if (tmp1byte == 0xff)
+		return ;
+	if (tmp1byte&HAL_8192S_HW_GPIO_WPS_BIT) {
+		/* Here we only set bPbcPressed to true
+		 * After trigger PBC, the variable will be set to false */
+		DBG_8712("CheckPbcGPIO - PBC is pressed !!!!\n");
+		/* 0 is the default value and it means the application monitors
+		 * the HW PBC doesn't privde its pid to driver. */
+		if (padapter->pid == 0)
+			return;
+		kill_pid(find_vpid(padapter->pid), SIGUSR1, 1);
+	}
+}
+
+/* query rx phy status from fw.
+ * Adhoc mode: beacon.
+ * Infrastructure mode: beacon , data. */
+static void query_fw_rx_phy_status(struct _adapter *padapter)
+{
+	u32 val32 = 0;
+	int pollingcnts = 50;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == true) {
+		r8712_write32(padapter, IOCMD_CTRL_REG, 0xf4000001);
+		msleep(100);
+		/* Wait FW complete IO Cmd */
+		while ((r8712_read32(padapter, IOCMD_CTRL_REG)) &&
+		       (pollingcnts > 0)) {
+			pollingcnts--;
+			msleep(20);
+		}
+		if (pollingcnts != 0)
+			val32 = r8712_read32(padapter, IOCMD_DATA_REG);
+		else /* time out */
+			val32 = 0;
+		val32 = val32 >> 4;
+		padapter->recvpriv.fw_rssi =
+			 (u8)r8712_signal_scale_mapping(val32);
+	}
+}
+
+/* check mlme, hw, phy, or dynamic algorithm status. */
+static void StatusWatchdogCallback(struct _adapter *padapter)
+{
+	check_hw_pbc(padapter);
+	query_fw_rx_phy_status(padapter);
+}
+
+static void r871x_internal_cmd_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	struct drvint_cmd_parm *pdrvcmd;
+
+	if (!pbuf)
+		return;
+	pdrvcmd = (struct drvint_cmd_parm *)pbuf;
+	switch (pdrvcmd->i_cid) {
+	case WDG_WK_CID:
+		StatusWatchdogCallback(padapter);
+		break;
+	default:
+		break;
+	}
+	kfree(pdrvcmd->pbuf);
+}
+
+static u8 read_macreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	/*  invoke cmd->callback function */
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_macreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	/*  invoke cmd->callback function */
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 read_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct readBB_parm *prdbbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	prdbbparm = (struct readBB_parm *)pcmd->parmbuf;
+	if (pcmd->rsp && pcmd->rspsz > 0)
+		memcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct writeBB_parm *pwritebbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	pwritebbparm = (struct writeBB_parm *)pcmd->parmbuf;
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 read_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct readRF_parm *prdrfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	prdrfparm = (struct readRF_parm *)pcmd->parmbuf;
+	if (pcmd->rsp && pcmd->rspsz > 0)
+		memcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	pwriterfparm = (struct writeRF_parm *)pcmd->parmbuf;
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 sys_suspend_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	struct usb_suspend_parm *psetusbsuspend;
+
+	psetusbsuspend = (struct usb_suspend_parm *)pcmd->parmbuf;
+	r8712_free_cmd_obj(pcmd);
+	return H2C_SUCCESS;
+}
+
+static struct cmd_obj *cmd_hdl_filter(struct _adapter *padapter,
+				      struct cmd_obj *pcmd)
+{
+	struct cmd_obj *pcmd_r;
+
+	if (pcmd == NULL)
+		return pcmd;
+	pcmd_r = NULL;
+
+	switch (pcmd->cmdcode) {
+	case GEN_CMD_CODE(_Read_MACREG):
+		read_macreg_hdl(padapter, (u8 *)pcmd);
+		pcmd_r = pcmd;
+		break;
+	case GEN_CMD_CODE(_Write_MACREG):
+		write_macreg_hdl(padapter, (u8 *)pcmd);
+		pcmd_r = pcmd;
+		break;
+	case GEN_CMD_CODE(_Read_BBREG):
+		read_bbreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Write_BBREG):
+		write_bbreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Read_RFREG):
+		read_rfreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Write_RFREG):
+		write_rfreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_SetUsbSuspend):
+		sys_suspend_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_JoinBss):
+		r8712_joinbss_reset(padapter);
+		/* Before set JoinBss_CMD to FW, driver must ensure FW is in
+		 * PS_MODE_ACTIVE. Directly write rpwm to radio on and assign
+		 * new pwr_mode to Driver, instead of use workitem to change
+		 * state. */
+		if (padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE) {
+			padapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;
+			_enter_pwrlock(&(padapter->pwrctrlpriv.lock));
+			r8712_set_rpwm(padapter, PS_STATE_S4);
+			up(&(padapter->pwrctrlpriv.lock));
+		}
+		pcmd_r = pcmd;
+		break;
+	case _DRV_INT_CMD_:
+		r871x_internal_cmd_hdl(padapter, pcmd->parmbuf);
+		r8712_free_cmd_obj(pcmd);
+		pcmd_r = NULL;
+		break;
+	default:
+		pcmd_r = pcmd;
+		break;
+	}
+	return pcmd_r; /* if returning pcmd_r == NULL, pcmd must be free. */
+}
+
+static u8 check_cmd_fifo(struct _adapter *padapter, uint sz)
+{
+	u8 res = _SUCCESS;
+	return res;
+}
+
+u8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd)
+{
+	int pollingcnts = 50;
+
+	r8712_write32(pAdapter, IOCMD_CTRL_REG, cmd);
+	msleep(100);
+	while ((0 != r8712_read32(pAdapter, IOCMD_CTRL_REG)) &&
+	       (pollingcnts > 0)) {
+		pollingcnts--;
+		msleep(20);
+	}
+	if (pollingcnts == 0)
+		return false;
+	return true;
+}
+
+void r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag)
+{
+	if (flag == 0)	/* set */
+		r8712_write32(pAdapter, IOCMD_DATA_REG, *value);
+	else		/* query */
+		*value = r8712_read32(pAdapter, IOCMD_DATA_REG);
+}
+
+int r8712_cmd_thread(void *context)
+{
+	struct cmd_obj *pcmd;
+	unsigned int cmdsz, wr_sz, *pcmdbuf, *prspbuf;
+	struct tx_desc *pdesc;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct _adapter *padapter = (struct _adapter *)context;
+	struct	cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+
+	thread_enter(padapter);
+	while (1) {
+		if ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+			break;
+		if ((padapter->bDriverStopped == true) ||
+		    (padapter->bSurpriseRemoved == true))
+			break;
+		if (r8712_register_cmd_alive(padapter) != _SUCCESS)
+			continue;
+_next:
+		pcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if (!(pcmd)) {
+			r8712_unregister_cmd_alive(padapter);
+			continue;
+		}
+		pcmdbuf = (unsigned int *)pcmdpriv->cmd_buf;
+		prspbuf = (unsigned int *)pcmdpriv->rsp_buf;
+		pdesc = (struct tx_desc *)pcmdbuf;
+		memset(pdesc, 0, TXDESC_SIZE);
+		pcmd = cmd_hdl_filter(padapter, pcmd);
+		if (pcmd) { /* if pcmd != NULL, cmd will be handled by f/w */
+			struct dvobj_priv *pdvobj = (struct dvobj_priv *)
+						    &padapter->dvobjpriv;
+			u8 blnPending = 0;
+			pcmdpriv->cmd_issued_cnt++;
+			cmdsz = _RND8((pcmd->cmdsz)); /* _RND8	*/
+			wr_sz = TXDESC_SIZE + 8 + cmdsz;
+			pdesc->txdw0 |= cpu_to_le32((wr_sz-TXDESC_SIZE) &
+						     0x0000ffff);
+			if (pdvobj->ishighspeed) {
+				if ((wr_sz % 512) == 0)
+					blnPending = 1;
+			} else {
+				if ((wr_sz % 64) == 0)
+					blnPending = 1;
+			}
+			if (blnPending) /* 32 bytes for TX Desc - 8 offset */
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +
+						OFFSET_SZ + 8) << OFFSET_SHT) &
+						0x00ff0000);
+			else {
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +
+							      OFFSET_SZ) <<
+							      OFFSET_SHT) &
+							      0x00ff0000);
+			}
+			pdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+			pdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) &
+						    0x00001f00);
+			pcmdbuf += (TXDESC_SIZE >> 2);
+			*pcmdbuf = cpu_to_le32((cmdsz & 0x0000ffff) |
+					       (pcmd->cmdcode << 16) |
+					       (pcmdpriv->cmd_seq << 24));
+			pcmdbuf += 2 ; /* 8 bytes aligment */
+			memcpy((u8 *)pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+			while (check_cmd_fifo(padapter, wr_sz) == _FAIL) {
+				if ((padapter->bDriverStopped == true) ||
+				    (padapter->bSurpriseRemoved == true))
+					break;
+				msleep(100);
+				continue;
+			}
+			if (blnPending)
+				wr_sz += 8;   /* Append 8 bytes */
+			r8712_write_mem(padapter, RTL8712_DMA_H2CCMD, wr_sz,
+				       (u8 *)pdesc);
+			pcmdpriv->cmd_seq++;
+			if (pcmd->cmdcode == GEN_CMD_CODE(_CreateBss)) {
+				pcmd->res = H2C_SUCCESS;
+				pcmd_callback = cmd_callback[pcmd->
+						cmdcode].callback;
+				if (pcmd_callback)
+					pcmd_callback(padapter, pcmd);
+				continue;
+			}
+			if (pcmd->cmdcode == GEN_CMD_CODE(_SetPwrMode)) {
+				if (padapter->pwrctrlpriv.bSleep) {
+					_enter_pwrlock(&(padapter->
+						       pwrctrlpriv.lock));
+					r8712_set_rpwm(padapter, PS_STATE_S2);
+					up(&padapter->pwrctrlpriv.lock);
+				}
+			}
+			r8712_free_cmd_obj(pcmd);
+			if (_queue_empty(&(pcmdpriv->cmd_queue))) {
+				r8712_unregister_cmd_alive(padapter);
+				continue;
+			} else
+				goto _next;
+		} else
+			goto _next;
+		flush_signals_thread();
+	}
+	/* free all cmd_obj resources */
+	do {
+		pcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if (pcmd == NULL)
+			break;
+		r8712_free_cmd_obj(pcmd);
+	} while (1);
+	up(&pcmdpriv->terminate_cmdthread_sema);
+	thread_exit();
+}
+
+void r8712_event_handle(struct _adapter *padapter, uint *peventbuf)
+{
+	u8 evt_code, evt_seq;
+	u16 evt_sz;
+	void (*event_callback)(struct _adapter *dev, u8 *pbuf);
+	struct	evt_priv *pevt_priv = &(padapter->evtpriv);
+
+	if (peventbuf == NULL)
+		goto _abort_event_;
+	evt_sz = (u16)(le32_to_cpu(*peventbuf) & 0xffff);
+	evt_seq = (u8)((le32_to_cpu(*peventbuf) >> 24) & 0x7f);
+	evt_code = (u8)((le32_to_cpu(*peventbuf) >> 16) & 0xff);
+	/* checking event sequence... */
+	if ((evt_seq & 0x7f) != pevt_priv->event_seq) {
+		pevt_priv->event_seq = ((evt_seq + 1) & 0x7f);
+		goto _abort_event_;
+	}
+	/* checking if event code is valid */
+	if (evt_code >= MAX_C2HEVT) {
+		pevt_priv->event_seq = ((evt_seq+1) & 0x7f);
+		goto _abort_event_;
+	} else if ((evt_code == GEN_EVT_CODE(_Survey)) &&
+		   (evt_sz > sizeof(struct wlan_bssid_ex))) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+	/* checking if event size match the event parm size */
+	if ((wlanevents[evt_code].parmsize) &&
+	    (wlanevents[evt_code].parmsize != evt_sz)) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	} else if ((evt_sz == 0) && (evt_code != GEN_EVT_CODE(_WPS_PBC))) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+	pevt_priv->event_seq++;	/* update evt_seq */
+	if (pevt_priv->event_seq > 127)
+		pevt_priv->event_seq = 0;
+	peventbuf = peventbuf + 2; /* move to event content, 8 bytes aligment */
+	if (peventbuf) {
+		event_callback = wlanevents[evt_code].event_callback;
+		if (event_callback)
+			event_callback(padapter, (u8 *)peventbuf);
+	}
+	pevt_priv->evt_done_cnt++;
+_abort_event_:
+	return;
+}
diff --git a/drivers/staging/rtl8712/rtl8712_cmd.h b/drivers/staging/rtl8712/rtl8712_cmd.h
new file mode 100644
index 0000000..766a646
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_cmd.h
@@ -0,0 +1,244 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMD_H_
+#define __RTL8712_CMD_H_
+
+#define CMD_HDR_SZ      8
+
+u8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd);
+void r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag);
+
+struct cmd_hdr {
+	u32 cmd_dw0;
+	u32 cmd_dw1;
+};
+
+enum rtl8712_h2c_cmd {
+	GEN_CMD_CODE(_Read_MACREG),	/*0*/
+	GEN_CMD_CODE(_Write_MACREG),
+	GEN_CMD_CODE(_Read_BBREG),
+	GEN_CMD_CODE(_Write_BBREG),
+	GEN_CMD_CODE(_Read_RFREG),
+	GEN_CMD_CODE(_Write_RFREG), /*5*/
+	GEN_CMD_CODE(_Read_EEPROM),
+	GEN_CMD_CODE(_Write_EEPROM),
+	GEN_CMD_CODE(_Read_EFUSE),
+	GEN_CMD_CODE(_Write_EFUSE),
+
+	GEN_CMD_CODE(_Read_CAM),	/*10*/
+	GEN_CMD_CODE(_Write_CAM),
+	GEN_CMD_CODE(_setBCNITV),
+	GEN_CMD_CODE(_setMBIDCFG),
+	GEN_CMD_CODE(_JoinBss),   /*14*/
+	GEN_CMD_CODE(_DisConnect), /*15*/
+	GEN_CMD_CODE(_CreateBss),
+	GEN_CMD_CODE(_SetOpMode),
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+	GEN_CMD_CODE(_SetAuth),
+
+	GEN_CMD_CODE(_SetKey),	/*20*/
+	GEN_CMD_CODE(_SetStaKey),
+	GEN_CMD_CODE(_SetAssocSta),
+	GEN_CMD_CODE(_DelAssocSta),
+	GEN_CMD_CODE(_SetStaPwrState),
+	GEN_CMD_CODE(_SetBasicRate), /*25*/
+	GEN_CMD_CODE(_GetBasicRate),
+	GEN_CMD_CODE(_SetDataRate),
+	GEN_CMD_CODE(_GetDataRate),
+	GEN_CMD_CODE(_SetPhyInfo),
+
+	GEN_CMD_CODE(_GetPhyInfo),	/*30*/
+	GEN_CMD_CODE(_SetPhy),
+	GEN_CMD_CODE(_GetPhy),
+	GEN_CMD_CODE(_readRssi),
+	GEN_CMD_CODE(_readGain),
+	GEN_CMD_CODE(_SetAtim), /*35*/
+	GEN_CMD_CODE(_SetPwrMode),
+	GEN_CMD_CODE(_JoinbssRpt),
+	GEN_CMD_CODE(_SetRaTable),
+	GEN_CMD_CODE(_GetRaTable),
+
+	GEN_CMD_CODE(_GetCCXReport), /*40*/
+	GEN_CMD_CODE(_GetDTMReport),
+	GEN_CMD_CODE(_GetTXRateStatistics),
+	GEN_CMD_CODE(_SetUsbSuspend),
+	GEN_CMD_CODE(_SetH2cLbk),
+	GEN_CMD_CODE(_AddBAReq), /*45*/
+
+	GEN_CMD_CODE(_SetChannel), /*46*/
+/* MP_OFFLOAD Start (47~54)*/
+	GEN_CMD_CODE(_SetTxPower),
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+	GEN_CMD_CODE(_SetSingleToneTx),
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+/* MP_OFFLOAD End*/
+	GEN_CMD_CODE(_TX_Beacon), /*55*/
+	GEN_CMD_CODE(_SetPowerTracking),
+	GEN_CMD_CODE(_AMSDU_TO_AMPDU), /*57*/
+	GEN_CMD_CODE(_SetMacAddress), /*58*/
+
+	GEN_CMD_CODE(_DisconnectCtrl), /*59*/
+	GEN_CMD_CODE(_SetChannelPlan), /*60*/
+	GEN_CMD_CODE(_DisconnectCtrlEx), /*61*/
+
+	/* To do, modify these h2c cmd, add or delete */
+	GEN_CMD_CODE(_GetH2cLbk) ,
+
+	/* WPS extra IE */
+	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
+	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
+	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
+	GEN_CMD_CODE(_SetAssocRspExtraIE) ,
+
+	/* the following is driver will do */
+	GEN_CMD_CODE(_GetCurDataRate) ,
+
+	GEN_CMD_CODE(_GetTxRetrycnt),  /* to record times that Tx retry to
+					* transmmit packet after association
+					*/
+	GEN_CMD_CODE(_GetRxRetrycnt),  /* to record total number of the
+					* received frame with ReTry bit set in
+					* the WLAN header
+					*/
+
+	GEN_CMD_CODE(_GetBCNOKcnt),
+	GEN_CMD_CODE(_GetBCNERRcnt),
+	GEN_CMD_CODE(_GetCurTxPwrLevel),
+
+	GEN_CMD_CODE(_SetDIG),
+	GEN_CMD_CODE(_SetRA),
+	GEN_CMD_CODE(_SetPT),
+	GEN_CMD_CODE(_ReadTSSI),
+
+	MAX_H2CCMD
+};
+
+
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_		_Write_RFREG_CMD_
+#define _DRV_INT_CMD_		(MAX_H2CCMD+1)
+#define _SetRFIntFs_CMD_	(MAX_H2CCMD+2)
+
+#ifdef _RTL8712_CMD_C_
+static struct _cmd_callback	cmd_callback[] = {
+	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL},
+	{GEN_CMD_CODE(_Read_BBREG), &r8712_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &r8712_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &r8712_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &r8712_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), &r8712_createbss_cmd_callback},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &r8712_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &r8712_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &r8712_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable), NULL},
+
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
+	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
+	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+/* MP_OFFLOAD Start (47~54)*/
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL},
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+/* MP_OFFLOAD End*/
+	{GEN_CMD_CODE(_TX_Beacon), NULL}, /*55*/
+	{GEN_CMD_CODE(_SetPowerTracking), NULL},
+	{GEN_CMD_CODE(_AMSDU_TO_AMPDU), NULL}, /*57*/
+	{GEN_CMD_CODE(_SetMacAddress), NULL}, /*58*/
+
+	{GEN_CMD_CODE(_DisconnectCtrl), NULL}, /*59*/
+	{GEN_CMD_CODE(_SetChannelPlan), NULL}, /*60*/
+	{GEN_CMD_CODE(_DisconnectCtrlEx), NULL}, /*61*/
+
+	/* To do, modify these h2c cmd, add or delete */
+	{GEN_CMD_CODE(_GetH2cLbk), NULL},
+
+	{_SetProbeReqExtraIE_CMD_, NULL},
+	{_SetAssocReqExtraIE_CMD_, NULL},
+	{_SetProbeRspExtraIE_CMD_, NULL},
+	{_SetAssocRspExtraIE_CMD_, NULL},
+	{_GetCurDataRate_CMD_, NULL},
+	{_GetTxRetrycnt_CMD_, NULL},
+	{_GetRxRetrycnt_CMD_, NULL},
+	{_GetBCNOKcnt_CMD_, NULL},
+	{_GetBCNERRcnt_CMD_, NULL},
+	{_GetCurTxPwrLevel_CMD_, NULL},
+	{_SetDIG_CMD_, NULL},
+	{_SetRA_CMD_, NULL},
+	{_SetPT_CMD_, NULL},
+	{GEN_CMD_CODE(_ReadTSSI), &r8712_readtssi_cmdrsp_callback}
+};
+#endif
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h b/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h
new file mode 100644
index 0000000..8dffe10
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMDCTRL_BITDEF_H__
+#define __RTL8712_CMDCTRL_BITDEF_H__
+
+/*
+ * 2. Command Control Registers	 (Offset: 0x0040 - 0x004F)*/
+/*--------------------------------------------------------------------------*/
+/*       8192S (CMD) command register bits	(Offset 0x40, 16 bits)*/
+/*--------------------------------------------------------------------------*/
+#define		_APSDOFF_STATUS		BIT(15)
+#define		_APSDOFF		BIT(14)
+#define		_BBRSTn			BIT(13)  /*Enable OFDM/CCK*/
+#define		_BB_GLB_RSTn		BIT(12)   /*Enable BB*/
+#define		_SCHEDULE_EN		BIT(10)  /*Enable MAC scheduler*/
+#define		_MACRXEN		BIT(9)
+#define		_MACTXEN		BIT(8)
+#define		_DDMA_EN		BIT(7)  /*FW off load function enable*/
+#define		_FW2HW_EN		BIT(6)  /*MAC every module reset */
+#define		_RXDMA_EN		BIT(5)
+#define		_TXDMA_EN		BIT(4)
+#define		_HCI_RXDMA_EN		BIT(3)
+#define		_HCI_TXDMA_EN		BIT(2)
+
+/*TXPAUSE*/
+#define	_STOPHCCA			BIT(6)
+#define	_STOPHIGH			BIT(5)
+#define	_STOPMGT			BIT(4)
+#define	_STOPVO				BIT(3)
+#define	_STOPVI				BIT(2)
+#define	_STOPBE				BIT(1)
+#define	_STOPBK				BIT(0)
+
+/*TCR*/
+#define	_DISCW				BIT(20)
+#define	_ICV				BIT(19)
+#define	_CFEND_FMT			BIT(17)
+#define	_CRC				BIT(16)
+#define	_FWRDY				BIT(7)
+#define _BASECHG			BIT(6)
+#define	_IMEM_RDY			BIT(5)
+#define _DMEM_CODE_DONE			BIT(4)
+#define _EMEM_CHK_RPT			BIT(3)
+#define _EMEM_CODE_DONE			BIT(2)
+#define _IMEM_CHK_RPT			BIT(1)
+#define _IMEM_CODE_DONE			BIT(0)
+
+#define	_TXDMA_INIT_VALUE	(_IMEM_CHK_RPT|_EMEM_CHK_RPT)
+
+/*RCR*/
+#define	_ENMBID				BIT(27)
+#define	_APP_PHYST_RXFF			BIT(25)
+#define	_APP_PHYST_STAFF		BIT(24)
+#define	_CBSSID				BIT(23)
+#define	_APWRMGT			BIT(22)
+#define	_ADD3				BIT(21)
+#define	_AMF				BIT(20)
+#define	_ACF				BIT(19)
+#define	_ADF				BIT(18)
+#define	_APP_MIC			BIT(17)
+#define	_APP_ICV			BIT(16)
+#define	_RXFTH_MSK			0x0000E000
+#define	_RXFTH_SHT			13
+#define	_AICV				BIT(12)
+#define	_RXPKTLMT_MSK			0x00000FC0
+#define	_RXPKTLMT_SHT			6
+#define	_ACRC32				BIT(5)
+#define	_AB				BIT(3)
+#define	_AM				BIT(2)
+#define	_APM				BIT(1)
+#define	_AAP				BIT(0)
+
+/*MSR*/
+#define	_NETTYPE_MSK			0x03
+#define	_NETTYPE_SHT			0
+
+/*BT*/
+#define _BTMODE_MSK			0x06
+#define _BTMODE_SHT			1
+#define _ENBT				BIT(0)
+
+/*MBIDCTRL*/
+#define	_ENMBID_MODE			BIT(15)
+#define	_BCNNO_MSK			0x7000
+#define	_BCNNO_SHT			12
+#define	_BCNSPACE_MSK			0x0FFF
+#define	_BCNSPACE_SHT			0
+
+
+#endif /* __RTL8712_CMDCTRL_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h b/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h
new file mode 100644
index 0000000..9374f1c
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMDCTRL_REGDEF_H__
+#define __RTL8712_CMDCTRL_REGDEF_H__
+
+
+#define CR			(RTL8712_CMDCTRL_ + 0x0000)
+#define TXPAUSE			(RTL8712_CMDCTRL_ + 0x0002)
+#define TCR			(RTL8712_CMDCTRL_ + 0x0004)
+#define RCR			(RTL8712_CMDCTRL_ + 0x0008)
+#define MSR			(RTL8712_CMDCTRL_ + 0x000C)
+#define SYSF_CFG		(RTL8712_CMDCTRL_ + 0x000D)
+#define MBIDCTRL		(RTL8712_CMDCTRL_ + 0x000E)
+
+
+#endif /* __RTL8712_CMDCTRL_REGDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h b/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h
new file mode 100644
index 0000000..8bd4837
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_DEBUGCTRL_BITDEF_H__
+#define __RTL8712_DEBUGCTRL_BITDEF_H__
+
+/*BIST*/
+#define	_BIST_RST			BIT(0)
+
+/*LMS*/
+#define	_LMS_MSK			0x03
+
+/*WDG_CTRL*/
+#define	_OVSEL_MSK			0x0600
+#define	_OVSEL_SHT			9
+#define	_WDGCLR				BIT(8)
+#define	_WDGEN_MSK			0x00FF
+#define	_WDGEN_SHT			0
+
+/*INTM*/
+#define	_TXTIMER_MSK		0xF000
+#define	_TXTIMER_SHT		12
+#define	_TXNUM_MSK			0x0F00
+#define	_TXNUM_SHT			8
+#define	_RXTIMER_MSK		0x00F0
+#define	_RXTIMER_SHT		4
+#define	_RXNUM_MSK			0x000F
+#define	_RXNUM_SHT			0
+
+/*FDLOCKTURN0*/
+/*FDLOCKTURN1*/
+#define	_TURN1				BIT(0)
+
+/*FDLOCKFLAG0*/
+/*FDLOCKFLAG1*/
+#define	_LOCKFLAG1_MSK		0x03
+
+
+#endif /* __RTL8712_DEBUGCTRL_BITDEF_H__ */
diff --git a/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h b/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h
new file mode 100644
index 0000000..43630bb
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_DEBUGCTRL_REGDEF_H__
+#define __RTL8712_DEBUGCTRL_REGDEF_H__
+
+#define BIST			(RTL8712_DEBUGCTRL_ + 0x00)
+#define DBS			(RTL8712_DEBUGCTRL_ + 0x04)
+#define LMS			(RTL8712_DEBUGCTRL_ + 0x05)
+#define CPUINST			(RTL8712_DEBUGCTRL_ + 0x08)
+#define CPUCAUSE		(RTL8712_DEBUGCTRL_ + 0x0C)
+#define LBUS_ERR_ADDR		(RTL8712_DEBUGCTRL_ + 0x10)
+#define LBUS_ERR_CMD		(RTL8712_DEBUGCTRL_ + 0x14)
+#define LBUS_ERR_DATA_L		(RTL8712_DEBUGCTRL_ + 0x18)
+#define LBUS_ERR_DATA_H		(RTL8712_DEBUGCTRL_ + 0x1C)
+#define LBUS_EXCEPTION_ADDR	(RTL8712_DEBUGCTRL_ + 0x20)
+#define WDG_CTRL		(RTL8712_DEBUGCTRL_ + 0x24)
+#define INTMTU			(RTL8712_DEBUGCTRL_ + 0x28)
+#define INTM			(RTL8712_DEBUGCTRL_ + 0x2A)
+#define FDLOCKTURN0		(RTL8712_DEBUGCTRL_ + 0x2C)
+#define FDLOCKTURN1		(RTL8712_DEBUGCTRL_ + 0x2D)
+#define FDLOCKFLAG0		(RTL8712_DEBUGCTRL_ + 0x2E)
+#define FDLOCKFLAG1		(RTL8712_DEBUGCTRL_ + 0x2F)
+#define TRXPKTBUF_DBG_DATA	(RTL8712_DEBUGCTRL_ + 0x30)
+#define TRXPKTBUF_DBG_CTRL	(RTL8712_DEBUGCTRL_ + 0x38)
+#define DPLL_MON		(RTL8712_DEBUGCTRL_ + 0x3A)
+
+
+
+#endif /* __RTL8712_DEBUGCTRL_REGDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h b/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h
new file mode 100644
index 0000000..32dab81
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h
@@ -0,0 +1,77 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_EDCASETTING_BITDEF_H__
+#define __RTL8712_EDCASETTING_BITDEF_H__
+
+/*EDCAPARAM*/
+#define	_TXOPLIMIT_MSK		0xFFFF0000
+#define	_TXOPLIMIT_SHT		16
+#define	_ECWIN_MSK		0x0000FF00
+#define	_ECWIN_SHT		8
+#define	_AIFS_MSK		0x000000FF
+#define	_AIFS_SHT		0
+
+/*BCNTCFG*/
+#define	_BCNECW_MSK		0xFF00
+#define	_BCNECW_SHT		8
+#define	_BCNIFS_MSK		0x00FF
+#define	_BCNIFS_SHT		0
+
+/*CWRR*/
+#define	_CWRR_MSK		0x03FF
+
+/*ACMAVG*/
+#define	_AVG_TIME_UP		BIT(3)
+#define	_AVGPERIOD_MSK		0x03
+
+/*ACMHWCTRL*/
+#define	_VOQ_ACM_STATUS		BIT(6)
+#define	_VIQ_ACM_STATUS		BIT(5)
+#define	_BEQ_ACM_STATUS		BIT(4)
+#define	_VOQ_ACM_EN		BIT(3)
+#define	_VIQ_ACM_EN		BIT(2)
+#define	_BEQ_ACM_EN		BIT(1)
+#define	_ACMHWEN		BIT(0)
+
+/*VO_ADMTIME*/
+#define	_VO_ACM_RUT		BIT(18)
+#define	_VO_ADMTIME_MSK		0x0003FFF
+
+/*VI_ADMTIME*/
+#define	_VI_ACM_RUT		BIT(18)
+#define	_VI_ADMTIME_MSK		0x0003FFF
+
+/*BE_ADMTIME*/
+#define	_BE_ACM_RUT		BIT(18)
+#define	_BE_ADMTIME_MSK		0x0003FFF
+
+/*Retry limit reg*/
+#define	_SRL_MSK		0xFF00
+#define	_SRL_SHT		8
+#define	_LRL_MSK		0x00FF
+#define	_LRL_SHT		0
+
+#endif /* __RTL8712_EDCASETTING_BITDEF_H__*/
diff --git a/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h b/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h
new file mode 100644
index 0000000..d992cb8
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_EDCASETTING_REGDEF_H__
+#define __RTL8712_EDCASETTING_REGDEF_H__
+
+#define EDCA_VO_PARAM		(RTL8712_EDCASETTING_ + 0x00)
+#define EDCA_VI_PARAM		(RTL8712_EDCASETTING_ + 0x04)
+#define EDCA_BE_PARAM		(RTL8712_EDCASETTING_ + 0x08)
+#define EDCA_BK_PARAM		(RTL8712_EDCASETTING_ + 0x0C)
+#define BCNTCFG			(RTL8712_EDCASETTING_ + 0x10)
+#define CWRR			(RTL8712_EDCASETTING_ + 0x12)
+#define ACMAVG			(RTL8712_EDCASETTING_ + 0x16)
+#define ACMHWCTRL		(RTL8712_EDCASETTING_ + 0x17)
+#define VO_ADMTIME		(RTL8712_EDCASETTING_ + 0x18)
+#define VI_ADMTIME		(RTL8712_EDCASETTING_ + 0x1C)
+#define BE_ADMTIME		(RTL8712_EDCASETTING_ + 0x20)
+#define RL			(RTL8712_EDCASETTING_ + 0x24)
+
+#endif /* __RTL8712_EDCASETTING_REGDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_efuse.c b/drivers/staging/rtl8712/rtl8712_efuse.c
new file mode 100644
index 0000000..b08e9a2
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_efuse.c
@@ -0,0 +1,575 @@
+/*
+ * rtl8712_efuse.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_EFUSE_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl8712_efuse.h"
+
+/* reserve 3 bytes for HW stop read */
+static int efuse_available_max_size = EFUSE_MAX_SIZE - 3 /*0x1FD*/;
+
+static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
+{
+	u8 tmpu8 = 0;
+
+	if (true == bPowerOn) {
+		/* -----------------e-fuse pwr & clk reg ctrl ---------------
+		 * Enable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 |= 0x80;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		msleep(20); /* for some platform , need some delay time */
+		/* Change Efuse Clock for write action to 40MHZ */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x03);
+		msleep(20); /* for some platform , need some delay time */
+	} else {
+		/* -----------------e-fuse pwr & clk reg ctrl -----------------
+		 * Disable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 &= 0x7F;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		/* Change Efuse Clock for write action to 500K */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x02);
+	}
+}
+
+/*
+ * Before write E-Fuse, this function must be called.
+ */
+u8 r8712_efuse_reg_init(struct _adapter *padapter)
+{
+	return true;
+}
+
+void r8712_efuse_reg_uninit(struct _adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, false);
+}
+
+static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL+3, 0x72); /* read cmd */
+	/* wait for complete */
+	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100) {
+		*data = r8712_read8(padapter, EFUSE_CTRL);
+		bResult = true;
+	} else {
+		*data = 0xff;
+		bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl -------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL, data); /* data */
+	r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+	/* wait for complete */
+	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100)
+		bResult = true;
+	else
+		bResult = false;
+	return bResult;
+}
+
+static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
+			    u8 *data)
+{
+	u8 tmpidx = 0, tmpv8 = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
+		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
+	r8712_write8(padapter, EFUSE_CTRL+2, tmpv8);
+	if (true == bRead) {
+		r8712_write8(padapter, EFUSE_CTRL+3,  0x72); /* read cmd */
+		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100) {
+			*data = r8712_read8(padapter, EFUSE_CTRL);
+			bResult = true;
+		} else {
+			*data = 0;
+			bResult = false;
+		}
+	} else {
+		r8712_write8(padapter, EFUSE_CTRL, *data); /* data */
+		r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100)
+			bResult = true;
+		else
+			bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
+{
+	u8 value, ret = true;
+
+	/* read one byte to check if E-Fuse is empty */
+	if (efuse_one_byte_rw(padapter, true, 0, &value) == true) {
+		if (0xFF == value)
+			*empty = true;
+		else
+			*empty = false;
+	} else
+		ret = false;
+	return ret;
+}
+
+void r8712_efuse_change_max_size(struct _adapter *padapter)
+{
+	u16 pre_pg_data_saddr = 0x1FB;
+	u16 i;
+	u16 pre_pg_data_size = 5;
+	u8 pre_pg_data[5];
+
+	for (i = 0; i < pre_pg_data_size; i++)
+		efuse_one_byte_read(padapter, pre_pg_data_saddr + i,
+				    &pre_pg_data[i]);
+	if ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&
+	    (pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&
+	    (pre_pg_data[4] == 0x0C))
+		efuse_available_max_size -= pre_pg_data_size;
+}
+
+int r8712_efuse_get_max_size(struct _adapter *padapter)
+{
+	return	efuse_available_max_size;
+}
+
+static u8 calculate_word_cnts(const u8 word_en)
+{
+	u8 word_cnts = 0;
+	u8 word_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++)
+		if (!(word_en & BIT(word_idx)))
+			word_cnts++; /* 0 : write enable */
+	return word_cnts;
+}
+
+static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,
+			       u8 *targetdata)
+{
+	u8 tmpindex = 0;
+	u8 word_idx, byte_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en&BIT(word_idx))) {
+			byte_idx = word_idx * 2;
+			targetdata[byte_idx] = sourdata[tmpindex++];
+			targetdata[byte_idx + 1] = sourdata[tmpindex++];
+		}
+	}
+}
+
+u16 r8712_efuse_get_current_size(struct _adapter *padapter)
+{
+	int bContinual = true;
+	u16 efuse_addr = 0;
+	u8 hoffset = 0, hworden = 0;
+	u8 efuse_data, word_cnts = 0;
+
+	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
+	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
+		if (efuse_data != 0xFF) {
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			/* read next header */
+			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
+		} else
+			bContinual = false ;
+	}
+	return efuse_addr;
+}
+
+u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
+{
+	u8 hoffset = 0, hworden = 0, word_cnts = 0;
+	u16 efuse_addr = 0;
+	u8 efuse_data;
+	u8 tmpidx = 0;
+	u8 tmpdata[PGPKT_DATA_SIZE];
+	u8 ret = true;
+
+	if (data == NULL)
+		return false;
+	if (offset > 0x0f)
+		return false;
+	memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
+	while (efuse_addr < efuse_available_max_size) {
+		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) ==
+		    true) {
+			if (efuse_data == 0xFF)
+				break;
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			if (hoffset == offset) {
+				memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
+				for (tmpidx = 0; tmpidx < word_cnts * 2;
+				     tmpidx++) {
+					if (efuse_one_byte_read(padapter,
+					    efuse_addr+1+tmpidx, &efuse_data) ==
+					     true) {
+						tmpdata[tmpidx] = efuse_data;
+					} else
+						ret = false;
+				}
+				pgpacket_copy_data(hworden, tmpdata, data);
+			}
+			efuse_addr += 1 + (word_cnts*2);
+		} else {
+			ret = false;
+			break;
+		}
+	}
+	return ret;
+}
+
+static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
+{
+	struct PGPKT_STRUCT pkt;
+	u8 offset, word_en, value;
+	u16 addr;
+	int i;
+	u8 ret = true;
+
+	pkt.offset = GET_EFUSE_OFFSET(header);
+	pkt.word_en = GET_EFUSE_WORD_EN(header);
+	addr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;
+	if (addr > efuse_available_max_size)
+		return false;
+	/* retrieve original data */
+	addr = 0;
+	while (addr < header_addr) {
+		if (efuse_one_byte_read(padapter, addr++, &value) == false) {
+			ret = false;
+			break;
+		}
+		offset = GET_EFUSE_OFFSET(value);
+		word_en = GET_EFUSE_WORD_EN(value);
+		if (pkt.offset != offset) {
+			addr += calculate_word_cnts(word_en)*2;
+			continue;
+		}
+		for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+			if (BIT(i) & word_en) {
+				if (BIT(i) & pkt.word_en) {
+					if (efuse_one_byte_read(
+							padapter, addr,
+							&value) == true)
+						pkt.data[i*2] = value;
+					else
+						return false;
+					if (efuse_one_byte_read(
+							padapter,
+							addr + 1,
+							&value) == true)
+						pkt.data[i*2 + 1] =
+							value;
+					else
+						return false;
+				}
+				addr += 2;
+			}
+		}
+	}
+	if (addr != header_addr)
+		return false;
+	addr++;
+	/* fill original data */
+	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+		if (BIT(i) & pkt.word_en) {
+			efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+			efuse_one_byte_write(padapter, addr+1,
+					pkt.data[i*2 + 1]);
+			/* additional check */
+			if (efuse_one_byte_read(padapter, addr, &value)
+				== false)
+				ret = false;
+			else if (pkt.data[i*2] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr,
+							pkt.data[i * 2]);
+			}
+			if (efuse_one_byte_read(padapter, addr+1, &value) ==
+				false)
+				ret = false;
+			else if (pkt.data[i*2 + 1] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr+1,
+							pkt.data[i*2 + 1]);
+			}
+		}
+		addr += 2;
+	}
+	return ret;
+}
+
+u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
+			 const u8 word_en, const u8 *data)
+{
+	u8 pg_header = 0;
+	u16 efuse_addr = 0, curr_size = 0;
+	u8 efuse_data, target_word_cnts = 0;
+	static int repeat_times;
+	int sub_repeat;
+	u8 bResult = true;
+
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	efuse_data = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (efuse_data != 0x03)
+		return false;
+	pg_header = MAKE_EFUSE_HEADER(offset, word_en);
+	target_word_cnts = calculate_word_cnts(word_en);
+	repeat_times = 0;
+	efuse_addr = 0;
+	while (efuse_addr < efuse_available_max_size) {
+		curr_size = r8712_efuse_get_current_size(padapter);
+		if ((curr_size + 1 + target_word_cnts * 2) >
+		     efuse_available_max_size)
+			return false; /*target_word_cnts + pg header(1 byte)*/
+		efuse_addr = curr_size; /* current size is also the last addr*/
+		efuse_one_byte_write(padapter, efuse_addr, pg_header); /*hdr*/
+		sub_repeat = 0;
+		/* check if what we read is what we write */
+		while (efuse_one_byte_read(padapter, efuse_addr,
+					   &efuse_data) == false) {
+			if (++sub_repeat > _REPEAT_THRESHOLD_) {
+				bResult = false; /* continue to blind write */
+				break; /* continue to blind write */
+			}
+		}
+		if ((sub_repeat > _REPEAT_THRESHOLD_) ||
+		    (pg_header == efuse_data)) {
+			/* write header ok OR can't check header(creep) */
+			u8 i;
+
+			/* go to next address */
+			efuse_addr++;
+			for (i = 0; i < target_word_cnts*2; i++) {
+				efuse_one_byte_write(padapter,
+						     efuse_addr + i,
+						     *(data + i));
+				if (efuse_one_byte_read(padapter,
+				    efuse_addr + i, &efuse_data) == false)
+					bResult = false;
+				else if (*(data+i) != efuse_data) /* fail */
+					bResult = false;
+			}
+			break;
+		} else { /* write header fail */
+			bResult = false;
+			if (0xFF == efuse_data)
+				return bResult; /* not thing damaged. */
+			/* call rescue procedure */
+			if (fix_header(padapter, efuse_data, efuse_addr) ==
+			    false)
+				return false; /* rescue fail */
+
+			if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
+				break;
+			/* otherwise, take another risk... */
+		}
+	}
+	return bResult;
+}
+
+u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
+		      u16 cnts, u8 *data)
+{
+	int i;
+	u8 res = true;
+
+	if (start_addr > EFUSE_MAX_SIZE)
+		return false;
+	if ((bRead == false) && ((start_addr + cnts) >
+	   efuse_available_max_size))
+		return false;
+	if ((false == bRead) && (r8712_efuse_reg_init(padapter) == false))
+		return false;
+	/* -----------------e-fuse one byte read / write ---------------------*/
+	for (i = 0; i < cnts; i++) {
+		if ((start_addr + i) > EFUSE_MAX_SIZE) {
+			res = false;
+			break;
+		}
+		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
+		      data + i);
+		if ((false == bRead) && (false == res))
+			break;
+	}
+	if (false == bRead)
+		r8712_efuse_reg_uninit(padapter);
+	return res;
+}
+
+u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, ret = true;
+	u8 pktdata[PGPKT_DATA_SIZE];
+	int i, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	if ((efuse_is_empty(padapter, &offset) == true) && (offset ==
+	     true)) {
+		for (i = 0; i < cnts; i++)
+			data[i] = 0xFF;
+		return ret;
+	}
+	offset = (addr >> 3) & 0xF;
+	ret = r8712_efuse_pg_packet_read(padapter, offset, pktdata);
+	i = addr & 0x7;	/* pktdata index */
+	idx = 0;	/* data index */
+
+	do {
+		for (; i < PGPKT_DATA_SIZE; i++) {
+			data[idx++] = pktdata[i];
+			if (idx == cnts)
+				return ret;
+		}
+		offset++;
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			ret = false;
+		i = 0;
+	} while (1);
+	return ret;
+}
+
+u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
+			 u8 *data)
+{
+	u8 offset, word_en, empty;
+	u8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];
+	int i, j, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	empty = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (empty != 0x03)
+		return false;
+	if (efuse_is_empty(padapter, &empty) == true) {
+		if (true == empty)
+			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
+	} else
+		return false;
+	offset = (addr >> 3) & 0xF;
+	if (empty == false)
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			return false;
+	word_en = 0xF;
+	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	i = addr & 0x7;	/* pktdata index */
+	j = 0;		/* newdata index */
+	idx = 0;	/* data index */
+
+	if (i & 0x1) {
+		/*  odd start */
+		if (data[idx] != pktdata[i]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[j++] = pktdata[i - 1];
+			newdata[j++] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < PGPKT_DATA_SIZE; i += 2) {
+			if ((cnts - idx) == 1) {
+				if (data[idx] != pktdata[i]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = pktdata[1 + 1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != pktdata[i]) || (data[idx+1] !=
+				     pktdata[i+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts)
+				break;
+		}
+
+		if (word_en != 0xF)
+			if (r8712_efuse_pg_packet_write(padapter, offset,
+			    word_en, newdata) == false)
+				return false;
+		if (idx == cnts)
+			break;
+		offset++;
+		if (empty == false)
+			if (!r8712_efuse_pg_packet_read(padapter, offset,
+			    pktdata))
+				return false;
+		i = 0;
+		j = 0;
+		word_en = 0xF;
+		memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	} while (1);
+
+	return true;
+}
diff --git a/drivers/staging/rtl8712/rtl8712_efuse.h b/drivers/staging/rtl8712/rtl8712_efuse.h
new file mode 100644
index 0000000..6a64f91
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_efuse.h
@@ -0,0 +1,43 @@
+#ifndef __RTL8712_EFUSE_H__
+#define __RTL8712_EFUSE_H__
+
+#include "osdep_service.h"
+
+
+#define _REPEAT_THRESHOLD_	3
+
+#define EFUSE_MAX_SIZE		512
+#define EFUSE_MAP_MAX_SIZE	128
+
+#define PGPKG_MAX_WORDS	4
+#define PGPKT_DATA_SIZE	8 /* PGPKG_MAX_WORDS*2; BYTES sizeof(u8)*8*/
+#define MAX_PGPKT_SIZE	9 /* 1 + PGPKT_DATA_SIZE; header + 2 * 4 words (BYTES)*/
+
+#define GET_EFUSE_OFFSET(header)	((header & 0xF0) >> 4)
+#define GET_EFUSE_WORD_EN(header)	(header & 0x0F)
+#define MAKE_EFUSE_HEADER(offset, word_en)	(((offset & 0x0F) << 4) | \
+						(word_en & 0x0F))
+/*--------------------------------------------------------------------------*/
+struct PGPKT_STRUCT {
+	u8 offset;
+	u8 word_en;
+	u8 data[PGPKT_DATA_SIZE];
+};
+/*--------------------------------------------------------------------------*/
+u8 r8712_efuse_reg_init(struct _adapter *padapter);
+void r8712_efuse_reg_uninit(struct _adapter *padapter);
+u16 r8712_efuse_get_current_size(struct _adapter *padapter);
+int r8712_efuse_get_max_size(struct _adapter *padapter);
+void r8712_efuse_change_max_size(struct _adapter *padapter);
+u8 r8712_efuse_pg_packet_read(struct _adapter *padapter,
+			      u8 offset, u8 *data);
+u8 r8712_efuse_pg_packet_write(struct _adapter *padapter,
+			       const u8 offset, const u8 word_en,
+			       const u8 *data);
+u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead,
+		      u16 start_addr, u16 cnts, u8 *data);
+u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr,
+			u16 cnts, u8 *data);
+u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr,
+				u16 cnts, u8 *data);
+#endif
diff --git a/drivers/staging/rtl8712/rtl8712_event.h b/drivers/staging/rtl8712/rtl8712_event.h
new file mode 100644
index 0000000..3d7f79e
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_event.h
@@ -0,0 +1,99 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_EVENT_H_
+#define _RTL8712_EVENT_H_
+
+void r8712_event_handle(struct _adapter *padapter, uint *peventbuf);
+void r8712_got_addbareq_event_callback(struct _adapter *adapter , u8 *pbuf);
+
+enum rtl8712_c2h_event {
+	GEN_EVT_CODE(_Read_MACREG) = 0,		/*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+	GEN_EVT_CODE(_Read_RFREG),
+	GEN_EVT_CODE(_Read_EEPROM),
+	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),		/*5*/
+	GEN_EVT_CODE(_Get_BasicRate),
+	GEN_EVT_CODE(_Get_DataRate),
+	GEN_EVT_CODE(_Survey),			/*8*/
+	GEN_EVT_CODE(_SurveyDone),		/*9*/
+
+	GEN_EVT_CODE(_JoinBss),			/*10*/
+	GEN_EVT_CODE(_AddSTA),
+	GEN_EVT_CODE(_DelSTA),
+	GEN_EVT_CODE(_AtimDone),
+	GEN_EVT_CODE(_TX_Report),
+	GEN_EVT_CODE(_CCX_Report),		/*15*/
+	GEN_EVT_CODE(_DTM_Report),
+	GEN_EVT_CODE(_TX_Rate_Statistics),
+	GEN_EVT_CODE(_C2HLBK),
+	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),		/*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		/*filen: only for PCIE, USB*/
+	GEN_EVT_CODE(_WPS_PBC),			/*24*/
+	GEN_EVT_CODE(_ADDBAReq_Report),		/*25*/
+	MAX_C2HEVT
+};
+
+
+#ifdef _RTL8712_CMD_C_
+
+static struct fwevent wlanevents[] = {
+	{0, NULL},	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &r8712_survey_event_callback},		/*8*/
+	{sizeof(struct surveydone_event),
+		&r8712_surveydone_event_callback},	/*9*/
+
+	{0, &r8712_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &r8712_stassoc_event_callback},
+	{sizeof(struct stadel_event), &r8712_stadel_event_callback},
+	{0, &r8712_atimdone_event_callback},
+	{0, NULL},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},	/*fwdbg_event_callback},*/
+	{0, NULL},	/*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &r8712_cpwm_event_callback},
+	{0, &r8712_wpspbc_event_callback},
+	{0, &r8712_got_addbareq_event_callback},
+};
+
+#endif/*_RTL8712_CMD_C_*/
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h b/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h
new file mode 100644
index 0000000..c564dc8
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_FIFOCTRL_BITDEF_H__
+#define __RTL8712_FIFOCTRL_BITDEF_H__
+
+/*PBP*/
+#define	_PSTX_MSK			0xF0
+#define	_PSTX_SHT			4
+#define	_PSRX_MSK			0x0F
+#define	_PSRX_SHT			0
+
+/*TXFF_STATUS*/
+#define	_TXSTATUS_OVF		BIT(15)
+
+/*RXFF_STATUS*/
+#define	_STATUSFF1_OVF		BIT(7)
+#define	_STATUSFF1_EMPTY	BIT(6)
+#define	_STATUSFF0_OVF		BIT(5)
+#define	_STATUSFF0_EMPTY	BIT(4)
+#define	_RXFF1_OVF			BIT(3)
+#define	_RXFF1_EMPTY		BIT(2)
+#define	_RXFF0_OVF			BIT(1)
+#define	_RXFF0_EMPTY		BIT(0)
+
+/*TXFF_EMPTY_TH*/
+#define	_BKQ_EMPTY_TH_MSK	0x0F0000
+#define	_BKQ_EMPTY_TH_SHT	16
+#define	_BEQ_EMPTY_TH_MSK	0x00F000
+#define	_BEQ_EMPTY_TH_SHT	12
+#define	_VIQ_EMPTY_TH_MSK	0x000F00
+#define	_VIQ_EMPTY_TH_SHT	8
+#define	_VOQ_EMPTY_TH_MSK	0x0000F0
+#define	_VOQ_EMPTY_TH_SHT	4
+#define	_BMCQ_EMPTY_TH_MSK	0x00000F
+#define	_BMCQ_EMPTY_TH_SHT	0
+
+/*SDIO_RX_BLKSZ*/
+#define	_SDIO_RX_BLKSZ_MSK	0x07
+
+/*RXDMA_CTRL*/
+#define	_C2HFF_POLL		BIT(4)
+#define	_RXPKT_POLL		BIT(0)
+
+/*RXPKT_NUM*/
+#define	_RXCMD_NUM_MSK		0xFF00
+#define	_RXCMD_NUM_SHT		8
+#define	_RXFF0_NUM_MSK		0x00FF
+#define	_RXFF0_NUM_SHT		0
+
+/*FIFOPAGE2*/
+#define	_PUB_AVAL_PG_MSK	0xFFFF0000
+#define	_PUB_AVAL_PG_SHT	16
+#define	_BCN_AVAL_PG_MSK	0x0000FFFF
+#define	_BCN_AVAL_PG_SHT	0
+
+/*RX0PKTNUM*/
+#define	_RXFF0_DEC_POLL				BIT(15)
+#define	_RXFF0_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF0_PKT_DEC_NUM_SHT		8
+#define	_RXFF0_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF0_PKTNUM_RPT_SHT		0
+
+/*RX1PKTNUM*/
+#define	_RXFF1_DEC_POLL				BIT(15)
+#define	_RXFF1_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF1_PKT_DEC_NUM_SHT		8
+#define	_RXFF1_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF1_PKTNUM_RPT_SHT		0
+
+/*RXFLTMAP0*/
+#define	_MGTFLT13EN		BIT(13)
+#define	_MGTFLT12EN		BIT(12)
+#define	_MGTFLT11EN		BIT(11)
+#define	_MGTFLT10EN		BIT(10)
+#define	_MGTFLT9EN		BIT(9)
+#define	_MGTFLT8EN		BIT(8)
+#define	_MGTFLT5EN		BIT(5)
+#define	_MGTFLT4EN		BIT(4)
+#define	_MGTFLT3EN		BIT(3)
+#define	_MGTFLT2EN		BIT(2)
+#define	_MGTFLT1EN		BIT(1)
+#define	_MGTFLT0EN		BIT(0)
+
+/*RXFLTMAP1*/
+#define	_CTRLFLT15EN	BIT(15)
+#define	_CTRLFLT14EN	BIT(14)
+#define	_CTRLFLT13EN	BIT(13)
+#define	_CTRLFLT12EN	BIT(12)
+#define	_CTRLFLT11EN	BIT(11)
+#define	_CTRLFLT10EN	BIT(10)
+#define	_CTRLFLT9EN		BIT(9)
+#define	_CTRLFLT8EN		BIT(8)
+#define	_CTRLFLT7EN		BIT(7)
+#define	_CTRLFLT6EN		BIT(6)
+
+/*RXFLTMAP2*/
+#define	_DATAFLT15EN	BIT(15)
+#define	_DATAFLT14EN	BIT(14)
+#define	_DATAFLT13EN	BIT(13)
+#define	_DATAFLT12EN	BIT(12)
+#define	_DATAFLT11EN	BIT(11)
+#define	_DATAFLT10EN	BIT(10)
+#define	_DATAFLT9EN		BIT(9)
+#define	_DATAFLT8EN		BIT(8)
+#define	_DATAFLT7EN		BIT(7)
+#define	_DATAFLT6EN		BIT(6)
+#define	_DATAFLT5EN		BIT(5)
+#define	_DATAFLT4EN		BIT(4)
+#define	_DATAFLT3EN		BIT(3)
+#define	_DATAFLT2EN		BIT(2)
+#define	_DATAFLT1EN		BIT(1)
+#define	_DATAFLT0EN		BIT(0)
+
+/*RXFLTMAP3*/
+#define	_MESHAFLT1EN		BIT(1)
+#define	_MESHAFLT0EN		BIT(0)
+
+/*TXPKT_NUM_CTRL*/
+#define	_TXPKTNUM_DEC		BIT(8)
+#define	_TXPKTNUM_MSK		0x00FF
+#define	_TXPKTNUM_SHT		0
+
+/*TXFF_PG_NUM*/
+#define	_TXFF_PG_NUM_MSK	0x0FFF
+
+
+#endif	/*	__RTL8712_FIFOCTRL_BITDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h b/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h
new file mode 100644
index 0000000..29b89c4
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_FIFOCTRL_REGDEF_H__
+#define __RTL8712_FIFOCTRL_REGDEF_H__
+
+#define RQPN			(RTL8712_FIFOCTRL_ + 0x00)
+#define RXFF_BNDY		(RTL8712_FIFOCTRL_ + 0x0C)
+#define RXRPT_BNDY		(RTL8712_FIFOCTRL_ + 0x10)
+#define TXPKTBUF_PGBNDY		(RTL8712_FIFOCTRL_ + 0x14)
+#define PBP			(RTL8712_FIFOCTRL_ + 0x15)
+#define RX_DRVINFO_SZ		(RTL8712_FIFOCTRL_ + 0x16)
+#define TXFF_STATUS		(RTL8712_FIFOCTRL_ + 0x17)
+#define RXFF_STATUS		(RTL8712_FIFOCTRL_ + 0x18)
+#define TXFF_EMPTY_TH		(RTL8712_FIFOCTRL_ + 0x19)
+#define SDIO_RX_BLKSZ		(RTL8712_FIFOCTRL_ + 0x1C)
+#define RXDMA_RXCTRL		(RTL8712_FIFOCTRL_ + 0x1D)
+#define RXPKT_NUM		(RTL8712_FIFOCTRL_ + 0x1E)
+#define RXPKT_NUM_C2H		(RTL8712_FIFOCTRL_ + 0x1F)
+#define C2HCMD_UDT_SIZE		(RTL8712_FIFOCTRL_ + 0x20)
+#define C2HCMD_UDT_ADDR		(RTL8712_FIFOCTRL_ + 0x22)
+#define FIFOPAGE2		(RTL8712_FIFOCTRL_ + 0x24)
+#define FIFOPAGE1		(RTL8712_FIFOCTRL_ + 0x28)
+#define FW_RSVD_PG_CTRL		(RTL8712_FIFOCTRL_ + 0x30)
+#define TXRPTFF_RDPTR		(RTL8712_FIFOCTRL_ + 0x40)
+#define TXRPTFF_WTPTR		(RTL8712_FIFOCTRL_ + 0x44)
+#define C2HFF_RDPTR		(RTL8712_FIFOCTRL_ + 0x48)
+#define C2HFF_WTPTR		(RTL8712_FIFOCTRL_ + 0x4C)
+#define RXFF0_RDPTR		(RTL8712_FIFOCTRL_ + 0x50)
+#define RXFF0_WTPTR		(RTL8712_FIFOCTRL_ + 0x54)
+#define RXFF1_RDPTR		(RTL8712_FIFOCTRL_ + 0x58)
+#define RXFF1_WTPTR		(RTL8712_FIFOCTRL_ + 0x5C)
+#define RXRPT0FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x60)
+#define RXRPT0FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x64)
+#define RXRPT1FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x68)
+#define RXRPT1FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x6C)
+#define RX0PKTNUM		(RTL8712_FIFOCTRL_ + 0x72)
+#define RX1PKTNUM		(RTL8712_FIFOCTRL_ + 0x74)
+#define RXFLTMAP0		(RTL8712_FIFOCTRL_ + 0x76)
+#define RXFLTMAP1		(RTL8712_FIFOCTRL_ + 0x78)
+#define RXFLTMAP2		(RTL8712_FIFOCTRL_ + 0x7A)
+#define RXFLTMAP3		(RTL8712_FIFOCTRL_ + 0x7c)
+#define TBDA			(RTL8712_FIFOCTRL_ + 0x84)
+#define THPDA			(RTL8712_FIFOCTRL_ + 0x88)
+#define TCDA			(RTL8712_FIFOCTRL_ + 0x8C)
+#define TMDA			(RTL8712_FIFOCTRL_ + 0x90)
+#define HDA			(RTL8712_FIFOCTRL_ + 0x94)
+#define TVODA			(RTL8712_FIFOCTRL_ + 0x98)
+#define TVIDA			(RTL8712_FIFOCTRL_ + 0x9C)
+#define TBEDA			(RTL8712_FIFOCTRL_ + 0xA0)
+#define TBKDA			(RTL8712_FIFOCTRL_ + 0xA4)
+#define RCDA			(RTL8712_FIFOCTRL_ + 0xA8)
+#define RDSA			(RTL8712_FIFOCTRL_ + 0xAC)
+#define TXPKT_NUM_CTRL		(RTL8712_FIFOCTRL_ + 0xB0)
+#define TXQ_PGADD		(RTL8712_FIFOCTRL_ + 0xB3)
+#define TXFF_PG_NUM		(RTL8712_FIFOCTRL_ + 0xB4)
+
+
+
+#endif	/* __RTL8712_FIFOCTRL_REGDEF_H__ */
diff --git a/drivers/staging/rtl8712/rtl8712_gp_bitdef.h b/drivers/staging/rtl8712/rtl8712_gp_bitdef.h
new file mode 100644
index 0000000..884a821
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_gp_bitdef.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_GP_BITDEF_H__
+#define __RTL8712_GP_BITDEF_H__
+
+/*GPIO_CTRL*/
+#define	_GPIO_MOD_MSK			0xFF000000
+#define	_GPIO_MOD_SHT			24
+#define	_GPIO_IO_SEL_MSK		0x00FF0000
+#define	_GPIO_IO_SEL_SHT		16
+#define	_GPIO_OUT_MSK			0x0000FF00
+#define	_GPIO_OUT_SHT			8
+#define	_GPIO_IN_MSK			0x000000FF
+#define	_GPIO_IN_SHT			0
+
+/*SYS_PINMUX_CFG*/
+#define	_GPIOSEL_MSK			0x0003
+#define	_GPIOSEL_SHT			0
+
+/*LED_CFG*/
+#define _LED1SV				BIT(7)
+#define _LED1CM_MSK			0x0070
+#define _LED1CM_SHT			4
+#define _LED0SV				BIT(3)
+#define _LED0CM_MSK			0x0007
+#define _LED0CM_SHT			0
+
+/*PHY_REG*/
+#define _HST_RDRDY_SHT			0
+#define _HST_RDRDY_MSK			0xFF
+#define _HST_RDRDY			BIT(_HST_RDRDY_SHT)
+#define _CPU_WTBUSY_SHT			1
+#define _CPU_WTBUSY_MSK			0xFF
+#define _CPU_WTBUSY			BIT(_CPU_WTBUSY_SHT)
+
+/* 11. General Purpose Registers   (Offset: 0x02E0 - 0x02FF)*/
+
+/*       8192S GPIO Config Setting (offset 0x2F1, 1 byte)*/
+
+/*----------------------------------------------------------------------------*/
+
+#define		GPIOMUX_EN	BIT(3)	/* When this bit is set to "1",
+					 * GPIO PINs will switch to MAC
+					 * GPIO Function*/
+#define		GPIOSEL_GPIO	0	/* UART or JTAG or pure GPIO*/
+#define		GPIOSEL_PHYDBG	1	/* PHYDBG*/
+#define		GPIOSEL_BT	2	/* BT_coex*/
+#define		GPIOSEL_WLANDBG	3	/* WLANDBG*/
+#define		GPIOSEL_GPIO_MASK	(~(BIT(0)|BIT(1)))
+/* HW Readio OFF switch (GPIO BIT) */
+#define		HAL_8192S_HW_GPIO_OFF_BIT	BIT(3)
+#define		HAL_8192S_HW_GPIO_OFF_MASK	0xF7
+#define		HAL_8192S_HW_GPIO_WPS_BIT	BIT(4)
+
+#endif	/*__RTL8712_GP_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_gp_regdef.h b/drivers/staging/rtl8712/rtl8712_gp_regdef.h
new file mode 100644
index 0000000..8fc68f6
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_gp_regdef.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_GP_REGDEF_H__
+#define __RTL8712_GP_REGDEF_H__
+
+#define PSTIMER			(RTL8712_GP_ + 0x00)
+#define TIMER1			(RTL8712_GP_ + 0x04)
+#define TIMER2			(RTL8712_GP_ + 0x08)
+#define GPIO_CTRL		(RTL8712_GP_ + 0x0C)
+#define GPIO_IO_SEL		(RTL8712_GP_ + 0x0E)
+#define GPIO_INTCTRL		(RTL8712_GP_ + 0x10)
+#define MAC_PINMUX_CTRL		(RTL8712_GP_ + 0x11)
+#define LEDCFG			(RTL8712_GP_ + 0x12)
+#define PHY_REG_RPT		(RTL8712_GP_ + 0x13)
+#define PHY_REG_DATA		(RTL8712_GP_ + 0x14)
+
+
+#endif	/*__RTL8712_GP_REGDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_hal.h b/drivers/staging/rtl8712/rtl8712_hal.h
new file mode 100644
index 0000000..d19865a
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_hal.h
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_HAL_H__
+#define __RTL8712_HAL_H__
+
+enum _HW_VERSION {
+	RTL8712_FPGA,
+	RTL8712_1stCUT,	/*A Cut (RTL8712_ASIC)*/
+	RTL8712_2ndCUT,	/*B Cut*/
+	RTL8712_3rdCUT,	/*C Cut*/
+};
+
+enum _LOOPBACK_TYPE {
+	RTL8712_AIR_TRX = 0,
+	RTL8712_MAC_LBK,
+	RTL8712_BB_LBK,
+	RTL8712_MAC_FW_LBK = 4,
+	RTL8712_BB_FW_LBK = 8,
+};
+
+enum RTL871X_HCI_TYPE {
+	RTL8712_SDIO,
+	RTL8712_USB,
+};
+
+enum RTL8712_RF_CONFIG {
+	RTL8712_RF_1T1R,
+	RTL8712_RF_1T2R,
+	RTL8712_RF_2T2R
+};
+
+enum _RTL8712_HCI_TYPE_ {
+	RTL8712_HCI_TYPE_PCIE = 0x01,
+	RTL8712_HCI_TYPE_AP_PCIE = 0x81,
+	RTL8712_HCI_TYPE_USB = 0x02,
+	RTL8712_HCI_TYPE_92USB = 0x02,
+	RTL8712_HCI_TYPE_AP_USB = 0x82,
+	RTL8712_HCI_TYPE_72USB = 0x12,
+	RTL8712_HCI_TYPE_SDIO = 0x04,
+	RTL8712_HCI_TYPE_72SDIO = 0x14
+};
+
+struct fw_priv {   /*8-bytes alignment required*/
+	/*--- long word 0 ----*/
+	unsigned char signature_0;  /*0x12: CE product, 0x92: IT product*/
+	unsigned char signature_1;  /*0x87: CE product, 0x81: IT product*/
+	unsigned char hci_sel; /*0x81: PCI-AP, 01:PCIe, 02: 92S-U, 0x82: USB-AP,
+			    * 0x12: 72S-U, 03:SDIO*/
+	unsigned char chip_version; /*the same value as register value*/
+	unsigned char customer_ID_0; /*customer  ID low byte*/
+	unsigned char customer_ID_1; /*customer  ID high byte*/
+	unsigned char rf_config;  /*0x11:  1T1R, 0x12: 1T2R, 0x92: 1T2R turbo,
+			     * 0x22: 2T2R*/
+	unsigned char usb_ep_num;  /* 4: 4EP, 6: 6EP, 11: 11EP*/
+	/*--- long word 1 ----*/
+	unsigned char regulatory_class_0; /*regulatory class bit map 0*/
+	unsigned char regulatory_class_1; /*regulatory class bit map 1*/
+	unsigned char regulatory_class_2; /*regulatory class bit map 2*/
+	unsigned char regulatory_class_3; /*regulatory class bit map 3*/
+	unsigned char rfintfs;    /* 0:SWSI, 1:HWSI, 2:HWPI*/
+	unsigned char def_nettype;
+	unsigned char turboMode;
+	unsigned char lowPowerMode;/* 0: noral mode, 1: low power mode*/
+	/*--- long word 2 ----*/
+	unsigned char lbk_mode; /*0x00: normal, 0x03: MACLBK, 0x01: PHYLBK*/
+	unsigned char mp_mode; /* 1: for MP use, 0: for normal driver */
+	unsigned char vcsType; /* 0:off 1:on 2:auto */
+	unsigned char vcsMode; /* 1:RTS/CTS 2:CTS to self */
+	unsigned char rsvd022;
+	unsigned char rsvd023;
+	unsigned char rsvd024;
+	unsigned char rsvd025;
+	/*--- long word 3 ----*/
+	unsigned char qos_en;    /*1: QoS enable*/
+	unsigned char bw_40MHz_en;   /*1: 40MHz BW enable*/
+	unsigned char AMSDU2AMPDU_en;   /*1: 4181 convert AMSDU to AMPDU,
+				   * 0: disable*/
+	unsigned char AMPDU_en;   /*1: 11n AMPDU enable*/
+	unsigned char rate_control_offload; /*1: FW offloads,0: driver handles*/
+	unsigned char aggregation_offload;  /*1: FW offloads,0: driver handles*/
+	unsigned char rsvd030;
+	unsigned char rsvd031;
+	/*--- long word 4 ----*/
+	unsigned char beacon_offload;   /* 1. FW offloads, 0: driver handles*/
+	unsigned char MLME_offload;   /* 2. FW offloads, 0: driver handles*/
+	unsigned char hwpc_offload;   /* 3. FW offloads, 0: driver handles*/
+	unsigned char tcp_checksum_offload; /*4. FW offloads,0: driver handles*/
+	unsigned char tcp_offload;    /* 5. FW offloads, 0: driver handles*/
+	unsigned char ps_control_offload; /* 6. FW offloads, 0: driver handles*/
+	unsigned char WWLAN_offload;   /* 7. FW offloads, 0: driver handles*/
+	unsigned char rsvd040;
+	/*--- long word 5 ----*/
+	unsigned char tcp_tx_frame_len_L;  /*tcp tx packet length low byte*/
+	unsigned char tcp_tx_frame_len_H;  /*tcp tx packet length high byte*/
+	unsigned char tcp_rx_frame_len_L;  /*tcp rx packet length low byte*/
+	unsigned char tcp_rx_frame_len_H;  /*tcp rx packet length high byte*/
+	unsigned char rsvd050;
+	unsigned char rsvd051;
+	unsigned char rsvd052;
+	unsigned char rsvd053;
+};
+
+struct fw_hdr {/*8-byte alinment required*/
+	unsigned short	signature;
+	unsigned short	version;	/*0x8000 ~ 0x8FFF for FPGA version,
+					 *0x0000 ~ 0x7FFF for ASIC version,*/
+	unsigned int		dmem_size;    /*define the size of boot loader*/
+	unsigned int		img_IMEM_size; /*define the size of FW in IMEM*/
+	unsigned int		img_SRAM_size; /*define the size of FW in SRAM*/
+	unsigned int		fw_priv_sz; /*define the size of DMEM variable*/
+	unsigned short	efuse_addr;
+	unsigned short	h2ccnd_resp_addr;
+	unsigned int		SVNRevision;
+	unsigned int		release_time; /*Mon:Day:Hr:Min*/
+	struct fw_priv	fwpriv;
+};
+
+struct hal_priv {
+	/*Endpoint handles*/
+	struct  net_device *pipehdls_r8712[10];
+	u8 (*hal_bus_init)(struct _adapter *adapter);
+};
+
+uint	 rtl8712_hal_init(struct _adapter *padapter);
+int rtl871x_load_fw(struct _adapter *padapter);
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h b/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h
new file mode 100644
index 0000000..49598c3
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_INTERRUPT_BITDEF_H__
+#define __RTL8712_INTERRUPT_BITDEF_H__
+
+/*HIMR*/
+/*HISR*/
+#define	_CPUERR					BIT(29)
+#define	_ATIMEND				BIT(28)
+#define	_TXBCNOK				BIT(27)
+#define	_TXBCNERR				BIT(26)
+#define	_BCNDMAINT4				BIT(25)
+#define	_BCNDMAINT3				BIT(24)
+#define	_BCNDMAINT2				BIT(23)
+#define	_BCNDMAINT1				BIT(22)
+#define	_BCNDOK4				BIT(21)
+#define	_BCNDOK3				BIT(20)
+#define	_BCNDOK2				BIT(19)
+#define	_BCNDOK1				BIT(18)
+#define	_TIMEOUT2				BIT(17)
+#define	_TIMEOUT1				BIT(16)
+#define	_TXFOVW					BIT(15)
+#define	_PSTIMEOUT				BIT(14)
+#define	_BCNDMAINT0				BIT(13)
+#define	_FOVW					BIT(12)
+#define	_RDU					BIT(11)
+#define	_RXCMDOK				BIT(10)
+#define	_BCNDOK0				BIT(9)
+#define	_HIGHDOK				BIT(8)
+#define	_COMDOK					BIT(7)
+#define	_MGTDOK					BIT(6)
+#define	_HCCADOK				BIT(5)
+#define	_BKDOK					BIT(4)
+#define	_BEDOK					BIT(3)
+#define	_VIDOK					BIT(2)
+#define	_VODOK					BIT(1)
+#define	_RXOK					BIT(0)
+
+
+#endif	/*__RTL8712_INTERRUPT_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_io.c b/drivers/staging/rtl8712/rtl8712_io.c
new file mode 100644
index 0000000..c734600
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_io.c
@@ -0,0 +1,151 @@
+/******************************************************************************
+ * rtl8712_io.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_IO_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_io.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+u8 r8712_read8(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u8 r_val;
+
+	_read8 = pintfhdl->io_ops._read8;
+	r_val = _read8(pintfhdl, addr);
+	return r_val;
+}
+
+u16 r8712_read16(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u16 r_val;
+
+	_read16 = pintfhdl->io_ops._read16;
+	r_val = _read16(pintfhdl, addr);
+	return r_val;
+}
+
+u32 r8712_read32(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	u32 r_val;
+
+	_read32 = pintfhdl->io_ops._read32;
+	r_val = _read32(pintfhdl, addr);
+	return r_val;
+}
+
+void r8712_write8(struct _adapter *adapter, u32 addr, u8 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+
+	_write8 = pintfhdl->io_ops._write8;
+	_write8(pintfhdl, addr, val);
+}
+
+void r8712_write16(struct _adapter *adapter, u32 addr, u16 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	_write16 = pintfhdl->io_ops._write16;
+	_write16(pintfhdl, addr, val);
+}
+
+void r8712_write32(struct _adapter *adapter, u32 addr, u32 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = (struct intf_hdl *)(&(pio_queue->intf));
+
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	_write32 = pintfhdl->io_ops._write32;
+	_write32(pintfhdl, addr, val);
+}
+
+void r8712_read_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true))
+		return;
+	_read_mem = pintfhdl->io_ops._read_mem;
+	_read_mem(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_write_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+
+	_write_mem = pintfhdl->io_ops._write_mem;
+	_write_mem(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_read_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &(pio_queue->intf);
+
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true))
+		return;
+	_read_port = pintfhdl->io_ops._read_port;
+	_read_port(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_write_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+	_write_port = pintfhdl->io_ops._write_port;
+	_write_port(pintfhdl, addr, cnt, pmem);
+}
diff --git a/drivers/staging/rtl8712/rtl8712_led.c b/drivers/staging/rtl8712/rtl8712_led.c
new file mode 100644
index 0000000..bac56e5
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_led.c
@@ -0,0 +1,1815 @@
+/******************************************************************************
+ * rtl8712_led.c
+ *
+ * Copyright(c) 2007 - 2010  Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#include "drv_types.h"
+
+/*===========================================================================
+ *	Constant.
+ *===========================================================================
+
+ *
+ * Default LED behavior.
+ */
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
+#define LED_BLINK_LINK_INTERVAL_ALPHA		500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+/*===========================================================================
+ * LED object.
+ *===========================================================================
+ */
+enum _LED_STATE_871x {
+	LED_UNKNOWN = 0,
+	LED_ON = 1,
+	LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_POWER_ON_BLINK = 5,
+	LED_SCAN_BLINK = 6, /* LED is blinking during scanning period,
+			     * the # of times to blink is depend on time
+			     * for scanning. */
+	LED_NO_LINK_BLINK = 7, /* LED is blinking during no link state. */
+	LED_BLINK_StartToBlink = 8,/* Customzied for Sercomm Printer
+				    * Server case */
+	LED_BLINK_WPS = 9,	/* LED is blinkg during WPS communication */
+	LED_TXRX_BLINK = 10,
+	LED_BLINK_WPS_STOP = 11,	/*for ALPHA */
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	/*for BELKIN */
+};
+
+/*===========================================================================
+ *	Prototype of protected function.
+ *===========================================================================
+ */
+static void BlinkTimerCallback(unsigned long data);
+
+static void BlinkWorkItemCallback(struct work_struct *work);
+/*===========================================================================
+ * LED_819xUsb routines.
+ *===========================================================================
+ *
+ *
+ *
+ *	Description:
+ *		Initialize an LED_871x object.
+ */
+static void InitLed871x(struct _adapter *padapter, struct LED_871x *pLed,
+		 enum LED_PIN_871x	LedPin)
+{
+	struct  net_device *nic;
+
+	nic = padapter->pnetdev;
+	pLed->padapter = padapter;
+	pLed->LedPin = LedPin;
+	pLed->CurrLedState = LED_OFF;
+	pLed->bLedOn = false;
+	pLed->bLedBlinkInProgress = false;
+	pLed->BlinkTimes = 0;
+	pLed->BlinkingLedState = LED_UNKNOWN;
+	_init_timer(&(pLed->BlinkTimer), nic, BlinkTimerCallback, pLed);
+	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+}
+
+/*
+ *	Description:
+ *		DeInitialize an LED_871x object.
+ */
+static void DeInitLed871x(struct LED_871x *pLed)
+{
+	_cancel_timer_ex(&(pLed->BlinkTimer));
+	/* We should reset bLedBlinkInProgress if we cancel
+	 * the LedControlTimer, */
+	pLed->bLedBlinkInProgress = false;
+}
+
+/*
+ *	Description:
+ *		Turn on LED according to LedPin specified.
+ */
+static void SwLedOn(struct _adapter *padapter, struct LED_871x *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) ||
+	    (padapter->bDriverStopped == true))
+		return;
+	LedCfg = r8712_read8(padapter, LEDCFG);
+	switch (pLed->LedPin) {
+	case LED_PIN_GPIO0:
+		break;
+	case LED_PIN_LED0:
+		/* SW control led0 on.*/
+		r8712_write8(padapter, LEDCFG, LedCfg&0xf0);
+		break;
+	case LED_PIN_LED1:
+		/* SW control led1 on.*/
+		r8712_write8(padapter, LEDCFG, LedCfg&0x0f);
+		break;
+	default:
+		break;
+	}
+	pLed->bLedOn = true;
+}
+
+/*
+ *	Description:
+ *		Turn off LED according to LedPin specified.
+ */
+static void SwLedOff(struct _adapter *padapter, struct LED_871x *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) ||
+	    (padapter->bDriverStopped == true))
+		return;
+	LedCfg = r8712_read8(padapter, LEDCFG);
+	switch (pLed->LedPin) {
+	case LED_PIN_GPIO0:
+		break;
+	case LED_PIN_LED0:
+		LedCfg &= 0xf0; /* Set to software control.*/
+		r8712_write8(padapter, LEDCFG, (LedCfg|BIT(3)));
+		break;
+	case LED_PIN_LED1:
+		LedCfg &= 0x0f; /* Set to software control.*/
+		r8712_write8(padapter, LEDCFG, (LedCfg|BIT(7)));
+		break;
+	default:
+		break;
+	}
+	pLed->bLedOn = false;
+}
+
+/*===========================================================================
+ * Interface to manipulate LED objects.
+ *===========================================================================
+ *
+ *	Description:
+ *		Initialize all LED_871x objects.
+ */
+void r8712_InitSwLeds(struct _adapter *padapter)
+{
+	struct led_priv	*pledpriv = &(padapter->ledpriv);
+
+	pledpriv->LedControlHandler = LedControl871x;
+	InitLed871x(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
+	InitLed871x(padapter, &(pledpriv->SwLed1), LED_PIN_LED1);
+}
+
+/*	Description:
+ *		DeInitialize all LED_819xUsb objects.
+ */
+void r8712_DeInitSwLeds(struct _adapter *padapter)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	DeInitLed871x(&(ledpriv->SwLed0));
+	DeInitLed871x(&(ledpriv->SwLed1));
+}
+
+/*	Description:
+ *		Implementation of LED blinking behavior.
+ *		It toggle off LED and schedule corresponding timer if necessary.
+ */
+static void SwLedBlink(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	/* Determine if we shall change LED state again. */
+	pLed->BlinkTimes--;
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_NORMAL:
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	case LED_BLINK_StartToBlink:
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		    (pmlmepriv->fw_state & WIFI_STATION_STATE))
+			bStopBlinking = true;
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		   ((pmlmepriv->fw_state & WIFI_ADHOC_STATE) ||
+		    (pmlmepriv->fw_state & WIFI_ADHOC_MASTER_STATE)))
+			bStopBlinking = true;
+		else if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	default:
+		bStopBlinking = true;
+		break;
+	}
+	if (bStopBlinking) {
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		    (pLed->bLedOn == false))
+			SwLedOn(padapter, pLed);
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED) ==
+			 true) &&  pLed->bLedOn == true)
+			SwLedOff(padapter, pLed);
+		pLed->BlinkTimes = 0;
+		pLed->bLedBlinkInProgress = false;
+	} else {
+		/* Assign LED state to toggle. */
+		if (pLed->BlinkingLedState == LED_ON)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+
+		/* Schedule a timer to toggle LED state. */
+		switch (pLed->CurrLedState) {
+		case LED_BLINK_NORMAL:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+			break;
+		case LED_BLINK_SLOWLY:
+		case LED_BLINK_StartToBlink:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		case LED_BLINK_WPS:
+			if (pLed->BlinkingLedState == LED_ON)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LONG_INTERVAL);
+			else
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LONG_INTERVAL);
+			break;
+		default:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		}
+	}
+}
+
+static void SwLedBlink1(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct led_priv *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct eeprom_priv *peeprompriv = &(padapter->eeprompriv);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+	u8 bStopBlinking = false;
+
+	if (peeprompriv->CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	if (peeprompriv->CustomerID == RT_CID_DEFAULT) {
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+			if (!pLed1->bSWLedCtrl) {
+				SwLedOn(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			} else if (!pLed1->bLedOn)
+				SwLedOn(padapter, pLed1);
+		} else {
+			if (!pLed1->bSWLedCtrl) {
+				SwLedOff(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			} else if (pLed1->bLedOn)
+				SwLedOff(padapter, pLed1);
+		}
+	}
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_SLOWLY:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_NORMAL:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->bLedLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LINK_INTERVAL_ALPHA);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->bLedLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LINK_INTERVAL_ALPHA);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			pLed->BlinkTimes = 0;
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_WPS_STOP:	/* WPS success */
+		if (pLed->BlinkingLedState == LED_ON) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			bStopBlinking = false;
+		} else
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		}
+		pLed->bLedWPSBlinkInProgress = false;
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink2(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				SwLedOff(padapter, pLed);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				SwLedOff(padapter, pLed);
+			}
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink3(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		if (pLed->CurrLedState != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				if (!pLed->bLedOn)
+					SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				if (pLed->bLedOn)
+					SwLedOff(padapter, pLed);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				if (!pLed->bLedOn)
+					SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				if (pLed->bLedOn)
+					SwLedOff(padapter, pLed);
+			}
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_WPS_STOP:	/*WPS success*/
+		if (pLed->BlinkingLedState == LED_ON) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			bStopBlinking = false;
+		} else
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			SwLedOn(padapter, pLed);
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink4(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	if (!pLed1->bLedWPSBlinkInProgress &&
+	    pLed1->BlinkingLedState == LED_UNKNOWN) {
+		pLed1->BlinkingLedState = LED_OFF;
+		pLed1->CurrLedState = LED_OFF;
+		SwLedOff(padapter, pLed1);
+	}
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_SLOWLY:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_StartToBlink:
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	case LED_BLINK_WPS_STOP:	/*WPS authentication fail*/
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_BLINK_WPS_STOP_OVERLAP:	/*WPS session overlap */
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0) {
+			if (pLed->bLedOn)
+				pLed->BlinkTimes = 1;
+			else
+				bStopBlinking = true;
+		}
+		if (bStopBlinking) {
+			pLed->BlinkTimes = 10;
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink5(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_FASTER_INTERVAL_ALPHA);
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_FASTER_INTERVAL_ALPHA);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink6(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				SwLedOn(padapter, pLed);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*	Description:
+ *		Callback function of LED BlinkTimer,
+ *		it just schedules to corresponding BlinkWorkItem.
+ */
+static void BlinkTimerCallback(unsigned long data)
+{
+	struct LED_871x  *pLed = (struct LED_871x *)data;
+
+	/* This fixed the crash problem on Fedora 12 when trying to do thei
+	 * insmod;ifconfig up;rmmod commands. */
+	if ((pLed->padapter->bSurpriseRemoved == true) ||
+	    (pLed->padapter->bDriverStopped == true))
+		return;
+	_set_workitem(&(pLed->BlinkWorkItem));
+}
+
+/*	Description:
+ *		Callback function of LED BlinkWorkItem.
+ *		We dispatch acture LED blink action according to LedStrategy.
+ */
+static void BlinkWorkItemCallback(struct work_struct *work)
+{
+	struct LED_871x *pLed = container_of(work, struct LED_871x,
+				BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+
+	switch (ledpriv->LedStrategy) {
+	case SW_LED_MODE0:
+		SwLedBlink(pLed);
+		break;
+	case SW_LED_MODE1:
+		SwLedBlink1(pLed);
+		break;
+	case SW_LED_MODE2:
+		SwLedBlink2(pLed);
+		break;
+	case SW_LED_MODE3:
+		SwLedBlink3(pLed);
+		break;
+	case SW_LED_MODE4:
+		SwLedBlink4(pLed);
+		break;
+	case SW_LED_MODE5:
+		SwLedBlink5(pLed);
+		break;
+	case SW_LED_MODE6:
+		SwLedBlink6(pLed);
+		break;
+	default:
+		SwLedBlink(pLed);
+		break;
+	}
+}
+
+/*============================================================================
+ * Default LED behavior.
+ *============================================================================
+ *
+ *	Description:
+ *		Implement each led action for SW_LED_MODE0.
+ *		This is default strategy.
+ */
+
+static void SwLedControlMode1(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv *ledpriv = &(padapter->ledpriv);
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sitesurvey_ctrl *psitesurveyctrl = &(pmlmepriv->sitesurveyctrl);
+
+	if (padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	switch (LedAction) {
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (pLed->bLedNoLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			  IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_LINK:
+		if (pLed->bLedLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((psitesurveyctrl->traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			; /* dummy branch */
+		 else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		 }
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+
+	case LED_CTL_START_WPS: /*wait until xinpin finish */
+	case LED_CTL_START_WPS_BOTTON:
+		 if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedNoLinkBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			 pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+		else
+			pLed->bLedWPSBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedNoLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode2(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	 *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_SITE_SURVEY:
+		 if (pmlmepriv->sitesurveyctrl.traffic_busy)
+			; /* dummy branch */
+		 else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		 }
+		break;
+
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if ((pLed->bLedBlinkInProgress == false) &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			   IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+
+	case LED_CTL_LINK:
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		 }
+		break;
+
+	case LED_CTL_STOP_WPS:
+		pLed->bLedWPSBlinkInProgress = false;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_STOP_WPS_FAIL:
+		pLed->bLedWPSBlinkInProgress = false;
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (!IS_LED_BLINKING(pLed)) {
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode3(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_SITE_SURVEY:
+		if (pmlmepriv->sitesurveyctrl.traffic_busy)
+			; /* dummy branch */
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if ((pLed->bLedBlinkInProgress == false) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_LINK:
+		if (IS_LED_WPS_BLINKING(pLed))
+			return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_START_WPS: /* wait until xinpin finish */
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		} else
+			pLed->bLedWPSBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (!IS_LED_BLINKING(pLed)) {
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode4(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+
+	switch (LedAction) {
+	case LED_CTL_START_TO_LINK:
+		if (pLed1->bLedWPSBlinkInProgress) {
+			pLed1->bLedWPSBlinkInProgress = false;
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->BlinkingLedState = LED_OFF;
+			pLed1->CurrLedState = LED_OFF;
+			if (pLed1->bLedOn)
+				_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		if (pLed->bLedStartToLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			pLed->bLedStartToLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			if (pLed->bLedOn) {
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_SLOWLY_INTERVAL);
+			} else {
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NORMAL_INTERVAL);
+			}
+		}
+		break;
+	case LED_CTL_LINK:
+	case LED_CTL_NO_LINK:
+		/*LED1 settings*/
+		if (LedAction == LED_CTL_LINK) {
+			if (pLed1->bLedWPSBlinkInProgress) {
+				pLed1->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+				if (pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+		}
+		if (pLed->bLedNoLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((pmlmepriv->sitesurveyctrl.traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			;
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed1->bLedWPSBlinkInProgress) {
+			pLed1->bLedWPSBlinkInProgress = false;
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->BlinkingLedState = LED_OFF;
+			pLed1->CurrLedState = LED_OFF;
+			if (pLed1->bLedOn)
+				_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn) {
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_SLOWLY_INTERVAL);
+			} else {
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NORMAL_INTERVAL);
+			}
+		}
+		break;
+	case LED_CTL_STOP_WPS:	/*WPS connect success*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_CTL_STOP_WPS_FAIL:	/*WPS authentication fail*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		/*LED1 settings*/
+		if (pLed1->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+		else
+			pLed1->bLedWPSBlinkInProgress = true;
+		pLed1->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed1->bLedOn)
+			pLed1->BlinkingLedState = LED_OFF;
+		else
+			pLed1->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_CTL_STOP_WPS_FAIL_OVERLAP:	/*WPS session overlap*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		/*LED1 settings*/
+		if (pLed1->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+		else
+			pLed1->bLedWPSBlinkInProgress = true;
+		pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
+		pLed1->BlinkTimes = 10;
+		if (pLed1->bLedOn)
+			pLed1->BlinkingLedState = LED_OFF;
+		else
+			pLed1->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedNoLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedStartToLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedStartToLinkBlinkInProgress = false;
+		}
+		if (pLed1->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->bLedWPSBlinkInProgress = false;
+		}
+		pLed1->BlinkingLedState = LED_UNKNOWN;
+		SwLedOff(padapter, pLed);
+		SwLedOff(padapter, pLed1);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode5(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	if (padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+
+	switch (LedAction) {
+	case LED_CTL_POWER_ON:
+	case LED_CTL_NO_LINK:
+	case LED_CTL_LINK:	/* solid blue */
+		if (pLed->CurrLedState == LED_SCAN_BLINK)
+			return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		pLed->bLedBlinkInProgress = false;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((pmlmepriv->sitesurveyctrl.traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			; /* dummy branch */
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK)
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+	default:
+		break;
+	}
+}
+
+
+static void SwLedControlMode6(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_POWER_ON:
+	case LED_CTL_NO_LINK:
+	case LED_CTL_LINK:	/*solid blue*/
+	case LED_CTL_SITE_SURVEY:
+		if (IS_LED_WPS_BLINKING(pLed))
+				return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		pLed->bLedBlinkInProgress = false;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+	default:
+		break;
+	}
+}
+
+/*	Description:
+ *		Dispatch LED action according to pHalData->LedStrategy.
+ */
+void LedControl871x(struct _adapter *padapter, enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	if (ledpriv->bRegUseLed == false)
+		return;
+	switch (ledpriv->LedStrategy) {
+	case SW_LED_MODE0:
+		break;
+	case SW_LED_MODE1:
+		SwLedControlMode1(padapter, LedAction);
+		break;
+	case SW_LED_MODE2:
+		SwLedControlMode2(padapter, LedAction);
+		break;
+	case SW_LED_MODE3:
+		SwLedControlMode3(padapter, LedAction);
+		break;
+	case SW_LED_MODE4:
+		SwLedControlMode4(padapter, LedAction);
+		break;
+	case SW_LED_MODE5:
+		SwLedControlMode5(padapter, LedAction);
+		break;
+	case SW_LED_MODE6:
+		SwLedControlMode6(padapter, LedAction);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h b/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h
new file mode 100644
index 0000000..28e0a7e
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_MACSETTING_BITDEF_H__
+#define __RTL8712_MACSETTING_BITDEF_H__
+
+
+/*MACID*/
+/*BSSID*/
+
+/*HWVID*/
+#define	_HWVID_MSK				0x0F
+
+/*MAR*/
+/*MBIDCANCONTENT*/
+
+/*MBIDCANCFG*/
+#define	_POOLING				BIT(31)
+#define	_WRITE_EN				BIT(16)
+#define	_CAM_ADDR_MSK			0x001F
+#define	_CAM_ADDR_SHT			0
+
+/*BUILDTIME*/
+#define _BUILDTIME_MSK			0x3FFFFFFF
+
+/*BUILDUSER*/
+
+
+
+#endif /* __RTL8712_MACSETTING_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h b/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h
new file mode 100644
index 0000000..ced0da9
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_MACSETTING_REGDEF_H__
+#define __RTL8712_MACSETTING_REGDEF_H__
+
+#define MACID				(RTL8712_MACIDSETTING_ + 0x0000)
+#define BSSIDR				(RTL8712_MACIDSETTING_ + 0x0008)
+#define HWVID				(RTL8712_MACIDSETTING_ + 0x000E)
+#define MAR				(RTL8712_MACIDSETTING_ + 0x0010)
+#define MBIDCANCONTENT			(RTL8712_MACIDSETTING_ + 0x0018)
+#define MBIDCANCFG			(RTL8712_MACIDSETTING_ + 0x0020)
+#define BUILDTIME			(RTL8712_MACIDSETTING_ + 0x0024)
+#define BUILDUSER			(RTL8712_MACIDSETTING_ + 0x0028)
+
+
+
+#endif /*__RTL8712_MACSETTING_REGDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h b/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h
new file mode 100644
index 0000000..8fc6894
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_POWERSAVE_BITDEF_H__
+#define __RTL8712_POWERSAVE_BITDEF_H__
+
+/*WOWCTRL*/
+#define	_UWF			BIT(3)
+#define	_MAGIC			BIT(2)
+#define	_WOW_EN			BIT(1)
+#define	_PMEN			BIT(0)
+
+/*PSSTATUS*/
+#define	_PSSTATUS_SEL_MSK		0x0F
+
+/*PSSWITCH*/
+#define	_PSSWITCH_ACT			BIT(7)
+#define	_PSSWITCH_SEL_MSK		0x0F
+#define	_PSSWITCH_SEL_SHT		0
+
+/*LPNAV_CTRL*/
+#define	_LPNAV_EN			BIT(31)
+#define	_LPNAV_EARLY_MSK		0x7FFF0000
+#define	_LPNAV_EARLY_SHT		16
+#define	_LPNAV_TH_MSK			0x0000FFFF
+#define	_LPNAV_TH_SHT			0
+
+/*RPWM*/
+/*CPWM*/
+#define	_TOGGLING			BIT(7)
+#define	_WWLAN				BIT(3)
+#define	_RPS_ST				BIT(2)
+#define	_WLAN_TRX			BIT(1)
+#define	_SYS_CLK			BIT(0)
+
+#endif /* __RTL8712_POWERSAVE_BITDEF_H__*/
diff --git a/drivers/staging/rtl8712/rtl8712_powersave_regdef.h b/drivers/staging/rtl8712/rtl8712_powersave_regdef.h
new file mode 100644
index 0000000..4632ddd
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_powersave_regdef.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_POWERSAVE_REGDEF_H__
+#define __RTL8712_POWERSAVE_REGDEF_H__
+
+#define WOWCTRL				(RTL8712_POWERSAVE_ + 0x00)
+#define PSSTATUS			(RTL8712_POWERSAVE_ + 0x01)
+#define PSSWITCH			(RTL8712_POWERSAVE_ + 0x02)
+#define MIMOPS_WAITPERIOD		(RTL8712_POWERSAVE_ + 0x03)
+#define LPNAV_CTRL			(RTL8712_POWERSAVE_ + 0x04)
+#define WFM0				(RTL8712_POWERSAVE_ + 0x10)
+#define WFM1				(RTL8712_POWERSAVE_ + 0x20)
+#define WFM2				(RTL8712_POWERSAVE_ + 0x30)
+#define WFM3				(RTL8712_POWERSAVE_ + 0x40)
+#define WFM4				(RTL8712_POWERSAVE_ + 0x50)
+#define WFM5				(RTL8712_POWERSAVE_ + 0x60)
+#define WFCRC				(RTL8712_POWERSAVE_ + 0x70)
+#define RPWM				(RTL8712_POWERSAVE_ + 0x7C)
+#define CPWM				(RTL8712_POWERSAVE_ + 0x7D)
+
+#endif /* __RTL8712_POWERSAVE_REGDEF_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h b/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h
new file mode 100644
index 0000000..6d3d6e8
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_RATECTRL_BITDEF_H__
+#define __RTL8712_RATECTRL_BITDEF_H__
+
+/*INIRTSMCS_SEL*/
+#define	_INIRTSMCS_SEL_MSK		0x3F
+
+/* RRSR*/
+#define	_RRSR_SHORT			BIT(23)
+#define	_RRSR_RSC_MSK		0x600000
+#define	_RRSR_RSC_SHT		21
+#define	_RRSR_BITMAP_MSK	0x0FFFFF
+#define	_RRSR_BITMAP_SHT	0
+
+/* AGGLEN_LMT_H*/
+#define	_AGGLMT_MCS32_MSK			0xF0
+#define	_AGGLMT_MCS32_SHT			4
+#define	_AGGLMT_MCS15_SGI_MSK		0x0F
+#define	_AGGLMT_MCS15_SGI_SHT		0
+
+/* DARFRC*/
+/* RARFRC*/
+/* MCS_TXAGC*/
+/* CCK_TXAGC*/
+#define	_CCK_MSK			0xFF00
+#define	_CCK_SHT			8
+#define	_BARKER_MSK			0x00FF
+#define	_BARKER_SHT			0
+
+#endif	/*	__RTL8712_RATECTRL_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h b/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h
new file mode 100644
index 0000000..73dfc36
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_RATECTRL_REGDEF_H__
+#define __RTL8712_RATECTRL_REGDEF_H__
+
+#define INIMCS_SEL			(RTL8712_RATECTRL_ + 0x00)
+#define INIRTSMCS_SEL		(RTL8712_RATECTRL_ + 0x20)
+#define RRSR				(RTL8712_RATECTRL_ + 0x21)
+#define ARFR0				(RTL8712_RATECTRL_ + 0x24)
+#define ARFR1				(RTL8712_RATECTRL_ + 0x28)
+#define ARFR2				(RTL8712_RATECTRL_ + 0x2C)
+#define ARFR3				(RTL8712_RATECTRL_ + 0x30)
+#define ARFR4				(RTL8712_RATECTRL_ + 0x34)
+#define ARFR5				(RTL8712_RATECTRL_ + 0x38)
+#define ARFR6				(RTL8712_RATECTRL_ + 0x3C)
+#define ARFR7				(RTL8712_RATECTRL_ + 0x40)
+#define AGGLEN_LMT_H		(RTL8712_RATECTRL_ + 0x47)
+#define AGGLEN_LMT_L		(RTL8712_RATECTRL_ + 0x48)
+#define DARFRC				(RTL8712_RATECTRL_ + 0x50)
+#define RARFRC				(RTL8712_RATECTRL_ + 0x58)
+#define MCS_TXAGC0			(RTL8712_RATECTRL_ + 0x60)
+#define MCS_TXAGC1			(RTL8712_RATECTRL_ + 0x61)
+#define MCS_TXAGC2			(RTL8712_RATECTRL_ + 0x62)
+#define MCS_TXAGC3			(RTL8712_RATECTRL_ + 0x63)
+#define MCS_TXAGC4			(RTL8712_RATECTRL_ + 0x64)
+#define MCS_TXAGC5			(RTL8712_RATECTRL_ + 0x65)
+#define MCS_TXAGC6			(RTL8712_RATECTRL_ + 0x66)
+#define MCS_TXAGC7			(RTL8712_RATECTRL_ + 0x67)
+#define CCK_TXAGC			(RTL8712_RATECTRL_ + 0x68)
+
+
+#endif	/*__RTL8712_RATECTRL_REGDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c
new file mode 100644
index 0000000..6d69265
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_recv.c
@@ -0,0 +1,1133 @@
+/******************************************************************************
+ * rtl8712_recv.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_RECV_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "ip.h"
+#include "if_ether.h"
+#include "ethernet.h"
+#include "usb_ops.h"
+#include "wifi.h"
+
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 bridge_tunnel_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static u8 rfc1042_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+static void recv_tasklet(void *priv);
+
+int r8712_init_recv_priv(struct recv_priv *precvpriv, struct _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	int res = _SUCCESS;
+	addr_t tmpaddr = 0;
+	int alignment = 0;
+	struct sk_buff *pskb = NULL;
+
+	sema_init(&precvpriv->recv_sema, 0);
+	sema_init(&precvpriv->terminate_recvthread_sema, 0);
+	/*init recv_buf*/
+	_init_queue(&precvpriv->free_recv_buf_queue);
+	precvpriv->pallocated_recv_buf = _malloc(NR_RECVBUFF *
+					 sizeof(struct recv_buf) + 4);
+	if (precvpriv->pallocated_recv_buf == NULL)
+		return _FAIL;
+	memset(precvpriv->pallocated_recv_buf, 0, NR_RECVBUFF *
+		sizeof(struct recv_buf) + 4);
+	precvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -
+			      ((addr_t) (precvpriv->pallocated_recv_buf) & 3);
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		_init_listhead(&precvbuf->list);
+		spin_lock_init(&precvbuf->recvbuf_lock);
+		res = r8712_os_recvbuf_resource_alloc(padapter, precvbuf);
+		if (res == _FAIL)
+			break;
+		precvbuf->ref_cnt = 0;
+		precvbuf->adapter = padapter;
+		list_insert_tail(&precvbuf->list,
+				 &(precvpriv->free_recv_buf_queue.queue));
+		precvbuf++;
+	}
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))recv_tasklet,
+	     (unsigned long)padapter);
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+	skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+	for (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {
+		pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ +
+		       RECVBUFF_ALIGN_SZ);
+		if (pskb) {
+			pskb->dev = padapter->pnetdev;
+			tmpaddr = (addr_t)pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));
+			skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+		}
+		pskb = NULL;
+	}
+	return res;
+}
+
+void r8712_free_recv_priv(struct recv_priv *precvpriv)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	struct _adapter *padapter = precvpriv->adapter;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF ; i++) {
+		r8712_os_recvbuf_resource_free(padapter, precvbuf);
+		precvbuf++;
+	}
+	kfree(precvpriv->pallocated_recv_buf);
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+	if (skb_queue_len(&precvpriv->rx_skb_queue))
+		printk(KERN_WARNING "r8712u: rx_skb_queue not empty\n");
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue))
+		printk(KERN_WARNING "r8712u: free_recv_skb_queue not empty "
+		       "%d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+}
+
+int r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res = _SUCCESS;
+
+	precvbuf->transfer_len = 0;
+	precvbuf->len = 0;
+	precvbuf->ref_cnt = 0;
+	if (precvbuf->pbuf) {
+		precvbuf->pdata = precvbuf->pbuf;
+		precvbuf->phead = precvbuf->pbuf;
+		precvbuf->ptail = precvbuf->pbuf;
+		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
+	}
+	return res;
+}
+
+int r8712_free_recvframe(union recv_frame *precvframe,
+		   struct  __queue *pfree_recv_queue)
+{
+	unsigned long irqL;
+	struct _adapter *padapter = precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	if (precvframe->u.hdr.pkt) {
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);/*free skb by driver*/
+		precvframe->u.hdr.pkt = NULL;
+	}
+	spin_lock_irqsave(&pfree_recv_queue->lock, irqL);
+	list_delete(&(precvframe->u.hdr.list));
+	list_insert_tail(&(precvframe->u.hdr.list),
+			 get_list_head(pfree_recv_queue));
+	if (padapter != NULL) {
+		if (pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+	spin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);
+	return _SUCCESS;
+}
+
+static void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib *pattrib,
+					   struct recv_stat *prxstat)
+{
+	u32 *pphy_info;
+	struct phy_stat *pphy_stat;
+	u16 drvinfo_sz = 0;
+
+	drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;
+	drvinfo_sz = drvinfo_sz<<3;
+	/*TODO:
+	 * Offset 0 */
+	pattrib->bdecrypted = ((le32_to_cpu(prxstat->rxdw0) & BIT(27)) >> 27)
+				 ? 0 : 1;
+	pattrib->crc_err = ((le32_to_cpu(prxstat->rxdw0) & BIT(14)) >> 14);
+	/*Offset 4*/
+	/*Offset 8*/
+	/*Offset 12*/
+	if (le32_to_cpu(prxstat->rxdw3) & BIT(13)) {
+		pattrib->tcpchk_valid = 1; /* valid */
+		if (le32_to_cpu(prxstat->rxdw3) & BIT(11))
+			pattrib->tcp_chkrpt = 1; /* correct */
+		else
+			pattrib->tcp_chkrpt = 0; /* incorrect */
+		if (le32_to_cpu(prxstat->rxdw3) & BIT(12))
+			pattrib->ip_chkrpt = 1; /* correct */
+		else
+			pattrib->ip_chkrpt = 0; /* incorrect */
+	} else
+		pattrib->tcpchk_valid = 0; /* invalid */
+	pattrib->mcs_rate = (u8)((le32_to_cpu(prxstat->rxdw3)) & 0x3f);
+	pattrib->htc = (u8)((le32_to_cpu(prxstat->rxdw3) >> 14) & 0x1);
+	/*Offset 16*/
+	/*Offset 20*/
+	/*phy_info*/
+	if (drvinfo_sz) {
+		pphy_stat = (struct phy_stat *)(prxstat+1);
+		pphy_info = (u32 *)prxstat+1;
+	}
+}
+
+/*perform defrag*/
+static union recv_frame *recvframe_defrag(struct _adapter *adapter,
+				   struct  __queue *defrag_q)
+{
+	struct list_head *plist, *phead;
+	u8	*data, wlanhdr_offset;
+	u8	curfragnum;
+	struct recv_frame_hdr *pfhdr, *pnfhdr;
+	union recv_frame *prframe, *pnextrframe;
+	struct  __queue	*pfree_recv_queue;
+
+	pfree_recv_queue = &adapter->recvpriv.free_recv_queue;
+	phead = get_list_head(defrag_q);
+	plist = get_next(phead);
+	prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+	list_delete(&prframe->u.list);
+	pfhdr = &prframe->u.hdr;
+	curfragnum = 0;
+	if (curfragnum != pfhdr->attrib.frag_num) {
+		/*the first fragment number must be 0
+		 *free the whole queue*/
+		r8712_free_recvframe(prframe, pfree_recv_queue);
+		r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+		return NULL;
+	}
+	curfragnum++;
+	plist = get_list_head(defrag_q);
+	plist = get_next(plist);
+	data = get_recvframe_data(prframe);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnfhdr = &pnextrframe->u.hdr;
+		/*check the fragment sequence  (2nd ~n fragment frame) */
+		if (curfragnum != pnfhdr->attrib.frag_num) {
+			/* the fragment number must increase  (after decache)
+			 * release the defrag_q & prframe */
+			r8712_free_recvframe(prframe, pfree_recv_queue);
+			r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+			return NULL;
+		}
+		curfragnum++;
+		/* copy the 2nd~n fragment frame's payload to the first fragment
+		 * get the 2nd~last fragment frame's payload */
+		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+		/* append  to first fragment frame's tail (if privacy frame,
+		 * pull the ICV) */
+		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
+		memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
+		recvframe_put(prframe, pnfhdr->len);
+		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
+		plist = get_next(plist);
+	}
+	/* free the defrag_q queue and return the prframe */
+	r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+	return prframe;
+}
+
+/* check if need to defrag, if needed queue the frame to defrag_q */
+union recv_frame *r8712_recvframe_chk_defrag(struct _adapter *padapter,
+					     union recv_frame *precv_frame)
+{
+	u8	ismfrag;
+	u8	fragnum;
+	u8   *psta_addr;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct	sta_priv *pstapriv ;
+	struct list_head *phead;
+	union recv_frame *prtnframe = NULL;
+	struct  __queue *pfree_recv_queue, *pdefrag_q;
+
+	pstapriv = &padapter->stapriv;
+	pfhdr = &precv_frame->u.hdr;
+	pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	/* need to define struct of wlan header frame ctrl */
+	ismfrag = pfhdr->attrib.mfrag;
+	fragnum = pfhdr->attrib.frag_num;
+	psta_addr = pfhdr->attrib.ta;
+	psta = r8712_get_stainfo(pstapriv, psta_addr);
+	if (psta == NULL)
+		pdefrag_q = NULL;
+	else
+		pdefrag_q = &psta->sta_recvpriv.defrag_q;
+
+	if ((ismfrag == 0) && (fragnum == 0))
+		prtnframe = precv_frame;/*isn't a fragment frame*/
+	if (ismfrag == 1) {
+		/* 0~(n-1) fragment frame
+		 * enqueue to defraf_g */
+		if (pdefrag_q != NULL) {
+			if (fragnum == 0) {
+				/*the first fragment*/
+				if (_queue_empty(pdefrag_q) == false) {
+					/*free current defrag_q */
+					r8712_free_recvframe_queue(pdefrag_q,
+							     pfree_recv_queue);
+				}
+			}
+			/* Then enqueue the 0~(n-1) fragment to the defrag_q */
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list, phead);
+			prtnframe = NULL;
+		} else {
+			/* can't find this ta's defrag_queue, so free this
+			 * recv_frame */
+			r8712_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+
+	}
+	if ((ismfrag == 0) && (fragnum != 0)) {
+		/* the last fragment frame
+		 * enqueue the last fragment */
+		if (pdefrag_q != NULL) {
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list, phead);
+			/*call recvframe_defrag to defrag*/
+			precv_frame = recvframe_defrag(padapter, pdefrag_q);
+			prtnframe = precv_frame;
+		} else {
+			/* can't find this ta's defrag_queue, so free this
+			 *  recv_frame */
+			r8712_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+	}
+	if ((prtnframe != NULL) && (prtnframe->u.hdr.attrib.privacy)) {
+		/* after defrag we must check tkip mic code */
+		if (r8712_recvframe_chkmic(padapter, prtnframe) == _FAIL) {
+			r8712_free_recvframe(prtnframe, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+	}
+	return prtnframe;
+}
+
+static int amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe)
+{
+	int	a_len, padding_len;
+	u16	eth_type, nSubframe_Length;
+	u8	nr_subframes, i;
+	unsigned char *data_ptr, *pdata;
+	struct rx_pkt_attrib *pattrib;
+	_pkt *sub_skb, *subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct  __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int	ret = _SUCCESS;
+
+	nr_subframes = 0;
+	pattrib = &prframe->u.hdr.attrib;
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+	if (prframe->u.hdr.attrib.iv_len > 0)
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	a_len = prframe->u.hdr.len;
+	pdata = prframe->u.hdr.rx_data;
+	while (a_len > ETH_HLEN) {
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16 *)(pdata + 12));
+		/*==m==>change the length order*/
+		nSubframe_Length = (nSubframe_Length >> 8) +
+				   (nSubframe_Length << 8);
+		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+			printk(KERN_WARNING "r8712u: nRemain_Length is %d and"
+			    " nSubframe_Length is: %d\n",
+			    a_len, nSubframe_Length);
+			goto exit;
+		}
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+		/* Allocate new skb for releasing to upper layer */
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		memcpy(data_ptr, pdata, nSubframe_Length);
+		subframes[nr_subframes++] = sub_skb;
+		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
+			printk(KERN_WARNING "r8712u: ParseSubframe(): Too"
+			    " many Subframes! Packets dropped!\n");
+			break;
+		}
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if (a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & 3);
+			if (padding_len == 4)
+				padding_len = 0;
+			if (a_len < padding_len)
+				goto exit;
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+	for (i = 0; i < nr_subframes; i++) {
+		sub_skb = subframes[i];
+		/* convert hdr + possible LLC headers into Ethernet header */
+		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
+		if (sub_skb->len >= 8 &&
+		   ((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&
+		   eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		   !memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and
+			 * replace EtherType */
+			skb_pull(sub_skb, SNAP_SIZE);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+				ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+				ETH_ALEN);
+		} else {
+			u16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+			len = htons(sub_skb->len);
+			memcpy(skb_push(sub_skb, 2), &len, 2);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+				ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+				ETH_ALEN);
+		}
+		/* Indicate the packets to upper layer */
+		if (sub_skb) {
+			sub_skb->protocol =
+				 eth_type_trans(sub_skb, padapter->pnetdev);
+			sub_skb->dev = padapter->pnetdev;
+			if ((pattrib->tcpchk_valid == 1) &&
+			    (pattrib->tcp_chkrpt == 1)) {
+				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+			} else
+				sub_skb->ip_summed = CHECKSUM_NONE;
+			netif_rx(sub_skb);
+		}
+	}
+exit:
+	prframe->u.hdr.len = 0;
+	r8712_free_recvframe(prframe, pfree_recv_queue);
+	return ret;
+}
+
+void r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf)
+{
+	uint voffset;
+	u8 *poffset;
+	u16 pkt_len, cmd_len, drvinfo_sz;
+	u8 eid, cmd_seq;
+	struct recv_stat *prxstat;
+
+	poffset = (u8 *)prxcmdbuf;
+	voffset = *(uint *)poffset;
+	pkt_len = le32_to_cpu(voffset) & 0x00003fff;
+	prxstat = (struct recv_stat *)prxcmdbuf;
+	drvinfo_sz = ((le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16);
+	drvinfo_sz = drvinfo_sz << 3;
+	poffset += RXDESC_SIZE + drvinfo_sz;
+	do {
+		voffset  = *(uint *)poffset;
+		cmd_len = (u16)(le32_to_cpu(voffset) & 0xffff);
+		cmd_seq = (u8)((le32_to_cpu(voffset) >> 24) & 0x7f);
+		eid = (u8)((le32_to_cpu(voffset) >> 16) & 0xff);
+		r8712_event_handle(padapter, (uint *)poffset);
+		poffset += (cmd_len + 8);/*8 bytes aligment*/
+	} while (le32_to_cpu(voffset) & BIT(31));
+
+}
+
+static int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl,
+			      u16 seq_num)
+{
+	u8 wsize = preorder_ctrl->wsize_b;
+	u16 wend = (preorder_ctrl->indicate_seq + wsize - 1) % 4096;
+
+	/* Rx Reorder initialize condition.*/
+	if (preorder_ctrl->indicate_seq == 0xffff)
+		preorder_ctrl->indicate_seq = seq_num;
+	/* Drop out the packet which SeqNum is smaller than WinStart */
+	if (SN_LESS(seq_num, preorder_ctrl->indicate_seq))
+		return false;
+	/*
+	 * Sliding window manipulation. Conditions includes:
+	 * 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	 * 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	 */
+	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq +
+					      1) % 4096;
+	else if (SN_LESS(wend, seq_num)) {
+		if (seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 - wsize;
+		else
+			preorder_ctrl->indicate_seq = 4095 - (wsize -
+						      (seq_num + 1)) + 1;
+	}
+	return true;
+}
+
+static int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl,
+			      union recv_frame *prframe)
+{
+	struct list_head *phead, *plist;
+	union recv_frame *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+	struct  __queue *ppending_recvframe_queue =
+					&preorder_ctrl->pending_recvframe_queue;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnextattrib = &pnextrframe->u.hdr.attrib;
+		if (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+			plist = get_next(plist);
+		else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+			return false;
+		else
+			break;
+	}
+	list_delete(&(prframe->u.hdr.list));
+	list_insert_tail(&(prframe->u.hdr.list), plist);
+	return true;
+}
+
+int r8712_recv_indicatepkts_in_order(struct _adapter *padapter,
+			       struct recv_reorder_ctrl *preorder_ctrl,
+			       int bforced)
+{
+	struct list_head *phead, *plist;
+	union recv_frame *prframe;
+	struct rx_pkt_attrib *pattrib;
+	int bPktInBuf = false;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct  __queue *ppending_recvframe_queue =
+			 &preorder_ctrl->pending_recvframe_queue;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+	/* Handling some condition for forced indicate case.*/
+	if (bforced == true) {
+		if (is_list_empty(phead))
+			return true;
+		else {
+			prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+			pattrib = &prframe->u.hdr.attrib;
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+		}
+	}
+	/* Prepare indication list and indication.
+	 * Check if there is any packet need indicate. */
+	while (!is_list_empty(phead)) {
+		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pattrib = &prframe->u.hdr.attrib;
+		if (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+			plist = get_next(plist);
+			list_delete(&(prframe->u.hdr.list));
+			if (SN_EQUAL(preorder_ctrl->indicate_seq,
+			    pattrib->seq_num))
+				preorder_ctrl->indicate_seq =
+				  (preorder_ctrl->indicate_seq + 1) % 4096;
+			/*indicate this recv_frame*/
+			if (!pattrib->amsdu) {
+				if ((padapter->bDriverStopped == false) &&
+				    (padapter->bSurpriseRemoved == false)) {
+					/* indicate this recv_frame */
+					r8712_recv_indicatepkt(padapter,
+							       prframe);
+				}
+			} else if (pattrib->amsdu == 1) {
+				if (amsdu_to_msdu(padapter, prframe) !=
+				    _SUCCESS)
+					r8712_free_recvframe(prframe,
+						   &precvpriv->free_recv_queue);
+			}
+			/* Update local variables. */
+			bPktInBuf = false;
+		} else {
+			bPktInBuf = true;
+			break;
+		}
+	}
+	return bPktInBuf;
+}
+
+static int recv_indicatepkt_reorder(struct _adapter *padapter,
+			     union recv_frame *prframe)
+{
+	unsigned long irql;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
+	struct  __queue *ppending_recvframe_queue =
+			 &preorder_ctrl->pending_recvframe_queue;
+
+	if (!pattrib->amsdu) {
+		/* s1. */
+		r8712_wlanhdr_to_ethhdr(prframe);
+		if (pattrib->qos != 1) {
+			if ((padapter->bDriverStopped == false) &&
+			   (padapter->bSurpriseRemoved == false)) {
+				r8712_recv_indicatepkt(padapter, prframe);
+				return _SUCCESS;
+			} else
+				return _FAIL;
+		}
+	}
+	spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
+	/*s2. check if winstart_b(indicate_seq) needs to been updated*/
+	if (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+		goto _err_exit;
+	/*s3. Insert all packet into Reorder Queue to maintain its ordering.*/
+	if (!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+		goto _err_exit;
+	/*s4.
+	 * Indication process.
+	 * After Packet dropping and Sliding Window shifting as above, we can
+	 * now just indicate the packets with the SeqNum smaller than latest
+	 * WinStart and buffer other packets.
+	 *
+	 * For Rx Reorder condition:
+	 * 1. All packets with SeqNum smaller than WinStart => Indicate
+	 * 2. All packets with SeqNum larger than or equal to
+	 * WinStart => Buffer it.
+	 */
+	if (r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, false) ==
+	    true) {
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer,
+			   REORDER_WAIT_TIME);
+		spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+	} else {
+		spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+	return _SUCCESS;
+_err_exit:
+	spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+	return _FAIL;
+}
+
+void r8712_reordering_ctrl_timeout_handler(void *pcontext)
+{
+	unsigned long irql;
+	struct recv_reorder_ctrl *preorder_ctrl =
+				 (struct recv_reorder_ctrl *)pcontext;
+	struct _adapter *padapter = preorder_ctrl->padapter;
+	struct  __queue *ppending_recvframe_queue =
+				 &preorder_ctrl->pending_recvframe_queue;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
+		return;
+	spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
+	r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, true);
+	spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+}
+
+static int r8712_process_recv_indicatepkts(struct _adapter *padapter,
+			      union recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	if (phtpriv->ht_option == 1) { /*B/G/N Mode*/
+		if (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {
+			/* including perform A-MPDU Rx Ordering Buffer Control*/
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false))
+				return _FAIL;
+		}
+	} else { /*B/G mode*/
+		retval = r8712_wlanhdr_to_ethhdr(prframe);
+		if (retval != _SUCCESS)
+			return retval;
+		if ((padapter->bDriverStopped == false) &&
+		    (padapter->bSurpriseRemoved == false)) {
+			/* indicate this recv_frame */
+			r8712_recv_indicatepkt(padapter, prframe);
+		} else
+			return _FAIL;
+	}
+	return retval;
+}
+
+static u8 query_rx_pwr_percentage(s8 antpower)
+{
+	if ((antpower <= -100) || (antpower >= 20))
+		return	0;
+	else if (antpower >= 0)
+		return	100;
+	else
+		return 100 + antpower;
+}
+
+static u8 evm_db2percentage(s8 value)
+{
+	/*
+	 * -33dB~0dB to 0%~99%
+	 */
+	s8 ret_val;
+
+	ret_val = value;
+	if (ret_val >= 0)
+		ret_val = 0;
+	if (ret_val <= -33)
+		ret_val = -33;
+	ret_val = -ret_val;
+	ret_val *= 3;
+	if (ret_val == 99)
+		ret_val = 100;
+	return ret_val;
+}
+
+s32 r8712_signal_scale_mapping(s32 cur_sig)
+{
+	s32 ret_sig;
+
+	if (cur_sig >= 51 && cur_sig <= 100)
+		ret_sig = 100;
+	else if (cur_sig >= 41 && cur_sig <= 50)
+		ret_sig = 80 + ((cur_sig - 40) * 2);
+	else if (cur_sig >= 31 && cur_sig <= 40)
+		ret_sig = 66 + (cur_sig - 30);
+	else if (cur_sig >= 21 && cur_sig <= 30)
+		ret_sig = 54 + (cur_sig - 20);
+	else if (cur_sig >= 10 && cur_sig <= 20)
+		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
+	else if (cur_sig >= 5 && cur_sig <= 9)
+		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
+	else if (cur_sig >= 1 && cur_sig <= 4)
+		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
+	else
+		ret_sig = cur_sig;
+	return ret_sig;
+}
+
+static s32  translate2dbm(struct _adapter *padapter, u8 signal_strength_idx)
+{
+	s32 signal_power; /* in dBm.*/
+	/* Translate to dBm (x=0.5y-95).*/
+	signal_power = (s32)((signal_strength_idx + 1) >> 1);
+	signal_power -= 95;
+	return signal_power;
+}
+
+static void query_rx_phy_status(struct _adapter *padapter,
+				union recv_frame *prframe)
+{
+	u8 i, max_spatial_stream, evm;
+	struct recv_stat *prxstat = (struct recv_stat *)prframe->u.hdr.rx_head;
+	struct phy_stat *pphy_stat = (struct phy_stat *)(prxstat + 1);
+	u8 *pphy_head = (u8 *)(prxstat + 1);
+	s8 rx_pwr[4], rx_pwr_all;
+	u8 pwdb_all;
+	u32 rssi, total_rssi = 0;
+	u8 bcck_rate = 0, rf_rx_num = 0, cck_highpwr = 0;
+	struct phy_cck_rx_status *pcck_buf;
+	u8 sq;
+
+	/* Record it for next packet processing*/
+	bcck_rate = (prframe->u.hdr.attrib.mcs_rate <= 3 ? 1 : 0);
+	if (bcck_rate) {
+		u8 report;
+
+		/* CCK Driver info Structure is not the same as OFDM packet.*/
+		pcck_buf = (struct phy_cck_rx_status *)pphy_stat;
+		/* (1)Hardware does not provide RSSI for CCK
+		 * (2)PWDB, Average PWDB cacluated by hardware
+		 * (for rate adaptive)
+		 */
+		if (!cck_highpwr) {
+			report = pcck_buf->cck_agc_rpt & 0xc0;
+			report = report >> 6;
+			switch (report) {
+			/* Modify the RF RNA gain value to -40, -20,
+			 * -2, 14 by Jenyu's suggestion
+			 * Note: different RF with the different
+			 * RNA gain. */
+			case 0x3:
+				rx_pwr_all = -40 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x2:
+				rx_pwr_all = -20 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x1:
+				rx_pwr_all = -2 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x0:
+				rx_pwr_all = 14 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			}
+		} else {
+			report = ((u8)(le32_to_cpu(pphy_stat->phydw1) >> 8)) &
+				 0x60;
+			report = report >> 5;
+			switch (report) {
+			case 0x3:
+				rx_pwr_all = -40 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x2:
+				rx_pwr_all = -20 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x1:
+				rx_pwr_all = -2 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x0:
+				rx_pwr_all = 14 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			}
+		}
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+		/* CCK gain is smaller than OFDM/MCS gain,*/
+		/* so we add gain diff by experiences, the val is 6 */
+		pwdb_all += 6;
+		if (pwdb_all > 100)
+			pwdb_all = 100;
+		/* modify the offset to make the same gain index with OFDM.*/
+		if (pwdb_all > 34 && pwdb_all <= 42)
+			pwdb_all -= 2;
+		else if (pwdb_all > 26 && pwdb_all <= 34)
+			pwdb_all -= 6;
+		else if (pwdb_all > 14 && pwdb_all <= 26)
+			pwdb_all -= 8;
+		else if (pwdb_all > 4 && pwdb_all <= 14)
+			pwdb_all -= 4;
+		/*
+		 * (3) Get Signal Quality (EVM)
+		 */
+		if (pwdb_all > 40)
+			sq = 100;
+		else {
+			sq = pcck_buf->sq_rpt;
+			if (pcck_buf->sq_rpt > 64)
+				sq = 0;
+			else if (pcck_buf->sq_rpt < 20)
+				sq = 100;
+			else
+				sq = ((64-sq) * 100) / 44;
+		}
+		prframe->u.hdr.attrib.signal_qual = sq;
+		prframe->u.hdr.attrib.rx_mimo_signal_qual[0] = sq;
+		prframe->u.hdr.attrib.rx_mimo_signal_qual[1] = -1;
+	} else {
+		/* (1)Get RSSI for HT rate */
+		for (i = 0; i < ((padapter->registrypriv.rf_config) &
+			    0x0f) ; i++) {
+			rf_rx_num++;
+			rx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT + i]
+				    & 0x3F) * 2) - 110;
+			/* Translate DBM to percentage. */
+			rssi = query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += rssi;
+		}
+		/* (2)PWDB, Average PWDB cacluated by hardware (for
+		 * rate adaptive) */
+		rx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1) & 0x7f)
+			     - 106;
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+
+		{
+			/* (3)EVM of HT rate */
+			if (prframe->u.hdr.attrib.htc &&
+			    prframe->u.hdr.attrib.mcs_rate >= 20 &&
+			    prframe->u.hdr.attrib.mcs_rate <= 27) {
+				/* both spatial stream make sense */
+				max_spatial_stream = 2;
+			} else {
+				/* only spatial stream 1 makes sense */
+				max_spatial_stream = 1;
+			}
+			for (i = 0; i < max_spatial_stream; i++) {
+				evm = evm_db2percentage((pphy_head
+				      [PHY_STAT_RXEVM_SHT + i]));/*dbm*/
+				prframe->u.hdr.attrib.signal_qual =
+					 (u8)(evm & 0xff);
+				prframe->u.hdr.attrib.rx_mimo_signal_qual[i] =
+					 (u8)(evm & 0xff);
+			}
+		}
+	}
+	/* UI BSS List signal strength(in percentage), make it good looking,
+	 * from 0~100. It is assigned to the BSS List in
+	 * GetValueFromBeaconOrProbeRsp(). */
+	if (bcck_rate)
+		prframe->u.hdr.attrib.signal_strength =
+			 (u8)r8712_signal_scale_mapping(pwdb_all);
+	else {
+		if (rf_rx_num != 0)
+			prframe->u.hdr.attrib.signal_strength =
+				 (u8)(r8712_signal_scale_mapping(total_rssi /=
+				 rf_rx_num));
+	}
+}
+
+static void process_link_qual(struct _adapter *padapter,
+			      union recv_frame *prframe)
+{
+	u32	last_evm = 0, tmpVal;
+	struct rx_pkt_attrib *pattrib;
+
+	if (prframe == NULL || padapter == NULL)
+		return;
+	pattrib = &prframe->u.hdr.attrib;
+	if (pattrib->signal_qual != 0) {
+		/*
+		 * 1. Record the general EVM to the sliding window.
+		 */
+		if (padapter->recvpriv.signal_qual_data.total_num++ >=
+				  PHY_LINKQUALITY_SLID_WIN_MAX) {
+			padapter->recvpriv.signal_qual_data.total_num =
+				  PHY_LINKQUALITY_SLID_WIN_MAX;
+			last_evm = padapter->recvpriv.signal_qual_data.elements
+				  [padapter->recvpriv.signal_qual_data.index];
+			padapter->recvpriv.signal_qual_data.total_val -=
+				  last_evm;
+		}
+		padapter->recvpriv.signal_qual_data.total_val +=
+			  pattrib->signal_qual;
+		padapter->recvpriv.signal_qual_data.elements[padapter->
+			  recvpriv.signal_qual_data.index++] =
+			  pattrib->signal_qual;
+		if (padapter->recvpriv.signal_qual_data.index >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX)
+			padapter->recvpriv.signal_qual_data.index = 0;
+
+		/* <1> Showed on UI for user, in percentage. */
+		tmpVal = padapter->recvpriv.signal_qual_data.total_val /
+			 padapter->recvpriv.signal_qual_data.total_num;
+		padapter->recvpriv.signal = (u8)tmpVal;
+	}
+}
+
+static void process_rssi(struct _adapter *padapter, union recv_frame *prframe)
+{
+	u32 last_rssi, tmp_val;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	if (padapter->recvpriv.signal_strength_data.total_num++ >=
+	    PHY_RSSI_SLID_WIN_MAX) {
+		padapter->recvpriv.signal_strength_data.total_num =
+			 PHY_RSSI_SLID_WIN_MAX;
+		last_rssi = padapter->recvpriv.signal_strength_data.elements
+			    [padapter->recvpriv.signal_strength_data.index];
+		padapter->recvpriv.signal_strength_data.total_val -= last_rssi;
+	}
+	padapter->recvpriv.signal_strength_data.total_val +=
+			pattrib->signal_strength;
+	padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.
+			signal_strength_data.index++] =
+			pattrib->signal_strength;
+	if (padapter->recvpriv.signal_strength_data.index >=
+	    PHY_RSSI_SLID_WIN_MAX)
+		padapter->recvpriv.signal_strength_data.index = 0;
+	tmp_val = padapter->recvpriv.signal_strength_data.total_val /
+		  padapter->recvpriv.signal_strength_data.total_num;
+	padapter->recvpriv.rssi = (s8)translate2dbm(padapter, (u8)tmp_val);
+}
+
+static void process_phy_info(struct _adapter *padapter,
+			     union recv_frame *prframe)
+{
+	query_rx_phy_status(padapter, prframe);
+	process_rssi(padapter, prframe);
+	process_link_qual(padapter,  prframe);
+}
+
+int recv_func(struct _adapter *padapter, void *pcontext)
+{
+	struct rx_pkt_attrib *pattrib;
+	union recv_frame *prframe, *orig_prframe;
+	int retval = _SUCCESS;
+	struct  __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+	prframe = (union recv_frame *)pcontext;
+	orig_prframe = prframe;
+	pattrib = &prframe->u.hdr.attrib;
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		if (pattrib->crc_err == 1)
+			padapter->mppriv.rx_crcerrpktcount++;
+		else
+			padapter->mppriv.rx_pktcount++;
+		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == false) {
+			/* free this recv_frame */
+			r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _exit_recv_func;
+		}
+	}
+	/* check the frame crtl field and decache */
+	retval = r8712_validate_recv_frame(padapter, prframe);
+	if (retval != _SUCCESS) {
+		/* free this recv_frame */
+		r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+		goto _exit_recv_func;
+	}
+	process_phy_info(padapter, prframe);
+	prframe = r8712_decryptor(padapter, prframe);
+	if (prframe == NULL) {
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+	prframe = r8712_recvframe_chk_defrag(padapter, prframe);
+	if (prframe == NULL)
+		goto _exit_recv_func;
+	prframe = r8712_portctrl(padapter, prframe);
+	if (prframe == NULL) {
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+	retval = r8712_process_recv_indicatepkts(padapter, prframe);
+	if (retval != _SUCCESS) {
+		r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+		goto _exit_recv_func;
+	}
+_exit_recv_func:
+	return retval;
+}
+
+static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)
+{
+	u8 *pbuf, shift_sz = 0;
+	u8	frag, mf;
+	uint	pkt_len;
+	u32 transfer_len;
+	struct recv_stat *prxstat;
+	u16	pkt_cnt, drvinfo_sz, pkt_offset, tmp_len, alloc_sz;
+	struct  __queue *pfree_recv_queue;
+	_pkt  *pkt_copy = NULL;
+	union recv_frame *precvframe = NULL;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	pbuf = pskb->data;
+	prxstat = (struct recv_stat *)pbuf;
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16)&0xff;
+	pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+	transfer_len = pskb->len;
+	/* Test throughput with Netgear 3700 (No security) with Chariot 3T3R
+	 * pairs. The packet count will be a big number so that the containing
+	 * packet will effect the Rx reordering. */
+	if (transfer_len < pkt_len) {
+		/* In this case, it means the MAX_RECVBUF_SZ is too small to
+		 * get the data from 8712u. */
+		return _FAIL;
+	}
+	do {
+		prxstat = (struct recv_stat *)pbuf;
+		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+		/* more fragment bit */
+		mf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;
+		/* ragmentation number */
+		frag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;
+		/* uint 2^3 = 8 bytes */
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;
+		drvinfo_sz = drvinfo_sz<<3;
+		if (pkt_len <= 0)
+			goto  _exit_recvbuf2recvframe;
+		/* Qos data, wireless lan header length is 26 */
+		if ((le32_to_cpu(prxstat->rxdw0) >> 23) & 0x01)
+			shift_sz = 2;
+		precvframe = r8712_alloc_recvframe(pfree_recv_queue);
+		if (precvframe == NULL)
+			goto  _exit_recvbuf2recvframe;
+		_init_listhead(&precvframe->u.hdr.list);
+		precvframe->u.hdr.precvbuf = NULL; /*can't access the precvbuf*/
+		precvframe->u.hdr.len = 0;
+		tmp_len = pkt_len + drvinfo_sz + RXDESC_SIZE;
+		pkt_offset = (u16)_RND128(tmp_len);
+		/* for first fragment packet, driver need allocate 1536 +
+		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
+		if ((mf == 1) && (frag == 0))
+			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/
+		else
+			alloc_sz = tmp_len;
+		/* 2 is for IP header 4 bytes alignment in QoS packet case.
+		 * 4 is for skb->data 4 bytes alignment. */
+		alloc_sz += 6;
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
+		if (pkt_copy) {
+			pkt_copy->dev = padapter->pnetdev;
+			precvframe->u.hdr.pkt = pkt_copy;
+			skb_reserve(pkt_copy, 4 - ((addr_t)(pkt_copy->data)
+				    % 4));
+			skb_reserve(pkt_copy, shift_sz);
+			memcpy(pkt_copy->data, pbuf, tmp_len);
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data =
+				 precvframe->u.hdr.rx_tail = pkt_copy->data;
+			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
+		} else {
+			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
+			precvframe->u.hdr.rx_head = pbuf;
+			precvframe->u.hdr.rx_data = pbuf;
+			precvframe->u.hdr.rx_tail = pbuf;
+			precvframe->u.hdr.rx_end = pbuf + alloc_sz;
+		}
+		recvframe_put(precvframe, tmp_len);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+		/* because the endian issue, driver avoid reference to the
+		 * rxstat after calling update_recvframe_attrib_from_recvstat();
+		 */
+		update_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib,
+						      prxstat);
+		r8712_recv_entry(precvframe);
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;
+		pkt_cnt--;
+		precvframe = NULL;
+		pkt_copy = NULL;
+	} while ((transfer_len > 0) && pkt_cnt > 0);
+_exit_recvbuf2recvframe:
+	return _SUCCESS;
+}
+
+static void recv_tasklet(void *priv)
+{
+	struct sk_buff *pskb;
+	struct _adapter *padapter = (struct _adapter *)priv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {
+		recvbuf2recvframe(padapter, pskb);
+		skb_reset_tail_pointer(pskb);
+		pskb->len = 0;
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+	}
+}
diff --git a/drivers/staging/rtl8712/rtl8712_recv.h b/drivers/staging/rtl8712/rtl8712_recv.h
new file mode 100644
index 0000000..8efbd1f
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_recv.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_RECV_H_
+#define _RTL8712_RECV_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/* Realtek's v2.6.6 reduced this to 4. However, under heavy network and CPU
+ * loads, even 8 receive buffers might not be enough; cutting it to 4 seemed
+ * unwise.
+ */
+#define NR_RECVBUFF (8)
+
+#define NR_PREALLOC_RECV_SKB (8)
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+#define MAX_RECVBUF_SZ (30720) /* 30K */
+#define RECVBUFF_ALIGN_SZ 512
+#define RSVD_ROOM_SZ (0)
+/*These definition is used for Rx packet reordering.*/
+#define SN_LESS(a, b)		(((a-b) & 0x800) != 0)
+#define SN_EQUAL(a, b)	(a == b)
+#define REORDER_WAIT_TIME	30 /* (ms)*/
+
+struct recv_stat {
+	unsigned int rxdw0;
+	unsigned int rxdw1;
+	unsigned int rxdw2;
+	unsigned int rxdw3;
+	unsigned int rxdw4;
+	unsigned int rxdw5;
+};
+
+struct phy_cck_rx_status {
+	/* For CCK rate descriptor. This is a unsigned 8:1 variable.
+	 * LSB bit present 0.5. And MSB 7 bts present a signed value.
+	 * Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	sq_rpt;
+	u8	cck_agc_rpt;
+};
+
+struct phy_stat {
+	unsigned int phydw0;
+	unsigned int phydw1;
+	unsigned int phydw2;
+	unsigned int phydw3;
+	unsigned int phydw4;
+	unsigned int phydw5;
+	unsigned int phydw6;
+	unsigned int phydw7;
+};
+#define PHY_STAT_GAIN_TRSW_SHT 0
+#define PHY_STAT_PWDB_ALL_SHT 4
+#define PHY_STAT_CFOSHO_SHT 5
+#define PHY_STAT_CCK_AGC_RPT_SHT 5
+#define PHY_STAT_CFOTAIL_SHT 9
+#define PHY_STAT_RXEVM_SHT 13
+#define PHY_STAT_RXSNR_SHT 15
+#define PHY_STAT_PDSNR_SHT 19
+#define PHY_STAT_CSI_CURRENT_SHT 21
+#define PHY_STAT_CSI_TARGET_SHT 23
+#define PHY_STAT_SIGEVM_SHT 25
+#define PHY_STAT_MAX_EX_PWR_SHT 26
+
+union recvstat {
+	struct recv_stat recv_stat;
+	unsigned int value[RXDESC_SIZE>>2];
+};
+
+
+struct recv_buf {
+	struct list_head list;
+	spinlock_t recvbuf_lock;
+	u32	ref_cnt;
+	struct _adapter  *adapter;
+	struct urb *purb;
+	_pkt *pskb;
+	u8 reuse;
+	u8  irp_pending;
+	u32  transfer_len;
+	uint  len;
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	u8 *pbuf;
+	u8 *pallocated_buf;
+};
+
+/*
+	head  ----->
+		data  ----->
+			payload
+		tail  ----->
+	end   ----->
+	len = (unsigned int )(tail - data);
+*/
+struct recv_frame_hdr {
+	struct list_head list;
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+	struct _adapter  *adapter;
+	u8 fragcnt;
+	struct rx_pkt_attrib attrib;
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+	void *precvbuf;
+	struct sta_info *psta;
+	/*for A-MPDU Rx reordering buffer control*/
+	struct recv_reorder_ctrl *preorder_ctrl;
+};
+
+union recv_frame {
+	union {
+		struct list_head list;
+		struct recv_frame_hdr hdr;
+	} u;
+};
+
+int r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf);
+void r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf);
+s32 r8712_signal_scale_mapping(s32 cur_sig);
+void r8712_reordering_ctrl_timeout_handler(void *pcontext);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl8712_regdef.h b/drivers/staging/rtl8712/rtl8712_regdef.h
new file mode 100644
index 0000000..e7bca55
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_regdef.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_REGDEF_H__
+#define __RTL8712_REGDEF_H__
+
+#include "rtl8712_syscfg_regdef.h"
+#include "rtl8712_cmdctrl_regdef.h"
+#include "rtl8712_macsetting_regdef.h"
+#include "rtl8712_timectrl_regdef.h"
+#include "rtl8712_fifoctrl_regdef.h"
+#include "rtl8712_ratectrl_regdef.h"
+#include "rtl8712_edcasetting_regdef.h"
+#include "rtl8712_wmac_regdef.h"
+#include "rtl8712_powersave_regdef.h"
+#include "rtl8712_gp_regdef.h"
+#include "rtl8712_debugctrl_regdef.h"
+
+#define HIMR	(RTL8712_INTERRUPT_ + 0x08)
+
+#endif /* __RTL8712_REGDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_security_bitdef.h b/drivers/staging/rtl8712/rtl8712_security_bitdef.h
new file mode 100644
index 0000000..05dafa0
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_security_bitdef.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SECURITY_BITDEF_H__
+#define __RTL8712_SECURITY_BITDEF_H__
+
+/*CAMCMD*/
+#define	_SECCAM_POLLING				BIT(31)
+#define	_SECCAM_CLR					BIT(30)
+#define	_SECCAM_WE					BIT(16)
+#define	_SECCAM_ADR_MSK				0x000000FF
+#define	_SECCAM_ADR_SHT				0
+
+/*CAMDBG*/
+#define	_SECCAM_INFO				BIT(31)
+#define	_SEC_KEYFOUND				BIT(30)
+#define	_SEC_CONFIG_MSK				0x3F000000
+#define	_SEC_CONFIG_SHT				24
+#define	_SEC_KEYCONTENT_MSK			0x00FFFFFF
+#define	_SEC_KEYCONTENT_SHT			0
+
+/*SECCFG*/
+#define	_NOSKMC						BIT(5)
+#define	_SKBYA2						BIT(4)
+#define	_RXDEC						BIT(3)
+#define	_TXENC						BIT(2)
+#define	_RXUSEDK					BIT(1)
+#define	_TXUSEDK					BIT(0)
+
+
+#endif	/*__RTL8712_SECURITY_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_spec.h b/drivers/staging/rtl8712/rtl8712_spec.h
new file mode 100644
index 0000000..af11b44
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_spec.h
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SPEC_H__
+#define __RTL8712_SPEC_H__
+
+#define RTL8712_IOBASE_TXPKT		0x10200000	/*IOBASE_TXPKT*/
+#define RTL8712_IOBASE_RXPKT		0x10210000	/*IOBASE_RXPKT*/
+#define RTL8712_IOBASE_RXCMD		0x10220000	/*IOBASE_RXCMD*/
+#define RTL8712_IOBASE_TXSTATUS		0x10230000	/*IOBASE_TXSTATUS*/
+#define RTL8712_IOBASE_RXSTATUS		0x10240000	/*IOBASE_RXSTATUS*/
+#define RTL8712_IOBASE_IOREG		0x10250000	/*IOBASE_IOREG ADDR*/
+#define RTL8712_IOBASE_SCHEDULER	0x10260000	/*IOBASE_SCHEDULE*/
+
+#define RTL8712_IOBASE_TRXDMA		0x10270000	/*IOBASE_TRXDMA*/
+#define RTL8712_IOBASE_TXLLT		0x10280000	/*IOBASE_TXLLT*/
+#define RTL8712_IOBASE_WMAC		0x10290000	/*IOBASE_WMAC*/
+#define RTL8712_IOBASE_FW2HW		0x102A0000	/*IOBASE_FW2HW*/
+#define RTL8712_IOBASE_ACCESS_PHYREG	0x102B0000	/*IOBASE_ACCESS_PHYREG*/
+
+#define RTL8712_IOBASE_FF	0x10300000 /*IOBASE_FIFO 0x1031000~0x103AFFFF*/
+
+
+/*IOREG Offset for 8712*/
+#define RTL8712_SYSCFG_		RTL8712_IOBASE_IOREG
+#define RTL8712_CMDCTRL_	(RTL8712_IOBASE_IOREG + 0x40)
+#define RTL8712_MACIDSETTING_	(RTL8712_IOBASE_IOREG + 0x50)
+#define RTL8712_TIMECTRL_	(RTL8712_IOBASE_IOREG + 0x80)
+#define RTL8712_FIFOCTRL_	(RTL8712_IOBASE_IOREG + 0xA0)
+#define RTL8712_RATECTRL_	(RTL8712_IOBASE_IOREG + 0x160)
+#define RTL8712_EDCASETTING_	(RTL8712_IOBASE_IOREG + 0x1D0)
+#define RTL8712_WMAC_		(RTL8712_IOBASE_IOREG + 0x200)
+#define RTL8712_SECURITY_	(RTL8712_IOBASE_IOREG + 0x240)
+#define RTL8712_POWERSAVE_	(RTL8712_IOBASE_IOREG + 0x260)
+#define RTL8712_GP_		(RTL8712_IOBASE_IOREG + 0x2E0)
+#define RTL8712_INTERRUPT_	(RTL8712_IOBASE_IOREG + 0x300)
+#define RTL8712_DEBUGCTRL_	(RTL8712_IOBASE_IOREG + 0x310)
+#define RTL8712_OFFLOAD_	(RTL8712_IOBASE_IOREG + 0x2D0)
+
+
+/*FIFO for 8712*/
+#define RTL8712_DMA_BCNQ	(RTL8712_IOBASE_FF + 0x10000)
+#define RTL8712_DMA_MGTQ	(RTL8712_IOBASE_FF + 0x20000)
+#define RTL8712_DMA_BMCQ	(RTL8712_IOBASE_FF + 0x30000)
+#define RTL8712_DMA_VOQ		(RTL8712_IOBASE_FF + 0x40000)
+#define RTL8712_DMA_VIQ		(RTL8712_IOBASE_FF + 0x50000)
+#define RTL8712_DMA_BEQ		(RTL8712_IOBASE_FF + 0x60000)
+#define RTL8712_DMA_BKQ		(RTL8712_IOBASE_FF + 0x70000)
+#define RTL8712_DMA_RX0FF	(RTL8712_IOBASE_FF + 0x80000)
+#define RTL8712_DMA_H2CCMD	(RTL8712_IOBASE_FF + 0x90000)
+#define RTL8712_DMA_C2HCMD	(RTL8712_IOBASE_FF + 0xA0000)
+
+
+/*------------------------------*/
+
+/*BIT 16 15*/
+#define	DID_SDIO_LOCAL			0	/* 0 0*/
+#define	DID_WLAN_IOREG			1	/* 0 1*/
+#define	DID_WLAN_FIFO			3	/* 1 1*/
+#define   DID_UNDEFINE				(-1)
+
+#define CMD_ADDR_MAPPING_SHIFT		2	/*SDIO CMD ADDR MAPPING,
+						 *shift 2 bit for match
+						 * offset[14:2]*/
+
+/*Offset for SDIO LOCAL*/
+#define	OFFSET_SDIO_LOCAL				0x0FFF
+
+/*Offset for WLAN IOREG*/
+#define OFFSET_WLAN_IOREG				0x0FFF
+
+/*Offset for WLAN FIFO*/
+#define	OFFSET_TX_BCNQ				0x0300
+#define	OFFSET_TX_HIQ					0x0310
+#define	OFFSET_TX_CMDQ				0x0320
+#define	OFFSET_TX_MGTQ				0x0330
+#define	OFFSET_TX_HCCAQ				0x0340
+#define	OFFSET_TX_VOQ					0x0350
+#define	OFFSET_TX_VIQ					0x0360
+#define	OFFSET_TX_BEQ					0x0370
+#define	OFFSET_TX_BKQ					0x0380
+#define	OFFSET_RX_RX0FFQ				0x0390
+#define	OFFSET_RX_C2HFFQ				0x03A0
+
+#define	BK_QID_01	1
+#define	BK_QID_02	2
+#define	BE_QID_01	0
+#define	BE_QID_02	3
+#define	VI_QID_01	4
+#define	VI_QID_02	5
+#define	VO_QID_01	6
+#define	VO_QID_02	7
+#define	HCCA_QID_01	8
+#define	HCCA_QID_02	9
+#define	HCCA_QID_03	10
+#define	HCCA_QID_04	11
+#define	HCCA_QID_05	12
+#define	HCCA_QID_06	13
+#define	HCCA_QID_07	14
+#define	HCCA_QID_08	15
+#define	HI_QID		17
+#define	CMD_QID	19
+#define	MGT_QID	18
+#define	BCN_QID	16
+
+#include "rtl8712_regdef.h"
+
+#include "rtl8712_bitdef.h"
+
+#include "basic_types.h"
+
+#endif /* __RTL8712_SPEC_H__ */
+
diff --git a/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h b/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h
new file mode 100644
index 0000000..eed09c8
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h
@@ -0,0 +1,170 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SYSCFG_BITDEF_H__
+#define __RTL8712_SYSCFG_BITDEF_H__
+
+/*SYS_PWR_CTRL*/
+/*SRCTRL0*/
+/*SRCTRL1*/
+/*SYS_CLKR*/
+
+/*SYS_IOS_CTRL*/
+#define iso_LDR2RP_SHT		8 /* EE Loader to Retention Path*/
+#define iso_LDR2RP		BIT(iso_LDR2RP_SHT) /* 1:isolation, 0:attach*/
+
+/*SYS_CTRL*/
+#define FEN_DIO_SDIO_SHT	0
+#define FEN_DIO_SDIO		BIT(FEN_DIO_SDIO_SHT)
+#define FEN_SDIO_SHT		1
+#define FEN_SDIO		BIT(FEN_SDIO_SHT)
+#define FEN_USBA_SHT		2
+#define FEN_USBA		BIT(FEN_USBA_SHT)
+#define FEN_UPLL_SHT		3
+#define FEN_UPLL		BIT(FEN_UPLL_SHT)
+#define FEN_USBD_SHT		4
+#define FEN_USBD		BIT(FEN_USBD_SHT)
+#define FEN_DIO_PCIE_SHT	5
+#define FEN_DIO_PCIE		BIT(FEN_DIO_PCIE_SHT)
+#define FEN_PCIEA_SHT		6
+#define FEN_PCIEA		BIT(FEN_PCIEA_SHT)
+#define FEN_PPLL_SHT		7
+#define FEN_PPLL		BIT(FEN_PPLL_SHT)
+#define FEN_PCIED_SHT		8
+#define FEN_PCIED		BIT(FEN_PCIED_SHT)
+#define FEN_CPUEN_SHT		10
+#define FEN_CPUEN		BIT(FEN_CPUEN_SHT)
+#define FEN_DCORE_SHT		11
+#define FEN_DCORE		BIT(FEN_DCORE_SHT)
+#define FEN_ELDR_SHT		12
+#define FEN_ELDR		BIT(FEN_ELDR_SHT)
+#define PWC_DV2LDR_SHT		13
+#define PWC_DV2LDR		BIT(PWC_DV2LDR_SHT) /* Loader Power Enable*/
+
+/*=== SYS_CLKR ===*/
+#define SYS_CLKSEL_SHT		0
+#define SYS_CLKSEL		BIT(SYS_CLKSEL_SHT) /* System Clock 80MHz*/
+#define PS_CLKSEL_SHT		1
+#define PS_CLKSEL		BIT(PS_CLKSEL_SHT) /*System power save
+						    * clock select.*/
+#define CPU_CLKSEL_SHT		2
+#define CPU_CLKSEL		BIT(CPU_CLKSEL_SHT) /* System Clock select,
+						     * 1: AFE source,
+						     * 0: System clock(L-Bus)*/
+#define INT32K_EN_SHT		3
+#define INT32K_EN		BIT(INT32K_EN_SHT)
+#define MACSLP_SHT		4
+#define MACSLP			BIT(MACSLP_SHT)
+#define MAC_CLK_EN_SHT		11
+#define MAC_CLK_EN		BIT(MAC_CLK_EN_SHT) /* MAC Clock Enable.*/
+#define SYS_CLK_EN_SHT		12
+#define SYS_CLK_EN		BIT(SYS_CLK_EN_SHT)
+#define RING_CLK_EN_SHT		13
+#define RING_CLK_EN		BIT(RING_CLK_EN_SHT)
+#define SWHW_SEL_SHT		14
+#define SWHW_SEL		BIT(SWHW_SEL_SHT) /* Load done,
+						   * control path switch.*/
+#define FWHW_SEL_SHT		15
+#define FWHW_SEL		BIT(FWHW_SEL_SHT) /* Sleep exit,
+						   * control path switch.*/
+
+/*9346CR*/
+#define	_VPDIDX_MSK		0xFF00
+#define	_VPDIDX_SHT		8
+#define	_EEM_MSK		0x00C0
+#define	_EEM_SHT		6
+#define	_EEM0			BIT(6)
+#define	_EEM1			BIT(7)
+#define	_EEPROM_EN		BIT(5)
+#define	_9356SEL		BIT(4)
+#define	_EECS			BIT(3)
+#define	_EESK			BIT(2)
+#define	_EEDI			BIT(1)
+#define	_EEDO			BIT(0)
+
+/*AFE_MISC*/
+#define	AFE_MISC_USB_MBEN_SHT	7
+#define	AFE_MISC_USB_MBEN	BIT(AFE_MISC_USB_MBEN_SHT)
+#define	AFE_MISC_USB_BGEN_SHT	6
+#define	AFE_MISC_USB_BGEN	BIT(AFE_MISC_USB_BGEN_SHT)
+#define	AFE_MISC_LD12_VDAJ_SHT	4
+#define	AFE_MISC_LD12_VDAJ_MSK	0X0030
+#define	AFE_MISC_LD12_VDAJ	BIT(AFE_MISC_LD12_VDAJ_SHT)
+#define	AFE_MISC_I32_EN_SHT	3
+#define	AFE_MISC_I32_EN		BIT(AFE_MISC_I32_EN_SHT)
+#define	AFE_MISC_E32_EN_SHT	2
+#define	AFE_MISC_E32_EN		BIT(AFE_MISC_E32_EN_SHT)
+#define	AFE_MISC_MBEN_SHT	1
+#define	AFE_MISC_MBEN		BIT(AFE_MISC_MBEN_SHT)/* Enable AFE Macro
+						       * Block's Mbias.*/
+#define	AFE_MISC_BGEN_SHT	0
+#define	AFE_MISC_BGEN		BIT(AFE_MISC_BGEN_SHT)/* Enable AFE Macro
+						       * Block's Bandgap.*/
+
+
+/*--------------------------------------------------------------------------*/
+/*       SPS1_CTRL bits				(Offset 0x18-1E, 56bits)*/
+/*--------------------------------------------------------------------------*/
+#define	SPS1_SWEN		BIT(1)	/* Enable vsps18 SW Macro Block.*/
+#define	SPS1_LDEN		BIT(0)	/* Enable VSPS12 LDO Macro block.*/
+
+
+/*----------------------------------------------------------------------------*/
+/*       LDOA15_CTRL bits		(Offset 0x20, 8bits)*/
+/*----------------------------------------------------------------------------*/
+#define	LDA15_EN		BIT(0)	/* Enable LDOA15 Macro Block*/
+
+
+/*----------------------------------------------------------------------------*/
+/*       8192S LDOV12D_CTRL bit		(Offset 0x21, 8bits)*/
+/*----------------------------------------------------------------------------*/
+#define	LDV12_EN		BIT(0)	/* Enable LDOVD12 Macro Block*/
+#define	LDV12_SDBY		BIT(1)	/* LDOVD12 standby mode*/
+
+/*CLK_PS_CTRL*/
+#define	_CLK_GATE_EN		BIT(0)
+
+
+/* EFUSE_CTRL*/
+#define EF_FLAG			BIT(31)		/* Access Flag, Write:1;
+						 *	        Read:0*/
+#define EF_PGPD			0x70000000	/* E-fuse Program time*/
+#define EF_RDT			0x0F000000	/* E-fuse read time: in the
+						 * unit of cycle time*/
+#define EF_PDN_EN		BIT(19)		/* EFuse Power down enable*/
+#define ALD_EN			BIT(18)		/* Autoload Enable*/
+#define EF_ADDR			0x0003FF00	/* Access Address*/
+#define EF_DATA			0x000000FF	/* Access Data*/
+
+/* EFUSE_TEST*/
+#define LDOE25_EN		BIT(31)		/* Enable LDOE25 Macro Block*/
+
+/* EFUSE_CLK_CTRL*/
+#define EFUSE_CLK_EN		BIT(1)		/* E-Fuse Clock Enable*/
+#define EFUSE_CLK_SEL		BIT(0)		/* E-Fuse Clock Select,
+						 * 0:500K, 1:40M*/
+
+#endif	/*__RTL8712_SYSCFG_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h b/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h
new file mode 100644
index 0000000..767dfdf
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SYSCFG_REGDEF_H__
+#define __RTL8712_SYSCFG_REGDEF_H__
+
+
+#define SYS_ISO_CTRL		(RTL8712_SYSCFG_ + 0x0000)
+#define SYS_FUNC_EN		(RTL8712_SYSCFG_ + 0x0002)
+#define PMC_FSM			(RTL8712_SYSCFG_ + 0x0004)
+#define SYS_CLKR		(RTL8712_SYSCFG_ + 0x0008)
+#define EE_9346CR		(RTL8712_SYSCFG_ + 0x000A)
+#define EE_VPD			(RTL8712_SYSCFG_ + 0x000C)
+#define AFE_MISC		(RTL8712_SYSCFG_ + 0x0010)
+#define SPS0_CTRL		(RTL8712_SYSCFG_ + 0x0011)
+#define SPS1_CTRL		(RTL8712_SYSCFG_ + 0x0018)
+#define RF_CTRL			(RTL8712_SYSCFG_ + 0x001F)
+#define LDOA15_CTRL		(RTL8712_SYSCFG_ + 0x0020)
+#define LDOV12D_CTRL		(RTL8712_SYSCFG_ + 0x0021)
+#define LDOHCI12_CTRL		(RTL8712_SYSCFG_ + 0x0022)
+#define LDO_USB_CTRL		(RTL8712_SYSCFG_ + 0x0023)
+#define LPLDO_CTRL		(RTL8712_SYSCFG_ + 0x0024)
+#define AFE_XTAL_CTRL		(RTL8712_SYSCFG_ + 0x0026)
+#define AFE_PLL_CTRL		(RTL8712_SYSCFG_ + 0x0028)
+#define EFUSE_CTRL		(RTL8712_SYSCFG_ + 0x0030)
+#define EFUSE_TEST		(RTL8712_SYSCFG_ + 0x0034)
+#define PWR_DATA		(RTL8712_SYSCFG_ + 0x0038)
+#define DPS_TIMER		(RTL8712_SYSCFG_ + 0x003C)
+#define RCLK_MON		(RTL8712_SYSCFG_ + 0x003E)
+#define EFUSE_CLK_CTRL		(RTL8712_SYSCFG_ + 0x02F8)
+
+
+#endif /*__RTL8712_SYSCFG_REGDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h b/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h
new file mode 100644
index 0000000..7244215
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_TIMECTRL_BITDEF_H__
+#define __RTL8712_TIMECTRL_BITDEF_H__
+
+/*TSFTR*/
+/*SLOT*/
+/*USTIME*/
+
+/*TUBASE*/
+#define	_TUBASE_MSK			0x07FF
+
+/*SIFS_CCK*/
+#define	_SIFS_CCK_TRX_MSK		0xFF00
+#define	_SIFS_CCK_TRX_SHT		0x8
+#define	_SIFS_CCK_CTX_MSK		0x00FF
+#define	_SIFS_CCK_CTX_SHT		0
+
+/*SIFS_OFDM*/
+#define	_SIFS_OFDM_TRX_MSK		0xFF00
+#define	_SIFS_OFDM_TRX_SHT		0x8
+#define	_SIFS_OFDM_CTX_MSK		0x00FF
+#define	_SIFS_OFDM_CTX_SHT		0
+
+/*PIFS*/
+/*ACKTO*/
+/*EIFS*/
+/*BCNITV*/
+/*ATIMWND*/
+
+/*DRVERLYINT*/
+#define	_ENSWBCN				BIT(15)
+#define	_DRVERLY_TU_MSK			0x0FF0
+#define	_DRVERLY_TU_SHT			4
+#define	_DRVERLY_US_MSK			0x000F
+#define	_DRVERLY_US_SHT			0
+
+/*BCNDMATIM*/
+#define	_BCNDMATIM_MSK			0x03FF
+
+/*BCNERRTH*/
+/*MLT*/
+
+
+#endif /* __RTL8712_TIMECTRL_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h b/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h
new file mode 100644
index 0000000..106916c
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_TIMECTRL_REGDEF_H__
+#define __RTL8712_TIMECTRL_REGDEF_H__
+
+#define TSFTR			(RTL8712_TIMECTRL_ + 0x00)
+#define USTIME			(RTL8712_TIMECTRL_ + 0x08)
+#define SLOT			(RTL8712_TIMECTRL_ + 0x09)
+#define TUBASE			(RTL8712_TIMECTRL_ + 0x0A)
+#define SIFS_CCK		(RTL8712_TIMECTRL_ + 0x0C)
+#define SIFS_OFDM		(RTL8712_TIMECTRL_ + 0x0E)
+#define PIFS			(RTL8712_TIMECTRL_ + 0x10)
+#define ACKTO			(RTL8712_TIMECTRL_ + 0x11)
+#define EIFS			(RTL8712_TIMECTRL_ + 0x12)
+#define BCNITV			(RTL8712_TIMECTRL_ + 0x14)
+#define ATIMWND			(RTL8712_TIMECTRL_ + 0x16)
+#define DRVERLYINT		(RTL8712_TIMECTRL_ + 0x18)
+#define BCNDMATIM		(RTL8712_TIMECTRL_ + 0x1A)
+#define BCNERRTH		(RTL8712_TIMECTRL_ + 0x1C)
+#define MLT			(RTL8712_TIMECTRL_ + 0x1D)
+
+#endif /* __RTL8712_TIMECTRL_REGDEF_H__ */
diff --git a/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h b/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h
new file mode 100644
index 0000000..61a3603
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_WMAC_BITDEF_H__
+#define __RTL8712_WMAC_BITDEF_H__
+
+/*NAVCTRL*/
+#define	_NAV_UPPER_EN			BIT(18)
+#define	_NAV_MTO_EN				BIT(17)
+#define	_NAV_UPPER				BIT(16)
+#define	_NAV_MTO_MSK			0xFF00
+#define	_NAV_MTO_SHT			8
+#define	_RTSRST_MSK				0x00FF
+#define	_RTSRST_SHT				0
+
+/*BWOPMODE*/
+#define	_20MHZBW				BIT(2)
+
+/*BACAMCMD*/
+#define	_BACAM_POLL				BIT(31)
+#define	_BACAM_RST				BIT(17)
+#define	_BACAM_RW				BIT(16)
+#define	_BACAM_ADDR_MSK			0x0000007F
+#define	_BACAM_ADDR_SHT			0
+
+/*LBDLY*/
+#define	_LBDLY_MSK				0x1F
+
+/*FWDLY*/
+#define	_FWDLY_MSK				0x0F
+
+/*RXERR_RPT*/
+#define	_RXERR_RPT_SEL_MSK		0xF0000000
+#define	_RXERR_RPT_SEL_SHT		28
+#define	_RPT_CNT_MSK			0x000FFFFF
+#define	_RPT_CNT_SHT			0
+
+
+#endif	/*__RTL8712_WMAC_BITDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_wmac_regdef.h b/drivers/staging/rtl8712/rtl8712_wmac_regdef.h
new file mode 100644
index 0000000..d9f8347
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_wmac_regdef.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_WMAC_REGDEF_H__
+#define __RTL8712_WMAC_REGDEF_H__
+
+#define NAVCTRL				(RTL8712_WMAC_ + 0x00)
+#define BWOPMODE			(RTL8712_WMAC_ + 0x03)
+#define BACAMCMD			(RTL8712_WMAC_ + 0x04)
+#define BACAMCONTENT			(RTL8712_WMAC_ + 0x08)
+#define LBDLY				(RTL8712_WMAC_ + 0x10)
+#define FWDLY				(RTL8712_WMAC_ + 0x11)
+#define HWPC_RX_CTRL			(RTL8712_WMAC_ + 0x18)
+#define MQ				(RTL8712_WMAC_ + 0x20)
+#define MA				(RTL8712_WMAC_ + 0x22)
+#define MS				(RTL8712_WMAC_ + 0x24)
+#define CLM_RESULT			(RTL8712_WMAC_ + 0x27)
+#define NHM_RPI_CNT			(RTL8712_WMAC_ + 0x28)
+#define RXERR_RPT			(RTL8712_WMAC_ + 0x30)
+#define NAV_PROT_LEN			(RTL8712_WMAC_ + 0x34)
+#define CFEND_TH			(RTL8712_WMAC_ + 0x36)
+#define AMPDU_MIN_SPACE			(RTL8712_WMAC_ + 0x37)
+#define	TXOP_STALL_CTRL			(RTL8712_WMAC_ + 0x38)
+
+
+#endif /*__RTL8712_WMAC_REGDEF_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl8712_xmit.c b/drivers/staging/rtl8712/rtl8712_xmit.c
new file mode 100644
index 0000000..6933319
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_xmit.c
@@ -0,0 +1,760 @@
+/******************************************************************************
+ * rtl8712_xmit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_XMIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+static void dump_xframe(struct _adapter *padapter,
+			struct xmit_frame *pxmitframe);
+static void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz);
+
+sint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag)
+{
+	phw_txqueue->ac_tag = ac_tag;
+	switch (ac_tag) {
+	case BE_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+		break;
+	case BK_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BKQ;
+		break;
+	case VI_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_VIQ;
+		break;
+	case VO_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_VOQ;
+		break;
+	case BMC_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+		break;
+	}
+	return _SUCCESS;
+}
+
+int r8712_txframes_sta_ac_pending(struct _adapter *padapter,
+				  struct pkt_attrib *pattrib)
+{
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	int priority = pattrib->priority;
+
+	psta = pattrib->psta;
+	switch (priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+	break;
+	}
+	return ptxservq->qcnt;
+}
+
+static u32 get_ff_hwaddr(struct xmit_frame *pxmitframe)
+{
+	u32 addr = 0;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+
+	if (pxmitframe->frame_tag == TXAGG_FRAMETAG)
+		addr = RTL8712_DMA_H2CCMD;
+	else if (pxmitframe->frame_tag == MGNT_FRAMETAG)
+		addr = RTL8712_DMA_MGTQ;
+	else if (pdvobj->nr_endpoint == 6) {
+		switch (pattrib->priority) {
+		case 0:
+		case 3:
+			addr = RTL8712_DMA_BEQ;
+			break;
+		case 1:
+		case 2:
+			addr = RTL8712_DMA_BKQ;
+			break;
+		case 4:
+		case 5:
+			addr = RTL8712_DMA_VIQ;
+			break;
+		case 6:
+		case 7:
+			addr = RTL8712_DMA_VOQ;
+			break;
+		case 0x10:
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			addr = RTL8712_DMA_H2CCMD;
+			break;
+		default:
+			addr = RTL8712_DMA_BEQ;
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 4) {
+		switch (pattrib->qsel) {
+		case 0:
+		case 3:
+		case 1:
+		case 2:
+			addr = RTL8712_DMA_BEQ;/*RTL8712_EP_LO;*/
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			addr = RTL8712_DMA_VOQ;/*RTL8712_EP_HI;*/
+			break;
+		case 0x10:
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			addr = RTL8712_DMA_H2CCMD;
+			break;
+		default:
+			addr = RTL8712_DMA_BEQ;/*RTL8712_EP_LO;*/
+			break;
+		}
+	}
+	return addr;
+}
+
+static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,
+					 struct hw_xmit *phwxmit,
+					 struct tx_servq *ptxservq,
+					 struct  __queue *pframe_queue)
+{
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame *pxmitframe = NULL;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = get_next(xmitframe_phead);
+	if ((end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist,
+			     struct xmit_frame, list);
+		list_delete(&pxmitframe->list);
+		ptxservq->qcnt--;
+		phwxmit->txcmdcnt++;
+	}
+	return pxmitframe;
+}
+
+static struct xmit_frame *dequeue_xframe_ex(struct xmit_priv *pxmitpriv,
+				     struct hw_xmit *phwxmit_i, sint entry)
+{
+	unsigned long irqL0;
+	struct list_head *sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	struct  __queue *pframe_queue = NULL;
+	struct	xmit_frame *pxmitframe = NULL;
+	int i, inx[4];
+	int j, tmp, acirp_cnt[4];
+
+	/*entry indx: 0->vo, 1->vi, 2->be, 3->bk.*/
+	inx[0] = 0; acirp_cnt[0] = pxmitpriv->voq_cnt;
+	inx[1] = 1; acirp_cnt[1] = pxmitpriv->viq_cnt;
+	inx[2] = 2; acirp_cnt[2] = pxmitpriv->beq_cnt;
+	inx[3] = 3; acirp_cnt[3] = pxmitpriv->bkq_cnt;
+	for (i = 0; i < 4; i++) {
+		for (j = i + 1; j < 4; j++) {
+			if (acirp_cnt[j] < acirp_cnt[i]) {
+				tmp = acirp_cnt[i];
+				acirp_cnt[i] = acirp_cnt[j];
+				acirp_cnt[j] = tmp;
+				tmp = inx[i];
+				inx[i] = inx[j];
+				inx[j] = tmp;
+			}
+		}
+	}
+	spin_lock_irqsave(&pxmitpriv->lock, irqL0);
+	for (i = 0; i < entry; i++) {
+		phwxmit = phwxmit_i + inx[i];
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+		while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
+			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,
+				  tx_pending);
+			pframe_queue = &ptxservq->sta_pending;
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit,
+				     ptxservq, pframe_queue);
+			if (pxmitframe) {
+				phwxmit->accnt--;
+				goto exit_dequeue_xframe_ex;
+			}
+			sta_plist = get_next(sta_plist);
+			/*Remove sta node when there are no pending packets.*/
+			if (_queue_empty(pframe_queue)) {
+				/*must be done after get_next and before break*/
+				list_delete(&ptxservq->tx_pending);
+			}
+		}
+	}
+exit_dequeue_xframe_ex:
+	spin_unlock_irqrestore(&pxmitpriv->lock, irqL0);
+	return pxmitframe;
+}
+
+void r8712_do_queue_select(struct _adapter *padapter,
+			   struct pkt_attrib *pattrib)
+{
+	unsigned int qsel = 0;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+
+	if (pdvobj->nr_endpoint == 6)
+		qsel = (unsigned int) pattrib->priority;
+	else if (pdvobj->nr_endpoint == 4) {
+		qsel = (unsigned int) pattrib->priority;
+		if (qsel == 0 || qsel == 3)
+			qsel = 3;
+		else if (qsel == 1 || qsel == 2)
+			qsel = 1;
+		else if (qsel == 4 || qsel == 5)
+			qsel = 5;
+		else if (qsel == 6 || qsel == 7)
+			qsel = 7;
+		else
+			qsel = 3;
+	}
+	pattrib->qsel = qsel;
+}
+
+#ifdef CONFIG_R8712_TX_AGGR
+u8 r8712_construct_txaggr_cmd_desc(struct xmit_buf *pxmitbuf)
+{
+	struct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;
+
+	/* Fill up TxCmd Descriptor according as USB FW Tx Aaggregation info.*/
+	/* dw0 */
+	ptx_desc->txdw0 = cpu_to_le32(CMD_HDR_SZ&0xffff);
+	ptx_desc->txdw0 |=
+		cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);
+	ptx_desc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	/* dw1 */
+	ptx_desc->txdw1 |= cpu_to_le32((0x13<<QSEL_SHT)&0x00001f00);
+
+	return _SUCCESS;
+}
+
+u8 r8712_construct_txaggr_cmd_hdr(struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)
+		pxmitbuf->priv_data;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+	struct cmd_hdr *pcmd_hdr = (struct cmd_hdr  *)
+		(pxmitbuf->pbuf + TXDESC_SIZE);
+
+	/* Fill up Cmd Header for USB FW Tx Aggregation.*/
+	/* dw0 */
+	pcmd_hdr->cmd_dw0 = cpu_to_le32((GEN_CMD_CODE(_AMSDU_TO_AMPDU) << 16) |
+					(pcmdpriv->cmd_seq << 24));
+	pcmdpriv->cmd_seq++;
+
+	return _SUCCESS;
+}
+
+u8 r8712_append_mpdu_unit(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;
+	int last_txcmdsz = 0;
+	int padding_sz = 0;
+
+	/* 802.3->802.11 convertor */
+	r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	/* free skb struct */
+	r8712_xmit_complete(padapter, pxmitframe);
+	if (pxmitframe->attrib.ether_type != 0x0806) {
+		if ((pxmitframe->attrib.ether_type != 0x888e) &&
+			(pxmitframe->attrib.dhcp_pkt != 1)) {
+			r8712_issue_addbareq_cmd(padapter,
+					pxmitframe->attrib.priority);
+		}
+	}
+	pxmitframe->last[0] = 1;
+	update_txdesc(pxmitframe, (uint *)(pxmitframe->buf_addr),
+		pxmitframe->attrib.last_txcmdsz);
+	/*padding zero */
+	last_txcmdsz = pxmitframe->attrib.last_txcmdsz;
+	padding_sz = (8 - (last_txcmdsz % 8));
+	if ((last_txcmdsz % 8) != 0) {
+		int i;
+		for (i = 0; i < padding_sz; i++)
+			*(pxmitframe->buf_addr+TXDESC_SIZE+last_txcmdsz+i) = 0;
+	}
+	/* Add the new mpdu's length */
+	ptx_desc->txdw0 = cpu_to_le32((ptx_desc->txdw0&0xffff0000) |
+		((ptx_desc->txdw0&0x0000ffff)+
+			((TXDESC_SIZE+last_txcmdsz+padding_sz)&0x0000ffff)));
+
+	return _SUCCESS;
+}
+
+
+u8 r8712_xmitframe_aggr_1st(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	/* linux complete context doesnt need to protect */
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf+TXDESC_SIZE+CMD_HDR_SZ;
+	/*RTL8712_DMA_H2CCMD */
+	r8712_construct_txaggr_cmd_desc(pxmitbuf);
+	r8712_construct_txaggr_cmd_hdr(pxmitbuf);
+	if (r8712_append_mpdu_unit(pxmitbuf, pxmitframe) == _SUCCESS)
+		pxmitbuf->aggr_nr = 1;
+
+	return _SUCCESS;
+}
+
+u16 r8712_xmitframe_aggr_next(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf + TXDESC_SIZE +
+		(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);
+	if (r8712_append_mpdu_unit(pxmitbuf, pxmitframe) == _SUCCESS) {
+		r8712_free_xmitframe_ex(&pxmitframe->padapter->xmitpriv,
+					pxmitframe);
+		pxmitbuf->aggr_nr++;
+	}
+
+	return TXDESC_SIZE +
+		(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);
+}
+
+u8 r8712_dump_aggr_xframe(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *) &padapter->dvobjpriv;
+	struct tx_desc * ptxdesc = (struct tx_desc *)pxmitbuf->pbuf;
+	struct cmd_hdr *pcmd_hdr = (struct cmd_hdr *)
+		(pxmitbuf->pbuf + TXDESC_SIZE);
+	u16 total_length = (u16) (ptxdesc->txdw0 & 0xffff);
+
+	/* use 1st xmitframe as media */
+	xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+	pcmd_hdr->cmd_dw0 = cpu_to_le32(((total_length-CMD_HDR_SZ)&0x0000ffff)|
+					(pcmd_hdr->cmd_dw0&0xffff0000));
+
+	/* urb length in cmd_dw1 */
+	pcmd_hdr->cmd_dw1 = cpu_to_le32((pxmitbuf->aggr_nr & 0xff)|
+					((total_length+TXDESC_SIZE) << 16));
+	pxmitframe->last[0] = 1;
+	pxmitframe->bpending[0] = false;
+	pxmitframe->mem_addr = pxmitbuf->pbuf;
+
+	if ((pdvobj->ishighspeed && ((total_length+TXDESC_SIZE)%0x200) == 0) ||
+		((!pdvobj->ishighspeed &&
+			((total_length+TXDESC_SIZE)%0x40) == 0))) {
+		ptxdesc->txdw0 |= cpu_to_le32
+			(((TXDESC_SIZE+OFFSET_SZ+8)<<OFFSET_SHT)&0x00ff0000);
+		/*32 bytes for TX Desc + 8 bytes pending*/
+	} else {
+		ptxdesc->txdw0 |= cpu_to_le32
+			(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);
+		/*default = 32 bytes for TX Desc*/
+	}
+	r8712_write_port(pxmitframe->padapter, RTL8712_DMA_H2CCMD,
+			total_length+TXDESC_SIZE, (u8 *)pxmitframe);
+
+	return _SUCCESS;
+}
+
+#endif
+
+static void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz)
+{
+	uint qsel;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct tx_desc *ptxdesc = (struct tx_desc *)pmem;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+#ifdef CONFIG_R8712_TX_AGGR
+	struct cmd_priv *pcmdpriv = (struct cmd_priv *)&padapter->cmdpriv;
+#endif
+	u8 blnSetTxDescOffset;
+	sint bmcst = IS_MCAST(pattrib->ra);
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct tx_desc txdesc_mp;
+
+	memcpy(&txdesc_mp, ptxdesc, sizeof(struct tx_desc));
+	memset(ptxdesc, 0, sizeof(struct tx_desc));
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
+	if (pdvobj->ishighspeed) {
+		if (((sz + TXDESC_SIZE) % 512) == 0)
+			blnSetTxDescOffset = 1;
+		else
+			blnSetTxDescOffset = 0;
+	} else {
+		if (((sz + TXDESC_SIZE) % 64) == 0)
+			blnSetTxDescOffset = 1;
+		else
+			blnSetTxDescOffset = 0;
+	}
+	if (blnSetTxDescOffset) {
+		/* 32 bytes for TX Desc + 8 bytes pending */
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ + 8) <<
+			      OFFSET_SHT) & 0x00ff0000);
+	} else {
+		/* default = 32 bytes for TX Desc */
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ) <<
+				  OFFSET_SHT) & 0x00ff0000);
+	}
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+	if (pxmitframe->frame_tag == DATA_FRAMETAG) {
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);
+
+#ifdef CONFIG_R8712_TX_AGGR
+		/* dirty workaround, need to check if it is aggr cmd. */
+		if ((u8 *)pmem != (u8 *)pxmitframe->pxmitbuf->pbuf) {
+			ptxdesc->txdw0 |= cpu_to_le32
+				((0x3 << TYPE_SHT)&TYPE_MSK);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+			if (qsel == 2)
+				qsel = 0;
+			ptxdesc->txdw1 |= cpu_to_le32
+				((qsel << QSEL_SHT) & 0x00001f00);
+			ptxdesc->txdw2 = cpu_to_le32
+				((qsel << RTS_RC_SHT)&0x001f0000);
+			ptxdesc->txdw6 |= cpu_to_le32
+				((0x5 << RSVD6_SHT)&RSVD6_MSK);
+		} else {
+			ptxdesc->txdw0 |= cpu_to_le32
+				((0x3 << TYPE_SHT)&TYPE_MSK);
+			ptxdesc->txdw1 |= cpu_to_le32
+				((0x13 << QSEL_SHT) & 0x00001f00);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+			if (qsel == 2)
+				qsel = 0;
+			ptxdesc->txdw2 = cpu_to_le32
+				((qsel << RTS_RC_SHT)&0x0001f000);
+			ptxdesc->txdw7 |= cpu_to_le32
+				(pcmdpriv->cmd_seq << 24);
+			pcmdpriv->cmd_seq++;
+		}
+		pattrib->qsel = 0x13;
+#else
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+#endif
+		if (!pqospriv->qos_option)
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(16));/*Non-QoS*/
+		if ((pattrib->encrypt > 0) && !pattrib->bswenc) {
+			switch (pattrib->encrypt) {	/*SEC_TYPE*/
+			case _WEP40_:
+			case _WEP104_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x01 << 22) &
+						  0x00c00000);
+				/*KEY_ID when WEP is used;*/
+				ptxdesc->txdw1 |= cpu_to_le32((psecuritypriv->
+						  PrivacyKeyIndex << 17) &
+						  0x00060000);
+				break;
+			case _TKIP_:
+			case _TKIP_WTMIC_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x02 << 22) &
+						  0x00c00000);
+				break;
+			case _AES_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x03 << 22) &
+						  0x00c00000);
+				break;
+			case _NO_PRIVACY_:
+			default:
+				break;
+			}
+		}
+		/*offset 8*/
+		if (bmcst)
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+
+		/*offset 12*/
+		/* f/w will increase the seqnum by itself, driver pass the
+		 * correct priority to fw
+		 * fw will check the correct priority for increasing the
+		 * seqnum per tid. about usb using 4-endpoint, qsel points out
+		 * the correct mapping between AC&Endpoint,
+		 * the purpose is that correct mapping lets the MAC release
+		 * the AC Queue list correctly. */
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &
+				 0x0fff0000);
+		if ((pattrib->ether_type != 0x888e) &&
+		    (pattrib->ether_type != 0x0806) &&
+		    (pattrib->dhcp_pkt != 1)) {
+			/*Not EAP & ARP type data packet*/
+			if (phtpriv->ht_option == 1) { /*B/G/N Mode*/
+				if (phtpriv->ampdu_enable != true)
+					ptxdesc->txdw2 |= cpu_to_le32(BK);
+			}
+		} else {
+			/* EAP data packet and ARP packet.
+			 * Use the 1M data rate to send the EAP/ARP packet.
+			 * This will maybe make the handshake smooth.
+			 */
+			/*driver uses data rate*/
+			ptxdesc->txdw4 = cpu_to_le32(0x80000000);
+			ptxdesc->txdw5 = cpu_to_le32(0x001f8000);/*1M*/
+		}
+		if (pattrib->pctrl == 1) { /* mp tx packets */
+			struct tx_desc *ptxdesc_mp;
+			ptxdesc_mp = &txdesc_mp;
+			/* offset 8 */
+			ptxdesc->txdw2 = cpu_to_le32(ptxdesc_mp->txdw2);
+			if (bmcst)
+				ptxdesc->txdw2 |= cpu_to_le32(BMC);
+			ptxdesc->txdw2 |= cpu_to_le32(BK);
+			/* offset 16 */
+			ptxdesc->txdw4 = cpu_to_le32(ptxdesc_mp->txdw4);
+			/* offset 20 */
+			ptxdesc->txdw5 = cpu_to_le32(ptxdesc_mp->txdw5);
+			pattrib->pctrl = 0;/* reset to zero; */
+		}
+	} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {
+		/* offset 4 */
+		ptxdesc->txdw1 |= (0x05) & 0x1f;/*CAM_ID(MAC_ID), default=5;*/
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+		ptxdesc->txdw1 |= cpu_to_le32(BIT(16));/* Non-QoS */
+		/* offset 8 */
+		if (bmcst)
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+		/* offset 12 */
+		/* f/w will increase the seqnum by itself, driver pass the
+		 * correct priority to fw
+		 * fw will check the correct priority for increasing the seqnum
+		 * per tid. about usb using 4-endpoint, qsel points out the
+		 * correct mapping between AC&Endpoint,
+		 * the purpose is that correct mapping let the MAC releases
+		 * the AC Queue list correctly. */
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &
+					      0x0fff0000);
+		/* offset 16 */
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);/*gtest*/
+		/* offset 20 */
+		ptxdesc->txdw5 = cpu_to_le32(0x001f8000);/* gtest 1M */
+	} else if (pxmitframe->frame_tag == TXAGG_FRAMETAG) {
+		/* offset 4 */
+		qsel = 0x13;
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+	} else {
+		/* offset 4 */
+		qsel = (uint)(pattrib->priority&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+		/*offset 8*/
+		/*offset 12*/
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->seqnum << SEQ_SHT) &
+					      0x0fff0000);
+		/*offset 16*/
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);/*gtest*/
+		/*offset 20*/
+		ptxdesc->txdw5 = cpu_to_le32(0x001f9600);/*gtest*/
+	}
+}
+
+int r8712_xmitframe_complete(struct _adapter *padapter,
+			     struct xmit_priv *pxmitpriv,
+			     struct xmit_buf *pxmitbuf)
+{
+	struct hw_xmit *phwxmits;
+	sint hwentry;
+	struct xmit_frame *pxmitframe = NULL;
+#ifdef CONFIG_R8712_TX_AGGR
+	struct xmit_frame *p2ndxmitframe = NULL;
+#else
+	int res = _SUCCESS, xcnt = 0;
+#endif
+
+	phwxmits = pxmitpriv->hwxmits;
+	hwentry = pxmitpriv->hwxmit_entry;
+	if (pxmitbuf == NULL) {
+		pxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);
+		if (!pxmitbuf)
+			return false;
+#ifdef CONFIG_R8712_TX_AGGR
+		pxmitbuf->aggr_nr = 0;
+#endif
+	}
+	/* 1st frame dequeued */
+	pxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);
+	/* need to remember the 1st frame */
+	if (pxmitframe != NULL) {
+
+#ifdef CONFIG_R8712_TX_AGGR
+		/* 1. dequeue 2nd frame
+		 * 2. aggr if 2nd xframe is dequeued, else dump directly
+		 */
+		if (AGGR_NR_HIGH_BOUND > 1)
+			p2ndxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits,
+							hwentry);
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+			return false;
+		}
+		if (p2ndxmitframe != NULL)
+			if (p2ndxmitframe->frame_tag != DATA_FRAMETAG) {
+				r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+				return false;
+			}
+		r8712_xmitframe_aggr_1st(pxmitbuf, pxmitframe);
+		if (p2ndxmitframe != NULL) {
+			u16 total_length;
+			total_length = r8712_xmitframe_aggr_next(
+				pxmitbuf, p2ndxmitframe);
+			do {
+				p2ndxmitframe = dequeue_xframe_ex(
+					pxmitpriv, phwxmits, hwentry);
+				if (p2ndxmitframe != NULL)
+					total_length =
+						r8712_xmitframe_aggr_next(
+							pxmitbuf,
+							p2ndxmitframe);
+				else
+					break;
+			} while (total_length <= 0x1800 &&
+				pxmitbuf->aggr_nr <= AGGR_NR_HIGH_BOUND);
+		}
+		if (pxmitbuf->aggr_nr > 0)
+			r8712_dump_aggr_xframe(pxmitbuf, pxmitframe);
+
+#else
+
+		xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+		if (pxmitframe->frame_tag == DATA_FRAMETAG) {
+			if (pxmitframe->attrib.priority <= 15)
+				res = r8712_xmitframe_coalesce(padapter,
+					pxmitframe->pkt, pxmitframe);
+			/* always return ndis_packet after
+			 * r8712_xmitframe_coalesce */
+			r8712_xmit_complete(padapter, pxmitframe);
+		}
+		if (res == _SUCCESS)
+			dump_xframe(padapter, pxmitframe);
+		else
+			r8712_free_xmitframe_ex(pxmitpriv, pxmitframe);
+		xcnt++;
+#endif
+
+	} else { /* pxmitframe == NULL && p2ndxmitframe == NULL */
+		r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+		return false;
+	}
+	return true;
+}
+
+static void dump_xframe(struct _adapter *padapter,
+			struct xmit_frame *pxmitframe)
+{
+	int t, sz, w_sz;
+	u8 *mem_addr;
+	u32 ff_hwaddr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if (pxmitframe->attrib.ether_type != 0x0806) {
+		if (pxmitframe->attrib.ether_type != 0x888e)
+			r8712_issue_addbareq_cmd(padapter, pattrib->priority);
+	}
+	mem_addr = pxmitframe->buf_addr;
+	for (t = 0; t < pattrib->nr_frags; t++) {
+		if (t != (pattrib->nr_frags - 1)) {
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 :
+			     pattrib->icv_len);
+			pxmitframe->last[t] = 0;
+		} else {
+			sz = pattrib->last_txcmdsz;
+			pxmitframe->last[t] = 1;
+		}
+		update_txdesc(pxmitframe, (uint *)mem_addr, sz);
+		w_sz = sz + TXDESC_SIZE;
+		pxmitframe->mem_addr = mem_addr;
+		pxmitframe->bpending[t] = false;
+		ff_hwaddr = get_ff_hwaddr(pxmitframe);
+#ifdef CONFIG_R8712_TX_AGGR
+		r8712_write_port(padapter, RTL8712_DMA_H2CCMD, w_sz,
+				(unsigned char *)pxmitframe);
+#else
+		r8712_write_port(padapter, ff_hwaddr, w_sz,
+			   (unsigned char *)pxmitframe);
+#endif
+		mem_addr += w_sz;
+		mem_addr = (u8 *)RND4(((addr_t)(mem_addr)));
+	}
+}
+
+int r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int res = _SUCCESS;
+
+	res = r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	pxmitframe->pkt = NULL;
+	if (res == _SUCCESS)
+		dump_xframe(padapter, pxmitframe);
+	return res;
+}
+
+int r8712_xmit_enqueue(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (r8712_xmit_classifier(padapter, pxmitframe) == _FAIL) {
+		pxmitframe->pkt = NULL;
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/rtl8712_xmit.h b/drivers/staging/rtl8712/rtl8712_xmit.h
new file mode 100644
index 0000000..b50e7a1
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl8712_xmit.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_XMIT_H_
+#define _RTL8712_XMIT_H_
+
+#define HWXMIT_ENTRY	4
+
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX	1
+#define BE_QUEUE_INX	2
+#define BK_QUEUE_INX	3
+#define TS_QUEUE_INX	4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define TXDESC_SIZE 32
+#define TXDESC_OFFSET TXDESC_SIZE
+
+#define NR_AMSDU_XMITFRAME 8
+#define NR_TXAGG_XMITFRAME 8
+
+#define MAX_AMSDU_XMITBUF_SZ 8704
+#define MAX_TXAGG_XMITBUF_SZ 16384 /*16k*/
+
+
+#define tx_cmd tx_desc
+
+
+/*
+ *defined for TX DESC Operation
+ */
+
+#define MAX_TID (15)
+
+/*OFFSET 0*/
+#define OFFSET_SZ (0)
+#define OFFSET_SHT (16)
+#define OWN	BIT(31)
+#define FSG	BIT(27)
+#define LSG	BIT(26)
+#define TYPE_SHT (24)
+#define TYPE_MSK (0x03000000)
+
+/*OFFSET 4*/
+#define PKT_OFFSET_SZ (0)
+#define QSEL_SHT (8)
+#define HWPC BIT(31)
+
+/*OFFSET 8*/
+#define BMC BIT(7)
+#define BK BIT(30)
+#define AGG_EN BIT(29)
+#define RTS_RC_SHT (16)
+
+/*OFFSET 12*/
+#define SEQ_SHT (16)
+
+/*OFFSET 16*/
+#define TXBW BIT(18)
+
+/*OFFSET 20*/
+#define DISFB BIT(15)
+#define RSVD6_MSK (0x00E00000)
+#define RSVD6_SHT (21)
+
+struct tx_desc {
+	/*DWORD 0*/
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];
+};
+
+int r8712_xmitframe_complete(struct _adapter *padapter,
+			     struct xmit_priv *pxmitpriv,
+			     struct xmit_buf *pxmitbuf);
+void r8712_do_queue_select(struct _adapter *padapter,
+			   struct pkt_attrib *pattrib);
+
+#ifdef CONFIG_R8712_TX_AGGR
+u8 r8712_xmitframe_aggr_1st(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe);
+u8 r8712_dump_aggr_xframe(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe);
+#endif
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl871x_byteorder.h b/drivers/staging/rtl8712/rtl871x_byteorder.h
new file mode 100644
index 0000000..bd3703b
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_byteorder.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_BYTEORDER_H_
+#define _RTL871X_BYTEORDER_H_
+
+#if defined(__LITTLE_ENDIAN)
+#  include "little_endian.h"
+#elif defined(__BIG_ENDIAN)
+#  include "big_endian.h"
+#else
+#  error "Must be LITTLE/BIG Endian Host"
+#endif
+
+#endif /* _RTL871X_BYTEORDER_H_ */
+
diff --git a/drivers/staging/rtl8712/rtl871x_cmd.c b/drivers/staging/rtl8712/rtl871x_cmd.c
new file mode 100644
index 0000000..cd73f33
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_cmd.c
@@ -0,0 +1,1067 @@
+/******************************************************************************
+ * rtl871x_cmd.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_CMD_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/rtnetlink.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "rtl871x_byteorder.h"
+
+/*
+Caller and the r8712_cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+static sint _init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	sema_init(&(pcmdpriv->cmd_queue_sema), 0);
+	sema_init(&(pcmdpriv->terminate_cmdthread_sema), 0);
+
+	_init_queue(&(pcmdpriv->cmd_queue));
+
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	pcmdpriv->cmd_seq = 1;
+	pcmdpriv->cmd_allocated_buf = _malloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+	if (pcmdpriv->cmd_allocated_buf == NULL)
+		return _FAIL;
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ -
+			    ((addr_t)(pcmdpriv->cmd_allocated_buf) &
+			    (CMDBUFF_ALIGN_SZ-1));
+	pcmdpriv->rsp_allocated_buf = _malloc(MAX_RSPSZ + 4);
+	if (pcmdpriv->rsp_allocated_buf == NULL)
+		return _FAIL;
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 -
+			    ((addr_t)(pcmdpriv->rsp_allocated_buf) & 3);
+	pcmdpriv->cmd_issued_cnt = 0;
+	pcmdpriv->cmd_done_cnt = 0;
+	pcmdpriv->rsp_cnt = 0;
+	return _SUCCESS;
+}
+
+static sint _init_evt_priv(struct evt_priv *pevtpriv)
+{
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	pevtpriv->event_seq = 0;
+	pevtpriv->evt_allocated_buf = _malloc(MAX_EVTSZ + 4);
+
+	if (pevtpriv->evt_allocated_buf == NULL)
+		return _FAIL;
+	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 -
+			    ((addr_t)(pevtpriv->evt_allocated_buf) & 3);
+	pevtpriv->evt_done_cnt = 0;
+	return _SUCCESS;
+}
+
+static void _free_evt_priv(struct evt_priv *pevtpriv)
+{
+	kfree(pevtpriv->evt_allocated_buf);
+}
+
+static void _free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	if (pcmdpriv) {
+		kfree(pcmdpriv->cmd_allocated_buf);
+		kfree(pcmdpriv->rsp_allocated_buf);
+	}
+}
+
+/*
+Calling Context:
+
+_enqueue_cmd can only be called between kernel thread,
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+static sint _enqueue_cmd(struct  __queue *queue, struct cmd_obj *obj)
+{
+	unsigned long irqL;
+
+	if (obj == NULL)
+		return _SUCCESS;
+	spin_lock_irqsave(&queue->lock, irqL);
+	list_insert_tail(&obj->list, &queue->queue);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	return _SUCCESS;
+}
+
+static struct cmd_obj *_dequeue_cmd(struct  __queue *queue)
+{
+	unsigned long irqL;
+	struct cmd_obj *obj;
+
+	spin_lock_irqsave(&(queue->lock), irqL);
+	if (is_list_empty(&(queue->queue)))
+		obj = NULL;
+	else {
+		obj = LIST_CONTAINOR(get_next(&(queue->queue)),
+				     struct cmd_obj, list);
+		list_delete(&obj->list);
+	}
+	spin_unlock_irqrestore(&(queue->lock), irqL);
+	return obj;
+}
+
+u32 r8712_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	return _init_cmd_priv(pcmdpriv);
+}
+
+u32 r8712_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	return _init_evt_priv(pevtpriv);
+}
+
+void r8712_free_evt_priv(struct evt_priv *pevtpriv)
+{
+	_free_evt_priv(pevtpriv);
+}
+
+void r8712_free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	_free_cmd_priv(pcmdpriv);
+}
+
+u32 r8712_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	int res;
+
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == true)
+		return _FAIL;
+	res = _enqueue_cmd(&pcmdpriv->cmd_queue, obj);
+	up(&pcmdpriv->cmd_queue_sema);
+	return res;
+}
+
+u32 r8712_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	unsigned long irqL;
+	struct  __queue *queue;
+
+	if (obj == NULL)
+		return _SUCCESS;
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == true)
+		return _FAIL;
+	queue = &pcmdpriv->cmd_queue;
+	spin_lock_irqsave(&queue->lock, irqL);
+	list_insert_tail(&obj->list, &queue->queue);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	up(&pcmdpriv->cmd_queue_sema);
+	return _SUCCESS;
+}
+
+struct cmd_obj *r8712_dequeue_cmd(struct  __queue *queue)
+{
+	return _dequeue_cmd(queue);
+}
+
+void r8712_free_cmd_obj(struct cmd_obj *pcmd)
+{
+	if ((pcmd->cmdcode != _JoinBss_CMD_) &&
+	    (pcmd->cmdcode != _CreateBss_CMD_))
+		kfree((unsigned char *)pcmd->parmbuf);
+	if (pcmd->rsp != NULL) {
+		if (pcmd->rspsz != 0)
+			kfree((unsigned char *)pcmd->rsp);
+	}
+	kfree((unsigned char *)pcmd);
+}
+
+/*
+r8712_sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC,
+	 YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+u8 r8712_sitesurvey_cmd(struct _adapter *padapter,
+			struct ndis_802_11_ssid *pssid)
+{
+	struct cmd_obj	*ph2c;
+	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psurveyPara = (struct sitesurvey_parm *)_malloc(
+		       sizeof(struct sitesurvey_parm));
+	if (psurveyPara == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,
+				   GEN_CMD_CODE(_SiteSurvey));
+	psurveyPara->bsslimit = cpu_to_le32(48);
+	psurveyPara->passive_mode = cpu_to_le32(pmlmepriv->passive_mode);
+	psurveyPara->ss_ssidlen = 0;
+	memset(psurveyPara->ss_ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	if ((pssid != NULL) && (pssid->SsidLength)) {
+		memcpy(psurveyPara->ss_ssid, pssid->Ssid, pssid->SsidLength);
+		psurveyPara->ss_ssidlen = cpu_to_le32(pssid->SsidLength);
+	}
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_SITE_SURVEY);
+	padapter->blnEnableRxFF0Filter = 0;
+	return _SUCCESS;
+}
+
+u8 r8712_setdatarate_cmd(struct _adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj		*ph2c;
+	struct setdatarate_parm	*pbsetdataratepara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pbsetdataratepara = (struct setdatarate_parm *)_malloc(
+			     sizeof(struct setdatarate_parm));
+	if (pbsetdataratepara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara,
+				   GEN_CMD_CODE(_SetDataRate));
+	pbsetdataratepara->mac_id = 5;
+	memcpy(pbsetdataratepara->datarates, rateset, NumRates);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_set_chplan_cmd(struct _adapter *padapter, int chplan)
+{
+	struct cmd_obj *ph2c;
+	struct SetChannelPlan_param *psetchplanpara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetchplanpara = (struct SetChannelPlan_param *)
+		_malloc(sizeof(struct SetChannelPlan_param));
+	if (psetchplanpara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetchplanpara,
+				GEN_CMD_CODE(_SetChannelPlan));
+	psetchplanpara->ChannelPlan = chplan;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setbasicrate_cmd(struct _adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj *ph2c;
+	struct setbasicrate_parm *pssetbasicratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pssetbasicratepara = (struct setbasicrate_parm *)_malloc(
+			      sizeof(struct setbasicrate_parm));
+	if (pssetbasicratepara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara,
+		_SetBasicRate_CMD_);
+	memcpy(pssetbasicratepara->basicrates, rateset, NumRates);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+/* power tracking mechanism setting */
+u8 r8712_setptm_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj		*ph2c;
+	struct writePTM_parm	*pwriteptmparm;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct writePTM_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetPT));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setfwdig_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj *ph2c;
+	struct writePTM_parm *pwriteptmparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct setdig_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetDIG));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setfwra_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj *ph2c;
+	struct writePTM_parm *pwriteptmparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct setra_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetRA));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrfreg_cmd(struct _adapter  *padapter, u8 offset, u32 val)
+{
+	struct cmd_obj *ph2c;
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriterfparm = (struct writeRF_parm *)_malloc(
+			sizeof(struct writeRF_parm));
+	if (pwriterfparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));
+	pwriterfparm->offset = offset;
+	pwriterfparm->value = val;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_getrfreg_cmd(struct _adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj *ph2c;
+	struct readRF_parm *prdrfparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	prdrfparm = (struct readRF_parm *)_malloc(sizeof(struct readRF_parm));
+	if (prdrfparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_GetRFReg);
+	ph2c->parmbuf = (unsigned char *)prdrfparm;
+	ph2c->cmdsz =  sizeof(struct readRF_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readRF_rsp);
+	prdrfparm->offset = offset;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+void r8712_getbbrfreg_cmdrsp_callback(struct _adapter *padapter,
+				      struct cmd_obj *pcmd)
+{
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+	padapter->mppriv.workparam.bcompleted = true;
+}
+
+void r8712_readtssi_cmdrsp_callback(struct _adapter *padapter,
+				struct cmd_obj *pcmd)
+{
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+
+	padapter->mppriv.workparam.bcompleted = true;
+}
+
+u8 r8712_createbss_cmd(struct _adapter *padapter)
+{
+	struct cmd_obj *pcmd;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct wlan_bssid_ex *pdev_network =
+				 &padapter->registrypriv.dev_network;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _CreateBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = r8712_get_ndis_wlan_bssid_ex_sz((
+			struct ndis_wlan_bssid_ex *)
+			pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	/* notes: translate IELength & Length after assign to cmdsz; */
+	pdev_network->Length = cpu_to_le32(pcmd->cmdsz);
+	pdev_network->IELength = cpu_to_le32(pdev_network->IELength);
+	pdev_network->Ssid.SsidLength = cpu_to_le32(
+					pdev_network->Ssid.SsidLength);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+u8 r8712_joinbss_cmd(struct _adapter  *padapter, struct wlan_network *pnetwork)
+{
+	u8 *auth;
+	uint t_len = 0;
+	struct ndis_wlan_bssid_ex *psecnetwork;
+	struct cmd_obj		*pcmd;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->
+						network.InfrastructureMode;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	t_len = sizeof(u32) + 6 * sizeof(unsigned char) + 2 +
+			sizeof(struct ndis_802_11_ssid) + sizeof(u32) +
+			sizeof(s32) +
+			sizeof(enum NDIS_802_11_NETWORK_TYPE) +
+			sizeof(struct NDIS_802_11_CONFIGURATION) +
+			sizeof(enum NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof(NDIS_802_11_RATES_EX) +
+			sizeof(u32) + MAX_IE_SZ;
+
+	/* for hidden ap to set fw_state here */
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) !=
+	    true) {
+		switch (ndis_network_mode) {
+		case Ndis802_11IBSS:
+			pmlmepriv->fw_state |= WIFI_ADHOC_STATE;
+			break;
+		case Ndis802_11Infrastructure:
+			pmlmepriv->fw_state |= WIFI_STATION_STATE;
+			break;
+		case Ndis802_11APMode:
+		case Ndis802_11AutoUnknown:
+		case Ndis802_11InfrastructureMax:
+			break;
+		}
+	}
+	psecnetwork = (struct ndis_wlan_bssid_ex *)&psecuritypriv->sec_bss;
+	if (psecnetwork == NULL) {
+		kfree(pcmd);
+		return _FAIL;
+	}
+	memset(psecnetwork, 0, t_len);
+	memcpy(psecnetwork, &pnetwork->network, t_len);
+	auth = &psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0] = (unsigned char)
+					     psecnetwork->IELength;
+	if ((psecnetwork->IELength-12) < (256 - 1))
+		memcpy(&psecuritypriv->authenticator_ie[1],
+			&psecnetwork->IEs[12], psecnetwork->IELength-12);
+	else
+		memcpy(&psecuritypriv->authenticator_ie[1],
+			&psecnetwork->IEs[12], (256-1));
+	psecnetwork->IELength = 0;
+	/* If the the driver wants to use the bssid to create the connection.
+	 * If not,  we copy the connecting AP's MAC address to it so that
+	 * the driver just has the bssid information for PMKIDList searching.
+	 */
+	if (pmlmepriv->assoc_by_bssid == false)
+		memcpy(&pmlmepriv->assoc_bssid[0],
+			&pnetwork->network.MacAddress[0], ETH_ALEN);
+	psecnetwork->IELength = r8712_restruct_sec_ie(padapter,
+						&pnetwork->network.IEs[0],
+						&psecnetwork->IEs[0],
+						pnetwork->network.IELength);
+	pqospriv->qos_option = 0;
+	if (pregistrypriv->wmm_enable) {
+		u32 tmp_len;
+
+		tmp_len = r8712_restruct_wmm_ie(padapter,
+					  &pnetwork->network.IEs[0],
+					  &psecnetwork->IEs[0],
+					  pnetwork->network.IELength,
+					  psecnetwork->IELength);
+		if (psecnetwork->IELength != tmp_len) {
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; /* WMM IE in beacon */
+		} else
+			pqospriv->qos_option = 0; /* no WMM IE in beacon */
+	}
+	if (pregistrypriv->ht_enable) {
+		/* For WEP mode, we will use the bg mode to do the connection
+		 * to avoid some IOT issues, especially for Realtek 8192u
+		 * SoftAP.
+		 */
+		if ((padapter->securitypriv.PrivacyAlgrthm != _WEP40_) &&
+		    (padapter->securitypriv.PrivacyAlgrthm != _WEP104_)) {
+			/* restructure_ht_ie */
+			r8712_restructure_ht_ie(padapter,
+						&pnetwork->network.IEs[0],
+						&psecnetwork->IEs[0],
+						pnetwork->network.IELength,
+						&psecnetwork->IELength);
+		}
+	}
+	psecuritypriv->supplicant_ie[0] = (u8)psecnetwork->IELength;
+	if (psecnetwork->IELength < 255)
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],
+			psecnetwork->IELength);
+	else
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],
+			255);
+	/* get cmdsz before endian conversion */
+	pcmd->cmdsz = r8712_get_ndis_wlan_bssid_ex_sz(psecnetwork);
+#ifdef __BIG_ENDIAN
+	/* wlan_network endian conversion */
+	psecnetwork->Length = cpu_to_le32(psecnetwork->Length);
+	psecnetwork->Ssid.SsidLength = cpu_to_le32(
+				       psecnetwork->Ssid.SsidLength);
+	psecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);
+	psecnetwork->Rssi = cpu_to_le32(psecnetwork->Rssi);
+	psecnetwork->NetworkTypeInUse = cpu_to_le32(
+					psecnetwork->NetworkTypeInUse);
+	psecnetwork->Configuration.ATIMWindow = cpu_to_le32(
+				psecnetwork->Configuration.ATIMWindow);
+	psecnetwork->Configuration.BeaconPeriod = cpu_to_le32(
+				 psecnetwork->Configuration.BeaconPeriod);
+	psecnetwork->Configuration.DSConfig = cpu_to_le32(
+				psecnetwork->Configuration.DSConfig);
+	psecnetwork->Configuration.FHConfig.DwellTime = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.DwellTime);
+	psecnetwork->Configuration.FHConfig.HopPattern = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.HopPattern);
+	psecnetwork->Configuration.FHConfig.HopSet = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.HopSet);
+	psecnetwork->Configuration.FHConfig.Length = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.Length);
+	psecnetwork->Configuration.Length = cpu_to_le32(
+				psecnetwork->Configuration.Length);
+	psecnetwork->InfrastructureMode = cpu_to_le32(
+				psecnetwork->InfrastructureMode);
+	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);
+#endif
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _JoinBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+u8 r8712_disassoc_cmd(struct _adapter *padapter) /* for sta_mode */
+{
+	struct cmd_obj *pdisconnect_cmd;
+	struct disconnect_parm *pdisconnect;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	pdisconnect_cmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pdisconnect_cmd == NULL)
+		return _FAIL;
+	pdisconnect = (struct disconnect_parm *)_malloc(
+		      sizeof(struct disconnect_parm));
+	if (pdisconnect == NULL) {
+		kfree((u8 *)pdisconnect_cmd);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(pdisconnect_cmd, pdisconnect,
+				   _DisConnect_CMD_);
+	r8712_enqueue_cmd(pcmdpriv, pdisconnect_cmd);
+	return _SUCCESS;
+}
+
+u8 r8712_setopmode_cmd(struct _adapter *padapter,
+		 enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct cmd_obj *ph2c;
+	struct setopmode_parm *psetop;
+
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetop = (struct setopmode_parm *)_malloc(
+		  sizeof(struct setopmode_parm));
+	if (psetop == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);
+	psetop->mode = (u8)networktype;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setstakey_cmd(struct _adapter *padapter, u8 *psta, u8 unicast_key)
+{
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp *psetstakey_rsp = NULL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct sta_info *sta = (struct sta_info *)psta;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetstakey_para = (struct set_stakey_parm *)_malloc(
+			  sizeof(struct set_stakey_parm));
+	if (psetstakey_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	psetstakey_rsp = (struct set_stakey_rsp *)_malloc(
+			  sizeof(struct set_stakey_rsp));
+	if (psetstakey_rsp == NULL) {
+		kfree((u8 *) ph2c);
+		kfree((u8 *) psetstakey_para);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+	ph2c->rsp = (u8 *) psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+	memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		psetstakey_para->algorithm = (unsigned char)
+					    psecuritypriv->PrivacyAlgrthm;
+	else
+		GET_ENCRY_ALGO(psecuritypriv, sta,
+			       psetstakey_para->algorithm, false);
+	if (unicast_key == true)
+		memcpy(&psetstakey_para->key, &sta->x_UncstKey, 16);
+	else
+		memcpy(&psetstakey_para->key,
+			&psecuritypriv->XGrpKey[
+			psecuritypriv->XGrpKeyid - 1]. skey, 16);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrfintfs_cmd(struct _adapter *padapter, u8 mode)
+{
+	struct cmd_obj *ph2c;
+	struct setrfintfs_parm *psetrfintfsparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetrfintfsparm = (struct setrfintfs_parm *)_malloc(
+			   sizeof(struct setrfintfs_parm));
+	if (psetrfintfsparm == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrfintfsparm,
+				   GEN_CMD_CODE(_SetRFIntFs));
+	psetrfintfsparm->rfintfs = mode;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrttbl_cmd(struct _adapter *padapter,
+		      struct setratable_parm *prate_table)
+{
+	struct cmd_obj *ph2c;
+	struct setratable_parm *psetrttblparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetrttblparm = (struct setratable_parm *)_malloc(
+			sizeof(struct setratable_parm));
+	if (psetrttblparm == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm,
+				   GEN_CMD_CODE(_SetRaTable));
+	memcpy(psetrttblparm, prate_table, sizeof(struct setratable_parm));
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_gettssi_cmd(struct _adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct readTSSI_parm *prdtssiparm;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	prdtssiparm = (struct readTSSI_parm *)
+		_malloc(sizeof(struct readTSSI_parm));
+	if (prdtssiparm == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_ReadTSSI);
+	ph2c->parmbuf = (unsigned char *)prdtssiparm;
+	ph2c->cmdsz = sizeof(struct readTSSI_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readTSSI_rsp);
+
+	prdtssiparm->offset = offset;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setMacAddr_cmd(struct _adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct SetMacAddr_param	*psetMacAddr_para;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetMacAddr_para = (struct SetMacAddr_param *)_malloc(
+			   sizeof(struct SetMacAddr_param));
+	if (psetMacAddr_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetMacAddr_para,
+				   _SetMacAddress_CMD_);
+	memcpy(psetMacAddr_para->MacAddr, mac_addr, ETH_ALEN);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setassocsta_cmd(struct _adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv			*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj			*ph2c;
+	struct set_assocsta_parm	*psetassocsta_para;
+	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetassocsta_para = (struct set_assocsta_parm *)
+			    _malloc(sizeof(struct set_assocsta_parm));
+	if (psetassocsta_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	psetassocsta_rsp = (struct set_stakey_rsp *)_malloc(
+			    sizeof(struct set_assocsta_rsp));
+	if (psetassocsta_rsp == NULL) {
+		kfree((u8 *)ph2c);
+		kfree((u8 *)psetassocsta_para);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
+	ph2c->rsp = (u8 *) psetassocsta_rsp;
+	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+	memcpy(psetassocsta_para->addr, mac_addr, ETH_ALEN);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_addbareq_cmd(struct _adapter *padapter, u8 tid)
+{
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj		*ph2c;
+	struct addBaReq_parm	*paddbareq_parm;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	paddbareq_parm = (struct addBaReq_parm *)_malloc(
+			  sizeof(struct addBaReq_parm));
+	if (paddbareq_parm == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	paddbareq_parm->tid = tid;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm,
+				   GEN_CMD_CODE(_AddBAReq));
+	r8712_enqueue_cmd_ex(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_wdg_wk_cmd(struct _adapter *padapter)
+{
+	struct cmd_obj *ph2c;
+	struct drvint_cmd_parm  *pdrvintcmd_param;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pdrvintcmd_param = (struct drvint_cmd_parm *)_malloc(
+			   sizeof(struct drvint_cmd_parm));
+	if (pdrvintcmd_param == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	pdrvintcmd_param->i_cid = WDG_WK_CID;
+	pdrvintcmd_param->sz = 0;
+	pdrvintcmd_param->pbuf = NULL;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvintcmd_param, _DRV_INT_CMD_);
+	r8712_enqueue_cmd_ex(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+void r8712_survey_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res != H2C_SUCCESS)
+		clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_disassoc_cmd_callback(struct _adapter *padapter,
+				 struct cmd_obj *pcmd)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res != H2C_SUCCESS) {
+		spin_lock_irqsave(&pmlmepriv->lock, irqL);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+		return;
+	}
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_joinbss_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if ((pcmd->res != H2C_SUCCESS))
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_createbss_cmd_callback(struct _adapter *padapter,
+				  struct cmd_obj *pcmd)
+{
+	unsigned long irqL;
+	u8 timer_cancelled;
+	struct sta_info *psta = NULL;
+	struct wlan_network *pwlan = NULL;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pnetwork = (struct ndis_wlan_bssid_ex *)
+					      pcmd->parmbuf;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+	if ((pcmd->res != H2C_SUCCESS))
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->
+					Configuration.ATIMWindow);
+	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->
+					Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->
+					Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->
+					   InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((pmlmepriv->fw_state) & WIFI_AP_STATE) {
+		psta = r8712_get_stainfo(&padapter->stapriv,
+					 pnetwork->MacAddress);
+		if (!psta) {
+			psta = r8712_alloc_stainfo(&padapter->stapriv,
+						   pnetwork->MacAddress);
+			if (psta == NULL)
+				goto createbss_cmd_fail ;
+		}
+		r8712_indicate_connect(padapter);
+	} else {
+		pwlan = _r8712_alloc_network(pmlmepriv);
+		if (pwlan == NULL) {
+			pwlan = r8712_get_oldest_wlan_network(
+				&pmlmepriv->scanned_queue);
+			if (pwlan == NULL)
+				goto createbss_cmd_fail;
+			pwlan->last_scanned = jiffies;
+		} else
+			list_insert_tail(&(pwlan->list),
+					 &pmlmepriv->scanned_queue.queue);
+		pnetwork->Length = r8712_get_ndis_wlan_bssid_ex_sz(pnetwork);
+		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+		pwlan->fixed = true;
+		memcpy(&tgt_network->network, pnetwork,
+			(r8712_get_ndis_wlan_bssid_ex_sz(pnetwork)));
+		if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+			pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+		/* we will set _FW_LINKED when there is one more sat to
+		 * join us (stassoc_event_callback) */
+	}
+createbss_cmd_fail:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_setstaKey_cmdrsp_callback(struct _adapter *padapter,
+				     struct cmd_obj *pcmd)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)
+						(pcmd->rsp);
+	struct sta_info *psta = r8712_get_stainfo(pstapriv,
+						  psetstakey_rsp->addr);
+
+	if (psta == NULL)
+		goto exit;
+	psta->aid = psta->mac_id = psetstakey_rsp->keyid; /*CAM_ID(CAM_ENTRY)*/
+exit:
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_setassocsta_cmdrsp_callback(struct _adapter *padapter,
+				       struct cmd_obj *pcmd)
+{
+	unsigned long	irqL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct set_assocsta_parm *passocsta_parm =
+				(struct set_assocsta_parm *)(pcmd->parmbuf);
+	struct set_assocsta_rsp *passocsta_rsp =
+				(struct set_assocsta_rsp *) (pcmd->rsp);
+	struct sta_info *psta = r8712_get_stainfo(pstapriv,
+						  passocsta_parm->addr);
+
+	if (psta == NULL)
+		return;
+	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE)) &&
+	    (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)))
+		pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	r8712_free_cmd_obj(pcmd);
+}
+
+u8 r8712_disconnectCtrlEx_cmd(struct _adapter *adapter, u32 enableDrvCtrl,
+			u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO)
+{
+	struct cmd_obj *ph2c;
+	struct DisconnectCtrlEx_param *param;
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	param = (struct DisconnectCtrlEx_param *)
+		_malloc(sizeof(struct DisconnectCtrlEx_param));
+	if (param == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	memset(param, 0, sizeof(struct DisconnectCtrlEx_param));
+
+	param->EnableDrvCtrl = (unsigned char)enableDrvCtrl;
+	param->TryPktCnt = (unsigned char)tryPktCnt;
+	param->TryPktInterval = (unsigned char)tryPktInterval;
+	param->FirstStageTO = (unsigned int)firstStageTO;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, param,
+				GEN_CMD_CODE(_DisconnectCtrlEx));
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_cmd.h b/drivers/staging/rtl8712/rtl871x_cmd.h
new file mode 100644
index 0000000..757ebf7
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_cmd.h
@@ -0,0 +1,790 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_CMD_H_
+#define __RTL871X_CMD_H_
+
+#include "wlan_bssdef.h"
+#include "rtl871x_rf.h"
+#define C2H_MEM_SZ (16*1024)
+
+#include "osdep_service.h"
+#include "ieee80211.h"
+
+#define FREE_CMDOBJ_SZ	128
+#define MAX_CMDSZ	512
+#define MAX_RSPSZ	512
+#define MAX_EVTSZ	1024
+#define CMDBUFF_ALIGN_SZ 512
+
+struct cmd_obj {
+	u16	cmdcode;
+	u8	res;
+	u8	*parmbuf;
+	u32	cmdsz;
+	u8	*rsp;
+	u32	rspsz;
+	struct list_head list;
+};
+
+struct cmd_priv {
+	struct semaphore cmd_queue_sema;
+	struct semaphore terminate_cmdthread_sema;
+	struct  __queue	cmd_queue;
+	u8 cmd_seq;
+	u8 *cmd_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8 *cmd_allocated_buf;
+	u8 *rsp_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8 *rsp_allocated_buf;
+	u32 cmd_issued_cnt;
+	u32 cmd_done_cnt;
+	u32 rsp_cnt;
+	struct _adapter *padapter;
+};
+
+struct evt_obj {
+	u16 evtcode;
+	u8 res;
+	u8 *parmbuf;
+	u32 evtsz;
+	struct list_head list;
+};
+
+struct	evt_priv {
+	struct  __queue	evt_queue;
+	u8	event_seq;
+	u8	*evt_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8	*evt_allocated_buf;
+	u32	evt_done_cnt;
+	struct tasklet_struct event_tasklet;
+};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof(*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while (0)
+
+u32 r8712_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+u32 r8712_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+struct cmd_obj *r8712_dequeue_cmd(struct  __queue *queue);
+void r8712_free_cmd_obj(struct cmd_obj *pcmd);
+int r8712_cmd_thread(void *context);
+u32 r8712_init_cmd_priv(struct cmd_priv *pcmdpriv);
+void r8712_free_cmd_priv(struct cmd_priv *pcmdpriv);
+u32 r8712_init_evt_priv(struct evt_priv *pevtpriv);
+void r8712_free_evt_priv(struct evt_priv *pevtpriv);
+
+enum rtl871x_drvint_cid {
+	NONE_WK_CID,
+	WDG_WK_CID,
+	MAX_WK_CID
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+ * Caller Mode: Infra, Ad-HoC(C)
+ * Notes: To enter USB suspend mode
+ * Command Mode
+ */
+struct usb_suspend_parm {
+	u32 action; /* 1: sleep, 0:resume */
+};
+
+/*
+ * Caller Mode: Infra, Ad-Hoc
+ * Notes: To join the specified bss
+ * Command Event Mode
+ */
+struct joinbss_parm {
+	struct ndis_wlan_bssid_ex network;
+};
+
+/*
+ * Caller Mode: Infra, Ad-HoC(C)
+ * Notes: To disconnect the current associated BSS
+ * Command Mode
+ */
+struct disconnect_parm {
+	u32 rsvd;
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC(M)
+ * Notes: To create a BSS
+ * Command Mode
+ */
+struct createbss_parm {
+	struct ndis_wlan_bssid_ex network;
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC, Infra
+ * Notes: To set the NIC mode of RTL8711
+ * Command Mode
+ * The definition of mode:
+ *
+ * #define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+ * #define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+ * #define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+ * #define IW_MODE_MASTER	3	// Synchronisation master or AP
+ * #define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+ * #define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+ * #define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+*/
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC, Infra
+ * Notes: To ask RTL8711 performing site-survey
+ * Command-Event Mode
+ */
+struct sitesurvey_parm {
+	sint passive_mode;	/*active: 1, passive: 0 */
+	sint bsslimit;	/* 1 ~ 48 */
+	sint	ss_ssidlen;
+	u8	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+};
+
+/*
+ * Caller Mode: Any
+ * Notes: To set the auth type of RTL8711. open/shared/802.1x
+ * Command Mode
+ */
+struct setauth_parm {
+	u8 mode;  /*0: legacy open, 1: legacy shared 2: 802.1x*/
+	u8 _1x;   /*0: PSK, 1: TLS*/
+	u8 rsvd[2];
+};
+
+/*
+ * Caller Mode: Infra
+ * a. algorithm: wep40, wep104, tkip & aes
+ * b. keytype: grp key/unicast key
+ * c. key contents
+ *
+ * when shared key ==> keyid is the camid
+ * when 802.1x ==> keyid [0:1] ==> grp key
+ * when 802.1x ==> keyid > 2 ==> unicast key
+ */
+struct setkey_parm {
+	u8	algorithm;	/* encryption algorithm, could be none, wep40,
+				 * TKIP, CCMP, wep104 */
+	u8	keyid;
+	u8	grpkey;		/* 1: this is the grpkey for 802.1x.
+				 * 0: this is the unicast key for 802.1x */
+	u8	key[16];	/* this could be 40 or 104 */
+};
+
+/*
+ * When in AP or Ad-Hoc mode, this is used to
+ * allocate an sw/hw entry for a newly associated sta.
+ * Command
+ * when shared key ==> algorithm/keyid
+ */
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+struct SetMacAddr_param {
+	u8	MacAddr[ETH_ALEN];
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+
+	Command mode
+
+	This is to force fw to del an sta_data entry per driver's request
+
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+	u8	mac_id;
+	u8	datarates[NumRates];
+};
+
+enum _RT_CHANNEL_DOMAIN {
+	RT_CHANNEL_DOMAIN_FCC = 0,
+	RT_CHANNEL_DOMAIN_IC = 1,
+	RT_CHANNEL_DOMAIN_ETSI = 2,
+	RT_CHANNEL_DOMAIN_SPAIN = 3,
+	RT_CHANNEL_DOMAIN_FRANCE = 4,
+	RT_CHANNEL_DOMAIN_MKK = 5,
+	RT_CHANNEL_DOMAIN_MKK1 = 6,
+	RT_CHANNEL_DOMAIN_ISRAEL = 7,
+	RT_CHANNEL_DOMAIN_TELEC = 8,
+
+	/* Be compatible with old channel plan. No good! */
+	RT_CHANNEL_DOMAIN_MIC = 9,
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 10,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 11,
+	RT_CHANNEL_DOMAIN_TELEC_NETGEAR = 12,
+
+	RT_CHANNEL_DOMAIN_NCC = 13,
+	RT_CHANNEL_DOMAIN_5G = 14,
+	RT_CHANNEL_DOMAIN_5G_40M = 15,
+ /*===== Add new channel plan above this line===============*/
+	RT_CHANNEL_DOMAIN_MAX,
+};
+
+
+struct SetChannelPlan_param {
+	enum _RT_CHANNEL_DOMAIN ChannelPlan;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct writePTM_parm {
+	u8	type;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct setrfintfs_parm {
+	u8	rfintfs;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=	swap32(w1);
+		b0		=	b1
+		s2		=	s0 + s1
+		b1		=	b0
+		w1		=	w0
+
+	mac[0] ==	2
+	==> CMD_EVENT mode, return	H2C_SUCCESS
+	The event layout shall be:
+	event:	     parm:
+	mac[0]  =   mac[5];
+	mac[1]  =   mac[4];
+	mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+	mac[3]  =   mac[2];
+	mac[4]  =   mac[1];
+	mac[5]  =   mac[0];
+	s0		=   swap16(s0) - event.mac[2];
+	s1		=   s1 + event.mac[2];
+	w0		=	swap32(w0);
+	b0		=	b1
+	s2		=	s0 + event.mac[2]
+	b1		=	b0
+	w1		=	swap32(w1) - event.mac[2];
+
+	parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+/* CMD param Formart for DRV INTERNAL CMD HDL*/
+struct drvint_cmd_parm {
+	int i_cid; /*internal cmd id*/
+	int sz; /* buf sz*/
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;
+	u8	rx_antset;
+	u8	tx_antenna;
+	u8	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;	/* 0: pure hw, 1: fw */
+};
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct setpwrmode_parm  {
+	u8	mode;
+	u8	flag_low_traffic_en;
+	u8	flag_lpnav_en;
+	u8	flag_rf_low_snr_en;
+	u8	flag_dps_en; /* 1: dps, 0: 32k */
+	u8	bcn_rx_en;
+	u8	bcn_pass_cnt;	  /* fw report one beacon information to
+				   * driver  when it receives bcn_pass_cnt
+				   *  beacons. */
+	u8	bcn_to;		  /* beacon TO (ms). =0 no limit.*/
+	u16	bcn_itv;
+	u8	app_itv; /* only for VOIP mode. */
+	u8	awake_bcn_itv;
+	u8	smart_ps;
+	u8	bcn_pass_time;	/* unit: 100ms */
+};
+
+struct setatim_parm {
+	u8 op;   /*0: add, 1:del*/
+	u8 txid; /* id of dest station.*/
+};
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+	uint rsvd;
+};
+struct getratable_rsp {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+/*to get TX,RX retry count*/
+struct gettxretrycnt_parm {
+	unsigned int rsvd;
+};
+
+struct gettxretrycnt_rsp {
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm {
+	unsigned int rsvd;
+};
+
+struct getrxretrycnt_rsp {
+	unsigned long rx_retrycnt;
+};
+
+/*to get BCNOK,BCNERR count*/
+struct getbcnokcnt_parm {
+	unsigned int rsvd;
+};
+
+struct getbcnokcnt_rsp {
+	unsigned long bcnokcnt;
+};
+
+struct getbcnerrcnt_parm {
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp {
+	unsigned long bcnerrcnt;
+};
+
+/* to get current TX power level*/
+struct getcurtxpwrlevel_parm {
+	unsigned int rsvd;
+};
+
+struct getcurtxpwrlevel_rsp {
+	unsigned short tx_power;
+};
+
+/*dynamic on/off DIG*/
+struct setdig_parm {
+	unsigned char dig_on;	/* 1:on , 0:off */
+};
+
+/*dynamic on/off RA*/
+struct setra_parm {
+	unsigned char ra_on;	/* 1:on , 0:off */
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct addBaReq_parm {
+	unsigned int tid;
+};
+
+/*H2C Handler index: 46 */
+struct SetChannel_parm {
+	u32 curr_ch;
+};
+
+/*H2C Handler index: 61 */
+struct DisconnectCtrlEx_param {
+	/* MAXTIME = (2 * FirstStageTO) + (TryPktCnt * TryPktInterval) */
+	unsigned char EnableDrvCtrl;
+	unsigned char TryPktCnt;
+	unsigned char TryPktInterval; /* Unit: ms */
+	unsigned char rsvd;
+	unsigned int  FirstStageTO; /* Unit: ms */
+};
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+/*
+ * Result:
+ * 0x00: success
+ * 0x01: success, and check Response.
+ * 0x02: cmd ignored due to duplicated sequcne number
+ * 0x03: cmd dropped due to invalid cmd code
+ * 0x04: reserved.
+ */
+
+#define H2C_RSP_OFFSET			512
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+u8 r8712_setMacAddr_cmd(struct _adapter *padapter, u8 *mac_addr);
+u8 r8712_setassocsta_cmd(struct _adapter *padapter, u8 *mac_addr);
+u8 r8712_sitesurvey_cmd(struct _adapter *padapter,
+			struct ndis_802_11_ssid *pssid);
+u8 r8712_createbss_cmd(struct _adapter *padapter);
+u8 r8712_setstakey_cmd(struct _adapter *padapter, u8 *psta, u8 unicast_key);
+u8 r8712_joinbss_cmd(struct _adapter *padapter,
+		     struct wlan_network *pnetwork);
+u8 r8712_disassoc_cmd(struct _adapter *padapter);
+u8 r8712_setopmode_cmd(struct _adapter *padapter,
+		 enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 r8712_setdatarate_cmd(struct _adapter *padapter, u8 *rateset);
+u8 r8712_set_chplan_cmd(struct _adapter  *padapter, int chplan);
+u8 r8712_setbasicrate_cmd(struct _adapter *padapter, u8 *rateset);
+u8 r8712_getrfreg_cmd(struct _adapter *padapter, u8 offset, u8 * pval);
+u8 r8712_setrfintfs_cmd(struct _adapter *padapter, u8 mode);
+u8 r8712_setrfreg_cmd(struct _adapter  *padapter, u8 offset, u32 val);
+u8 r8712_setrttbl_cmd(struct _adapter  *padapter,
+		      struct setratable_parm *prate_table);
+u8 r8712_gettssi_cmd(struct _adapter  *padapter, u8 offset, u8 *pval);
+u8 r8712_setptm_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_setfwdig_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_setfwra_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_addbareq_cmd(struct _adapter *padapter, u8 tid);
+u8 r8712_wdg_wk_cmd(struct _adapter *padapter);
+void r8712_survey_cmd_callback(struct _adapter  *padapter,
+			       struct cmd_obj *pcmd);
+void r8712_disassoc_cmd_callback(struct _adapter  *padapter,
+				 struct cmd_obj *pcmd);
+void r8712_joinbss_cmd_callback(struct _adapter  *padapter,
+				struct cmd_obj *pcmd);
+void r8712_createbss_cmd_callback(struct _adapter *padapter,
+				  struct cmd_obj *pcmd);
+void r8712_getbbrfreg_cmdrsp_callback(struct _adapter *padapter,
+				      struct cmd_obj *pcmd);
+void r8712_readtssi_cmdrsp_callback(struct _adapter *padapter,
+				struct cmd_obj *pcmd);
+void r8712_setstaKey_cmdrsp_callback(struct _adapter  *padapter,
+				     struct cmd_obj *pcmd);
+void r8712_setassocsta_cmdrsp_callback(struct _adapter  *padapter,
+				       struct cmd_obj *pcmd);
+u8 r8712_disconnectCtrlEx_cmd(struct _adapter *adapter, u32 enableDrvCtrl,
+			u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO);
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(struct _adapter  *padapter, struct cmd_obj *cmd);
+};
+
+#include "rtl8712_cmd.h"
+
+#endif /* _CMD_H_ */
+
diff --git a/drivers/staging/rtl8712/rtl871x_debug.h b/drivers/staging/rtl8712/rtl871x_debug.h
new file mode 100644
index 0000000..74468b0
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_debug.h
@@ -0,0 +1,167 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_DEBUG_H__
+#define __RTL871X_DEBUG_H__
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#define _drv_emerg_			1
+#define _drv_alert_			2
+#define _drv_crit_			3
+#define _drv_err_			4
+#define	_drv_warning_			5
+#define _drv_notice_			6
+#define _drv_info_			7
+#define _drv_dump_			8
+#define	_drv_debug_			9
+
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define	_module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_	BIT(6)
+#define _module_rtl871x_cmd_c_		BIT(7)
+#define	_module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_		BIT(9)
+#define	_module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_		BIT(11)
+#define _module_rtl871x_security_c_	BIT(12)
+#define _module_rtl871x_eeprom_c_	BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_	BIT(16)
+#define _module_rtl871x_ioctl_set_c_	BIT(17)
+#define _module_rtl871x_pwrctrl_c_	BIT(19)
+#define _module_hci_intfs_c_		BIT(20)
+#define _module_hci_ops_c_		BIT(21)
+#define _module_osdep_service_c_	BIT(22)
+#define _module_rtl871x_mp_ioctl_c_	BIT(23)
+#define _module_hci_ops_os_c_		BIT(24)
+#define _module_rtl871x_ioctl_os_c	BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+#define _module_rtl871x_mp_c_		BIT(27)
+#define _module_rtl8712_xmit_c_		BIT(28)
+#define _module_rtl8712_efuse_c_	BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTL871X_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_
+#elif defined _RTL871X_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_
+#elif defined _RTL871X_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTL871X_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTL871X_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTL871X_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTL871X_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_
+#elif defined _RTL871X_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
+#elif defined _HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_
+#elif defined _HCI_HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_
+#elif defined _RTL871X_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_ioctl_c_
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c
+#elif defined _RTL871X_MP_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_c_
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_
+#elif defined _RTL8712_XMIT_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_xmit_c_
+#elif defined _RTL8712_EFUSE_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_efuse_c_
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#else
+	#undef	_MODULE_DEFINE_
+#endif
+
+#define _dbgdump	printk
+
+#define MSG_8712(x, ...) {}
+
+#define DBG_8712(x, ...)  {}
+
+#define WRN_8712(x, ...)  {}
+
+#define ERR_8712(x, ...)  {}
+
+#undef MSG_8712
+#define MSG_8712 _dbgdump
+
+#undef DBG_8712
+#define DBG_8712 _dbgdump
+
+#undef WRN_8712
+#define WRN_8712 _dbgdump
+
+#undef ERR_8712
+#define ERR_8712 _dbgdump
+
+#endif	/*__RTL871X_DEBUG_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl871x_eeprom.c b/drivers/staging/rtl8712/rtl871x_eeprom.c
new file mode 100644
index 0000000..2f145d6
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_eeprom.c
@@ -0,0 +1,233 @@
+/******************************************************************************
+ * rtl871x_eeprom.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_EEPROM_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+static void up_clk(struct _adapter *padapter, u16 *x)
+{
+	*x = *x | _EESK;
+	r8712_write8(padapter, EE_9346CR, (u8)*x);
+	udelay(CLOCK_RATE);
+}
+
+static void down_clk(struct _adapter *padapter, u16 *x)
+{
+	*x = *x & ~_EESK;
+	r8712_write8(padapter, EE_9346CR, (u8)*x);
+	udelay(CLOCK_RATE);
+}
+
+static void shift_out_bits(struct _adapter *padapter, u16 data, u16 count)
+{
+	u16 x, mask;
+
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	mask = 0x01 << (count - 1);
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDO | _EEDI);
+	do {
+		x &= ~_EEDI;
+		if (data & mask)
+			x |= _EEDI;
+		if (padapter->bSurpriseRemoved == true)
+			goto out;
+		r8712_write8(padapter, EE_9346CR, (u8)x);
+		udelay(CLOCK_RATE);
+		up_clk(padapter, &x);
+		down_clk(padapter, &x);
+		mask = mask >> 1;
+	} while (mask);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x &= ~_EEDI;
+	r8712_write8(padapter, EE_9346CR, (u8)x);
+out:;
+}
+
+static u16 shift_in_bits(struct _adapter *padapter)
+{
+	u16 x, d = 0, i;
+
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDO | _EEDI);
+	d = 0;
+	for (i = 0; i < 16; i++) {
+		d = d << 1;
+		up_clk(padapter, &x);
+		if (padapter->bSurpriseRemoved == true)
+			goto out;
+		x = r8712_read8(padapter, EE_9346CR);
+		x &= ~(_EEDI);
+		if (x & _EEDO)
+			d |= 1;
+		down_clk(padapter, &x);
+	}
+out:
+	return d;
+}
+
+static void standby(struct _adapter *padapter)
+{
+	u8   x;
+
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EECS | _EESK);
+	r8712_write8(padapter, EE_9346CR, x);
+	udelay(CLOCK_RATE);
+	x |= _EECS;
+	r8712_write8(padapter, EE_9346CR, x);
+	udelay(CLOCK_RATE);
+}
+
+static u16 wait_eeprom_cmd_done(struct _adapter *padapter)
+{
+	u8	x;
+	u16	i;
+
+	standby(padapter);
+	for (i = 0; i < 200; i++) {
+		x = r8712_read8(padapter, EE_9346CR);
+		if (x & _EEDO)
+			return true;
+		udelay(CLOCK_RATE);
+	}
+	return false;
+}
+
+static void eeprom_clean(struct _adapter *padapter)
+{
+	u16 x;
+
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	x = r8712_read8(padapter, EE_9346CR);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	x &= ~(_EECS | _EEDI);
+	r8712_write8(padapter, EE_9346CR, (u8)x);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	up_clk(padapter, &x);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	down_clk(padapter, &x);
+}
+
+void r8712_eeprom_write16(struct _adapter *padapter, u16 reg, u16 data)
+{
+	u8 x;
+	u8 tmp8_ori, tmp8_new, tmp8_clk_ori, tmp8_clk_new;
+
+	tmp8_ori = r8712_read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if (tmp8_ori != tmp8_new)
+		r8712_write8(padapter, 0x102502f1, tmp8_new);
+	tmp8_clk_ori = r8712_read8(padapter, 0x10250003);
+	tmp8_clk_new = tmp8_clk_ori | 0x20;
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_new);
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	r8712_write8(padapter, EE_9346CR, x);
+	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
+	if (padapter->EepromAddressSize == 8)	/*CF+ and SDIO*/
+		shift_out_bits(padapter, 0, 6);
+	else	/* USB */
+		shift_out_bits(padapter, 0, 4);
+	standby(padapter);
+	/* Erase this particular word.  Write the erase opcode and register
+	 * number in that order. The opcode is 3bits in length; reg is 6
+	 * bits long.
+	 */
+	standby(padapter);
+	/* write the new word to the EEPROM
+	 * send the write opcode the EEPORM
+	 */
+	shift_out_bits(padapter, EEPROM_WRITE_OPCODE, 3);
+	/* select which word in the EEPROM that we are writing to. */
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+	/* write the data to the selected EEPROM word. */
+	shift_out_bits(padapter, data, 16);
+	if (wait_eeprom_cmd_done(padapter)) {
+		standby(padapter);
+		shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
+		shift_out_bits(padapter, reg, 4);
+		eeprom_clean(padapter);
+	}
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if (tmp8_new != tmp8_ori)
+		r8712_write8(padapter, 0x102502f1, tmp8_ori);
+}
+
+u16 r8712_eeprom_read16(struct _adapter *padapter, u16 reg) /*ReadEEprom*/
+{
+	u16 x;
+	u16 data = 0;
+	u8 tmp8_ori, tmp8_new, tmp8_clk_ori, tmp8_clk_new;
+
+	tmp8_ori = r8712_read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if (tmp8_ori != tmp8_new)
+		r8712_write8(padapter, 0x102502f1, tmp8_new);
+	tmp8_clk_ori = r8712_read8(padapter, 0x10250003);
+	tmp8_clk_new = tmp8_clk_ori | 0x20;
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_new);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	/* select EEPROM, reset bits, set _EECS */
+	x = r8712_read8(padapter, EE_9346CR);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	r8712_write8(padapter, EE_9346CR, (unsigned char)x);
+	/* write the read opcode and register number in that order
+	 * The opcode is 3bits in length, reg is 6 bits long
+	 */
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+	/* Now read the data (16 bits) in from the selected EEPROM word */
+	data = shift_in_bits(padapter);
+	eeprom_clean(padapter);
+out:
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if (tmp8_new != tmp8_ori)
+		r8712_write8(padapter, 0x102502f1, tmp8_ori);
+	return data;
+}
+
diff --git a/drivers/staging/rtl8712/rtl871x_eeprom.h b/drivers/staging/rtl8712/rtl871x_eeprom.h
new file mode 100644
index 0000000..497276e
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_eeprom.h
@@ -0,0 +1,101 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_EEPROM_H__
+#define __RTL871X_EEPROM_H__
+
+#include "osdep_service.h"
+
+#define	RTL8712_EEPROM_ID		0x8712
+#define	EEPROM_MAX_SIZE			256
+#define	CLOCK_RATE			50	/*100us*/
+
+/*- EEPROM opcodes*/
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      /* Erase/write enable*/
+#define EEPROM_EWDS_OPCODE		16      /* Erase/write disable*/
+
+#define	EEPROM_CID_DEFAULT		0x0
+#define	EEPROM_CID_ALPHA		0x1
+#define	EEPROM_CID_Senao		0x3
+#define	EEPROM_CID_NetCore		0x5
+#define	EEPROM_CID_CAMEO		0X8
+#define	EEPROM_CID_SITECOM		0x9
+#define	EEPROM_CID_COREGA		0xB
+#define	EEPROM_CID_EDIMAX_BELKIN	0xC
+#define	EEPROM_CID_SERCOMM_BELKIN	0xE
+#define	EEPROM_CID_CAMEO1		0xF
+#define	EEPROM_CID_WNC_COREGA		0x12
+#define	EEPROM_CID_CLEVO		0x13
+#define	EEPROM_CID_WHQL			0xFE
+
+enum RT_CUSTOMER_ID {
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_819x_ALPHA = 15,
+	RT_CID_819x_Sitecom = 16,
+	RT_CID_CCX = 17,
+	RT_CID_819x_Lenovo = 18,
+	RT_CID_819x_QMI = 19,
+	RT_CID_819x_Edimax_Belkin = 20,
+	RT_CID_819x_Sercomm_Belkin = 21,
+	RT_CID_819x_CAMEO1 = 22,
+	RT_CID_819x_MSI = 23,
+	RT_CID_819x_Acer = 24,
+	RT_CID_819x_AzWave_ASUS = 25,
+	RT_CID_819x_AzWave = 26,
+	RT_CID_819x_WNC_COREGA = 27,
+	RT_CID_819x_CLEVO = 28,
+};
+
+struct eeprom_priv {
+	u8 bautoload_fail_flag;
+	u8 bempty;
+	u8 sys_config;
+	u8 mac_addr[6];
+	u8 config0;
+	u16 channel_plan;
+	u8 country_string[3];
+	u8 tx_power_b[15];
+	u8 tx_power_g[15];
+	u8 tx_power_a[201];
+	u8 efuse_eeprom_data[EEPROM_MAX_SIZE];
+	enum RT_CUSTOMER_ID CustomerID;
+};
+
+void r8712_eeprom_write16(struct _adapter *padapter, u16 reg, u16 data);
+u16 r8712_eeprom_read16(struct _adapter *padapter, u16 reg);
+
+#endif  /*__RTL871X_EEPROM_H__*/
+
diff --git a/drivers/staging/rtl8712/rtl871x_event.h b/drivers/staging/rtl8712/rtl871x_event.h
new file mode 100644
index 0000000..e03ee90
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_event.h
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871x_EVENT_H_
+#define _RTL871x_EVENT_H_
+
+#include "osdep_service.h"
+
+#include "wlan_bssdef.h"
+#include <linux/semaphore.h>
+#include <linux/sem.h>
+
+/*
+ * Used to report a bss has been scanned
+*/
+struct survey_event	{
+	struct ndis_wlan_bssid_ex bss;
+};
+
+/*
+ * Used to report that the requested site survey has been done.
+ * bss_cnt indicates the number of bss that has been reported.
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+ * Used to report the link result of joinning the given bss
+ * join_res:
+ *  -1: authentication fail
+ *  -2: association fail
+ *  > 0: TID
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+ * Used to report a given STA has joinned the created BSS.
+ * It is used in AP/Ad-HoC(M) mode.
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+};
+
+struct stadel_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+};
+
+struct addba_event {
+	unsigned int tid;
+};
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(struct _adapter *dev, u8 *pbuf);
+};
+
+#define C2HEVENT_SZ			32
+struct event_node {
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	/*volatile*/ int *caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	/*volatile*/ int	head;
+	/*volatile*/ int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	/*volatile*/ int	head;
+	/*volatile*/ int	tail;
+	struct wlan_bssid_ex networks[NETWORK_QUEUE_SZ];
+};
+
+struct ADDBA_Req_Report_parm {
+	unsigned char MacAddress[ETH_ALEN];
+	unsigned short StartSeqNum;
+	unsigned char tid;
+};
+#include "rtl8712_event.h"
+
+#endif /* _WLANEVENT_H_ */
+
diff --git a/drivers/staging/rtl8712/rtl871x_ht.h b/drivers/staging/rtl8712/rtl871x_ht.h
new file mode 100644
index 0000000..41872d9
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ht.h
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_HT_H_
+#define _RTL871X_HT_H_
+
+#include "osdep_service.h"
+#include "wifi.h"
+
+struct ht_priv {
+	unsigned int	ht_option;
+	unsigned int	ampdu_enable;/*for enable Tx A-MPDU*/
+	unsigned char	baddbareq_issued[16];
+	unsigned int	tx_amsdu_enable;/*for enable Tx A-MSDU */
+	unsigned int	tx_amdsu_maxlen; /* 1: 8k, 0:4k ; default:8k, for tx */
+	unsigned int	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz,
+					  *  updated when join_callback. */
+	struct ieee80211_ht_cap ht_cap;
+};
+
+#endif	/*_RTL871X_HT_H_ */
+
diff --git a/drivers/staging/rtl8712/rtl871x_io.c b/drivers/staging/rtl8712/rtl871x_io.c
new file mode 100644
index 0000000..ca84ee0
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_io.c
@@ -0,0 +1,161 @@
+/******************************************************************************
+ * rtl871x_io.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*
+ *
+ * The purpose of rtl871x_io.c
+ *
+ * a. provides the API
+ * b. provides the protocol engine
+ * c. provides the software interface between caller and the hardware interface
+ *
+ * For r8712u, both sync/async operations are provided.
+ *
+ * Only sync read/write_mem operations are provided.
+ *
+ */
+
+#define _RTL871X_IO_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_io.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+static uint _init_intf_hdl(struct _adapter *padapter,
+			   struct intf_hdl *pintf_hdl)
+{
+	struct	intf_priv	*pintf_priv;
+	void (*set_intf_option)(u32 *poption) = NULL;
+	void (*set_intf_funs)(struct intf_hdl *pintf_hdl);
+	void (*set_intf_ops)(struct _io_ops	*pops);
+	uint (*init_intf_priv)(struct intf_priv *pintfpriv);
+
+	set_intf_option = &(r8712_usb_set_intf_option);
+	set_intf_funs = &(r8712_usb_set_intf_funs);
+	set_intf_ops = &r8712_usb_set_intf_ops;
+	init_intf_priv = &r8712_usb_init_intf_priv;
+	pintf_priv = pintf_hdl->pintfpriv = (struct intf_priv *)
+		     _malloc(sizeof(struct intf_priv));
+	if (pintf_priv == NULL)
+		goto _init_intf_hdl_fail;
+	pintf_hdl->adapter = (u8 *)padapter;
+	set_intf_option(&pintf_hdl->intf_option);
+	set_intf_funs(pintf_hdl);
+	set_intf_ops(&pintf_hdl->io_ops);
+	pintf_priv->intf_dev = (u8 *)&(padapter->dvobjpriv);
+	if (init_intf_priv(pintf_priv) == _FAIL)
+		goto _init_intf_hdl_fail;
+	return _SUCCESS;
+_init_intf_hdl_fail:
+	kfree(pintf_priv);
+	return _FAIL;
+}
+
+static void _unload_intf_hdl(struct intf_priv *pintfpriv)
+{
+	void (*unload_intf_priv)(struct intf_priv *pintfpriv);
+
+	unload_intf_priv = &r8712_usb_unload_intf_priv;
+	unload_intf_priv(pintfpriv);
+	kfree(pintfpriv);
+}
+
+static uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl)
+{
+	struct _adapter *adapter = (struct _adapter *)dev;
+
+	pintfhdl->intf_option = 0;
+	pintfhdl->adapter = dev;
+	pintfhdl->intf_dev = (u8 *)&(adapter->dvobjpriv);
+	if (_init_intf_hdl(adapter, pintfhdl) == false)
+		goto register_intf_hdl_fail;
+	return _SUCCESS;
+register_intf_hdl_fail:
+	return false;
+}
+
+static  void unregister_intf_hdl(struct intf_hdl *pintfhdl)
+{
+	_unload_intf_hdl(pintfhdl->pintfpriv);
+	memset((u8 *)pintfhdl, 0, sizeof(struct intf_hdl));
+}
+
+uint r8712_alloc_io_queue(struct _adapter *adapter)
+{
+	u32 i;
+	struct io_queue *pio_queue;
+	struct io_req *pio_req;
+
+	pio_queue = (struct io_queue *)_malloc(sizeof(struct io_queue));
+	if (pio_queue == NULL)
+		goto alloc_io_queue_fail;
+	_init_listhead(&pio_queue->free_ioreqs);
+	_init_listhead(&pio_queue->processing);
+	_init_listhead(&pio_queue->pending);
+	spin_lock_init(&pio_queue->lock);
+	pio_queue->pallocated_free_ioreqs_buf = (u8 *)_malloc(NUM_IOREQ *
+						(sizeof(struct io_req)) + 4);
+	if ((pio_queue->pallocated_free_ioreqs_buf) == NULL)
+		goto alloc_io_queue_fail;
+	memset(pio_queue->pallocated_free_ioreqs_buf, 0,
+			(NUM_IOREQ * (sizeof(struct io_req)) + 4));
+	pio_queue->free_ioreqs_buf = pio_queue->pallocated_free_ioreqs_buf + 4
+			- ((addr_t)(pio_queue->pallocated_free_ioreqs_buf)
+			& 3);
+	pio_req = (struct io_req *)(pio_queue->free_ioreqs_buf);
+	for (i = 0; i < NUM_IOREQ; i++) {
+		_init_listhead(&pio_req->list);
+		sema_init(&pio_req->sema, 0);
+		list_insert_tail(&pio_req->list, &pio_queue->free_ioreqs);
+		pio_req++;
+	}
+	if ((register_intf_hdl((u8 *)adapter, &(pio_queue->intf))) == _FAIL)
+		goto alloc_io_queue_fail;
+	adapter->pio_queue = pio_queue;
+	return _SUCCESS;
+alloc_io_queue_fail:
+	if (pio_queue) {
+		kfree(pio_queue->pallocated_free_ioreqs_buf);
+		kfree((u8 *)pio_queue);
+	}
+	adapter->pio_queue = NULL;
+	return _FAIL;
+}
+
+void r8712_free_io_queue(struct _adapter *adapter)
+{
+	struct io_queue *pio_queue = (struct io_queue *)(adapter->pio_queue);
+
+	if (pio_queue) {
+		kfree(pio_queue->pallocated_free_ioreqs_buf);
+		adapter->pio_queue = NULL;
+		unregister_intf_hdl(&pio_queue->intf);
+		kfree((u8 *)pio_queue);
+	}
+}
diff --git a/drivers/staging/rtl8712/rtl871x_io.h b/drivers/staging/rtl8712/rtl871x_io.h
new file mode 100644
index 0000000..86308a0
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_io.h
@@ -0,0 +1,258 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _IO_H_
+#define _IO_H_
+
+#include "osdep_service.h"
+#include "osdep_intf.h"
+
+#define NUM_IOREQ		8
+
+#define MAX_PROT_SZ	(64-16)
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+/* IO COMMAND TYPE */
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+/* IO STATUS TYPE */
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+/*
+	Only Sync. burst accessing is provided.
+*/
+#define IO_WR_BURST(x)		(IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | \
+				((x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+/*below is for the intf_option bit defition...*/
+#define _INTF_ASYNC_	BIT(0)	/*support async io*/
+struct intf_priv;
+struct	intf_hdl;
+struct io_queue;
+struct	_io_ops {
+	uint (*_sdbus_read_bytes_to_membuf)(struct intf_priv *pintfpriv,
+					    u32 addr, u32 cnt, u8 *pbuf);
+	uint (*_sdbus_read_blocks_to_membuf)(struct intf_priv *pintfpriv,
+					     u32 addr, u32 cnt, u8 *pbuf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	uint (*_sdbus_write_blocks_from_membuf)(struct intf_priv *pintfpriv,
+						u32 addr, u32 cnt, u8 *pbuf,
+						u8 async);
+	uint (*_sdbus_write_bytes_from_membuf)(struct intf_priv *pintfpriv,
+					       u32 addr, u32 cnt, u8 *pbuf);
+	u8 (*_cmd52r)(struct intf_priv *pintfpriv, u32 addr);
+	void (*_cmd52w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+	u8 (*_cmdfunc152r)(struct intf_priv *pintfpriv, u32 addr);
+	void (*_cmdfunc152w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+	void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+};
+
+struct io_req {
+	struct list_head list;
+	u32	addr;
+	/*volatile*/ u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;
+	struct semaphore sema;
+	void (*_async_io_callback)(struct _adapter *padater,
+				   struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;
+};
+
+struct	intf_hdl {
+	u32	intf_option;
+	u8	*adapter;
+	u8	*intf_dev;
+	struct intf_priv	*pintfpriv;
+	void (*intf_hdl_init)(u8 *priv);
+	void (*intf_hdl_unload)(u8 *priv);
+	void (*intf_hdl_open)(u8 *priv);
+	void (*intf_hdl_close)(u8 *priv);
+	struct	_io_ops	io_ops;
+};
+
+struct reg_protocol_rd {
+
+#ifdef __LITTLE_ENDIAN
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/*0:read, 1:write*/
+	u32		FixOrContinuous:1;	/*0:continuous, 1: Fix*/
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/*DW3*/
+	u32		BusAddress;
+	/*DW4*/
+#else
+/*DW1*/
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 WriteEnable:1;
+	u32 ByteCount:7;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1 ;
+	u32 FixOrContinuous:1;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+#endif
+};
+
+struct reg_protocol_wt {
+#ifdef __LITTLE_ENDIAN
+	/*DW1*/
+	u32 NumOfTrans:4;
+	u32 Reserved1:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 ByteCount:7;
+	u32 WriteEnable:1;	/*0:read, 1:write*/
+	u32 FixOrContinuous:1;	/*0:continuous, 1: Fix*/
+	u32 BurstMode:1;
+	u32 Byte1Access:1;
+	u32 Byte2Access:1;
+	u32 Byte4Access:1;
+	u32 Reserved3:3;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+	u32 Value;
+#else
+	/*DW1*/
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 WriteEnable:1;
+	u32 ByteCount:7;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1;
+	u32 FixOrContinuous:1;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+	u32 Value;
+#endif
+};
+
+/*
+Below is the data structure used by _io_handler
+*/
+
+struct io_queue {
+	spinlock_t lock;
+	struct list_head free_ioreqs;
+	/*The io_req list that will be served in the single protocol r/w.*/
+	struct list_head pending;
+	struct list_head processing;
+	u8 *free_ioreqs_buf; /* 4-byte aligned */
+	u8 *pallocated_free_ioreqs_buf;
+	struct	intf_hdl intf;
+};
+
+static inline u32 _RND4(u32 sz)
+{
+	u32	val;
+	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;
+	return val;
+}
+
+u8 r8712_read8(struct _adapter *adapter, u32 addr);
+u16 r8712_read16(struct _adapter *adapter, u32 addr);
+u32 r8712_read32(struct _adapter *adapter, u32 addr);
+void r8712_read_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_read_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_write8(struct _adapter *adapter, u32 addr, u8 val);
+void r8712_write16(struct _adapter *adapter, u32 addr, u16 val);
+void r8712_write32(struct _adapter *adapter, u32 addr, u32 val);
+void r8712_write_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_write_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+/*ioreq */
+uint r8712_alloc_io_queue(struct _adapter *adapter);
+void r8712_free_io_queue(struct _adapter *adapter);
+
+#endif	/*_RTL8711_IO_H_*/
+
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl.h b/drivers/staging/rtl8712/rtl871x_ioctl.h
new file mode 100644
index 0000000..2016802
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl.h
@@ -0,0 +1,97 @@
+#ifndef __IOCTL_H
+#define __IOCTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+/* For DDK-defined OIDs*/
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+#define SZ_OID_NDIS_SEG1	23
+#define SZ_OID_NDIS_SEG2	3
+#define SZ_OID_NDIS_SEG3	6
+#define SZ_OID_NDIS_SEG4	6
+#define SZ_OID_NDIS_SEG5	4
+#define SZ_OID_NDIS_SEG6	8
+#define SZ_OID_NDIS_SEG7	7
+#define SZ_OID_NDIS_SEG8	36
+#define SZ_OID_NDIS_SEG9	24
+#define SZ_OID_NDIS_SEG10	19
+
+/* For Realtek-defined OIDs*/
+#define OID_MP_SEG1	0xFF871100
+#define OID_MP_SEG2	0xFF818000
+#define OID_MP_SEG3	0xFF818700
+#define OID_MP_SEG4	0xFF011100
+
+enum oid_type {
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; /*the starting number for OID*/
+	unsigned int oid_end; /*the ending number for OID*/
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; /*the size of node_array*/
+	int query_counter; /*count the number of query hits for this segment*/
+	int set_counter; /*count the number of set hits for this segment*/
+};
+
+struct oid_par_priv {
+	void	*adapter_context;
+	uint oid;
+	void *information_buf;
+	unsigned long information_buf_len;
+	unsigned long *bytes_rw;
+	unsigned long *bytes_needed;
+	enum oid_type	type_of_oid;
+	unsigned int dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; /* 0: without OID debug message
+			      * 1: with OID debug message */
+	uint(*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+uint oid_null_function(struct oid_par_priv *poid_par_priv);
+
+extern struct iw_handler_def  r871x_handlers_def;
+
+extern	uint drv_query_info(
+	struct  net_device *MiniportAdapterContext,
+	uint Oid,
+	void *InformationBuffer,
+	u32 InformationBufferLength,
+	u32 *BytesWritten,
+	u32 *BytesNeeded
+);
+
+extern	uint drv_set_info(
+	struct  net_device *MiniportAdapterContext,
+	uint Oid,
+	void *InformationBuffer,
+	u32 InformationBufferLength,
+	u32 *BytesRead,
+	u32 *BytesNeeded
+);
+
+#endif
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl_linux.c b/drivers/staging/rtl8712/rtl871x_ioctl_linux.c
new file mode 100644
index 0000000..4281e88
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl_linux.c
@@ -0,0 +1,2400 @@
+/******************************************************************************
+ * rtl871x_ioctl_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_IOCTL_LINUX_C_
+#define _RTL871X_MP_IOCTL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+#include "rtl871x_debug.h"
+#include "wifi.h"
+#include "rtl871x_mlme.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_set.h"
+#include "rtl871x_mp_ioctl.h"
+#include "mlme_osdep.h"
+#include "hex_to_bin.h"
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/io.h>
+#include <linux/semaphore.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV + 0x1E)
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+
+static const u32 rtl8180_rates[] = {1000000, 2000000, 5500000, 11000000,
+		       6000000, 9000000, 12000000, 18000000,
+		       24000000, 36000000, 48000000, 54000000};
+
+static const long ieee80211_wlan_frequencies[] = {
+	2412, 2417, 2422, 2427,
+	2432, 2437, 2442, 2447,
+	2452, 2457, 2462, 2467,
+	2472, 2484
+};
+
+static const char * const iw_operation_mode[] = {
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary",
+	 "Monitor"
+};
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex_to_bin(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex_to_bin(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+	return 0;
+}
+
+void r8712_indicate_wx_assoc_event(struct _adapter *padapter)
+{
+	union iwreq_data wrqu;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress,
+		ETH_ALEN);
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void r8712_indicate_wx_disassoc_event(struct _adapter *padapter)
+{
+	union iwreq_data wrqu;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+static inline void handle_pairwise_key(struct sta_info *psta,
+				       struct ieee_param *param,
+				       struct _adapter *padapter)
+{
+	/* pairwise key */
+	memcpy(psta->x_UncstKey.skey, param->u.crypt.key,
+	       (param->u.crypt. key_len > 16 ? 16 : param->u.crypt.key_len));
+	if (strcmp(param->u.crypt.alg, "TKIP") == 0) { /* set mic key */
+		memcpy(psta->tkiptxmickey. skey, &(param->u.crypt.
+			key[16]), 8);
+		memcpy(psta->tkiprxmickey. skey, &(param->u.crypt.
+			key[24]), 8);
+		padapter->securitypriv. busetkipkey = false;
+		_set_timer(&padapter->securitypriv.tkip_timer, 50);
+	}
+	r8712_setstakey_cmd(padapter, (unsigned char *)psta, true);
+}
+
+static inline void handle_group_key(struct ieee_param *param,
+				    struct _adapter *padapter)
+{
+	if (0 < param->u.crypt.idx &&
+	    param->u.crypt.idx < 3) {
+		/* group key idx is 1 or 2 */
+		memcpy(padapter->securitypriv.XGrpKey[param->u.crypt.
+			idx-1].skey, param->u.crypt.key, (param->u.crypt.key_len
+			> 16 ? 16 : param->u.crypt.key_len));
+		memcpy(padapter->securitypriv.XGrptxmickey[param->
+			u.crypt.idx-1].skey, &(param->u.crypt.key[16]), 8);
+		memcpy(padapter->securitypriv. XGrprxmickey[param->
+			u.crypt.idx-1].skey, &(param->u.crypt.key[24]), 8);
+		padapter->securitypriv.binstallGrpkey = true;
+		r8712_set_key(padapter, &padapter->securitypriv,
+			param->u.crypt.idx);
+		if (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE) {
+			if (padapter->registrypriv.power_mgnt != padapter->
+			    pwrctrlpriv.pwr_mode)
+				_set_timer(&(padapter->mlmepriv.dhcp_timer),
+					   60000);
+		}
+	}
+}
+
+static inline char *translate_scan(struct _adapter *padapter,
+				   struct iw_request_info *info,
+				   struct wlan_network *pnetwork,
+				   char *start, char *stop)
+{
+	struct iw_event iwe;
+	struct ieee80211_ht_cap *pht_capie;
+	char *current_val;
+	s8 *p;
+	u32 i = 0, ht_ielen = 0;
+	u16	cap, ht_cap = false, mcs_rate;
+	u8	rssi, bw_40MHz = 0, short_GI = 0;
+
+	if ((pnetwork->network.Configuration.DSConfig < 1) ||
+	    (pnetwork->network.Configuration.DSConfig > 14)) {
+		if (pnetwork->network.Configuration.DSConfig < 1)
+			pnetwork->network.Configuration.DSConfig = 1;
+		else
+			pnetwork->network.Configuration.DSConfig = 14;
+	}
+	/* AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = (u16)min((u16)pnetwork->network.Ssid.SsidLength,
+			    (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe,
+				     pnetwork->network.Ssid.Ssid);
+	/* parsing HT_CAP_IE */
+	p = r8712_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_,
+			 &ht_ielen, pnetwork->network.IELength - 12);
+	if (p && ht_ielen > 0) {
+		ht_cap = true;
+		pht_capie = (struct ieee80211_ht_cap *)(p + 2);
+		memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH)
+			   ? 1 : 0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20 |
+			    IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
+	}
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((r8712_is_cckratesonly_included((u8 *)&pnetwork->network.
+	     SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	} else if ((r8712_is_cckrates_included((u8 *)&pnetwork->network.
+		    SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	} else {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+	}
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	memcpy((u8 *)&cap, r8712_get_capability_from_ie(pnetwork->network.IEs),
+		2);
+	cap = le16_to_cpu(cap);
+	if (cap & (WLAN_CAPABILITY_IBSS|WLAN_CAPABILITY_BSS)) {
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = (u32)IW_MODE_MASTER;
+		else
+			iwe.u.mode = (u32)IW_MODE_ADHOC;
+		start = iwe_stream_add_event(info, start, stop, &iwe,
+			IW_EV_UINT_LEN);
+	}
+	/* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	{
+		/*  check legel index */
+		u8 dsconfig = pnetwork->network.Configuration.DSConfig;
+		if (dsconfig >= 1 && dsconfig <= sizeof(
+		    ieee80211_wlan_frequencies) / sizeof(long))
+			iwe.u.freq.m = (s32)(ieee80211_wlan_frequencies[
+				       pnetwork->network.Configuration.
+				       DSConfig - 1] * 100000);
+		else
+			iwe.u.freq.m = 0;
+	}
+	iwe.u.freq.e = (s16)1;
+	iwe.u.freq.i = (u8)pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe,
+		IW_EV_FREQ_LEN);
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = (u16)(IW_ENCODE_ENABLED |
+				    IW_ENCODE_NOKEY);
+	else
+		iwe.u.data.flags = (u16)(IW_ENCODE_DISABLED);
+	iwe.u.data.length = (u16)0;
+	start = iwe_stream_add_point(info, start, stop, &iwe,
+		pnetwork->network.Ssid.Ssid);
+	/*Add basic and extended rates */
+	current_val = start + iwe_stream_lcp_len(info);
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = 0;
+	iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = 0;
+	i = 0;
+	while (pnetwork->network.SupportedRates[i] != 0) {
+		/* Bit rate given in 500 kb/s units */
+		iwe.u.bitrate.value = (pnetwork->network.SupportedRates[i++] &
+				      0x7F) * 500000;
+		current_val = iwe_stream_add_value(info, start, current_val,
+			      stop, &iwe, IW_EV_PARAM_LEN);
+	}
+	/* Check if we added any event */
+	if ((current_val - start) > iwe_stream_lcp_len(info))
+		start = current_val;
+	/* parsing WPA/WPA2 IE */
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 wpa_ie[255], rsn_ie[255];
+		u16 wpa_len = 0, rsn_len = 0;
+		int n;
+		sint out_len = 0;
+		out_len = r8712_get_sec_ie(pnetwork->network.IEs,
+					   pnetwork->network.
+					   IELength, rsn_ie, &rsn_len,
+					   wpa_ie, &wpa_len);
+		if (wpa_len > 0) {
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			n = sprintf(buf, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				n += snprintf(buf + n, MAX_WPA_IE_LEN - n,
+							"%02x", wpa_ie[i]);
+				if (n >= MAX_WPA_IE_LEN)
+					break;
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = (u16)strlen(buf);
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, buf);
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = (u16)wpa_len;
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, wpa_ie);
+		}
+		if (rsn_len > 0) {
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			n = sprintf(buf, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				n += snprintf(buf + n, MAX_WPA_IE_LEN - n,
+							"%02x", rsn_ie[i]);
+				if (n >= MAX_WPA_IE_LEN)
+					break;
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, buf);
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe,
+				rsn_ie);
+		}
+	}
+
+	{ /* parsing WPS IE */
+		u8 wps_ie[512];
+		uint wps_ielen;
+
+		if (r8712_get_wps_ie(pnetwork->network.IEs,
+		    pnetwork->network.IELength,
+		    wps_ie, &wps_ielen) == true) {
+			if (wps_ielen > 2) {
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop,
+					&iwe, wps_ie);
+			}
+		}
+	}
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	rssi = r8712_signal_scale_mapping(pnetwork->network.Rssi);
+	/* we only update signal_level (signal strength) that is rssi. */
+	iwe.u.qual.updated = (u8)(IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_UPDATED |
+				  IW_QUAL_NOISE_INVALID);
+	iwe.u.qual.level = rssi;  /* signal strength */
+	iwe.u.qual.qual = 0; /* signal quality */
+	iwe.u.qual.noise = 0; /* noise level */
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	/* how to translate rssi to ?% */
+	return start;
+}
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {
+		padapter->securitypriv.ndisencryptstatus =
+						 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype =
+						 Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.AuthAlgrthm = 3;
+	} else if (value & AUTH_ALG_SHARED_KEY) {
+		padapter->securitypriv.ndisencryptstatus =
+						 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		padapter->securitypriv.AuthAlgrthm = 1;
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
+		if (padapter->securitypriv.ndisauthtype <
+						 Ndis802_11AuthModeWPAPSK) {
+			padapter->securitypriv.ndisauthtype =
+						 Ndis802_11AuthModeOpen;
+			padapter->securitypriv.AuthAlgrthm = 0;
+		}
+	} else
+		ret = -EINVAL;
+	return ret;
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
+			      u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len = 0;
+	struct NDIS_802_11_WEP	 *pwep = NULL;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+	if (param_len != (u32)((u8 *) param->u.crypt.key - (u8 *)param) +
+			 param->u.crypt.key_len)
+		return -EINVAL;
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
+			/* for large key indices, set the default (0) */
+			param->u.crypt.idx = 0;
+		}
+	} else
+		return -EINVAL;
+	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		printk(KERN_INFO "r8712u: wpa_set_encryption, crypt.alg ="
+		       " WEP\n");
+		padapter->securitypriv.ndisencryptstatus =
+			     Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.XGrpPrivacy = _WEP40_;
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+		if (wep_key_idx >= WEP_KEYS)
+			wep_key_idx = 0;
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			pwep = (struct NDIS_802_11_WEP *)_malloc((u32)
+			       (wep_key_len +
+			       FIELD_OFFSET(struct NDIS_802_11_WEP,
+			       KeyMaterial)));
+			if (pwep == NULL)
+				return -ENOMEM;
+			memset(pwep, 0, sizeof(struct NDIS_802_11_WEP));
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_key_len +
+				 FIELD_OFFSET(struct NDIS_802_11_WEP,
+				 KeyMaterial);
+			if (wep_key_len == 13) {
+				padapter->securitypriv.PrivacyAlgrthm =
+					 _WEP104_;
+				padapter->securitypriv.XGrpPrivacy =
+					 _WEP104_;
+			}
+		} else
+			return -EINVAL;
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+		memcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);
+		if (param->u.crypt.set_tx) {
+			if (r8712_set_802_11_add_wep(padapter, pwep) ==
+			    (u8)_FAIL)
+				ret = -EOPNOTSUPP;
+		} else {
+			/* don't update "psecuritypriv->PrivacyAlgrthm" and
+			 * "psecuritypriv->PrivacyKeyIndex=keyid", but can
+			 * r8712_set_key to fw/cam
+			 */
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP;
+				goto exit;
+			}
+			memcpy(&(psecuritypriv->DefKey[wep_key_idx].
+				skey[0]), pwep->KeyMaterial,
+				pwep->KeyLength);
+			psecuritypriv->DefKeylen[wep_key_idx] =
+				pwep->KeyLength;
+			r8712_set_key(padapter, psecuritypriv, wep_key_idx);
+		}
+		goto exit;
+	}
+	if (padapter->securitypriv.AuthAlgrthm == 2) { /* 802_1x */
+		struct sta_info *psta, *pbcmc_sta;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE |
+		    WIFI_MP_STATE) == true) { /* sta mode */
+			psta = r8712_get_stainfo(pstapriv,
+						 get_bssid(pmlmepriv));
+			if (psta) {
+				psta->ieee8021x_blocked = false;
+				if ((padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption2Enabled) ||
+				    (padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption3Enabled))
+					psta->XPrivacy = padapter->
+					    securitypriv.PrivacyAlgrthm;
+				if (param->u.crypt.set_tx == 1)
+					handle_pairwise_key(psta, param,
+							    padapter);
+				else /* group key */
+					handle_group_key(param, padapter);
+			}
+			pbcmc_sta = r8712_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta) {
+				pbcmc_sta->ieee8021x_blocked = false;
+				if ((padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption2Enabled) ||
+				    (padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption3Enabled))
+					pbcmc_sta->XPrivacy =
+					  padapter->securitypriv.
+					  PrivacyAlgrthm;
+			}
+		}
+	}
+exit:
+	kfree((u8 *)pwep);
+	return ret;
+}
+
+static int r871x_set_wpa_ie(struct _adapter *padapter, char *pie,
+			    unsigned short ielen)
+{
+	u8 *buf = NULL, *pos = NULL;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL))
+		return -EINVAL;
+	if (ielen) {
+		buf = _malloc(ielen);
+		if (buf == NULL)
+			return -ENOMEM;
+		memcpy(buf, pie , ielen);
+		pos = buf;
+		if (ielen < RSN_HEADER_LEN) {
+			ret  = -EINVAL;
+			goto exit;
+		}
+		if (r8712_parse_wpa_ie(buf, ielen, &group_cipher,
+		    &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeWPAPSK;
+		}
+		if (r8712_parse_wpa2_ie(buf, ielen, &group_cipher,
+		    &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeWPA2PSK;
+		}
+		switch (group_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.XGrpPrivacy =
+				 _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.XGrpPrivacy = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.XGrpPrivacy = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.XGrpPrivacy = _AES_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.XGrpPrivacy = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		}
+		switch (pairwise_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.PrivacyAlgrthm =
+				 _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.PrivacyAlgrthm = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.PrivacyAlgrthm = _AES_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.PrivacyAlgrthm = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		}
+		padapter->securitypriv.wps_phase = false;
+		{/* set wps_ie */
+			u16 cnt = 0;
+			u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+			while (cnt < ielen) {
+				eid = buf[cnt];
+
+				if ((eid == _VENDOR_SPECIFIC_IE_) &&
+				    (!memcmp(&buf[cnt+2], wps_oui, 4))) {
+					printk(KERN_INFO "r8712u: "
+					       "SET WPS_IE\n");
+					padapter->securitypriv.wps_ie_len =
+					    ((buf[cnt+1] + 2) <
+					    (MAX_WPA_IE_LEN << 2)) ?
+					    (buf[cnt + 1] + 2) :
+					    (MAX_WPA_IE_LEN << 2);
+					memcpy(padapter->securitypriv.wps_ie,
+					    &buf[cnt],
+					    padapter->securitypriv.wps_ie_len);
+					padapter->securitypriv.wps_phase =
+								 true;
+					printk(KERN_INFO "r8712u: SET WPS_IE,"
+					    " wps_phase==true\n");
+					cnt += buf[cnt+1]+2;
+					break;
+				} else
+					cnt += buf[cnt + 1] + 2;
+			}
+		}
+	}
+exit:
+	kfree(buf);
+	return ret;
+}
+
+static int r8711_wx_get_name(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap = false;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct ndis_wlan_bssid_ex  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX *prates = NULL;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) ==
+	    true) {
+		/* parsing HT_CAP_IE */
+		p = r8712_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_,
+				 &ht_ielen, pcur_bss->IELength - 12);
+		if (p && ht_ielen > 0)
+			ht_cap = true;
+		prates = &pcur_bss->SupportedRates;
+		if (r8712_is_cckratesonly_included((u8 *)prates) == true) {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11b");
+		} else if ((r8712_is_cckrates_included((u8 *)prates)) == true) {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bg");
+		} else {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11gn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11g");
+		}
+	} else
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	return 0;
+}
+
+static const long frequency_list[] = {
+	2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462,
+	2467, 2472, 2484, 4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,
+	5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210,
+	5220, 5230, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560,
+	5580, 5600, 5620, 5640, 5660, 5680, 5700, 5745, 5765, 5785, 5805,
+	5825
+};
+
+static int r8711_wx_set_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_freq *fwrq = &wrqu->freq;
+	int rc = 0;
+
+/* If setting by frequency, convert to a channel */
+	if ((fwrq->e == 1) &&
+	  (fwrq->m >= (int) 2.412e8) &&
+	  (fwrq->m <= (int) 2.487e8)) {
+		int f = fwrq->m / 100000;
+		int c = 0;
+		while ((c < 14) && (f != frequency_list[c]))
+			c++;
+		fwrq->e = 0;
+		fwrq->m = c + 1;
+	}
+	/* Setting by channel number */
+	if ((fwrq->m > 14) || (fwrq->e > 0))
+		rc = -EOPNOTSUPP;
+	else {
+		int channel = fwrq->m;
+		if ((channel < 1) || (channel > 14))
+			rc = -EINVAL;
+		else {
+			/* Yes ! We can set it !!! */
+			padapter->registrypriv.channel = channel;
+		}
+	}
+	return rc;
+}
+
+static int r8711_wx_get_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		wrqu->freq.m = ieee80211_wlan_frequencies[
+			       pcur_bss->Configuration.DSConfig-1] * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+	} else {
+		return -ENOLINK;
+	}
+	return 0;
+}
+
+static int r8711_wx_set_mode(struct net_device *dev,
+			     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+
+	switch (wrqu->mode) {
+	case IW_MODE_AUTO:
+		networkType = Ndis802_11AutoUnknown;
+		break;
+	case IW_MODE_ADHOC:
+		networkType = Ndis802_11IBSS;
+		break;
+	case IW_MODE_MASTER:
+		networkType = Ndis802_11APMode;
+		break;
+	case IW_MODE_INFRA:
+		networkType = Ndis802_11Infrastructure;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (Ndis802_11APMode == networkType)
+		r8712_setopmode_cmd(padapter, networkType);
+	else
+		r8712_setopmode_cmd(padapter, Ndis802_11AutoUnknown);
+
+	r8712_set_802_11_infrastructure_mode(padapter, networkType);
+	return 0;
+}
+
+static int r8711_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		wrqu->mode = IW_MODE_INFRA;
+	else if (check_fwstate(pmlmepriv,
+		 WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE) == true)
+		wrqu->mode = IW_MODE_ADHOC;
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		wrqu->mode = IW_MODE_MASTER;
+	else
+		wrqu->mode = IW_MODE_AUTO;
+	return 0;
+}
+
+static int r871x_wx_set_pmkid(struct net_device *dev,
+			     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct iw_pmksa *pPMK = (struct iw_pmksa *) extra;
+	u8 strZeroMacAddress[ETH_ALEN] = {0x00};
+	u8 strIssueBssid[ETH_ALEN] = {0x00};
+	u8 j, blInserted = false;
+	int intReturn = false;
+
+/*
+	There are the BSSID information in the bssid.sa_data array.
+	If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear
+	 all the PMKID information. If cmd is IW_PMKSA_ADD, it means the
+	  wpa_supplicant wants to add a PMKID/BSSID to driver.
+	If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to
+	  remove a PMKID/BSSID from driver.
+*/
+	if (pPMK == NULL)
+		return -EINVAL;
+	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+	switch (pPMK->cmd) {
+	case IW_PMKSA_ADD:
+		if (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))
+			return intReturn;
+		else
+			intReturn = true;
+		blInserted = false;
+		/* overwrite PMKID */
+		for (j = 0 ; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid,
+			    strIssueBssid, ETH_ALEN)) {
+				/* BSSID is matched, the same AP => rewrite
+				 * with new PMKID. */
+				printk(KERN_INFO "r8712u: r871x_wx_set_pmkid:"
+				    " BSSID exists in the PMKList.\n");
+				memcpy(psecuritypriv->PMKIDList[j].PMKID,
+					pPMK->pmkid, IW_PMKID_LEN);
+				psecuritypriv->PMKIDList[j].bUsed = true;
+				psecuritypriv->PMKIDIndex = j + 1;
+				blInserted = true;
+				break;
+			}
+		}
+		if (!blInserted) {
+			/* Find a new entry */
+			printk(KERN_INFO "r8712u: r871x_wx_set_pmkid: Use the"
+			    " new entry index = %d for this PMKID.\n",
+			    psecuritypriv->PMKIDIndex);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->
+				PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->
+				PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].
+				bUsed = true;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == NUM_PMKID_CACHE)
+				psecuritypriv->PMKIDIndex = 0;
+		}
+		break;
+	case IW_PMKSA_REMOVE:
+		intReturn = true;
+		for (j = 0; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid,
+			    strIssueBssid, ETH_ALEN)) {
+				/* BSSID is matched, the same AP => Remove
+				 * this PMKID information and reset it. */
+				memset(psecuritypriv->PMKIDList[j].Bssid,
+					0x00, ETH_ALEN);
+				psecuritypriv->PMKIDList[j].bUsed = false;
+				break;
+			}
+		}
+		break;
+	case IW_PMKSA_FLUSH:
+		memset(psecuritypriv->PMKIDList, 0,
+			sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		psecuritypriv->PMKIDIndex = 0;
+		intReturn = true;
+		break;
+	default:
+		printk(KERN_INFO "r8712u: r871x_wx_set_pmkid: "
+		       "unknown Command\n");
+		intReturn = false;
+		break;
+	}
+	return intReturn;
+}
+
+static int r8711_wx_get_sens(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	wrqu->sens.value = 0;
+	wrqu->sens.fixed = 0;	/* no auto select */
+	wrqu->sens.disabled = 1;
+	return 0;
+}
+
+static int r8711_wx_get_range(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	u16 val;
+	int i;
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;
+	/* TODO: 8711 sensitivity ? */
+	/* signal level threshold range */
+	/* percent values between 0 and 100. */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + -98;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+	range->num_bitrates = RATE_COUNT;
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)
+		range->bitrate[i] = rtl8180_rates[i];
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+	range->pm_capa = 0;
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+	range->num_channels = 14;
+	for (i = 0, val = 0; i < 14; i++) {
+		/* Include only legal frequencies for some countries */
+		range->freq[val].i = i + 1;
+		range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
+		range->freq[val].e = 1;
+		val++;
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+	range->num_frequency = val;
+	range->enc_capa = IW_ENC_CAPA_WPA |
+			  IW_ENC_CAPA_WPA2 |
+			  IW_ENC_CAPA_CIPHER_TKIP |
+			  IW_ENC_CAPA_CIPHER_CCMP;
+	return 0;
+}
+
+static int r8711_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra);
+
+static int r871x_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+	int ret = 0, len = 0;
+	char *ext;
+	struct _adapter *padapter = netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point *)awrq;
+
+	len = dwrq->length;
+	ext = _malloc(len);
+	if (!ext)
+		return -ENOMEM;
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		kfree(ext);
+		return -EFAULT;
+	}
+
+	if (0 == strcasecmp(ext, "RSSI")) {
+		/*Return received signal strength indicator in -db for */
+		/* current AP */
+		/*<ssid> Rssi xx */
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+		struct wlan_network *pcur_network = &pmlmepriv->cur_network;
+		/*static u8 xxxx; */
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+			sprintf(ext, "%s rssi %d",
+				pcur_network->network.Ssid.Ssid,
+				/*(xxxx=xxxx+10) */
+				((padapter->recvpriv.fw_rssi)>>1)-95
+				/*pcur_network->network.Rssi */
+				);
+		} else {
+			sprintf(ext, "OK");
+		}
+	} else if (0 == strcasecmp(ext, "LINKSPEED")) {
+		/*Return link speed in MBPS */
+		/*LinkSpeed xx */
+		union iwreq_data wrqd;
+		int ret_inner;
+		int mbps;
+
+		ret_inner = r8711_wx_get_rate(dev, info, &wrqd, extra);
+		if (0 != ret_inner)
+			mbps = 0;
+		else
+			mbps = wrqd.bitrate.value / 1000000;
+		sprintf(ext, "LINKSPEED %d", mbps);
+	} else if (0 == strcasecmp(ext, "MACADDR")) {
+		/*Return mac address of the station */
+		/*Macaddr = xx.xx.xx.xx.xx.xx */
+		sprintf(ext,
+			"MACADDR = %02x.%02x.%02x.%02x.%02x.%02x",
+			*(dev->dev_addr), *(dev->dev_addr+1),
+			*(dev->dev_addr+2), *(dev->dev_addr+3),
+			*(dev->dev_addr+4), *(dev->dev_addr+5));
+	} else if (0 == strcasecmp(ext, "SCAN-ACTIVE")) {
+		/*Set scan type to active */
+		/*OK if successful */
+		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+		pmlmepriv->passive_mode = 1;
+		sprintf(ext, "OK");
+	} else if (0 == strcasecmp(ext, "SCAN-PASSIVE")) {
+		/*Set scan type to passive */
+		/*OK if successful */
+		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+		pmlmepriv->passive_mode = 0;
+		sprintf(ext, "OK");
+	} else if (0 == strncmp(ext, "DCE-E", 5)) {
+		/*Set scan type to passive */
+		/*OK if successful */
+		r8712_disconnectCtrlEx_cmd(padapter
+			, 1 /*u32 enableDrvCtrl */
+			, 5 /*u32 tryPktCnt */
+			, 100 /*u32 tryPktInterval */
+			, 5000 /*u32 firstStageTO */
+		);
+		sprintf(ext, "OK");
+	} else if (0 == strncmp(ext, "DCE-D", 5)) {
+		/*Set scan type to passive */
+		/*OK if successfu */
+		r8712_disconnectCtrlEx_cmd(padapter
+			, 0 /*u32 enableDrvCtrl */
+			, 5 /*u32 tryPktCnt */
+			, 100 /*u32 tryPktInterval */
+			, 5000 /*u32 firstStageTO */
+		);
+		sprintf(ext, "OK");
+	} else {
+		printk(KERN_INFO "r8712u: r871x_wx_set_priv: unknown Command"
+		       " %s.\n", ext);
+		goto FREE_EXT;
+	}
+	if (copy_to_user(dwrq->pointer, ext,
+				min(dwrq->length, (__u16)(strlen(ext)+1))))
+		ret = -EFAULT;
+
+FREE_EXT:
+	kfree(ext);
+	return ret;
+}
+
+/* set bssid flow
+ * s1. set_802_11_infrastructure_mode()
+ * s2. set_802_11_authentication_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. set_802_11_bssid()
+ *
+ * This function intends to handle the Set AP command, which specifies the
+ * MAC# of a preferred Access Point.
+ * Currently, the request comes via Wireless Extensions' SIOCSIWAP ioctl.
+ *
+ * For this operation to succeed, there is no need for the interface to be Up.
+ *
+ */
+static int r8711_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	int ret = -EINPROGRESS;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+	unsigned long irqL;
+	struct list_head *phead;
+	u8 *dst_bssid;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		return -EBUSY;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		return ret;
+	if (temp->sa_family != ARPHRD_ETHER)
+		return -EINVAL;
+	authmode = padapter->securitypriv.ndisauthtype;
+	spin_lock_irqsave(&queue->lock, irqL);
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true)
+			break;
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+			   struct wlan_network, list);
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+		dst_bssid = pnetwork->network.MacAddress;
+		if (!memcmp(dst_bssid, temp->sa_data, ETH_ALEN)) {
+			r8712_set_802_11_infrastructure_mode(padapter,
+			    pnetwork->network.InfrastructureMode);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	if (!ret) {
+		if (!r8712_set_802_11_authentication_mode(padapter, authmode))
+			ret = -ENOMEM;
+		else {
+			if (!r8712_set_802_11_bssid(padapter, temp->sa_data))
+				ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int r8711_wx_get_wap(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	if (check_fwstate(pmlmepriv, _FW_LINKED |
+	    WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)) {
+		memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	}
+	return 0;
+}
+
+static int r871x_wx_set_mlme(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	u16 reason;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+	if (mlme == NULL)
+		return -1;
+	reason = cpu_to_le16(mlme->reason_code);
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+		if (!r8712_set_802_11_disassociate(padapter))
+			ret = -1;
+		break;
+	case IW_MLME_DISASSOC:
+		if (!r8712_set_802_11_disassociate(padapter))
+			ret = -1;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return ret;
+}
+
+/**
+ *
+ * This function intends to handle the Set Scan command.
+ * Currently, the request comes via Wireless Extensions' SIOCSIWSCAN ioctl.
+ *
+ * For this operation to succeed, the interface is brought Up beforehand.
+ *
+ */
+static int r8711_wx_set_scan(struct net_device *dev,
+			struct iw_request_info *a,
+			union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 status = true;
+
+	if (padapter->bDriverStopped == true) {
+		printk(KERN_WARNING "r8712u: in r8711_wx_set_scan: "
+		    "bDriverStopped=%d\n", padapter->bDriverStopped);
+		return -1;
+	}
+	if (padapter->bup == false)
+		return -ENETDOWN;
+	if (padapter->hw_init_completed == false)
+		return -1;
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == true))
+		return 0;
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+			struct ndis_802_11_ssid ssid;
+			unsigned long irqL;
+			u32 len = (u32) min((u8)req->essid_len,
+				  (u8)IW_ESSID_MAX_SIZE);
+			memset((unsigned char *)&ssid, 0,
+				 sizeof(struct ndis_802_11_ssid));
+			memcpy(ssid.Ssid, req->essid, len);
+			ssid.SsidLength = len;
+			spin_lock_irqsave(&pmlmepriv->lock, irqL);
+			if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |
+			     _FW_UNDER_LINKING)) ||
+			    (pmlmepriv->sitesurveyctrl.traffic_busy == true)) {
+				if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+					status = false;
+			} else
+				status = r8712_sitesurvey_cmd(padapter, &ssid);
+			spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+		}
+	} else
+		status = r8712_set_802_11_bssid_list_scan(padapter);
+	if (status == false)
+		return -1;
+	return 0;
+}
+
+static int r8711_wx_get_scan(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0, cnt = 0;
+
+	if (padapter->bDriverStopped)
+		return -EINVAL;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		msleep(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+	spin_lock_irqsave(&queue->lock, irqL);
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		ev = translate_scan(padapter, a, pnetwork, ev, stop);
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	wrqu->data.length = ev - extra;
+	wrqu->data.flags = 0;
+	return ret;
+}
+
+/* set ssid flow
+ * s1. set_802_11_infrastructure_mode()
+ * s2. set_802_11_authenticaion_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. set_802_11_ssid()
+ *
+ * This function intends to handle the Set ESSID command.
+ * Currently, the request comes via the Wireless Extensions' SIOCSIWESSID ioctl.
+ *
+ * For this operation to succeed, there is no need for the interface to be Up.
+ *
+ */
+static int r8711_wx_set_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
+	struct ndis_802_11_ssid ndis_ssid;
+	u8 *dst_ssid, *src_ssid;
+	struct list_head *phead;
+	u32 len;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		return -EBUSY;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+		return 0;
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+	authmode = padapter->securitypriv.ndisauthtype;
+	if (wrqu->essid.flags && wrqu->essid.length) {
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ?
+		       wrqu->essid.length : IW_ESSID_MAX_SIZE;
+		memset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));
+		ndis_ssid.SsidLength = len;
+		memcpy(ndis_ssid.Ssid, extra, len);
+		src_ssid = ndis_ssid.Ssid;
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = get_next(phead);
+		while (1) {
+			if (end_of_queue_search(phead, pmlmepriv->pscanned))
+				break;
+			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+				   struct wlan_network, list);
+			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+			if ((!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength))
+			    && (pnetwork->network.Ssid.SsidLength ==
+			     ndis_ssid.SsidLength)) {
+				if (check_fwstate(pmlmepriv,
+							WIFI_ADHOC_STATE)) {
+					if (pnetwork->network.
+						InfrastructureMode
+						!=
+						padapter->mlmepriv.
+						cur_network.network.
+						InfrastructureMode)
+						continue;
+				}
+
+				r8712_set_802_11_infrastructure_mode(
+				     padapter,
+				     pnetwork->network.InfrastructureMode);
+				break;
+			}
+		}
+		r8712_set_802_11_authentication_mode(padapter, authmode);
+		r8712_set_802_11_ssid(padapter, &ndis_ssid);
+	}
+	return -EINPROGRESS;
+}
+
+static int r8711_wx_get_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+	u32 len, ret = 0;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		len = pcur_bss->Ssid.SsidLength;
+		wrqu->essid.length = len;
+		memcpy(extra, pcur_bss->Ssid.Ssid, len);
+		wrqu->essid.flags = 1;
+	} else {
+		ret = -ENOLINK;
+	}
+	return ret;
+}
+
+static int r8711_wx_set_rate(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	u32 target_rate = wrqu->bitrate.value;
+	u32 fixed = wrqu->bitrate.fixed;
+	u32 ratevalue = 0;
+	u8 datarates[NumRates];
+	u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+	int i, ret = 0;
+
+	if (target_rate == -1) {
+		ratevalue = 11;
+		goto set_rate;
+	}
+	target_rate = target_rate / 100000;
+	switch (target_rate) {
+	case 10:
+		ratevalue = 0;
+		break;
+	case 20:
+		ratevalue = 1;
+		break;
+	case 55:
+		ratevalue = 2;
+		break;
+	case 60:
+		ratevalue = 3;
+		break;
+	case 90:
+		ratevalue = 4;
+		break;
+	case 110:
+		ratevalue = 5;
+		break;
+	case 120:
+		ratevalue = 6;
+		break;
+	case 180:
+		ratevalue = 7;
+		break;
+	case 240:
+		ratevalue = 8;
+		break;
+	case 360:
+		ratevalue = 9;
+		break;
+	case 480:
+		ratevalue = 10;
+		break;
+	case 540:
+		ratevalue = 11;
+		break;
+	default:
+		ratevalue = 11;
+		break;
+	}
+set_rate:
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+			if (fixed == 0)
+				break;
+		} else
+			datarates[i] = 0xff;
+	}
+	if (r8712_setdatarate_cmd(padapter, datarates) != _SUCCESS)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int r8711_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+	struct ieee80211_ht_cap *pht_capie;
+	unsigned char rf_type = padapter->registrypriv.rf_config;
+	int i;
+	u8 *p;
+	u16 rate, max_rate = 0, ht_cap = false;
+	u32 ht_ielen = 0;
+	u8 bw_40MHz = 0, short_GI = 0;
+	u16 mcs_rate = 0;
+
+	i = 0;
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		p = r8712_get_ie(&pcur_bss->IEs[12],
+				 _HT_CAPABILITY_IE_, &ht_ielen,
+		    pcur_bss->IELength - 12);
+		if (p && ht_ielen > 0) {
+			ht_cap = true;
+			pht_capie = (struct ieee80211_ht_cap *)(p + 2);
+			memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+			bw_40MHz = (pht_capie->cap_info &
+				    IEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;
+			short_GI = (pht_capie->cap_info &
+				    (IEEE80211_HT_CAP_SGI_20 |
+				    IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
+		}
+		while ((pcur_bss->SupportedRates[i] != 0) &&
+			(pcur_bss->SupportedRates[i] != 0xFF)) {
+			rate = pcur_bss->SupportedRates[i] & 0x7F;
+			if (rate > max_rate)
+				max_rate = rate;
+			wrqu->bitrate.fixed = 0;	/* no auto select */
+			wrqu->bitrate.value = rate*500000;
+			i++;
+		}
+		if (ht_cap == true) {
+			if (mcs_rate & 0x8000 /* MCS15 */
+				&&
+				RTL8712_RF_2T2R == rf_type)
+				max_rate = (bw_40MHz) ? ((short_GI) ? 300 :
+					    270) : ((short_GI) ? 144 : 130);
+			else if (mcs_rate & 0x0080) /* MCS7 */
+				max_rate = (bw_40MHz) ? ((short_GI) ? 150 :
+					    135) : ((short_GI) ? 72 : 65);
+			else /* default MCS7 */
+				max_rate = (bw_40MHz) ? ((short_GI) ? 150 :
+					    135) : ((short_GI) ? 72 : 65);
+			max_rate *= 2; /* Mbps/2 */
+			wrqu->bitrate.value = max_rate * 500000;
+		} else {
+			wrqu->bitrate.value = max_rate * 500000;
+		}
+	} else
+		return -ENOLINK;
+	return 0;
+}
+
+static int r8711_wx_get_rts(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	return 0;
+}
+
+static int r8711_wx_set_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+	return 0;
+}
+
+static int r8711_wx_get_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	return 0;
+}
+
+static int r8711_wx_get_retry(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+	return 0;
+}
+
+static int r8711_wx_set_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	u32 key;
+	u32 keyindex_provided;
+	struct NDIS_802_11_WEP	 wep;
+	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
+	struct iw_point *erq = &(wrqu->encoding);
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	key = erq->flags & IW_ENCODE_INDEX;
+	memset(&wep, 0, sizeof(struct NDIS_802_11_WEP));
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+		return 0;
+	}
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} else {
+		keyindex_provided = 0;
+		key = padapter->securitypriv.PrivacyKeyIndex;
+	}
+	/* set authentication mode */
+	if (erq->flags & IW_ENCODE_OPEN) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+	} else if (erq->flags & IW_ENCODE_RESTRICTED) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 1; /* shared system */
+		padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.XGrpPrivacy = _WEP40_;
+		authmode = Ndis802_11AuthModeShared;
+		padapter->securitypriv.ndisauthtype = authmode;
+	} else {
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+	}
+	wep.KeyIndex = key;
+	if (erq->length > 0) {
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+		wep.Length = wep.KeyLength +
+			     FIELD_OFFSET(struct NDIS_802_11_WEP, KeyMaterial);
+	} else {
+		wep.KeyLength = 0 ;
+		if (keyindex_provided == 1) { /* set key_id only, no given
+					       * KeyMaterial(erq->length==0).*/
+			padapter->securitypriv.PrivacyKeyIndex = key;
+			switch (padapter->securitypriv.DefKeylen[key]) {
+			case 5:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _WEP40_;
+				break;
+			case 13:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _WEP104_;
+				break;
+			default:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _NO_PRIVACY_;
+				break;
+			}
+			return 0;
+		}
+	}
+	wep.KeyIndex |= 0x80000000;	/* transmit key */
+	memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+	if (r8712_set_802_11_add_wep(padapter, &wep) == _FAIL)
+		return -EOPNOTSUPP;
+	return 0;
+}
+
+static int r8711_wx_get_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false) {
+		if (!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			return 0;
+		}
+	}
+	key = erq->flags & IW_ENCODE_INDEX;
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else {
+		key = padapter->securitypriv.PrivacyKeyIndex;
+	}
+	erq->flags = key + 1;
+	switch (padapter->securitypriv.ndisencryptstatus) {
+	case Ndis802_11EncryptionNotSupported:
+	case Ndis802_11EncryptionDisabled:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		break;
+	case Ndis802_11Encryption1Enabled:
+		erq->length = padapter->securitypriv.DefKeylen[key];
+		if (erq->length) {
+			memcpy(keybuf, padapter->securitypriv.DefKey[
+				key].skey, padapter->securitypriv.
+				DefKeylen[key]);
+			erq->flags |= IW_ENCODE_ENABLED;
+			if (padapter->securitypriv.ndisauthtype ==
+			    Ndis802_11AuthModeOpen)
+				erq->flags |= IW_ENCODE_OPEN;
+			else if (padapter->securitypriv.ndisauthtype ==
+				 Ndis802_11AuthModeShared)
+				erq->flags |= IW_ENCODE_RESTRICTED;
+		} else {
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+		break;
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption3Enabled:
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN |
+			       IW_ENCODE_NOKEY);
+		break;
+	default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		break;
+	}
+	return ret;
+}
+
+static int r8711_wx_get_power(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+	return 0;
+}
+
+static int r871x_wx_set_gen_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	return r871x_set_wpa_ie(padapter, extra, wrqu->data.length);
+}
+
+static int r871x_wx_set_auth(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_param *param = (struct iw_param *)&(wrqu->param);
+	int paramid;
+	int paramval;
+	int ret = 0;
+
+	paramid = param->flags & IW_AUTH_INDEX;
+	paramval = param->value;
+	switch (paramid) {
+	case IW_AUTH_WPA_VERSION:
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		break;
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		if (paramval) {
+			/* wpa_supplicant is enabling tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = true;
+		} else {
+			/* wpa_supplicant is disabling tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = false;
+		}
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		if (padapter->securitypriv.ndisencryptstatus ==
+		    Ndis802_11Encryption1Enabled) {
+				/* it means init value, or using wep,
+				 * ndisencryptstatus =
+				 *	Ndis802_11Encryption1Enabled,
+				 * then it needn't reset it;
+				 */
+				break;
+		}
+
+		if (paramval) {
+			padapter->securitypriv.ndisencryptstatus =
+				   Ndis802_11EncryptionDisabled;
+			padapter->securitypriv.PrivacyAlgrthm =
+				  _NO_PRIVACY_;
+			padapter->securitypriv.XGrpPrivacy =
+				  _NO_PRIVACY_;
+			padapter->securitypriv.AuthAlgrthm = 0;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeOpen;
+		}
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		ret = wpa_set_auth_algs(dev, (u32)paramval);
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int r871x_wx_set_enc_ext(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct iw_point *pencoding = &wrqu->encoding;
+	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+	struct ieee_param *param = NULL;
+	char *alg_name;
+	u32 param_len;
+	int ret = 0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)_malloc(param_len);
+	if (param == NULL)
+		return -ENOMEM;
+	memset(param, 0, param_len);
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -EINVAL;
+	}
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+		param->u.crypt.set_tx = 0;
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
+		param->u.crypt.set_tx = 1;
+	param->u.crypt.idx = (pencoding->flags & 0x00FF) - 1;
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+		memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	if (pext->key_len) {
+		param->u.crypt.key_len = pext->key_len;
+		memcpy(param + 1, pext + 1, pext->key_len);
+	}
+	ret = wpa_set_encryption(dev, param, param_len);
+	kfree(param);
+	return ret;
+}
+
+static int r871x_wx_get_nick(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	if (extra) {
+		wrqu->data.length = 8;
+		wrqu->data.flags = 1;
+		memcpy(extra, "rtl_wifi", 8);
+	}
+	return 0;
+}
+
+static int r8711_wx_read32(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	data32 = r8712_read32(padapter, addr);
+	put_user(data32, (u32 __user *)wrqu->data.pointer);
+	wrqu->data.length = (data32 & 0xffff0000) >> 16;
+	wrqu->data.flags = data32 & 0xffff;
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	return 0;
+}
+
+static int r8711_wx_write32(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *keybuf)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	data32 = ((u32)wrqu->data.length<<16) | (u32)wrqu->data.flags ;
+	r8712_write32(padapter, addr, data32);
+	return 0;
+}
+
+static int dummy(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	return -ENOSYS;
+}
+
+static int r8711_drvext_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+static int r871x_mp_ioctl_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+	struct oid_par_priv oid_par;
+	struct mp_ioctl_handler *phandler;
+	struct mp_ioctl_param *poidparam;
+	unsigned long BytesRead, BytesWritten, BytesNeeded;
+	u8 *pparmbuf = NULL, bset;
+	u16 len;
+	uint status;
+	int ret = 0;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = NULL;
+	pparmbuf = (u8 *)_malloc(len);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	poidparam = (struct mp_ioctl_param *)pparmbuf;
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	phandler = mp_ioctl_hdl + poidparam->subcode;
+	if ((phandler->paramsize != 0) &&
+	    (poidparam->len < phandler->paramsize)) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (phandler->oid == 0 && phandler->handler)
+		status = phandler->handler(&oid_par);
+	else if (phandler->handler) {
+		oid_par.adapter_context = padapter;
+		oid_par.oid = phandler->oid;
+		oid_par.information_buf = poidparam->data;
+		oid_par.information_buf_len = poidparam->len;
+		oid_par.dbg = 0;
+		BytesWritten = 0;
+		BytesNeeded = 0;
+		if (bset) {
+			oid_par.bytes_rw = &BytesRead;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = SET_OID;
+		} else {
+			oid_par.bytes_rw = &BytesWritten;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = QUERY_OID;
+		}
+		status = phandler->handler(&oid_par);
+		/* todo:check status, BytesNeeded, etc. */
+	} else {
+		printk(KERN_INFO "r8712u: r871x_mp_ioctl_hdl(): err!,"
+		    " subcode=%d, oid=%d, handler=%p\n",
+		    poidparam->subcode, phandler->oid, phandler->handler);
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (bset == 0x00) { /* query info */
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+	if (status) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+_r871x_mp_ioctl_hdl_exit:
+	kfree(pparmbuf);
+	return ret;
+}
+
+static int r871x_get_ap_info(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct iw_point *pdata = &wrqu->data;
+	struct wlan_network *pnetwork = NULL;
+	u32 cnt = 0, wpa_ielen;
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+
+	if (padapter->bDriverStopped || (pdata == NULL))
+		return -EINVAL;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		msleep(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+	pdata->flags = 0;
+	if (pdata->length >= 32) {
+		if (copy_from_user(data, pdata->pointer, 32))
+			return -EINVAL;
+	} else
+		 return -EINVAL;
+	spin_lock_irqsave(&(pmlmepriv->scanned_queue.lock), irqL);
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (hwaddr_aton_i(data, bssid)) {
+			printk(KERN_INFO "r8712u: Invalid BSSID '%s'.\n",
+			       (u8 *)data);
+			spin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock),
+									irqL);
+			return -EINVAL;
+		}
+		printk(KERN_INFO "r8712u: BSSID:%pM\n", bssid);
+		if (!memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN)) {
+			/* BSSID match, then check if supporting wpa/wpa2 */
+			pbuf = r8712_get_wpa_ie(&pnetwork->network.IEs[12],
+			       &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 1;
+				break;
+			}
+			pbuf = r8712_get_wpa2_ie(&pnetwork->network.IEs[12],
+			       &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 2;
+				break;
+			}
+		}
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock), irqL);
+	if (pdata->length >= 34) {
+		if (copy_to_user((u8 __user *)pdata->pointer + 32,
+		    (u8 *)&pdata->flags, 1))
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int r871x_set_pid(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+
+	if ((padapter->bDriverStopped) || (pdata == NULL))
+		return -EINVAL;
+	if (copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))
+		return -EINVAL;
+	return 0;
+}
+
+static int r871x_set_chplan(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	int ch_plan = -1;
+
+	if ((padapter->bDriverStopped) || (pdata == NULL)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	ch_plan = (int)*extra;
+	r8712_set_chplan_cmd(padapter, ch_plan);
+
+exit:
+
+	return ret;
+}
+
+static int r871x_wps_start(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+
+	if (copy_from_user((void *)&u32wps_start, pdata->pointer, 4))
+		return -EFAULT;
+	if ((padapter->bDriverStopped) || (pdata == NULL))
+		return -EINVAL;
+	if (u32wps_start == 0)
+		u32wps_start = *extra;
+	if (u32wps_start == 1) /* WPS Start */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_START_WPS);
+	else if (u32wps_start == 2) /* WPS Stop because of wps success */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_STOP_WPS);
+	else if (u32wps_start == 3) /* WPS Stop because of wps fail */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_STOP_WPS_FAIL);
+	return 0;
+}
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	switch (name) {
+	case IEEE_PARAM_WPA_ENABLED:
+		padapter->securitypriv.AuthAlgrthm = 2; /* 802.1x */
+		switch ((value)&0xff) {
+		case 1: /* WPA */
+			padapter->securitypriv.ndisauthtype =
+				Ndis802_11AuthModeWPAPSK; /* WPA_PSK */
+			padapter->securitypriv.ndisencryptstatus =
+				Ndis802_11Encryption2Enabled;
+			break;
+		case 2: /* WPA2 */
+			padapter->securitypriv.ndisauthtype =
+				Ndis802_11AuthModeWPA2PSK; /* WPA2_PSK */
+			padapter->securitypriv.ndisencryptstatus =
+				Ndis802_11Encryption3Enabled;
+			break;
+		}
+		break;
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		break;
+	case IEEE_PARAM_DROP_UNENCRYPTED:
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		break;
+	case IEEE_PARAM_PRIVACY_INVOKED:
+		break;
+	case IEEE_PARAM_AUTH_ALGS:
+		return wpa_set_auth_algs(dev, value);
+		break;
+	case IEEE_PARAM_IEEE_802_1X:
+		break;
+	case IEEE_PARAM_WPAX_SELECT:
+		/* added for WPA2 mixed mode */
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	switch (command) {
+	case IEEE_MLME_STA_DEAUTH:
+		if (!r8712_set_802_11_disassociate(padapter))
+			return -1;
+		break;
+	case IEEE_MLME_STA_DISASSOC:
+		if (!r8712_set_802_11_disassociate(padapter))
+			return -1;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer)
+		return -EINVAL;
+	param = (struct ieee_param *)_malloc(p->length);
+	if (param == NULL)
+		return -ENOMEM;
+	if (copy_from_user(param, p->pointer, p->length)) {
+		kfree((u8 *)param);
+		return -EFAULT;
+	}
+	switch (param->cmd) {
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(dev, param->u.wpa_param.name,
+		      param->u.wpa_param.value);
+		break;
+	case IEEE_CMD_SET_WPA_IE:
+		ret =  r871x_set_wpa_ie(padapter, (char *)param->u.wpa_ie.data,
+		       (u16)param->u.wpa_ie.len);
+		break;
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(dev, param, p->length);
+		break;
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(dev, param->u.mlme.command,
+		      param->u.mlme.reason_code);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+	kfree((u8 *)param);
+	return ret;
+}
+
+/* based on "driver_ipw" and for hostapd */
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+
+	switch (cmd) {
+	case RTL_IOCTL_WPA_SUPPLICANT:
+		return wpa_supplicant_ioctl(dev, &wrq->u.data);
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static iw_handler r8711_handlers[] = {
+	NULL,				/* SIOCSIWCOMMIT */
+	r8711_wx_get_name,		/* SIOCGIWNAME */
+	dummy,				/* SIOCSIWNWID */
+	dummy,				/* SIOCGIWNWID */
+	r8711_wx_set_freq,		/* SIOCSIWFREQ */
+	r8711_wx_get_freq,		/* SIOCGIWFREQ */
+	r8711_wx_set_mode,		/* SIOCSIWMODE */
+	r8711_wx_get_mode,		/* SIOCGIWMODE */
+	dummy,				/* SIOCSIWSENS */
+	r8711_wx_get_sens,		/* SIOCGIWSENS */
+	NULL,				/* SIOCSIWRANGE */
+	r8711_wx_get_range,		/* SIOCGIWRANGE */
+	r871x_wx_set_priv,		/* SIOCSIWPRIV */
+	NULL,				/* SIOCGIWPRIV */
+	NULL,				/* SIOCSIWSTATS */
+	NULL,				/* SIOCGIWSTATS */
+	dummy,				/* SIOCSIWSPY */
+	dummy,				/* SIOCGIWSPY */
+	NULL,				/* SIOCGIWTHRSPY */
+	NULL,				/* SIOCWIWTHRSPY */
+	r8711_wx_set_wap,		/* SIOCSIWAP */
+	r8711_wx_get_wap,		/* SIOCGIWAP */
+	r871x_wx_set_mlme,		/* request MLME operation;
+					 *  uses struct iw_mlme */
+	dummy,				/* SIOCGIWAPLIST -- deprecated */
+	r8711_wx_set_scan,		/* SIOCSIWSCAN */
+	r8711_wx_get_scan,		/* SIOCGIWSCAN */
+	r8711_wx_set_essid,		/* SIOCSIWESSID */
+	r8711_wx_get_essid,		/* SIOCGIWESSID */
+	dummy,				/* SIOCSIWNICKN */
+	r871x_wx_get_nick,		/* SIOCGIWNICKN */
+	NULL,				/* -- hole -- */
+	NULL,				/* -- hole -- */
+	r8711_wx_set_rate,		/* SIOCSIWRATE */
+	r8711_wx_get_rate,		/* SIOCGIWRATE */
+	dummy,				/* SIOCSIWRTS */
+	r8711_wx_get_rts,		/* SIOCGIWRTS */
+	r8711_wx_set_frag,		/* SIOCSIWFRAG */
+	r8711_wx_get_frag,		/* SIOCGIWFRAG */
+	dummy,				/* SIOCSIWTXPOW */
+	dummy,				/* SIOCGIWTXPOW */
+	dummy,				/* SIOCSIWRETRY */
+	r8711_wx_get_retry,		/* SIOCGIWRETRY */
+	r8711_wx_set_enc,		/* SIOCSIWENCODE */
+	r8711_wx_get_enc,		/* SIOCGIWENCODE */
+	dummy,				/* SIOCSIWPOWER */
+	r8711_wx_get_power,		/* SIOCGIWPOWER */
+	NULL,				/*---hole---*/
+	NULL,				/*---hole---*/
+	r871x_wx_set_gen_ie,		/* SIOCSIWGENIE */
+	NULL,				/* SIOCGIWGENIE */
+	r871x_wx_set_auth,		/* SIOCSIWAUTH */
+	NULL,				/* SIOCGIWAUTH */
+	r871x_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
+	NULL,				/* SIOCGIWENCODEEXT */
+	r871x_wx_set_pmkid,		/* SIOCSIWPMKSA */
+	NULL,				/*---hole---*/
+};
+
+static const struct iw_priv_args r8711_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "read32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "write32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "chplan"
+	}
+};
+
+static iw_handler r8711_private_handler[] = {
+	r8711_wx_read32,
+	r8711_wx_write32,
+	r8711_drvext_hdl,
+	r871x_mp_ioctl_hdl,
+	r871x_get_ap_info, /*for MM DTV platform*/
+	r871x_set_pid,
+	r871x_wps_start,
+	r871x_set_chplan
+};
+
+static struct iw_statistics *r871x_get_wireless_stats(struct net_device *dev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_statistics *piwstats = &padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true) {
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+	} else {
+		/* show percentage, we need transfer dbm to orignal value. */
+		tmp_level = padapter->recvpriv.fw_rssi;
+		tmp_qual = padapter->recvpriv.signal;
+		tmp_noise = padapter->recvpriv.noise;
+		piwstats->qual.level = tmp_level;
+		piwstats->qual.qual = tmp_qual;
+		piwstats->qual.noise = tmp_noise;
+	}
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED;
+	return &padapter->iwstats;
+}
+
+struct iw_handler_def r871x_handlers_def = {
+	.standard = r8711_handlers,
+	.num_standard = sizeof(r8711_handlers) / sizeof(iw_handler),
+	.private = r8711_private_handler,
+	.private_args = (struct iw_priv_args *)r8711_private_args,
+	.num_private = sizeof(r8711_private_handler) / sizeof(iw_handler),
+	.num_private_args = sizeof(r8711_private_args) /
+			    sizeof(struct iw_priv_args),
+	.get_wireless_stats = r871x_get_wireless_stats
+};
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c b/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c
new file mode 100644
index 0000000..9a33eae
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c
@@ -0,0 +1,535 @@
+/******************************************************************************
+ * rtl871x_ioctl_rtl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define  _RTL871X_IOCTL_RTL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+#include "wifi.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_set.h"
+#include "rtl871x_ioctl_rtl.h"
+#include "mp_custom_oid.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_mp_ioctl.h"
+
+uint oid_rt_get_signal_quality_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_small_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				padapter->recvpriv.rx_smallpacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				padapter->recvpriv.rx_middlepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_large_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				 padapter->recvpriv.rx_largepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_retry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_retry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_total_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					 padapter->recvpriv.rx_pkts +
+					 padapter->recvpriv.rx_drop;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_icv_err_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(uint *)poid_par_priv->information_buf =
+					 padapter->recvpriv.rx_icv_err;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH ;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_preamble_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	u32 preamblemode = 0 ;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		if (padapter->registrypriv.preamble == PREAMBLE_LONG)
+			preamblemode = 0;
+		else if (padapter->registrypriv.preamble == PREAMBLE_AUTO)
+			preamblemode = 1;
+		else if (padapter->registrypriv.preamble == PREAMBLE_SHORT)
+			preamblemode = 2;
+		*(u32 *)poid_par_priv->information_buf = preamblemode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_ap_ip_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channelplan_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct eeprom_priv *peeprompriv = &padapter->eeprompriv;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	*(u16 *)poid_par_priv->information_buf = peeprompriv->channel_plan;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_channelplan_hdl(struct oid_par_priv
+				       *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct eeprom_priv *peeprompriv = &padapter->eeprompriv;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	peeprompriv->channel_plan = *(u16 *)poid_par_priv->information_buf;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_preamble_mode_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	u32 preamblemode = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		preamblemode = *(u32 *)poid_par_priv->information_buf;
+		if (preamblemode == 0)
+			padapter->registrypriv.preamble = PREAMBLE_LONG;
+		else if (preamblemode == 1)
+			padapter->registrypriv.preamble = PREAMBLE_AUTO;
+		else if (preamblemode == 2)
+			padapter->registrypriv.preamble = PREAMBLE_SHORT;
+		*(u32 *)poid_par_priv->information_buf = preamblemode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_bcn_intvl_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_dedicate_probe_hdl(struct oid_par_priv
+				      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+						 padapter->xmitpriv.tx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					   padapter->recvpriv.rx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->
+					   information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_current_tx_power_level_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv
+						  *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channel_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct NDIS_802_11_CONFIGURATION *pnic_Config;
+	u32   channelnum;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
+		pnic_Config = &pmlmepriv->cur_network.network.Configuration;
+	else
+		pnic_Config = &padapter->registrypriv.dev_network.
+			      Configuration;
+	channelnum = pnic_Config->DSConfig;
+	*(u32 *)poid_par_priv->information_buf = channelnum;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv
+			 *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_key_mismatch_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_supported_wireless_mode_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	u32 ulInfo = 0;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		ulInfo |= 0x0100; /* WIRELESS_MODE_B */
+		ulInfo |= 0x0200; /* WIRELESS_MODE_G */
+		ulInfo |= 0x0400; /* WIRELESS_MODE_A */
+		*(u32 *) poid_par_priv->information_buf = ulInfo;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channel_list_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_scan_in_progress_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+
+uint oid_rt_forced_data_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv
+						   *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv
+						      *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv*
+					      poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_supported_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_set_passphrase_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv*
+					     poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+			(poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID) /* QUERY_OID */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len ==
+	   (sizeof(unsigned long) * 3)) {
+		if (!r8712_setrfreg_cmd(Adapter,
+			*(unsigned char *)poid_par_priv->information_buf,
+			(unsigned long)(*((unsigned long *)
+					poid_par_priv->information_buf + 2))))
+			status = NDIS_STATUS_NOT_ACCEPTED;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+			(poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID) /* QUERY_OID */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len == (sizeof(unsigned long)*3)) {
+		if (Adapter->mppriv.act_in_progress == true)
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		else {
+			/* init workparam */
+			Adapter->mppriv.act_in_progress = true;
+			Adapter->mppriv.workparam.bcompleted = false;
+			Adapter->mppriv.workparam.act_type = MPT_READ_RF;
+			Adapter->mppriv.workparam.io_offset = *(unsigned long *)
+						poid_par_priv->information_buf;
+			Adapter->mppriv.workparam.io_value = 0xcccccccc;
+
+		/* RegOffsetValue	- The offset of RF register to read.
+		 * RegDataWidth	- The data width of RF register to read.
+		 * RegDataValue	- The value to read.
+		 * RegOffsetValue = *((unsigned long *)InformationBuffer);
+		 * RegDataWidth = *((unsigned long *)InformationBuffer+1);
+		 * RegDataValue =  *((unsigned long *)InformationBuffer+2);
+		 */
+			if (!r8712_getrfreg_cmd(Adapter,
+			    *(unsigned char *)poid_par_priv->information_buf,
+			    (unsigned char *)&Adapter->mppriv.workparam.
+			    io_value))
+				status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+enum _CONNECT_STATE_ {
+	CHECKINGSTATUS,
+	ASSOCIATED,
+	ADHOCMODE,
+	NOTASSOCIATED
+};
+
+uint oid_rt_get_connect_state_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				     (poid_par_priv->adapter_context);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u32 ulInfo;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	/* nStatus==0	CheckingStatus
+	 * nStatus==1	Associated
+	 * nStatus==2	AdHocMode
+	 * nStatus==3	NotAssociated
+	 */
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		ulInfo = CHECKINGSTATUS;
+	else if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+		ulInfo = ASSOCIATED;
+	else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+		ulInfo = ADHOCMODE;
+	else
+		ulInfo = NOTASSOCIATED ;
+	*(u32 *)poid_par_priv->information_buf = ulInfo;
+	*poid_par_priv->bytes_rw =  poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_default_key_id_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h b/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h
new file mode 100644
index 0000000..3bcceae
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h
@@ -0,0 +1,121 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_IOCTL_RTL_H
+#define _RTL871X_IOCTL_RTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/*************** oid_rtl_seg_01_01 **************/
+uint oid_rt_get_signal_quality_hdl(
+			struct oid_par_priv *poid_par_priv);/*84*/
+uint oid_rt_get_small_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_middle_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_large_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_retry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_retry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_total_packet_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_beacon_ok_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_beacon_err_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_icv_err_hdl(
+			struct oid_par_priv *poid_par_priv);/*93*/
+uint oid_rt_set_encryption_algorithm_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_preamble_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_ap_ip_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channelplan_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_channelplan_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_preamble_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_bcn_intvl_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_dedicate_probe_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_total_tx_bytes_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_total_rx_bytes_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_current_tx_power_level_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_enc_key_mismatch_count_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_enc_key_match_count_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channel_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_hardware_radio_off_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_key_mismatch_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_supported_wireless_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channel_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_scan_in_progress_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_forced_data_rate_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_wireless_mode_for_scan_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_bss_wireless_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_scan_with_magic_packet_hdl(
+			struct oid_par_priv *poid_par_priv);
+
+/**************  oid_rtl_seg_01_03 section start **************/
+uint oid_rt_ap_get_associated_station_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_switch_into_ap_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_supported_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_set_passphrase_hdl(
+			struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_01_11 */
+uint oid_rt_pro_rf_write_registry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rf_read_registry_hdl(
+			struct oid_par_priv *poid_par_priv);
+/***************  oid_rtl_seg_03_00 section start **************/
+uint oid_rt_get_connect_state_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_default_key_id_hdl(
+			struct oid_par_priv *poid_par_priv);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl_set.c b/drivers/staging/rtl8712/rtl871x_ioctl_set.c
new file mode 100644
index 0000000..fb29b42
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl_set.c
@@ -0,0 +1,381 @@
+/******************************************************************************
+ * rtl871x_ioctl_set.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_IOCTL_SET_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_ioctl_set.h"
+#include "usb_osintf.h"
+#include "usb_ops.h"
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+( \
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
+	 (addr[2] == 0xff) && (addr[3] == 0xff) && \
+	 (addr[4] == 0xff) && (addr[5] == 0xff)) ? true : false \
+)
+
+static u8 validate_ssid(struct ndis_802_11_ssid *ssid)
+{
+	u8 i;
+
+	if (ssid->SsidLength > 32)
+		return false;
+	for (i = 0; i < ssid->SsidLength; i++) {
+		/* wifi, printable ascii code must be supported */
+		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e)))
+			return false;
+	}
+	return true;
+}
+
+static u8 do_join(struct _adapter *padapter)
+{
+	struct list_head *plist, *phead;
+	u8 *pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct  __queue	*queue	= &(pmlmepriv->scanned_queue);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	pmlmepriv->cur_network.join_res = -2;
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+	pmlmepriv->pscanned = plist;
+	pmlmepriv->to_join = true;
+
+	/* adhoc mode will start with an empty queue, but skip checking */
+	if (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) &&
+	    _queue_empty(queue)) {
+		if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+			pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+		/* when set_ssid/set_bssid for do_join(), but scanning queue
+		 * is empty we try to issue sitesurvey firstly
+		 */
+		if (pmlmepriv->sitesurveyctrl.traffic_busy == false)
+			r8712_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+		return true;
+	} else {
+		int ret;
+
+		ret = r8712_select_and_join_from_scan(pmlmepriv);
+		if (ret == _SUCCESS)
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+		else {
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+				/* submit r8712_createbss_cmd to change to an
+				 * ADHOC_MASTER pmlmepriv->lock has been
+				 * acquired by caller...
+				 */
+				struct wlan_bssid_ex *pdev_network =
+					&(padapter->registrypriv.dev_network);
+				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+				pibss = padapter->registrypriv.dev_network.
+					MacAddress;
+				memset(&pdev_network->Ssid, 0,
+					sizeof(struct ndis_802_11_ssid));
+				memcpy(&pdev_network->Ssid,
+					&pmlmepriv->assoc_ssid,
+					sizeof(struct ndis_802_11_ssid));
+				r8712_update_registrypriv_dev_network(padapter);
+				r8712_generate_random_ibss(pibss);
+				if (r8712_createbss_cmd(padapter) != _SUCCESS)
+					return false;
+				pmlmepriv->to_join = false;
+			} else {
+				/* can't associate ; reset under-linking */
+				if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+					pmlmepriv->fw_state ^=
+							     _FW_UNDER_LINKING;
+				/* when set_ssid/set_bssid for do_join(), but
+				 * there are no desired bss in scanning queue
+				 * we try to issue sitesurvey first
+				 */
+				if (!pmlmepriv->sitesurveyctrl.traffic_busy)
+					r8712_sitesurvey_cmd(padapter,
+						       &pmlmepriv->assoc_ssid);
+			}
+		}
+	}
+	return true;
+}
+
+u8 r8712_set_802_11_bssid(struct _adapter *padapter, u8 *bssid)
+{
+	unsigned long irqL;
+	u8 status = true;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 &&
+	     bssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||
+	    (bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF &&
+	     bssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {
+		status = false;
+		return status;
+	}
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |
+	    _FW_UNDER_LINKING) == true) {
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_BSSID;
+	}
+	if (check_fwstate(pmlmepriv,
+	    _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {
+		if (!memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid,
+		    ETH_ALEN)) {
+			if (check_fwstate(pmlmepriv,
+			    WIFI_STATION_STATE) == false)
+				goto _Abort_Set_BSSID; /* driver is in
+						* WIFI_ADHOC_MASTER_STATE */
+		} else {
+			r8712_disassoc_cmd(padapter);
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				r8712_ind_disconnect(padapter);
+			r8712_free_assoc_resources(padapter);
+			if ((check_fwstate(pmlmepriv,
+			     WIFI_ADHOC_MASTER_STATE))) {
+				_clr_fwstate_(pmlmepriv,
+					      WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+	memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+	pmlmepriv->assoc_by_bssid = true;
+	status = do_join(padapter);
+	goto done;
+_Abort_Set_BSSID:
+done:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return status;
+}
+
+void r8712_set_802_11_ssid(struct _adapter *padapter,
+			   struct ndis_802_11_ssid *ssid)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+
+	if (padapter->hw_init_completed == false)
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_SSID;
+	}
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (!memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid,
+		    ssid->SsidLength))) {
+			if ((check_fwstate(pmlmepriv,
+			     WIFI_STATION_STATE) == false)) {
+				if (r8712_is_same_ibss(padapter,
+				     pnetwork) == false) {
+					/* if in WIFI_ADHOC_MASTER_STATE or
+					 *  WIFI_ADHOC_STATE, create bss or
+					 * rejoin again
+					 */
+					r8712_disassoc_cmd(padapter);
+					if (check_fwstate(pmlmepriv,
+					    _FW_LINKED) == true)
+						r8712_ind_disconnect(padapter);
+					r8712_free_assoc_resources(padapter);
+					if (check_fwstate(pmlmepriv,
+					     WIFI_ADHOC_MASTER_STATE)) {
+						_clr_fwstate_(pmlmepriv,
+						    WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv,
+							    WIFI_ADHOC_STATE);
+					}
+				} else
+					goto _Abort_Set_SSID; /* driver is in
+						  * WIFI_ADHOC_MASTER_STATE */
+			}
+		} else {
+			r8712_disassoc_cmd(padapter);
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				r8712_ind_disconnect(padapter);
+			r8712_free_assoc_resources(padapter);
+			if (check_fwstate(pmlmepriv,
+			    WIFI_ADHOC_MASTER_STATE) == true) {
+				_clr_fwstate_(pmlmepriv,
+					      WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+	if (padapter->securitypriv.btkip_countermeasure == true)
+		goto _Abort_Set_SSID;
+	if (validate_ssid(ssid) == false)
+		goto _Abort_Set_SSID;
+	memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));
+	pmlmepriv->assoc_by_bssid = false;
+	do_join(padapter);
+	goto done;
+_Abort_Set_SSID:
+done:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_set_802_11_infrastructure_mode(struct _adapter *padapter,
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	unsigned long irqL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state =
+				&(cur_network->network.InfrastructureMode);
+
+	if (*pold_state != networktype) {
+		spin_lock_irqsave(&pmlmepriv->lock, irqL);
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		    (*pold_state == Ndis802_11IBSS))
+			r8712_disassoc_cmd(padapter);
+		if (check_fwstate(pmlmepriv,
+		    _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
+			r8712_free_assoc_resources(padapter);
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		    (*pold_state == Ndis802_11Infrastructure) ||
+		    (*pold_state == Ndis802_11IBSS)) {
+			/* will clr Linked_state before this function,
+			 * we must have chked whether issue dis-assoc_cmd or
+			 * not */
+			r8712_ind_disconnect(padapter);
+		}
+		*pold_state = networktype;
+		/* clear WIFI_STATION_STATE; WIFI_AP_STATE; WIFI_ADHOC_STATE;
+		 * WIFI_ADHOC_MASTER_STATE */
+		_clr_fwstate_(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE |
+			      WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE |
+			      WIFI_AP_STATE);
+		switch (networktype) {
+		case Ndis802_11IBSS:
+			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			break;
+		case Ndis802_11Infrastructure:
+			set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+			break;
+		case Ndis802_11APMode:
+			set_fwstate(pmlmepriv, WIFI_AP_STATE);
+			break;
+		case Ndis802_11AutoUnknown:
+		case Ndis802_11InfrastructureMax:
+			break;
+		}
+		spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	}
+}
+
+u8 r8712_set_802_11_disassociate(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		r8712_disassoc_cmd(padapter);
+		r8712_ind_disconnect(padapter);
+		r8712_free_assoc_resources(padapter);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return true;
+}
+
+u8 r8712_set_802_11_bssid_list_scan(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = NULL;
+	unsigned long irqL;
+	u8 ret = true;
+
+	if (padapter == NULL)
+		return false;
+	pmlmepriv = &padapter->mlmepriv;
+	if (padapter->hw_init_completed == false)
+		return false;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == true)) {
+		/* Scan or linking is in progress, do nothing. */
+		ret = (u8)check_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	} else {
+		r8712_free_network_queue(padapter);
+		ret = r8712_sitesurvey_cmd(padapter, NULL);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return ret;
+}
+
+u8 r8712_set_802_11_authentication_mode(struct _adapter *padapter,
+				enum NDIS_802_11_AUTHENTICATION_MODE authmode)
+{
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u8 ret;
+
+	psecuritypriv->ndisauthtype = authmode;
+	if (psecuritypriv->ndisauthtype > 3)
+		psecuritypriv->AuthAlgrthm = 2; /* 802.1x */
+	if (r8712_set_auth(padapter, psecuritypriv) == _SUCCESS)
+		ret = true;
+	else
+		ret = false;
+	return ret;
+}
+
+u8 r8712_set_802_11_add_wep(struct _adapter *padapter,
+			    struct NDIS_802_11_WEP *wep)
+{
+	u8	bdefaultkey;
+	u8	btransmitkey;
+	sint	keyid;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	bdefaultkey = (wep->KeyIndex & 0x40000000) > 0 ? false : true;
+	btransmitkey = (wep->KeyIndex & 0x80000000) > 0 ? true : false;
+	keyid = wep->KeyIndex & 0x3fffffff;
+	if (keyid >= WEP_KEYS)
+		return false;
+	switch (wep->KeyLength) {
+	case 5:
+		psecuritypriv->PrivacyAlgrthm = _WEP40_;
+		break;
+	case 13:
+		psecuritypriv->PrivacyAlgrthm = _WEP104_;
+		break;
+	default:
+		psecuritypriv->PrivacyAlgrthm = _NO_PRIVACY_;
+		break;
+	}
+	memcpy(psecuritypriv->DefKey[keyid].skey, &wep->KeyMaterial,
+		wep->KeyLength);
+	psecuritypriv->DefKeylen[keyid] = wep->KeyLength;
+	psecuritypriv->PrivacyKeyIndex = keyid;
+	if (r8712_set_key(padapter, psecuritypriv, keyid) == _FAIL)
+		return false;
+	return _SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_ioctl_set.h b/drivers/staging/rtl8712/rtl871x_ioctl_set.h
new file mode 100644
index 0000000..2c94cd1
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_ioctl_set.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_SET_H
+#define __IOCTL_SET_H
+
+#include "drv_types.h"
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+struct BSSIDInfo {
+	unsigned char BSSID[6];
+	NDIS_802_11_PMKID_VALUE PMKID;
+};
+
+u8 r8712_set_802_11_authentication_mode(struct _adapter *pdapter,
+			enum NDIS_802_11_AUTHENTICATION_MODE authmode);
+
+u8 r8712_set_802_11_bssid(struct _adapter *padapter, u8 *bssid);
+
+u8 r8712_set_802_11_add_wep(struct _adapter *padapter,
+			    struct NDIS_802_11_WEP *wep);
+
+u8 r8712_set_802_11_disassociate(struct _adapter *padapter);
+
+u8 r8712_set_802_11_bssid_list_scan(struct _adapter *padapter);
+
+void r8712_set_802_11_infrastructure_mode(struct _adapter *padapter,
+			enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+
+void r8712_set_802_11_ssid(struct _adapter *padapter,
+			   struct ndis_802_11_ssid *ssid);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_led.h b/drivers/staging/rtl8712/rtl871x_led.h
new file mode 100644
index 0000000..1a90c7f
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_led.h
@@ -0,0 +1,124 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_LED_H
+#define __RTL8712_LED_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/*===========================================================================
+ * LED customization.
+ *===========================================================================
+ */
+enum LED_CTL_MODE {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11,
+	LED_CTL_STOP_WPS_FAIL = 12,
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13,
+};
+
+#define IS_LED_WPS_BLINKING(_LED_871x)	\
+	(((struct LED_871x *)_LED_871x)->CurrLedState == LED_BLINK_WPS \
+	|| ((struct LED_871x *)_LED_871x)->CurrLedState == LED_BLINK_WPS_STOP \
+	|| ((struct LED_871x *)_LED_871x)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_871x)	\
+		(((struct LED_871x *)_LED_871x)->bLedWPSBlinkInProgress \
+		|| ((struct LED_871x *)_LED_871x)->bLedScanBlinkInProgress)
+
+enum LED_PIN_871x {
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1
+};
+
+/*===========================================================================
+ * LED customization.
+ *===========================================================================
+ */
+enum LED_STRATEGY_871x {
+	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
+	SW_LED_MODE1, /* 2 LEDs, through LED0 and LED1. For ALPHA. */
+	SW_LED_MODE2, /* SW control 1 LED via GPIO0,
+		       * custom for AzWave 8187 minicard. */
+	SW_LED_MODE3, /* SW control 1 LED via GPIO0,
+		       *  customized for Sercomm Printer Server case.*/
+	SW_LED_MODE4, /*for Edimax / Belkin*/
+	SW_LED_MODE5, /*for Sercomm / Belkin*/
+	SW_LED_MODE6, /*for WNC / Corega*/
+	HW_LED, /* HW control 2 LEDs, LED0 and LED1 (there are 4 different
+		 * control modes, see MAC.CONFIG1 for details.)*/
+};
+
+struct LED_871x {
+	struct _adapter		*padapter;
+	enum LED_PIN_871x	LedPin;	/* Implementation for this SW led. */
+	u32			CurrLedState; /* Current LED state. */
+	u8			bLedOn; /* true if LED is ON */
+	u8			bSWLedCtrl;
+	u8			bLedBlinkInProgress; /*true if blinking */
+	u8			bLedNoLinkBlinkInProgress;
+	u8			bLedLinkBlinkInProgress;
+	u8			bLedStartToLinkBlinkInProgress;
+	u8			bLedScanBlinkInProgress;
+	u8			bLedWPSBlinkInProgress;
+	u32			BlinkTimes; /* No. times to toggle for blink.*/
+	u32			BlinkingLedState; /* Next state for blinking,
+						   * either LED_ON or OFF.*/
+
+	struct timer_list	BlinkTimer; /* Timer object for led blinking.*/
+	_workitem		BlinkWorkItem; /* Workitem used by BlinkTimer */
+};
+
+struct led_priv {
+	/* add for led control */
+	struct LED_871x		SwLed0;
+	struct LED_871x		SwLed1;
+	enum LED_STRATEGY_871x	LedStrategy;
+	u8			bRegUseLed;
+	void (*LedControlHandler)(struct _adapter *padapter,
+				  enum LED_CTL_MODE LedAction);
+	/* add for led control */
+};
+
+/*===========================================================================
+ * Interface to manipulate LED objects.
+ *===========================================================================*/
+void r8712_InitSwLeds(struct _adapter *padapter);
+void r8712_DeInitSwLeds(struct _adapter *padapter);
+void LedControl871x(struct _adapter *padapter, enum LED_CTL_MODE LedAction);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_mlme.c b/drivers/staging/rtl8712/rtl871x_mlme.c
new file mode 100644
index 0000000..ef8eb6c
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mlme.c
@@ -0,0 +1,1818 @@
+/******************************************************************************
+ * rtl871x_mlme.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_MLME_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "mlme_osdep.h"
+#include "sta_info.h"
+#include "wifi.h"
+#include "wlan_bssdef.h"
+
+static void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len);
+
+static sint _init_mlme_priv(struct _adapter *padapter)
+{
+	sint	i;
+	u8	*pbuf;
+	struct wlan_network	*pnetwork;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	pmlmepriv->nic_hdl = (u8 *)padapter;
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode =
+				 Ndis802_11AutoUnknown;
+	/* Maybe someday we should rename this variable to "active_mode"(Jeff)*/
+	pmlmepriv->passive_mode = 1; /* 1: active, 0: passive. */
+	spin_lock_init(&(pmlmepriv->lock));
+	spin_lock_init(&(pmlmepriv->lock2));
+	_init_queue(&(pmlmepriv->free_bss_pool));
+	_init_queue(&(pmlmepriv->scanned_queue));
+	set_scanned_network_val(pmlmepriv, 0);
+	memset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));
+	pbuf = _malloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+	if (pbuf == NULL)
+		return _FAIL;
+	pmlmepriv->free_bss_buf = pbuf;
+	pnetwork = (struct wlan_network *)pbuf;
+	for (i = 0; i < MAX_BSS_CNT; i++) {
+		_init_listhead(&(pnetwork->list));
+		list_insert_tail(&(pnetwork->list),
+				 &(pmlmepriv->free_bss_pool.queue));
+		pnetwork++;
+	}
+	pmlmepriv->sitesurveyctrl.last_rx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.last_tx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.traffic_busy = false;
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	r8712_init_mlme_timer(padapter);
+	return _SUCCESS;
+}
+
+struct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+	struct wlan_network *pnetwork;
+	struct  __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct list_head *plist = NULL;
+
+	if (_queue_empty(free_queue) == true)
+		return NULL;
+	spin_lock_irqsave(&free_queue->lock, irqL);
+	plist = get_next(&(free_queue->queue));
+	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
+	list_delete(&pnetwork->list);
+	pnetwork->last_scanned = jiffies;
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_irqrestore(&free_queue->lock, irqL);
+	return pnetwork;
+}
+
+static void _free_network(struct mlme_priv *pmlmepriv,
+			  struct wlan_network *pnetwork)
+{
+	u32 curr_time, delta_time;
+	unsigned long irqL;
+	struct  __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		return;
+	if (pnetwork->fixed == true)
+		return;
+	curr_time = jiffies;
+	delta_time = (curr_time - (u32)pnetwork->last_scanned) / HZ;
+	if (delta_time < SCANQUEUE_LIFETIME)
+		return;
+	spin_lock_irqsave(&free_queue->lock, irqL);
+	list_delete(&pnetwork->list);
+	list_insert_tail(&pnetwork->list, &free_queue->queue);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_irqrestore(&free_queue->lock, irqL);
+}
+
+static void _free_network_nolock(struct mlme_priv *pmlmepriv,
+			  struct wlan_network *pnetwork)
+{
+	struct  __queue *free_queue = &pmlmepriv->free_bss_pool;
+
+	if (pnetwork == NULL)
+		return;
+	if (pnetwork->fixed == true)
+		return;
+	list_delete(&pnetwork->list);
+	list_insert_tail(&pnetwork->list, get_list_head(free_queue));
+	pmlmepriv->num_of_scanned--;
+}
+
+
+/*
+	return the wlan_network with the matching addr
+	Shall be calle under atomic context...
+	to avoid possible racing condition...
+*/
+static struct wlan_network *_r8712_find_network(struct  __queue *scanned_queue,
+					 u8 *addr)
+{
+	unsigned long irqL;
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork = NULL;
+	u8 zero_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
+
+	if (!memcmp(zero_addr, addr, ETH_ALEN))
+		return NULL;
+	spin_lock_irqsave(&scanned_queue->lock, irqL);
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (plist != phead) {
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		if (!memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN))
+			break;
+	}
+	spin_unlock_irqrestore(&scanned_queue->lock, irqL);
+	return pnetwork;
+}
+
+static void _free_network_queue(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *scanned_queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_irqsave(&scanned_queue->lock, irqL);
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		_free_network(pmlmepriv, pnetwork);
+	}
+	spin_unlock_irqrestore(&scanned_queue->lock, irqL);
+}
+
+sint r8712_if_up(struct _adapter *padapter)
+{
+	sint res;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false)) {
+		res = false;
+	} else
+		res = true;
+	return res;
+}
+
+void r8712_generate_random_ibss(u8 *pibss)
+{
+	u32 curtime = jiffies;
+
+	pibss[0] = 0x02; /*in ad-hoc mode bit1 must set to 1 */
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (u8)(curtime & 0xff);
+	pibss[4] = (u8)((curtime>>8) & 0xff);
+	pibss[5] = (u8)((curtime>>16) & 0xff);
+}
+
+uint r8712_get_ndis_wlan_bssid_ex_sz(struct ndis_wlan_bssid_ex *bss)
+{
+	uint t_len;
+
+	t_len = sizeof(u32) + 6 * sizeof(unsigned long) + 2 +
+			sizeof(struct ndis_802_11_ssid) + sizeof(u32) +
+			sizeof(s32) +
+			sizeof(enum NDIS_802_11_NETWORK_TYPE) +
+			sizeof(struct NDIS_802_11_CONFIGURATION) +
+			sizeof(enum NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof(NDIS_802_11_RATES_EX) +
+			sizeof(u32) + bss->IELength;
+	return t_len;
+}
+
+u8 *r8712_get_capability_from_ie(u8 *ie)
+{
+	return ie + 8 + 2;
+}
+
+int r8712_init_mlme_priv(struct _adapter *padapter)
+{
+	return _init_mlme_priv(padapter);
+}
+
+void r8712_free_mlme_priv(struct mlme_priv *pmlmepriv)
+{
+	kfree(pmlmepriv->free_bss_buf);
+}
+
+static struct	wlan_network *alloc_network(struct mlme_priv *pmlmepriv)
+{
+	return _r8712_alloc_network(pmlmepriv);
+}
+
+static void free_network_nolock(struct mlme_priv *pmlmepriv,
+			 struct wlan_network *pnetwork)
+{
+	_free_network_nolock(pmlmepriv, pnetwork);
+}
+
+void r8712_free_network_queue(struct _adapter *dev)
+{
+	_free_network_queue(dev);
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context...
+	to avoid possible racing condition...
+*/
+static struct wlan_network *r8712_find_network(struct  __queue *scanned_queue,
+					       u8 *addr)
+{
+	struct wlan_network *pnetwork = _r8712_find_network(scanned_queue,
+							    addr);
+
+	return pnetwork;
+}
+
+int r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork)
+{
+	int ret = true;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&
+		    (pnetwork->network.Privacy == 0))
+		ret = false;
+	else if ((psecuritypriv->PrivacyAlgrthm == _NO_PRIVACY_) &&
+		 (pnetwork->network.Privacy == 1))
+		ret = false;
+	else
+		ret = true;
+	return ret;
+
+}
+
+static int is_same_network(struct ndis_wlan_bssid_ex *src,
+			   struct ndis_wlan_bssid_ex *dst)
+{
+	 u16 s_cap, d_cap;
+
+	memcpy((u8 *)&s_cap, r8712_get_capability_from_ie(src->IEs), 2);
+	memcpy((u8 *)&d_cap, r8712_get_capability_from_ie(dst->IEs), 2);
+	return (src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+			(src->Configuration.DSConfig ==
+			dst->Configuration.DSConfig) &&
+			((!memcmp(src->MacAddress, dst->MacAddress,
+			ETH_ALEN))) &&
+			((!memcmp(src->Ssid.Ssid,
+			  dst->Ssid.Ssid,
+			  src->Ssid.SsidLength))) &&
+			((s_cap & WLAN_CAPABILITY_IBSS) ==
+			(d_cap & WLAN_CAPABILITY_IBSS)) &&
+			((s_cap & WLAN_CAPABILITY_BSS) ==
+			(d_cap & WLAN_CAPABILITY_BSS));
+
+}
+
+struct	wlan_network *r8712_get_oldest_wlan_network(
+				struct  __queue *scanned_queue)
+{
+	struct list_head *plist, *phead;
+	struct	wlan_network	*pwlan = NULL;
+	struct	wlan_network	*oldest = NULL;
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) ==  true)
+			break;
+		pwlan = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (pwlan->fixed != true) {
+			if (oldest == NULL ||
+			    time_after((unsigned long)oldest->last_scanned,
+			    (unsigned long)pwlan->last_scanned))
+				oldest = pwlan;
+		}
+		plist = get_next(plist);
+	}
+	return oldest;
+}
+
+static void update_network(struct ndis_wlan_bssid_ex *dst,
+			   struct ndis_wlan_bssid_ex *src,
+			   struct _adapter *padapter)
+{
+	u32 last_evm = 0, tmpVal;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) &&
+	    is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {
+		if (padapter->recvpriv.signal_qual_data.total_num++ >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX) {
+			padapter->recvpriv.signal_qual_data.total_num =
+				   PHY_LINKQUALITY_SLID_WIN_MAX;
+			last_evm = padapter->recvpriv.signal_qual_data.
+				   elements[padapter->recvpriv.
+				   signal_qual_data.index];
+			padapter->recvpriv.signal_qual_data.total_val -=
+				 last_evm;
+		}
+		padapter->recvpriv.signal_qual_data.total_val += src->Rssi;
+
+		padapter->recvpriv.signal_qual_data.
+			  elements[padapter->recvpriv.signal_qual_data.
+			  index++] = src->Rssi;
+		if (padapter->recvpriv.signal_qual_data.index >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX)
+			padapter->recvpriv.signal_qual_data.index = 0;
+		/* <1> Showed on UI for user, in percentage. */
+		tmpVal = padapter->recvpriv.signal_qual_data.total_val /
+			 padapter->recvpriv.signal_qual_data.total_num;
+		padapter->recvpriv.signal = (u8)tmpVal;
+
+		src->Rssi = padapter->recvpriv.signal;
+	} else
+		src->Rssi = (src->Rssi + dst->Rssi) / 2;
+	memcpy((u8 *)dst, (u8 *)src, r8712_get_ndis_wlan_bssid_ex_sz(src));
+}
+
+static void update_current_network(struct _adapter *adapter,
+				   struct ndis_wlan_bssid_ex *pnetwork)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	if (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)) {
+		update_network(&(pmlmepriv->cur_network.network),
+			       pnetwork, adapter);
+		r8712_update_protection(adapter,
+			       (pmlmepriv->cur_network.network.IEs) +
+			       sizeof(struct NDIS_802_11_FIXED_IEs),
+			       pmlmepriv->cur_network.network.IELength);
+	}
+}
+
+/*
+Caller must hold pmlmepriv->lock first.
+*/
+static void update_scanned_network(struct _adapter *adapter,
+			    struct ndis_wlan_bssid_ex *target)
+{
+	struct list_head *plist, *phead;
+
+	u32 bssid_ex_sz;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *oldest = NULL;
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (is_same_network(&pnetwork->network, target))
+			break;
+		if ((oldest == ((struct wlan_network *)0)) ||
+		    time_after((unsigned long)oldest->last_scanned,
+				(unsigned long)pnetwork->last_scanned))
+			oldest = pnetwork;
+
+		plist = get_next(plist);
+	}
+
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (end_of_queue_search(phead, plist) == true) {
+		if (_queue_empty(&pmlmepriv->free_bss_pool) == true) {
+			/* If there are no more slots, expire the oldest */
+			pnetwork = oldest;
+			target->Rssi = (pnetwork->network.Rssi +
+					target->Rssi) / 2;
+			memcpy(&pnetwork->network, target,
+				r8712_get_ndis_wlan_bssid_ex_sz(target));
+			pnetwork->last_scanned = jiffies;
+		} else {
+			/* Otherwise just pull from the free list */
+			/* update scan_time */
+			pnetwork = alloc_network(pmlmepriv);
+			if (pnetwork == NULL)
+				return;
+			bssid_ex_sz = r8712_get_ndis_wlan_bssid_ex_sz(target);
+			target->Length = bssid_ex_sz;
+			memcpy(&pnetwork->network, target, bssid_ex_sz);
+			list_insert_tail(&pnetwork->list, &queue->queue);
+		}
+	} else {
+		/* we have an entry and we are going to update it. But
+		 * this entry may be already expired. In this case we
+		 * do the same as we found a new net and call the new_net
+		 * handler
+		 */
+		update_network(&pnetwork->network, target, adapter);
+		pnetwork->last_scanned = jiffies;
+	}
+}
+
+static void rtl8711_add_network(struct _adapter *adapter,
+			 struct ndis_wlan_bssid_ex *pnetwork)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &(((struct _adapter *)adapter)->mlmepriv);
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_irqsave(&queue->lock, irqL);
+	update_current_network(adapter, pnetwork);
+	update_scanned_network(adapter, pnetwork);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+}
+
+/*select the desired network based on the capability of the (i)bss.
+ * check items:		(1) security
+ *			(2) network_type
+ *			(3) WMM
+ *			(4) HT
+ *			(5) others
+ */
+static int is_desired_network(struct _adapter *adapter,
+				struct wlan_network *pnetwork)
+{
+	u8 wps_ie[512];
+	uint wps_ielen;
+	int bselected = true;
+	struct	security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if (psecuritypriv->wps_phase == true) {
+		if (r8712_get_wps_ie(pnetwork->network.IEs,
+		    pnetwork->network.IELength, wps_ie,
+		    &wps_ielen) == true)
+			return true;
+		else
+			return false;
+	}
+	if ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&
+		    (pnetwork->network.Privacy == 0))
+		bselected = false;
+	if (check_fwstate(&adapter->mlmepriv, WIFI_ADHOC_STATE) == true) {
+		if (pnetwork->network.InfrastructureMode !=
+			adapter->mlmepriv.cur_network.network.
+			InfrastructureMode)
+			bselected = false;
+	}
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void r8712_atimdone_event_callback(struct _adapter *adapter , u8 *pbuf)
+{
+}
+
+void r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long flags;
+	u32 len;
+	struct ndis_wlan_bssid_ex *pnetwork;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	pnetwork = (struct ndis_wlan_bssid_ex *)pbuf;
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow =
+		 le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	pnetwork->Configuration.BeaconPeriod =
+		 le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =
+		 le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length =
+		 le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode =
+		 le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+	len = r8712_get_ndis_wlan_bssid_ex_sz(pnetwork);
+	if (len > sizeof(struct wlan_bssid_ex))
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock2, flags);
+	/* update IBSS_network 's timestamp */
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+		if (!memcmp(&(pmlmepriv->cur_network.network.MacAddress),
+		    pnetwork->MacAddress, ETH_ALEN)) {
+			struct wlan_network *ibss_wlan = NULL;
+
+			memcpy(pmlmepriv->cur_network.network.IEs,
+				pnetwork->IEs, 8);
+			ibss_wlan = r8712_find_network(
+						&pmlmepriv->scanned_queue,
+						pnetwork->MacAddress);
+			if (!ibss_wlan) {
+				memcpy(ibss_wlan->network.IEs,
+					pnetwork->IEs, 8);
+				goto exit;
+			}
+		}
+	}
+	/* lock pmlmepriv->lock when you accessing network_q */
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == false) {
+		if (pnetwork->Ssid.Ssid[0] != 0)
+			rtl8711_add_network(adapter, pnetwork);
+		else {
+			pnetwork->Ssid.SsidLength = 8;
+			memcpy(pnetwork->Ssid.Ssid, "<hidden>", 8);
+			rtl8711_add_network(adapter, pnetwork);
+		}
+	}
+exit:
+	spin_unlock_irqrestore(&pmlmepriv->lock2, flags);
+}
+
+void r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		u8 timer_cancelled;
+
+		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	}
+
+	if (pmlmepriv->to_join == true) {
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == false) {
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+				if (r8712_select_and_join_from_scan(pmlmepriv)
+				    == _SUCCESS)
+					_set_timer(&pmlmepriv->assoc_timer,
+						   MAX_JOIN_TIMEOUT);
+				else {
+					struct wlan_bssid_ex *pdev_network =
+					  &(adapter->registrypriv.dev_network);
+					u8 *pibss =
+						 adapter->registrypriv.
+							dev_network.MacAddress;
+					pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;
+					memset(&pdev_network->Ssid, 0,
+						sizeof(struct
+						       ndis_802_11_ssid));
+					memcpy(&pdev_network->Ssid,
+						&pmlmepriv->assoc_ssid,
+						sizeof(struct
+							 ndis_802_11_ssid));
+					r8712_update_registrypriv_dev_network
+						(adapter);
+					r8712_generate_random_ibss(pibss);
+					pmlmepriv->fw_state =
+						 WIFI_ADHOC_MASTER_STATE;
+					pmlmepriv->to_join = false;
+				}
+			}
+		} else {
+			pmlmepriv->to_join = false;
+			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+			if (r8712_select_and_join_from_scan(pmlmepriv) ==
+			    _SUCCESS)
+				_set_timer(&pmlmepriv->assoc_timer,
+					   MAX_JOIN_TIMEOUT);
+			else
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+/*
+ *r8712_free_assoc_resources: the caller has to lock pmlmepriv->lock
+ */
+void r8712_free_assoc_resources(struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct wlan_network *pwlan = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	pwlan = r8712_find_network(&pmlmepriv->scanned_queue,
+				   tgt_network->network.MacAddress);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE)) {
+		struct sta_info *psta;
+
+		psta = r8712_get_stainfo(&adapter->stapriv,
+					 tgt_network->network.MacAddress);
+
+		spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+		r8712_free_stainfo(adapter,  psta);
+		spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+	}
+
+	if (check_fwstate(pmlmepriv,
+	    WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+		r8712_free_all_stainfo(adapter);
+	if (pwlan)
+		pwlan->fixed = false;
+
+	if (((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) &&
+	     (adapter->stapriv.asoc_sta_count == 1)))
+		free_network_nolock(pmlmepriv, pwlan);
+}
+
+/*
+*r8712_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void r8712_indicate_connect(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	pmlmepriv->to_join = false;
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);
+	r8712_os_indicate_connect(padapter);
+	if (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE)
+		_set_timer(&pmlmepriv->dhcp_timer, 60000);
+}
+
+
+/*
+*r8712_ind_disconnect: the caller has to lock pmlmepriv->lock
+*/
+void r8712_ind_disconnect(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+		padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+		r8712_os_indicate_disconnect(padapter);
+	}
+	if (padapter->pwrctrlpriv.pwr_mode !=
+	    padapter->registrypriv.power_mgnt) {
+		_cancel_timer_ex(&pmlmepriv->dhcp_timer);
+		r8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,
+				  padapter->registrypriv.smart_ps);
+	}
+}
+
+/*Notes:
+ *pnetwork : returns from r8712_joinbss_event_callback
+ *ptarget_wlan: found from scanned_queue
+ *if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if
+ *  "ptarget_sta" & "ptarget_wlan" exist.
+ *if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check
+ * if "ptarget_wlan" exist.
+ *if join_res > 0, update "cur_network->network" from
+ * "pnetwork->network" if (ptarget_wlan !=NULL).
+ */
+void r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL = 0, irqL2;
+	u8 timer_cancelled;
+	struct sta_info	*ptarget_sta = NULL, *pcur_sta = NULL;
+	struct sta_priv	*pstapriv = &adapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int		the_same_macaddr = false;
+	struct wlan_network *pnetwork;
+
+	if (sizeof(struct list_head) == 4 * sizeof(u32)) {
+		pnetwork = (struct wlan_network *)
+			_malloc(sizeof(struct wlan_network));
+		memcpy((u8 *)pnetwork+16, (u8 *)pbuf + 8,
+			sizeof(struct wlan_network) - 16);
+	} else
+		pnetwork = (struct wlan_network *)pbuf;
+
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->join_res = le32_to_cpu(pnetwork->join_res);
+	pnetwork->network_type = le32_to_cpu(pnetwork->network_type);
+	pnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);
+	pnetwork->network.Ssid.SsidLength =
+		 le32_to_cpu(pnetwork->network.Ssid.SsidLength);
+	pnetwork->network.Privacy = le32_to_cpu(pnetwork->network.Privacy);
+	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
+	pnetwork->network.NetworkTypeInUse =
+		 le32_to_cpu(pnetwork->network.NetworkTypeInUse);
+	pnetwork->network.Configuration.ATIMWindow =
+		 le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
+	pnetwork->network.Configuration.BeaconPeriod =
+		 le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
+	pnetwork->network.Configuration.DSConfig =
+		 le32_to_cpu(pnetwork->network.Configuration.DSConfig);
+	pnetwork->network.Configuration.FHConfig.DwellTime =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.
+			     DwellTime);
+	pnetwork->network.Configuration.FHConfig.HopPattern =
+		 le32_to_cpu(pnetwork->network.Configuration.
+			     FHConfig.HopPattern);
+	pnetwork->network.Configuration.FHConfig.HopSet =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
+	pnetwork->network.Configuration.FHConfig.Length =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);
+	pnetwork->network.Configuration.Length =
+		 le32_to_cpu(pnetwork->network.Configuration.Length);
+	pnetwork->network.InfrastructureMode =
+		 le32_to_cpu(pnetwork->network.InfrastructureMode);
+	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength);
+#endif
+
+	the_same_macaddr = !memcmp(pnetwork->network.MacAddress,
+				   cur_network->network.MacAddress, ETH_ALEN);
+	pnetwork->network.Length =
+		 r8712_get_ndis_wlan_bssid_ex_sz(&pnetwork->network);
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex))
+		goto ignore_joinbss_callback;
+	if (pnetwork->join_res > 0) {
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+			/*s1. find ptarget_wlan*/
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				if (the_same_macaddr == true)
+					ptarget_wlan =
+					    r8712_find_network(&pmlmepriv->
+					    scanned_queue,
+					    cur_network->network.MacAddress);
+				else {
+					pcur_wlan =
+					     r8712_find_network(&pmlmepriv->
+					     scanned_queue,
+					     cur_network->network.MacAddress);
+					pcur_wlan->fixed = false;
+
+					pcur_sta = r8712_get_stainfo(pstapriv,
+					     cur_network->network.MacAddress);
+					spin_lock_irqsave(&pstapriv->
+						sta_hash_lock, irqL2);
+					r8712_free_stainfo(adapter, pcur_sta);
+					spin_unlock_irqrestore(&(pstapriv->
+						sta_hash_lock), irqL2);
+
+					ptarget_wlan =
+						 r8712_find_network(&pmlmepriv->
+						 scanned_queue,
+						 pnetwork->network.
+						 MacAddress);
+					if (ptarget_wlan)
+						ptarget_wlan->fixed = true;
+				}
+			} else {
+				ptarget_wlan = r8712_find_network(&pmlmepriv->
+						scanned_queue,
+						pnetwork->network.MacAddress);
+				if (ptarget_wlan)
+					ptarget_wlan->fixed = true;
+			}
+
+			if (ptarget_wlan == NULL) {
+				if (check_fwstate(pmlmepriv,
+					_FW_UNDER_LINKING))
+					pmlmepriv->fw_state ^=
+						 _FW_UNDER_LINKING;
+				goto ignore_joinbss_callback;
+			}
+
+			/*s2. find ptarget_sta & update ptarget_sta*/
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+				if (the_same_macaddr == true) {
+					ptarget_sta =
+						 r8712_get_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+					if (ptarget_sta == NULL)
+						ptarget_sta =
+						 r8712_alloc_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+				} else
+					ptarget_sta =
+						 r8712_alloc_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+				if (ptarget_sta) /*update ptarget_sta*/ {
+					ptarget_sta->aid = pnetwork->join_res;
+					ptarget_sta->qos_option = 1;
+					ptarget_sta->mac_id = 5;
+					if (adapter->securitypriv.
+					    AuthAlgrthm == 2) {
+						adapter->securitypriv.
+							binstallGrpkey =
+							 false;
+						adapter->securitypriv.
+							busetkipkey =
+							 false;
+						adapter->securitypriv.
+							bgrpkey_handshake =
+							 false;
+						ptarget_sta->ieee8021x_blocked
+							 = true;
+						ptarget_sta->XPrivacy =
+							 adapter->securitypriv.
+							 PrivacyAlgrthm;
+						memset((u8 *)&ptarget_sta->
+							 x_UncstKey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 tkiprxmickey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 tkiptxmickey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 txpn, 0,
+							 sizeof(union pn48));
+						memset((u8 *)&ptarget_sta->
+							 rxpn, 0,
+							 sizeof(union pn48));
+					}
+				} else {
+					if (check_fwstate(pmlmepriv,
+					    _FW_UNDER_LINKING))
+						pmlmepriv->fw_state ^=
+							 _FW_UNDER_LINKING;
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			/*s3. update cur_network & indicate connect*/
+			memcpy(&cur_network->network, &pnetwork->network,
+				pnetwork->network.Length);
+			cur_network->aid = pnetwork->join_res;
+			/*update fw_state will clr _FW_UNDER_LINKING*/
+			switch (pnetwork->network.InfrastructureMode) {
+			case Ndis802_11Infrastructure:
+				pmlmepriv->fw_state = WIFI_STATION_STATE;
+				break;
+			case Ndis802_11IBSS:
+				pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+				break;
+			default:
+				pmlmepriv->fw_state = WIFI_NULL_STATE;
+				break;
+			}
+			r8712_update_protection(adapter,
+					  (cur_network->network.IEs) +
+					  sizeof(struct NDIS_802_11_FIXED_IEs),
+					  (cur_network->network.IELength));
+			/*TODO: update HT_Capability*/
+			update_ht_cap(adapter, cur_network->network.IEs,
+				      cur_network->network.IELength);
+			/*indicate connect*/
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+				== true)
+				r8712_indicate_connect(adapter);
+			_cancel_timer(&pmlmepriv->assoc_timer,
+				      &timer_cancelled);
+		} else
+			goto ignore_joinbss_callback;
+	} else {
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+			_set_timer(&pmlmepriv->assoc_timer, 1);
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+	}
+ignore_joinbss_callback:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	if (sizeof(struct list_head) == 4 * sizeof(u32))
+		kfree((u8 *)pnetwork);
+}
+
+void r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL;
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stassoc_event *pstassoc	= (struct stassoc_event *)pbuf;
+
+	/* to do: */
+	if (r8712_access_ctrl(&adapter->acl_list, pstassoc->macaddr) == false)
+		return;
+	psta = r8712_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta != NULL) {
+		/*the sta have been in sta_info_queue => do nothing
+		 *(between drv has received this event before and
+		 *  fw have not yet to set key to CAM_ENTRY) */
+		return;
+	}
+
+	psta = r8712_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta == NULL)
+		return;
+	/* to do : init sta_info variable */
+	psta->qos_option = 0;
+	psta->mac_id = le32_to_cpu((uint)pstassoc->cam_id);
+	/* psta->aid = (uint)pstassoc->cam_id; */
+
+	if (adapter->securitypriv.AuthAlgrthm == 2)
+		psta->XPrivacy = adapter->securitypriv.PrivacyAlgrthm;
+	psta->ieee8021x_blocked = false;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+		if (adapter->stapriv.asoc_sta_count == 2) {
+			/* a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			r8712_indicate_connect(adapter);
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL, irqL2;
+	struct sta_info *psta;
+	struct wlan_network *pwlan = NULL;
+	struct wlan_bssid_ex *pdev_network = NULL;
+	u8 *pibss = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct stadel_event *pstadel = (struct stadel_event *)pbuf;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL2);
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		r8712_ind_disconnect(adapter);
+		r8712_free_assoc_resources(adapter);
+	}
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE |
+	    WIFI_ADHOC_STATE)) {
+		psta = r8712_get_stainfo(&adapter->stapriv, pstadel->macaddr);
+		spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+		r8712_free_stainfo(adapter, psta);
+		spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+		if (adapter->stapriv.asoc_sta_count == 1) {
+			/*a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			pwlan = r8712_find_network(&pmlmepriv->scanned_queue,
+				tgt_network->network.MacAddress);
+			if (pwlan) {
+				pwlan->fixed = false;
+				free_network_nolock(pmlmepriv, pwlan);
+			}
+			/*re-create ibss*/
+			pdev_network = &(adapter->registrypriv.dev_network);
+			pibss = adapter->registrypriv.dev_network.MacAddress;
+			memcpy(pdev_network, &tgt_network->network,
+				r8712_get_ndis_wlan_bssid_ex_sz(&tgt_network->
+							network));
+			memset(&pdev_network->Ssid, 0,
+				sizeof(struct ndis_802_11_ssid));
+			memcpy(&pdev_network->Ssid,
+				&pmlmepriv->assoc_ssid,
+				sizeof(struct ndis_802_11_ssid));
+			r8712_update_registrypriv_dev_network(adapter);
+			r8712_generate_random_ibss(pibss);
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL2);
+}
+
+void r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	struct reportpwrstate_parm *preportpwrstate =
+			 (struct reportpwrstate_parm *)pbuf;
+
+	preportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);
+	r8712_cpwm_int_hdl(adapter, preportpwrstate);
+}
+
+/*	When the Netgear 3500 AP is with WPA2PSK-AES mode, it will send
+ *	 the ADDBA req frame with start seq control = 0 to wifi client after
+ *	 the WPA handshake and the seqence number of following data packet
+ *	will be 0. In this case, the Rx reorder sequence is not longer than 0
+ *	 and the WiFi client will drop the data with seq number 0.
+ *	So, the 8712 firmware has to inform driver with receiving the
+ *	 ADDBA-Req frame so that the driver can reset the
+ *	sequence value of Rx reorder contorl.
+ */
+void r8712_got_addbareq_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	struct	ADDBA_Req_Report_parm *pAddbareq_pram =
+			 (struct ADDBA_Req_Report_parm *)pbuf;
+	struct	sta_info *psta;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	recv_reorder_ctrl *precvreorder_ctrl = NULL;
+
+	printk(KERN_INFO "r8712u: [%s] mac = %pM, seq = %d, tid = %d\n",
+	     __func__, pAddbareq_pram->MacAddress,
+	    pAddbareq_pram->StartSeqNum, pAddbareq_pram->tid);
+	psta = r8712_get_stainfo(pstapriv, pAddbareq_pram->MacAddress);
+	if (psta) {
+		precvreorder_ctrl =
+			 &psta->recvreorder_ctrl[pAddbareq_pram->tid];
+		/* set the indicate_seq to 0xffff so that the rx reorder
+		 * can store any following data packet.
+		 */
+		precvreorder_ctrl->indicate_seq = 0xffff;
+	}
+}
+
+void r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	if (adapter->securitypriv.wps_hw_pbc_pressed == false)
+		adapter->securitypriv.wps_hw_pbc_pressed = true;
+}
+
+void _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sitesurvey_ctrl	*psitesurveyctrl = &pmlmepriv->sitesurveyctrl;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	u64 current_tx_pkts;
+	uint current_rx_pkts;
+
+	current_tx_pkts = (adapter->xmitpriv.tx_pkts) -
+			  (psitesurveyctrl->last_tx_pkts);
+	current_rx_pkts = (adapter->recvpriv.rx_pkts) -
+			  (psitesurveyctrl->last_rx_pkts);
+	psitesurveyctrl->last_tx_pkts = adapter->xmitpriv.tx_pkts;
+	psitesurveyctrl->last_rx_pkts = adapter->recvpriv.rx_pkts;
+	if ((current_tx_pkts > pregistrypriv->busy_thresh) ||
+	    (current_rx_pkts > pregistrypriv->busy_thresh))
+		psitesurveyctrl->traffic_busy = true;
+	else
+		psitesurveyctrl->traffic_busy = false;
+}
+
+void _r8712_join_timeout_handler(struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	pmlmepriv->to_join = false;
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		r8712_os_indicate_disconnect(adapter);
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+	}
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {
+		r8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,
+				  adapter->registrypriv.smart_ps);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_scan_timeout_handler (struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	pmlmepriv->to_join = false;	/* scan fail, so clear to_join flag */
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void _r8712_dhcp_timeout_handler (struct _adapter *adapter)
+{
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt)
+		r8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,
+			    adapter->registrypriv.smart_ps);
+}
+
+void _r8712_wdg_timeout_handler(struct _adapter *adapter)
+{
+	r8712_wdg_wk_cmd(adapter);
+}
+
+int r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv)
+{
+	struct list_head *phead;
+	unsigned char *dst_ssid, *src_ssid;
+	struct _adapter *adapter;
+	struct  __queue *queue = NULL;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *pnetwork_max_rssi = NULL;
+
+	adapter = (struct _adapter *)pmlmepriv->nic_hdl;
+	queue = &pmlmepriv->scanned_queue;
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
+			if ((pmlmepriv->assoc_by_rssi == true) &&
+			    (pnetwork_max_rssi != NULL)) {
+				pnetwork = pnetwork_max_rssi;
+				goto ask_for_joinbss;
+			}
+			return _FAIL;
+		}
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+					  struct wlan_network, list);
+		if (pnetwork == NULL)
+			return _FAIL;
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+		if (pmlmepriv->assoc_by_bssid == true) {
+			dst_ssid = pnetwork->network.MacAddress;
+			src_ssid = pmlmepriv->assoc_bssid;
+			if (!memcmp(dst_ssid, src_ssid, ETH_ALEN)) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+					if (is_same_network(&pmlmepriv->
+					    cur_network.network,
+					    &pnetwork->network)) {
+						_clr_fwstate_(pmlmepriv,
+							_FW_UNDER_LINKING);
+						/*r8712_indicate_connect again*/
+						r8712_indicate_connect(adapter);
+						return 2;
+					}
+					r8712_disassoc_cmd(adapter);
+					r8712_ind_disconnect(adapter);
+					r8712_free_assoc_resources(adapter);
+				}
+				goto ask_for_joinbss;
+			}
+		} else if (pmlmepriv->assoc_ssid.SsidLength == 0)
+			goto ask_for_joinbss;
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		src_ssid = pmlmepriv->assoc_ssid.Ssid;
+		if ((pnetwork->network.Ssid.SsidLength ==
+		    pmlmepriv->assoc_ssid.SsidLength) &&
+		    (!memcmp(dst_ssid, src_ssid,
+		     pmlmepriv->assoc_ssid.SsidLength))) {
+			if (pmlmepriv->assoc_by_rssi == true) {
+				/* if the ssid is the same, select the bss
+				 *  which has the max rssi*/
+				if (pnetwork_max_rssi) {
+					if (pnetwork->network.Rssi >
+					    pnetwork_max_rssi->network.Rssi)
+						pnetwork_max_rssi = pnetwork;
+				} else
+					pnetwork_max_rssi = pnetwork;
+			} else if (is_desired_network(adapter, pnetwork)) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+					r8712_disassoc_cmd(adapter);
+					r8712_free_assoc_resources(adapter);
+				}
+				goto ask_for_joinbss;
+			}
+		}
+	}
+	return _FAIL;
+ask_for_joinbss:
+	return r8712_joinbss_cmd(adapter, pnetwork);
+}
+
+sint r8712_set_auth(struct _adapter *adapter,
+		    struct security_priv *psecuritypriv)
+{
+	struct cmd_priv	*pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setauth_parm *psetauthparm;
+	sint ret = _SUCCESS;
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+
+	psetauthparm = (struct setauth_parm *)_malloc(
+			sizeof(struct setauth_parm));
+	if (psetauthparm == NULL) {
+		kfree((unsigned char *)pcmd);
+		return _FAIL;
+	}
+	memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode = (u8)psecuritypriv->AuthAlgrthm;
+	pcmd->cmdcode = _SetAuth_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;
+	pcmd->cmdsz = sizeof(struct setauth_parm);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	_init_listhead(&pcmd->list);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return ret;
+}
+
+sint r8712_set_key(struct _adapter *adapter,
+		   struct security_priv *psecuritypriv,
+	     sint keyid)
+{
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setkey_parm *psetkeyparm;
+	u8 keylen;
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	psetkeyparm = (struct setkey_parm *)_malloc(sizeof(struct setkey_parm));
+	if (psetkeyparm == NULL) {
+		kfree((unsigned char *)pcmd);
+		return _FAIL;
+	}
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+	if (psecuritypriv->AuthAlgrthm == 2) { /* 802.1X */
+		psetkeyparm->algorithm =
+			 (u8)psecuritypriv->XGrpPrivacy;
+	} else { /* WEP */
+		psetkeyparm->algorithm =
+			 (u8)psecuritypriv->PrivacyAlgrthm;
+	}
+	psetkeyparm->keyid = (u8)keyid;
+
+	switch (psetkeyparm->algorithm) {
+	case _WEP40_:
+		keylen = 5;
+		memcpy(psetkeyparm->key,
+			psecuritypriv->DefKey[keyid].skey, keylen);
+		break;
+	case _WEP104_:
+		keylen = 13;
+		memcpy(psetkeyparm->key,
+			psecuritypriv->DefKey[keyid].skey, keylen);
+		break;
+	case _TKIP_:
+		if (keyid < 1 || keyid > 2)
+			return _FAIL;
+		keylen = 16;
+		memcpy(psetkeyparm->key,
+			&psecuritypriv->XGrpKey[keyid - 1], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	case _AES_:
+		if (keyid < 1 || keyid > 2)
+			return _FAIL;
+		keylen = 16;
+		memcpy(psetkeyparm->key,
+			&psecuritypriv->XGrpKey[keyid - 1], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	default:
+		return _FAIL;
+	}
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	_init_listhead(&pcmd->list);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+/* adjust IEs for r8712_joinbss_cmd in WMM */
+int r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie, u8 *out_ie,
+		    uint in_len, uint initial_out_len)
+{
+	unsigned int ielength = 0;
+	unsigned int i, j;
+
+	i = 12; /* after the fixed IE */
+	while (i < in_len) {
+		ielength = initial_out_len;
+		if (in_ie[i] == 0xDD && in_ie[i + 2] == 0x00 &&
+		    in_ie[i + 3] == 0x50 && in_ie[i + 4] == 0xF2 &&
+		    in_ie[i + 5] == 0x02 && i + 5 < in_len) {
+			/*WMM element ID and OUI*/
+			for (j = i; j < i + 9; j++) {
+				out_ie[ielength] = in_ie[j];
+				ielength++;
+			}
+			out_ie[initial_out_len + 1] = 0x07;
+			out_ie[initial_out_len + 6] = 0x00;
+			out_ie[initial_out_len + 8] = 0x00;
+			break;
+		}
+		i += (in_ie[i + 1] + 2); /* to the next IE element */
+	}
+	return ielength;
+}
+
+/*
+ * Ported from 8185: IsInPreAuthKeyList().
+ *
+ * Search by BSSID,
+ * Return Value:
+ *	-1		:if there is no pre-auth key in the  table
+ *	>=0		:if there is pre-auth key, and   return the entry id
+ */
+static int SecIsInPMKIDList(struct _adapter *Adapter, u8 *bssid)
+{
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	int i = 0;
+
+	do {
+		if (psecuritypriv->PMKIDList[i].bUsed &&
+		   (!memcmp(psecuritypriv->PMKIDList[i].Bssid,
+			    bssid, ETH_ALEN)))
+			break;
+		else
+			i++;
+	} while (i < NUM_PMKID_CACHE);
+
+	if (i == NUM_PMKID_CACHE) {
+		i = -1; /* Could not find. */
+	} else {
+		; /* There is one Pre-Authentication Key for the
+		   * specific BSSID. */
+	}
+	return i;
+}
+
+sint r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,
+		     u8 *out_ie, uint in_len)
+{
+	u8 authmode = 0, securitytype, match;
+	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint ielength, cnt, remove_cnt;
+	int iEntry;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	uint ndisauthmode = psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+
+	if ((ndisauthmode == Ndis802_11AuthModeWPA) ||
+	    (ndisauthmode == Ndis802_11AuthModeWPAPSK)) {
+		authmode = _WPA_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x50;
+		uncst_oui[2] = 0xf2;
+	}
+	if ((ndisauthmode == Ndis802_11AuthModeWPA2) ||
+	    (ndisauthmode == Ndis802_11AuthModeWPA2PSK)) {
+		authmode = _WPA2_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x0f;
+		uncst_oui[2] = 0xac;
+	}
+	switch (ndissecuritytype) {
+	case Ndis802_11Encryption1Enabled:
+	case Ndis802_11Encryption1KeyAbsent:
+		securitytype = _WEP40_;
+		uncst_oui[3] = 0x1;
+		break;
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption2KeyAbsent:
+		securitytype = _TKIP_;
+		uncst_oui[3] = 0x2;
+		break;
+	case Ndis802_11Encryption3Enabled:
+	case Ndis802_11Encryption3KeyAbsent:
+		securitytype = _AES_;
+		uncst_oui[3] = 0x4;
+		break;
+	default:
+		securitytype = _NO_PRIVACY_;
+		break;
+	}
+	/*Search required WPA or WPA2 IE and copy to sec_ie[] */
+	cnt = 12;
+	match = false;
+	while (cnt < in_len) {
+		if (in_ie[cnt] == authmode) {
+			if ((authmode == _WPA_IE_ID_) &&
+			    (!memcmp(&in_ie[cnt+2], &wpa_oui[0], 4))) {
+				memcpy(&sec_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				match = true;
+				break;
+			}
+			if (authmode == _WPA2_IE_ID_) {
+				memcpy(&sec_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				match = true;
+				break;
+			}
+			if (((authmode == _WPA_IE_ID_) &&
+			     (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) ||
+			     (authmode == _WPA2_IE_ID_))
+				memcpy(&bkup_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+		}
+		cnt += in_ie[cnt+1] + 2; /*get next*/
+	}
+	/*restruct WPA IE or WPA2 IE in sec_ie[] */
+	if (match == true) {
+		if (sec_ie[0] == _WPA_IE_ID_) {
+			/* parsing SSN IE to select required encryption
+			 * algorithm, and set the bc/mc encryption algorithm */
+			while (true) {
+				/*check wpa_oui tag*/
+				if (memcmp(&sec_ie[2], &wpa_oui[0], 4)) {
+					match = false;
+					break;
+				}
+				if ((sec_ie[6] != 0x01) || (sec_ie[7] != 0x0)) {
+					/*IE Ver error*/
+					match = false;
+					break;
+				}
+				if (!memcmp(&sec_ie[8], &wpa_oui[0], 3)) {
+					/* get bc/mc encryption type (group
+					 * key type)*/
+					switch (sec_ie[11]) {
+					case 0x0: /*none*/
+						psecuritypriv->XGrpPrivacy =
+								_NO_PRIVACY_;
+						break;
+					case 0x1: /*WEP_40*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP40_;
+						break;
+					case 0x2: /*TKIP*/
+						psecuritypriv->XGrpPrivacy =
+								_TKIP_;
+						break;
+					case 0x3: /*AESCCMP*/
+					case 0x4:
+						psecuritypriv->XGrpPrivacy =
+								_AES_;
+						break;
+					case 0x5: /*WEP_104*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP104_;
+						break;
+					}
+				} else {
+					match = false;
+					break;
+				}
+				if (sec_ie[12] == 0x01) {
+					/*check the unicast encryption type*/
+					if (memcmp(&sec_ie[14],
+					    &uncst_oui[0], 4)) {
+						match = false;
+						break;
+
+					} /*else the uncst_oui is match*/
+				} else { /*mixed mode, unicast_enc_type > 1*/
+					/*select the uncst_oui and remove
+					 * the other uncst_oui*/
+					cnt = sec_ie[12];
+					remove_cnt = (cnt-1) * 4;
+					sec_ie[12] = 0x01;
+					memcpy(&sec_ie[14], &uncst_oui[0], 4);
+					/*remove the other unicast suit*/
+					memcpy(&sec_ie[18],
+						&sec_ie[18 + remove_cnt],
+						sec_ie[1] - 18 + 2 -
+						remove_cnt);
+					sec_ie[1] = sec_ie[1] - remove_cnt;
+				}
+				break;
+			}
+		}
+		if (authmode == _WPA2_IE_ID_) {
+			/* parsing RSN IE to select required encryption
+			 * algorithm, and set the bc/mc encryption algorithm */
+			while (true) {
+				if ((sec_ie[2] != 0x01) || (sec_ie[3] != 0x0)) {
+					/*IE Ver error*/
+					match = false;
+					break;
+				}
+				if (!memcmp(&sec_ie[4], &uncst_oui[0], 3)) {
+					/*get bc/mc encryption type*/
+					switch (sec_ie[7]) {
+					case 0x1: /*WEP_40*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP40_;
+						break;
+					case 0x2: /*TKIP*/
+						psecuritypriv->XGrpPrivacy =
+								_TKIP_;
+						break;
+					case 0x4: /*AESWRAP*/
+						psecuritypriv->XGrpPrivacy =
+								_AES_;
+						break;
+					case 0x5: /*WEP_104*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP104_;
+						break;
+					default: /*one*/
+						psecuritypriv->XGrpPrivacy =
+								_NO_PRIVACY_;
+						break;
+					}
+				} else {
+					match = false;
+					break;
+				}
+				if (sec_ie[8] == 0x01) {
+					/*check the unicast encryption type*/
+					if (memcmp(&sec_ie[10],
+						     &uncst_oui[0], 4)) {
+						match = false;
+						break;
+					} /*else the uncst_oui is match*/
+				} else { /*mixed mode, unicast_enc_type > 1*/
+					/*select the uncst_oui and remove the
+					 * other uncst_oui*/
+					cnt = sec_ie[8];
+					remove_cnt = (cnt-1)*4;
+					sec_ie[8] = 0x01;
+					memcpy(&sec_ie[10], &uncst_oui[0], 4);
+					/*remove the other unicast suit*/
+					memcpy(&sec_ie[14],
+						&sec_ie[14 + remove_cnt],
+						(sec_ie[1] - 14 + 2 -
+						remove_cnt));
+					sec_ie[1] = sec_ie[1]-remove_cnt;
+				}
+				break;
+			}
+		}
+	}
+	if ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {
+		/*copy fixed ie*/
+		memcpy(out_ie, in_ie, 12);
+		ielength = 12;
+		/*copy RSN or SSN*/
+		if (match == true) {
+			memcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1]+2);
+			ielength += sec_ie[1] + 2;
+			if (authmode == _WPA2_IE_ID_) {
+				/*the Pre-Authentication bit should be zero*/
+				out_ie[ielength - 1] = 0;
+				out_ie[ielength - 2] = 0;
+			}
+			r8712_report_sec_ie(adapter, authmode, sec_ie);
+		}
+	} else {
+		/*copy fixed ie only*/
+		memcpy(out_ie, in_ie, 12);
+		ielength = 12;
+		if (psecuritypriv->wps_phase == true) {
+			memcpy(out_ie+ielength, psecuritypriv->wps_ie,
+				psecuritypriv->wps_ie_len);
+			ielength += psecuritypriv->wps_ie_len;
+		}
+	}
+	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
+	if (iEntry < 0)
+		return ielength;
+	else {
+		if (authmode == _WPA2_IE_ID_) {
+			out_ie[ielength] = 1;
+			ielength++;
+			out_ie[ielength] = 0;	/*PMKID count = 0x0100*/
+			ielength++;
+			memcpy(&out_ie[ielength],
+				&psecuritypriv->PMKIDList[iEntry].PMKID, 16);
+			ielength += 16;
+			out_ie[13] += 18;/*PMKID length = 2+16*/
+		}
+	}
+	return ielength;
+}
+
+void r8712_init_registrypriv_dev_network(struct _adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct eeprom_priv *peepriv = &adapter->eeprompriv;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *myhwaddr = myid(peepriv);
+
+	memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
+	memcpy(&pdev_network->Ssid, &pregistrypriv->ssid,
+		sizeof(struct ndis_802_11_ssid));
+	pdev_network->Configuration.Length =
+			 sizeof(struct NDIS_802_11_CONFIGURATION);
+	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+}
+
+void r8712_update_registrypriv_dev_network(struct _adapter *adapter)
+{
+	int sz = 0;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	struct wlan_bssid_ex	*pdev_network = &pregistrypriv->dev_network;
+	struct security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
+
+	pdev_network->Privacy = cpu_to_le32(psecuritypriv->PrivacyAlgrthm
+					    > 0 ? 1 : 0) ; /* adhoc no 802.1x */
+	pdev_network->Rssi = 0;
+	switch (pregistrypriv->wireless_mode) {
+	case WIRELESS_11B:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11DS);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM24);
+		break;
+	case WIRELESS_11A:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM5);
+		break;
+	default:
+		/* TODO */
+		break;
+	}
+	pdev_network->Configuration.DSConfig = cpu_to_le32(
+					       pregistrypriv->channel);
+	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+		pdev_network->Configuration.ATIMWindow = cpu_to_le32(3);
+	pdev_network->InfrastructureMode = cpu_to_le32(
+				cur_network->network.InfrastructureMode);
+	/* 1. Supported rates
+	 * 2. IE
+	 */
+	sz = r8712_generate_ie(pregistrypriv);
+	pdev_network->IELength = sz;
+	pdev_network->Length = r8712_get_ndis_wlan_bssid_ex_sz(
+			      (struct ndis_wlan_bssid_ex *)pdev_network);
+}
+
+/*the function is at passive_level*/
+void r8712_joinbss_reset(struct _adapter *padapter)
+{
+	int i;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+
+	/* todo: if you want to do something io/reg/hw setting before join_bss,
+	 * please add code here */
+	phtpriv->ampdu_enable = false;/*reset to disabled*/
+	for (i = 0; i < 16; i++)
+		phtpriv->baddbareq_issued[i] = false;/*reset it*/
+	if (phtpriv->ht_option) {
+		/* validate  usb rx aggregation */
+		r8712_write8(padapter, 0x102500D9, 48);/*TH = 48 pages, 6k*/
+	} else {
+		/* invalidate  usb rx aggregation */
+		/* TH=1 => means that invalidate usb rx aggregation */
+		r8712_write8(padapter, 0x102500D9, 1);
+	}
+}
+
+/*the function is >= passive_level*/
+unsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,
+				     u8 *out_ie, uint in_len, uint *pout_len)
+{
+	u32 ielen, out_len;
+	unsigned char *p, *pframe;
+	struct ieee80211_ht_cap ht_capie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+
+	phtpriv->ht_option = 0;
+	p = r8712_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
+	if (p && (ielen > 0)) {
+		if (pqospriv->qos_option == 0) {
+			out_len = *pout_len;
+			pframe = r8712_set_ie(out_ie+out_len,
+					      _VENDOR_SPECIFIC_IE_,
+					      _WMM_IE_Length_,
+					       WMM_IE, pout_len);
+			pqospriv->qos_option = 1;
+		}
+		out_len = *pout_len;
+		memset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));
+		ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |
+				    IEEE80211_HT_CAP_SGI_20 |
+				    IEEE80211_HT_CAP_SGI_40 |
+				    IEEE80211_HT_CAP_TX_STBC |
+				    IEEE80211_HT_CAP_MAX_AMSDU |
+				    IEEE80211_HT_CAP_DSSSCCK40;
+		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR &
+				0x03) | (IEEE80211_HT_CAP_AMPDU_DENSITY & 0x00);
+		pframe = r8712_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
+				sizeof(struct ieee80211_ht_cap),
+				(unsigned char *)&ht_capie, pout_len);
+		phtpriv->ht_option = 1;
+	}
+	return phtpriv->ht_option;
+}
+
+/* the function is > passive_level (in critical_section) */
+static void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len)
+{
+	u8 *p, max_ampdu_sz;
+	int i, len;
+	struct sta_info *bmc_sta, *psta;
+	struct ieee80211_ht_cap *pht_capie;
+	struct ieee80211_ht_addt_info *pht_addtinfo;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct wlan_network *pcur_network = &(pmlmepriv->cur_network);
+
+	if (!phtpriv->ht_option)
+		return;
+	/* maybe needs check if ap supports rx ampdu. */
+	if ((phtpriv->ampdu_enable == false) &&
+	    (pregistrypriv->ampdu_enable == 1))
+		phtpriv->ampdu_enable = true;
+	/*check Max Rx A-MPDU Size*/
+	len = 0;
+	p = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),
+				_HT_CAPABILITY_IE_,
+				&len, ie_len -
+				sizeof(struct NDIS_802_11_FIXED_IEs));
+	if (p && len > 0) {
+		pht_capie = (struct ieee80211_ht_cap *)(p+2);
+		max_ampdu_sz = (pht_capie->ampdu_params_info &
+				IEEE80211_HT_CAP_AMPDU_FACTOR);
+		/* max_ampdu_sz (kbytes); */
+		max_ampdu_sz = 1 << (max_ampdu_sz+3);
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+	}
+	/* for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
+	 * if A-MPDU Rx is enabled, reseting rx_ordering_ctrl
+	 * wstart_b(indicate_seq) to default value=0xffff
+	 * todo: check if AP can send A-MPDU packets
+	 */
+	bmc_sta = r8712_get_bcmc_stainfo(padapter);
+	if (bmc_sta) {
+		for (i = 0; i < 16; i++) {
+			preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+		}
+	}
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 pcur_network->network.MacAddress);
+	if (psta) {
+		for (i = 0; i < 16 ; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+		}
+	}
+	len = 0;
+	p = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),
+		   _HT_ADD_INFO_IE_, &len,
+		   ie_len-sizeof(struct NDIS_802_11_FIXED_IEs));
+	if (p && len > 0)
+		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p + 2);
+}
+
+void r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+
+	if ((phtpriv->ht_option == 1) && (phtpriv->ampdu_enable == true)) {
+		if (phtpriv->baddbareq_issued[priority] == false) {
+			r8712_addbareq_cmd(padapter, (u8)priority);
+			phtpriv->baddbareq_issued[priority] = true;
+		}
+	}
+}
diff --git a/drivers/staging/rtl8712/rtl871x_mlme.h b/drivers/staging/rtl8712/rtl871x_mlme.h
new file mode 100644
index 0000000..71ca013
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mlme.h
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MLME_H_
+#define __RTL871X_MLME_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+
+#define	MAX_BSS_CNT	64
+#define   MAX_JOIN_TIMEOUT	6000
+
+#define		SCANNING_TIMEOUT	4500
+
+#define	SCANQUEUE_LIFETIME 20 /* unit:sec */
+
+#define		WIFI_NULL_STATE	0x00000000
+#define	WIFI_ASOC_STATE		0x00000001	/* Under Linked state...*/
+#define		WIFI_REASOC_STATE 0x00000002
+#define	WIFI_SLEEP_STATE	0x00000004
+#define	WIFI_STATION_STATE	0x00000008
+#define	WIFI_AP_STATE		0x00000010
+#define	WIFI_ADHOC_STATE	0x00000020
+#define   WIFI_ADHOC_MASTER_STATE 0x00000040
+#define   WIFI_UNDER_LINKING	0x00000080
+#define WIFI_SITE_MONITOR	0x00000800	/* to indicate the station
+						 * is under site surveying*/
+#define	WIFI_MP_STATE		0x00010000
+#define	WIFI_MP_CTX_BACKGROUND	0x00020000	/* in cont. tx background*/
+#define	WIFI_MP_CTX_ST		0x00040000	/* in cont. tx with
+						 *  single-tone*/
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in cont, tx
+					* background due to out of skb*/
+#define	WIFI_MP_CTX_CCK_HW	0x00100000	/* in continuous tx*/
+#define	WIFI_MP_CTX_CCK_CS	0x00200000	/* in cont, tx with carrier
+						 * suppression*/
+#define   WIFI_MP_LPBK_STATE	0x00400000
+
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED		WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+/*
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+*/
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	struct timer_list sitesurvey_ctrl_timer;
+};
+
+struct mlme_priv {
+
+	spinlock_t lock;
+	spinlock_t lock2;
+	sint	fw_state;	/*shall we protect this variable? */
+	u8 to_join; /*flag*/
+	u8 *nic_hdl;
+	struct list_head *pscanned;
+	struct  __queue free_bss_pool;
+	struct  __queue scanned_queue;
+	u8 *free_bss_buf;
+	unsigned long num_of_scanned;
+	u8 passive_mode; /*add for Android's SCAN-ACTIVE/SCAN-PASSIVE */
+	struct ndis_802_11_ssid	assoc_ssid;
+	u8 assoc_bssid[6];
+	struct wlan_network cur_network;
+	struct sitesurvey_ctrl sitesurveyctrl;
+	struct timer_list assoc_timer;
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+	struct timer_list scan_to_timer; /* driver handles scan_timeout.*/
+	struct timer_list dhcp_timer; /* set dhcp to if driver in ps mode.*/
+	struct qos_priv qospriv;
+	struct ht_priv	htpriv;
+	struct timer_list wdg_timer; /*watchdog periodic timer*/
+};
+
+static inline u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+static inline u8 check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if (pmlmepriv->fw_state & state)
+		return true;
+	return false;
+}
+
+static inline sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * TAKE CARE THAT BEFORE CALLING THIS FUNC, LOCK pmlmepriv->lock
+ */
+static inline void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+}
+
+static inline void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+static inline void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, state) == true)
+		pmlmepriv->fw_state ^= state;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void set_scanned_network_val(struct mlme_priv *pmlmepriv,
+					     sint val)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned = val;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_atimdone_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_free_network_queue(struct _adapter *adapter);
+int r8712_init_mlme_priv(struct _adapter *adapter);
+void r8712_free_mlme_priv(struct mlme_priv *pmlmepriv);
+sint r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv);
+sint r8712_set_key(struct _adapter *adapter,
+		   struct security_priv *psecuritypriv, sint keyid);
+sint r8712_set_auth(struct _adapter *adapter,
+		    struct security_priv *psecuritypriv);
+uint r8712_get_ndis_wlan_bssid_ex_sz(struct ndis_wlan_bssid_ex *bss);
+void r8712_generate_random_ibss(u8 *pibss);
+u8 *r8712_get_capability_from_ie(u8 *ie);
+struct wlan_network *r8712_get_oldest_wlan_network(
+				struct  __queue *scanned_queue);
+void r8712_free_assoc_resources(struct _adapter *adapter);
+void r8712_ind_disconnect(struct _adapter *adapter);
+void r8712_indicate_connect(struct _adapter *adapter);
+int r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,
+			  u8 *out_ie, uint in_len);
+int r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie,
+			  u8 *out_ie, uint in_len, uint initial_out_len);
+void r8712_init_registrypriv_dev_network(struct _adapter *adapter);
+void r8712_update_registrypriv_dev_network(struct _adapter *adapter);
+void _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter);
+void _r8712_join_timeout_handler(struct _adapter *adapter);
+void r8712_scan_timeout_handler(struct _adapter *adapter);
+void _r8712_dhcp_timeout_handler(struct _adapter *adapter);
+void _r8712_wdg_timeout_handler(struct _adapter *adapter);
+struct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv);
+sint r8712_if_up(struct _adapter *padapter);
+void r8712_joinbss_reset(struct _adapter *padapter);
+unsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,
+				     u8 *out_ie, uint in_len, uint *pout_len);
+void r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority);
+int r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork);
+
+#endif /*__RTL871X_MLME_H_*/
diff --git a/drivers/staging/rtl8712/rtl871x_mp.c b/drivers/staging/rtl8712/rtl871x_mp.c
new file mode 100644
index 0000000..5638d5e
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mp.c
@@ -0,0 +1,748 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#define _RTL871X_MP_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_mp_phy_regdef.h"
+#include "rtl8712_cmd.h"
+
+static void _init_mp_priv_(struct mp_priv *pmp_priv)
+{
+	pmp_priv->mode = _LOOPBOOK_MODE_;
+	pmp_priv->curr_ch = 1;
+	pmp_priv->curr_modem = MIXED_PHY;
+	pmp_priv->curr_rateidx = 0;
+	pmp_priv->curr_txpoweridx = 0x14;
+	pmp_priv->antenna_tx = ANTENNA_A;
+	pmp_priv->antenna_rx = ANTENNA_AB;
+	pmp_priv->check_mp_pkt = 0;
+	pmp_priv->tx_pktcount = 0;
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+}
+
+static int init_mp_priv(struct mp_priv *pmp_priv)
+{
+	int i, res;
+	struct mp_xmit_frame *pmp_xmitframe;
+
+	_init_mp_priv_(pmp_priv);
+	_init_queue(&pmp_priv->free_mp_xmitqueue);
+	pmp_priv->pallocated_mp_xmitframe_buf = NULL;
+	pmp_priv->pallocated_mp_xmitframe_buf = _malloc(NR_MP_XMITFRAME *
+					 sizeof(struct mp_xmit_frame) + 4);
+	if (pmp_priv->pallocated_mp_xmitframe_buf == NULL) {
+		res = _FAIL;
+		goto _exit_init_mp_priv;
+	}
+	pmp_priv->pmp_xmtframe_buf = pmp_priv->pallocated_mp_xmitframe_buf +
+			 4 -
+			 ((addr_t)(pmp_priv->pallocated_mp_xmitframe_buf) & 3);
+	pmp_xmitframe = (struct mp_xmit_frame *)pmp_priv->pmp_xmtframe_buf;
+	for (i = 0; i < NR_MP_XMITFRAME; i++) {
+		_init_listhead(&(pmp_xmitframe->list));
+		list_insert_tail(&(pmp_xmitframe->list),
+				 &(pmp_priv->free_mp_xmitqueue.queue));
+		pmp_xmitframe->pkt = NULL;
+		pmp_xmitframe->frame_tag = MP_FRAMETAG;
+		pmp_xmitframe->padapter = pmp_priv->papdater;
+		pmp_xmitframe++;
+	}
+	pmp_priv->free_mp_xmitframe_cnt = NR_MP_XMITFRAME;
+	res = _SUCCESS;
+_exit_init_mp_priv:
+	return res;
+}
+
+static int free_mp_priv(struct mp_priv *pmp_priv)
+{
+	int res = 0;
+	kfree(pmp_priv->pallocated_mp_xmitframe_buf);
+	return res;
+}
+
+void mp871xinit(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+
+	pmppriv->papdater = padapter;
+	init_mp_priv(pmppriv);
+}
+
+void mp871xdeinit(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+
+	free_mp_priv(pmppriv);
+}
+
+/*
+ * Special for bb and rf reg read/write
+ */
+static u32 fw_iocmd_read(struct _adapter *pAdapter, struct IOCMD_STRUCT iocmd)
+{
+	u32 cmd32 = 0, val32 = 0;
+	u8 iocmd_class	= iocmd.cmdclass;
+	u16 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	if (r8712_fw_cmd(pAdapter, cmd32))
+		r8712_fw_cmd_data(pAdapter, &val32, 1);
+	else
+		val32 = 0;
+	return val32;
+}
+
+static u8 fw_iocmd_write(struct _adapter *pAdapter,
+			 struct IOCMD_STRUCT iocmd, u32 value)
+{
+	u32 cmd32 = 0;
+	u8 iocmd_class	= iocmd.cmdclass;
+	u32 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	r8712_fw_cmd_data(pAdapter, &value, 0);
+	msleep(100);
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	return r8712_fw_cmd(pAdapter, cmd32);
+}
+
+/* offset : 0X800~0XFFF */
+u32 r8712_bb_reg_read(struct _adapter *pAdapter, u16 offset)
+{
+	u8 shift = offset & 0x0003;	/* 4 byte access */
+	u16 bb_addr = offset & 0x0FFC;	/* 4 byte access */
+	u32 bb_val = 0;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_READ_IDX;
+	bb_val = fw_iocmd_read(pAdapter, iocmd);
+	if (shift != 0) {
+		u32 bb_val2 = 0;
+		bb_val >>= (shift * 8);
+		iocmd.value += 4;
+		bb_val2 = fw_iocmd_read(pAdapter, iocmd);
+		bb_val2 <<= ((4 - shift) * 8);
+		bb_val |= bb_val2;
+	}
+	return bb_val;
+}
+
+/* offset : 0X800~0XFFF */
+u8 r8712_bb_reg_write(struct _adapter *pAdapter, u16 offset, u32 value)
+{
+	u8 shift = offset & 0x0003;	/* 4 byte access */
+	u16 bb_addr = offset & 0x0FFC;	/* 4 byte access */
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_WRITE_IDX;
+	if (shift != 0) {
+		u32 oldValue = 0;
+		u32 newValue = value;
+
+		oldValue = r8712_bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF >> ((4 - shift) * 8));
+		value = oldValue | (newValue << (shift * 8));
+		if (fw_iocmd_write(pAdapter, iocmd, value) == false)
+			return false;
+		iocmd.value += 4;
+		oldValue = r8712_bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF << (shift * 8));
+		value = oldValue | (newValue >> ((4 - shift) * 8));
+	}
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+/* offset : 0x00 ~ 0xFF */
+u32 r8712_rf_reg_read(struct _adapter *pAdapter, u8 path, u8 offset)
+{
+	u16 rf_addr = (path << 8) | offset;
+	u32 rf_data;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF ;
+	iocmd.value	= rf_addr ;
+	iocmd.index	= IOCMD_RF_READ_IDX;
+	rf_data = fw_iocmd_read(pAdapter, iocmd);
+	return rf_data;
+}
+
+u8 r8712_rf_reg_write(struct _adapter *pAdapter, u8 path, u8 offset, u32 value)
+{
+	u16 rf_addr = (path << 8) | offset;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= rf_addr;
+	iocmd.index	= IOCMD_RF_WRIT_IDX;
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1)
+			break;
+	return i;
+}
+
+static u32 get_bb_reg(struct _adapter *pAdapter, u16 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = r8712_bb_reg_read(pAdapter, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+	return new_value;
+}
+
+static u8 set_bb_reg(struct _adapter *pAdapter,
+		     u16 offset,
+		     u32 bitmask,
+		     u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = r8712_bb_reg_read(pAdapter, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+	} else
+		new_value = value;
+	return r8712_bb_reg_write(pAdapter, offset, new_value);
+}
+
+static u32 get_rf_reg(struct _adapter *pAdapter, u8 path, u8 offset,
+		      u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = r8712_rf_reg_read(pAdapter, path, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+	return new_value;
+}
+
+static u8 set_rf_reg(struct _adapter *pAdapter, u8 path, u8 offset, u32 bitmask,
+	      u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = r8712_rf_reg_read(pAdapter, path, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+	} else
+		new_value = value;
+	return r8712_rf_reg_write(pAdapter, path, offset, new_value);
+}
+
+/*
+ * SetChannel
+ * Description
+ *	Use H2C command to change channel,
+ *	not only modify rf register, but also other setting need to be done.
+ */
+void r8712_SetChannel(struct _adapter *pAdapter)
+{
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetChannel_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetChannel);
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return;
+	pparm = (struct SetChannel_parm *)_malloc(sizeof(struct
+					 SetChannel_parm));
+	if (pparm == NULL) {
+		kfree(pcmd);
+		return;
+	}
+	pparm->curr_ch = pAdapter->mppriv.curr_ch;
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+}
+
+static void SetCCKTxPower(struct _adapter *pAdapter, u8 TxPower)
+{
+	u16 TxAGC = 0;
+
+	TxAGC = TxPower;
+	set_bb_reg(pAdapter, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);
+}
+
+static void SetOFDMTxPower(struct _adapter *pAdapter, u8 TxPower)
+{
+	u32 TxAGC = 0;
+
+	TxAGC |= ((TxPower<<24)|(TxPower<<16)|(TxPower<<8)|TxPower);
+	set_bb_reg(pAdapter, rTxAGC_Rate18_06, bTxAGCRate18_06, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Rate54_24, bTxAGCRate54_24, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs03_Mcs00, bTxAGCRateMCS3_MCS0, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs07_Mcs04, bTxAGCRateMCS7_MCS4, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs11_Mcs08, bTxAGCRateMCS11_MCS8, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs15_Mcs12, bTxAGCRateMCS15_MCS12, TxAGC);
+}
+
+void r8712_SetTxPower(struct _adapter *pAdapter)
+{
+	u8 TxPower = pAdapter->mppriv.curr_txpoweridx;
+	SetCCKTxPower(pAdapter, TxPower);
+	SetOFDMTxPower(pAdapter, TxPower);
+}
+
+void r8712_SetTxAGCOffset(struct _adapter *pAdapter, u32 ulTxAGCOffset)
+{
+	u32 TxAGCOffset_B, TxAGCOffset_C, TxAGCOffset_D, tmpAGC;
+
+	TxAGCOffset_B = (ulTxAGCOffset&0x000000ff);
+	TxAGCOffset_C = ((ulTxAGCOffset&0x0000ff00)>>8);
+	TxAGCOffset_D = ((ulTxAGCOffset&0x00ff0000)>>16);
+	tmpAGC = (TxAGCOffset_D<<8 | TxAGCOffset_C<<4 | TxAGCOffset_B);
+	set_bb_reg(pAdapter, rFPGA0_TxGainStage,
+			(bXBTxAGC|bXCTxAGC|bXDTxAGC), tmpAGC);
+}
+
+void r8712_SetDataRate(struct _adapter *pAdapter)
+{
+	u8 path = RF_PATH_A;
+	u8 offset = RF_SYN_G2;
+	u32 value;
+
+	value = (pAdapter->mppriv.curr_rateidx < 4) ? 0x4440 : 0xF200;
+	r8712_rf_reg_write(pAdapter, path, offset, value);
+}
+
+void r8712_SwitchBandwidth(struct _adapter *pAdapter)
+{
+	/* 3 1.Set MAC register : BWOPMODE  bit2:1 20MhzBW */
+	u8 regBwOpMode = 0;
+	u8 Bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	regBwOpMode = r8712_read8(pAdapter, 0x10250203);
+	if (Bandwidth == HT_CHANNEL_WIDTH_20)
+		regBwOpMode |= BIT(2);
+	else
+		regBwOpMode &= ~(BIT(2));
+	r8712_write8(pAdapter, 0x10250203, regBwOpMode);
+	/* 3 2.Set PHY related register */
+	switch (Bandwidth) {
+	/* 20 MHz channel*/
+	case HT_CHANNEL_WIDTH_20:
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+		set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+		/* Use PHY_REG.txt default value. Do not need to change.
+		 * Correct the tx power for CCK rate in 40M.
+		 * It is set in Tx descriptor for 8192x series
+		 */
+		set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x58);
+		break;
+	/* 40 MHz channel*/
+	case HT_CHANNEL_WIDTH_40:
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+		set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+		/* Use PHY_REG.txt default value. Do not need to change.
+		 * Correct the tx power for CCK rate in 40M.
+		 * Set Control channel to upper or lower. These settings are
+		 * required only for 40MHz */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKSideBand,
+			   (HAL_PRIME_CHNL_OFFSET_DONT_CARE>>1));
+		set_bb_reg(pAdapter, rOFDM1_LSTF, 0xC00,
+			   HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x18);
+		break;
+	default:
+		break;
+	}
+
+	/* 3 3.Set RF related register */
+	switch (Bandwidth) {
+	case HT_CHANNEL_WIDTH_20:
+		set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW,
+			   BIT(10) | BIT(11), 0x01);
+		break;
+	case HT_CHANNEL_WIDTH_40:
+		set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW,
+			   BIT(10) | BIT(11), 0x00);
+		break;
+	default:
+		break;
+	}
+}
+/*------------------------------Define structure----------------------------*/
+struct R_ANTENNA_SELECT_OFDM {
+	u32	r_tx_antenna:4;
+	u32	r_ant_l:4;
+	u32	r_ant_non_ht:4;
+	u32	r_ant_ht1:4;
+	u32	r_ant_ht2:4;
+	u32	r_ant_ht_s1:4;
+	u32	r_ant_non_ht_s1:4;
+	u32	OFDM_TXSC:2;
+	u32	Reserved:2;
+};
+
+struct R_ANTENNA_SELECT_CCK {
+	u8	r_cckrx_enable_2:2;
+	u8	r_cckrx_enable:2;
+	u8	r_ccktx_enable:4;
+};
+
+void r8712_SwitchAntenna(struct _adapter *pAdapter)
+{
+	u32	ofdm_tx_en_val = 0, ofdm_tx_ant_sel_val = 0;
+	u8	ofdm_rx_ant_sel_val = 0;
+	u8	cck_ant_select_val = 0;
+	u32	cck_ant_sel_val = 0;
+	struct R_ANTENNA_SELECT_CCK *p_cck_txrx;
+
+	p_cck_txrx = (struct R_ANTENNA_SELECT_CCK *)&cck_ant_select_val;
+
+	switch (pAdapter->mppriv.antenna_tx) {
+	case ANTENNA_A:
+		/* From SD3 Willis suggestion !!! Set RF A=TX and B as standby*/
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 1);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x11111111;/* Power save */
+		p_cck_txrx->r_ccktx_enable = 0x8;
+		break;
+	case ANTENNA_B:
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 1);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x22222222;/* Power save */
+		p_cck_txrx->r_ccktx_enable = 0x4;
+		break;
+	case ANTENNA_AB:	/* For 8192S */
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x3321333; /* Disable Power save */
+		p_cck_txrx->r_ccktx_enable = 0xC;
+		break;
+	default:
+		break;
+	}
+	/*OFDM Tx*/
+	set_bb_reg(pAdapter, rFPGA1_TxInfo, 0xffffffff, ofdm_tx_ant_sel_val);
+	/*OFDM Tx*/
+	set_bb_reg(pAdapter, rFPGA0_TxInfo, 0x0000000f, ofdm_tx_en_val);
+	switch (pAdapter->mppriv.antenna_rx) {
+	case ANTENNA_A:
+		ofdm_rx_ant_sel_val = 0x1;	/* A */
+		p_cck_txrx->r_cckrx_enable = 0x0; /* default: A */
+		p_cck_txrx->r_cckrx_enable_2 = 0x0; /* option: A */
+		break;
+	case ANTENNA_B:
+		ofdm_rx_ant_sel_val = 0x2;	/* B */
+		p_cck_txrx->r_cckrx_enable = 0x1; /* default: B */
+		p_cck_txrx->r_cckrx_enable_2 = 0x1; /* option: B */
+		break;
+	case ANTENNA_AB:
+		ofdm_rx_ant_sel_val = 0x3; /* AB */
+		p_cck_txrx->r_cckrx_enable = 0x0; /* default:A */
+		p_cck_txrx->r_cckrx_enable_2 = 0x1; /* option:B */
+		break;
+	default:
+		break;
+	}
+	/*OFDM Rx*/
+	set_bb_reg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f,
+		   ofdm_rx_ant_sel_val);
+	/*OFDM Rx*/
+	set_bb_reg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f,
+		   ofdm_rx_ant_sel_val);
+
+	cck_ant_sel_val = cck_ant_select_val;
+	/*CCK TxRx*/
+	set_bb_reg(pAdapter, rCCK0_AFESetting, bMaskByte3, cck_ant_sel_val);
+}
+
+void r8712_SetCrystalCap(struct _adapter *pAdapter)
+{
+	set_bb_reg(pAdapter, rFPGA0_AnalogParameter1, bXtalCap,
+		   pAdapter->mppriv.curr_crystalcap);
+}
+
+static void TriggerRFThermalMeter(struct _adapter *pAdapter)
+{
+	/* 0x24: RF Reg[6:5] */
+	set_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+}
+
+static u32 ReadRFThermalMeter(struct _adapter *pAdapter)
+{
+	u32 ThermalValue = 0;
+
+	/* 0x24: RF Reg[4:0] */
+	ThermalValue = get_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, 0x1F);
+	return ThermalValue;
+}
+
+void r8712_GetThermalMeter(struct _adapter *pAdapter, u32 *value)
+{
+	TriggerRFThermalMeter(pAdapter);
+	msleep(1000);
+	*value = ReadRFThermalMeter(pAdapter);
+}
+
+void r8712_SetSingleCarrierTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) { /* Start Single Carrier. */
+		/* 1. if OFDM block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			/*set OFDM block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		/* 2. set CCK test mode off, set to CCK normal mode */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+		/* 3. turn on scramble setting */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/* 4. Turn On Single Carrier Tx and off the other test modes. */
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else { /* Stop Single Carrier.*/
+		/* Turn off all test modes.*/
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+			   bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		msleep(20);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}
+
+void r8712_SetSingleToneTx(struct _adapter *pAdapter, u8 bStart)
+{
+	u8 rfPath = pAdapter->mppriv.curr_rfpath;
+	switch (pAdapter->mppriv.antenna_tx) {
+	case ANTENNA_B:
+		rfPath = RF_PATH_B;
+		break;
+	case ANTENNA_A:
+	default:
+		rfPath = RF_PATH_A;
+		break;
+	}
+	if (bStart) { /* Start Single Tone.*/
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bDisable);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bDisable);
+		set_rf_reg(pAdapter, rfPath, RF_TX_G2, bRFRegOffsetMask,
+			   0xd4000);
+		msleep(100);
+		/* PAD all on.*/
+		set_rf_reg(pAdapter, rfPath, RF_AC, bRFRegOffsetMask, 0x2001f);
+		msleep(100);
+	} else { /* Stop Single Tone.*/
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		set_rf_reg(pAdapter, rfPath, RF_TX_G2, bRFRegOffsetMask,
+			   0x54000);
+		msleep(100);
+		/* PAD all on.*/
+		set_rf_reg(pAdapter, rfPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		msleep(100);
+	}
+}
+
+void r8712_SetCarrierSuppressionTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) { /* Start Carrier Suppression.*/
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			/* 1. if CCK block on? */
+			if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn)) {
+				/*set CCK block on*/
+				set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn,
+					   bEnable);
+			}
+			/* Turn Off All Test Mode */
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx,
+				   bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+				   bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone,
+				   bDisable);
+			/*transmit mode*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);
+			/*turn off scramble setting*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble,
+				   bDisable);
+			/*Set CCK Tx Test Rate*/
+			/*Set FTxRate to 1Mbps*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, 0x0);
+		}
+	} else { /* Stop Carrier Suppression. */
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			/*normal mode*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);
+			/*turn on scramble setting*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble,
+				   bEnable);
+			/*BB Reset*/
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+		}
+	}
+}
+
+static void SetCCKContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	u32 cckrate;
+
+	if (bStart) {
+		/* 1. if CCK block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn)) {
+			/*set CCK block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);
+		}
+		/* Turn Off All Test Mode */
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		/*Set CCK Tx Test Rate*/
+		cckrate  = pAdapter->mppriv.curr_rateidx;
+		set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, cckrate);
+		/*transmit mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);
+		/*turn on scramble setting*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+	} else {
+		/*normal mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);
+		/*turn on scramble setting*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+} /* mpt_StartCckContTx */
+
+static void SetOFDMContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) {
+		/* 1. if OFDM block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn)) {
+			/*set OFDM block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		}
+		/* 2. set CCK test mode off, set to CCK normal mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+		/* 3. turn on scramble setting */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/* 4. Turn On Continue Tx and turn off the other test modes.*/
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else {
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+			   bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		msleep(20);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+} /* mpt_StartOfdmContTx */
+
+void r8712_SetContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	/* ADC turn off [bit24-21] adc port0 ~ port1 */
+	if (bStart) {
+		r8712_bb_reg_write(pAdapter, rRx_Wait_CCCA,
+				   r8712_bb_reg_read(pAdapter,
+				   rRx_Wait_CCCA) & 0xFE1FFFFF);
+		msleep(100);
+	}
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+		SetCCKContinuousTx(pAdapter, bStart);
+	else if ((pAdapter->mppriv.curr_rateidx >= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx <= MPT_RATE_MCS15))
+		SetOFDMContinuousTx(pAdapter, bStart);
+	/* ADC turn on [bit24-21] adc port0 ~ port1 */
+	if (!bStart)
+		r8712_bb_reg_write(pAdapter, rRx_Wait_CCCA,
+				   r8712_bb_reg_read(pAdapter,
+				   rRx_Wait_CCCA) | 0x01E00000);
+}
+
+void r8712_ResetPhyRxPktCount(struct _adapter *pAdapter)
+{
+	u32 i, phyrx_set = 0;
+
+	for (i = OFDM_PPDU_BIT; i <= HT_MPDU_FAIL_BIT; i++) {
+		phyrx_set = 0;
+		phyrx_set |= (i << 28);		/*select*/
+		phyrx_set |= 0x08000000;	/* set counter to zero*/
+		r8712_write32(pAdapter, RXERR_RPT, phyrx_set);
+	}
+}
+
+static u32 GetPhyRxPktCounts(struct _adapter *pAdapter, u32 selbit)
+{
+	/*selection*/
+	u32 phyrx_set = 0, count = 0;
+	u32 SelectBit;
+
+	SelectBit = selbit << 28;
+	phyrx_set |= (SelectBit & 0xF0000000);
+	r8712_write32(pAdapter, RXERR_RPT, phyrx_set);
+	/*Read packet count*/
+	count = r8712_read32(pAdapter, RXERR_RPT) & RPTMaxCount;
+	return count;
+}
+
+u32 r8712_GetPhyRxPktReceived(struct _adapter *pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_OK_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_OK_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_OK_BIT);
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+u32 r8712_GetPhyRxPktCRC32Error(struct _adapter *pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_FAIL_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_FAIL_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_FAIL_BIT);
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_mp.h b/drivers/staging/rtl8712/rtl871x_mp.h
new file mode 100644
index 0000000..255dc94
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mp.h
@@ -0,0 +1,342 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MP_H_
+#define __RTL871X_MP_H_
+
+/*	00 - Success */
+/*	11 - Error */
+#define STATUS_SUCCESS			(0x00000000L)
+#define STATUS_PENDING			(0x00000103L)
+#define STATUS_UNSUCCESSFUL		(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES	(0xC000009AL)
+#define STATUS_NOT_SUPPORTED		(0xC00000BBL)
+#define NDIS_STATUS_SUCCESS		((uint)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING		((uint) STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED	((uint)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED		((uint)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED	((uint)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE		((uint)0x00010007L)
+#define NDIS_STATUS_FAILURE		((uint) STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES		((uint)\
+					STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING		((uint)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION		((uint)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS	((uint)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND	((uint)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED		((uint)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED	((uint)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL	((uint)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS	((uint)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND	((uint)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED	((uint)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS	((uint)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING	((uint)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED	((uint)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET	((uint)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL	((uint)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY	((uint)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN	((uint)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING	((uint)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH	((uint)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA	((uint)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT	((uint)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID		((uint)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED	((uint)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA	((uint)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE ((uint)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND	((uint)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE	((uint)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED	((uint)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT	((uint)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE		((uint)0xC001001FL)
+#define NDIS_STATUS_INVALID_SAP		((uint)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE		((uint)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS	((uint)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED	((uint)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER	((uint)0xC0010024L) /* cause 27*/
+#define NDIS_STATUS_VC_NOT_AVAILABLE	((uint)0xC0010025L) /* 35,45*/
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE ((uint)0xC0010026L) /* 37*/
+#define NDIS_STATUS_INCOMPATABLE_QOS	((uint)0xC0010027L)  /* 49*/
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED ((uint)0xC0010028L)  /*  93*/
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION ((uint)0xC0010029L)  /*  3*/
+#define MPT_NOOP			0
+#define MPT_READ_MAC_1BYTE		1
+#define MPT_READ_MAC_2BYTE		2
+#define MPT_READ_MAC_4BYTE		3
+#define MPT_WRITE_MAC_1BYTE		4
+#define MPT_WRITE_MAC_2BYTE		5
+#define MPT_WRITE_MAC_4BYTE		6
+#define MPT_READ_BB_CCK			7
+#define MPT_WRITE_BB_CCK		8
+#define MPT_READ_BB_OFDM		9
+#define MPT_WRITE_BB_OFDM		10
+#define MPT_READ_RF			11
+#define MPT_WRITE_RF			12
+#define MPT_READ_EEPROM_1BYTE		13
+#define MPT_WRITE_EEPROM_1BYTE		14
+#define MPT_READ_EEPROM_2BYTE		15
+#define MPT_WRITE_EEPROM_2BYTE		16
+#define MPT_SET_CSTHRESHOLD		21
+#define MPT_SET_INITGAIN		22
+#define MPT_SWITCH_BAND			23
+#define MPT_SWITCH_CHANNEL		24
+#define MPT_SET_DATARATE		25
+#define MPT_SWITCH_ANTENNA		26
+#define MPT_SET_TX_POWER		27
+#define MPT_SET_CONT_TX			28
+#define MPT_SET_SINGLE_CARRIER		29
+#define MPT_SET_CARRIER_SUPPRESSION	30
+#define MPT_GET_RATE_TABLE		31
+#define MPT_READ_TSSI			32
+#define MPT_GET_THERMAL_METER		33
+#define MAX_MP_XMITBUF_SZ	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	_pkt *pkt;
+	int frame_tag;
+	struct _adapter *padapter;
+	u8 *mem_addr;
+	u16 sz[8];
+	struct urb *pxmit_urb[8];
+	u8 bpending[8];
+	u8 last[8];
+};
+
+struct mp_wiparam {
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+struct mp_priv {
+	struct _adapter *papdater;
+	/*OID cmd handler*/
+	struct mp_wiparam workparam;
+	u8 act_in_progress;
+	/*Tx Section*/
+	u8 TID;
+	u32 tx_pktcount;
+	/*Rx Section*/
+	u32 rx_pktcount;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+	struct recv_stat rxstat;
+	/*RF/BB relative*/
+	u32 curr_ch;
+	u32 curr_rateidx;
+	u8 curr_bandwidth;
+	u8 curr_modem;
+	u8 curr_txpoweridx;
+	u32 curr_crystalcap;
+	u16 antenna_tx;
+	u16 antenna_rx;
+	u8 curr_rfpath;
+	u8 check_mp_pkt;
+	uint ForcedDataRate;
+	struct wlan_network mp_network;
+	unsigned char network_macaddr[6];
+	/*Testing Flag*/
+	u32 mode;/*0 for normal type packet,
+		  * 1 for loopback packet (16bytes TXCMD)*/
+	sint prev_fw_state;
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	struct  __queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+};
+
+struct IOCMD_STRUCT {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+};
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+/* ======================================================================= */
+
+#define LOWER	true
+#define RAISE	false
+#define IOCMD_CTRL_REG			0x10250370
+#define IOCMD_DATA_REG			0x10250374
+#define IOCMD_GET_THERMAL_METER		0xFD000028
+#define IOCMD_CLASS_BB_RF		0xF0
+#define IOCMD_BB_READ_IDX		0x00
+#define IOCMD_BB_WRITE_IDX		0x01
+#define IOCMD_RF_READ_IDX		0x02
+#define IOCMD_RF_WRIT_IDX		0x03
+#define BB_REG_BASE_ADDR		0x800
+#define RF_PATH_A	0
+#define RF_PATH_B	1
+#define RF_PATH_C	2
+#define RF_PATH_D	3
+#define MAX_RF_PATH_NUMS	2
+#define _2MAC_MODE_	0
+#define _LOOPBOOK_MODE_	1
+
+/* MP set force data rate base on the definition. */
+enum {
+	/* CCK rate. */
+	MPT_RATE_1M,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_LAST
+};
+
+/* Represent Channel Width in HT Capabilities */
+enum HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+};
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	/* 0x3F */
+
+enum POWER_MODE {
+	POWER_LOW = 0,
+	POWER_NORMAL
+};
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+#define RPTMaxCount 0x000FFFFF;
+
+/* parameter 1 : BitMask
+ *	bit 0  : OFDM PPDU
+ *	bit 1  : OFDM False Alarm
+ *	bit 2  : OFDM MPDU OK
+ *	bit 3  : OFDM MPDU Fail
+ *	bit 4  : CCK PPDU
+ *	bit 5  : CCK False Alarm
+ *	bit 6  : CCK MPDU ok
+ *	bit 7  : CCK MPDU fail
+ *	bit 8  : HT PPDU counter
+ *	bit 9  : HT false alarm
+ *	bit 10 : HT MPDU total
+ *	bit 11 : HT MPDU OK
+ *	bit 12 : HT MPDU fail
+ *	bit 15 : RX full drop
+ */
+enum RXPHY_BITMASK {
+	OFDM_PPDU_BIT = 0,
+	OFDM_MPDU_OK_BIT,
+	OFDM_MPDU_FAIL_BIT,
+	CCK_PPDU_BIT,
+	CCK_MPDU_OK_BIT,
+	CCK_MPDU_FAIL_BIT,
+	HT_PPDU_BIT,
+	HT_MPDU_BIT,
+	HT_MPDU_OK_BIT,
+	HT_MPDU_FAIL_BIT,
+};
+
+enum ENCRY_CTRL_STATE {
+	HW_CONTROL,		/*hw encryption& decryption*/
+	SW_CONTROL,		/*sw encryption& decryption*/
+	HW_ENCRY_SW_DECRY,	/*hw encryption & sw decryption*/
+	SW_ENCRY_HW_DECRY	/*sw encryption & hw decryption*/
+};
+
+/* Bandwidth Offset */
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+/*=======================================================================*/
+void mp871xinit(struct _adapter *padapter);
+void mp871xdeinit(struct _adapter *padapter);
+u32 r8712_bb_reg_read(struct _adapter *Adapter, u16 offset);
+u8 r8712_bb_reg_write(struct _adapter *Adapter, u16 offset, u32 value);
+u32 r8712_rf_reg_read(struct _adapter *Adapter, u8 path, u8 offset);
+u8 r8712_rf_reg_write(struct _adapter *Adapter, u8 path,
+		      u8 offset, u32 value);
+u32 r8712_get_bb_reg(struct _adapter *Adapter, u16 offset, u32 bitmask);
+u8 r8712_set_bb_reg(struct _adapter *Adapter, u16 offset,
+		    u32 bitmask, u32 value);
+u32 r8712_get_rf_reg(struct _adapter *Adapter, u8 path, u8 offset,
+		     u32 bitmask);
+u8 r8712_set_rf_reg(struct _adapter *Adapter, u8 path, u8 offset,
+		    u32 bitmask, u32 value);
+
+void r8712_SetChannel(struct _adapter *pAdapter);
+void r8712_SetTxPower(struct _adapter *pAdapte);
+void r8712_SetTxAGCOffset(struct _adapter *pAdapter, u32 ulTxAGCOffset);
+void r8712_SetDataRate(struct _adapter *pAdapter);
+void r8712_SwitchBandwidth(struct _adapter *pAdapter);
+void r8712_SwitchAntenna(struct _adapter *pAdapter);
+void r8712_SetCrystalCap(struct _adapter *pAdapter);
+void r8712_GetThermalMeter(struct _adapter *pAdapter, u32 *value);
+void r8712_SetContinuousTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetSingleCarrierTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetSingleToneTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetCarrierSuppressionTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_ResetPhyRxPktCount(struct _adapter *pAdapter);
+u32 r8712_GetPhyRxPktReceived(struct _adapter *pAdapter);
+u32 r8712_GetPhyRxPktCRC32Error(struct _adapter *pAdapter);
+
+#endif /*__RTL871X_MP_H_*/
+
diff --git a/drivers/staging/rtl8712/rtl871x_mp_ioctl.c b/drivers/staging/rtl8712/rtl871x_mp_ioctl.c
new file mode 100644
index 0000000..5eb461b
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mp_ioctl.c
@@ -0,0 +1,1473 @@
+/******************************************************************************
+ * rtl871x_mp_ioctl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mlme_osdep.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_mp_ioctl.h"
+
+uint oid_null_function(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		if (poid_par_priv->information_buf_len >= sizeof(u8))
+			Adapter->registrypriv.wireless_mode =
+					*(u8 *)poid_par_priv->information_buf;
+		else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (poid_par_priv->information_buf_len >= sizeof(u8)) {
+			*(u8 *)poid_par_priv->information_buf =
+					 Adapter->registrypriv.wireless_mode;
+			*poid_par_priv->bytes_rw =
+					poid_par_priv->information_buf_len;
+		} else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}
+	return status;
+}
+
+uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+	offset = (u16)(pbbreg->offset) & 0xFFF; /*0ffset :0x800~0xfff*/
+	if (offset < BB_REG_BASE_ADDR)
+		offset |= BB_REG_BASE_ADDR;
+	value = pbbreg->value;
+	r8712_bb_reg_write(Adapter, offset, value);
+	return status;
+}
+
+uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+	offset = (u16)(pbbreg->offset) & 0xFFF; /*0ffset :0x800~0xfff*/
+	if (offset < BB_REG_BASE_ADDR)
+		offset |= BB_REG_BASE_ADDR;
+	value = r8712_bb_reg_read(Adapter, offset);
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	offset = (u8)pbbreg->offset;
+	value = pbbreg->value;
+	r8712_rf_reg_write(Adapter, path, offset, value);
+	return status;
+}
+
+uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B) /* 1T2R  path_a /path_b */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	offset = (u8)pbbreg->offset;
+	value = r8712_rf_reg_read(Adapter, path, offset);
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+/*This function initializes the DUT to the MP test mode*/
+static int mp_start_test(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct ndis_wlan_bssid_ex bssid;
+	struct sta_info *psta;
+	unsigned long length;
+	unsigned long irqL;
+	int res = _SUCCESS;
+
+	/* 3 1. initialize a new struct ndis_wlan_bssid_ex */
+	memcpy(bssid.MacAddress, pmppriv->network_macaddr, ETH_ALEN);
+	bssid.Ssid.SsidLength = 16;
+	memcpy(bssid.Ssid.Ssid, (unsigned char *)"mp_pseudo_adhoc",
+		bssid.Ssid.SsidLength);
+	bssid.InfrastructureMode = Ndis802_11IBSS;
+	bssid.NetworkTypeInUse = Ndis802_11DS;
+	bssid.IELength = 0;
+	length = r8712_get_ndis_wlan_bssid_ex_sz(&bssid);
+	if (length % 4) {
+		/*round up to multiple of 4 bytes.*/
+		bssid.Length = ((length >> 2) + 1) << 2;
+	} else
+		bssid.Length = length;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		goto end_of_mp_start_test;
+	/*init mp_start_test status*/
+	pmppriv->prev_fw_state = get_fwstate(pmlmepriv);
+	pmlmepriv->fw_state = WIFI_MP_STATE;
+	if (pmppriv->mode == _LOOPBOOK_MODE_)
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); /*append txdesc*/
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	/* 3 2. create a new psta for mp driver */
+	/* clear psta in the cur_network, if any */
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 tgt_network->network.MacAddress);
+	if (psta)
+		r8712_free_stainfo(padapter, psta);
+	psta = r8712_alloc_stainfo(&padapter->stapriv, bssid.MacAddress);
+	if (psta == NULL) {
+		res = _FAIL;
+		goto end_of_mp_start_test;
+	}
+	/* 3 3. join psudo AdHoc */
+	tgt_network->join_res = 1;
+	tgt_network->aid = psta->aid = 1;
+	memcpy(&tgt_network->network, &bssid, length);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	r8712_os_indicate_connect(padapter);
+	/* Set to LINKED STATE for MP TRX Testing */
+	set_fwstate(pmlmepriv, _FW_LINKED);
+end_of_mp_start_test:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return res;
+}
+
+/*This function change the DUT from the MP test mode into normal mode */
+static int mp_stop_test(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct sta_info *psta;
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)
+		goto end_of_mp_stop_test;
+	/* 3 1. disconnect psudo AdHoc */
+	r8712_os_indicate_disconnect(padapter);
+	/* 3 2. clear psta used in mp test mode. */
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 tgt_network->network.MacAddress);
+	if (psta)
+		r8712_free_stainfo(padapter, psta);
+	/* 3 3. return to normal state (default:station mode) */
+	pmlmepriv->fw_state = pmppriv->prev_fw_state; /* WIFI_STATION_STATE;*/
+	/*flush the cur_network*/
+	memset(tgt_network, 0, sizeof(struct wlan_network));
+end_of_mp_stop_test:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return _SUCCESS;
+}
+
+int mp_start_joinbss(struct _adapter *padapter, struct ndis_802_11_ssid *pssid)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	unsigned char res = _SUCCESS;
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)
+		return _FAIL;
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
+		return _FAIL;
+	_clr_fwstate_(pmlmepriv, _FW_LINKED);
+	res = r8712_setassocsta_cmd(padapter, pmppriv->network_macaddr);
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	return res;
+}
+
+uint oid_rt_pro_set_data_rate_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 ratevalue;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	ratevalue = *((u32 *)poid_par_priv->information_buf);
+	if (ratevalue >= MPT_RATE_LAST)
+		return NDIS_STATUS_INVALID_DATA;
+	Adapter->mppriv.curr_rateidx = ratevalue;
+	r8712_SetDataRate(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 mode;
+	u8 val8;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return  NDIS_STATUS_NOT_ACCEPTED;
+	mode = *((u32 *)poid_par_priv->information_buf);
+	Adapter->mppriv.mode = mode;/* 1 for loopback*/
+	if (mp_start_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	r8712_write8(Adapter, MSR, 1); /* Link in ad hoc network, 0x1025004C */
+	r8712_write8(Adapter, RCR, 0); /* RCR : disable all pkt, 0x10250048 */
+	/* RCR disable Check BSSID, 0x1025004a */
+	r8712_write8(Adapter, RCR+2, 0x57);
+	/* disable RX filter map , mgt frames will put in RX FIFO 0 */
+	r8712_write16(Adapter, RXFLTMAP0, 0x0);
+	val8 = r8712_read8(Adapter, EE_9346CR);
+	if (!(val8 & _9356SEL)) { /*boot from EFUSE*/
+		r8712_efuse_reg_init(Adapter);
+		r8712_efuse_change_max_size(Adapter);
+		r8712_efuse_reg_uninit(Adapter);
+	}
+	return status;
+}
+
+uint oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (mp_stop_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv
+						   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		Channel;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	Channel = *((u32 *)poid_par_priv->information_buf);
+	if (Channel > 14)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_ch = Channel;
+	r8712_SetChannel(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 antenna;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	antenna = *((u32 *)poid_par_priv->information_buf);
+	Adapter->mppriv.antenna_tx = (u16)((antenna & 0xFFFF0000) >> 16);
+	Adapter->mppriv.antenna_rx = (u16)(antenna & 0x0000FFFF);
+	r8712_SwitchAntenna(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_set_tx_power_control_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 tx_pwr_idx;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	tx_pwr_idx = *((u32 *)poid_par_priv->information_buf);
+	if (tx_pwr_idx > MAX_TX_PWR_INDEX_N_MODE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_txpoweridx = (u8)tx_pwr_idx;
+	r8712_SetTxPower(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_query_tx_packet_sent_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.tx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_query_rx_packet_received_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.rx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_query_rx_packet_crc32_error_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.rx_crcerrpktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.tx_pktcount = 0;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv
+						    *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		Adapter->mppriv.rx_pktcount = 0;
+		Adapter->mppriv.rx_crcerrpktcount = 0;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv
+						 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	r8712_ResetPhyRxPktCount(Adapter);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv
+						  *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(u32 *)poid_par_priv->information_buf =
+					 r8712_GetPhyRxPktReceived(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv
+						     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(u32 *)poid_par_priv->information_buf =
+					 r8712_GetPhyRxPktCRC32Error(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_modulation_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_modem = *((u8 *)poid_par_priv->information_buf);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetContinuousTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv
+						 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetSingleCarrierTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv
+						      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetCarrierSuppressionTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetSingleToneTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct ndis_802_11_ssid *pssid;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed = (u32)sizeof(struct ndis_802_11_ssid);
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pssid = (struct ndis_802_11_ssid *)poid_par_priv->information_buf;
+	if (mp_start_joinbss(Adapter, pssid) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = sizeof(struct ndis_802_11_ssid);
+	return status;
+}
+
+uint oid_rt_pro_read_register_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mp_rw_reg *RegRWStruct;
+	u16		offset;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	RegRWStruct = (struct mp_rw_reg *)poid_par_priv->information_buf;
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF)) {
+		/*baseband register*/
+		/*0ffset :0x800~0xfff*/
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;
+		RegRWStruct->value = r8712_bb_reg_read(Adapter, offset);
+	} else {
+		switch (RegRWStruct->width) {
+		case 1:
+			RegRWStruct->value = r8712_read8(Adapter,
+						   RegRWStruct->offset);
+			break;
+		case 2:
+			RegRWStruct->value = r8712_read16(Adapter,
+						    RegRWStruct->offset);
+			break;
+		case 4:
+			RegRWStruct->value = r8712_read32(Adapter,
+						    RegRWStruct->offset);
+			break;
+		default:
+			status = NDIS_STATUS_NOT_ACCEPTED;
+			break;
+		}
+	}
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mp_rw_reg *RegRWStruct;
+	u16		offset;
+	u32		value;
+	u32 oldValue = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	RegRWStruct = (struct mp_rw_reg *)poid_par_priv->information_buf;
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF)) {
+		/*baseband register*/
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;
+		value = RegRWStruct->value;
+		switch (RegRWStruct->width) {
+		case 1:
+			oldValue = r8712_bb_reg_read(Adapter, offset);
+			oldValue &= 0xFFFFFF00;
+			value &= 0x000000FF;
+			value |= oldValue;
+			break;
+		case 2:
+			oldValue = r8712_bb_reg_read(Adapter, offset);
+			oldValue &= 0xFFFF0000;
+			value &= 0x0000FFFF;
+			value |= oldValue;
+			break;
+		}
+		r8712_bb_reg_write(Adapter, offset, value);
+	} else {
+		switch (RegRWStruct->width) {
+		case 1:
+			r8712_write8(Adapter, RegRWStruct->offset,
+			       (unsigned char)RegRWStruct->value);
+			break;
+		case 2:
+			r8712_write16(Adapter, RegRWStruct->offset,
+				(unsigned short)RegRWStruct->value);
+			break;
+		case 4:
+			r8712_write32(Adapter, RegRWStruct->offset,
+				(unsigned int)RegRWStruct->value);
+			break;
+		default:
+			status = NDIS_STATUS_NOT_ACCEPTED;
+			break;
+		}
+
+		if ((status == NDIS_STATUS_SUCCESS) &&
+		    (RegRWStruct->offset == HIMR) &&
+		    (RegRWStruct->width == 4))
+			Adapter->ImrContent = RegRWStruct->value;
+	}
+	return status;
+}
+
+uint oid_rt_pro_burst_read_register_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct burst_rw_reg *pBstRwReg;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pBstRwReg = (struct burst_rw_reg *)poid_par_priv->information_buf;
+	r8712_read_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len,
+		 pBstRwReg->Data);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_burst_write_register_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct burst_rw_reg *pBstRwReg;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pBstRwReg = (struct burst_rw_reg *)poid_par_priv->information_buf;
+	r8712_write_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len,
+		  pBstRwReg->Data);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct eeprom_rw_param *pEEPROM;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pEEPROM = (struct eeprom_rw_param *)poid_par_priv->information_buf;
+	pEEPROM->value = r8712_eeprom_read16(Adapter,
+					     (u16)(pEEPROM->offset >> 1));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_write16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct eeprom_rw_param *pEEPROM;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pEEPROM = (struct eeprom_rw_param *)poid_par_priv->information_buf;
+	r8712_eeprom_write16(Adapter, (u16)(pEEPROM->offset >> 1),
+			     pEEPROM->value);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct mp_wiparam *pwi_param;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct mp_wiparam))
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (Adapter->mppriv.workparam.bcompleted == false)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pwi_param = (struct mp_wiparam *)poid_par_priv->information_buf;
+	memcpy(pwi_param, &Adapter->mppriv.workparam,
+		sizeof(struct mp_wiparam));
+	Adapter->mppriv.act_in_progress = false;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(uint) * 2)
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (*(uint *)poid_par_priv->information_buf == 1)
+		Adapter->mppriv.rx_pktloss = 0;
+	*((uint *)poid_par_priv->information_buf+1) =
+					 Adapter->mppriv.rx_pktloss;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wr_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_setrfintfs_cmd(Adapter, *(unsigned char *)
+	    poid_par_priv->information_buf) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	memcpy(poid_par_priv->information_buf,
+		(unsigned char *)&Adapter->mppriv.rxstat,
+		sizeof(struct recv_stat));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv
+					    *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_setdatarate_cmd(Adapter,
+	    poid_par_priv->information_buf) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_get_thermal_meter_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == true)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	/*init workparam*/
+	Adapter->mppriv.act_in_progress = true;
+	Adapter->mppriv.workparam.bcompleted = false;
+	Adapter->mppriv.workparam.act_type = MPT_GET_THERMAL_METER;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+	r8712_GetThermalMeter(Adapter, &Adapter->mppriv.workparam.io_value);
+	Adapter->mppriv.workparam.bcompleted = true;
+	Adapter->mppriv.act_in_progress = false;
+	*(u32 *)poid_par_priv->information_buf =
+				 Adapter->mppriv.workparam.io_value;
+	*poid_par_priv->bytes_rw = sizeof(u32);
+	return status;
+}
+
+uint oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (!r8712_setptm_cmd(Adapter, *((u8 *)poid_par_priv->information_buf)))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 ratevalue;
+	u8 datarates[NumRates];
+	int i;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	ratevalue = *((u32 *)poid_par_priv->information_buf);
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i])
+			datarates[i] = mpdatarate[i];
+		else
+			datarates[i] = 0xff;
+	}
+	if (r8712_setbasicrate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+	*poid_par_priv->bytes_rw = 8;
+	memcpy(poid_par_priv->information_buf,
+		&(Adapter->pwrctrlpriv.pwr_mode), 8);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint pwr_mode, smart_ps;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = 0;
+	*poid_par_priv->bytes_needed = 8;
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pwr_mode = *(uint *)(poid_par_priv->information_buf);
+	smart_ps = *(uint *)((addr_t)poid_par_priv->information_buf + 4);
+	if (pwr_mode != Adapter->pwrctrlpriv.pwr_mode || smart_ps !=
+			Adapter->pwrctrlpriv.smart_ps)
+		r8712_set_ps_mode(Adapter, pwr_mode, smart_ps);
+	*poid_par_priv->bytes_rw = 8;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct setratable_parm *prate_table;
+	u8 res;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed  = sizeof(struct setratable_parm);
+	if (poid_par_priv->information_buf_len <
+	    sizeof(struct setratable_parm))
+		return NDIS_STATUS_INVALID_LENGTH;
+	prate_table = (struct setratable_parm *)poid_par_priv->information_buf;
+	res = r8712_setrttbl_cmd(Adapter, prate_table);
+	if (res == _FAIL)
+		status = NDIS_STATUS_FAILURE;
+	return status;
+}
+
+uint oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv
+					   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	enum ENCRY_CTRL_STATE encry_mode = 0;
+
+	*poid_par_priv->bytes_needed = sizeof(u8);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		encry_mode = *((u8 *)poid_par_priv->information_buf);
+		switch (encry_mode) {
+		case HW_CONTROL:
+			psecuritypriv->sw_decrypt = false;
+			psecuritypriv->sw_encrypt = false;
+			break;
+		case SW_CONTROL:
+			psecuritypriv->sw_decrypt = true;
+			psecuritypriv->sw_encrypt = true;
+			break;
+		case HW_ENCRY_SW_DECRY:
+			psecuritypriv->sw_decrypt = true;
+			psecuritypriv->sw_encrypt = false;
+			break;
+		case SW_ENCRY_HW_DECRY:
+			psecuritypriv->sw_decrypt = false;
+			psecuritypriv->sw_encrypt = true;
+			break;
+		}
+	} else {
+		if ((psecuritypriv->sw_encrypt == false) &&
+		    (psecuritypriv->sw_decrypt == false))
+			encry_mode = HW_CONTROL;
+		else if ((psecuritypriv->sw_encrypt == false) &&
+			 (psecuritypriv->sw_decrypt == true))
+			encry_mode = HW_ENCRY_SW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == true) &&
+			 (psecuritypriv->sw_decrypt == false))
+			encry_mode = SW_ENCRY_HW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == true) &&
+			 (psecuritypriv->sw_decrypt == true))
+			encry_mode = SW_CONTROL;
+		*(u8 *)poid_par_priv->information_buf =  encry_mode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	return NDIS_STATUS_SUCCESS;
+}
+/*----------------------------------------------------------------------*/
+uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info	*psta = NULL;
+	u8	*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	macaddr = (u8 *) poid_par_priv->information_buf;
+	psta = r8712_get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta == NULL) { /* the sta in sta_info_queue => do nothing*/
+		psta = r8712_alloc_stainfo(&Adapter->stapriv, macaddr);
+		if (psta == NULL)
+			status = NDIS_STATUS_FAILURE;
+	}
+	return status;
+}
+/*-------------------------------------------------------------------------*/
+uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	unsigned long			irqL;
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info		*psta = NULL;
+	u8			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (u8 *)poid_par_priv->information_buf;
+
+	psta = r8712_get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta != NULL) {
+		spin_lock_irqsave(&(Adapter->stapriv.sta_hash_lock), irqL);
+		r8712_free_stainfo(Adapter, psta);
+		spin_unlock_irqrestore(&(Adapter->stapriv.sta_hash_lock), irqL);
+	}
+
+	return status;
+}
+/*--------------------------------------------------------------------------*/
+static u32 mp_query_drv_var(struct _adapter *padapter, u8 offset, u32 var)
+{
+	return var;
+}
+
+uint oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct DR_VARIABLE_STRUCT *pdrv_var;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed = sizeof(struct DR_VARIABLE_STRUCT);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pdrv_var = (struct DR_VARIABLE_STRUCT *)poid_par_priv->information_buf;
+	pdrv_var->variable = mp_query_drv_var(Adapter, pdrv_var->offset,
+					      pdrv_var->variable);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+/*--------------------------------------------------------------------------*/
+uint oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+/*------------------------------------------------------------------------*/
+uint oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct EFUSE_ACCESS_STRUCT *pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len <
+	    sizeof(struct EFUSE_ACCESS_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pefuse = (struct EFUSE_ACCESS_STRUCT *)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+	memset(data, 0xFF, cnts);
+	if ((addr > 511) || (cnts < 1) || (cnts > 512) || (addr + cnts) >
+	     EFUSE_MAX_SIZE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_efuse_access(Adapter, true, addr, cnts, data) == false)
+		status = NDIS_STATUS_FAILURE;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+/*------------------------------------------------------------------------*/
+uint oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct EFUSE_ACCESS_STRUCT *pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pefuse = (struct EFUSE_ACCESS_STRUCT *)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	if ((addr > 511) || (cnts < 1) || (cnts > 512) ||
+	    (addr + cnts) > r8712_efuse_get_max_size(Adapter))
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_efuse_access(Adapter, false, addr, cnts, data) == false)
+		status = NDIS_STATUS_FAILURE;
+	return status;
+}
+/*----------------------------------------------------------------------*/
+uint oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct PGPKT_STRUCT	*ppgpkt;
+
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < sizeof(struct PGPKT_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+	ppgpkt = (struct PGPKT_STRUCT *)poid_par_priv->information_buf;
+	if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (r8712_efuse_pg_packet_read(Adapter, ppgpkt->offset,
+		    ppgpkt->data) == true)
+			*poid_par_priv->bytes_rw =
+				 poid_par_priv->information_buf_len;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		if (r8712_efuse_reg_init(Adapter) == true) {
+			if (r8712_efuse_pg_packet_write(Adapter, ppgpkt->offset,
+			    ppgpkt->word_en, ppgpkt->data) == true)
+				*poid_par_priv->bytes_rw =
+					 poid_par_priv->information_buf_len;
+			else
+				status = NDIS_STATUS_FAILURE;
+			r8712_efuse_reg_uninit(Adapter);
+		} else
+			status = NDIS_STATUS_FAILURE;
+	}
+	return status;
+}
+
+uint oid_rt_get_efuse_current_size_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(int))
+		return NDIS_STATUS_INVALID_LENGTH;
+	r8712_efuse_reg_init(Adapter);
+	*(int *)poid_par_priv->information_buf =
+				 r8712_efuse_get_current_size(Adapter);
+	r8712_efuse_reg_uninit(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(int *)poid_par_priv->information_buf =
+					 r8712_efuse_get_max_size(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+		status = oid_rt_pro_read_efuse_hdl(poid_par_priv);
+	else
+		status = oid_rt_pro_write_efuse_hdl(poid_par_priv);
+	return status;
+}
+
+uint oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u8		*data;
+
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < EFUSE_MAP_MAX_SIZE)
+		return NDIS_STATUS_INVALID_LENGTH;
+	data = (u8 *)poid_par_priv->information_buf;
+	if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (r8712_efuse_map_read(Adapter, 0, EFUSE_MAP_MAX_SIZE, data))
+			*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		/* SET_OID */
+		if (r8712_efuse_reg_init(Adapter) == true) {
+			if (r8712_efuse_map_write(Adapter, 0,
+			    EFUSE_MAP_MAX_SIZE, data))
+				*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+			else
+				status = NDIS_STATUS_FAILURE;
+			r8712_efuse_reg_uninit(Adapter);
+		} else {
+			status = NDIS_STATUS_FAILURE;
+		}
+	}
+	return status;
+}
+
+uint oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		bandwidth;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	bandwidth = *((u32 *)poid_par_priv->information_buf);/*4*/
+	if (bandwidth != HT_CHANNEL_WIDTH_20)
+		bandwidth = HT_CHANNEL_WIDTH_40;
+	Adapter->mppriv.curr_bandwidth = (u8)bandwidth;
+	r8712_SwitchBandwidth(Adapter);
+	return status;
+}
+
+uint oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		crystal_cap = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	crystal_cap = *((u32 *)poid_par_priv->information_buf);/*4*/
+	if (crystal_cap > 0xf)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_crystalcap = crystal_cap;
+	r8712_SetCrystalCap(Adapter);
+	return status;
+}
+
+uint oid_rt_set_rx_packet_type_hdl(struct oid_par_priv
+					   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u8		rx_pkt_type;
+	u32		rcr_val32;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	rx_pkt_type = *((u8 *)poid_par_priv->information_buf);/*4*/
+	rcr_val32 = r8712_read32(Adapter, RCR);/*RCR = 0x10250048*/
+	rcr_val32 &= ~(RCR_CBSSID | RCR_AB | RCR_AM | RCR_APM | RCR_AAP);
+	switch (rx_pkt_type) {
+	case RX_PKT_BROADCAST:
+		rcr_val32 |= (RCR_AB | RCR_AM | RCR_APM | RCR_AAP | RCR_ACRC32);
+		break;
+	case RX_PKT_DEST_ADDR:
+		rcr_val32 |= (RCR_AB | RCR_AM | RCR_APM | RCR_AAP | RCR_ACRC32);
+		break;
+	case RX_PKT_PHY_MATCH:
+		rcr_val32 |= (RCR_APM|RCR_ACRC32);
+		break;
+	default:
+		rcr_val32 &= ~(RCR_AAP |
+			       RCR_APM |
+			       RCR_AM |
+			       RCR_AB |
+			       RCR_ACRC32);
+		break;
+	}
+	if (rx_pkt_type == RX_PKT_DEST_ADDR)
+		Adapter->mppriv.check_mp_pkt = 1;
+	else
+		Adapter->mppriv.check_mp_pkt = 0;
+	r8712_write32(Adapter, RCR, rcr_val32);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32 txagc;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	txagc = *(u32 *)poid_par_priv->information_buf;
+	r8712_SetTxAGCOffset(Adapter, txagc);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	struct mp_priv		*pmppriv = &Adapter->mppriv;
+	u32			type;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	type = *(u32 *)poid_par_priv->information_buf;
+
+	if (_LOOPBOOK_MODE_ == type) {
+		pmppriv->mode = type;
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); /*append txdesc*/
+	} else if (_2MAC_MODE_ == type) {
+		pmppriv->mode = type;
+		_clr_fwstate_(pmlmepriv, WIFI_MP_LPBK_STATE);
+	} else
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+/*--------------------------------------------------------------------------*/
+/*Linux*/
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return _SUCCESS;
+}
+/*-------------------------------------------------------------------------*/
+uint oid_rt_set_power_down_hdl(struct oid_par_priv *poid_par_priv)
+{
+	u8	bpwrup;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bpwrup = *(u8 *)poid_par_priv->information_buf;
+	/*CALL  the power_down function*/
+	return NDIS_STATUS_SUCCESS;
+}
+
+/*-------------------------------------------------------------------------- */
+uint oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(int *)poid_par_priv->information_buf =
+		 Adapter->registrypriv.low_power ? POWER_LOW : POWER_NORMAL;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_mp_ioctl.h b/drivers/staging/rtl8712/rtl871x_mp_ioctl.h
new file mode 100644
index 0000000..850143d
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mp_ioctl.h
@@ -0,0 +1,480 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_MP_IOCTL_H
+#define _RTL871X_MP_IOCTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mp_custom_oid.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_rtl.h"
+#include "rtl8712_efuse.h"
+
+#define TESTFWCMDNUMBER			1000000
+#define TEST_H2CINT_WAIT_TIME		500
+#define TEST_C2HINT_WAIT_TIME		500
+#define HCI_TEST_SYSCFG_HWMASK		1
+#define _BUSCLK_40M			(4 << 2)
+
+struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+};
+
+struct mp_rw_reg {
+	uint offset;
+	uint width;
+	u32 value;
+};
+
+/* for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM */
+struct eeprom_rw_param {
+	uint offset;
+	u16 value;
+};
+
+struct EFUSE_ACCESS_STRUCT {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+};
+
+struct burst_rw_reg {
+	uint offset;
+	uint len;
+	u8 Data[256];
+};
+
+struct usb_vendor_req {
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;/*0:OUT, 1:IN */
+	u8	u8InData;
+};
+
+struct DR_VARIABLE_STRUCT {
+	u8 offset;
+	u32 variable;
+};
+
+int mp_start_joinbss(struct _adapter *padapter, struct ndis_802_11_ssid *pssid);
+
+/* oid_rtl_seg_87_11_00 */
+uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_register_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_burst_read_register_hdl(struct oid_par_priv*
+					       poid_par_priv);
+uint oid_rt_pro_burst_write_register_hdl(struct oid_par_priv*
+						poid_par_priv);
+uint oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_wr_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+uint  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_20 */
+uint oid_rt_pro_cfg_debug_message_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_data_rate_ex_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_basic_rate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_power_tracking_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_50 */
+uint oid_rt_pro_qry_pwrstate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_pwrstate_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_F0 */
+uint oid_rt_pro_h2c_set_rate_table_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_h2c_get_rate_table_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_80_00 */
+uint oid_rt_pro_set_data_rate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_channel_direct_call_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_antenna_bb_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_tx_power_control_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_80_20 */
+uint oid_rt_pro_query_tx_packet_sent_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_rx_packet_crc32_error_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_reset_tx_packet_sent_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_reset_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_modulation_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_continuous_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_single_carrier_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_carrier_suppression_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_single_tone_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_87 */
+uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_85 */
+uint oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_12_00 */
+uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_dr_variable_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_efuse_current_size_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_tx_agc_offset_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_pkt_test_mode_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_thermal_meter_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_reset_phy_rx_packet_count_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_phy_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_phy_rx_packet_crc32_error_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_power_down_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_power_mode_hdl(
+				struct oid_par_priv *poid_par_priv);
+#ifdef _RTL871X_MP_IOCTL_C_ /* CAUTION!!! */
+/* This ifdef _MUST_ be left in!! */
+static const struct oid_obj_priv oid_rtl_seg_81_80_00[] = {
+	{1, &oid_null_function},	/*0x00	OID_RT_PRO_RESET_DUT */
+	{1, &oid_rt_pro_set_data_rate_hdl},	/*0x01*/
+	{1, &oid_rt_pro_start_test_hdl},/*0x02*/
+	{1, &oid_rt_pro_stop_test_hdl},	/*0x03*/
+	{1, &oid_null_function},	/*0x04	OID_RT_PRO_SET_PREAMBLE*/
+	{1, &oid_null_function},	/*0x05	OID_RT_PRO_SET_SCRAMBLER*/
+	{1, &oid_null_function},	/*0x06	OID_RT_PRO_SET_FILTER_BB*/
+	{1, &oid_null_function},	/*0x07
+					 * OID_RT_PRO_SET_MANUAL_DIVERS_BB*/
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	/*0x08*/
+	{1, &oid_null_function},	/*0x09
+				* OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL*/
+	{1, &oid_null_function},	/*0x0A
+				* OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL*/
+	{1, &oid_rt_pro_set_continuous_tx_hdl},	/*0x0B
+				* OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL*/
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl}, /*0x0C
+				* OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS*/
+	{1, &oid_null_function},	/*0x0D
+				* OID_RT_PRO_SET_TX_ANTENNA_BB*/
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		/*0x0E*/
+	{1, &oid_null_function},	/*0x0F	OID_RT_PRO_SET_CR_SCRAMBLER*/
+	{1, &oid_null_function},	/*0x10	OID_RT_PRO_SET_CR_NEW_FILTER*/
+	{1, &oid_rt_pro_set_tx_power_control_hdl}, /*0x11
+				* OID_RT_PRO_SET_TX_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x12	OID_RT_PRO_SET_CR_TX_CONFIG*/
+	{1, &oid_null_function},	/*0x13
+					 * OID_RT_PRO_GET_TX_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x14
+					 * OID_RT_PRO_GET_CR_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x15	OID_RT_PRO_SET_CR_SETPOINT*/
+	{1, &oid_null_function},	/*0x16	OID_RT_PRO_SET_INTEGRATOR*/
+	{1, &oid_null_function},	/*0x17	OID_RT_PRO_SET_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x18	OID_RT_PRO_GET_INTEGRATOR*/
+	{1, &oid_null_function},	/*0x19	OID_RT_PRO_GET_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE*/
+	{1, &oid_null_function},	/*0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS*/
+	{1, &oid_null_function},	/*0x1C	OID_RT_PRO_READ_MAC_ADDRESS*/
+	{1, &oid_null_function},	/*0x1D	OID_RT_PRO_WRITE_CIS_DATA*/
+	{1, &oid_null_function},	/*0x1E	OID_RT_PRO_READ_CIS_DATA*/
+	{1, &oid_null_function}		/*0x1F	OID_RT_PRO_WRITE_POWER_CONTROL*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_20[] = {
+	{1, &oid_null_function},	/*0x20	OID_RT_PRO_READ_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x21	OID_RT_PRO_WRITE_EEPROM*/
+	{1, &oid_null_function},	/*0x22	OID_RT_PRO_READ_EEPROM*/
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	/*0x23*/
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	/*0x24*/
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	/*0x25*/
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	/*0x26*/
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},/*0x27*/
+	{1, &oid_null_function},	/*0x28
+					 *OID_RT_PRO_QUERY_CURRENT_ADDRESS*/
+	{1, &oid_null_function},	/*0x29
+					 *OID_RT_PRO_QUERY_PERMANENT_ADDRESS*/
+	{1, &oid_null_function},	/*0x2A
+				 *OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS*/
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},/*0x2B
+				 *OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX*/
+	{1, &oid_null_function},	/*0x2C	OID_RT_PRO_RECEIVE_PACKET*/
+	{1, &oid_null_function},	/*0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE*/
+	{1, &oid_null_function},	/*0x2E	OID_RT_PRO_READ_EEPROM_BYTE*/
+	{1, &oid_rt_pro_set_modulation_hdl}		/*0x2F*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_40[] = {
+	{1, &oid_null_function},			/*0x40*/
+	{1, &oid_null_function},			/*0x41*/
+	{1, &oid_null_function},			/*0x42*/
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	/*0x43*/
+	{1, &oid_null_function},			/*0x44*/
+	{1, &oid_null_function}				/*0x45*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_80[] = {
+	{1, &oid_null_function},	/*0x80	OID_RT_DRIVER_OPTION*/
+	{1, &oid_null_function},	/*0x81	OID_RT_RF_OFF*/
+	{1, &oid_null_function}		/*0x82	OID_RT_AUTH_STATUS*/
+
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_85[] = {
+	{1, &oid_rt_wireless_mode_hdl}	/*0x00	OID_RT_WIRELESS_MODE*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+
+enum MP_MODE {
+	MP_START_MODE,
+	MP_STOP_MODE,
+	MP_ERR_MODE
+};
+
+struct rwreg_param {
+	unsigned int offset;
+	unsigned int width;
+	unsigned int value;
+};
+
+struct bbreg_param {
+	unsigned int offset;
+	unsigned int phymask;
+	unsigned int value;
+};
+
+struct txpower_param {
+	unsigned int pwr_index;
+};
+
+struct datarate_param {
+	unsigned int rate_index;
+};
+
+struct rfintfs_parm {
+	unsigned int rfintfs;
+};
+
+struct mp_xmit_packet {
+	unsigned int len;
+};
+
+struct psmode_param {
+	unsigned int ps_mode;
+	unsigned int smart_ps;
+};
+
+struct mp_ioctl_handler {
+	unsigned int paramsize;
+	unsigned int (*handler)(struct oid_par_priv *poid_par_priv);
+	unsigned int oid;
+};
+
+struct mp_ioctl_param {
+	unsigned int subcode;
+	unsigned int len;
+	unsigned char data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START),			/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP),			/*1*/
+	GEN_MP_IOCTL_SUBCODE(READ_REG),			/*2*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),		/*4*/
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*6*/
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),		/*7*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),		/*9*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_RF_INTFS),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),	/*12*/
+	GEN_MP_IOCTL_SUBCODE(PS_STATE),			/*13*/
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),		/*14*/
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),		/*15*/
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),			/*16*/
+	GEN_MP_IOCTL_SUBCODE(READ_TSSI),		/*17*/
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),			/*18*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),		/*19*/
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),		/*20*/
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),	/*21*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*22*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),	/*23*/
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*24*/
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),	/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_POWER_MODE),		/*26*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE),			/*27*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*28*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),	/*29*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),	/*30*/
+	GEN_MP_IOCTL_SUBCODE(SC_TX),			/*31*/
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*32*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),			/*33*/
+	GEN_MP_IOCTL_SUBCODE(SET_ANTENNA),		/*34*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_ /* CAUTION!!! */
+/* This ifdef _MUST_ be left in!! */
+
+static struct mp_ioctl_handler mp_ioctl_hdl[] = {
+	{sizeof(u32), oid_rt_pro_start_test_hdl,
+			     OID_RT_PRO_START_TEST},/*0*/
+	{sizeof(u32), oid_rt_pro_stop_test_hdl,
+			     OID_RT_PRO_STOP_TEST},/*1*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_read_register_hdl,
+			     OID_RT_PRO_READ_REGISTER},/*2*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_write_register_hdl,
+			     OID_RT_PRO_WRITE_REGISTER},
+	{sizeof(u32),
+			     oid_rt_pro_set_channel_direct_call_hdl,
+			     OID_RT_PRO_SET_CHANNEL_DIRECT_CALL},
+	{sizeof(struct txpower_param),
+			     oid_rt_pro_set_tx_power_control_hdl,
+			     OID_RT_PRO_SET_TX_POWER_CONTROL},
+	{sizeof(u32),
+			     oid_rt_pro_set_data_rate_hdl,
+			     OID_RT_PRO_SET_DATA_RATE},
+	{sizeof(struct bb_reg_param),
+			     oid_rt_pro_read_bb_reg_hdl,
+			     OID_RT_PRO_READ_BB_REG},/*7*/
+	{sizeof(struct bb_reg_param),
+			     oid_rt_pro_write_bb_reg_hdl,
+			     OID_RT_PRO_WRITE_BB_REG},
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_read_rf_reg_hdl,
+			     OID_RT_PRO_RF_READ_REGISTRY},/*9*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_write_rf_reg_hdl,
+			     OID_RT_PRO_RF_WRITE_REGISTRY},
+	{sizeof(struct rfintfs_parm), NULL, 0},
+	{0, &mp_ioctl_xmit_packet_hdl, 0},/*12*/
+	{sizeof(struct psmode_param), NULL, 0},/*13*/
+	{sizeof(struct eeprom_rw_param), NULL, 0},/*14*/
+	{sizeof(struct eeprom_rw_param), NULL, 0},/*15*/
+	{sizeof(unsigned char), NULL, 0},/*16*/
+	{sizeof(u32), NULL, 0},/*17*/
+	{sizeof(u32), oid_rt_pro_set_continuous_tx_hdl,
+			     OID_RT_PRO_SET_CONTINUOUS_TX},/*18*/
+	{sizeof(u32), oid_rt_set_bandwidth_hdl,
+			     OID_RT_SET_BANDWIDTH},/*19*/
+	{sizeof(u32), oid_rt_set_rx_packet_type_hdl,
+			     OID_RT_SET_RX_PACKET_TYPE},/*20*/
+	{0, oid_rt_reset_phy_rx_packet_count_hdl,
+			     OID_RT_RESET_PHY_RX_PACKET_COUNT},/*21*/
+	{sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl,
+			     OID_RT_GET_PHY_RX_PACKET_RECEIVED},/*22*/
+	{sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl,
+			     OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR},/*23*/
+	{sizeof(unsigned char), oid_rt_set_power_down_hdl,
+			     OID_RT_SET_POWER_DOWN},/*24*/
+	{sizeof(u32), oid_rt_get_thermal_meter_hdl,
+			     OID_RT_PRO_GET_THERMAL_METER},/*25*/
+	{sizeof(u32), oid_rt_get_power_mode_hdl,
+			     OID_RT_GET_POWER_MODE},/*26*/
+	{sizeof(struct EFUSE_ACCESS_STRUCT),
+			     oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE},/*27*/
+	{EFUSE_MAP_MAX_SIZE, oid_rt_pro_efuse_map_hdl,
+			     OID_RT_PRO_EFUSE_MAP},/*28*/
+	{sizeof(u32), oid_rt_get_efuse_max_size_hdl,
+			     OID_RT_GET_EFUSE_MAX_SIZE},/*29*/
+	{sizeof(u32), oid_rt_get_efuse_current_size_hdl,
+			     OID_RT_GET_EFUSE_CURRENT_SIZE},/*30*/
+	{sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl,
+			     OID_RT_PRO_SET_SINGLE_CARRIER_TX},/*31*/
+	{sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl,
+			     OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX},/*32*/
+	{sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl,
+			     OID_RT_PRO_SET_SINGLE_TONE_TX},/*33*/
+	{sizeof(u32), oid_rt_pro_set_antenna_bb_hdl,
+			     OID_RT_PRO_SET_ANTENNA_BB},/*34*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h b/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
new file mode 100644
index 0000000..23532a7
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
@@ -0,0 +1,1025 @@
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *	Data			Who		Remark
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __RTL871X_MP_PHY_REGDEF_H
+#define __RTL871X_MP_PHY_REGDEF_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*============================================================
+ *       8192S Regsiter offset definition
+ *============================================================
+ *
+ *
+ * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+ * 3. RF register 0x00-2E
+ * 4. Bit Mask for BB/RF register
+ * 5. Other definition for BB/RF R/W
+ *
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 1. Page1(0x100)
+ */
+#define	rPMAC_Reset			0x100
+#define	rPMAC_TxStart			0x104
+#define	rPMAC_TxLegacySIG		0x108
+#define	rPMAC_TxHTSIG1			0x10c
+#define	rPMAC_TxHTSIG2			0x110
+#define	rPMAC_PHYDebug			0x114
+#define	rPMAC_TxPacketNum		0x118
+#define	rPMAC_TxIdle			0x11c
+#define	rPMAC_TxMACHeader0		0x120
+#define	rPMAC_TxMACHeader1		0x124
+#define	rPMAC_TxMACHeader2		0x128
+#define	rPMAC_TxMACHeader3		0x12c
+#define	rPMAC_TxMACHeader4		0x130
+#define	rPMAC_TxMACHeader5		0x134
+#define	rPMAC_TxDataType		0x138
+#define	rPMAC_TxRandomSeed		0x13c
+#define	rPMAC_CCKPLCPPreamble		0x140
+#define	rPMAC_CCKPLCPHeader		0x144
+#define	rPMAC_CCKCRC16			0x148
+#define	rPMAC_OFDMRxCRC32OK		0x170
+#define	rPMAC_OFDMRxCRC32Er		0x174
+#define	rPMAC_OFDMRxParityEr		0x178
+#define	rPMAC_OFDMRxCRC8Er		0x17c
+#define	rPMAC_CCKCRxRC16Er		0x180
+#define	rPMAC_CCKCRxRC32Er		0x184
+#define	rPMAC_CCKCRxRC32OK		0x188
+#define	rPMAC_TxStatus			0x18c
+
+/*
+ * 2. Page2(0x200)
+ *
+ * The following two definition are only used for USB interface.
+ *#define RF_BB_CMD_ADDR	0x02c0	// RF/BB read/write command address.
+ *#define RF_BB_CMD_DATA	0x02c4	// RF/BB read/write command data.
+ *
+ *
+ * 3. Page8(0x800)
+ */
+#define	rFPGA0_RFMOD			0x800	/*RF mode & CCK TxSC RF
+						 * BW Setting?? */
+#define	rFPGA0_TxInfo			0x804	/* Status report?? */
+#define	rFPGA0_PSDFunction		0x808
+#define	rFPGA0_TxGainStage		0x80c	/* Set TX PWR init gain? */
+#define	rFPGA0_RFTiming1		0x810	/* Useless now */
+#define	rFPGA0_RFTiming2		0x814
+#define	rFPGA0_XA_HSSIParameter1	0x820	/* RF 3 wire register */
+#define	rFPGA0_XA_HSSIParameter2	0x824
+#define	rFPGA0_XB_HSSIParameter1	0x828
+#define	rFPGA0_XB_HSSIParameter2	0x82c
+#define	rFPGA0_XC_HSSIParameter1	0x830
+#define	rFPGA0_XC_HSSIParameter2	0x834
+#define	rFPGA0_XD_HSSIParameter1	0x838
+#define	rFPGA0_XD_HSSIParameter2	0x83c
+#define	rFPGA0_XA_LSSIParameter		0x840
+#define	rFPGA0_XB_LSSIParameter		0x844
+#define	rFPGA0_XC_LSSIParameter		0x848
+#define	rFPGA0_XD_LSSIParameter		0x84c
+
+#define	rFPGA0_RFWakeUpParameter	0x850	/* Useless now */
+#define	rFPGA0_RFSleepUpParameter	0x854
+
+#define	rFPGA0_XAB_SwitchControl	0x858	/* RF Channel switch */
+#define	rFPGA0_XCD_SwitchControl	0x85c
+
+#define	rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
+#define	rFPGA0_XB_RFInterfaceOE		0x864
+#define	rFPGA0_XC_RFInterfaceOE		0x868
+#define	rFPGA0_XD_RFInterfaceOE		0x86c
+#define	rFPGA0_XAB_RFInterfaceSW	0x870	/* RF Interface Software Ctrl */
+#define	rFPGA0_XCD_RFInterfaceSW	0x874
+
+#define	rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
+#define	rFPGA0_XCD_RFParameter		0x87c
+
+#define	rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting
+						 * RF-R/W protection
+						 * for parameter4?? */
+#define	rFPGA0_AnalogParameter2		0x884
+#define	rFPGA0_AnalogParameter3		0x888	/* Useless now */
+#define	rFPGA0_AnalogParameter4		0x88c
+
+#define	rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
+#define	rFPGA0_XB_LSSIReadBack		0x8a4
+#define	rFPGA0_XC_LSSIReadBack		0x8a8
+#define	rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define	rFPGA0_PSDReport		0x8b4	/* Useless now */
+#define	rFPGA0_XAB_RFInterfaceRB	0x8e0	/* Useless now */
+#define	rFPGA0_XCD_RFInterfaceRB	0x8e4	/* Useless now */
+
+/*
+ * 4. Page9(0x900)
+ */
+#define	rFPGA1_RFMOD			0x900	/* RF mode & OFDM TxSC */
+
+#define	rFPGA1_TxBlock			0x904	/* Useless now */
+#define	rFPGA1_DebugSelect		0x908	/* Useless now */
+#define	rFPGA1_TxInfo			0x90c	/* Useless now */
+
+/*
+ * 5. PageA(0xA00)
+ *
+ * Set Control channel to upper or lower.
+ * These settings are required only for 40MHz */
+#define	rCCK0_System			0xa00
+
+#define	rCCK0_AFESetting		0xa04	/* Disable init gain now */
+#define	rCCK0_CCA			0xa08	/* Disable init gain now */
+
+#define	rCCK0_RxAGC1			0xa0c
+/* AGC default value, saturation level
+ * Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now.
+ * Not the same as 90 series */
+#define	rCCK0_RxAGC2			0xa10	/* AGC & DAGC */
+
+#define	rCCK0_RxHP			0xa14
+
+#define	rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel
+						 * estimation threshold */
+#define	rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define	rCCK0_TxFilter1			0xa20
+#define	rCCK0_TxFilter2			0xa24
+#define	rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define	rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d useless now 0xa30-a4f
+						 * channel report */
+#define	rCCK0_TRSSIReport		0xa50
+#define	rCCK0_RxReport			0xa54   /* 0xa57 */
+#define	rCCK0_FACounterLower		0xa5c   /* 0xa5b */
+#define	rCCK0_FACounterUpper		0xa58   /* 0xa5c */
+
+/*
+ * 6. PageC(0xC00)
+ */
+#define	rOFDM0_LSTF			0xc00
+#define	rOFDM0_TRxPathEnable		0xc04
+#define	rOFDM0_TRMuxPar			0xc08
+#define	rOFDM0_TRSWIsolation		0xc0c
+
+/*RxIQ DC offset, Rx digital filter, DC notch filter */
+#define	rOFDM0_XARxAFE			0xc10
+#define	rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
+#define	rOFDM0_XBRxAFE			0xc18
+#define	rOFDM0_XBRxIQImbalance		0xc1c
+#define	rOFDM0_XCRxAFE			0xc20
+#define	rOFDM0_XCRxIQImbalance		0xc24
+#define	rOFDM0_XDRxAFE			0xc28
+#define	rOFDM0_XDRxIQImbalance		0xc2c
+
+#define	rOFDM0_RxDetector1		0xc30  /* PD,BW & SBD DM tune
+						* init gain */
+#define	rOFDM0_RxDetector2		0xc34  /* SBD & Fame Sync. */
+#define	rOFDM0_RxDetector3		0xc38  /* Frame Sync. */
+#define	rOFDM0_RxDetector4		0xc3c  /* PD, SBD, Frame Sync &
+						* Short-GI */
+
+#define	rOFDM0_RxDSP			0xc40  /* Rx Sync Path */
+#define	rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define	rOFDM0_CCADropThreshold		0xc48 /* CCA Drop threshold */
+#define	rOFDM0_ECCAThreshold		0xc4c /* energy CCA */
+
+#define	rOFDM0_XAAGCCore1		0xc50	/* DIG */
+#define	rOFDM0_XAAGCCore2		0xc54
+#define	rOFDM0_XBAGCCore1		0xc58
+#define	rOFDM0_XBAGCCore2		0xc5c
+#define	rOFDM0_XCAGCCore1		0xc60
+#define	rOFDM0_XCAGCCore2		0xc64
+#define	rOFDM0_XDAGCCore1		0xc68
+#define	rOFDM0_XDAGCCore2		0xc6c
+#define	rOFDM0_AGCParameter1		0xc70
+#define	rOFDM0_AGCParameter2		0xc74
+#define	rOFDM0_AGCRSSITable		0xc78
+#define	rOFDM0_HTSTFAGC			0xc7c
+
+#define	rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
+#define	rOFDM0_XATxAFE			0xc84
+#define	rOFDM0_XBTxIQImbalance		0xc88
+#define	rOFDM0_XBTxAFE			0xc8c
+#define	rOFDM0_XCTxIQImbalance		0xc90
+#define	rOFDM0_XCTxAFE			0xc94
+#define	rOFDM0_XDTxIQImbalance		0xc98
+#define	rOFDM0_XDTxAFE			0xc9c
+
+#define	rOFDM0_RxHPParameter		0xce0
+#define	rOFDM0_TxPseudoNoiseWgt		0xce4
+#define	rOFDM0_FrameSync		0xcf0
+#define	rOFDM0_DFSReport		0xcf4
+#define	rOFDM0_TxCoeff1			0xca4
+#define	rOFDM0_TxCoeff2			0xca8
+#define	rOFDM0_TxCoeff3			0xcac
+#define	rOFDM0_TxCoeff4			0xcb0
+#define	rOFDM0_TxCoeff5			0xcb4
+#define	rOFDM0_TxCoeff6			0xcb8
+
+/*
+ * 7. PageD(0xD00)
+ */
+#define	rOFDM1_LSTF			0xd00
+#define	rOFDM1_TRxPathEnable		0xd04
+
+#define	rOFDM1_CFO			0xd08	/* No setting now */
+#define	rOFDM1_CSI1			0xd10
+#define	rOFDM1_SBD			0xd14
+#define	rOFDM1_CSI2			0xd18
+#define	rOFDM1_CFOTracking		0xd2c
+#define	rOFDM1_TRxMesaure1		0xd34
+#define	rOFDM1_IntfDet			0xd3c
+#define	rOFDM1_PseudoNoiseStateAB	0xd50
+#define	rOFDM1_PseudoNoiseStateCD	0xd54
+#define	rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define	rOFDM_PHYCounter1		0xda0  /* cca, parity fail */
+#define	rOFDM_PHYCounter2		0xda4  /* rate illegal, crc8 fail */
+#define	rOFDM_PHYCounter3		0xda8  /* MCS not support */
+#define	rOFDM_ShortCFOAB		0xdac  /* No setting now */
+#define	rOFDM_ShortCFOCD		0xdb0
+#define	rOFDM_LongCFOAB			0xdb4
+#define	rOFDM_LongCFOCD			0xdb8
+#define	rOFDM_TailCFOAB			0xdbc
+#define	rOFDM_TailCFOCD			0xdc0
+#define	rOFDM_PWMeasure1		0xdc4
+#define	rOFDM_PWMeasure2		0xdc8
+#define	rOFDM_BWReport			0xdcc
+#define	rOFDM_AGCReport			0xdd0
+#define	rOFDM_RxSNR			0xdd4
+#define	rOFDM_RxEVMCSI			0xdd8
+#define	rOFDM_SIGReport			0xddc
+
+/*
+ * 8. PageE(0xE00)
+ */
+#define	rTxAGC_Rate18_06		0xe00
+#define	rTxAGC_Rate54_24		0xe04
+#define	rTxAGC_CCK_Mcs32		0xe08
+#define	rTxAGC_Mcs03_Mcs00		0xe10
+#define	rTxAGC_Mcs07_Mcs04		0xe14
+#define	rTxAGC_Mcs11_Mcs08		0xe18
+#define	rTxAGC_Mcs15_Mcs12		0xe1c
+
+/* Analog- control in RX_WAIT_CCA : REG: EE0
+ * [Analog- Power & Control Register] */
+#define		rRx_Wait_CCCA		0xe70
+#define	rAnapar_Ctrl_BB			0xee0
+
+/*
+ * 7. RF Register 0x00-0x2E (RF 8256)
+ *    RF-0222D 0x00-3F
+ *
+ * Zebra1
+ */
+#define	rZebra1_HSSIEnable		0x0	/* Useless now */
+#define	rZebra1_TRxEnable1		0x1
+#define	rZebra1_TRxEnable2		0x2
+#define	rZebra1_AGC			0x4
+#define	rZebra1_ChargePump		0x5
+#define	rZebra1_Channel			0x7	/* RF channel switch */
+#define	rZebra1_TxGain			0x8	/* Useless now */
+#define	rZebra1_TxLPF			0x9
+#define	rZebra1_RxLPF			0xb
+#define	rZebra1_RxHPFCorner		0xc
+
+/* Zebra4 */
+#define	rGlobalCtrl			0	/* Useless now */
+#define	rRTL8256_TxLPF			19
+#define	rRTL8256_RxLPF			11
+
+/* RTL8258 */
+#define	rRTL8258_TxLPF			0x11	/* Useless now */
+#define	rRTL8258_RxLPF			0x13
+#define	rRTL8258_RSSILPF		0xa
+
+/* RL6052 Register definition */
+#define	RF_AC				0x00
+#define	RF_IQADJ_G1			0x01
+#define	RF_IQADJ_G2			0x02
+#define	RF_POW_TRSW			0x05
+
+#define	RF_GAIN_RX			0x06
+#define	RF_GAIN_TX			0x07
+
+#define	RF_TXM_IDAC			0x08
+#define	RF_BS_IQGEN			0x0F
+
+#define	RF_MODE1			0x10
+#define	RF_MODE2			0x11
+
+#define	RF_RX_AGC_HP			0x12
+#define	RF_TX_AGC			0x13
+#define	RF_BIAS				0x14
+#define	RF_IPA				0x15
+#define	RF_POW_ABILITY			0x17
+#define	RF_MODE_AG			0x18
+#define	rRfChannel			0x18	/* RF channel and BW switch */
+#define	RF_CHNLBW			0x18	/* RF channel and BW switch */
+#define	RF_TOP				0x19
+#define	RF_RX_G1			0x1A
+#define	RF_RX_G2			0x1B
+#define	RF_RX_BB2			0x1C
+#define	RF_RX_BB1			0x1D
+
+#define	RF_RCK1				0x1E
+#define	RF_RCK2				0x1F
+
+#define	RF_TX_G1			0x20
+#define	RF_TX_G2			0x21
+#define	RF_TX_G3			0x22
+
+#define	RF_TX_BB1			0x23
+#define	RF_T_METER			0x24
+
+#define	RF_SYN_G1			0x25	/* RF TX Power control */
+#define	RF_SYN_G2			0x26	/* RF TX Power control */
+#define	RF_SYN_G3			0x27	/* RF TX Power control */
+#define	RF_SYN_G4			0x28	/* RF TX Power control */
+#define	RF_SYN_G5			0x29	/* RF TX Power control */
+#define	RF_SYN_G6			0x2A	/* RF TX Power control */
+#define	RF_SYN_G7			0x2B	/* RF TX Power control */
+#define	RF_SYN_G8			0x2C	/* RF TX Power control */
+
+#define	RF_RCK_OS			0x30	/* RF TX PA control */
+
+#define	RF_TXPA_G1			0x31	/* RF TX PA control */
+#define	RF_TXPA_G2			0x32	/* RF TX PA control */
+#define	RF_TXPA_G3			0x33	/* RF TX PA control */
+
+/*
+ * Bit Mask
+ *
+ * 1. Page1(0x100) */
+#define	bBBResetB			0x100	/* Useless now? */
+#define	bGlobalResetB			0x200
+#define	bOFDMTxStart			0x4
+#define	bCCKTxStart			0x8
+#define	bCRC32Debug			0x100
+#define	bPMACLoopback			0x10
+#define	bTxLSIG				0xffffff
+#define	bOFDMTxRate			0xf
+#define	bOFDMTxReserved			0x10
+#define	bOFDMTxLength			0x1ffe0
+#define	bOFDMTxParity			0x20000
+#define	bTxHTSIG1			0xffffff
+#define	bTxHTMCSRate			0x7f
+#define	bTxHTBW				0x80
+#define	bTxHTLength			0xffff00
+#define	bTxHTSIG2			0xffffff
+#define	bTxHTSmoothing			0x1
+#define	bTxHTSounding			0x2
+#define	bTxHTReserved			0x4
+#define	bTxHTAggreation			0x8
+#define	bTxHTSTBC			0x30
+#define	bTxHTAdvanceCoding		0x40
+#define	bTxHTShortGI			0x80
+#define	bTxHTNumberHT_LTF		0x300
+#define	bTxHTCRC8			0x3fc00
+#define	bCounterReset			0x10000
+#define	bNumOfOFDMTx			0xffff
+#define	bNumOfCCKTx			0xffff0000
+#define	bTxIdleInterval			0xffff
+#define	bOFDMService			0xffff0000
+#define	bTxMACHeader			0xffffffff
+#define	bTxDataInit			0xff
+#define	bTxHTMode			0x100
+#define	bTxDataType			0x30000
+#define	bTxRandomSeed			0xffffffff
+#define	bCCKTxPreamble			0x1
+#define	bCCKTxSFD			0xffff0000
+#define	bCCKTxSIG			0xff
+#define	bCCKTxService			0xff00
+#define	bCCKLengthExt			0x8000
+#define	bCCKTxLength			0xffff0000
+#define	bCCKTxCRC16			0xffff
+#define	bCCKTxStatus			0x1
+#define	bOFDMTxStatus			0x2
+#define IS_BB_REG_OFFSET_92S(_Offset)	((_Offset >= 0x800) && \
+					(_Offset <= 0xfff))
+
+/* 2. Page8(0x800) */
+#define	bRFMOD			0x1	/* Reg 0x800 rFPGA0_RFMOD */
+#define	bJapanMode		0x2
+#define	bCCKTxSC		0x30
+#define	bCCKEn			0x1000000
+#define	bOFDMEn			0x2000000
+
+#define	bOFDMRxADCPhase         0x10000	/* Useless now */
+#define	bOFDMTxDACPhase         0x40000
+#define	bXATxAGC                0x3f
+#define	bXBTxAGC                0xf00	/* Reg 80c rFPGA0_TxGainStage */
+#define	bXCTxAGC                0xf000
+#define	bXDTxAGC                0xf0000
+
+#define	bPAStart		0xf0000000	/* Useless now */
+#define	bTRStart		0x00f00000
+#define	bRFStart		0x0000f000
+#define	bBBStart		0x000000f0
+#define	bBBCCKStart		0x0000000f
+#define	bPAEnd			0xf          /* Reg0x814 */
+#define	bTREnd			0x0f000000
+#define	bRFEnd			0x000f0000
+#define	bCCAMask		0x000000f0   /* T2R */
+#define	bR2RCCAMask		0x00000f00
+#define	bHSSI_R2TDelay		0xf8000000
+#define	bHSSI_T2RDelay		0xf80000
+#define	bContTxHSSI		0x400     /* change gain at continue Tx */
+#define	bIGFromCCK		0x200
+#define	bAGCAddress		0x3f
+#define	bRxHPTx			0x7000
+#define	bRxHPT2R		0x38000
+#define	bRxHPCCKIni		0xc0000
+#define	bAGCTxCode		0xc00000
+#define	bAGCRxCode		0x300000
+#define	b3WireDataLength	0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParm1 */
+#define	b3WireAddressLength	0x400
+#define	b3WireRFPowerDown	0x1	/* Useless now */
+#define	b5GPAPEPolarity		0x40000000
+#define	b2GPAPEPolarity		0x80000000
+#define	bRFSW_TxDefaultAnt	0x3
+#define	bRFSW_TxOptionAnt	0x30
+#define	bRFSW_RxDefaultAnt	0x300
+#define	bRFSW_RxOptionAnt	0x3000
+#define	bRFSI_3WireData		0x1
+#define	bRFSI_3WireClock	0x2
+#define	bRFSI_3WireLoad		0x4
+#define	bRFSI_3WireRW		0x8
+#define	bRFSI_3Wire		0xf
+#define	bRFSI_RFENV		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+#define	bRFSI_TRSW		0x20	/* Useless now */
+#define	bRFSI_TRSWB		0x40
+#define	bRFSI_ANTSW		0x100
+#define	bRFSI_ANTSWB		0x200
+#define	bRFSI_PAPE		0x400
+#define	bRFSI_PAPE5G		0x800
+#define	bBandSelect		0x1
+#define	bHTSIG2_GI		0x80
+#define	bHTSIG2_Smoothing	0x01
+#define	bHTSIG2_Sounding	0x02
+#define	bHTSIG2_Aggreaton	0x08
+#define	bHTSIG2_STBC		0x30
+#define	bHTSIG2_AdvCoding	0x40
+#define	bHTSIG2_NumOfHTLTF	0x300
+#define	bHTSIG2_CRC8		0x3fc
+#define	bHTSIG1_MCS		0x7f
+#define	bHTSIG1_BandWidth	0x80
+#define	bHTSIG1_HTLength	0xffff
+#define	bLSIG_Rate		0xf
+#define	bLSIG_Reserved		0x10
+#define	bLSIG_Length		0x1fffe
+#define	bLSIG_Parity		0x20
+#define	bCCKRxPhase		0x4
+#define	bLSSIReadAddress	0x7f800000   /* T65 RF */
+#define	bLSSIReadEdge		0x80000000   /* LSSI "Read" edge signal */
+#define	bLSSIReadBackData	0xfffff		/* T65 RF */
+#define	bLSSIReadOKFlag		0x1000	/* Useless now */
+#define	bCCKSampleRate		0x8       /*0: 44MHz, 1:88MHz*/
+#define	bRegulator0Standby	0x1
+#define	bRegulatorPLLStandby	0x2
+#define	bRegulator1Standby	0x4
+#define	bPLLPowerUp		0x8
+#define	bDPLLPowerUp		0x10
+#define	bDA10PowerUp		0x20
+#define	bAD7PowerUp		0x200
+#define	bDA6PowerUp		0x2000
+#define	bXtalPowerUp		0x4000
+#define	b40MDClkPowerUP		0x8000
+#define	bDA6DebugMode		0x20000
+#define	bDA6Swing		0x380000
+
+/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+#define	bADClkPhase		0x4000000
+
+#define	b80MClkDelay		0x18000000	/* Useless */
+#define	bAFEWatchDogEnable	0x20000000
+
+/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define	bXtalCap01		0xc0000000
+#define	bXtalCap23		0x3
+#define	bXtalCap92x		0x0f000000
+#define bXtalCap		0x0f000000
+#define	bIntDifClkEnable	0x400	/* Useless */
+#define	bExtSigClkEnable	0x800
+#define	bBandgapMbiasPowerUp	0x10000
+#define	bAD11SHGain		0xc0000
+#define	bAD11InputRange		0x700000
+#define	bAD11OPCurrent		0x3800000
+#define	bIPathLoopback		0x4000000
+#define	bQPathLoopback		0x8000000
+#define	bAFELoopback		0x10000000
+#define	bDA10Swing		0x7e0
+#define	bDA10Reverse		0x800
+#define	bDAClkSource		0x1000
+#define	bAD7InputRange		0x6000
+#define	bAD7Gain		0x38000
+#define	bAD7OutputCMMode	0x40000
+#define	bAD7InputCMMode		0x380000
+#define	bAD7Current		0xc00000
+#define	bRegulatorAdjust	0x7000000
+#define	bAD11PowerUpAtTx	0x1
+#define	bDA10PSAtTx		0x10
+#define	bAD11PowerUpAtRx	0x100
+#define	bDA10PSAtRx		0x1000
+#define	bCCKRxAGCFormat		0x200
+#define	bPSDFFTSamplepPoint	0xc000
+#define	bPSDAverageNum		0x3000
+#define	bIQPathControl		0xc00
+#define	bPSDFreq		0x3ff
+#define	bPSDAntennaPath		0x30
+#define	bPSDIQSwitch		0x40
+#define	bPSDRxTrigger		0x400000
+#define	bPSDTxTrigger		0x80000000
+#define	bPSDSineToneScale	0x7f000000
+#define	bPSDReport		0xffff
+
+/* 3. Page9(0x900) */
+#define	bOFDMTxSC		0x30000000	/* Useless */
+#define	bCCKTxOn		0x1
+#define	bOFDMTxOn		0x2
+#define	bDebugPage		0xfff  /* reset debug page and HWord, LWord */
+#define	bDebugItem		0xff   /* reset debug page and LWord */
+#define	bAntL			0x10
+#define	bAntNonHT		0x100
+#define	bAntHT1			0x1000
+#define	bAntHT2			0x10000
+#define	bAntHT1S1		0x100000
+#define	bAntNonHTS1		0x1000000
+
+/* 4. PageA(0xA00) */
+#define	bCCKBBMode		0x3	/* Useless */
+#define	bCCKTxPowerSaving	0x80
+#define	bCCKRxPowerSaving	0x40
+
+#define	bCCKSideBand		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch*/
+#define	bCCKScramble		0x8	/* Useless */
+#define	bCCKAntDiversity	0x8000
+#define	bCCKCarrierRecovery	0x4000
+#define	bCCKTxRate		0x3000
+#define	bCCKDCCancel		0x0800
+#define	bCCKISICancel		0x0400
+#define	bCCKMatchFilter		0x0200
+#define	bCCKEqualizer		0x0100
+#define	bCCKPreambleDetect	0x800000
+#define	bCCKFastFalseCCA	0x400000
+#define	bCCKChEstStart		0x300000
+#define	bCCKCCACount		0x080000
+#define	bCCKcs_lim		0x070000
+#define	bCCKBistMode		0x80000000
+#define	bCCKCCAMask		0x40000000
+#define	bCCKTxDACPhase		0x4
+#define	bCCKRxADCPhase		0x20000000   /* r_rx_clk */
+#define	bCCKr_cp_mode0		0x0100
+#define	bCCKTxDCOffset		0xf0
+#define	bCCKRxDCOffset		0xf
+#define	bCCKCCAMode		0xc000
+#define	bCCKFalseCS_lim		0x3f00
+#define	bCCKCS_ratio		0xc00000
+#define	bCCKCorgBit_sel		0x300000
+#define	bCCKPD_lim		0x0f0000
+#define	bCCKNewCCA		0x80000000
+#define	bCCKRxHPofIG		0x8000
+#define	bCCKRxIG		0x7f00
+#define	bCCKLNAPolarity		0x800000
+#define	bCCKRx1stGain		0x7f0000
+#define	bCCKRFExtend		0x20000000 /* CCK Rx Iinital gain polarity */
+#define	bCCKRxAGCSatLevel	0x1f000000
+#define	bCCKRxAGCSatCount       0xe0
+#define	bCCKRxRFSettle          0x1f       /* AGCsamp_dly */
+#define	bCCKFixedRxAGC          0x8000
+#define	bCCKAntennaPolarity     0x2000
+#define	bCCKTxFilterType        0x0c00
+#define	bCCKRxAGCReportType	0x0300
+#define	bCCKRxDAGCEn            0x80000000
+#define	bCCKRxDAGCPeriod        0x20000000
+#define	bCCKRxDAGCSatLevel	0x1f000000
+#define	bCCKTimingRecovery      0x800000
+#define	bCCKTxC0                0x3f0000
+#define	bCCKTxC1                0x3f000000
+#define	bCCKTxC2                0x3f
+#define	bCCKTxC3                0x3f00
+#define	bCCKTxC4                0x3f0000
+#define	bCCKTxC5		0x3f000000
+#define	bCCKTxC6		0x3f
+#define	bCCKTxC7		0x3f00
+#define	bCCKDebugPort		0xff0000
+#define	bCCKDACDebug		0x0f000000
+#define	bCCKFalseAlarmEnable	0x8000
+#define	bCCKFalseAlarmRead	0x4000
+#define	bCCKTRSSI		0x7f
+#define	bCCKRxAGCReport		0xfe
+#define	bCCKRxReport_AntSel	0x80000000
+#define	bCCKRxReport_MFOff	0x40000000
+#define	bCCKRxRxReport_SQLoss	0x20000000
+#define	bCCKRxReport_Pktloss	0x10000000
+#define	bCCKRxReport_Lockedbit	0x08000000
+#define	bCCKRxReport_RateError	0x04000000
+#define	bCCKRxReport_RxRate	0x03000000
+#define	bCCKRxFACounterLower	0xff
+#define	bCCKRxFACounterUpper	0xff000000
+#define	bCCKRxHPAGCStart	0xe000
+#define	bCCKRxHPAGCFinal	0x1c00
+#define	bCCKRxFalseAlarmEnable	0x8000
+#define	bCCKFACounterFreeze	0x4000
+#define	bCCKTxPathSel		0x10000000
+#define	bCCKDefaultRxPath	0xc000000
+#define	bCCKOptionRxPath	0x3000000
+
+/* 5. PageC(0xC00) */
+#define	bNumOfSTF		0x3	/* Useless */
+#define	bShift_L                0xc0
+#define	bGI_TH			0xc
+#define	bRxPathA		0x1
+#define	bRxPathB		0x2
+#define	bRxPathC		0x4
+#define	bRxPathD		0x8
+#define	bTxPathA		0x1
+#define	bTxPathB		0x2
+#define	bTxPathC		0x4
+#define	bTxPathD		0x8
+#define	bTRSSIFreq		0x200
+#define	bADCBackoff		0x3000
+#define	bDFIRBackoff		0xc000
+#define	bTRSSILatchPhase	0x10000
+#define	bRxIDCOffset		0xff
+#define	bRxQDCOffset		0xff00
+#define	bRxDFIRMode		0x1800000
+#define	bRxDCNFType		0xe000000
+#define	bRXIQImb_A		0x3ff
+#define	bRXIQImb_B		0xfc00
+#define	bRXIQImb_C		0x3f0000
+#define	bRXIQImb_D		0xffc00000
+#define	bDC_dc_Notch		0x60000
+#define	bRxNBINotch		0x1f000000
+#define	bPD_TH			0xf
+#define	bPD_TH_Opt2		0xc000
+#define	bPWED_TH		0x700
+#define	bIfMF_Win_L		0x800
+#define	bPD_Option		0x1000
+#define	bMF_Win_L		0xe000
+#define	bBW_Search_L		0x30000
+#define	bwin_enh_L		0xc0000
+#define	bBW_TH			0x700000
+#define	bED_TH2			0x3800000
+#define	bBW_option		0x4000000
+#define	bRatio_TH		0x18000000
+#define	bWindow_L		0xe0000000
+#define	bSBD_Option		0x1
+#define	bFrame_TH		0x1c
+#define	bFS_Option		0x60
+#define	bDC_Slope_check		0x80
+#define	bFGuard_Counter_DC_L	0xe00
+#define	bFrame_Weight_Short	0x7000
+#define	bSub_Tune		0xe00000
+#define	bFrame_DC_Length	0xe000000
+#define	bSBD_start_offset	0x30000000
+#define	bFrame_TH_2		0x7
+#define	bFrame_GI2_TH		0x38
+#define	bGI2_Sync_en		0x40
+#define	bSarch_Short_Early	0x300
+#define	bSarch_Short_Late	0xc00
+#define	bSarch_GI2_Late		0x70000
+#define	bCFOAntSum		0x1
+#define	bCFOAcc			0x2
+#define	bCFOStartOffset		0xc
+#define	bCFOLookBack		0x70
+#define	bCFOSumWeight		0x80
+#define	bDAGCEnable		0x10000
+#define	bTXIQImb_A		0x3ff
+#define	bTXIQImb_B		0xfc00
+#define	bTXIQImb_C		0x3f0000
+#define	bTXIQImb_D		0xffc00000
+#define	bTxIDCOffset		0xff
+#define	bTxQDCOffset		0xff00
+#define	bTxDFIRMode		0x10000
+#define	bTxPesudoNoiseOn	0x4000000
+#define	bTxPesudoNoise_A	0xff
+#define	bTxPesudoNoise_B	0xff00
+#define	bTxPesudoNoise_C	0xff0000
+#define	bTxPesudoNoise_D	0xff000000
+#define	bCCADropOption		0x20000
+#define	bCCADropThres		0xfff00000
+#define	bEDCCA_H		0xf
+#define	bEDCCA_L		0xf0
+#define	bLambda_ED              0x300
+#define	bRxInitialGain          0x7f
+#define	bRxAntDivEn             0x80
+#define	bRxAGCAddressForLNA     0x7f00
+#define	bRxHighPowerFlow        0x8000
+#define	bRxAGCFreezeThres       0xc0000
+#define	bRxFreezeStep_AGC1      0x300000
+#define	bRxFreezeStep_AGC2      0xc00000
+#define	bRxFreezeStep_AGC3      0x3000000
+#define	bRxFreezeStep_AGC0      0xc000000
+#define	bRxRssi_Cmp_En          0x10000000
+#define	bRxQuickAGCEn           0x20000000
+#define	bRxAGCFreezeThresMode   0x40000000
+#define	bRxOverFlowCheckType    0x80000000
+#define	bRxAGCShift             0x7f
+#define	bTRSW_Tri_Only          0x80
+#define	bPowerThres             0x300
+#define	bRxAGCEn                0x1
+#define	bRxAGCTogetherEn        0x2
+#define	bRxAGCMin               0x4
+#define	bRxHP_Ini               0x7
+#define	bRxHP_TRLNA             0x70
+#define	bRxHP_RSSI              0x700
+#define	bRxHP_BBP1              0x7000
+#define	bRxHP_BBP2              0x70000
+#define	bRxHP_BBP3              0x700000
+#define	bRSSI_H                 0x7f0000     /* the threshold for high power */
+#define	bRSSI_Gen               0x7f000000   /* the threshold for ant divers */
+#define	bRxSettle_TRSW          0x7
+#define	bRxSettle_LNA           0x38
+#define	bRxSettle_RSSI          0x1c0
+#define	bRxSettle_BBP           0xe00
+#define	bRxSettle_RxHP          0x7000
+#define	bRxSettle_AntSW_RSSI    0x38000
+#define	bRxSettle_AntSW         0xc0000
+#define	bRxProcessTime_DAGC     0x300000
+#define	bRxSettle_HSSI          0x400000
+#define	bRxProcessTime_BBPPW    0x800000
+#define	bRxAntennaPowerShift    0x3000000
+#define	bRSSITableSelect        0xc000000
+#define	bRxHP_Final             0x7000000
+#define	bRxHTSettle_BBP         0x7
+#define	bRxHTSettle_HSSI        0x8
+#define	bRxHTSettle_RxHP        0x70
+#define	bRxHTSettle_BBPPW       0x80
+#define	bRxHTSettle_Idle        0x300
+#define	bRxHTSettle_Reserved    0x1c00
+#define	bRxHTRxHPEn             0x8000
+#define	bRxHTAGCFreezeThres     0x30000
+#define	bRxHTAGCTogetherEn      0x40000
+#define	bRxHTAGCMin             0x80000
+#define	bRxHTAGCEn              0x100000
+#define	bRxHTDAGCEn             0x200000
+#define	bRxHTRxHP_BBP           0x1c00000
+#define	bRxHTRxHP_Final         0xe0000000
+#define	bRxPWRatioTH            0x3
+#define	bRxPWRatioEn            0x4
+#define	bRxMFHold               0x3800
+#define	bRxPD_Delay_TH1         0x38
+#define	bRxPD_Delay_TH2         0x1c0
+#define	bRxPD_DC_COUNT_MAX      0x600
+#define	bRxPD_Delay_TH          0x8000
+#define	bRxProcess_Delay        0xf0000
+#define	bRxSearchrange_GI2_Early 0x700000
+#define	bRxFrame_Guard_Counter_L 0x3800000
+#define	bRxSGI_Guard_L          0xc000000
+#define	bRxSGI_Search_L         0x30000000
+#define	bRxSGI_TH               0xc0000000
+#define	bDFSCnt0                0xff
+#define	bDFSCnt1                0xff00
+#define	bDFSFlag                0xf0000
+#define	bMFWeightSum            0x300000
+#define	bMinIdxTH               0x7f000000
+#define	bDAFormat               0x40000
+#define	bTxChEmuEnable          0x01000000
+#define	bTRSWIsolation_A        0x7f
+#define	bTRSWIsolation_B        0x7f00
+#define	bTRSWIsolation_C        0x7f0000
+#define	bTRSWIsolation_D        0x7f000000
+#define	bExtLNAGain             0x7c00
+
+/* 6. PageE(0xE00) */
+#define	bSTBCEn                 0x4	/* Useless */
+#define	bAntennaMapping         0x10
+#define	bNss                    0x20
+#define	bCFOAntSumD             0x200
+#define	bPHYCounterReset        0x8000000
+#define	bCFOReportGet           0x4000000
+#define	bOFDMContinueTx         0x10000000
+#define	bOFDMSingleCarrier      0x20000000
+#define	bOFDMSingleTone         0x40000000
+#define	bHTDetect               0x100
+#define	bCFOEn                  0x10000
+#define	bCFOValue               0xfff00000
+#define	bSigTone_Re             0x3f
+#define	bSigTone_Im             0x7f00
+#define	bCounter_CCA            0xffff
+#define	bCounter_ParityFail     0xffff0000
+#define	bCounter_RateIllegal    0xffff
+#define	bCounter_CRC8Fail       0xffff0000
+#define	bCounter_MCSNoSupport   0xffff
+#define	bCounter_FastSync       0xffff
+#define	bShortCFO               0xfff
+#define	bShortCFOTLength        12   /* total */
+#define	bShortCFOFLength        11   /* fraction */
+#define	bLongCFO                0x7ff
+#define	bLongCFOTLength         11
+#define	bLongCFOFLength         11
+#define	bTailCFO                0x1fff
+#define	bTailCFOTLength         13
+#define	bTailCFOFLength         12
+#define	bmax_en_pwdB            0xffff
+#define	bCC_power_dB            0xffff0000
+#define	bnoise_pwdB             0xffff
+#define	bPowerMeasTLength       10
+#define	bPowerMeasFLength       3
+#define	bRx_HT_BW               0x1
+#define	bRxSC                   0x6
+#define	bRx_HT                  0x8
+#define	bNB_intf_det_on         0x1
+#define	bIntf_win_len_cfg       0x30
+#define	bNB_Intf_TH_cfg         0x1c0
+#define	bRFGain                 0x3f
+#define	bTableSel               0x40
+#define	bTRSW                   0x80
+#define	bRxSNR_A                0xff
+#define	bRxSNR_B                0xff00
+#define	bRxSNR_C                0xff0000
+#define	bRxSNR_D                0xff000000
+#define	bSNREVMTLength          8
+#define	bSNREVMFLength          1
+#define	bCSI1st                 0xff
+#define	bCSI2nd                 0xff00
+#define	bRxEVM1st               0xff0000
+#define	bRxEVM2nd               0xff000000
+#define	bSIGEVM                 0xff
+#define	bPWDB                   0xff00
+#define	bSGIEN                  0x10000
+
+#define	bSFactorQAM1            0xf	/* Useless */
+#define	bSFactorQAM2            0xf0
+#define	bSFactorQAM3            0xf00
+#define	bSFactorQAM4            0xf000
+#define	bSFactorQAM5            0xf0000
+#define	bSFactorQAM6            0xf0000
+#define	bSFactorQAM7            0xf00000
+#define	bSFactorQAM8            0xf000000
+#define	bSFactorQAM9            0xf0000000
+#define	bCSIScheme              0x100000
+
+#define	bNoiseLvlTopSet         0x3	/* Useless */
+#define	bChSmooth               0x4
+#define	bChSmoothCfg1           0x38
+#define	bChSmoothCfg2           0x1c0
+#define	bChSmoothCfg3           0xe00
+#define	bChSmoothCfg4           0x7000
+#define	bMRCMode                0x800000
+#define	bTHEVMCfg               0x7000000
+
+#define	bLoopFitType            0x1	/* Useless */
+#define	bUpdCFO                 0x40
+#define	bUpdCFOOffData          0x80
+#define	bAdvUpdCFO              0x100
+#define	bAdvTimeCtrl            0x800
+#define	bUpdClko                0x1000
+#define	bFC                     0x6000
+#define	bTrackingMode           0x8000
+#define	bPhCmpEnable            0x10000
+#define	bUpdClkoLTF             0x20000
+#define	bComChCFO               0x40000
+#define	bCSIEstiMode            0x80000
+#define	bAdvUpdEqz              0x100000
+#define	bUChCfg                 0x7000000
+#define	bUpdEqz			0x8000000
+
+#define	bTxAGCRate18_06		0x7f7f7f7f	/* Useless */
+#define	bTxAGCRate54_24		0x7f7f7f7f
+#define	bTxAGCRateMCS32		0x7f
+#define	bTxAGCRateCCK		0x7f00
+#define	bTxAGCRateMCS3_MCS0	0x7f7f7f7f
+#define	bTxAGCRateMCS7_MCS4	0x7f7f7f7f
+#define	bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define	bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+/* Rx Pseduo noise */
+#define	bRxPesudoNoiseOn         0x20000000	/* Useless */
+#define	bRxPesudoNoise_A         0xff
+#define	bRxPesudoNoise_B         0xff00
+#define	bRxPesudoNoise_C         0xff0000
+#define	bRxPesudoNoise_D         0xff000000
+#define	bPesudoNoiseState_A      0xffff
+#define	bPesudoNoiseState_B      0xffff0000
+#define	bPesudoNoiseState_C      0xffff
+#define	bPesudoNoiseState_D      0xffff0000
+
+/* 7. RF Register
+ * Zebra1 */
+#define	bZebra1_HSSIEnable        0x8		/* Useless */
+#define	bZebra1_TRxControl        0xc00
+#define	bZebra1_TRxGainSetting    0x07f
+#define	bZebra1_RxCorner          0xc00
+#define	bZebra1_TxChargePump      0x38
+#define	bZebra1_RxChargePump      0x7
+#define	bZebra1_ChannelNum        0xf80
+#define	bZebra1_TxLPFBW           0x400
+#define	bZebra1_RxLPFBW           0x600
+
+/*Zebra4 */
+#define	bRTL8256RegModeCtrl1      0x100	/* Useless */
+#define	bRTL8256RegModeCtrl0      0x40
+#define	bRTL8256_TxLPFBW          0x18
+#define	bRTL8256_RxLPFBW          0x600
+
+/* RTL8258 */
+#define	bRTL8258_TxLPFBW          0xc	/* Useless */
+#define	bRTL8258_RxLPFBW          0xc00
+#define	bRTL8258_RSSILPFBW        0xc0
+
+/*
+ * Other Definition
+ */
+
+/* byte endable for sb_write */
+#define	bByte0                    0x1	/* Useless */
+#define	bByte1                    0x2
+#define	bByte2                    0x4
+#define	bByte3                    0x8
+#define	bWord0                    0x3
+#define	bWord1                    0xc
+#define	bDWord                    0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define	bMaskByte0                0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define	bMaskByte1                0xff00
+#define	bMaskByte2                0xff0000
+#define	bMaskByte3                0xff000000
+#define	bMaskHWord                0xffff0000
+#define	bMaskLWord                0x0000ffff
+#define	bMaskDWord                0xffffffff
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
+#define	bRFRegOffsetMask	0xfffff
+#define	bEnable                   0x1	/* Useless */
+#define	bDisable                  0x0
+
+#define	LeftAntenna               0x0	/* Useless */
+#define	RightAntenna              0x1
+
+#define	tCheckTxStatus            500   /* 500ms Useless */
+#define	tUpdateRxCounter          100   /* 100ms */
+
+#define	rateCCK     0	/* Useless */
+#define	rateOFDM    1
+#define	rateHT      2
+
+/* define Register-End */
+#define	bPMAC_End       0x1ff	/* Useless */
+#define	bFPGAPHY0_End   0x8ff
+#define	bFPGAPHY1_End   0x9ff
+#define	bCCKPHY0_End    0xaff
+#define	bOFDMPHY0_End   0xcff
+#define	bOFDMPHY1_End   0xdff
+
+#define	bPMACControl	0x0	/* Useless */
+#define	bWMACControl	0x1
+#define	bWNICControl	0x2
+
+#define	ANTENNA_A	0x1	/* Useless */
+#define	ANTENNA_B	0x2
+#define	ANTENNA_AB	0x3	/* ANTENNA_A |ANTENNA_B */
+
+#define	ANTENNA_C	0x4
+#define	ANTENNA_D	0x8
+
+
+/* accept all physical address */
+#define RCR_AAP		BIT(0)
+#define RCR_APM		BIT(1)		/* accept physical match */
+#define RCR_AM		BIT(2)		/* accept multicast */
+#define RCR_AB		BIT(3)		/* accept broadcast */
+#define RCR_ACRC32	BIT(5)		/* accept error packet */
+#define RCR_9356SEL	BIT(6)
+#define RCR_AICV	BIT(12)		/* Accept ICV error packet */
+#define RCR_RXFTH0	(BIT(13)|BIT(14)|BIT(15))	/* Rx FIFO threshold */
+#define RCR_ADF		BIT(18)		/* Accept Data(frame type) frame */
+#define RCR_ACF		BIT(19)		/* Accept control frame */
+#define RCR_AMF		BIT(20)		/* Accept management frame */
+#define RCR_ADD3	BIT(21)
+#define RCR_APWRMGT	BIT(22)		/* Accept power management packet */
+#define RCR_CBSSID	BIT(23)		/* Accept BSSID match packet */
+#define RCR_ENMARP	BIT(28)		/* enable mac auto reset phy */
+#define RCR_EnCS1	BIT(29)		/* enable carrier sense method 1 */
+#define RCR_EnCS2	BIT(30)		/* enable carrier sense method 2 */
+/* Rx Early mode is performed for packet size greater than 1536 */
+#define RCR_OnlyErlPkt	BIT(31)
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	/*__INC_HAL8192SPHYREG_H */
+
diff --git a/drivers/staging/rtl8712/rtl871x_pwrctrl.c b/drivers/staging/rtl8712/rtl871x_pwrctrl.c
new file mode 100644
index 0000000..23e72a0
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_pwrctrl.c
@@ -0,0 +1,250 @@
+/******************************************************************************
+ * rtl871x_pwrctrl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_PWRCTRL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+
+#define RTL8712_SDIO_LOCAL_BASE 0X10100000
+#define SDIO_HCPWM (RTL8712_SDIO_LOCAL_BASE + 0x0081)
+
+void r8712_set_rpwm(struct _adapter *padapter, u8 val8)
+{
+	u8	rpwm;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (pwrpriv->rpwm == val8) {
+		if (pwrpriv->rpwm_retry == 0)
+			return;
+	}
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
+		return;
+	rpwm = val8 | pwrpriv->tog;
+	switch (val8) {
+	case PS_STATE_S1:
+		pwrpriv->cpwm = val8;
+		break;
+	case PS_STATE_S2:/* only for USB normal powersave mode use,
+			  * temp mark some code. */
+	case PS_STATE_S3:
+	case PS_STATE_S4:
+		pwrpriv->cpwm = val8;
+		break;
+	default:
+		break;
+	}
+	pwrpriv->rpwm_retry = 0;
+	pwrpriv->rpwm = val8;
+	r8712_write8(padapter, 0x1025FE58, rpwm);
+	pwrpriv->tog += 0x80;
+}
+
+void r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode, uint smart_ps)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (ps_mode > PM_Card_Disable)
+		return;
+	/* if driver is in active state, we dont need set smart_ps.*/
+	if (ps_mode == PS_MODE_ACTIVE)
+		smart_ps = 0;
+	if ((pwrpriv->pwr_mode != ps_mode) || (pwrpriv->smart_ps != smart_ps)) {
+		if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			pwrpriv->bSleep = true;
+		else
+			pwrpriv->bSleep = false;
+		pwrpriv->pwr_mode = ps_mode;
+		pwrpriv->smart_ps = smart_ps;
+		_set_workitem(&(pwrpriv->SetPSModeWorkItem));
+	}
+}
+
+/*
+ * Caller:ISR handler...
+ *
+ * This will be called when CPWM interrupt is up.
+ *
+ * using to update cpwn of drv; and drv will make a decision to up or
+ * down pwr level
+ */
+void r8712_cpwm_int_hdl(struct _adapter *padapter,
+			struct reportpwrstate_parm *preportpwrstate)
+{
+	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+
+	if (pwrpriv->cpwm_tog == ((preportpwrstate->state) & 0x80))
+		return;
+	_cancel_timer_ex(&padapter->pwrctrlpriv. rpwm_check_timer);
+	_enter_pwrlock(&pwrpriv->lock);
+	pwrpriv->cpwm = (preportpwrstate->state) & 0xf;
+	if (pwrpriv->cpwm >= PS_STATE_S2) {
+		if (pwrpriv->alives & CMD_ALIVE)
+			up(&(pcmdpriv->cmd_queue_sema));
+		if (pwrpriv->alives & XMIT_ALIVE)
+			up(&(pxmitpriv->xmit_sema));
+	}
+	pwrpriv->cpwm_tog = (preportpwrstate->state) & 0x80;
+	up(&pwrpriv->lock);
+}
+
+static inline void register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+		pwrctrl->alives |= tag;
+}
+
+static inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+	if (pwrctrl->alives & tag)
+		pwrctrl->alives ^= tag;
+}
+
+static void _rpwm_check_handler (struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (padapter->bDriverStopped == true ||
+	    padapter->bSurpriseRemoved == true)
+		return;
+	if (pwrpriv->cpwm != pwrpriv->rpwm)
+		_set_workitem(&(pwrpriv->rpwm_workitem));
+}
+
+static void SetPSModeWorkItemCallback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work,
+				       struct pwrctrl_priv, SetPSModeWorkItem);
+	struct _adapter *padapter = container_of(pwrpriv,
+				    struct _adapter, pwrctrlpriv);
+	_enter_pwrlock(&pwrpriv->lock);
+	if (!pwrpriv->bSleep) {
+		if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			r8712_set_rpwm(padapter, PS_STATE_S4);
+	}
+	up(&pwrpriv->lock);
+}
+
+static void rpwm_workitem_callback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work,
+				       struct pwrctrl_priv, rpwm_workitem);
+	struct _adapter *padapter = container_of(pwrpriv,
+				    struct _adapter, pwrctrlpriv);
+	u8 cpwm = pwrpriv->cpwm;
+	_enter_pwrlock(&pwrpriv->lock);
+	if (pwrpriv->cpwm != pwrpriv->rpwm) {
+		cpwm = r8712_read8(padapter, SDIO_HCPWM);
+		pwrpriv->rpwm_retry = 1;
+		r8712_set_rpwm(padapter, pwrpriv->rpwm);
+	}
+	up(&pwrpriv->lock);
+}
+
+static void rpwm_check_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_rpwm_check_handler(adapter);
+}
+
+void r8712_init_pwrctrl_priv(struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+	sema_init(&pwrctrlpriv->lock, 1);
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+	pwrctrlpriv->smart_ps = 0;
+	pwrctrlpriv->tog = 0x80;
+/* clear RPWM to ensure driver and fw back to initial state. */
+	r8712_write8(padapter, 0x1025FE58, 0);
+	_init_workitem(&(pwrctrlpriv->SetPSModeWorkItem),
+		       SetPSModeWorkItemCallback, padapter);
+	_init_workitem(&(pwrctrlpriv->rpwm_workitem),
+		       rpwm_workitem_callback, padapter);
+	_init_timer(&(pwrctrlpriv->rpwm_check_timer),
+		    padapter->pnetdev, rpwm_check_handler, (u8 *)padapter);
+}
+
+/*
+Caller: r8712_cmd_thread
+
+Check if the fw_pwrstate is okay for issuing cmd.
+If not (cpwm should be is less than P2 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P2.
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: r8712_cmd_thread can issue cmds to firmware afterwards.
+_FAIL: r8712_cmd_thread can not do anything.
+*/
+sint r8712_register_cmd_alive(struct _adapter *padapter)
+{
+	uint res = _SUCCESS;
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+	register_task_alive(pwrctrl, CMD_ALIVE);
+	if (pwrctrl->cpwm < PS_STATE_S2) {
+		r8712_set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+	up(&pwrctrl->lock);
+	return res;
+}
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void r8712_unregister_cmd_alive(struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+	unregister_task_alive(pwrctrl, CMD_ALIVE);
+	if ((pwrctrl->cpwm > PS_STATE_S2) &&
+	   (pwrctrl->pwr_mode > PS_MODE_ACTIVE)) {
+		if ((pwrctrl->alives == 0) &&
+		    (check_fwstate(&padapter->mlmepriv,
+		     _FW_UNDER_LINKING) != true)) {
+			r8712_set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+	up(&pwrctrl->lock);
+}
diff --git a/drivers/staging/rtl8712/rtl871x_pwrctrl.h b/drivers/staging/rtl8712/rtl871x_pwrctrl.h
new file mode 100644
index 0000000..b41ca28
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_pwrctrl.h
@@ -0,0 +1,152 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_PWRCTRL_H_
+#define __RTL871X_PWRCTRL_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#define FW_PWR0	0
+#define FW_PWR1		1
+#define FW_PWR2		2
+#define FW_PWR3		3
+
+
+#define HW_PWR0	7
+#define HW_PWR1		6
+#define HW_PWR2		2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt {
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state, 0: register active state,
+				    1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define		PS_DPS				BIT(0)
+#define		PS_LCLK				(PS_DPS)
+#define	PS_RF_OFF			BIT(1)
+#define	PS_ALL_ON			BIT(2)
+#define	PS_ST_ACTIVE		BIT(3)
+#define	PS_LP				BIT(4)	/* low performance */
+
+#define	PS_STATE_MASK		(0x0F)
+#define	PS_STATE_HW_MASK	(0x07)
+#define		PS_SEQ_MASK		(0xc0)
+
+#define	PS_STATE(x)			(PS_STATE_MASK & (x))
+#define	PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define	PS_SEQ(x)			(PS_SEQ_MASK & (x))
+
+#define	PS_STATE_S0		(PS_DPS)
+#define		PS_STATE_S1		(PS_LCLK)
+#define	PS_STATE_S2		(PS_RF_OFF)
+#define		PS_STATE_S3		(PS_ALL_ON)
+#define	PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define		PS_IS_RF_ON(x)		((x) & (PS_ALL_ON))
+#define		PS_IS_ACTIVE(x)		((x) & (PS_ST_ACTIVE))
+#define		CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; /* the CPWM value */
+	unsigned short rsvd;
+};
+
+static inline void _enter_pwrlock(struct semaphore *plock)
+{
+	_down_sema(plock);
+}
+
+struct	pwrctrl_priv {
+	struct semaphore lock;
+	/*volatile*/ u8 rpwm; /* requested power state for fw */
+	/* fw current power state. updated when 1. read from HCPWM or
+	 * 2. driver lowers power level */
+	/*volatile*/ u8 cpwm;
+	/*volatile*/ u8 tog; /* toggling */
+	/*volatile*/ u8 cpwm_tog; /* toggling */
+	/*volatile*/ u8 tgt_rpwm; /* wanted power state */
+	uint pwr_mode;
+	uint smart_ps;
+	uint alives;
+	uint ImrContent;	/* used to store original imr. */
+	uint bSleep; /* sleep -> active is different from active -> sleep. */
+
+	_workitem SetPSModeWorkItem;
+	_workitem rpwm_workitem;
+	struct timer_list rpwm_check_timer;
+	u8	rpwm_retry;
+	uint	bSetPSModeWorkItemInProgress;
+
+	struct semaphore pnp_pwr_mgnt_sema;
+	spinlock_t pnp_pwr_mgnt_lock;
+	s32	pnp_current_pwr_state;
+	u8	pnp_bstop_trx;
+	u8	pnp_wwirp_pending;
+};
+
+void r8712_init_pwrctrl_priv(struct _adapter *adapter);
+sint r8712_register_cmd_alive(struct _adapter *padapter);
+void r8712_unregister_cmd_alive(struct _adapter *padapter);
+void r8712_cpwm_int_hdl(struct _adapter *padapter,
+			struct reportpwrstate_parm *preportpwrstate);
+void r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode,
+			uint smart_ps);
+void r8712_set_rpwm(struct _adapter *padapter, u8 val8);
+
+#endif  /* __RTL871X_PWRCTRL_H_ */
diff --git a/drivers/staging/rtl8712/rtl871x_recv.c b/drivers/staging/rtl8712/rtl871x_recv.c
new file mode 100644
index 0000000..7069f06
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_recv.c
@@ -0,0 +1,699 @@
+/******************************************************************************
+ * rtl871x_recv.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_RECV_C_
+
+#include <linux/slab.h>
+#include <linux/kmemleak.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "ip.h"
+#include "if_ether.h"
+#include "ethernet.h"
+#include "usb_ops.h"
+#include "wifi.h"
+
+static const u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+/* Datagram Delivery Protocol */
+static const u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static const u8 bridge_tunnel_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static const u8 rfc1042_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+void _r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{
+	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
+	spin_lock_init(&psta_recvpriv->lock);
+	_init_queue(&psta_recvpriv->defrag_q);
+}
+
+sint _r8712_init_recv_priv(struct recv_priv *precvpriv,
+			   struct _adapter *padapter)
+{
+	sint i;
+	union recv_frame *precvframe;
+
+	 memset((unsigned char *)precvpriv, 0, sizeof(struct  recv_priv));
+	spin_lock_init(&precvpriv->lock);
+	_init_queue(&precvpriv->free_recv_queue);
+	_init_queue(&precvpriv->recv_pending_queue);
+	precvpriv->adapter = padapter;
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+	precvpriv->pallocated_frame_buf = _malloc(NR_RECVFRAME *
+					   sizeof(union recv_frame) +
+					   RXFRAME_ALIGN_SZ);
+	if (precvpriv->pallocated_frame_buf == NULL)
+		return _FAIL;
+	kmemleak_not_leak(precvpriv->pallocated_frame_buf);
+	memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME *
+		sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf +
+				    RXFRAME_ALIGN_SZ -
+				    ((addr_t)(precvpriv->pallocated_frame_buf) &
+				    (RXFRAME_ALIGN_SZ-1));
+	precvframe = (union recv_frame *)precvpriv->precv_frame_buf;
+	for (i = 0; i < NR_RECVFRAME; i++) {
+		_init_listhead(&(precvframe->u.list));
+		list_insert_tail(&(precvframe->u.list),
+				 &(precvpriv->free_recv_queue.queue));
+		r8712_os_recv_resource_alloc(padapter, precvframe);
+		precvframe->u.hdr.adapter = padapter;
+		precvframe++;
+	}
+	precvpriv->rx_pending_cnt = 1;
+	sema_init(&precvpriv->allrxreturnevt, 0);
+	return r8712_init_recv_priv(precvpriv, padapter);
+}
+
+void _r8712_free_recv_priv(struct recv_priv *precvpriv)
+{
+	kfree(precvpriv->pallocated_frame_buf);
+	r8712_free_recv_priv(precvpriv);
+}
+
+union recv_frame *r8712_alloc_recvframe(struct  __queue *pfree_recv_queue)
+{
+	unsigned long irqL;
+	union recv_frame  *precvframe;
+	struct list_head *plist, *phead;
+	struct _adapter *padapter;
+	struct recv_priv *precvpriv;
+
+	spin_lock_irqsave(&pfree_recv_queue->lock, irqL);
+	if (_queue_empty(pfree_recv_queue) == true)
+		precvframe = NULL;
+	else {
+		phead = get_list_head(pfree_recv_queue);
+		plist = get_next(phead);
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		list_delete(&precvframe->u.hdr.list);
+		padapter = precvframe->u.hdr.adapter;
+		if (padapter != NULL) {
+			precvpriv = &padapter->recvpriv;
+			if (pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+	spin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);
+	return precvframe;
+}
+
+/*
+caller : defrag; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spin_lock to protect
+
+*/
+
+void r8712_free_recvframe_queue(struct  __queue *pframequeue,
+				struct  __queue *pfree_recv_queue)
+{
+	union	recv_frame *precvframe;
+	struct list_head *plist, *phead;
+
+	spin_lock(&pframequeue->lock);
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		plist = get_next(plist);
+		r8712_free_recvframe(precvframe, pfree_recv_queue);
+	}
+	spin_unlock(&pframequeue->lock);
+}
+
+sint r8712_recvframe_chkmic(struct _adapter *adapter,
+			    union recv_frame *precvframe)
+{
+	sint i, res = _SUCCESS;
+	u32	datalen;
+	u8 miccode[8];
+	u8 bmic_err = false;
+	u8 *pframe, *payload, *pframemic;
+	u8   *mickey, idx, *iv;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &precvframe->u.hdr.attrib;
+	struct	security_priv *psecuritypriv = &adapter->securitypriv;
+
+	stainfo = r8712_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);
+	if (prxattrib->encrypt == _TKIP_) {
+		/* calculate mic code */
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				iv = precvframe->u.hdr.rx_data +
+				     prxattrib->hdrlen;
+				idx = iv[3];
+				mickey = &psecuritypriv->XGrprxmickey[(((idx >>
+					 6) & 0x3)) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+			} else
+				mickey = &stainfo->tkiprxmickey.skey[0];
+			/*icv_len included the mic code*/
+			datalen = precvframe->u.hdr.len - prxattrib->hdrlen -
+				  prxattrib->iv_len - prxattrib->icv_len - 8;
+			pframe = precvframe->u.hdr.rx_data;
+			payload = pframe + prxattrib->hdrlen +
+				  prxattrib->iv_len;
+			seccalctkipmic(mickey, pframe, payload, datalen,
+				       &miccode[0],
+				       (unsigned char)prxattrib->priority);
+			pframemic = payload + datalen;
+			bmic_err = false;
+			for (i = 0; i < 8; i++) {
+				if (miccode[i] != *(pframemic + i))
+					bmic_err = true;
+			}
+			if (bmic_err == true) {
+				if (prxattrib->bdecrypted == true)
+					r8712_handle_tkip_mic_err(adapter,
+						(u8)IS_MCAST(prxattrib->ra));
+				res = _FAIL;
+			} else {
+				/* mic checked ok */
+				if ((psecuritypriv->bcheck_grpkey ==
+				     false) && (IS_MCAST(prxattrib->ra) ==
+				     true))
+					psecuritypriv->bcheck_grpkey = true;
+			}
+			recvframe_pull_tail(precvframe, 8);
+		}
+	}
+	return res;
+}
+
+/* decrypt and set the ivlen,icvlen of the recv_frame */
+union recv_frame *r8712_decryptor(struct _adapter *padapter,
+			    union recv_frame *precv_frame)
+{
+	struct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	union recv_frame *return_packet = precv_frame;
+
+	if ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0) ||
+	   (psecuritypriv->sw_decrypt == true))) {
+		psecuritypriv->hw_decrypted = false;
+		switch (prxattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			r8712_wep_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _TKIP_:
+			r8712_tkip_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _AES_:
+			r8712_aes_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		default:
+				break;
+		}
+	} else if (prxattrib->bdecrypted == 1)
+		psecuritypriv->hw_decrypted = true;
+	return return_packet;
+}
+/*###set the security information in the recv_frame */
+union recv_frame *r8712_portctrl(struct _adapter *adapter,
+				 union recv_frame *precv_frame)
+{
+	u8 *psta_addr, *ptr;
+	uint auth_alg;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct	sta_priv *pstapriv;
+	union recv_frame *prtnframe;
+	u16 ether_type = 0;
+
+	pstapriv = &adapter->stapriv;
+	ptr = get_recvframe_data(precv_frame);
+	pfhdr = &precv_frame->u.hdr;
+	psta_addr = pfhdr->attrib.ta;
+	psta = r8712_get_stainfo(pstapriv, psta_addr);
+	auth_alg = adapter->securitypriv.AuthAlgrthm;
+	if (auth_alg == 2) {
+		if ((psta != NULL) && (psta->ieee8021x_blocked)) {
+			/* blocked
+			 * only accept EAPOL frame */
+			prtnframe = precv_frame;
+			/*get ether_type */
+			ptr = ptr + pfhdr->attrib.hdrlen +
+			      pfhdr->attrib.iv_len + LLC_HEADER_SIZE;
+			memcpy(&ether_type, ptr, 2);
+			ether_type = ntohs((unsigned short)ether_type);
+			if (ether_type == 0x888e)
+				prtnframe = precv_frame;
+			else {
+				/*free this frame*/
+				r8712_free_recvframe(precv_frame,
+					 &adapter->recvpriv.free_recv_queue);
+				prtnframe = NULL;
+			}
+		} else {
+			/* allowed
+			 * check decryption status, and decrypt the
+			 * frame if needed */
+			prtnframe = precv_frame;
+			/* check is the EAPOL frame or not (Rekey) */
+			if (ether_type == 0x888e) {
+				/* check Rekey */
+				prtnframe = precv_frame;
+			}
+		}
+	} else
+		prtnframe = precv_frame;
+	return prtnframe;
+}
+
+static sint recv_decache(union recv_frame *precv_frame, u8 bretry,
+		  struct stainfo_rxcache *prxcache)
+{
+	sint tid = precv_frame->u.hdr.attrib.priority;
+	u16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
+			(precv_frame->u.hdr.attrib.frag_num & 0xf);
+
+	if (tid > 15)
+		return _FAIL;
+	if (seq_ctrl == prxcache->tid_rxseq[tid])
+		return _FAIL;
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+	return _SUCCESS;
+}
+
+static sint sta2sta_data_frame(struct _adapter *adapter,
+			       union recv_frame *precv_frame,
+			       struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	sint ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	u8 *sta_addr = NULL;
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		/* filter packets that SA is myself or multicast or broadcast */
+		if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))
+			return _FAIL;
+		if ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))
+			return _FAIL;
+		if (!memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    !memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
+			return _FAIL;
+		sta_addr = pattrib->src;
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		/* For Station mode, sa and bssid should always be BSSID,
+		 * and DA is my mac-address */
+		if (memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))
+			return _FAIL;
+	       sta_addr = pattrib->bssid;
+	 } else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		if (bmcast) {
+			/* For AP mode, if DA == MCAST, then BSSID should
+			 * be also MCAST */
+			if (!IS_MCAST(pattrib->bssid))
+				return _FAIL;
+		} else { /* not mc-frame */
+			/* For AP mode, if DA is non-MCAST, then it must be
+			 *  BSSID, and bssid == BSSID */
+			if (memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN))
+				return _FAIL;
+			sta_addr = pattrib->src;
+		}
+	  } else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		sta_addr = mybssid;
+	  } else
+		ret  = _FAIL;
+	if (bmcast)
+		*psta = r8712_get_bcmc_stainfo(adapter);
+	else
+		*psta = r8712_get_stainfo(pstapriv, sta_addr); /* get ap_info */
+	if (*psta == NULL) {
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+			adapter->mppriv.rx_pktloss++;
+		return _FAIL;
+	}
+	return ret;
+}
+
+static sint ap2sta_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame,
+			      struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	     && (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		/* if NULL-frame, drop packet */
+		if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
+			return _FAIL;
+		/* drop QoS-SubType Data, including QoS NULL,
+		 * excluding QoS-Data */
+		if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) ==
+		     WIFI_QOS_DATA_TYPE) {
+			if (GetFrameSubType(ptr) & (BIT(4) | BIT(5) | BIT(6)))
+				return _FAIL;
+		}
+
+		/* filter packets that SA is myself or multicast or broadcast */
+	       if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))
+			return _FAIL;
+
+		/* da should be for me */
+		if ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))
+			return _FAIL;
+		/* check BSSID */
+		if (!memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     !memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
+			return _FAIL;
+		if (bmcast)
+			*psta = r8712_get_bcmc_stainfo(adapter);
+		else
+		       *psta = r8712_get_stainfo(pstapriv, pattrib->bssid);
+		if (*psta == NULL)
+			return _FAIL;
+	} else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+		*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);
+		if (*psta == NULL)
+			return _FAIL;
+	} else
+		return _FAIL;
+	return _SUCCESS;
+}
+
+static sint sta2ap_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame,
+			      struct sta_info **psta)
+{
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	unsigned char *mybssid  = get_bssid(pmlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		/* For AP mode, if DA is non-MCAST, then it must be BSSID,
+		 * and bssid == BSSID
+		 * For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
+		if (memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+			return _FAIL;
+		*psta = r8712_get_stainfo(pstapriv, pattrib->src);
+		if (*psta == NULL)
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+static sint validate_recv_ctrl_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	return _FAIL;
+}
+
+static sint validate_recv_mgnt_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	return _FAIL;
+}
+
+
+static sint validate_recv_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	int res;
+	u8 bretry;
+	u8 *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+	if (pbssid == NULL)
+		return _FAIL;
+	memcpy(pattrib->dst, pda, ETH_ALEN);
+	memcpy(pattrib->src, psa, ETH_ALEN);
+	memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+	switch (pattrib->to_fr_ds) {
+	case 0:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		res = sta2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 1:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, pbssid, ETH_ALEN);
+		res = ap2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 2:
+		memcpy(pattrib->ra, pbssid, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		res = sta2ap_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 3:
+		memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+		return _FAIL;
+	default:
+		return _FAIL;
+	}
+	if (res == _FAIL)
+		return _FAIL;
+	if (psta == NULL)
+		return _FAIL;
+	else
+		precv_frame->u.hdr.psta = psta;
+	pattrib->amsdu = 0;
+	/* parsing QC field */
+	if (pattrib->qos == 1) {
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy = GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));
+		pattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;
+	} else {
+		pattrib->priority = 0;
+		pattrib->hdrlen = (pattrib->to_fr_ds == 3) ? 30 : 24;
+	}
+
+	if (pattrib->order)/*HT-CTRL 11n*/
+		pattrib->hdrlen += 4;
+	precv_frame->u.hdr.preorder_ctrl =
+			 &psta->recvreorder_ctrl[pattrib->priority];
+
+	/* decache, drop duplicate recv packets */
+	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==
+	    _FAIL)
+		return _FAIL;
+
+	if (pattrib->privacy) {
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,
+			       IS_MCAST(pattrib->ra));
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len,
+			       pattrib->encrypt);
+	} else {
+		pattrib->encrypt = 0;
+		pattrib->iv_len = pattrib->icv_len = 0;
+	}
+	return _SUCCESS;
+}
+
+sint r8712_validate_recv_frame(struct _adapter *adapter,
+			       union recv_frame *precv_frame)
+{
+	/*shall check frame subtype, to / from ds, da, bssid */
+	/*then call check if rx seq/frag. duplicated.*/
+
+	u8 type;
+	u8 subtype;
+	sint retval = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	u8  ver = (unsigned char)(*ptr) & 0x3;
+
+	/*add version chk*/
+	if (ver != 0)
+		return _FAIL;
+	type =  GetFrameType(ptr);
+	subtype = GetFrameSubType(ptr); /*bit(7)~bit(2)*/
+	pattrib->to_fr_ds = get_tofr_ds(ptr);
+	pattrib->frag_num = GetFragNum(ptr);
+	pattrib->seq_num = GetSequence(ptr);
+	pattrib->pw_save = GetPwrMgt(ptr);
+	pattrib->mfrag = GetMFrag(ptr);
+	pattrib->mdata = GetMData(ptr);
+	pattrib->privacy =  GetPrivacy(ptr);
+	pattrib->order = GetOrder(ptr);
+	switch (type) {
+	case WIFI_MGT_TYPE: /*mgnt*/
+		retval = validate_recv_mgnt_frame(adapter, precv_frame);
+		break;
+	case WIFI_CTRL_TYPE:/*ctrl*/
+		retval = validate_recv_ctrl_frame(adapter, precv_frame);
+		break;
+	case WIFI_DATA_TYPE: /*data*/
+		pattrib->qos = (subtype & BIT(7)) ? 1 : 0;
+		retval = validate_recv_data_frame(adapter, precv_frame);
+		break;
+	default:
+		return _FAIL;
+	}
+	return retval;
+}
+
+sint r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe)
+{
+	/*remove the wlanhdr and add the eth_hdr*/
+	sint	rmv_len;
+	u16	eth_type, len;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr *psnap;
+
+	sint ret = _SUCCESS;
+	struct _adapter	*adapter = precvframe->u.hdr.adapter;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	u8 *ptr = get_recvframe_data(precvframe); /*point to frame_ctrl field*/
+	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;
+
+	if (pattrib->encrypt)
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+	psnap = (struct ieee80211_snap_hdr *)(ptr + pattrib->hdrlen +
+		 pattrib->iv_len);
+	psnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	if ((!memcmp(psnap, (void *)rfc1042_header, SNAP_SIZE) &&
+	    (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_IPX, 2)) &&
+	    (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_APPLETALK_AARP, 2))) ||
+	     !memcmp(psnap, (void *)bridge_tunnel_header, SNAP_SIZE)) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and
+		 * replace EtherType */
+		bsnaphdr = true;
+	} else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = false;
+	}
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +
+		  (bsnaphdr ? SNAP_SIZE : 0);
+	len = precvframe->u.hdr.len - rmv_len;
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		ptr += rmv_len;
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+		eth_type = 0x8712;
+		/* append rx status for mp test packets */
+		ptr = recvframe_pull(precvframe, (rmv_len -
+		      sizeof(struct ethhdr) + 2) - 24);
+		memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr += 24;
+	} else
+		ptr = recvframe_pull(precvframe, (rmv_len -
+		      sizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));
+
+	memcpy(ptr, pattrib->dst, ETH_ALEN);
+	memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+	if (!bsnaphdr) {
+		len = htons(len);
+		memcpy(ptr + 12, &len, 2);
+	}
+	return ret;
+}
+
+s32 r8712_recv_entry(union recv_frame *precvframe)
+{
+	struct _adapter *padapter;
+	struct recv_priv *precvpriv;
+	struct	mlme_priv *pmlmepriv;
+	struct recv_stat *prxstat;
+	struct dvobj_priv *pdev;
+	u8 *phead, *pdata, *ptail, *pend;
+
+	struct  __queue *pfree_recv_queue, *ppending_recv_queue;
+	s32 ret = _SUCCESS;
+	struct intf_hdl *pintfhdl;
+
+	padapter = precvframe->u.hdr.adapter;
+	pintfhdl = &padapter->pio_queue->intf;
+	pmlmepriv = &padapter->mlmepriv;
+	precvpriv = &(padapter->recvpriv);
+	pdev = &padapter->dvobjpriv;
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	ppending_recv_queue = &(precvpriv->recv_pending_queue);
+	phead = precvframe->u.hdr.rx_head;
+	pdata = precvframe->u.hdr.rx_data;
+	ptail = precvframe->u.hdr.rx_tail;
+	pend = precvframe->u.hdr.rx_end;
+	prxstat = (struct recv_stat *)phead;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);
+
+	ret = recv_func(padapter, precvframe);
+	if (ret == _FAIL)
+		goto _recv_entry_drop;
+	precvpriv->rx_pkts++;
+	precvpriv->rx_bytes += (uint)(precvframe->u.hdr.rx_tail -
+				precvframe->u.hdr.rx_data);
+	return ret;
+_recv_entry_drop:
+	precvpriv->rx_drop++;
+	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
+	return ret;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_recv.h b/drivers/staging/rtl8712/rtl871x_recv.h
new file mode 100644
index 0000000..cc7a72f
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_recv.h
@@ -0,0 +1,330 @@
+#ifndef _RTL871X_RECV_H_
+#define _RTL871X_RECV_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define NR_RECVFRAME 256
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1 << RXFRAME_ALIGN)
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+#define MAX_SUBFRAME_COUNT	64
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+/* for Rx reordering buffer control */
+struct recv_reorder_ctrl {
+	struct _adapter	*padapter;
+	u16 indicate_seq; /* =wstart_b, init_value=0xffff */
+	u16 wend_b;
+	u8 wsize_b;
+	struct  __queue pending_recvframe_queue;
+	struct timer_list reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16	tid_rxseq[16];
+};
+
+#define		PHY_RSSI_SLID_WIN_MAX			100
+#define		PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	/* array to store values */
+	u32	index;		/* index to current array to store */
+	u32	total_num;	/* num of valid elements */
+	u32	total_val;	/* sum of valid elements */
+};
+
+struct rx_pkt_attrib {
+
+	u8	amsdu;
+	u8	order;
+	u8	qos;
+	u8	to_fr_ds;
+	u8	frag_num;
+	u16	seq_num;
+	u8   pw_save;
+	u8    mfrag;
+	u8    mdata;
+	u8	privacy; /* in frame_ctrl field */
+	u8	bdecrypted;
+	int	hdrlen;	 /* the WLAN Header Len */
+	int	encrypt; /* 0 no encrypt. != 0 encrypt algorith */
+	int	iv_len;
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+	u8	crc_err;
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	bssid[ETH_ALEN];
+	u8	tcpchk_valid; /* 0: invalid, 1: valid */
+	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
+	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	u8	mcs_rate;
+	u8	htc;
+	u8	signal_strength;
+};
+
+/*
+accesser of recv_priv: recv_entry(dispatch / passive level);
+recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv {
+	spinlock_t lock;
+	struct semaphore recv_sema;
+	struct semaphore terminate_recvthread_sema;
+	struct  __queue	free_recv_queue;
+	struct  __queue	recv_pending_queue;
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf;
+	uint free_recvframe_cnt;
+	struct _adapter	*adapter;
+	uint	rx_bytes;
+	uint	rx_pkts;
+	uint	rx_drop;
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+	struct semaphore allrxreturnevt;
+	u8  rx_pending_cnt;
+	uint	ff_hwaddr;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    /* 4 alignment */
+	struct  __queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+	/* For the phy informatiom */
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 fw_rssi;
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+};
+
+struct sta_recv_priv {
+	spinlock_t lock;
+	sint	option;
+	struct  __queue defrag_q; /* keeping the fragment frame until defrag */
+	struct	stainfo_rxcache rxcache;
+	uint	sta_rx_bytes;
+	uint	sta_rx_pkts;
+	uint	sta_rx_fail;
+};
+
+#include "rtl8712_recv.h"
+
+/* get a free recv_frame from pfree_recv_queue */
+union recv_frame *r8712_alloc_recvframe(struct  __queue *pfree_recv_queue);
+union recv_frame *r8712_dequeue_recvframe(struct  __queue *queue);
+int r8712_enqueue_recvframe(union recv_frame *precvframe,
+			     struct  __queue *queue);
+int r8712_free_recvframe(union recv_frame *precvframe,
+			  struct  __queue *pfree_recv_queue);
+void r8712_free_recvframe_queue(struct  __queue *pframequeue,
+				 struct  __queue *pfree_recv_queue);
+void r8712_init_recvframe(union recv_frame *precvframe,
+			   struct recv_priv *precvpriv);
+int r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe);
+int recv_func(struct _adapter *padapter, void *pcontext);
+
+static inline u8 *get_rxmem(union recv_frame *precvframe)
+{
+	/* always return rx_head... */
+	if (precvframe == NULL)
+		return NULL;
+	return precvframe->u.hdr.rx_head;
+}
+
+static inline u8 *get_rx_status(union recv_frame *precvframe)
+{
+	return get_rxmem(precvframe);
+}
+
+static inline u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+	/* always return rx_data */
+	if (precvframe == NULL)
+		return NULL;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{
+	/* append data before rx_data */
+
+	/* add data to the start of recv_frame
+	 *
+	 * This function extends the used data area of the recv_frame at the
+	 * buffer start. rx_data must be still larger than rx_head, after
+	 * pushing.
+	 */
+
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_data -= sz ;
+	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head) {
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+	precvframe->u.hdr.len += sz;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	/* used for extract sz bytes from rx_data, update rx_data and return
+	 *  the updated rx_data to the caller */
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_data += sz;
+	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len -= sz;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_put(union recv_frame *precvframe, sint sz)
+{
+	/* used for append sz bytes from ptr to rx_tail, update rx_tail and
+	 * return the updated rx_tail to the caller
+	 * after putting, rx_tail must be still larger than rx_end. */
+	unsigned char *prev_rx_tail;
+
+	if (precvframe == NULL)
+		return NULL;
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+	precvframe->u.hdr.rx_tail += sz;
+	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len += sz;
+	return precvframe->u.hdr.rx_tail;
+}
+
+static inline u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	/* rmv data from rx_tail (by yitsen)
+	 * used for extract sz bytes from rx_end, update rx_end and return the
+	 * updated rx_end to the caller
+	 * after pulling, rx_end must be still larger than rx_data. */
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_tail -= sz;
+	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len -= sz;
+	return precvframe->u.hdr.rx_tail;
+}
+
+static inline _buffer *get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer *buf_desc;
+	if (precvframe == NULL)
+		return NULL;
+	return buf_desc;
+}
+
+static inline union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	/* due to the design of 2048 bytes alignment of recv_frame, we can
+	 * reference the union recv_frame from any given member of recv_frame.
+	 * rxmem indicates the any member/address in recv_frame */
+	return (union recv_frame *)(((addr_t)rxmem >> RXFRAME_ALIGN) <<
+				  RXFRAME_ALIGN);
+}
+
+static inline union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+	u8 *buf_star;
+	union recv_frame *precv_frame;
+
+	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);
+	return precv_frame;
+}
+
+static inline u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	/* return the rx_head */
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_head;
+}
+
+static inline u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	/* return the rx_data */
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_data;
+}
+
+static inline sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+struct sta_info;
+
+void	_r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+sint r8712_recvframe_chkmic(struct _adapter *adapter,
+			    union recv_frame *precvframe);
+union recv_frame *r8712_decryptor(struct _adapter *adapter,
+				  union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_chk_defrag(struct _adapter *adapter,
+					     union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_defrag(struct _adapter *adapter,
+					 struct  __queue *defrag_q);
+union recv_frame *r8712_recvframe_chk_defrag_new(struct _adapter *adapter,
+					union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_defrag_new(struct _adapter *adapter,
+					struct  __queue *defrag_q,
+					union recv_frame *precv_frame);
+int r8712_recv_decache(union recv_frame *precv_frame, u8 bretry,
+		       struct stainfo_rxcache *prxcache);
+int r8712_sta2sta_data_frame(struct _adapter *adapter,
+			     union recv_frame *precv_frame,
+			     struct sta_info **psta);
+int r8712_ap2sta_data_frame(struct _adapter *adapter,
+			    union recv_frame *precv_frame,
+			    struct sta_info **psta);
+int r8712_sta2ap_data_frame(struct _adapter *adapter,
+			    union recv_frame *precv_frame,
+			    struct sta_info **psta);
+int r8712_validate_recv_ctrl_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_mgnt_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_data_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame);
+union recv_frame *r8712_portctrl(struct _adapter *adapter,
+				 union recv_frame *precv_frame);
+void  r8712_mgt_dispatcher(struct _adapter *padapter, u8 *pframe, uint len);
+int r8712_amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_rf.h b/drivers/staging/rtl8712/rtl871x_rf.h
new file mode 100644
index 0000000..133ed64
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_rf.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__RTL871X_RF_H_
+#define __RTL871X_RF_H_
+
+#include "rtl871x_cmd.h"
+#include "rtl871x_mp_phy_regdef.h"
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+#define NumRates	(13)
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+#define NUM_CHANNELS	15
+
+struct	regulatory_class {
+	u32	starting_freq;		/*MHz, */
+	u8	channel_set[NUM_CHANNELS];
+	u8	channel_cck_power[NUM_CHANNELS]; /*dbm*/
+	u8	channel_ofdm_power[NUM_CHANNELS];/*dbm*/
+	u8	txpower_limit;		/*dbm*/
+	u8	channel_spacing;	/*MHz*/
+	u8	modem;
+};
+
+enum	_REG_PREAMBLE_MODE {
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+enum {
+	RTL8712_RFC_1T = 0x10,
+	RTL8712_RFC_2T = 0x20,
+	RTL8712_RFC_1R = 0x01,
+	RTL8712_RFC_2R = 0x02,
+	RTL8712_RFC_1T1R = 0x11,
+	RTL8712_RFC_1T2R = 0x12,
+	RTL8712_RFC_TURBO = 0x92,
+	RTL8712_RFC_2T2R = 0x22
+};
+
+#endif /*_RTL8711_RF_H_*/
+
diff --git a/drivers/staging/rtl8712/rtl871x_security.c b/drivers/staging/rtl8712/rtl871x_security.c
new file mode 100644
index 0000000..8437cc2
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_security.c
@@ -0,0 +1,1404 @@
+/******************************************************************************
+ * rtl871x_security.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define  _RTL871X_SECURITY_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+
+/* =====WEP related===== */
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context {
+	u32 x;
+	u32 y;
+	u8 state[256];
+};
+
+static void arcfour_init(struct arc4context *parc4ctx, u8 * key, u32 key_len)
+{
+	u32	t, u;
+	u32	keyindex;
+	u32	stateindex;
+	u8 *state;
+	u32	counter;
+
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (u8)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++) {
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (u8)t;
+		state[counter] = (u8)u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+}
+
+static u32 arcfour_byte(struct arc4context *parc4ctx)
+{
+	u32 x;
+	u32 y;
+	u32 sx, sy;
+	u8 *state;
+
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (u8)sx;
+	state[x] = (u8)sy;
+	return state[(sx + sy) & 0xff];
+}
+
+static void arcfour_encrypt(struct arc4context	*parc4ctx,
+		     u8 *dest, u8 *src, u32 len)
+{
+	u32 i;
+
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+}
+
+static sint bcrc32initialized;
+static u32 crc32_table[256];
+
+static u8 crc32_reverseBit(u8 data)
+{
+	return ((u8)(data << 7) & 0x80) | ((data << 5) & 0x40) | ((data << 3)
+		 & 0x20) | ((data << 1) & 0x10) | ((data >> 1) & 0x08) |
+		 ((data >> 3) & 0x04) | ((data >> 5) & 0x02) | ((data >> 7) &
+		 0x01);
+}
+
+static void crc32_init(void)
+{
+	if (bcrc32initialized == 1)
+		return;
+	else {
+		sint i, j;
+		u32 c;
+		u8 *p = (u8 *)&c, *p1;
+		u8 k;
+
+		c = 0x12340000;
+		for (i = 0; i < 256; ++i) {
+			k = crc32_reverseBit((u8)i);
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j)
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY :
+				    (c << 1);
+			p1 = (u8 *)&crc32_table[i];
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized = 1;
+	}
+}
+
+static u32 getcrc32(u8 *buf, u32 len)
+{
+	u8 *p;
+	u32  crc;
+
+	if (bcrc32initialized == 0)
+		crc32_init();
+	crc = 0xffffffff; /* preload shift register, per CRC-32 spec */
+	for (p = buf; len > 0; ++p, --len)
+		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
+	return ~crc;    /* transmit complement, per CRC-32 spec */
+}
+
+/*
+	Need to consider the fragment  situation
+*/
+void r8712_wep_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/* exclude ICV */
+	unsigned char	crc[4];
+	struct arc4context  mycontext;
+	u32 curfragnum, length, keylength;
+	u8 *pframe, *payload, *iv;    /*,*wepkey*/
+	u8 wepkey[16];
+	struct	pkt_attrib  *pattrib = &((struct xmit_frame *)
+				       pxmitframe)->attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return;
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;
+	/*start to encrypt each fragment*/
+	if ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {
+		keylength = psecuritypriv->DefKeylen[psecuritypriv->
+			    PrivacyKeyIndex];
+		for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+		     curfragnum++) {
+			iv = pframe+pattrib->hdrlen;
+			memcpy(&wepkey[0], iv, 3);
+			memcpy(&wepkey[3], &psecuritypriv->DefKey[
+				psecuritypriv->PrivacyKeyIndex].skey[0],
+				keylength);
+			payload = pframe+pattrib->iv_len+pattrib->hdrlen;
+			if ((curfragnum + 1) == pattrib->nr_frags) {
+				length = pattrib->last_txcmdsz-pattrib->
+					 hdrlen-pattrib->iv_len -
+					 pattrib->icv_len;
+				*((u32 *)crc) = cpu_to_le32(getcrc32(
+						payload, length));
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload + length,
+						crc, 4);
+			} else {
+				length = pxmitpriv->frag_len-pattrib->hdrlen -
+					 pattrib->iv_len-pattrib->icv_len;
+				*((u32 *)crc) = cpu_to_le32(getcrc32(
+						payload, length));
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload+length,
+						crc, 4);
+				pframe += pxmitpriv->frag_len;
+				pframe = (u8 *)RND4((addr_t)(pframe));
+			}
+		}
+	}
+}
+
+void r8712_wep_decrypt(struct _adapter  *padapter, u8 *precvframe)
+{
+	/* exclude ICV */
+	u8 crc[4];
+	struct arc4context  mycontext;
+	u32 length, keylength;
+	u8 *pframe, *payload, *iv, wepkey[16];
+	u8  keyindex;
+	struct rx_pkt_attrib  *prxattrib = &(((union recv_frame *)
+					  precvframe)->u.hdr.attrib);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame *)precvframe)->
+		  u.hdr.rx_data;
+	/* start to decrypt recvframe */
+	if ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt ==
+	     _WEP104_)) {
+		iv = pframe + prxattrib->hdrlen;
+		keyindex = (iv[3] & 0x3);
+		keylength = psecuritypriv->DefKeylen[keyindex];
+		memcpy(&wepkey[0], iv, 3);
+		memcpy(&wepkey[3], &psecuritypriv->DefKey[
+			psecuritypriv->PrivacyKeyIndex].skey[0],
+			keylength);
+		length = ((union recv_frame *)precvframe)->
+			   u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+		payload = pframe+prxattrib->iv_len+prxattrib->hdrlen;
+		/* decrypt payload include icv */
+		arcfour_init(&mycontext, wepkey, 3 + keylength);
+		arcfour_encrypt(&mycontext, payload, payload,  length);
+		/* calculate icv and compare the icv */
+		*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length - 4));
+	}
+	return;
+}
+
+/* 3 =====TKIP related===== */
+
+static u32 secmicgetuint32(u8 *p)
+/* Convert from Byte[] to Us4Byte32 in a portable way */
+{
+	s32 i;
+	u32 res = 0;
+
+	for (i = 0; i < 4; i++)
+		res |= ((u32)(*p++)) << (8 * i);
+	return res;
+}
+
+static void secmicputuint32(u8 *p, u32 val)
+/* Convert from Us4Byte32 to Byte[] in a portable way */
+{
+	long i;
+	for (i = 0; i < 4; i++) {
+		*p++ = (u8) (val & 0xff);
+		val >>= 8;
+	}
+}
+
+static void secmicclear(struct mic_data *pmicdata)
+{
+/* Reset the state to the empty message. */
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+}
+
+void r8712_secmicsetkey(struct mic_data *pmicdata, u8 * key)
+{
+	/* Set the key */
+	pmicdata->K0 = secmicgetuint32(key);
+	pmicdata->K1 = secmicgetuint32(key + 4);
+	/* and reset the message */
+	secmicclear(pmicdata);
+}
+
+static void secmicappendbyte(struct mic_data *pmicdata, u8 b)
+{
+	/* Append the byte to our word-sized buffer */
+	pmicdata->M |= ((u32)b) << (8 * pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	/* Process the word if it is full. */
+	if (pmicdata->nBytesInM >= 4) {
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32(pmicdata->L, 17);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) |
+			       ((pmicdata->L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32(pmicdata->L, 3);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32(pmicdata->L, 2);
+		pmicdata->L += pmicdata->R;
+		/* Clear the buffer */
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+}
+
+void r8712_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes)
+{
+	/* This is simple */
+	while (nbytes > 0) {
+		secmicappendbyte(pmicdata, *src++);
+		nbytes--;
+	}
+}
+
+void r8712_secgetmic(struct mic_data *pmicdata, u8 *dst)
+{
+	/* Append the minimum padding */
+	secmicappendbyte(pmicdata, 0x5a);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	/* and then zeroes until the length is a multiple of 4 */
+	while (pmicdata->nBytesInM != 0)
+		secmicappendbyte(pmicdata, 0);
+	/* The appendByte function has already computed the result. */
+	secmicputuint32(dst, pmicdata->L);
+	secmicputuint32(dst + 4, pmicdata->R);
+	/* Reset to the empty message. */
+	secmicclear(pmicdata);
+}
+
+void seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code,
+		    u8 pri)
+{
+
+	struct mic_data	micdata;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
+
+	r8712_secmicsetkey(&micdata, key);
+	priority[0] = pri;
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if (header[1] & 1) {   /* ToDS==1 */
+		r8712_secmicappend(&micdata, &header[16], 6);  /* DA */
+		if (header[1] & 2)  /* From Ds==1 */
+			r8712_secmicappend(&micdata, &header[24], 6);
+		else
+			r8712_secmicappend(&micdata, &header[10], 6);
+	} else {	/* ToDS==0 */
+		r8712_secmicappend(&micdata, &header[4], 6);   /* DA */
+		if (header[1] & 2)  /* From Ds==1 */
+			r8712_secmicappend(&micdata, &header[16], 6);
+		else
+			r8712_secmicappend(&micdata, &header[10], 6);
+	}
+	r8712_secmicappend(&micdata, &priority[0], 4);
+	r8712_secmicappend(&micdata, data, data_len);
+	r8712_secgetmic(&micdata, mic_code);
+}
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((u8)((v16) & 0x00FF))
+#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)((v32) & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >> 16) & 0xFFFF))
+#define  Mk16(hi, lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)  Mk16(tk[2 * (N) + 1], tk[2 * (N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)  (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8    /* this needs to be "big enough"     */
+#define TA_SIZE           6    /*  48-bit transmitter address       */
+#define TK_SIZE          16    /* 128-bit temporal key              */
+#define P1K_SIZE         10    /*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16    /* 128-bit RC4KEY (104 bits unknown) */
+
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+static const unsigned short Sbox1[2][256] = {/* Sbox for hash (can be in ROM) */
+	{
+	0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,
+	0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,
+	0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,
+	0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,
+	0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,
+	0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,
+	0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,
+	0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,
+	0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,
+	0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,
+	0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,
+	0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,
+	0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,
+	0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,
+	0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,
+	0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,
+	0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,
+	0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,
+	0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,
+	0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,
+	0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,
+	0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,
+	0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,
+	0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,
+	0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,
+	0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,
+	0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,
+	0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,
+	0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,
+	0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,
+	0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,
+	0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,
+	},
+	{  /* second half is unsigned char-reversed version of first! */
+	0xA5C6, 0x84F8, 0x99EE, 0x8DF6, 0x0DFF, 0xBDD6, 0xB1DE, 0x5491,
+	0x5060, 0x0302, 0xA9CE, 0x7D56, 0x19E7, 0x62B5, 0xE64D, 0x9AEC,
+	0x458F, 0x9D1F, 0x4089, 0x87FA, 0x15EF, 0xEBB2, 0xC98E, 0x0BFB,
+	0xEC41, 0x67B3, 0xFD5F, 0xEA45, 0xBF23, 0xF753, 0x96E4, 0x5B9B,
+	0xC275, 0x1CE1, 0xAE3D, 0x6A4C, 0x5A6C, 0x417E, 0x02F5, 0x4F83,
+	0x5C68, 0xF451, 0x34D1, 0x08F9, 0x93E2, 0x73AB, 0x5362, 0x3F2A,
+	0x0C08, 0x5295, 0x6546, 0x5E9D, 0x2830, 0xA137, 0x0F0A, 0xB52F,
+	0x090E, 0x3624, 0x9B1B, 0x3DDF, 0x26CD, 0x694E, 0xCD7F, 0x9FEA,
+	0x1B12, 0x9E1D, 0x7458, 0x2E34, 0x2D36, 0xB2DC, 0xEEB4, 0xFB5B,
+	0xF6A4, 0x4D76, 0x61B7, 0xCE7D, 0x7B52, 0x3EDD, 0x715E, 0x9713,
+	0xF5A6, 0x68B9, 0x0000, 0x2CC1, 0x6040, 0x1FE3, 0xC879, 0xEDB6,
+	0xBED4, 0x468D, 0xD967, 0x4B72, 0xDE94, 0xD498, 0xE8B0, 0x4A85,
+	0x6BBB, 0x2AC5, 0xE54F, 0x16ED, 0xC586, 0xD79A, 0x5566, 0x9411,
+	0xCF8A, 0x10E9, 0x0604, 0x81FE, 0xF0A0, 0x4478, 0xBA25, 0xE34B,
+	0xF3A2, 0xFE5D, 0xC080, 0x8A05, 0xAD3F, 0xBC21, 0x4870, 0x04F1,
+	0xDF63, 0xC177, 0x75AF, 0x6342, 0x3020, 0x1AE5, 0x0EFD, 0x6DBF,
+	0x4C81, 0x1418, 0x3526, 0x2FC3, 0xE1BE, 0xA235, 0xCC88, 0x392E,
+	0x5793, 0xF255, 0x82FC, 0x477A, 0xACC8, 0xE7BA, 0x2B32, 0x95E6,
+	0xA0C0, 0x9819, 0xD19E, 0x7FA3, 0x6644, 0x7E54, 0xAB3B, 0x830B,
+	0xCA8C, 0x29C7, 0xD36B, 0x3C28, 0x79A7, 0xE2BC, 0x1D16, 0x76AD,
+	0x3BDB, 0x5664, 0x4E74, 0x1E14, 0xDB92, 0x0A0C, 0x6C48, 0xE4B8,
+	0x5D9F, 0x6EBD, 0xEF43, 0xA6C4, 0xA839, 0xA431, 0x37D3, 0x8BF2,
+	0x32D5, 0x438B, 0x596E, 0xB7DA, 0x8C01, 0x64B1, 0xD29C, 0xE049,
+	0xB4D8, 0xFAAC, 0x07F3, 0x25CF, 0xAFCA, 0x8EF4, 0xE947, 0x1810,
+	0xD56F, 0x88F0, 0x6F4A, 0x725C, 0x2438, 0xF157, 0xC773, 0x5197,
+	0x23CB, 0x7CA1, 0x9CE8, 0x213E, 0xDD96, 0xDC61, 0x860D, 0x850F,
+	0x90E0, 0x427C, 0xC471, 0xAACC, 0xD890, 0x0506, 0x01F7, 0x121C,
+	0xA3C2, 0x5F6A, 0xF9AE, 0xD069, 0x9117, 0x5899, 0x273A, 0xB927,
+	0x38D9, 0x13EB, 0xB32B, 0x3322, 0xBBD2, 0x70A9, 0x8907, 0xA733,
+	0xB62D, 0x223C, 0x9215, 0x20C9, 0x4987, 0xFFAA, 0x7850, 0x7AA5,
+	0x8F03, 0xF859, 0x8009, 0x171A, 0xDA65, 0x31D7, 0xC684, 0xB8D0,
+	0xC382, 0xB029, 0x775A, 0x111E, 0xCB7B, 0xFCA8, 0xD66D, 0x3A2C,
+	}
+};
+
+/*
+**********************************************************************
+* Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+*
+* Inputs:
+*     tk[]      = temporal key                         [128 bits]
+*     ta[]      = transmitter's MAC address            [ 48 bits]
+*     iv32      = upper 32 bits of IV                  [ 32 bits]
+* Output:
+*     p1k[]     = Phase 1 key                          [ 80 bits]
+*
+* Note:
+*     This function only needs to be called every 2**16 packets,
+*     although in theory it could be called every packet.
+*
+**********************************************************************
+*/
+static void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)
+{
+	sint  i;
+
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0] = Lo16(iv32);
+	p1k[1] = Hi16(iv32);
+	p1k[2] = Mk16(ta[1], ta[0]); /* use TA[] as little-endian */
+	p1k[3] = Mk16(ta[3], ta[2]);
+	p1k[4] = Mk16(ta[5], ta[4]);
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i = 0; i < PHASE1_LOOP_CNT; i++) {  /* Each add is mod 2**16 */
+		p1k[0] += _S_(p1k[4] ^ TK16((i&1) + 0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i&1) + 2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i&1) + 4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i&1) + 6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i&1) + 0));
+		p1k[4] +=  (unsigned short)i;	/* avoid "slide attacks" */
+	}
+}
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [ 80 bits]
+*     iv16      = low 16 bits of IV counter            [ 16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA,IV32,IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+static void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)
+{
+	sint  i;
+	u16 PPK[6];			/* temporary key for mixing    */
+
+	/* Note: all adds in the PPK[] equations below are mod 2**16 */
+	for (i = 0; i < 5; i++)
+		PPK[i] = p1k[i]; /* first, copy P1K to PPK */
+	PPK[5]  =  p1k[4] + iv16; /* next,  add in IV16 */
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5] */
+	PPK[0] += _S_(PPK[5] ^ TK16(0));   /* Mix key in each "round" */
+	PPK[1] += _S_(PPK[0] ^ TK16(1));
+	PPK[2] += _S_(PPK[1] ^ TK16(2));
+	PPK[3] += _S_(PPK[2] ^ TK16(3));
+	PPK[4] += _S_(PPK[3] ^ TK16(4));
+	PPK[5] += _S_(PPK[4] ^ TK16(5));   /* Total # S-box lookups == 6  */
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] +=  RotR1(PPK[5] ^ TK16(6));
+	PPK[1] +=  RotR1(PPK[0] ^ TK16(7));   /* Use all of TK[] in Phase2   */
+	PPK[2] +=  RotR1(PPK[1]);
+	PPK[3] +=  RotR1(PPK[2]);
+	PPK[4] +=  RotR1(PPK[3]);
+	PPK[5] +=  RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/* value PPK[0..5] is guaranteed to be unique, as a function   */
+	/* of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  */
+	/* is now a keyed permutation of {TA,IV32,IV16}. */
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16); /* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] = (Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian) */
+	for (i = 0; i < 6; i++) {
+		rc4key[4 + 2 * i] = Lo8(PPK[i]);
+		rc4key[5 + 2 * i] = Hi8(PPK[i]);
+	}
+}
+
+/*The hlen isn't include the IV*/
+u32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/*  exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	u32 curfragnum, length, prwskeylen;
+
+	u8 *pframe, *payload, *iv, *prwskey;
+	union pn48 txpn;
+	struct sta_info *stainfo;
+	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;
+	/* 4 start to encrypt each fragment */
+	if (pattrib->encrypt == _TKIP_) {
+		if (pattrib->psta)
+			stainfo = pattrib->psta;
+		else
+			stainfo = r8712_get_stainfo(&padapter->stapriv,
+				  &pattrib->ra[0]);
+		if (stainfo != NULL) {
+			prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				iv = pframe + pattrib->hdrlen;
+				payload = pframe+pattrib->iv_len +
+					  pattrib->hdrlen;
+				GET_TKIP_PN(iv, txpn);
+				pnl = (u16)(txpn.val);
+				pnh = (u32)(txpn.val >> 16);
+				phase1((u16 *)&ttkey[0], prwskey, &pattrib->
+				       ta[0], pnh);
+				phase2(&rc4key[0], prwskey, (u16 *)&ttkey[0],
+				       pnl);
+				if ((curfragnum + 1) == pattrib->nr_frags) {
+					/* 4 the last fragment */
+					length = pattrib->last_txcmdsz -
+					     pattrib->hdrlen-pattrib->iv_len -
+					     pattrib->icv_len;
+					*((u32 *)crc) = cpu_to_le32(
+						getcrc32(payload, length));
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							payload, length);
+					arcfour_encrypt(&mycontext, payload +
+							length, crc, 4);
+				} else {
+					length = pxmitpriv->frag_len-pattrib->
+						 hdrlen-pattrib->
+						 iv_len-pattrib->icv_len;
+					*((u32 *)crc) = cpu_to_le32(getcrc32(
+							payload, length));
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							 payload, length);
+					arcfour_encrypt(&mycontext,
+							payload+length, crc, 4);
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((addr_t)(pframe));
+				}
+			}
+		} else
+			res = _FAIL;
+	}
+	return res;
+}
+
+/* The hlen doesn't include the IV */
+u32 r8712_tkip_decrypt(struct _adapter *padapter, u8 *precvframe)
+{	/* exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	u32 length, prwskeylen;
+	u8 *pframe, *payload, *iv, *prwskey, idx = 0;
+	union pn48 txpn;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &((union recv_frame *)
+					   precvframe)->u.hdr.attrib;
+	struct	security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame *)
+				   precvframe)->u.hdr.rx_data;
+	/* 4 start to decrypt recvframe */
+	if (prxattrib->encrypt == _TKIP_) {
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			iv = pframe+prxattrib->hdrlen;
+			payload = pframe+prxattrib->iv_len + prxattrib->hdrlen;
+			length = ((union recv_frame *)precvframe)->
+				 u.hdr.len - prxattrib->hdrlen -
+				 prxattrib->iv_len;
+			if (IS_MCAST(prxattrib->ra)) {
+				idx = iv[3];
+				prwskey = &psecuritypriv->XGrpKey[
+					 ((idx >> 6) & 0x3) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+			} else
+				prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			GET_TKIP_PN(iv, txpn);
+			pnl = (u16)(txpn.val);
+			pnh = (u32)(txpn.val >> 16);
+			phase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0],
+				pnh);
+			phase2(&rc4key[0], prwskey, (unsigned short *)
+			       &ttkey[0], pnl);
+			/* 4 decrypt payload include icv */
+			arcfour_init(&mycontext, rc4key, 16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+			*((u32 *)crc) = cpu_to_le32(getcrc32(payload,
+					length - 4));
+			if (crc[3] != payload[length - 1] ||
+			    crc[2] != payload[length - 2] ||
+			    crc[1] != payload[length - 3] ||
+			    crc[0] != payload[length - 4])
+				return _FAIL;
+		} else
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+/* 3 =====AES related===== */
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+static const u8 sbox_table[256] = {
+	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+};
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+static void xor_128(u8 *a, u8 *b, u8 *out)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = a[i] ^ b[i];
+}
+
+static void xor_32(u8 *a, u8 *b, u8 *out)
+{
+	sint i;
+	for (i = 0; i < 4; i++)
+		out[i] = a[i] ^ b[i];
+}
+
+static u8 sbox(u8 a)
+{
+	return sbox_table[(sint)a];
+}
+
+static void next_key(u8 *key, sint round)
+{
+	u8 rcon;
+	u8 sbox_key[4];
+	u8 rcon_table[12] = {
+		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+		0x1b, 0x36, 0x36, 0x36
+	};
+
+	sbox_key[0] = sbox(key[13]);
+	sbox_key[1] = sbox(key[14]);
+	sbox_key[2] = sbox(key[15]);
+	sbox_key[3] = sbox(key[12]);
+	rcon = rcon_table[round];
+	xor_32(&key[0], sbox_key, &key[0]);
+	key[0] = key[0] ^ rcon;
+	xor_32(&key[4], &key[0], &key[4]);
+	xor_32(&key[8], &key[4], &key[8]);
+	xor_32(&key[12], &key[8], &key[12]);
+}
+
+static void byte_sub(u8 *in, u8 *out)
+{
+	sint i;
+	for (i = 0; i < 16; i++)
+		out[i] = sbox(in[i]);
+}
+
+static void shift_row(u8 *in, u8 *out)
+{
+	out[0] =  in[0];
+	out[1] =  in[5];
+	out[2] =  in[10];
+	out[3] =  in[15];
+	out[4] =  in[4];
+	out[5] =  in[9];
+	out[6] =  in[14];
+	out[7] =  in[3];
+	out[8] =  in[8];
+	out[9] =  in[13];
+	out[10] = in[2];
+	out[11] = in[7];
+	out[12] = in[12];
+	out[13] = in[1];
+	out[14] = in[6];
+	out[15] = in[11];
+}
+
+static void mix_column(u8 *in, u8 *out)
+{
+	sint i;
+	u8 add1b[4];
+	u8 add1bf7[4];
+	u8 rotl[4];
+	u8 swap_halfs[4];
+	u8 andf7[4];
+	u8 rotr[4];
+	u8 temp[4];
+	u8 tempb[4];
+
+	for (i = 0 ; i < 4; i++) {
+		if ((in[i] & 0x80) == 0x80)
+			add1b[i] = 0x1b;
+		else
+			add1b[i] = 0x00;
+	}
+	swap_halfs[0] = in[2];    /* Swap halves */
+	swap_halfs[1] = in[3];
+	swap_halfs[2] = in[0];
+	swap_halfs[3] = in[1];
+	rotl[0] = in[3];        /* Rotate left 8 bits */
+	rotl[1] = in[0];
+	rotl[2] = in[1];
+	rotl[3] = in[2];
+	andf7[0] = in[0] & 0x7f;
+	andf7[1] = in[1] & 0x7f;
+	andf7[2] = in[2] & 0x7f;
+	andf7[3] = in[3] & 0x7f;
+	for (i = 3; i > 0; i--) {   /* logical shift left 1 bit */
+		andf7[i] = andf7[i] << 1;
+		if ((andf7[i-1] & 0x80) == 0x80)
+			andf7[i] = (andf7[i] | 0x01);
+	}
+	andf7[0] = andf7[0] << 1;
+	andf7[0] = andf7[0] & 0xfe;
+	xor_32(add1b, andf7, add1bf7);
+	xor_32(in, add1bf7, rotr);
+	temp[0] = rotr[0];         /* Rotate right 8 bits */
+	rotr[0] = rotr[1];
+	rotr[1] = rotr[2];
+	rotr[2] = rotr[3];
+	rotr[3] = temp[0];
+	xor_32(add1bf7, rotr, temp);
+	xor_32(swap_halfs, rotl, tempb);
+	xor_32(temp, tempb, out);
+}
+
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
+{
+	sint round;
+	sint i;
+	u8 intermediatea[16];
+	u8 intermediateb[16];
+	u8 round_key[16];
+
+	for (i = 0; i < 16; i++)
+		round_key[i] = key[i];
+	for (round = 0; round < 11; round++) {
+		if (round == 0) {
+			xor_128(round_key, data, ciphertext);
+			next_key(round_key, round);
+		} else if (round == 10) {
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			xor_128(intermediateb, round_key, ciphertext);
+		} else {   /* 1 - 9 */
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			mix_column(&intermediateb[0], &intermediatea[0]);
+			mix_column(&intermediateb[4], &intermediatea[4]);
+			mix_column(&intermediateb[8], &intermediatea[8]);
+			mix_column(&intermediateb[12], &intermediatea[12]);
+			xor_128(intermediatea, round_key, ciphertext);
+			next_key(round_key, round);
+		}
+	}
+}
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+static void construct_mic_iv(u8 *mic_iv, sint qc_exists, sint a4_exists,
+			     u8 *mpdu, uint payload_length, u8 *pn_vector)
+{
+	sint i;
+
+	mic_iv[0] = 0x59;
+	if (qc_exists && a4_exists)
+		mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+	if (qc_exists && !a4_exists)
+		mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+	if (!qc_exists)
+		mic_iv[1] = 0x00;
+	for (i = 2; i < 8; i++)
+		mic_iv[i] = mpdu[i + 8];
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[13 - i]; /* mic_iv[8:13] = PN[5:0] */
+	mic_iv[14] = (unsigned char) (payload_length / 256);
+	mic_iv[15] = (unsigned char) (payload_length % 256);
+}
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header1(u8 *mic_header1, sint header_length, u8 *mpdu)
+{
+	mic_header1[0] = (u8)((header_length - 2) / 256);
+	mic_header1[1] = (u8)((header_length - 2) % 256);
+	mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
+	/* Mute retry, more data and pwr mgt bits */
+	mic_header1[3] = mpdu[1] & 0xc7;
+	mic_header1[4] = mpdu[4];       /* A1 */
+	mic_header1[5] = mpdu[5];
+	mic_header1[6] = mpdu[6];
+	mic_header1[7] = mpdu[7];
+	mic_header1[8] = mpdu[8];
+	mic_header1[9] = mpdu[9];
+	mic_header1[10] = mpdu[10];     /* A2 */
+	mic_header1[11] = mpdu[11];
+	mic_header1[12] = mpdu[12];
+	mic_header1[13] = mpdu[13];
+	mic_header1[14] = mpdu[14];
+	mic_header1[15] = mpdu[15];
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header2(u8 *mic_header2, u8 *mpdu, sint a4_exists,
+			   sint qc_exists)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		mic_header2[i] = 0x00;
+	mic_header2[0] = mpdu[16];    /* A3 */
+	mic_header2[1] = mpdu[17];
+	mic_header2[2] = mpdu[18];
+	mic_header2[3] = mpdu[19];
+	mic_header2[4] = mpdu[20];
+	mic_header2[5] = mpdu[21];
+	mic_header2[6] = 0x00;
+	mic_header2[7] = 0x00; /* mpdu[23]; */
+	if (!qc_exists && a4_exists)
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];   /* A4 */
+	if (qc_exists && !a4_exists) {
+		mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+		mic_header2[9] = mpdu[25] & 0x00;
+	}
+	if (qc_exists && a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];   /* A4 */
+		mic_header2[14] = mpdu[30] & 0x0f;
+		mic_header2[15] = mpdu[31] & 0x00;
+	}
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_ctr_preload(u8 *ctr_preload, sint a4_exists, sint qc_exists,
+			   u8 *mpdu, u8 *pn_vector, sint c)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		ctr_preload[i] = 0x00;
+	i = 0;
+	ctr_preload[0] = 0x01;    /* flag */
+	if (qc_exists && a4_exists)
+		ctr_preload[1] = mpdu[30] & 0x0f;
+	if (qc_exists && !a4_exists)
+		ctr_preload[1] = mpdu[24] & 0x0f;
+	for (i = 2; i < 8; i++)
+		ctr_preload[i] = mpdu[i + 8];
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[13 - i];
+	ctr_preload[14] = (unsigned char) (c / 256); /* Ctr */
+	ctr_preload[15] = (unsigned char) (c % 256);
+}
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = ina[i] ^ inb[i];
+}
+
+static sint aes_cipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	uint qc_exists, a4_exists, i, j, payload_remainder;
+	uint num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if ((frtype == WIFI_DATA_CFACK) ||
+	     (frtype == WIFI_DATA_CFPOLL) ||
+	     (frtype == WIFI_DATA_CFACKPOLL)) {
+			qc_exists = 1;
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+	} else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) ||
+		   (frsubtype == 0x0b)) {
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+			qc_exists = 1;
+	} else
+		qc_exists = 0;
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);
+	construct_mic_header1(mic_header1, hdrlen, pframe);
+	construct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);
+	payload_remainder = plen % 16;
+	num_blocks = plen / 16;
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	for (j = 0; j < 8; j++)
+		mic[j] = aes_out[j];
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		pframe[payload_index+j] = mic[j];
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) {  /* If short final block, then pad it,*/
+				      /* encrypt and copy unpadded part back */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index+j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+			      pframe, pn_vector, 0);
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = pframe[j+hdrlen+8+plen];
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		pframe[payload_index++] = chain_buffer[j];
+	return _SUCCESS;
+}
+
+u32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/* exclude ICV */
+	/* Intermediate Buffers */
+	sint	curfragnum, length;
+	u32	prwskeylen;
+	u8	*pframe, *prwskey;
+	struct	sta_info *stainfo;
+	struct	pkt_attrib  *pattrib = &((struct xmit_frame *)
+				       pxmitframe)->attrib;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;
+	/* 4 start to encrypt each fragment */
+	if ((pattrib->encrypt == _AES_)) {
+		if (pattrib->psta)
+			stainfo = pattrib->psta;
+		else
+			stainfo = r8712_get_stainfo(&padapter->stapriv,
+				  &pattrib->ra[0]);
+		if (stainfo != NULL) {
+			prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				if ((curfragnum + 1) == pattrib->nr_frags) {\
+					length = pattrib->last_txcmdsz -
+						 pattrib->hdrlen -
+						 pattrib->iv_len -
+						 pattrib->icv_len;
+					aes_cipher(prwskey, pattrib->
+						  hdrlen, pframe, length);
+				} else {
+					length = pxmitpriv->frag_len -
+						 pattrib->hdrlen -
+						 pattrib->iv_len -
+						 pattrib->icv_len ;
+					aes_cipher(prwskey, pattrib->
+						   hdrlen, pframe, length);
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((addr_t)(pframe));
+				}
+			}
+		} else
+			res = _FAIL;
+	}
+	return res;
+}
+
+static sint aes_decipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	static u8 message[MAX_MSG_SIZE];
+	uint qc_exists, a4_exists, i, j, payload_remainder;
+	uint num_blocks, payload_index;
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint frtype  = GetFrameType(pframe);
+	uint frsubtype  = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+	/* start to decrypt the payload */
+	/*(plen including llc, payload and mic) */
+	num_blocks = (plen - 8) / 16;
+	payload_remainder = (plen-8) % 16;
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+	if ((frtype == WIFI_DATA_CFACK) ||
+	    (frtype == WIFI_DATA_CFPOLL) ||
+	    (frtype == WIFI_DATA_CFACKPOLL)) {
+		qc_exists = 1;
+		if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+		}  else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) ||
+		   (frsubtype == 0x0b)) {
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+			qc_exists = 1;
+	} else
+		qc_exists = 0;
+	/* now, decrypt pframe with hdrlen offset and plen long */
+	payload_index = hdrlen + 8; /* 8 is for extiv */
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) {  /* If short final block, pad it,*/
+		/* encrypt it and copy the unpadded part back   */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	/* start to calculate the mic */
+	memcpy((void *)message, pframe, (hdrlen + plen + 8));
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, message, plen-8,
+			 pn_vector);
+	construct_mic_header1(mic_header1, hdrlen, message);
+	construct_mic_header2(mic_header2, message, a4_exists, qc_exists);
+	payload_remainder = (plen - 8) % 16;
+	num_blocks = (plen - 8) / 16;
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	for (j = 0 ; j < 8; j++)
+		mic[j] = aes_out[j];
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		message[payload_index+j] = mic[j];
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      message, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) { /* If short final block, pad it,*/
+				     /* encrypt and copy unpadded part back */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      message, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, message,
+			      pn_vector, 0);
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = message[j + hdrlen + plen];
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		message[payload_index++] = chain_buffer[j];
+	/* compare the mic */
+	return _SUCCESS;
+}
+
+u32 r8712_aes_decrypt(struct _adapter *padapter, u8 *precvframe)
+{	/* exclude ICV */
+	/* Intermediate Buffers */
+	sint		length;
+	u32	prwskeylen;
+	u8	*pframe, *prwskey, *iv, idx;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &((union recv_frame *)
+					   precvframe)->u.hdr.attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame*)precvframe)->
+		 u.hdr.rx_data;
+	/* 4 start to encrypt each fragment */
+	if ((prxattrib->encrypt == _AES_)) {
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				iv = pframe+prxattrib->hdrlen;
+				idx = iv[3];
+				prwskey = &psecuritypriv->XGrpKey[
+					  ((idx >> 6) & 0x3) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+
+			} else
+				prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			length = ((union recv_frame *)precvframe)->
+				 u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+			aes_decipher(prwskey, prxattrib->hdrlen, pframe,
+				     length);
+		} else
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+void r8712_use_tkipkey_handler(void *FunctionContext)
+{
+	struct _adapter *padapter = (struct _adapter *)FunctionContext;
+
+	padapter->securitypriv.busetkipkey = true;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_security.h b/drivers/staging/rtl8712/rtl871x_security.h
new file mode 100644
index 0000000..a13395f
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_security.h
@@ -0,0 +1,222 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_SECURITY_H_
+#define __RTL871X_SECURITY_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define _NO_PRIVACY_	0x0
+#define _WEP40_		0x1
+#define _TKIP_		0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_		0x4
+#define _WEP104_	0x5
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48 {
+	u64 val;
+#if defined(__BIG_ENDIAN)
+	struct {
+		u8 TSC7;
+		u8 TSC6;
+		u8 TSC5;
+		u8 TSC4;
+		u8 TSC3;
+		u8 TSC2;
+		u8 TSC1;
+		u8 TSC0;
+	} _byte_;
+#else
+	struct {
+		u8 TSC0;
+		u8 TSC1;
+		u8 TSC2;
+		u8 TSC3;
+		u8 TSC4;
+		u8 TSC5;
+		u8 TSC6;
+		u8 TSC7;
+	} _byte_;
+#endif
+};
+
+union Keytype {
+	u8 skey[16];
+	u32 lkey[4];
+};
+
+struct RT_PMKID_LIST {
+	u8 bUsed;
+	u8 Bssid[6];
+	u8 PMKID[16];
+	u8 SsidBuf[33];
+	u8 *ssid_octet;
+	u16 ssid_length;
+};
+
+struct security_priv {
+	u32 AuthAlgrthm;		/* 802.11 auth, could be open, shared,
+					 * 8021x and authswitch */
+	u32 PrivacyAlgrthm;		/* This specify the privacy for shared
+					 * auth. algorithm. */
+	u32 PrivacyKeyIndex;		/* this is only valid for legendary
+					 * wep, 0~3 for key id. */
+	union Keytype DefKey[4];	/* this is only valid for def. key */
+	u32 DefKeylen[4];
+	u32 XGrpPrivacy;		/* This specify the privacy algthm.
+					 * used for Grp key */
+	u32 XGrpKeyid;			/* key id used for Grp Key */
+	union Keytype	XGrpKey[2];	/* 802.1x Group Key, for
+					 * inx0 and inx1 */
+	union Keytype	XGrptxmickey[2];
+	union Keytype	XGrprxmickey[2];
+	union pn48 Grptxpn;		/* PN48 used for Grp Key xmit. */
+	union pn48 Grprxpn;		/* PN48 used for Grp Key recv. */
+	u8 wps_hw_pbc_pressed;/*for hw pbc pressed*/
+	u8 wps_phase;/*for wps*/
+	u8 wps_ie[MAX_WPA_IE_LEN<<2];
+	int wps_ie_len;
+	u8	binstallGrpkey;
+	u8	busetkipkey;
+	struct timer_list tkip_timer;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+	s32	sw_encrypt;	/* from registry_priv */
+	s32	sw_decrypt;	/* from registry_priv */
+	s32	hw_decrypted;	/* if the rx packets is hw_decrypted==false,
+				 * it means the hw has not been ready. */
+	u32 ndisauthtype;	/* keeps the auth_type & enc_status from upper
+				 * layer ioctl(wpa_supplicant or wzc) */
+	u32 ndisencryptstatus;
+	struct wlan_bssid_ex sec_bss;  /* for joinbss (h2c buffer) usage */
+	struct NDIS_802_11_WEP ndiswep;
+	u8 assoc_info[600];
+	u8 szofcapability[256]; /* for wpa2 usage */
+	u8 oidassociation[512]; /* for wpa/wpa2 usage */
+	u8 authenticator_ie[256];  /* store ap security information element */
+	u8 supplicant_ie[256];  /* store sta security information element */
+	/* for tkip countermeasure */
+	u32 last_mic_err_time;
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+	/*-------------------------------------------------------------------
+	 * For WPA2 Pre-Authentication.
+	 *------------------------------------------------------------------ */
+	struct RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];
+	u8				PMKIDIndex;
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst) \
+do { \
+	switch (psecuritypriv->AuthAlgrthm) { \
+	case 0: \
+	case 1: \
+	case 3: \
+		encry_algo = (u8)psecuritypriv->PrivacyAlgrthm; \
+		break; \
+	case 2: \
+		if (bmcst) \
+			encry_algo = (u8)psecuritypriv->XGrpPrivacy; \
+		else \
+			encry_algo = (u8)psta->XPrivacy; \
+		break; \
+	} \
+} while (0)
+#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
+do {\
+	switch (encrypt) { \
+	case _WEP40_: \
+	case _WEP104_: \
+		iv_len = 4; \
+		icv_len = 4; \
+		break; \
+	case _TKIP_: \
+		iv_len = 8; \
+		icv_len = 4; \
+		break; \
+	case _AES_: \
+		iv_len = 8; \
+		icv_len = 8; \
+		break; \
+	default: \
+		iv_len = 0; \
+		icv_len = 0; \
+		break; \
+	} \
+} while (0)
+#define GET_TKIP_PN(iv, txpn) \
+do {\
+	txpn._byte_.TSC0 = iv[2];\
+	txpn._byte_.TSC1 = iv[0];\
+	txpn._byte_.TSC2 = iv[4];\
+	txpn._byte_.TSC3 = iv[5];\
+	txpn._byte_.TSC4 = iv[6];\
+	txpn._byte_.TSC5 = iv[7];\
+} while (0)
+
+#define ROL32(A, n) (((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
+#define ROR32(A, n) ROL32((A), 32 - (n))
+
+struct mic_data {
+	u32  K0, K1;         /* Key */
+	u32  L, R;           /* Current state */
+	u32  M;              /* Message accumulator (single word) */
+	u32  nBytesInM;      /* # bytes in M */
+};
+
+void seccalctkipmic(
+	u8  *key,
+	u8  *header,
+	u8  *data,
+	u32  data_len,
+	u8  *Miccode,
+	u8   priority);
+
+void r8712_secmicsetkey(struct mic_data *pmicdata, u8 * key);
+void r8712_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes);
+void r8712_secgetmic(struct mic_data *pmicdata, u8 * dst);
+u32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe);
+u32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe);
+void r8712_wep_encrypt(struct _adapter *padapter, u8  *pxmitframe);
+u32 r8712_aes_decrypt(struct _adapter *padapter, u8  *precvframe);
+u32 r8712_tkip_decrypt(struct _adapter *padapter, u8  *precvframe);
+void r8712_wep_decrypt(struct _adapter *padapter, u8  *precvframe);
+void r8712_use_tkipkey_handler(void *FunctionContext);
+
+#endif	/*__RTL871X_SECURITY_H_ */
+
diff --git a/drivers/staging/rtl8712/rtl871x_sta_mgt.c b/drivers/staging/rtl8712/rtl871x_sta_mgt.c
new file mode 100644
index 0000000..1247b3d
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_sta_mgt.c
@@ -0,0 +1,296 @@
+/******************************************************************************
+ * rtl871x_sta_mgt.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_STA_MGT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "sta_info.h"
+
+static void _init_stainfo(struct sta_info *psta)
+{
+	memset((u8 *)psta, 0, sizeof(struct sta_info));
+	 spin_lock_init(&psta->lock);
+	_init_listhead(&psta->list);
+	_init_listhead(&psta->hash_list);
+	_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_r8712_init_sta_recv_priv(&psta->sta_recvpriv);
+	_init_listhead(&psta->asoc_list);
+	_init_listhead(&psta->auth_list);
+}
+
+u32 _r8712_init_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	s32 i;
+
+	pstapriv->pallocated_stainfo_buf = _malloc(sizeof(struct sta_info) *
+						   NUM_STA + 4);
+	if (pstapriv->pallocated_stainfo_buf == NULL)
+		return _FAIL;
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
+		((addr_t)(pstapriv->pallocated_stainfo_buf) & 3);
+	_init_queue(&pstapriv->free_sta_queue);
+	spin_lock_init(&pstapriv->sta_hash_lock);
+	pstapriv->asoc_sta_count = 0;
+	_init_queue(&pstapriv->sleep_q);
+	_init_queue(&pstapriv->wakeup_q);
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+	for (i = 0; i < NUM_STA; i++) {
+		_init_stainfo(psta);
+		_init_listhead(&(pstapriv->sta_hash[i]));
+		list_insert_tail(&psta->list,
+				 get_list_head(&pstapriv->free_sta_queue));
+		psta++;
+	}
+	_init_listhead(&pstapriv->asoc_list);
+	_init_listhead(&pstapriv->auth_list);
+	return _SUCCESS;
+}
+
+/* this function is used to free the memory of lock || sema for all stainfos */
+static void mfree_all_stainfo(struct sta_priv *pstapriv)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = get_next(phead);
+	while ((end_of_queue_search(phead, plist)) == false) {
+		psta = LIST_CONTAINOR(plist, struct sta_info, list);
+		plist = get_next(plist);
+	}
+
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+}
+
+
+static void mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+	 mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
+}
+
+u32 _r8712_free_sta_priv(struct sta_priv *pstapriv)
+{
+	if (pstapriv) {
+		mfree_sta_priv_lock(pstapriv);
+		kfree(pstapriv->pallocated_stainfo_buf);
+	}
+	return _SUCCESS;
+}
+
+struct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	uint tmp_aid;
+	s32	index;
+	struct list_head *phash_list;
+	struct sta_info	*psta;
+	struct  __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+	unsigned long flags;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	spin_lock_irqsave(&(pfree_sta_queue->lock), flags);
+	if (_queue_empty(pfree_sta_queue) == true)
+		psta = NULL;
+	else {
+		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue),
+				      struct sta_info, list);
+		list_delete(&(psta->list));
+		tmp_aid = psta->aid;
+		_init_stainfo(psta);
+		memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+		index = wifi_mac_hash(hwaddr);
+		if (index >= NUM_STA) {
+			psta = NULL;
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+		list_insert_tail(&psta->hash_list, phash_list);
+		pstapriv->asoc_sta_count++ ;
+
+/* For the SMC router, the sequence number of first packet of WPS handshake
+ * will be 0. In this case, this packet will be dropped by recv_decache function
+ * if we use the 0x00 as the default value for tid_rxseq variable. So, we
+ * initialize the tid_rxseq variable as the 0xffff.
+ */
+		for (i = 0; i < 16; i++)
+			memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],
+				&wRxSeqInitialValue, 2);
+		/* for A-MPDU Rx reordering buffer control */
+		for (i = 0; i < 16 ; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->padapter = pstapriv->padapter;
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+			preorder_ctrl->wsize_b = 64;
+			_init_queue(&preorder_ctrl->pending_recvframe_queue);
+			r8712_init_recv_timer(preorder_ctrl);
+		}
+	}
+exit:
+	spin_unlock_irqrestore(&(pfree_sta_queue->lock), flags);
+	return psta;
+}
+
+/* using pstapriv->sta_hash_lock to protect */
+void r8712_free_stainfo(struct _adapter *padapter, struct sta_info *psta)
+{
+	int i;
+	unsigned long irqL0;
+	struct  __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct	sta_xmit_priv *pstaxmitpriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	if (psta == NULL)
+		return;
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	pstaxmitpriv = &psta->sta_xmitpriv;
+	spin_lock_irqsave(&(pxmitpriv->vo_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+	list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->vo_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->vi_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+	list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->vi_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->bk_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+	list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->bk_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->be_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+	list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->be_pending.lock), irqL0);
+	list_delete(&psta->hash_list);
+	pstapriv->asoc_sta_count--;
+	/* re-init sta_info; 20061114 */
+	_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_r8712_init_sta_recv_priv(&psta->sta_recvpriv);
+	/* for A-MPDU Rx reordering buffer control,
+	 * cancel reordering_ctrl_timer */
+	for (i = 0; i < 16; i++) {
+		preorder_ctrl = &psta->recvreorder_ctrl[i];
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+	spin_lock(&(pfree_sta_queue->lock));
+	/* insert into free_sta_queue; 20061114 */
+	list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	spin_unlock(&(pfree_sta_queue->lock));
+}
+
+/* free all stainfo which in sta_hash[all] */
+void r8712_free_all_stainfo(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	s32 index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *pbcmc_stainfo = r8712_get_bcmc_stainfo(padapter);
+
+	if (pstapriv->asoc_sta_count == 1)
+		return;
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	for (index = 0; index < NUM_STA; index++) {
+		phead = &(pstapriv->sta_hash[index]);
+		plist = get_next(phead);
+		while ((end_of_queue_search(phead, plist)) == false) {
+			psta = LIST_CONTAINOR(plist,
+					      struct sta_info, hash_list);
+			plist = get_next(plist);
+			if (pbcmc_stainfo != psta)
+				r8712_free_stainfo(padapter , psta);
+		}
+	}
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	unsigned long	 irqL;
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+	u32	index;
+
+	if (hwaddr == NULL)
+		return NULL;
+	index = wifi_mac_hash(hwaddr);
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	phead = &(pstapriv->sta_hash[index]);
+	plist = get_next(phead);
+	while ((end_of_queue_search(phead, plist)) == false) {
+		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+		if ((!memcmp(psta->hwaddr, hwaddr, ETH_ALEN))) {
+			/* if found the matched address */
+			break;
+		}
+		psta = NULL;
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+	return psta;
+}
+
+void r8712_init_bcmc_stainfo(struct _adapter *padapter)
+{
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	unsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	psta = r8712_alloc_stainfo(pstapriv, bcast_addr);
+	if (psta == NULL)
+		return;
+	ptxservq = &(psta->sta_xmitpriv.be_q);
+}
+
+struct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter)
+{
+	struct sta_info *psta;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	psta = r8712_get_stainfo(pstapriv, bc_addr);
+	return psta;
+}
+
+
+u8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 *mac_addr)
+{
+	return true;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_wlan_sme.h b/drivers/staging/rtl8712/rtl871x_wlan_sme.h
new file mode 100644
index 0000000..44924d5
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_wlan_sme.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_WLAN_SME_H_
+#define _RTL871X_WLAN_SME_H_
+
+#define MSR_APMODE		0x0C
+#define MSR_STAMODE	0x08
+#define MSR_ADHOCMODE	0x04
+#define MSR_NOLINKMODE	0x00
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+#endif
+
diff --git a/drivers/staging/rtl8712/rtl871x_xmit.c b/drivers/staging/rtl8712/rtl871x_xmit.c
new file mode 100644
index 0000000..8bbdee7
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_xmit.c
@@ -0,0 +1,1066 @@
+/******************************************************************************
+ * rtl871x_xmit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_XMIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+
+static const u8 P802_1H_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0xf8};
+static const u8 RFC1042_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0x00};
+static void init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+static void alloc_hwxmits(struct _adapter *padapter);
+static void free_hwxmits(struct _adapter *padapter);
+
+static void _init_txservq(struct tx_servq *ptxservq)
+{
+	_init_listhead(&ptxservq->tx_pending);
+	_init_queue(&ptxservq->sta_pending);
+	ptxservq->qcnt = 0;
+}
+
+void _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{
+	memset((unsigned char *)psta_xmitpriv, 0,
+		 sizeof(struct sta_xmit_priv));
+	spin_lock_init(&psta_xmitpriv->lock);
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	_init_listhead(&psta_xmitpriv->legacy_dz);
+	_init_listhead(&psta_xmitpriv->apsd);
+}
+
+sint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,
+			   struct _adapter *padapter)
+{
+	sint i;
+	struct xmit_buf *pxmitbuf;
+	struct xmit_frame *pxframe;
+
+	memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	spin_lock_init(&pxmitpriv->lock);
+	sema_init(&pxmitpriv->xmit_sema, 0);
+	sema_init(&pxmitpriv->terminate_xmitthread_sema, 0);
+	/*
+	Please insert all the queue initializaiton using _init_queue below
+	*/
+	pxmitpriv->adapter = padapter;
+	_init_queue(&pxmitpriv->be_pending);
+	_init_queue(&pxmitpriv->bk_pending);
+	_init_queue(&pxmitpriv->vi_pending);
+	_init_queue(&pxmitpriv->vo_pending);
+	_init_queue(&pxmitpriv->bm_pending);
+	_init_queue(&pxmitpriv->legacy_dz_queue);
+	_init_queue(&pxmitpriv->apsd_queue);
+	_init_queue(&pxmitpriv->free_xmit_queue);
+	/*
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+	pxmitpriv->pallocated_frame_buf = _malloc(NR_XMITFRAME *
+					  sizeof(struct xmit_frame) + 4);
+	if (pxmitpriv->pallocated_frame_buf == NULL) {
+		pxmitpriv->pxmit_frame_buf = NULL;
+		return _FAIL;
+	}
+	pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
+			((addr_t) (pxmitpriv->pallocated_frame_buf) & 3);
+	pxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		_init_listhead(&(pxframe->list));
+		pxframe->padapter = padapter;
+		pxframe->frame_tag = DATA_FRAMETAG;
+		pxframe->pkt = NULL;
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+		list_insert_tail(&(pxframe->list),
+				 &(pxmitpriv->free_xmit_queue.queue));
+		pxframe++;
+	}
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+	/*
+		init xmit hw_txqueue
+	*/
+	_r8712_init_hw_txqueue(&pxmitpriv->be_txqueue, BE_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->bk_txqueue, BK_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->vi_txqueue, VI_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->vo_txqueue, VO_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->bmc_txqueue, BMC_QUEUE_INX);
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+	pxmitpriv->txirp_cnt = 1;
+	sema_init(&(pxmitpriv->tx_retevt), 0);
+	/*per AC pending irp*/
+	pxmitpriv->beq_cnt = 0;
+	pxmitpriv->bkq_cnt = 0;
+	pxmitpriv->viq_cnt = 0;
+	pxmitpriv->voq_cnt = 0;
+	/*init xmit_buf*/
+	_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+	pxmitpriv->pallocated_xmitbuf = _malloc(NR_XMITBUFF *
+					sizeof(struct xmit_buf) + 4);
+	if (pxmitpriv->pallocated_xmitbuf  == NULL)
+		return _FAIL;
+	pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
+			      ((addr_t)(pxmitpriv->pallocated_xmitbuf) & 3);
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		_init_listhead(&pxmitbuf->list);
+		pxmitbuf->pallocated_buf = _malloc(MAX_XMITBUF_SZ +
+					   XMITBUF_ALIGN_SZ);
+		if (pxmitbuf->pallocated_buf == NULL)
+			return _FAIL;
+		pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -
+				 ((addr_t) (pxmitbuf->pallocated_buf) &
+				 (XMITBUF_ALIGN_SZ - 1));
+		r8712_xmit_resource_alloc(padapter, pxmitbuf);
+		list_insert_tail(&pxmitbuf->list,
+				 &(pxmitpriv->free_xmitbuf_queue.queue));
+		pxmitbuf++;
+	}
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+	_init_workitem(&padapter->wkFilterRxFF0, r8712_SetFilter, padapter);
+	alloc_hwxmits(padapter);
+	init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+		(void(*)(unsigned long))r8712_xmit_bh,
+		(unsigned long)padapter);
+	return _SUCCESS;
+}
+
+void _free_xmit_priv(struct xmit_priv *pxmitpriv)
+{
+	int i;
+	struct _adapter *padapter = pxmitpriv->adapter;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)
+					pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+	if (pxmitpriv->pxmit_frame_buf == NULL)
+		return;
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		r8712_xmit_complete(padapter, pxmitframe);
+		pxmitframe++;
+	}
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		r8712_xmit_resource_free(padapter, pxmitbuf);
+		kfree(pxmitbuf->pallocated_buf);
+		pxmitbuf++;
+	}
+	kfree(pxmitpriv->pallocated_frame_buf);
+	kfree(pxmitpriv->pallocated_xmitbuf);
+	free_hwxmits(padapter);
+}
+
+sint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,
+		   struct pkt_attrib *pattrib)
+{
+	uint i;
+	struct pkt_file pktfile;
+	struct sta_info *psta = NULL;
+	struct ethhdr etherhdr;
+
+	struct tx_cmd txdesc;
+
+	sint bmcast;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+
+	_r8712_open_pktfile(pkt, &pktfile);
+
+	i = _r8712_pktfile_read(&pktfile, (unsigned char *)&etherhdr, ETH_HLEN);
+
+	pattrib->ether_type = ntohs(etherhdr.h_proto);
+
+{
+	u8 bool;
+	/*If driver xmit ARP packet, driver can set ps mode to initial
+	 * setting. It stands for getting DHCP or fix IP.*/
+	if (pattrib->ether_type == 0x0806) {
+		if (padapter->pwrctrlpriv.pwr_mode !=
+		    padapter->registrypriv.power_mgnt) {
+			_cancel_timer(&(pmlmepriv->dhcp_timer), &bool);
+			r8712_set_ps_mode(padapter, padapter->registrypriv.
+				power_mgnt, padapter->registrypriv.smart_ps);
+		}
+	}
+}
+	memcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);
+	memcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);
+	pattrib->pctrl = 0;
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		/*firstly, filter packet not belongs to mp*/
+		if (pattrib->ether_type != 0x8712)
+			return _FAIL;
+		/* for mp storing the txcmd per packet,
+		 * according to the info of txcmd to update pattrib */
+		/*get MP_TXDESC_SIZE bytes txcmd per packet*/
+		i = _r8712_pktfile_read(&pktfile, (u8 *)&txdesc, TXDESC_SIZE);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		pattrib->pctrl = 1;
+	}
+	/* r8712_xmitframe_coalesce() overwrite this!*/
+	pattrib->pktlen = pktfile.pkt_len;
+	if (ETH_P_IP == pattrib->ether_type) {
+		/* The following is for DHCP and ARP packet, we use cck1M to
+		 * tx these packets and let LPS awake some time
+		 * to prevent DHCP protocol fail */
+		u8 tmp[24];
+		_r8712_pktfile_read(&pktfile, &tmp[0], 24);
+		pattrib->dhcp_pkt = 0;
+		if (pktfile.pkt_len > 282) {/*MINIMUM_DHCP_PACKET_SIZE)*/
+			if (ETH_P_IP == pattrib->ether_type) {/* IP header*/
+				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
+					((tmp[21] == 67) && (tmp[23] == 68))) {
+					/* 68 : UDP BOOTP client
+					 * 67 : UDP BOOTP server
+					 * Use low rate to send DHCP packet.*/
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	}
+	bmcast = IS_MCAST(pattrib->ra);
+	/* get sta_info*/
+	if (bmcast) {
+		psta = r8712_get_bcmc_stainfo(padapter);
+		pattrib->mac_id = 4;
+	} else {
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+			psta = r8712_get_stainfo(pstapriv,
+						 get_bssid(pmlmepriv));
+			pattrib->mac_id = 5;
+		} else {
+			psta = r8712_get_stainfo(pstapriv, pattrib->ra);
+			if (psta == NULL)  /* drop the pkt */
+				return _FAIL;
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+				pattrib->mac_id = 5;
+			else
+				pattrib->mac_id = psta->mac_id;
+		}
+	}
+
+	if (psta) {
+		pattrib->psta = psta;
+	} else {
+		/* if we cannot get psta => drrp the pkt */
+		return _FAIL;
+	}
+
+	pattrib->ack_policy = 0;
+	/* get ether_hdr_len */
+	pattrib->pkt_hdrlen = ETH_HLEN;
+
+	if (pqospriv->qos_option)
+		r8712_set_qos(&pktfile, pattrib);
+	else {
+		pattrib->hdrlen = WLAN_HDR_A3_LEN;
+		pattrib->subtype = WIFI_DATA_TYPE;
+		pattrib->priority = 0;
+	}
+	if (psta->ieee8021x_blocked == true) {
+		pattrib->encrypt = 0;
+		if ((pattrib->ether_type != 0x888e) &&
+		    (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
+			return _FAIL;
+	} else
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+	switch (pattrib->encrypt) {
+	case _WEP40_:
+	case _WEP104_:
+		pattrib->iv_len = 4;
+		pattrib->icv_len = 4;
+		break;
+	case _TKIP_:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 4;
+		if (padapter->securitypriv.busetkipkey == _FAIL)
+			return _FAIL;
+		break;
+	case _AES_:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 8;
+		break;
+	default:
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+		break;
+	}
+
+	if (pattrib->encrypt &&
+	    ((padapter->securitypriv.sw_encrypt == true) ||
+	     (psecuritypriv->hw_decrypted == false)))
+		pattrib->bswenc = true;
+	else
+		pattrib->bswenc = false;
+	/* if in MP_STATE, update pkt_attrib from mp_txcmd, and overwrite
+	 * some settings above.*/
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		pattrib->priority = (txdesc.txdw1 >> QSEL_SHT) & 0x1f;
+	return _SUCCESS;
+}
+
+static sint xmitframe_addmic(struct _adapter *padapter,
+			     struct xmit_frame *pxmitframe)
+{
+	u32	curfragnum, length, datalen;
+	u8	*pframe, *payload, mic[8];
+	struct	mic_data micdata;
+	struct	sta_info *stainfo;
+	struct	qos_priv *pqospriv = &(padapter->mlmepriv.qospriv);
+	struct	pkt_attrib  *pattrib = &pxmitframe->attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta)
+		stainfo = pattrib->psta;
+	else
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &pattrib->ra[0]);
+	if (pattrib->encrypt == _TKIP_) {
+		/*encode mic code*/
+		if (stainfo != NULL) {
+			u8 null_key[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0};
+			datalen = pattrib->pktlen - pattrib->hdrlen;
+			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
+			if (bmcst) {
+				if (!memcmp(psecuritypriv->XGrptxmickey
+				   [psecuritypriv->XGrpKeyid].skey,
+				   null_key, 16))
+					return _FAIL;
+				/*start to calculate the mic code*/
+				r8712_secmicsetkey(&micdata,
+					 psecuritypriv->
+					 XGrptxmickey[psecuritypriv->
+					XGrpKeyid].skey);
+			} else {
+				if (!memcmp(&stainfo->tkiptxmickey.skey[0],
+					    null_key, 16))
+					return _FAIL;
+				/* start to calculate the mic code */
+				r8712_secmicsetkey(&micdata,
+					     &stainfo->tkiptxmickey.skey[0]);
+			}
+			if (pframe[1] & 1) {   /* ToDS==1 */
+				r8712_secmicappend(&micdata,
+						   &pframe[16], 6); /*DA*/
+				if (pframe[1]&2)  /* From Ds==1 */
+					r8712_secmicappend(&micdata,
+							   &pframe[24], 6);
+				else
+					r8712_secmicappend(&micdata,
+							   &pframe[10], 6);
+			} else {	/* ToDS==0 */
+				r8712_secmicappend(&micdata,
+						   &pframe[4], 6); /* DA */
+				if (pframe[1]&2)  /* From Ds==1 */
+					r8712_secmicappend(&micdata,
+							   &pframe[16], 6);
+				else
+					r8712_secmicappend(&micdata,
+							   &pframe[10], 6);
+			}
+			if (pqospriv->qos_option == 1)
+					priority[0] = (u8)pxmitframe->
+						      attrib.priority;
+			r8712_secmicappend(&micdata, &priority[0], 4);
+			payload = pframe;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				payload = (u8 *)RND4((addr_t)(payload));
+				payload = payload+pattrib->
+					  hdrlen+pattrib->iv_len;
+				if ((curfragnum + 1) == pattrib->nr_frags) {
+					length = pattrib->last_txcmdsz -
+						  pattrib->hdrlen -
+						  pattrib->iv_len -
+						  ((psecuritypriv->sw_encrypt)
+						  ? pattrib->icv_len : 0);
+					r8712_secmicappend(&micdata, payload,
+							   length);
+					payload = payload+length;
+				} else{
+					length = pxmitpriv->frag_len -
+					    pattrib->hdrlen-pattrib->iv_len -
+					    ((psecuritypriv->sw_encrypt) ?
+					    pattrib->icv_len : 0);
+					r8712_secmicappend(&micdata, payload,
+							   length);
+					payload = payload + length +
+						  pattrib->icv_len;
+				}
+			}
+			r8712_secgetmic(&micdata, &(mic[0]));
+			/* add mic code  and add the mic code length in
+			 * last_txcmdsz */
+			memcpy(payload, &(mic[0]), 8);
+			pattrib->last_txcmdsz += 8;
+			payload = payload-pattrib->last_txcmdsz + 8;
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint xmitframe_swencrypt(struct _adapter *padapter,
+				struct xmit_frame *pxmitframe)
+{
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+
+	if (pattrib->bswenc) {
+		switch (pattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			r8712_wep_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _TKIP_:
+			r8712_tkip_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _AES_:
+			r8712_aes_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		default:
+				break;
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint make_wlanhdr(struct _adapter *padapter , u8 *hdr,
+			 struct pkt_attrib *pattrib)
+{
+	u16 *qc;
+
+	struct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	u16 *fctrl = &pwlanhdr->frame_ctl;
+	memset(hdr, 0, WLANHDR_OFFSET);
+	SetFrameSubType(fctrl, pattrib->subtype);
+	if (pattrib->subtype & WIFI_DATA_TYPE) {
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
+			/* to_ds = 1, fr_ds = 0; */
+			SetToDs(fctrl);
+			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv),
+				ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+		} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)) {
+			/* to_ds = 0, fr_ds = 1; */
+			SetFrDs(fctrl);
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv),
+				ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+		} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+			   || (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
+			   == true)) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),
+				ETH_ALEN);
+		} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),
+				ETH_ALEN);
+		} else
+			return _FAIL;
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+		if (pqospriv->qos_option) {
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+			if (pattrib->priority)
+				SetPriority(qc, pattrib->priority);
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+		/* TODO: fill HT Control Field */
+		/* Update Seq Num will be handled by f/w */
+		{
+			struct sta_info *psta;
+
+			sint bmcst = IS_MCAST(pattrib->ra);
+			if (pattrib->psta)
+				psta = pattrib->psta;
+			else {
+				if (bmcst)
+					psta = r8712_get_bcmc_stainfo(padapter);
+				else
+					psta =
+					 r8712_get_stainfo(&padapter->stapriv,
+					 pattrib->ra);
+			}
+			if (psta) {
+				psta->sta_xmitpriv.txseq_tid
+						  [pattrib->priority]++;
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority]
+						   &= 0xFFF;
+				pattrib->seqnum = psta->sta_xmitpriv.
+						  txseq_tid[pattrib->priority];
+				SetSeqNum(hdr, pattrib->seqnum);
+			}
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint r8712_put_snap(u8 *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	const u8 *oui;
+
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+	return SNAP_SIZE + sizeof(u16);
+}
+
+/*
+ * This sub-routine will perform all the following:
+ * 1. remove 802.3 header.
+ * 2. create wlan_header, based on the info in pxmitframe
+ * 3. append sta's iv/ext-iv
+ * 4. append LLC
+ * 5. move frag chunk from pframe to pxmitframe->mem
+ * 6. apply sw-encrypt, if necessary.
+ */
+sint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,
+			struct xmit_frame *pxmitframe)
+{
+	struct pkt_file pktfile;
+
+	sint	frg_len, mpdu_len, llc_sz;
+	u32	mem_sz;
+	u8	frg_inx;
+	addr_t addr;
+	u8 *pframe, *mem_start, *ptxdesc;
+	struct sta_info		*psta;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	u8 *pbuf_start;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta == NULL)
+		return _FAIL;
+	psta = pattrib->psta;
+	if (pxmitframe->buf_addr == NULL)
+		return _FAIL;
+	pbuf_start = pxmitframe->buf_addr;
+	ptxdesc = pbuf_start;
+	mem_start = pbuf_start + TXDESC_OFFSET;
+	if (make_wlanhdr(padapter, mem_start, pattrib) == _FAIL)
+		return _FAIL;
+	_r8712_open_pktfile(pkt, &pktfile);
+	_r8712_pktfile_read(&pktfile, NULL, (uint) pattrib->pkt_hdrlen);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		/* truncate TXDESC_SIZE bytes txcmd if at mp mode for 871x */
+		if (pattrib->ether_type == 0x8712) {
+			/* take care -  update_txdesc overwrite this */
+			_r8712_pktfile_read(&pktfile, ptxdesc, TXDESC_SIZE);
+		}
+	}
+	pattrib->pktlen = pktfile.pkt_len;
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;
+	while (1) {
+		llc_sz = 0;
+		mpdu_len = frg_len;
+		pframe = mem_start;
+		SetMFrag(mem_start);
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+		/* adding icv, if necessary...*/
+		if (pattrib->iv_len) {
+			if (psta != NULL) {
+				switch (pattrib->encrypt) {
+				case _WEP40_:
+				case _WEP104_:
+					WEP_IV(pattrib->iv, psta->txpn,
+					       (u8)psecuritypriv->
+					       PrivacyKeyIndex);
+					break;
+				case _TKIP_:
+					if (bmcst)
+						TKIP_IV(pattrib->iv,
+						    psta->txpn,
+						    (u8)psecuritypriv->
+						    XGrpKeyid);
+					else
+						TKIP_IV(pattrib->iv, psta->txpn,
+							0);
+					break;
+				case _AES_:
+					if (bmcst)
+						AES_IV(pattrib->iv, psta->txpn,
+						    (u8)psecuritypriv->
+						    XGrpKeyid);
+					else
+						AES_IV(pattrib->iv, psta->txpn,
+						       0);
+					break;
+				}
+			}
+			memcpy(pframe, pattrib->iv, pattrib->iv_len);
+			pframe += pattrib->iv_len;
+			mpdu_len -= pattrib->iv_len;
+		}
+		if (frg_inx == 0) {
+			llc_sz = r8712_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc))
+			mpdu_len -= pattrib->icv_len;
+		if (bmcst)
+			mem_sz = _r8712_pktfile_read(&pktfile, pframe,
+				 pattrib->pktlen);
+		else
+			mem_sz = _r8712_pktfile_read(&pktfile, pframe,
+				 mpdu_len);
+		pframe += mem_sz;
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
+			memcpy(pframe, pattrib->icv, pattrib->icv_len);
+			pframe += pattrib->icv_len;
+		}
+		frg_inx++;
+		if (bmcst || (r8712_endofpktfile(&pktfile) == true)) {
+			pattrib->nr_frags = frg_inx;
+			pattrib->last_txcmdsz = pattrib->hdrlen +
+						pattrib->iv_len +
+						((pattrib->nr_frags == 1) ?
+						llc_sz : 0) +
+						((pattrib->bswenc) ?
+						pattrib->icv_len : 0) + mem_sz;
+			ClearMFrag(mem_start);
+			break;
+		}
+		addr = (addr_t)(pframe);
+		mem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;
+		memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
+	}
+
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
+		return _FAIL;
+	xmitframe_swencrypt(padapter, pxmitframe);
+	return _SUCCESS;
+}
+
+void r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len)
+{
+	uint	protection;
+	u8	*perp;
+	sint	 erp_len;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	switch (pxmitpriv->vcs_setting) {
+	case DISABLE_VCS:
+		pxmitpriv->vcs = NONE_VCS;
+		break;
+	case ENABLE_VCS:
+		break;
+	case AUTO_VCS:
+	default:
+		perp = r8712_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+		if (perp == NULL)
+			pxmitpriv->vcs = NONE_VCS;
+		else {
+			protection = (*(perp + 2)) & BIT(1);
+			if (protection) {
+				if (pregistrypriv->vcs_type == RTS_CTS)
+					pxmitpriv->vcs = RTS_CTS;
+				else
+					pxmitpriv->vcs = CTS_TO_SELF;
+			} else
+				pxmitpriv->vcs = NONE_VCS;
+		}
+		break;
+	}
+}
+
+struct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	unsigned long irqL;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	if (_queue_empty(pfree_xmitbuf_queue) == true)
+		pxmitbuf = NULL;
+	else {
+		phead = get_list_head(pfree_xmitbuf_queue);
+		plist = get_next(phead);
+		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
+		list_delete(&(pxmitbuf->list));
+	}
+	if (pxmitbuf !=  NULL)
+		pxmitpriv->free_xmitbuf_cnt--;
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+	return pxmitbuf;
+}
+
+int r8712_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	unsigned long irqL;
+	struct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	if (pxmitbuf == NULL)
+		return _FAIL;
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	list_delete(&pxmitbuf->list);
+	list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+	pxmitpriv->free_xmitbuf_cnt++;
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+	return _SUCCESS;
+}
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+
+struct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv)
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect
+		pfree_xmit_queue
+	*/
+	unsigned long irqL;
+	struct xmit_frame *pxframe = NULL;
+	struct list_head *plist, *phead;
+	struct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+
+	spin_lock_irqsave(&pfree_xmit_queue->lock, irqL);
+	if (_queue_empty(pfree_xmit_queue) == true)
+		pxframe =  NULL;
+	else {
+		phead = get_list_head(pfree_xmit_queue);
+		plist = get_next(phead);
+		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+		list_delete(&(pxframe->list));
+	}
+	if (pxframe !=  NULL) {
+		pxmitpriv->free_xmitframe_cnt--;
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+		pxframe->attrib.psta = NULL;
+		pxframe->pkt = NULL;
+	}
+	spin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);
+	return pxframe;
+}
+
+void r8712_free_xmitframe(struct xmit_priv *pxmitpriv,
+			  struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL;
+	struct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+	struct _adapter *padapter = pxmitpriv->adapter;
+	struct sk_buff *pndis_pkt = NULL;
+
+	if (pxmitframe == NULL)
+		return;
+	spin_lock_irqsave(&pfree_xmit_queue->lock, irqL);
+	list_delete(&pxmitframe->list);
+	if (pxmitframe->pkt) {
+		pndis_pkt = pxmitframe->pkt;
+		pxmitframe->pkt = NULL;
+	}
+	list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
+	pxmitpriv->free_xmitframe_cnt++;
+	spin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);
+}
+
+void r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,
+		      struct xmit_frame *pxmitframe)
+{
+	if (pxmitframe == NULL)
+		return;
+	if (pxmitframe->frame_tag == DATA_FRAMETAG)
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+}
+
+void r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,
+				struct  __queue *pframequeue)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	struct	xmit_frame	*pxmitframe;
+
+	spin_lock_irqsave(&(pframequeue->lock), irqL);
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+		plist = get_next(plist);
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+	}
+	spin_unlock_irqrestore(&(pframequeue->lock), irqL);
+}
+
+static inline struct tx_servq *get_sta_pending(struct _adapter *padapter,
+					       struct  __queue **ppstapending,
+					       struct sta_info *psta, sint up)
+{
+
+	struct tx_servq *ptxservq;
+	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
+
+	switch (up) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		*ppstapending = &padapter->xmitpriv.bk_pending;
+		(phwxmits+3)->accnt++;
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		*ppstapending = &padapter->xmitpriv.vi_pending;
+		(phwxmits+1)->accnt++;
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		*ppstapending = &padapter->xmitpriv.vo_pending;
+		(phwxmits+0)->accnt++;
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+		*ppstapending = &padapter->xmitpriv.be_pending;
+		(phwxmits + 2)->accnt++;
+		break;
+	}
+	return ptxservq;
+}
+
+/*
+ * Will enqueue pxmitframe to the proper queue, and indicate it
+ * to xx_pending list.....
+ */
+sint r8712_xmit_classifier(struct _adapter *padapter,
+			   struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL0;
+	struct  __queue *pstapending;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else {
+		if (bmcst)
+			psta = r8712_get_bcmc_stainfo(padapter);
+		else {
+			if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+				psta = r8712_get_stainfo(pstapriv,
+				       get_bssid(pmlmepriv));
+			else
+				psta = r8712_get_stainfo(pstapriv, pattrib->ra);
+		}
+	}
+	if (psta == NULL)
+		return _FAIL;
+	ptxservq = get_sta_pending(padapter, &pstapending,
+		   psta, pattrib->priority);
+	spin_lock_irqsave(&pstapending->lock, irqL0);
+	if (is_list_empty(&ptxservq->tx_pending))
+		list_insert_tail(&ptxservq->tx_pending,
+				 get_list_head(pstapending));
+	list_insert_tail(&pxmitframe->list,
+			 get_list_head(&ptxservq->sta_pending));
+	ptxservq->qcnt++;
+	spin_unlock_irqrestore(&pstapending->lock, irqL0);
+	return _SUCCESS;
+}
+
+static void alloc_hwxmits(struct _adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
+	pxmitpriv->hwxmits = (struct hw_xmit *)_malloc(sizeof(struct hw_xmit) *
+			     pxmitpriv->hwxmit_entry);
+	if (pxmitpriv->hwxmits == NULL)
+		return;
+	hwxmits = pxmitpriv->hwxmits;
+	if (pxmitpriv->hwxmit_entry == 5) {
+		pxmitpriv->bmc_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
+	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
+	} else if (pxmitpriv->hwxmit_entry == 4) {
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
+		pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+	}
+}
+
+static void free_hwxmits(struct _adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	kfree(pxmitpriv->hwxmits);
+}
+
+static void init_hwxmits(struct hw_xmit *phwxmit, sint entry)
+{
+	sint i;
+
+	for (i = 0; i < entry; i++, phwxmit++) {
+		spin_lock_init(&phwxmit->xmit_lock);
+		_init_listhead(&phwxmit->pending);
+		phwxmit->txcmdcnt = 0;
+		phwxmit->accnt = 0;
+	}
+}
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,
+			struct xmit_buf *pxmitbuf)
+{
+	/* pxmitbuf attach to pxmitframe */
+	pxmitframe->pxmitbuf = pxmitbuf;
+	/* urb and irp connection */
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+	/* pxmitframe attach to pxmitbuf */
+	pxmitbuf->priv_data = pxmitframe;
+}
+
+/*
+ * tx_action == 0 == no frames to transmit
+ * tx_action > 0 ==> we have frames to transmit
+ * tx_action < 0 ==> we have frames to transmit, but TXFF is not even enough
+ *						 to transmit 1 frame.
+ */
+
+int r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL;
+	int ret;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	r8712_do_queue_select(padapter, pattrib);
+	spin_lock_irqsave(&pxmitpriv->lock, irqL);
+	if (r8712_txframes_sta_ac_pending(padapter, pattrib) > 0) {
+		ret = false;
+		r8712_xmit_enqueue(padapter, pxmitframe);
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+		return ret;
+	}
+	pxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);
+	if (pxmitbuf == NULL) { /*enqueue packet*/
+		ret = false;
+		r8712_xmit_enqueue(padapter, pxmitframe);
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+	} else { /*dump packet directly*/
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+		ret = true;
+		xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+		r8712_xmit_direct(padapter, pxmitframe);
+	}
+	return ret;
+}
diff --git a/drivers/staging/rtl8712/rtl871x_xmit.h b/drivers/staging/rtl8712/rtl871x_xmit.h
new file mode 100644
index 0000000..a034c0f
--- /dev/null
+++ b/drivers/staging/rtl8712/rtl871x_xmit.h
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_XMIT_H_
+#define _RTL871X_XMIT_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "xmit_osdep.h"
+
+#ifdef CONFIG_R8712_TX_AGGR
+#define MAX_XMITBUF_SZ  (16384)
+#else
+#define MAX_XMITBUF_SZ  (2048)
+#endif
+
+#define NR_XMITBUFF     (4)
+
+#ifdef CONFIG_R8712_TX_AGGR
+#define AGGR_NR_HIGH_BOUND      (4) /*(8) */
+#define AGGR_NR_LOW_BOUND       (2)
+#endif
+
+#define XMITBUF_ALIGN_SZ 512
+#define TX_GUARD_BAND		5
+#define MAX_NUMBLKS		(1)
+
+/* Fixed the Big Endian bug when using the software driver encryption.*/
+#define WEP_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC0;\
+	pattrib_iv[1] = txpn._byte_.TSC1;\
+	pattrib_iv[2] = txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	txpn.val = (txpn.val == 0xffffff) ? 0 : (txpn.val+1);\
+} while (0)
+
+/* Fixed the Big Endian bug when doing the Tx.
+ * The Linksys WRH54G will check this.*/
+#define TKIP_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC1;\
+	pattrib_iv[1] = (txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = txpn._byte_.TSC2;\
+	pattrib_iv[5] = txpn._byte_.TSC3;\
+	pattrib_iv[6] = txpn._byte_.TSC4;\
+	pattrib_iv[7] = txpn._byte_.TSC5;\
+	txpn.val = txpn.val == 0xffffffffffffULL ? 0 : \
+	(txpn.val+1);\
+} while (0)
+
+#define AES_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC0;\
+	pattrib_iv[1] = txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = txpn._byte_.TSC2;\
+	pattrib_iv[5] = txpn._byte_.TSC3;\
+	pattrib_iv[6] = txpn._byte_.TSC4;\
+	pattrib_iv[7] = txpn._byte_.TSC5;\
+	txpn.val = txpn.val == 0xffffffffffffULL ? 0 : \
+	(txpn.val+1);\
+} while (0)
+
+struct hw_xmit {
+	spinlock_t xmit_lock;
+	struct list_head pending;
+	struct  __queue *sta_queue;
+	struct hw_txqueue *phwtxqueue;
+	sint	txcmdcnt;
+	int	accnt;
+};
+
+struct pkt_attrib {
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+
+	u16	seqnum;
+	u16	ether_type;
+	u16	pktlen;		/* the original 802.3 pkt raw_data len
+				 * (not include ether_hdr data) */
+	u16	last_txcmdsz;
+
+	u8	pkt_hdrlen;	/*the original 802.3 pkt header len*/
+	u8	hdrlen;		/*the WLAN Header Len*/
+	u8	nr_frags;
+	u8	ack_policy;
+	u8	mac_id;
+	u8	vcs_mode;	/*virtual carrier sense method*/
+	u8	pctrl;/*per packet txdesc control enable*/
+	u8	qsel;
+
+	u8	priority;
+	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero,
+				 * indicate the encrypt algorith*/
+	u8	iv_len;
+	u8	icv_len;
+	unsigned char iv[8];
+	unsigned char icv[8];
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	struct sta_info *psta;
+};
+
+#define WLANHDR_OFFSET	64
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+#define MP_FRAMETAG		0x07
+#define TXAGG_FRAMETAG	0x08
+
+struct xmit_buf {
+	struct list_head list;
+
+	u8 *pallocated_buf;
+	u8 *pbuf;
+	void *priv_data;
+	struct urb *pxmit_urb[8];
+	u32 aggr_nr;
+};
+
+struct xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	_pkt *pkt;
+	int frame_tag;
+	struct _adapter *padapter;
+	 u8 *buf_addr;
+	 struct xmit_buf *pxmitbuf;
+	u8 *mem_addr;
+	u16 sz[8];
+	struct urb *pxmit_urb[8];
+	u8 bpending[8];
+	u8 last[8];
+};
+
+struct tx_servq {
+	struct list_head tx_pending;
+	struct  __queue	sta_pending;
+	int qcnt;
+};
+
+struct sta_xmit_priv {
+	spinlock_t lock;
+	sint	option;
+	sint	apsd_setting;	/* When bit mask is on, the associated edca
+				 * queue supports APSD.*/
+	struct tx_servq	be_q;	/* priority == 0,3 */
+	struct tx_servq	bk_q;	/* priority == 1,2*/
+	struct tx_servq	vi_q;	/*priority == 4,5*/
+	struct tx_servq	vo_q;	/*priority == 6,7*/
+	struct list_head  legacy_dz;
+	struct list_head apsd;
+	u16 txseq_tid[16];
+	uint	sta_tx_bytes;
+	u64	sta_tx_pkts;
+	uint	sta_tx_fail;
+};
+
+struct	hw_txqueue {
+	/*volatile*/ sint	head;
+	/*volatile*/ sint	tail;
+	/*volatile*/ sint	free_sz;	/*in units of 64 bytes*/
+	/*volatile*/ sint      free_cmdsz;
+	/*volatile*/ sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+struct	xmit_priv {
+	spinlock_t lock;
+	struct semaphore xmit_sema;
+	struct semaphore terminate_xmitthread_sema;
+	struct  __queue	be_pending;
+	struct  __queue	bk_pending;
+	struct  __queue	vi_pending;
+	struct  __queue	vo_pending;
+	struct  __queue	bm_pending;
+	struct  __queue	legacy_dz_queue;
+	struct  __queue	apsd_queue;
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+	uint mapping_addr;
+	uint pkt_sz;
+	struct  __queue	free_xmit_queue;
+	struct	hw_txqueue	be_txqueue;
+	struct	hw_txqueue	bk_txqueue;
+	struct	hw_txqueue	vi_txqueue;
+	struct	hw_txqueue	vo_txqueue;
+	struct	hw_txqueue	bmc_txqueue;
+	uint	frag_len;
+	struct _adapter	*adapter;
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	u16  rts_thresh;
+	uint	tx_bytes;
+	u64	tx_pkts;
+	uint	tx_drop;
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+	struct semaphore tx_retevt;/*all tx return event;*/
+	u8	txirp_cnt;
+	struct tasklet_struct xmit_tasklet;
+	_workitem xmit_pipe4_reset_wi;
+	_workitem xmit_pipe6_reset_wi;
+	_workitem xmit_piped_reset_wi;
+	/*per AC pending irp*/
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+	struct  __queue	free_amsdu_xmit_queue;
+	u8 *pallocated_amsdu_frame_buf;
+	u8 *pxmit_amsdu_frame_buf;
+	uint free_amsdu_xmitframe_cnt;
+	struct  __queue free_txagg_xmit_queue;
+	u8 *pallocated_txagg_frame_buf;
+	u8 *pxmit_txagg_frame_buf;
+	uint free_txagg_xmitframe_cnt;
+	int cmdseq;
+	struct  __queue free_xmitbuf_queue;
+	struct  __queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;
+};
+
+static inline struct  __queue *get_free_xmit_queue(
+				struct xmit_priv *pxmitpriv)
+{
+	return &(pxmitpriv->free_xmit_queue);
+}
+
+int r8712_free_xmitbuf(struct xmit_priv *pxmitpriv,
+		       struct xmit_buf *pxmitbuf);
+struct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+void r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len);
+struct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+void r8712_free_xmitframe(struct xmit_priv *pxmitpriv,
+			  struct xmit_frame *pxmitframe);
+void r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,
+				struct  __queue *pframequeue);
+sint r8712_xmit_classifier(struct _adapter *padapter,
+			    struct xmit_frame *pxmitframe);
+sint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,
+			      struct xmit_frame *pxmitframe);
+sint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag);
+void _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+sint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,
+			 struct pkt_attrib *pattrib);
+int r8712_txframes_sta_ac_pending(struct _adapter *padapter,
+				  struct pkt_attrib *pattrib);
+sint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,
+			   struct _adapter *padapter);
+void _free_xmit_priv(struct xmit_priv *pxmitpriv);
+void r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,
+			     struct xmit_frame *pxmitframe);
+int r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe);
+int r8712_xmit_enqueue(struct _adapter *padapter,
+		       struct xmit_frame *pxmitframe);
+int r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe);
+void r8712_xmit_bh(void *priv);
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,
+			struct xmit_buf *pxmitbuf);
+
+#include "rtl8712_xmit.h"
+
+#endif	/*_RTL871X_XMIT_H_*/
+
diff --git a/drivers/staging/rtl8712/sta_info.h b/drivers/staging/rtl8712/sta_info.h
new file mode 100644
index 0000000..f8016e9
--- /dev/null
+++ b/drivers/staging/rtl8712/sta_info.h
@@ -0,0 +1,146 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+
+#define NUM_STA 32
+#define NUM_ACL 64
+
+
+/* if mode ==0, then the sta is allowed once the addr is hit.
+ * if mode ==1, then the sta is rejected once the addr is non-hit.
+ */
+struct wlan_acl_node {
+	struct list_head list;
+	u8       addr[ETH_ALEN];
+	u8       mode;
+};
+
+struct wlan_acl_pool {
+	struct wlan_acl_node aclnode[NUM_ACL];
+};
+
+struct	stainfo_stats {
+
+	uint	rx_pkts;
+	uint	rx_bytes;
+	u64	tx_pkts;
+	uint	tx_bytes;
+};
+
+struct sta_info {
+	spinlock_t lock;
+	struct list_head list; /*free_sta_queue*/
+	struct list_head hash_list; /*sta_hash*/
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+	uint state;
+	uint aid;
+	uint	mac_id;
+	uint	qos_option;
+	u8	hwaddr[ETH_ALEN];
+	uint	ieee8021x_blocked;	/*0: allowed, 1:blocked */
+	uint	XPrivacy; /*aes, tkip...*/
+	union Keytype	tkiptxmickey;
+	union Keytype	tkiprxmickey;
+	union Keytype	x_UncstKey;
+	union pn48		txpn;	/* PN48 used for Unicast xmit.*/
+	union pn48		rxpn;	/* PN48 used for Unicast recv.*/
+	u8	bssrateset[16];
+	uint	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+	struct stainfo_stats sta_stats;
+	/*for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+	struct ht_priv	htpriv;
+	/* Notes:
+	 * STA_Mode:
+	 * curr_network(mlme_priv/security_priv/qos/ht)
+	 *   + sta_info: (STA & AP) CAP/INFO
+	 * scan_q: AP CAP/INFO
+	 * AP_Mode:
+	 * curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	 * sta_info: (AP & STA) CAP/INFO
+	 */
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+	unsigned int tx_ra_bitmap;
+};
+
+struct	sta_priv {
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	struct  __queue	free_sta_queue;
+	spinlock_t sta_hash_lock;
+	struct list_head sta_hash[NUM_STA];
+	int asoc_sta_count;
+	struct  __queue sleep_q;
+	struct  __queue wakeup_q;
+	struct _adapter *padapter;
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	unsigned int auth_to;  /* sec, time to expire in authenticating. */
+	unsigned int assoc_to; /* sec, time to expire before associating. */
+	unsigned int expire_to; /* sec , time to expire after associated. */
+};
+
+static inline u32 wifi_mac_hash(u8 *mac)
+{
+	u32 x;
+
+	x = mac[0];
+	x = (x << 2) ^ mac[1];
+	x = (x << 2) ^ mac[2];
+	x = (x << 2) ^ mac[3];
+	x = (x << 2) ^ mac[4];
+	x = (x << 2) ^ mac[5];
+	x ^= x >> 8;
+	x  = x & (NUM_STA - 1);
+	return x;
+}
+
+u32 _r8712_init_sta_priv(struct sta_priv *pstapriv);
+u32 _r8712_free_sta_priv(struct sta_priv *pstapriv);
+struct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv,
+				     u8 *hwaddr);
+void r8712_free_stainfo(struct _adapter *padapter , struct sta_info *psta);
+void r8712_free_all_stainfo(struct _adapter *padapter);
+struct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+void r8712_init_bcmc_stainfo(struct _adapter *padapter);
+struct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter);
+u8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 * mac_addr);
+
+#endif /* _STA_INFO_H_ */
+
diff --git a/drivers/staging/rtl8712/swab.h b/drivers/staging/rtl8712/swab.h
new file mode 100644
index 0000000..f127818
--- /dev/null
+++ b/drivers/staging/rtl8712/swab.h
@@ -0,0 +1,131 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+#ifndef __u16
+ #define __u16 unsigned short
+#endif
+
+#ifndef __u32
+ #define __u32 unsigned int
+#endif
+
+#ifndef __u8
+ #define __u8 unsigned char
+#endif
+
+#ifndef __u64
+ #define __u64 unsigned long long
+#endif
+
+
+static inline __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x;
+	return (__u16)(
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
+		(((__u16)(__x) & (__u16)0xff00U) >> 8));
+
+}
+
+static inline __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return (__u32)(
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24));
+}
+
+static inline __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+
+	return (__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56));
+}
+
+#ifndef __arch__swab16
+static inline __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+static inline __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ;
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+static inline __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ;
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+
+static inline const __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+static inline const __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
+
diff --git a/drivers/staging/rtl8712/usb_halinit.c b/drivers/staging/rtl8712/usb_halinit.c
new file mode 100644
index 0000000..46287c1
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_halinit.c
@@ -0,0 +1,317 @@
+/******************************************************************************
+ * usb_halinit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_HAL_INIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "usb_ops.h"
+#include "usb_osintf.h"
+
+u8 r8712_usb_hal_bus_init(struct _adapter *padapter)
+{
+	u8 val8 = 0;
+	u8 ret = _SUCCESS;
+	int PollingCnt = 20;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	if (pregistrypriv->chip_version == RTL8712_FPGA) {
+		val8 = 0x01;
+		/* switch to 80M clock */
+		r8712_write8(padapter, SYS_CLKR, val8);
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		val8 = val8 | 0x01;
+		/* enable VSPS12 LDO Macro block */
+		r8712_write8(padapter, SPS1_CTRL, val8);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		val8 = val8 | 0x01;
+		/* Enable AFE Macro Block's Bandgap */
+		r8712_write8(padapter, AFE_MISC, val8);
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		val8 = val8 | 0x01;
+		/* enable LDOA15 block */
+		r8712_write8(padapter, LDOA15_CTRL, val8);
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		val8 = val8 | 0x02;
+		/* Enable VSPS12_SW Macro Block */
+		r8712_write8(padapter, SPS1_CTRL, val8);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		val8 = val8 | 0x02;
+		/* Enable AFE Macro Block's Mbias */
+		r8712_write8(padapter, AFE_MISC, val8);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		val8 = val8 | 0x08;
+		/* isolate PCIe Analog 1.2V to PCIe 3.3V and PCIE Digital */
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		val8 = val8 & 0xEF;
+		/* attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		val8 = val8 & 0xFB;
+		/* enable AFE clock */
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		val8 = val8 | 0x01;
+		/* Enable AFE PLL Macro Block */
+		r8712_write8(padapter, AFE_PLL_CTRL, val8);
+		val8 = 0xEE;
+		/* release isolation AFE PLL & MD */
+		r8712_write8(padapter, SYS_ISO_CTRL, val8);
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		val8 = val8 | 0x08;
+		/* enable MAC clock */
+		r8712_write8(padapter, SYS_CLKR + 1, val8);
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		val8 = val8 | 0x08;
+		/* enable Core digital and enable IOREG R/W */
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		val8 = val8 | 0x80;
+		/* enable REG_EN */
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		val8 = (val8 | 0x80) & 0xBF;
+		/* switch the control path */
+		r8712_write8(padapter, SYS_CLKR + 1, val8);
+		val8 = 0xFC;
+		r8712_write8(padapter, CR, val8);
+		val8 = 0x37;
+		r8712_write8(padapter, CR + 1, val8);
+		/* reduce EndPoint & init it */
+		r8712_write8(padapter, 0x102500ab, r8712_read8(padapter,
+			     0x102500ab) | BIT(6) | BIT(7));
+		/* consideration of power consumption - init */
+		r8712_write8(padapter, 0x10250008, r8712_read8(padapter,
+			     0x10250008) & 0xfffffffb);
+	} else if (pregistrypriv->chip_version == RTL8712_1stCUT) {
+		/* Initialization for power on sequence, */
+		r8712_write8(padapter, SPS0_CTRL + 1, 0x53);
+		r8712_write8(padapter, SPS0_CTRL, 0x57);
+		/* Enable AFE Macro Block's Bandgap and Enable AFE Macro
+		 * Block's Mbias
+		 */
+		val8 = r8712_read8(padapter, AFE_MISC);
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN |
+			     AFE_MISC_MBEN));
+		/* Enable LDOA15 block */
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		r8712_write8(padapter, LDOA15_CTRL, (val8 | LDA15_EN));
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		r8712_write8(padapter, SPS1_CTRL, (val8 | SPS1_LDEN));
+		msleep(20);
+		/* Enable Switch Regulator Block */
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		r8712_write8(padapter, SPS1_CTRL, (val8 | SPS1_SWEN));
+		r8712_write32(padapter, SPS1_CTRL, 0x00a7b267);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 | 0x08));
+		/* Engineer Packet CP test Enable */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x20));
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 & 0x6F));
+		/* Enable AFE clock */
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, (val8 & 0xfb));
+		/* Enable AFE PLL Macro Block */
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		/* Attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL);
+		r8712_write8(padapter, SYS_ISO_CTRL, (val8 & 0xEE));
+		/* Switch to 40M clock */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8 & (~SYS_CLKSEL));
+		/* SSC Disable */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		/* Enable MAC clock */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x18));
+		/* Revised POS, */
+		r8712_write8(padapter, PMC_FSM, 0x02);
+		/* Enable Core digital and enable IOREG R/W */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x08));
+		/* Enable REG_EN */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x80));
+		/* Switch the control path to FW */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x80) & 0xBF);
+		r8712_write8(padapter, CR, 0xFC);
+		r8712_write8(padapter, CR + 1, 0x37);
+		/* Fix the RX FIFO issue(usb error), */
+		val8 = r8712_read8(padapter, 0x1025FE5c);
+		r8712_write8(padapter, 0x1025FE5c, (val8|BIT(7)));
+		val8 = r8712_read8(padapter, 0x102500ab);
+		r8712_write8(padapter, 0x102500ab, (val8|BIT(6)|BIT(7)));
+		/* For power save, used this in the bit file after 970621 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8&(~CPU_CLKSEL));
+	} else if (pregistrypriv->chip_version == RTL8712_2ndCUT ||
+		  pregistrypriv->chip_version == RTL8712_3rdCUT) {
+		/* Initialization for power on sequence,
+		 * E-Fuse leakage prevention sequence
+		 */
+		r8712_write8(padapter, 0x37, 0xb0);
+		msleep(20);
+		r8712_write8(padapter, 0x37, 0x30);
+		/* Set control path switch to HW control and reset Digital Core,
+		 * CPU Core and MAC I/O to solve FW download fail when system
+		 * from resume sate.
+		 */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		if (val8 & 0x80) {
+			val8 &= 0x3f;
+			r8712_write8(padapter, SYS_CLKR + 1, val8);
+		}
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		val8 &= 0x73;
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		msleep(20);
+		/* Revised POS, */
+		/* Enable AFE Macro Block's Bandgap and Enable AFE Macro
+		 * Block's Mbias */
+		r8712_write8(padapter, SPS0_CTRL + 1, 0x53);
+		r8712_write8(padapter, SPS0_CTRL, 0x57);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		/*Bandgap*/
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN));
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN |
+			     AFE_MISC_MBEN | AFE_MISC_I32_EN));
+		/* Enable PLL Power (LDOA15V) */
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		r8712_write8(padapter, LDOA15_CTRL, (val8 | LDA15_EN));
+		/* Enable LDOV12D block */
+		val8 = r8712_read8(padapter, LDOV12D_CTRL);
+		r8712_write8(padapter, LDOV12D_CTRL, (val8 | LDV12_EN));
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 | 0x08));
+		/* Engineer Packet CP test Enable */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x20));
+		/* Support 64k IMEM */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 & 0x68));
+		/* Enable AFE clock */
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, (val8 & 0xfb));
+		/* Enable AFE PLL Macro Block */
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		/* Some sample will download fw failure. The clock will be
+		 * stable with 500 us delay after reset the PLL
+		 * TODO: When usleep is added to kernel, change next 3
+		 * udelay(500) to usleep(500)
+		 */
+		udelay(500);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x51));
+		udelay(500);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		udelay(500);
+		/* Attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL);
+		r8712_write8(padapter, SYS_ISO_CTRL, (val8 & 0xEE));
+		/* Switch to 40M clock */
+		r8712_write8(padapter, SYS_CLKR, 0x00);
+		/* CPU Clock and 80M Clock SSC Disable to overcome FW download
+		 * fail timing issue.
+		 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, (val8 | 0xa0));
+		/* Enable MAC clock */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x18));
+		/* Revised POS, */
+		r8712_write8(padapter, PMC_FSM, 0x02);
+		/* Enable Core digital and enable IOREG R/W */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x08));
+		/* Enable REG_EN */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x80));
+		/* Switch the control path to FW */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x80) & 0xBF);
+		r8712_write8(padapter, CR, 0xFC);
+		r8712_write8(padapter, CR + 1, 0x37);
+		/* Fix the RX FIFO issue(usb error), 970410 */
+		val8 = r8712_read8(padapter, 0x1025FE5c);
+		r8712_write8(padapter, 0x1025FE5c, (val8 | BIT(7)));
+		/* For power save, used this in the bit file after 970621 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8 & (~CPU_CLKSEL));
+		/* Revised for 8051 ROM code wrong operation. */
+		r8712_write8(padapter, 0x1025fe1c, 0x80);
+		/* To make sure that TxDMA can ready to download FW.
+		 * We should reset TxDMA if IMEM RPT was not ready.
+		 */
+		do {
+			val8 = r8712_read8(padapter, TCR);
+			if ((val8 & _TXDMA_INIT_VALUE) == _TXDMA_INIT_VALUE)
+				break;
+			udelay(5); /* PlatformStallExecution(5); */
+		} while (PollingCnt--);	/* Delay 1ms */
+
+		if (PollingCnt <= 0) {
+			val8 = r8712_read8(padapter, CR);
+			r8712_write8(padapter, CR, val8&(~_TXDMA_EN));
+			udelay(2); /* PlatformStallExecution(2); */
+			/* Reset TxDMA */
+			r8712_write8(padapter, CR, val8|_TXDMA_EN);
+		}
+	} else
+		ret = _FAIL;
+	return ret;
+}
+
+unsigned int r8712_usb_inirp_init(struct _adapter *padapter)
+{
+	u8 i;
+	struct recv_buf *precvbuf;
+	struct intf_hdl *pintfhdl = &padapter->pio_queue->intf;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	precvpriv->ff_hwaddr = RTL8712_DMA_RX0FF; /* mapping rx fifo address */
+	/* issue Rx irp to receive data */
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		if (r8712_usb_read_port(pintfhdl, precvpriv->ff_hwaddr, 0,
+		   (unsigned char *)precvbuf) == false)
+			return _FAIL;
+		precvbuf++;
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+	return _SUCCESS;
+}
+
+unsigned int r8712_usb_inirp_deinit(struct _adapter *padapter)
+{
+	r8712_usb_read_port_cancel(padapter);
+	return _SUCCESS;
+}
diff --git a/drivers/staging/rtl8712/usb_intf.c b/drivers/staging/rtl8712/usb_intf.c
new file mode 100644
index 0000000..b1e0629
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_intf.c
@@ -0,0 +1,672 @@
+/******************************************************************************
+ * usb_intf.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_INTF_C_
+
+#include <linux/usb.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "rtl8712_efuse.h"
+#include "usb_vendor_req.h"
+#include "usb_ops.h"
+#include "usb_osintf.h"
+#include "hex_to_bin.h"
+
+#define DRVER  "v7_0.20100831"
+
+static struct usb_interface *pintf;
+
+static int r871xu_drv_init(struct usb_interface *pusb_intf,
+			   const struct usb_device_id *pdid);
+
+static void r871xu_dev_remove(struct usb_interface *pusb_intf);
+
+static struct usb_device_id rtl871x_usb_id_tbl[] = {
+
+/* RTL8188SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8171)},
+	{USB_DEVICE(0x0bda, 0x8173)},
+	{USB_DEVICE(0x0bda, 0x8712)},
+	{USB_DEVICE(0x0bda, 0x8713)},
+	{USB_DEVICE(0x0bda, 0xC512)},
+	/* Abocom */
+	{USB_DEVICE(0x07B8, 0x8188)},
+	/* ASUS */
+	{USB_DEVICE(0x0B05, 0x1786)},
+	{USB_DEVICE(0x0B05, 0x1791)}, /* 11n mode disable */
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x945A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0047)},
+	/* D-Link */
+	{USB_DEVICE(0x2001, 0x3306)},
+	{USB_DEVICE(0x07D1, 0x3306)}, /* 11n mode disable */
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7611)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9603)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0016)},
+	/* Hercules */
+	{USB_DEVICE(0x06F8, 0xE034)},
+	{USB_DEVICE(0x06F8, 0xE032)},
+	/* Logitec */
+	{USB_DEVICE(0x0789, 0x0167)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xAB28)},
+	{USB_DEVICE(0x2019, 0xED16)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0057)},
+	{USB_DEVICE(0x0DF6, 0x0045)},
+	{USB_DEVICE(0x0DF6, 0x0059)}, /* 11n mode disable */
+	{USB_DEVICE(0x0DF6, 0x004B)},
+	{USB_DEVICE(0x0DF6, 0x005B)},
+	{USB_DEVICE(0x0DF6, 0x005D)},
+	{USB_DEVICE(0x0DF6, 0x0063)},
+	/* Sweex */
+	{USB_DEVICE(0x177F, 0x0154)},
+	/* Thinkware */
+	{USB_DEVICE(0x0BDA, 0x5077)},
+	/* Toshiba */
+	{USB_DEVICE(0x1690, 0x0752)},
+	/* - */
+	{USB_DEVICE(0x20F4, 0x646B)},
+	{USB_DEVICE(0x083A, 0xC512)},
+
+/* RTL8191SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	/* Amigo */
+	{USB_DEVICE(0x0EB0, 0x9061)},
+	/* ASUS/EKB */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	{USB_DEVICE(0x13D3, 0x3323)},
+	{USB_DEVICE(0x13D3, 0x3311)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3342)},
+	/* ASUS/EKBLenovo */
+	{USB_DEVICE(0x13D3, 0x3333)},
+	{USB_DEVICE(0x13D3, 0x3334)},
+	{USB_DEVICE(0x13D3, 0x3335)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3336)}, /* 11n mode disable */
+	/* ASUS/Media BOX */
+	{USB_DEVICE(0x13D3, 0x3309)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x815F)},
+	/* D-Link */
+	{USB_DEVICE(0x07D1, 0x3302)},
+	{USB_DEVICE(0x07D1, 0x3300)},
+	{USB_DEVICE(0x07D1, 0x3303)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7612)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9605)},
+	/* Guillemot */
+	{USB_DEVICE(0x06F8, 0xE031)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0015)},
+	/* Mediao */
+	{USB_DEVICE(0x13D3, 0x3306)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xED18)},
+	{USB_DEVICE(0x2019, 0x4901)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0058)},
+	{USB_DEVICE(0x0DF6, 0x0049)},
+	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x0064)},
+	/* Skyworth */
+	{USB_DEVICE(0x14b2, 0x3300)},
+	{USB_DEVICE(0x14b2, 0x3301)},
+	{USB_DEVICE(0x14B2, 0x3302)},
+	/* - */
+	{USB_DEVICE(0x04F2, 0xAFF2)},
+	{USB_DEVICE(0x04F2, 0xAFF5)},
+	{USB_DEVICE(0x04F2, 0xAFF6)},
+	{USB_DEVICE(0x13D3, 0x3339)},
+	{USB_DEVICE(0x13D3, 0x3340)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3341)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3310)},
+	{USB_DEVICE(0x13D3, 0x3325)},
+
+/* RTL8192SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x845A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0051)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7622)},
+	/* NEC */
+	{USB_DEVICE(0x0409, 0x02B6)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, rtl871x_usb_id_tbl);
+
+static struct specific_device_id specific_device_id_tbl[] = {
+	{.idVendor = 0x0b05, .idProduct = 0x1791,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x0df6, .idProduct = 0x0059,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3306,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13D3, .idProduct = 0x3311,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3335,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3336,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3340,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3341,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{}
+};
+
+struct drv_priv {
+	struct usb_driver r871xu_drv;
+	int drv_registered;
+};
+
+#ifdef CONFIG_PM
+static int r871x_suspend(struct usb_interface *pusb_intf, pm_message_t state)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+
+	printk(KERN_INFO "r8712: suspending...\n");
+	if (!pnetdev || !netif_running(pnetdev)) {
+		printk(KERN_INFO "r8712: unable to suspend\n");
+		return 0;
+	}
+	if (pnetdev->netdev_ops->ndo_stop)
+		pnetdev->netdev_ops->ndo_stop(pnetdev);
+	mdelay(10);
+	netif_device_detach(pnetdev);
+	return 0;
+}
+
+static int r871x_resume(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+
+	printk(KERN_INFO "r8712: resuming...\n");
+	if (!pnetdev || !netif_running(pnetdev)) {
+		printk(KERN_INFO "r8712: unable to resume\n");
+		return 0;
+	}
+	netif_device_attach(pnetdev);
+	if (pnetdev->netdev_ops->ndo_open)
+		pnetdev->netdev_ops->ndo_open(pnetdev);
+	return 0;
+}
+
+static int r871x_reset_resume(struct usb_interface *pusb_intf)
+{
+	/* dummy routine */
+	return 0;
+}
+
+#endif
+
+static struct drv_priv drvpriv = {
+	.r871xu_drv.name = "r8712u",
+	.r871xu_drv.id_table = rtl871x_usb_id_tbl,
+	.r871xu_drv.probe = r871xu_drv_init,
+	.r871xu_drv.disconnect = r871xu_dev_remove,
+#ifdef CONFIG_PM
+	.r871xu_drv.suspend = r871x_suspend,
+	.r871xu_drv.resume = r871x_resume,
+	.r871xu_drv.reset_resume = r871x_reset_resume,
+#endif
+};
+
+static uint r8712_usb_dvobj_init(struct _adapter *padapter)
+{
+	uint	status = _SUCCESS;
+	struct	usb_device_descriptor		*pdev_desc;
+	struct	usb_host_config			*phost_conf;
+	struct	usb_config_descriptor		*pconf_desc;
+	struct	usb_host_interface		*phost_iface;
+	struct	usb_interface_descriptor	*piface_desc;
+	struct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;
+	struct usb_device *pusbd = pdvobjpriv->pusbdev;
+
+	pdvobjpriv->padapter = padapter;
+	padapter->EepromAddressSize = 6;
+	pdev_desc = &pusbd->descriptor;
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+	phost_iface = &pintf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+	pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
+	if (pusbd->speed == USB_SPEED_HIGH) {
+		pdvobjpriv->ishighspeed = true;
+		printk(KERN_INFO "r8712u: USB_SPEED_HIGH with %d endpoints\n",
+		       pdvobjpriv->nr_endpoint);
+	} else {
+		pdvobjpriv->ishighspeed = false;
+		printk(KERN_INFO "r8712u: USB_SPEED_LOW with %d endpoints\n",
+		       pdvobjpriv->nr_endpoint);
+	}
+	if ((r8712_alloc_io_queue(padapter)) == _FAIL)
+		status = _FAIL;
+	sema_init(&(padapter->dvobjpriv.usb_suspend_sema), 0);
+	return status;
+}
+
+static void r8712_usb_dvobj_deinit(struct _adapter *padapter)
+{
+}
+
+void rtl871x_intf_stop(struct _adapter *padapter)
+{
+	/*disable_hw_interrupt*/
+	if (padapter->bSurpriseRemoved == false) {
+		/*device still exists, so driver can do i/o operation
+		 * TODO: */
+	}
+
+	/* cancel in irp */
+	if (padapter->dvobjpriv.inirp_deinit != NULL)
+		padapter->dvobjpriv.inirp_deinit(padapter);
+	/* cancel out irp */
+	r8712_usb_write_port_cancel(padapter);
+	/* TODO:cancel other irps */
+}
+
+void r871x_dev_unload(struct _adapter *padapter)
+{
+	if (padapter->bup == true) {
+		/*s1.*/
+		padapter->bDriverStopped = true;
+
+		/*s3.*/
+		rtl871x_intf_stop(padapter);
+
+		/*s4.*/
+		r8712_stop_drv_threads(padapter);
+
+		/*s5.*/
+		if (padapter->bSurpriseRemoved == false) {
+			padapter->hw_init_completed = false;
+			rtl8712_hal_deinit(padapter);
+		}
+
+		/*s6.*/
+		if (padapter->dvobj_deinit)
+			padapter->dvobj_deinit(padapter);
+		padapter->bup = false;
+	}
+}
+
+static void disable_ht_for_spec_devid(const struct usb_device_id *pdid,
+				      struct _adapter *padapter)
+{
+	u16 vid, pid;
+	u32 flags;
+	int i;
+	int num = sizeof(specific_device_id_tbl) /
+		  sizeof(struct specific_device_id);
+
+	for (i = 0; i < num; i++) {
+		vid = specific_device_id_tbl[i].idVendor;
+		pid = specific_device_id_tbl[i].idProduct;
+		flags = specific_device_id_tbl[i].flags;
+
+		if ((pdid->idVendor == vid) && (pdid->idProduct == pid) &&
+		    (flags&SPEC_DEV_ID_DISABLE_HT)) {
+			padapter->registrypriv.ht_enable = 0;
+			padapter->registrypriv.cbw40_enable = 0;
+			padapter->registrypriv.ampdu_enable = 0;
+		}
+	}
+}
+
+static u8 key_2char2num(u8 hch, u8 lch)
+{
+	return (hex_to_bin(hch) << 4) | hex_to_bin(lch);
+}
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us
+ * to support. We accept the new device by returning 0.
+*/
+static int r871xu_drv_init(struct usb_interface *pusb_intf,
+			   const struct usb_device_id *pdid)
+{
+	uint status;
+	struct _adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	struct net_device *pnetdev;
+	struct usb_device *udev;
+
+	printk(KERN_INFO "r8712u: DriverVersion: %s\n", DRVER);
+	/* In this probe function, O.S. will provide the usb interface pointer
+	 * to driver. We have to increase the reference count of the usb device
+	 * structure by using the usb_get_dev function.
+	 */
+	udev = interface_to_usbdev(pusb_intf);
+	usb_get_dev(udev);
+	pintf = pusb_intf;
+	/* step 1. */
+	pnetdev = r8712_init_netdev();
+	if (!pnetdev)
+		goto error;
+	padapter = netdev_priv(pnetdev);
+	disable_ht_for_spec_devid(pdid, padapter);
+	pdvobjpriv = &padapter->dvobjpriv;
+	pdvobjpriv->padapter = padapter;
+	padapter->dvobjpriv.pusbdev = udev;
+	padapter->pusb_intf = pusb_intf;
+	usb_set_intfdata(pusb_intf, pnetdev);
+	SET_NETDEV_DEV(pnetdev, &pusb_intf->dev);
+	/* step 2. */
+	padapter->dvobj_init = &r8712_usb_dvobj_init;
+	padapter->dvobj_deinit = &r8712_usb_dvobj_deinit;
+	padapter->halpriv.hal_bus_init = &r8712_usb_hal_bus_init;
+	padapter->dvobjpriv.inirp_init = &r8712_usb_inirp_init;
+	padapter->dvobjpriv.inirp_deinit = &r8712_usb_inirp_deinit;
+	/* step 3.
+	 * initialize the dvobj_priv
+	 */
+	if (padapter->dvobj_init == NULL)
+			goto error;
+	else {
+		status = padapter->dvobj_init(padapter);
+		if (status != _SUCCESS)
+			goto error;
+	}
+	/* step 4. */
+	status = r8712_init_drv_sw(padapter);
+	if (status == _FAIL)
+		goto error;
+	/* step 5. read efuse/eeprom data and get mac_addr */
+	{
+		int i, offset;
+		u8 mac[6];
+		u8 tmpU1b, AutoloadFail, eeprom_CustomerID;
+		u8 *pdata = padapter->eeprompriv.efuse_eeprom_data;
+
+		tmpU1b = r8712_read8(padapter, EE_9346CR);/*CR9346*/
+
+		/* To check system boot selection.*/
+		printk(KERN_INFO "r8712u: Boot from %s: Autoload %s\n",
+		       (tmpU1b & _9356SEL) ? "EEPROM" : "EFUSE",
+		       (tmpU1b & _EEPROM_EN) ? "OK" : "Failed");
+
+		/* To check autoload success or not.*/
+		if (tmpU1b & _EEPROM_EN) {
+			AutoloadFail = true;
+			/* The following operations prevent Efuse leakage by
+			 * turning on 2.5V.
+			 */
+			tmpU1b = r8712_read8(padapter, EFUSE_TEST+3);
+			r8712_write8(padapter, EFUSE_TEST + 3, tmpU1b | 0x80);
+			msleep(20);
+			r8712_write8(padapter, EFUSE_TEST + 3,
+				     (tmpU1b & (~BIT(7))));
+
+			/* Retrieve Chip version.
+			 * Recognize IC version by Reg0x4 BIT15.
+			 */
+			tmpU1b = (u8)((r8712_read32(padapter, PMC_FSM) >> 15) &
+						    0x1F);
+			if (tmpU1b == 0x3)
+				padapter->registrypriv.chip_version =
+				     RTL8712_3rdCUT;
+			else
+				padapter->registrypriv.chip_version =
+				     (tmpU1b >> 1) + 1;
+			switch (padapter->registrypriv.chip_version) {
+			case RTL8712_1stCUT:
+			case RTL8712_2ndCUT:
+			case RTL8712_3rdCUT:
+				break;
+			default:
+				padapter->registrypriv.chip_version =
+				     RTL8712_2ndCUT;
+				break;
+			}
+
+			for (i = 0, offset = 0; i < 128; i += 8, offset++)
+				r8712_efuse_pg_packet_read(padapter, offset,
+						     &pdata[i]);
+
+			if (r8712_initmac) {
+				/* Users specify the mac address */
+				int jj, kk;
+
+				for (jj = 0, kk = 0; jj < ETH_ALEN;
+				     jj++, kk += 3)
+					mac[jj] =
+					   key_2char2num(r8712_initmac[kk],
+					   r8712_initmac[kk + 1]);
+			} else {
+				/* Use the mac address stored in the Efuse
+				 * offset = 0x12 for usb in efuse
+				 */
+				memcpy(mac, &pdata[0x12], ETH_ALEN);
+			}
+			eeprom_CustomerID = pdata[0x52];
+			switch (eeprom_CustomerID) {
+			case EEPROM_CID_ALPHA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_ALPHA;
+				break;
+			case EEPROM_CID_CAMEO:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CAMEO;
+				break;
+			case EEPROM_CID_SITECOM:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Sitecom;
+				break;
+			case EEPROM_CID_COREGA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_COREGA;
+				break;
+			case EEPROM_CID_Senao:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Senao;
+				break;
+			case EEPROM_CID_EDIMAX_BELKIN:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Edimax_Belkin;
+				break;
+			case EEPROM_CID_SERCOMM_BELKIN:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Sercomm_Belkin;
+				break;
+			case EEPROM_CID_WNC_COREGA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_WNC_COREGA;
+				break;
+			case EEPROM_CID_WHQL:
+				break;
+			case EEPROM_CID_NetCore:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Netcore;
+				break;
+			case EEPROM_CID_CAMEO1:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CAMEO1;
+				break;
+			case EEPROM_CID_CLEVO:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CLEVO;
+				break;
+			default:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_DEFAULT;
+				break;
+			}
+			printk(KERN_INFO "r8712u: CustomerID = 0x%.4x\n",
+			     padapter->eeprompriv.CustomerID);
+			/* Led mode */
+			switch (padapter->eeprompriv.CustomerID) {
+			case RT_CID_DEFAULT:
+			case RT_CID_819x_ALPHA:
+			case RT_CID_819x_CAMEO:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE1;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Sitecom:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE2;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_COREGA:
+			case RT_CID_819x_Senao:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE3;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Edimax_Belkin:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE4;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Sercomm_Belkin:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE5;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_WNC_COREGA:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE6;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			default:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE0;
+				padapter->ledpriv.bRegUseLed = false;
+				break;
+			}
+		} else
+			AutoloadFail = false;
+		if (((mac[0] == 0xff) && (mac[1] == 0xff) &&
+		     (mac[2] == 0xff) && (mac[3] == 0xff) &&
+		     (mac[4] == 0xff) && (mac[5] == 0xff)) ||
+		    ((mac[0] == 0x00) && (mac[1] == 0x00) &&
+		     (mac[2] == 0x00) && (mac[3] == 0x00) &&
+		     (mac[4] == 0x00) && (mac[5] == 0x00)) ||
+		     (AutoloadFail == false)) {
+			mac[0] = 0x00;
+			mac[1] = 0xe0;
+			mac[2] = 0x4c;
+			mac[3] = 0x87;
+			mac[4] = 0x00;
+			mac[5] = 0x00;
+		}
+		if (r8712_initmac) {
+			/* Make sure the user did not select a multicast
+			 * address by setting bit 1 of first octet.
+			 */
+			mac[0] &= 0xFE;
+			printk(KERN_INFO "r8712u: MAC Address from user = "
+			       "%pM\n", mac);
+		} else
+			printk(KERN_INFO "r8712u: MAC Address from efuse = "
+			       "%pM\n", mac);
+		memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+	}
+	/* step 6. Load the firmware asynchronously */
+	if (rtl871x_load_fw(padapter))
+		goto error;
+	spin_lock_init(&padapter->lockRxFF0Filter);
+	mutex_init(&padapter->mutex_start);
+	return 0;
+error:
+	usb_put_dev(udev);
+	usb_set_intfdata(pusb_intf, NULL);
+	if (padapter->dvobj_deinit != NULL)
+		padapter->dvobj_deinit(padapter);
+	if (pnetdev)
+		free_netdev(pnetdev);
+	return -ENODEV;
+}
+
+/* rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove()
+ * => how to recognize both */
+static void r871xu_dev_remove(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+	struct _adapter *padapter = netdev_priv(pnetdev);
+	struct usb_device *udev = interface_to_usbdev(pusb_intf);
+
+	if (padapter->fw_found)
+		release_firmware(padapter->fw);
+	/* never exit with a firmware callback pending */
+	wait_for_completion(&padapter->rtl8712_fw_ready);
+	usb_set_intfdata(pusb_intf, NULL);
+	if (padapter) {
+		if (drvpriv.drv_registered == true)
+			padapter->bSurpriseRemoved = true;
+		if (pnetdev != NULL) {
+			/* will call netdev_close() */
+			unregister_netdev(pnetdev);
+		}
+		flush_scheduled_work();
+		udelay(1);
+		/*Stop driver mlme relation timer */
+		if (padapter->fw_found)
+			r8712_stop_drv_timers(padapter);
+		r871x_dev_unload(padapter);
+		r8712_free_drv_sw(padapter);
+	}
+	usb_set_intfdata(pusb_intf, NULL);
+	/* decrease the reference count of the usb device structure
+	 * when disconnect */
+	usb_put_dev(udev);
+	/* If we didn't unplug usb dongle and remove/insert modlue, driver
+	 * fails on sitesurvey for the first time when device is up.
+	 * Reset usb port for sitesurvey fail issue. */
+	if (udev->state != USB_STATE_NOTATTACHED)
+		usb_reset_device(udev);
+	return;
+}
+
+static int __init r8712u_drv_entry(void)
+{
+	drvpriv.drv_registered = true;
+	return usb_register(&drvpriv.r871xu_drv);
+}
+
+static void __exit r8712u_drv_halt(void)
+{
+	drvpriv.drv_registered = false;
+	usb_deregister(&drvpriv.r871xu_drv);
+	printk(KERN_INFO "r8712u: Driver unloaded\n");
+}
+
+module_init(r8712u_drv_entry);
+module_exit(r8712u_drv_halt);
diff --git a/drivers/staging/rtl8712/usb_ops.c b/drivers/staging/rtl8712/usb_ops.c
new file mode 100644
index 0000000..5a8b0eb
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_ops.c
@@ -0,0 +1,201 @@
+/******************************************************************************
+ * usb_ops.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_OPS_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+#include "recv_osdep.h"
+#include "rtl871x_byteorder.h"
+
+static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return (u8)(le32_to_cpu(data)&0x0ff);
+}
+
+static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return (u16)(le32_to_cpu(data)&0xffff);
+}
+
+static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return le32_to_cpu(data);
+}
+
+static void usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	data = val;
+	data = cpu_to_le32(data&0x000000ff);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+static void usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	data = val;
+	data = cpu_to_le32(data&0x0000ffff);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+static void usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = cpu_to_le32(val);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+void r8712_usb_set_intf_option(u32 *poption)
+{
+	*poption = ((*poption) | _INTF_ASYNC_);
+}
+
+static void usb_intf_hdl_init(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_unload(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_open(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_close(u8 *priv)
+{
+}
+
+void r8712_usb_set_intf_funs(struct intf_hdl *pintf_hdl)
+{
+	pintf_hdl->intf_hdl_init = &usb_intf_hdl_init;
+	pintf_hdl->intf_hdl_unload = &usb_intf_hdl_unload;
+	pintf_hdl->intf_hdl_open = &usb_intf_hdl_open;
+	pintf_hdl->intf_hdl_close = &usb_intf_hdl_close;
+}
+
+void r8712_usb_set_intf_ops(struct _io_ops	*pops)
+{
+	memset((u8 *)pops, 0, sizeof(struct _io_ops));
+	pops->_read8 = &usb_read8;
+	pops->_read16 = &usb_read16;
+	pops->_read32 = &usb_read32;
+	pops->_read_port = &r8712_usb_read_port;
+	pops->_write8 = &usb_write8;
+	pops->_write16 = &usb_write16;
+	pops->_write32 = &usb_write32;
+	pops->_write_mem = &r8712_usb_write_mem;
+	pops->_write_port = &r8712_usb_write_port;
+}
diff --git a/drivers/staging/rtl8712/usb_ops.h b/drivers/staging/rtl8712/usb_ops.h
new file mode 100644
index 0000000..78e775a
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_ops.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+
+void r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr,
+			 u32 cnt, u8 *wmem);
+u32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr,
+			  u32 cnt, u8 *wmem);
+u32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr,
+			 u32 cnt, u8 *rmem);
+void r8712_usb_set_intf_option(u32 *poption);
+void r8712_usb_set_intf_funs(struct intf_hdl *pintf_hdl);
+uint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv);
+void r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv);
+void r8712_usb_set_intf_ops(struct _io_ops *pops);
+void r8712_usb_read_port_cancel(struct _adapter *padapter);
+void r8712_usb_write_port_cancel(struct _adapter *padapter);
+int r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,
+		      u16 index, void *pdata, u16 len, u8 requesttype);
+
+#endif
+
diff --git a/drivers/staging/rtl8712/usb_ops_linux.c b/drivers/staging/rtl8712/usb_ops_linux.c
new file mode 100644
index 0000000..24e1ec5
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_ops_linux.c
@@ -0,0 +1,530 @@
+/******************************************************************************
+ * usb_ops_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_OPS_OS_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+#define	RTL871X_VENQT_READ	0xc0
+#define	RTL871X_VENQT_WRITE	0x40
+
+struct zero_bulkout_context {
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+#define usb_write_cmd r8712_usb_write_mem
+#define usb_write_cmd_complete usb_write_mem_complete
+
+uint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv)
+{
+	pintfpriv->piorw_urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!pintfpriv->piorw_urb)
+		return _FAIL;
+	sema_init(&(pintfpriv->io_retevt), 0);
+	return _SUCCESS;
+}
+
+void r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv)
+{
+	if (pintfpriv->piorw_urb) {
+		usb_kill_urb(pintfpriv->piorw_urb);
+		usb_free_urb(pintfpriv->piorw_urb);
+	}
+}
+
+static unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
+{
+	unsigned int pipe = 0;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	if (pdvobj->nr_endpoint == 11) {
+		switch (addr) {
+		case RTL8712_DMA_BKQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x07);
+			break;
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VIQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x05);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_BCNQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0a);
+			break;
+		case RTL8712_DMA_BMCQ:	/* HI Queue */
+			pipe = usb_sndbulkpipe(pusbd, 0x0b);
+			break;
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0c);
+			break;
+		case RTL8712_DMA_RX0FF:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x09); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 6) {
+		switch (addr) {
+		case RTL8712_DMA_BKQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x07);
+			break;
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VIQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x05);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_RX0FF:
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+		case RTL8712_DMA_BCNQ:
+		case RTL8712_DMA_BMCQ:
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 4) {
+		switch (addr) {
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_RX0FF:
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+		case RTL8712_DMA_BCNQ:
+		case RTL8712_DMA_BMCQ:
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else
+	   pipe = 0;
+	return pipe;
+}
+
+static void usb_write_mem_complete(struct urb *purb)
+{
+	struct io_queue *pio_q = (struct io_queue *)purb->context;
+	struct intf_hdl *pintf = &(pio_q->intf);
+	struct intf_priv *pintfpriv = pintf->pintfpriv;
+	struct _adapter *padapter = (struct _adapter *)pintf->adapter;
+
+	if (purb->status != 0) {
+		if (purb->status == (-ESHUTDOWN))
+			padapter->bDriverStopped = true;
+		else
+			padapter->bSurpriseRemoved = true;
+	}
+	up(&pintfpriv->io_retevt);
+}
+
+void r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	unsigned int pipe;
+	int status;
+	struct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct io_queue *pio_queue = (struct io_queue *)padapter->pio_queue;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct urb *piorw_urb = pintfpriv->piorw_urb;
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
+		return;
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+	if (pipe == 0)
+		return;
+	usb_fill_bulk_urb(piorw_urb, pusbd, pipe,
+			  wmem, cnt, usb_write_mem_complete,
+			  pio_queue);
+	status = usb_submit_urb(piorw_urb, GFP_ATOMIC);
+	_down_sema(&pintfpriv->io_retevt);
+}
+
+static void r8712_usb_read_port_complete(struct urb *purb)
+{
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
+	struct _adapter *padapter = (struct _adapter *)precvbuf->adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped)
+		return;
+	if (purb->status == 0) { /* SUCCESS */
+		if ((purb->actual_length > (MAX_RECVBUF_SZ)) ||
+		    (purb->actual_length < RXDESC_SIZE)) {
+			precvbuf->reuse = true;
+			r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+				  (unsigned char *)precvbuf);
+		} else {
+			precvbuf->transfer_len = purb->actual_length;
+			pbuf = (uint *)precvbuf->pbuf;
+			isevt = le32_to_cpu(*(pbuf + 1)) & 0x1ff;
+			if ((isevt & 0x1ff) == 0x1ff) {
+				r8712_rxcmd_event_hdl(padapter, pbuf);
+				precvbuf->reuse = true;
+				r8712_read_port(padapter, precvpriv->ff_hwaddr,
+						0, (unsigned char *)precvbuf);
+			} else {
+				_pkt *pskb = precvbuf->pskb;
+				skb_put(pskb, purb->actual_length);
+				skb_queue_tail(&precvpriv->rx_skb_queue, pskb);
+				tasklet_hi_schedule(&precvpriv->recv_tasklet);
+				precvbuf->pskb = NULL;
+				precvbuf->reuse = false;
+				r8712_read_port(padapter, precvpriv->ff_hwaddr,
+						0, (unsigned char *)precvbuf);
+			}
+		}
+	} else {
+		switch (purb->status) {
+		case -EINVAL:
+		case -EPIPE:
+		case -ENODEV:
+		case -ESHUTDOWN:
+		case -ENOENT:
+			padapter->bDriverStopped = true;
+			break;
+		case -EPROTO:
+			precvbuf->reuse = true;
+			r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+				  (unsigned char *)precvbuf);
+			break;
+		case -EINPROGRESS:
+			printk(KERN_ERR "r8712u: ERROR: URB IS IN"
+			       " PROGRESS!/n");
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+u32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	unsigned int pipe;
+	int err;
+	u32 tmpaddr = 0;
+	int alignment = 0;
+	u32 ret = _SUCCESS;
+	struct urb *purb = NULL;
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	struct _adapter *adapter = (struct _adapter *)pdvobj->padapter;
+	struct recv_priv *precvpriv = &adapter->recvpriv;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||
+	    adapter->pwrctrlpriv.pnp_bstop_trx)
+		return _FAIL;
+	if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+		precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue);
+		if (NULL != precvbuf->pskb)
+			precvbuf->reuse = true;
+	}
+	if (precvbuf != NULL) {
+		r8712_init_recvbuf(adapter, precvbuf);
+		/* re-assign for linux based on skb */
+		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev,
+					 MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+			if (precvbuf->pskb == NULL)
+				return _FAIL;
+			tmpaddr = (addr_t)precvbuf->pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(precvbuf->pskb,
+				    (RECVBUFF_ALIGN_SZ - alignment));
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+		} else { /* reuse skb */
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+			precvbuf->reuse = false;
+		}
+		purb = precvbuf->purb;
+		/* translate DMA FIFO addr to pipehandle */
+		pipe = ffaddr2pipehdl(pdvobj, addr);
+		usb_fill_bulk_urb(purb, pusbd, pipe,
+				  precvbuf->pbuf, MAX_RECVBUF_SZ,
+				  r8712_usb_read_port_complete,
+				  precvbuf);
+		err = usb_submit_urb(purb, GFP_ATOMIC);
+		if ((err) && (err != (-EPERM)))
+			ret = _FAIL;
+	} else
+		ret = _FAIL;
+	return ret;
+}
+
+void r8712_usb_read_port_cancel(struct _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+
+	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		if (precvbuf->purb)
+			usb_kill_urb(precvbuf->purb);
+		precvbuf++;
+	}
+}
+
+void r8712_xmit_bh(void *priv)
+{
+	int ret = false;
+	struct _adapter *padapter = (struct _adapter *)priv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true)) {
+		printk(KERN_ERR "r8712u: xmit_bh => bDriverStopped"
+		       " or bSurpriseRemoved\n");
+		return;
+	}
+	ret = r8712_xmitframe_complete(padapter, pxmitpriv, NULL);
+	if (ret == false)
+		return;
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+}
+
+static void usb_write_port_complete(struct urb *purb)
+{
+	int i;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)purb->context;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	switch (pattrib->priority) {
+	case 1:
+	case 2:
+		pxmitpriv->bkq_cnt--;
+		break;
+	case 4:
+	case 5:
+		pxmitpriv->viq_cnt--;
+		break;
+	case 6:
+	case 7:
+		pxmitpriv->voq_cnt--;
+		break;
+	case 0:
+	case 3:
+	default:
+		pxmitpriv->beq_cnt--;
+		break;
+	}
+	pxmitpriv->txirp_cnt--;
+	for (i = 0; i < 8; i++) {
+		if (purb == pxmitframe->pxmit_urb[i]) {
+			pxmitframe->bpending[i] = false;
+			break;
+		}
+	}
+	if (padapter->bSurpriseRemoved)
+		return;
+	switch (purb->status) {
+	case 0:
+		break;
+	default:
+		printk(KERN_WARNING "r8712u: pipe error: (%d)\n", purb->status);
+		break;
+	}
+	/* not to consider tx fragment */
+	r8712_free_xmitframe_ex(pxmitpriv, pxmitframe);
+	r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+}
+
+u32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	unsigned long irqL;
+	int i, status;
+	unsigned int pipe;
+	u32 ret, bwritezero;
+	struct urb *purb = NULL;
+	struct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
+		return _FAIL;
+	for (i = 0; i < 8; i++) {
+		if (pxmitframe->bpending[i] == false) {
+			spin_lock_irqsave(&pxmitpriv->lock, irqL);
+			pxmitpriv->txirp_cnt++;
+			pxmitframe->bpending[i]  = true;
+			switch (pattrib->priority) {
+			case 1:
+			case 2:
+				pxmitpriv->bkq_cnt++;
+				break;
+			case 4:
+			case 5:
+				pxmitpriv->viq_cnt++;
+				break;
+			case 6:
+			case 7:
+				pxmitpriv->voq_cnt++;
+				break;
+			case 0:
+			case 3:
+			default:
+				pxmitpriv->beq_cnt++;
+				break;
+			}
+			spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+			pxmitframe->sz[i] = (u16)cnt;
+			purb = pxmitframe->pxmit_urb[i];
+			break;
+		}
+	}
+	bwritezero = false;
+	if (pdvobj->ishighspeed) {
+		if (cnt > 0 && cnt % 512 == 0)
+			bwritezero = true;
+	} else {
+		if (cnt > 0 && cnt % 64 == 0)
+			bwritezero = true;
+	}
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+	if (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	else
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+	if (bwritezero)
+		cnt += 8;
+	usb_fill_bulk_urb(purb, pusbd, pipe,
+			  pxmitframe->mem_addr,
+			  cnt, usb_write_port_complete,
+			  pxmitframe); /* context is xmit_frame */
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+	if (!status)
+		ret = _SUCCESS;
+	else
+		ret = _FAIL;
+	return ret;
+}
+
+void r8712_usb_write_port_cancel(struct _adapter *padapter)
+{
+	int i, j;
+	struct xmit_buf	*pxmitbuf = (struct xmit_buf *)
+				     padapter->xmitpriv.pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		for (j = 0; j < 8; j++) {
+			if (pxmitbuf->pxmit_urb[j])
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+		}
+		pxmitbuf++;
+	}
+}
+
+int r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,
+		      u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	unsigned int pipe;
+	int status;
+	u8 reqtype;
+	struct dvobj_priv *pdvobjpriv = (struct dvobj_priv *)
+					 pintfpriv->intf_dev;
+	struct usb_device *udev = pdvobjpriv->pusbdev;
+	/* For mstar platform, mstar suggests the address for USB IO
+	 * should be 16 bytes alignment. Trying to fix it here.
+	 */
+	u8 *palloc_buf, *pIo_buf;
+
+	palloc_buf = _malloc((u32) len + 16);
+	if (palloc_buf == NULL) {
+		printk(KERN_ERR "r8712u: [%s] Can't alloc memory for vendor"
+		       " request\n", __func__);
+		return -1;
+	}
+	pIo_buf = palloc_buf + 16 - ((addr_t)(palloc_buf) & 0x0f);
+	if (requesttype == 0x01) {
+		pipe = usb_rcvctrlpipe(udev, 0); /* read_in */
+		reqtype =  RTL871X_VENQT_READ;
+	} else {
+		pipe = usb_sndctrlpipe(udev, 0); /* write_out */
+		reqtype =  RTL871X_VENQT_WRITE;
+		memcpy(pIo_buf, pdata, len);
+	}
+	status = usb_control_msg(udev, pipe, request, reqtype, value, index,
+				 pIo_buf, len, HZ / 2);
+	if (status > 0) {  /* Success this control transfer. */
+		if (requesttype == 0x01) {
+			/* For Control read transfer, we have to copy the read
+			 * data from pIo_buf to pdata.
+			 */
+			memcpy(pdata, pIo_buf,  status);
+		}
+	}
+	kfree(palloc_buf);
+	return status;
+}
diff --git a/drivers/staging/rtl8712/usb_osintf.h b/drivers/staging/rtl8712/usb_osintf.h
new file mode 100644
index 0000000..d95797aa
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_osintf.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "usb_vendor_req.h"
+
+#define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)
+
+extern char *r8712_initmac;
+
+unsigned int r8712_usb_inirp_init(struct _adapter *padapter);
+unsigned int r8712_usb_inirp_deinit(struct _adapter *padapter);
+uint rtl871x_hal_init(struct _adapter *padapter);
+uint rtl8712_hal_deinit(struct _adapter *padapter);
+
+void rtl871x_intf_stop(struct _adapter *padapter);
+void r871x_dev_unload(struct _adapter *padapter);
+void r8712_stop_drv_threads(struct _adapter *padapter);
+void r8712_stop_drv_timers(struct _adapter *padapter);
+u8 r8712_init_drv_sw(struct _adapter *padapter);
+u8 r8712_free_drv_sw(struct _adapter *padapter);
+struct net_device *r8712_init_netdev(void);
+
+#endif
diff --git a/drivers/staging/rtl8712/usb_vendor_req.h b/drivers/staging/rtl8712/usb_vendor_req.h
new file mode 100644
index 0000000..82335a8
--- /dev/null
+++ b/drivers/staging/rtl8712/usb_vendor_req.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+/*4	Set/Get Register related wIndex/Data */
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON			1
+#define	RT_USB_LDO_OFF			0
+
+/*4	Set/Get SYSCLK related	wValue or Data */
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+enum RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+};
+
+enum RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO		=	4,
+	RT_USB_BOOT_TYPE	=	5
+};
+
+#endif
+
diff --git a/drivers/staging/rtl8712/wifi.h b/drivers/staging/rtl8712/wifi.h
new file mode 100644
index 0000000..277398c
--- /dev/null
+++ b/drivers/staging/rtl8712/wifi.h
@@ -0,0 +1,643 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+#include "rtl871x_byteorder.h"
+#include <linux/compiler.h>
+
+#ifdef BIT
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	/*!< QoS Data */
+};
+
+enum WIFI_FRAME_SUBTYPE {
+	/* below is for mgt frame */
+	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	/* below is for control frame */
+	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_CFEND_CFACK = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	/* below is for data frame */
+	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_			= 0,
+	_RSON_UNSPECIFIED_		= 1,
+	_RSON_AUTH_NO_LONGER_VALID_	= 2,
+	_RSON_DEAUTH_STA_LEAVING_	= 3,
+	_RSON_INACTIVITY_		= 4,
+	_RSON_UNABLE_HANDLE_		= 5,
+	_RSON_CLS2_			= 6,
+	_RSON_CLS3_			= 7,
+	_RSON_DISAOC_STA_LEAVING_	= 8,
+	_RSON_ASOC_NOT_AUTH_		= 9,
+	/* WPA reason */
+	_RSON_INVALID_IE_		= 13,
+	_RSON_MIC_FAILURE_		= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_	= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_			= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_		= 20,
+	_RSON_UNSUPPORT_RSNE_VER_	= 21,
+	_RSON_INVALID_RSNE_CAP_		= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+	/* below are Realtek definitions */
+	_RSON_PMK_NOT_AVAILABLE_	= 24,
+};
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_		= 0,
+	_STATS_FAILURE_			= 1,
+	_STATS_CAP_FAIL_		= 10,
+	_STATS_NO_ASOC_			= 11,
+	_STATS_OTHER_			= 12,
+	_STATS_NO_SUPP_ALG_		= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_		= 18,
+};
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC	= 1,
+	DOMAIN_IC	= 2,
+	DOMAIN_ETSI	= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK	= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1	= 8,
+	DOMAIN_MKK2	= 9,
+	DOMAIN_MKK3	= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_		BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while (0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while (0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while (0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while (0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while (0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while (0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while (0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while (0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while (0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while (0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while (0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while (0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while (0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & \
+				le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while (0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & \
+				(BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf, type)	\
+	do {	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | \
+		BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while (0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & \
+				(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | \
+				BIT(2)))
+
+#define SetFrameSubType(pbuf, type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | \
+		BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while (0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)\
+				((addr_t)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)\
+				(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)\
+				((addr_t)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 22) = \
+			((*(unsigned short *)((addr_t)(pbuf) + 22)) & \
+			le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while (0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 22) = \
+			((*(unsigned short *)((addr_t)(pbuf) + 22)) & \
+			le16_to_cpu((unsigned short)0x000f)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while (0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 2) |= \
+			cpu_to_le16(0xffff & (dur)); \
+	} while (0)
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while (0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
+	} while (0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
+	} while (0)
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)(pbuf) + 2)) \
+			& 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)(pbuf) + \
+			(((GetToDs(pbuf) << 1)|GetFrDs(pbuf)) == 3 ? \
+			30 : 24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 24))
+
+
+
+static inline int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return true;
+	else
+		return false;
+}
+
+
+static inline unsigned char *get_da(unsigned char *pframe)
+{
+	unsigned char	*da;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	}
+	return da;
+}
+
+
+static inline unsigned char *get_sa(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		sa = GetAddr4Ptr(pframe);
+		break;
+	}
+
+	return sa;
+}
+
+static inline unsigned char *get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = GetAddr1Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		sa = NULL;
+		break;
+	}
+	return sa;
+}
+
+
+
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_	2
+#define _PRE_ALLOCMEM_		1
+#define _PRE_ALLOCHDR_		3
+#define _PRE_ALLOCLLCHDR_	4
+#define _PRE_ALLOCICVHDR_	5
+#define _PRE_ALLOCMICHDR_	6
+
+#define _SIFSTIME_		((priv->pmib->BssType.net_work_type & \
+				WIRELESS_11A) ? 16 : 10)
+#define _ACKCTSLNG_		14	/*14 bytes long, including crclng */
+#define _CRCLNG_		4
+
+#define _ASOCREQ_IE_OFFSET_	4	/* excluding wlan_hdr */
+#define	_ASOCRSP_IE_OFFSET_	6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_	6
+#define _DEAUTH_IE_OFFSET_	0
+#define _BEACON_IE_OFFSET_	12
+
+#define _FIXED_IE_LENGTH_	_BEACON_IE_OFFSET_
+
+#define _SSID_IE_		0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_		3
+#define _TIM_IE_		5
+#define _IBSS_PARA_IE_		6
+#define _CHLGETXT_IE_		16
+#define _RSN_IE_2_		48`
+#define _SSN_IE_1_		221
+#define _ERPINFO_IE_		42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_	45
+#define _HT_EXTRA_INFO_IE_	61
+#define _HT_ADD_INFO_IE_	61 /* _HT_EXTRA_INFO_IE_ */
+
+#define _VENDOR_SPECIFIC_IE_	221
+
+#define	_RESERVED47_		47
+
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1	/*WPA */
+#define _IEEE8021X_PSK_			2	/* WPA with pre-shared key */
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  /* for WMM STA */
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while (0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & \
+				le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __packed;
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+
+ /**
+ * struct ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+
+struct ieee80211_ht_cap {
+	unsigned short	cap_info;
+	unsigned char	ampdu_params_info;
+	unsigned char	supp_mcs_set[16];
+	unsigned short	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __packed;
+
+/**
+ * struct ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __packed;
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE		0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+#endif /* _WIFI_H_ */
+
diff --git a/drivers/staging/rtl8712/wlan_bssdef.h b/drivers/staging/rtl8712/wlan_bssdef.h
new file mode 100644
index 0000000..2ea8a3d
--- /dev/null
+++ b/drivers/staging/rtl8712/wlan_bssdef.h
@@ -0,0 +1,267 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+#define MAX_IE_SZ	768
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+/* Set of 8 data rates*/
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];
+/* Set of 16 data rates */
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];
+
+struct ndis_802_11_ssid {
+	u32 SsidLength;
+	u8  Ssid[32];
+};
+
+enum NDIS_802_11_NETWORK_TYPE {
+	Ndis802_11FH,
+	Ndis802_11DS,
+	Ndis802_11OFDM5,
+	Ndis802_11OFDM24,
+	Ndis802_11NetworkTypeMax /* not a real type, defined as an upper bound*/
+};
+
+struct NDIS_802_11_CONFIGURATION_FH {
+	u32 Length;             /* Length of structure */
+	u32 HopPattern;         /* As defined by 802.11, MSB set */
+	u32 HopSet;             /* to one if non-802.11 */
+	u32 DwellTime;          /* units are Kusec */
+};
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+struct NDIS_802_11_CONFIGURATION {
+	u32 Length;             /* Length of structure */
+	u32 BeaconPeriod;       /* units are Kusec */
+	u32 ATIMWindow;         /* units are Kusec */
+	u32 DSConfig;           /* Frequency, units are kHz */
+	struct NDIS_802_11_CONFIGURATION_FH FHConfig;
+};
+
+enum NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	Ndis802_11IBSS,
+	Ndis802_11Infrastructure,
+	Ndis802_11AutoUnknown,
+	Ndis802_11InfrastructureMax, /*Not a real value,defined as upper bound*/
+	Ndis802_11APMode
+};
+
+struct NDIS_802_11_FIXED_IEs {
+	u8  Timestamp[8];
+	u16 BeaconInterval;
+	u16 Capabilities;
+};
+
+/*
+ * Length is the 4 bytes multiples of the sume of
+ * 6 * sizeof (unsigned char) + 2 + sizeof (ndis_802_11_ssid) + sizeof (u32)
+ * + sizeof (s32) + sizeof (NDIS_802_11_NETWORK_TYPE)
+ * + sizeof (struct NDIS_802_11_CONFIGURATION)
+ * + sizeof (NDIS_802_11_RATES_EX) + IELength
+
+ * Except the IELength, all other fields are fixed length. Therefore, we can
+ * define a macro to present the partial sum.
+ */
+
+struct ndis_wlan_bssid_ex {
+	u32 Length;
+	unsigned char  MacAddress[6];
+	u8  Reserved[2];
+	struct ndis_802_11_ssid  Ssid;
+	u32 Privacy;
+	s32 Rssi;
+	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	struct NDIS_802_11_CONFIGURATION  Configuration;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	NDIS_802_11_RATES_EX  SupportedRates;
+	u32 IELength;
+	/*(timestamp, beacon interval, and capability information) */
+	u8 IEs[MAX_IE_SZ];
+};
+
+enum NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeMax      /* Not a real mode, defined as upper bound */
+};
+
+enum {
+	Ndis802_11WEPEnabled,
+	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+	Ndis802_11WEPDisabled,
+	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+	Ndis802_11WEPKeyAbsent,
+	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+	Ndis802_11WEPNotSupported,
+	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+	Ndis802_11Encryption2Enabled,
+	Ndis802_11Encryption2KeyAbsent,
+	Ndis802_11Encryption3Enabled,
+	Ndis802_11Encryption3KeyAbsent
+};
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+struct NDIS_802_11_AI_REQFI {
+	u16 Capabilities;
+	u16 ListenInterval;
+	unsigned char CurrentAPAddress[6];
+};
+
+struct NDIS_802_11_AI_RESFI {
+	u16 Capabilities;
+	u16 StatusCode;
+	u16 AssociationId;
+};
+
+struct NDIS_802_11_ASSOCIATION_INFORMATION {
+	u32 Length;
+	u16 AvailableRequestFixedIEs;
+	struct NDIS_802_11_AI_REQFI RequestFixedIEs;
+	u32 RequestIELength;
+	u32 OffsetRequestIEs;
+	u16 AvailableResponseFixedIEs;
+	struct NDIS_802_11_AI_RESFI ResponseFixedIEs;
+	u32 ResponseIELength;
+	u32 OffsetResponseIEs;
+};
+
+/* Key mapping keys require a BSSID*/
+struct NDIS_802_11_KEY {
+	u32 Length;			/* Length of this structure */
+	u32 KeyIndex;
+	u32 KeyLength;			/* length of key in bytes */
+	unsigned char BSSID[6];
+	unsigned long long KeyRSC;
+	u8  KeyMaterial[32];		/* variable length */
+};
+
+struct NDIS_802_11_REMOVE_KEY {
+	u32 Length;			/* Length of this structure */
+	u32 KeyIndex;
+	unsigned char BSSID[6];
+};
+
+struct NDIS_802_11_WEP {
+	u32 Length;		  /* Length of this structure */
+	u32 KeyIndex;		  /* 0 is the per-client key,
+				   * 1-N are the global keys */
+	u32 KeyLength;		  /* length of key in bytes */
+	u8  KeyMaterial[16];      /* variable length depending on above field */
+};
+
+/* mask for authentication/integrity fields */
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+/* MIC check time, 60 seconds. */
+#define MIC_CHECK_TIME	60000000
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+struct	wlan_network {
+	struct list_head list;
+	int	network_type;	/*refer to ieee80211.h for WIRELESS_11A/B/G */
+	int	fixed;		/* set to fixed when not to be removed asi
+				 * site-surveying */
+	unsigned int	last_scanned; /*timestamp for the network */
+	int	aid;		/*will only be valid when a BSS is joined. */
+	int	join_res;
+	struct ndis_wlan_bssid_ex network; /*must be the last item */
+};
+
+enum VRTL_CARRIER_SENSE {
+	DISABLE_VCS,
+	ENABLE_VCS,
+	AUTO_VCS
+};
+
+enum VCS_TYPE {
+	NONE_VCS,
+	RTS_CTS,
+	CTS_TO_SELF
+};
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+enum UAPSD_MAX_SP {
+	NO_LIMIT,
+	TWO_MSDU,
+	FOUR_MSDU,
+	SIX_MSDU
+};
+
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+ *	WPA2
+ */
+struct wlan_bssid_ex {
+	u32 Length;
+	unsigned char  MacAddress[6];
+	u8  Reserved[2];
+	struct ndis_802_11_ssid  Ssid;
+	u32 Privacy;
+	s32 Rssi;
+	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	struct NDIS_802_11_CONFIGURATION  Configuration;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	NDIS_802_11_RATES_EX  SupportedRates;
+	u32 IELength;
+	u8  IEs[MAX_IE_SZ];	/* (timestamp, beacon interval, and capability
+				 * information) */
+};
+
+#endif /* #ifndef WLAN_BSSDEF_H_ */
+
diff --git a/drivers/staging/rtl8712/xmit_linux.c b/drivers/staging/rtl8712/xmit_linux.c
new file mode 100644
index 0000000..c970362
--- /dev/null
+++ b/drivers/staging/rtl8712/xmit_linux.c
@@ -0,0 +1,203 @@
+/******************************************************************************
+ * xmit_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _XMIT_OSDEP_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#include "if_ether.h"
+#include "ip.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "mlme_osdep.h"
+#include "xmit_osdep.h"
+#include "osdep_intf.h"
+
+static uint remainder_len(struct pkt_file *pfile)
+{
+	return (uint)(pfile->buf_len - ((addr_t)(pfile->cur_addr) -
+	       (addr_t)(pfile->buf_start)));
+}
+
+void _r8712_open_pktfile(_pkt *pktptr, struct pkt_file *pfile)
+{
+	pfile->pkt = pktptr;
+	pfile->cur_addr = pfile->buf_start = pktptr->data;
+	pfile->pkt_len = pfile->buf_len = pktptr->len;
+	pfile->cur_buffer = pfile->buf_start ;
+}
+
+uint _r8712_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen)
+{
+	uint len;
+
+	len = remainder_len(pfile);
+	len = (rlen > len) ? len : rlen;
+	if (rmem)
+		skb_copy_bits(pfile->pkt, pfile->buf_len - pfile->pkt_len,
+			      rmem, len);
+	pfile->cur_addr += len;
+	pfile->pkt_len -= len;
+	return len;
+}
+
+sint r8712_endofpktfile(struct pkt_file *pfile)
+{
+	if (pfile->pkt_len == 0)
+		return true;
+	else
+		return false;
+}
+
+
+void r8712_set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)
+{
+	int i;
+	struct ethhdr etherhdr;
+	struct iphdr ip_hdr;
+	u16 UserPriority = 0;
+
+	_r8712_open_pktfile(ppktfile->pkt, ppktfile);
+	_r8712_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);
+
+	/* get UserPriority from IP hdr*/
+	if (pattrib->ether_type == 0x0800) {
+		i = _r8712_pktfile_read(ppktfile, (u8 *)&ip_hdr,
+					sizeof(ip_hdr));
+		/*UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3 ;*/
+		UserPriority = ip_hdr.tos >> 5;
+	} else {
+		/* "When priority processing of data frames is supported,
+		 * a STA's SME should send EAPOL-Key frames at the highest
+		 * priority." */
+
+		if (pattrib->ether_type == 0x888e)
+			UserPriority = 7;
+	}
+	pattrib->priority = UserPriority;
+	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+void r8712_SetFilter(struct work_struct *work)
+{
+	struct _adapter *padapter = container_of(work, struct _adapter,
+						wkFilterRxFF0);
+	u8  oldvalue = 0x00, newvalue = 0x00;
+	unsigned long irqL;
+
+	oldvalue = r8712_read8(padapter, 0x117);
+	newvalue = oldvalue & 0xfe;
+	r8712_write8(padapter, 0x117, newvalue);
+
+	spin_lock_irqsave(&padapter->lockRxFF0Filter, irqL);
+	padapter->blnEnableRxFF0Filter = 1;
+	spin_unlock_irqrestore(&padapter->lockRxFF0Filter, irqL);
+	do {
+		msleep(100);
+	} while (padapter->blnEnableRxFF0Filter == 1);
+	r8712_write8(padapter, 0x117, oldvalue);
+}
+
+int r8712_xmit_resource_alloc(struct _adapter *padapter,
+			      struct xmit_buf *pxmitbuf)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (pxmitbuf->pxmit_urb[i] == NULL) {
+			printk(KERN_ERR "r8712u: pxmitbuf->pxmit_urb[i]"
+			    " == NULL");
+			return _FAIL;
+		}
+	}
+	return _SUCCESS;
+}
+
+void r8712_xmit_resource_free(struct _adapter *padapter,
+			      struct xmit_buf *pxmitbuf)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		if (pxmitbuf->pxmit_urb[i]) {
+			usb_kill_urb(pxmitbuf->pxmit_urb[i]);
+			usb_free_urb(pxmitbuf->pxmit_urb[i]);
+		}
+	}
+}
+
+void r8712_xmit_complete(struct _adapter *padapter, struct xmit_frame *pxframe)
+{
+	if (pxframe->pkt)
+		dev_kfree_skb_any(pxframe->pkt);
+	pxframe->pkt = NULL;
+}
+
+int r8712_xmit_entry(_pkt *pkt, struct  net_device *pnetdev)
+{
+	struct xmit_frame *pxmitframe = NULL;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	int ret = 0;
+
+	if (r8712_if_up(padapter) == false) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	pxmitframe = r8712_alloc_xmitframe(pxmitpriv);
+	if (pxmitframe == NULL) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	if ((!r8712_update_attrib(padapter, pkt, &pxmitframe->attrib))) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_TX);
+	pxmitframe->pkt = pkt;
+	if (r8712_pre_xmit(padapter, pxmitframe) == true) {
+		/*dump xmitframe directly or drop xframe*/
+		dev_kfree_skb_any(pkt);
+		pxmitframe->pkt = NULL;
+	}
+	pxmitpriv->tx_pkts++;
+	pxmitpriv->tx_bytes += pxmitframe->attrib.last_txcmdsz;
+	return ret;
+_xmit_entry_drop:
+	if (pxmitframe)
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+	pxmitpriv->tx_drop++;
+	dev_kfree_skb_any(pkt);
+	return ret;
+}
diff --git a/drivers/staging/rtl8712/xmit_osdep.h b/drivers/staging/rtl8712/xmit_osdep.h
new file mode 100644
index 0000000..8eba7ca
--- /dev/null
+++ b/drivers/staging/rtl8712/xmit_osdep.h
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+struct pkt_file {
+	_pkt	*pkt;
+	u32	pkt_len;	 /*the remainder length of the open_file*/
+	_buffer	*cur_buffer;
+	u8	*buf_start;
+	u8	*cur_addr;
+	u32	buf_len;
+};
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+int r8712_xmit_entry(_pkt *pkt, struct  net_device *pnetdev);
+void r8712_SetFilter(struct work_struct *work);
+int r8712_xmit_resource_alloc(struct _adapter *padapter,
+			   struct xmit_buf *pxmitbuf);
+void r8712_xmit_resource_free(struct _adapter *padapter,
+			   struct xmit_buf *pxmitbuf);
+
+void r8712_set_qos(struct pkt_file *ppktfile,
+		    struct pkt_attrib *pattrib);
+void _r8712_open_pktfile(_pkt *pktptr, struct pkt_file *pfile);
+uint _r8712_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen);
+sint r8712_endofpktfile(struct pkt_file *pfile);
+void r8712_xmit_complete(struct _adapter *padapter,
+			     struct xmit_frame *pxframe);
+
+#endif
