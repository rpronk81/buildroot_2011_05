diff --git a/MAKEALL b/MAKEALL
index 1aa0dc7..2977187 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -561,6 +561,7 @@ LIST_ARM9="			\
 	ap926ejs		\
 	ap946es			\
 	ap966			\
+        cc9p9215_config         \
 	cp920t			\
 	cp922_XA10		\
 	cp926ejs		\
diff --git a/Makefile b/Makefile
index fa1bddf..923f047 100644
--- a/Makefile
+++ b/Makefile
@@ -192,11 +192,13 @@ endif
 ifeq ($(CPU),ixp)
 LIBS += arch/arm/cpu/ixp/npe/libnpe.a
 endif
+ifeq ($(BOARD),cc9p921x)
+LIBS += arch/arm/cpu/arm926ejs/ns921x/libns921x.a
+endif
 LIBS += arch/$(ARCH)/lib/lib$(ARCH).a
 LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
 	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a fs/yaffs2/libyaffs2.a \
 	fs/ubifs/libubifs.a
-LIBS += net/libnet.a
 LIBS += disk/libdisk.a
 LIBS += drivers/bios_emulator/libatibiosemu.a
 LIBS += drivers/block/libblock.a
@@ -213,10 +215,11 @@ LIBS += drivers/mtd/nand/libnand.a
 LIBS += drivers/mtd/onenand/libonenand.a
 LIBS += drivers/mtd/ubi/libubi.a
 LIBS += drivers/mtd/spi/libspi_flash.a
-LIBS += drivers/net/libnet.a
 LIBS += drivers/net/phy/libphy.a
 LIBS += drivers/pci/libpci.a
+ifneq ($(CPU),arm926ejs)
 LIBS += drivers/pcmcia/libpcmcia.a
+endif
 LIBS += drivers/power/libpower.a
 LIBS += drivers/spi/libspi.a
 ifeq ($(CPU),mpc83xx)
@@ -233,6 +236,7 @@ LIBS += arch/powerpc/cpu/mpc8xxx/ddr/libddr.a
 LIBS += arch/powerpc/cpu/mpc8xxx/lib8xxx.a
 endif
 LIBS += drivers/rtc/librtc.a
+LIBS += net/libnet.a
 LIBS += drivers/serial/libserial.a
 LIBS += drivers/twserial/libtws.a
 LIBS += drivers/usb/gadget/libusb_gadget.a
@@ -242,10 +246,14 @@ LIBS += drivers/usb/phy/libusb_phy.a
 LIBS += drivers/video/libvideo.a
 LIBS += drivers/watchdog/libwatchdog.a
 LIBS += common/libcommon.a
+LIBS += common/digi/libdigi.a
+LIBS += arch/arm/lib/libarm.a
 LIBS += lib/libfdt/libfdt.a
 LIBS += api/libapi.a
 LIBS += post/libpost.a
-
+ifeq ($(BOARD),cc9p921x)
+LIBS += common/digi/cmd_nvram/libnvram.a
+endif
 ifeq ($(SOC),omap3)
 LIBS += $(CPUDIR)/omap-common/libomap-common.a
 endif
@@ -2103,6 +2111,188 @@ omap730p2_cs3boot_config :	unconfig
 	fi;
 	@$(MKCONFIG) -n $@ -a omap730p2 arm arm926ejs omap730p2 ti omap
 
+######################################################################## 
+## Digi boards 
+cc9p9215_config \
+cc9p9215js_config \
+cc9p9215js_dbg_netos_config \
+cc9p9215js_test_config \
+cc9p9215js_test_dbg_config \
+cc9p9215js_netos_config \
+cc9p9215js_test_netos_config \
+cc9p9215js_test_dbg_netos_config \
+cc9p9215js_dbg_config :	unconfig
+	@if [ "$(findstring cc9p9215_, $@)" ] ; then \
+		echo "crc32 will be appended to u-boot-${PLATFORM_NAME}.bin"; \
+		echo "#define CFG_APPEND_CRC32" >> ./include/config.h; \
+		echo "APPEND_CRC32=y"	>>include/config.mk; \
+		echo "#define CONFIG_NS9215" >> ./include/config.h; \
+		echo "#define CONFIG_DRIVER_NS921X_ETHERNET 1" >> ./include/config.h; \
+		echo "#define CFG_CMD_NET 1" >> ./include/config.h; \
+		echo "#define CONFIG_COMMANDS 1" >> ./include/config.h; \
+		echo "#define CONFIG_RTC_NS921X 1" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_HWFLOW" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_ELF" >> ./include/config.h; \
+		echo "#define CFG_CMD_DATE 1" >> ./include/config.h; \
+		echo "#define CFG_CMD_BSP 1" >> ./include/config.h; \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h; \
+		echo "#define CONFIG_CC9C" >> ./include/config.h; \
+		echo "#undef CONFIG_CC9C_NAND" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_NAND" >> ./include/config.h; \
+		echo "#define CONFIG_CMD_FLASH 1" >> ./include/config.h; \
+		echo "#define CFG_CMD_FLASH 1" >> ./include/config.h; \
+		echo "#define PHYS_SDRAM_1_SIZE SZ_16M" >> ./include/config.h; \
+		echo "#undef CONFIG_STATUS_LED" >> ./include/config.h; \
+		echo "#include <configs/digi_common.h>" >> ./include/config.h; \
+		echo "Configuring with 16MB SDRAM and NOR Flash"; \
+		echo "#define CONFIG_SYS_MAXARGS CFG_MAXARGS" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_MAX_FLASH_BANKS CFG_MAX_FLASH_BANKS" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_MAX_FLASH_SECT CFG_MAX_FLASH_SECT" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_FLASH_BASE CFG_FLASH_BASE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_MONITOR_BASE CFG_FLASH_BASE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_I2C_SPEED CFG_I2C_SPEED" >> ./include/config.h; \
+		echo "#define CONFIG_ENV_SIZE CFG_ENV_SIZE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_MEMTEST_START CFG_MEMTEST_START" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_MEMTEST_END CFG_MEMTEST_END" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_HZ CFG_HZ" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_BAUDRATE_TABLE CFG_BAUDRATE_TABLE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_CBSIZE CFG_CBSIZE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_PBSIZE CFG_PBSIZE" >> ./include/config.h; \
+		echo "#define CONFIG_SYS_PROMPT CFG_PROMPT" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_USB" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_PCMCIA" >> ./include/config.h; \
+		echo "#undef CONFIG_PCI" >> ./include/config.h; \
+		echo "#undef CONFIG_CMD_PCI" >> ./include/config.h; \
+	fi;
+	@if [ "$(findstring js_, $@)" ] ; then \
+		echo "#define CONFIG_JSCC9P9215 1" >> ./include/config.h ; \
+		echo "Configuring JSCC9P9215 Development Board"; \
+	fi;
+	@if [ "$(findstring _dbg_, $@)" ] ; then \
+		echo "#define CONFIG_DOWNLOAD_BY_DEBUGGER" >> ./include/config.h ; \
+		echo "Configuring for debugger download"; \
+	fi;
+	@if [ "$(findstring _netos_, $@)" ] ; then \
+		echo "#define CONFIG_NETOS_BRINGUP" >> ./include/config.h ; \
+		echo "Configuring for NET+OS bringup"; \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@if [ "$(findstring _test_, $@)" ] ; then \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+#
+#         mkconfig       _config  arch cpu       board    vendor soc
+#       -------------------------------------------------------------
+	$(MKCONFIG)   -a cc9p9215 arm  arm926ejs cc9p921x 
+
+	@echo "crc32 will be appended to u-boot-${PLATFORM_NAME}.bin";
+	@echo "#define CFG_APPEND_CRC32" >> ./include/config.h;
+	@echo "APPEND_CRC32=y"	>>include/config.mk;
+
+ccw9p9215js_config \
+ccw9p9215js_dbg_netos_config \
+ccw9p9215js_test_config \
+ccw9p9215js_test_dbg_config \
+ccw9p9215js_netos_config \
+ccw9p9215js_test_netos_config \
+ccw9p9215js_test_dbg_netos_config \
+ccw9p9215js_dbg_config :	unconfig
+	@if [ "$(findstring js_, $@)" ] ; then \
+		echo "#define CONFIG_JSCCW9P9215 1" >> ./include/config.h ; \
+		echo "Configuring JSCCW9P9215 Development Board"; \
+	fi;
+	@if [ "$(findstring _dbg_, $@)" ] ; then \
+		echo "#define CONFIG_DOWNLOAD_BY_DEBUGGER" >> ./include/config.h ; \
+		echo "Configuring for debugger download"; \
+	fi;
+	@if [ "$(findstring _netos_, $@)" ] ; then \
+		echo "#define CONFIG_NETOS_BRINGUP" >> ./include/config.h ; \
+		echo "Configuring for NET+OS bringup"; \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@if [ "$(findstring _test_, $@)" ] ; then \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@$(MKCONFIG) -a ccw9p9215 arm arm926ejs ccw9p921x NULL ns921x ns9xxx
+
+	@echo "crc32 will be appended to u-boot-${PLATFORM_NAME}.bin";
+	@echo "#define CFG_APPEND_CRC32" >> ./include/config.h;
+	@echo "APPEND_CRC32=y"	>>include/config.mk;
+
+cc9p9210js_config \
+cc9p9210js_dbg_netos_config \
+cc9p9210js_test_config \
+cc9p9210js_dbg_config :	unconfig
+	@if [ "$(findstring js_, $@)" ] ; then \
+		echo "#define CONFIG_JSCC9P9215 1" >> ./include/config.h ; \
+		echo "Configuring JSCC9P9215 Development Board"; \
+	fi;
+	@if [ "$(findstring _dbg_, $@)" ] ; then \
+		echo "#define CONFIG_DOWNLOAD_BY_DEBUGGER" >> ./include/config.h ; \
+		echo "Configuring for debugger download"; \
+	fi;
+	@if [ "$(findstring _netos_, $@)" ] ; then \
+		echo "#define CONFIG_NETOS_BRINGUP" >> ./include/config.h ; \
+		echo "Configuring for NET+OS bringup"; \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@if [ "$(findstring _test_, $@)" ] ; then \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@$(MKCONFIG) -a cc9p9210 arm arm926ejs cc9p921x NULL ns921x ns9xxx
+
+	@echo "crc32 will be appended to u-boot-${PLATFORM_NAME}.bin";
+	@echo "#define CFG_APPEND_CRC32" >> ./include/config.h;
+	@echo "APPEND_CRC32=y"	>>include/config.mk;
+
+cc9cjsnand_config \
+cc9cjsnor_config \
+cc9cjsnand_dbg_config \
+cc9cjsnand_test_config \
+cc9cjsnand_test_dbg_config \
+cc9cjsnor_dbg_config:	unconfig
+	@if [ "$(findstring jsnand_, $@)" ]; then \
+		echo "#define CONFIG_JSCCW9C 1"   >> ./include/config.h ; \
+		echo "#define CONFIG_CC9C_NAND 1" >> ./include/config.h; \
+		echo "Configuring ConnectCore 9C with NAND Flash on Development Board"; \
+	elif [ "$(findstring jsnor_, $@)" ]; then \
+		echo "#define CONFIG_JSCCW9C 1" >> ./include/config.h ; \
+		echo "#undef CONFIG_CC9C_NAND" >> ./include/config.h; \
+		echo "#define PHYS_SDRAM_1_SIZE SZ_16M" >> ./include/config.h; \
+		echo "Configuring ConnectCore 9C with 16MB SDRAM and NOR Flash on Development Board"; \
+	else \
+		echo "please specify if you have a ConnectCore 9C with NAND or NOR Flash"; \
+	fi;
+	@if [ "$(findstring _dbg_, $@)" ] ; then \
+		echo "#define CONFIG_DOWNLOAD_BY_DEBUGGER" >> ./include/config.h ; \
+		echo "Configuring for debugger download"; \
+	fi;
+	@if [ "$(findstring _test_, $@)" ] ; then \
+		echo "#define CONFIG_UBOOT_CMD_BSP_TESTHW" >> ./include/config.h ; \
+		echo "Configuring with test commands embedded"; \
+	fi;
+	@$(MKCONFIG) -a cc9c arm arm926ejs cc9c NULL ns9xxx
+
+cme9210js_config:	unconfig
+	@if [ "$(findstring js_, $@)" ] ; then \
+		echo "#define CONFIG_JSCME9210 1" >> ./include/config.h ; \
+		echo "Configuring CME9210JS Development Board"; \
+	fi;
+	@$(MKCONFIG) -a cme9210 arm arm926ejs cme9210 NULL ns921x ns9xxx
+	@echo "SWITCH_ENDIANESS=y" >>include/config.mk
+	@echo "crc32 will be appended to u-boot-${PLATFORM_NAME}.bin";
+	@echo "#define CFG_APPEND_CRC32" >> ./include/config.h;
+	@echo "APPEND_CRC32=y"	>>include/config.mk;
+
+#
+
+
 spear300_config \
 spear310_config \
 spear320_config :	unconfig
diff --git a/arch/arm/cpu/arm926ejs/ns921x/Makefile b/arch/arm/cpu/arm926ejs/ns921x/Makefile
new file mode 100644
index 0000000..ec36ad1
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2000-2005
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Copyright (C) 2007 by Digi International Inc.
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= libns921x.a
+
+COBJS	:= timer.o serial_ns921x.o ns921x_edt.o ns921x_eth.o \
+	   fim_serial.o fim.o fim_sdio.o
+
+SOBJS	:= reset.o
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+
+DIGI_DIR := $(TOPDIR)/common/digi
+DIGI_BSP := -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim.c b/arch/arm/cpu/arm926ejs/ns921x/fim.c
new file mode 100644
index 0000000..8487a10
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim.c
@@ -0,0 +1,572 @@
+/* -*- linux-c -*-
+ * cpu/arm926ejs/ns921x/fims/fim.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision$
+ * !Author:     Luis Galdos
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ */
+
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm-arm/arch-ns9xxx/ns921x_fim.h>
+#include <asm-arm/arch-ns9xxx/fim_firmware.h>
+#include <asm-arm/arch-ns9xxx/io.h>
+#include <asm-arm/arch-ns9xxx/ns921x_hub.h>
+#include "fim_reg.h"
+
+#define	FIM0_SHIFT			6
+
+/* @XXX: Need a similar mechanism as under Linux for having customizable DMA-channels */
+#define FIM_TOTAL_NUMBER                (FIM_MAX_PIC_INDEX + 1)
+#define FIM_DMA_BUFFERS                 (21)
+#define FIM_TOTAL_BUFFERS               (FIM_TOTAL_NUMBER * FIM_DMA_BUFFERS)
+#define FIM_BUFFER_SIZE                 (1024)
+
+//#define FIM_CORE_DEBUG
+
+#define printk_info(fmt,args...)                   printf(fmt, ##args)
+#define printk_err(fmt,args...)                   printf(fmt, ##args)
+
+#if defined(FIM_CORE_DEBUG)
+# define printk_debug(fmt,args...)                   printf(fmt, ##args)
+#else
+# define printk_debug(fmt, args...)
+#endif
+
+/* Data for the RX-DMA buffers and DMA-FIFOs too */
+static volatile struct iohub_dma_desc_t fim_rxdma_buffers[FIM_TOTAL_BUFFERS];
+static volatile struct iohub_dma_fifo_t fim_rxdma_fifos[FIM_TOTAL_NUMBER];
+
+int fim_get_exp_reg(int pic_num, int nr)
+{
+	return readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_EXP_REG(nr));
+}
+
+/*
+ * This function provides the access to the control registers of the PICs
+ * reg : Number of the control register (from 0 to 15)
+ * val : Value to write into the control register
+ */
+void fim_set_ctrl_reg(int pic_num, int reg, unsigned int val)
+{
+	writel(val, FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL_REG(reg));
+}
+
+int fim_send_interrupt(int pic_num, unsigned int code)
+{
+	unsigned int stopcnt;
+	u32 status;
+
+	if ( !code || (code & ~0x7f))
+		return 1;
+
+	if (!pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	code = NS92XX_FIM_INT_MASK(code);
+	status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	writel(status | code, FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	/* This loop is perhaps problematic, exit with a timeout */
+	stopcnt = 0xFFFF;
+	do {
+		status = readl(FIM_REG_ADDR(pic_num)  + NS92XX_FIM_GEN_CTRL_REG);
+		stopcnt--;
+	} while (!(status & NS92XX_FIM_GEN_CTRL_INTACKRD) && stopcnt);
+
+	if (!stopcnt) {
+		return 1;
+	}
+
+	/* Reset the interrupt bits for the PIC acknowledge */
+	status &= ~NS92XX_FIM_GEN_CTRL_INTTOPIC;
+	writel(status, FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	stopcnt = 0xFFFF;
+	do {
+		status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+		stopcnt--;
+	} while ((status & NS92XX_FIM_GEN_CTRL_INTACKRD) && stopcnt);
+
+	if (!stopcnt) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* Provides the read access to the control registers of the PICs */
+int fim_get_iohub_reg(int pic_num, int reg)
+{
+	return readl(FIM_IOHUB_ADDR(pic_num) + reg);
+}
+
+void fim_set_iohub_reg(int pic_num, int reg, unsigned int val)
+{
+	writel(val, FIM_IOHUB_ADDR(pic_num) + reg);
+}
+
+/* Provides the read access to the control registers of the PICs */
+int fim_get_ctrl_reg(int pic_num, int reg)
+{
+	if (NS92XX_FIM_CTRL_REG_CHECK(reg))
+		return -1;
+
+	return readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL_REG(reg));
+}
+
+int pic_get_exp_reg(int pic_num, int nr, unsigned int *value)
+{
+	*value = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_EXP_REG(nr));
+
+	return 0;
+}
+
+int pic_is_running(int pic_num)
+{
+	unsigned int regval;
+
+	regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	if (regval & NS92XX_FIM_GEN_CTRL_PROGMEM)
+		return 1;
+	else
+		return 0;
+}
+
+/* Called when the PIC interrupts the ARM-processor */
+void isr_from_pic(int pic_num, int irqnr)
+{
+	unsigned int status;
+	unsigned int rx_fifo;
+	unsigned int timeout;
+
+	status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	rx_fifo = readl(FIM_IOHUB_ADDR(pic_num) + HUB_RX_FIFO_STAT);
+
+	/* @TEST */
+	writel(status, FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL7_REG);
+
+	writel(status | NS92XX_FIM_GEN_CTRL_INTACKWR,
+	       FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	timeout = 0xFFFF;
+	do {
+		timeout--;
+		status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	} while (timeout && (status & NS92XX_FIM_GEN_CTRL_INTFROMPIC));
+
+	/* @XXX: Should we stop the PIC for avoiding more timeout errors? */
+	if (!timeout) {
+		return;
+	}
+
+	writel(status & ~NS92XX_FIM_GEN_CTRL_INTACKWR, FIM_REG_ADDR(pic_num) +
+	       NS92XX_FIM_GEN_CTRL_REG);
+}
+
+/* This is the main ISR for the PIC-interrupts */
+void pic_irq(int pic_num)
+{
+	unsigned int ifs;
+
+	ifs = readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+
+	if (ifs & HUB_INT_MODIP)
+		isr_from_pic(pic_num, 0x00);
+
+	writel(ifs, FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+}
+
+/* Set the HWA PIC clock (see PIC module specification, page 19) */
+static int pic_config_output_clock_divisor(int pic_num, struct fim_program_t *program)
+{
+	int div;
+	int clkd;
+	unsigned int val;
+
+	if (!program)
+		return 1;
+
+	div = program->clkdiv;
+	switch (div) {
+	case FIM_CLK_DIV_2:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_2;
+		break;
+
+	case FIM_CLK_DIV_4:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_4;
+		break;
+
+	case FIM_CLK_DIV_8:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_8;
+		break;
+
+	case FIM_CLK_DIV_16:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_16;
+		break;
+
+	case FIM_CLK_DIV_32:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_32;
+		break;
+
+	case FIM_CLK_DIV_64:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_64;
+		break;
+
+	case FIM_CLK_DIV_128:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_128;
+		break;
+
+	case FIM_CLK_DIV_256:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_256;
+		break;
+
+	default:
+		return 1;
+	}
+
+	val = readl(FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+	writel(val | clkd, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	return 0;
+}
+
+int pic_stop_and_reset(int pic_num)
+{
+	unsigned int regval = 0;
+
+	if (pic_is_running(pic_num)) {
+
+		regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+		writel(regval & NS92XX_FIM_GEN_CTRL_STOP_PIC,
+		       FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	}
+
+	if (pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	/* Reset the HWA generial register too */
+	writel(0x00, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	return 0;
+}
+
+int pic_start_at_zero(int pic_num)
+{
+	unsigned int regval;
+
+	regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	writel(regval | NS92XX_FIM_GEN_CTRL_START_PIC, FIM_REG_ADDR(pic_num) +
+	       NS92XX_FIM_GEN_CTRL_REG);
+
+	/* Check if the PIC is really running */
+	if (!pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int pic_download_firmware(int pic_num, const unsigned char *buffer)
+{
+	int mode;
+	unsigned int status;
+	struct fim_program_t *program = (struct fim_program_t *)buffer;
+	int offset;
+
+	if (!program )
+		return 1;
+
+	if (!(FORMAT_TYPE_VALID(program->format))) {
+		printf("Invalid format type\n");
+		return 1;
+	}
+
+	/* Check if the PIC is running, before starting the firmware update */
+	if (pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	/* Check if the firmware has the correct header */
+	if (!(PROCESSOR_TYPE_VALID(program->processor))) {
+		printf("Invalid processor type. Aborting firmware download.\n");
+		return 1;
+	}
+
+	/* Enable the clock to IO processor and reset the module */
+	status = sys_readl(SYS_CLOCK);
+	sys_writel(status | (1 << (pic_num + FIM0_SHIFT)), SYS_CLOCK);
+	status = sys_readl(SYS_RESET);
+	sys_writel(status & ~(1 << (pic_num + FIM0_SHIFT)), SYS_RESET);
+	sys_writel(status | (1 << (pic_num + FIM0_SHIFT)), SYS_RESET);
+
+	/* Configure the output clock */
+	if(pic_config_output_clock_divisor(pic_num, program)) {
+		printf("Couldn't set the clock output divisor.\n");
+		return 1;
+	}
+
+	switch (program->hw_mode) {
+	case FIM_HW_ASSIST_MODE_NONE:
+		mode = 0x00;
+		break;
+	case FIM_HW_ASSIST_MODE_GENERIC:
+		mode = 0x01;
+		break;
+	case FIM_HW_ASSIST_MODE_CAN:
+		mode = 0x02;
+		break;
+	default:
+		printf("Invalid HWA mode %i\n", program->hw_mode);
+		return 1;
+	}
+
+	status = readl(FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+	writel(mode | status, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	/* Update the HW assist config registers */
+	for (offset = 0; offset < FIM_NUM_HWA_CONF_REGS; offset++) {
+		status = program->hwa_cfg[offset];
+		writel(status, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_SIGNAL(offset));
+	}
+
+	/* Check for the maximal supported number of instructions */
+	if (program->length > FIM_NS9215_MAX_INSTRUCTIONS)
+		return 1;
+
+	/* Start programming the PIC (the program size is in 16bit-words) */
+	for (offset = 0; offset < program->length; offset++)
+		writel(program->data[offset] & NS92XX_FIM_INSTRUCTION_MASK,
+		       FIM_INSTR_ADDR(pic_num) + 4*offset);
+
+	return 0;
+}
+
+/* This is for a hard reset of the FIMs */
+void fim_force_hard_reset(int pic)
+{
+	unsigned int status;
+	ulong regval;
+	int cnt;
+
+	status = sys_readl(SYS_RESET);
+	for (cnt = 0; cnt < FIM_MAX_PIC_INDEX; cnt++) {
+
+		if (cnt != pic)
+			continue;
+		
+		sys_writel(status & ~(1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		sys_writel(status | (1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		regval = readl(FIM_IOHUB_ADDR(cnt) + HUB_INT);
+		writel(regval, FIM_IOHUB_ADDR(cnt) + HUB_INT);
+        }
+}
+
+/* Dont use any lock, otherwise it would be required to free the PIC by failures */
+int fim_core_init(int pic, const unsigned char *fwbuf)
+{
+	fim_force_hard_reset(pic);
+
+        /* Stop the PIC before any other action */
+	if(pic_stop_and_reset(pic))
+		goto exit_free_pic;
+
+	if(pic_download_firmware(pic, fwbuf))
+		goto exit_free_pic;
+
+	/* Start the PIC at zero */
+	if(pic_start_at_zero(pic))
+		goto exit_free_pic;
+
+	return 0;
+
+ exit_free_pic:
+	return 1;
+}
+
+
+
+/*
+ * Functions for using the DMA-channels of the FIMs. In some cases it is absolutely
+ * required to use DMA for exchanging data with the FIMs (like in the case of the MMC)
+ * for this reason we need the support.
+ */
+
+
+int fim_init_rxdma(int pic)
+{
+	/* DMA-buffer descriptors */
+	static uchar rxbuf[FIM_TOTAL_BUFFERS][FIM_BUFFER_SIZE];
+	volatile struct iohub_dma_desc_t *picbuf, *lstbuf;
+	volatile struct iohub_dma_fifo_t *picfifo;
+	int cnt;
+
+	/* Init the last buffer pointer too */
+	picbuf = &fim_rxdma_buffers[pic * FIM_DMA_BUFFERS];
+
+	picfifo = &fim_rxdma_fifos[pic];
+	picfifo->first = (struct iohub_dma_desc_t *)picbuf;
+	picfifo->dma_last = (struct iohub_dma_desc_t *)picbuf;
+	picfifo->last = (struct iohub_dma_desc_t *)(picbuf + FIM_DMA_BUFFERS - 1);
+
+	printk_debug("DMA buffers for the FIM %i [%p to %p]\n", pic,
+		     picfifo->first, picfifo->last);
+
+	for (cnt = 0; cnt < FIM_DMA_BUFFERS; cnt++, picbuf++) {
+		picbuf->src = (unsigned int)rxbuf[cnt];
+		picbuf->length = FIM_BUFFER_SIZE;
+		picbuf->control = IOHUB_DMA_DESC_CTRL_INT;
+		printk_debug("  %2i. %p : 0x%08x | %u Bytes\n", cnt+1, picbuf,
+			     picbuf->src, picbuf->length);
+
+		lstbuf = picbuf;
+	}
+
+	picbuf = &fim_rxdma_buffers[pic * FIM_DMA_BUFFERS];
+	lstbuf->control = IOHUB_DMA_DESC_CTRL_LAST | IOHUB_DMA_DESC_CTRL_INT |
+		IOHUB_DMA_DESC_CTRL_WRAP;
+
+	writel(0x0, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+
+	writel((unsigned long)picbuf, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_DESCR);
+
+	writel(HUB_RX_INT_NCIE | HUB_RX_INT_NRIE | HUB_RX_INT_ECIE,
+		FIM_IOHUB_ADDR(pic) + HUB_RX_INT);
+
+	writel(HUB_DMA_RX_CTRL_CE, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+	return 0;
+}
+
+/* Send a buffer by using the DMA-channel */
+int fim_send_buffer(int pic, struct fim_buffer_t *buffer)
+{
+	static volatile struct iohub_dma_desc_t fims_txdma_bufdesc[2];
+	volatile struct iohub_dma_desc_t *picbuf;
+
+	/* @TODO: Sanity check for the passed PIC number! */
+	picbuf = &fims_txdma_bufdesc[pic];
+
+	/* Configure the buffer first */
+	picbuf->src = (unsigned int)buffer->data;
+	picbuf->length = buffer->length;
+	picbuf->control = IOHUB_DMA_DESC_CTRL_LAST | IOHUB_DMA_DESC_CTRL_FULL |
+		IOHUB_DMA_DESC_CTRL_INT | IOHUB_DMA_DESC_CTRL_WRAP;
+
+	/* Configure the TX DMA-channel */
+	writel(0x0, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_CTRL);
+
+	flush_cache_all();
+	writel((unsigned long)picbuf, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_DESCR);
+
+	writel(HUB_TX_INT_NCIE | HUB_TX_INT_NRIE | HUB_TX_INT_ECIE,
+		FIM_IOHUB_ADDR(pic) + HUB_TX_INT);
+
+	writel(HUB_DMA_TX_CTRL_CE, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_CTRL);
+
+	return 0;
+}
+
+/* Wait until the DMA-buffer was closed by the FIM */
+int fim_wait_txdma(int pic)
+{
+	unsigned long ifs;
+	unsigned long timeout = 0xfffff;
+
+	do {
+		timeout--;
+		ifs = readl(FIM_IOHUB_ADDR(pic) + HUB_INT);
+	} while (timeout && !(ifs & HUB_INT_TX_NCIP));
+
+	if (timeout)
+		writel(ifs | HUB_INT_TX_NCIP, FIM_IOHUB_ADDR(pic) + HUB_INT);
+
+	return (timeout) ? (0) : (-1);
+}
+
+/* The timeout is in microseconds */
+struct fim_buffer_t *fim_wait_rxdma(int pic, uint timeout)
+{
+	struct fim_buffer_t *retval;
+	struct iohub_dma_desc_t *picbuf;
+	unsigned long ifs;
+	volatile static struct fim_buffer_t rxdma[FIM_TOTAL_NUMBER];
+	volatile struct iohub_dma_fifo_t *picfifo;
+	int cnt;
+
+	/* First check if there is an already fulled DMA-buffer */
+	picfifo = &fim_rxdma_fifos[pic];
+
+	do {
+		picbuf = picfifo->dma_last;
+		for (cnt = 0; cnt < FIM_DMA_BUFFERS; cnt++, picbuf++) {
+
+			/* Check that the pointer is correct */
+			if (picbuf > picfifo->last)
+				picbuf = picfifo->first;
+
+			invalidate_cache_all();
+			if (picbuf->control & IOHUB_DMA_DESC_CTRL_FULL) {
+
+				rxdma[pic].data = (uchar *)picbuf->src;
+				rxdma[pic].length = picbuf->length;
+				retval = (struct fim_buffer_t *)&rxdma[pic];
+				picbuf->control &= ~(IOHUB_DMA_DESC_CTRL_FULL |
+						     IOHUB_DMA_DESC_CTRL_LAST);
+				picbuf->length = FIM_BUFFER_SIZE;
+
+				/*
+				 * Update the last pointer. If we overflow the DMA-buffer,
+				 * then the above sanity check will correct the pointer
+				 */
+				picfifo->dma_last = picbuf + 1;
+				if (picfifo->dma_last > picfifo->last)
+					picfifo->dma_last = picfifo->first;
+
+				ifs = readl(FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+				printk_debug("  ==> RX-DMA %p (%i) | Last is now %p\n",
+					     picbuf, ifs & 0x3ff, picfifo->dma_last);
+				
+				return retval;
+			}
+		}
+
+		udelay(1);
+		timeout--;
+	} while (timeout);
+
+	return NULL;
+}
+
+/*
+ * There seems to be a problem when we try to boot the Linux-kernel with
+ * a running FIM. The failure is reproducible by resetting the target console
+ * stopped and then started with a command).
+ * At this moment let us reset the FIMs for being able to boot the system, but
+ * in the future we will need a better workaround.
+ * Luis Galdos
+ */
+void shutdown_fims(void)
+{
+        unsigned int status;
+	ulong regval;
+        int cnt;
+
+        status = sys_readl(SYS_RESET);
+        for (cnt = 0; cnt < FIM_MAX_PIC_INDEX; cnt++) {
+                sys_writel(status & ~(1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+                sys_writel(status | (1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		regval = readl(FIM_IOHUB_ADDR(cnt) + HUB_INT);
+		writel(regval, FIM_IOHUB_ADDR(cnt) + HUB_INT);
+        }
+}
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_reg.h b/arch/arm/cpu/arm926ejs/ns921x/fim_reg.h
new file mode 100644
index 0000000..b993d74
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_reg.h
@@ -0,0 +1,283 @@
+/*
+ * include/asm-arm/arch-ns9xxx/fim_reg.h
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ *  !Revision:   $Revision$
+ *  !Author:     Silvano Najera, Luis Galdos
+ *  !Descr:      
+ *  !References:
+ */
+
+
+#ifndef __FIM_REG_H
+#define __FIM_REG_H
+
+
+/* @FIXME: We must use the IOHUB base address*/
+#define NS92XX_FIM_IOHUB_BASE_PA		(0x90000000)
+#define NS92XX_FIM_IOHUB_SIZE			(0x1000)
+#define NS92XX_FIM_IOHUB_OFFSET			(0x8000)
+
+
+/* Base addresses of all memory regions */
+#define NS92XX_FIM_REG_BASE_PA			(0x90001000)
+#define NS92XX_FIM_REG_OFFSET			(0x8000)
+#define NS92XX_FIM_REG_SIZE                     (0x3000)
+
+#define NS92XX_FIM_INSTR_BASE_PA		(0x90004000)
+#define NS92XX_FIM_INSTR_OFFSET			(0x8000)
+#define NS92XX_FIM_INSTR_SIZE                   (0x5000)
+
+#define NS92XX_FIM_HWA_BASE_PA			(0x90068000)
+#define NS92XX_FIM_HWA_OFFSET			(0x8000)
+#define NS92XX_FIM_HWA_SIZE                     (0x8000)
+
+#define NS92XX_FIM_IO_SPACE_BASE_PA		(0x90078000)
+#define NS92XX_FIM_IO_SPACE_OFFSET		(0x8000)
+#define NS92XX_FIM_IO_SPACE_SIZE                (0x8000)
+
+
+/* FIM register offsets */
+#define NS92XX_FIM_GEN_CTRL_REG			(0x00)
+	
+#define NS92XX_FIM_CTRL0_REG			(0x10)
+#define NS92XX_FIM_CTRL1_REG			(0x14)
+#define NS92XX_FIM_CTRL2_REG			(0x18)
+#define NS92XX_FIM_CTRL3_REG			(0x1c)
+#define NS92XX_FIM_CTRL4_REG			(0x20)
+#define NS92XX_FIM_CTRL5_REG			(0x24)
+#define NS92XX_FIM_CTRL6_REG			(0x28)
+#define NS92XX_FIM_CTRL7_REG			(0x2c)
+#define NS92XX_FIM_CTRL8_REG			(0x30)
+#define NS92XX_FIM_CTRL9_REG			(0x34)
+#define NS92XX_FIM_CTRL10_REG			(0x38)
+#define NS92XX_FIM_CTRL11_REG			(0x3c)
+#define NS92XX_FIM_CTRL12_REG			(0x40)
+#define NS92XX_FIM_CTRL13_REG			(0x44)
+#define NS92XX_FIM_CTRL14_REG			(0x48)
+#define NS92XX_FIM_CTRL15_REG			(0x4c)
+#define NS92XX_FIM_CTRL_REG(i)			(NS92XX_FIM_CTRL0_REG + 4*i)
+#define NS92XX_FIM_CTRL_REG_CHECK(i)		((i<0 || i>15)?1:0)
+
+
+/*
+ * According to the HW-reference manual of the FIMs (page 16)
+ * The macros have as offset the address 0x90001000 (NS92XX_FIM_REG_BASE_PA)
+ */
+#define NS92XX_FIM_STAT0_REG			(0x50)
+#define NS92XX_FIM_STAT1_REG			(0x54)
+#define NS92XX_FIM_STAT2_REG			(0x58)
+#define NS92XX_FIM_STAT3_REG			(0x5c)
+#define NS92XX_FIM_STAT4_REG			(0x60)
+#define NS92XX_FIM_STAT5_REG			(0x64)
+#define NS92XX_FIM_STAT6_REG			(0x68)
+#define NS92XX_FIM_STAT7_REG			(0x6c)
+#define NS92XX_FIM_STAT8_REG			(0x70)
+#define NS92XX_FIM_STAT9_REG			(0x74)
+#define NS92XX_FIM_STAT10_REG			(0x78)
+#define NS92XX_FIM_STAT11_REG			(0x7c)
+#define NS92XX_FIM_STAT12_REG			(0x80)
+#define NS92XX_FIM_STAT13_REG			(0x84)
+#define NS92XX_FIM_STAT14_REG			(0x88)
+#define NS92XX_FIM_STAT_REG(i)			(NS92XX_FIM_STAT0_REG + 4*i)
+#define NS92XX_FIM_STAT_REG_CHECK(i)		((i<0 || i>14)?1:0)
+
+
+/*
+ * According to the HW-reference manual of the FIMs (page 16)
+ * The macros have as offset the address 0x90001000 (NS92XX_FIM_REG_BASE_PA)
+ */
+#define NS92XX_FIM_EXP0_REG			(0x50)
+#define NS92XX_FIM_EXP1_REG			(0x54)
+#define NS92XX_FIM_EXP2_REG			(0x58)
+#define NS92XX_FIM_EXP3_REG			(0x5c)
+#define NS92XX_FIM_EXP4_REG			(0x60)
+#define NS92XX_FIM_EXP5_REG			(0x64)
+#define NS92XX_FIM_EXP6_REG			(0x68)
+#define NS92XX_FIM_EXP7_REG			(0x6c)
+#define NS92XX_FIM_EXP8_REG			(0x70)
+#define NS92XX_FIM_EXP9_REG			(0x74)
+#define NS92XX_FIM_EXP10_REG			(0x78)
+#define NS92XX_FIM_EXP11_REG			(0x7c)
+#define NS92XX_FIM_EXP12_REG			(0x80)
+#define NS92XX_FIM_EXP13_REG			(0x84)
+#define NS92XX_FIM_EXP14_REG			(0x88)
+#define NS92XX_FIM_EXP15_REG			(0x8c)
+#define NS92XX_FIM_EXP_REG(i)			(NS92XX_FIM_EXP0_REG + 4*i)
+#define NS92XX_FIM_EXP_REG_CHECK(i)		((i<0 || i>15)?1:0)
+
+
+/* FIM intruction memory offset */
+#define NS92XX_FIM_INSTRUCTION_ADDR		(0x00)
+
+/* Hardware assist register offsets */
+#define NS92XX_FIM_HWA_GEN_CONF_REG		(0x00)
+
+#define NS92XX_FIM_HWA_SIGNAL0			(0x04)
+#define NS92XX_FIM_HWA_SIGNAL1			(0x08)
+#define NS92XX_FIM_HWA_SIGNAL2			(0x0c)
+#define NS92XX_FIM_HWA_SIGNAL3			(0x10)
+#define NS92XX_FIM_HWA_SIGNAL4			(0x14)
+#define NS92XX_FIM_HWA_SIGNAL5			(0x18)
+#define NS92XX_FIM_HWA_SIGNAL6			(0x1c)
+#define NS92XX_FIM_HWA_SIGNAL7			(0x20)
+#define NS92XX_FIM_HWA_CONTROL0			(0x24)
+#define NS92XX_FIM_HWA_CONTROL1			(0x28)
+#define NS92XX_FIM_HWA_CONTROL2			(0x2c)
+#define NS92XX_FIM_HWA_CONTROL3			(0x30)
+#define NS92XX_FIM_HWA_16_BIT_BUS		(0x34)
+#define NS92XX_FIM_HWA_32_BIT_BUS		(0x38)
+#define NS92XX_FIM_HWA_SIGNAL(index)		(NS92XX_FIM_HWA_GEN_CONF_REG + NS92XX_FIM_HWA_SIGNAL0 + 4*index)
+
+
+/* Fim register bit fields */
+#define NS92XX_FIM_GEN_CTRL_PROGMEM		(0x80000000)
+#define NS92XX_FIM_GEN_CTRL_RESERVED1		(0x7fff0000)
+#define NS92XX_FIM_GEN_CTRL_INTACKWR		(0x00008000)
+#define NS92XX_FIM_GEN_CTRL_INTTOPIC		(0x00007f00)
+#define NS92XX_FIM_GEN_CTRL_INTACKRD		(0x00000080)
+#define NS92XX_FIM_GEN_CTRL_INTFROMPIC		(0x0000007f)
+
+/* Mask used for the interrupt codes from the ARM to the PICs */
+#define NS92XX_FIM_INT_MASK(code)		(code<<8)
+
+
+/* FIM intructions bit fields*/
+#define NS92XX_FIM_INSTRUCTION_MASK		(0x00003fff)
+
+/* Hardware assist register bit fields */
+#define NS92XX_FIM_HWA_GEN_CONF_RESERVED1	(0xffffffe0)
+#define NS92XX_FIM_HWA_GEN_CONF_CLKSEL		(0x0000001c)
+#define NS92XX_FIM_HWA_GEN_CONF_ENABLE		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL0_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL0_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL0_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL0_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL0_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL0_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL1_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL1_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL1_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL1_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL1_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL1_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL2_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL2_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL2_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL2_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL2_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL2_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL3_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL3_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL3_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL3_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL3_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL3_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL4_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL4_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL4_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL4_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL4_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL4_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL5_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL5_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL5_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL5_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL5_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL5_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL6_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL6_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL6_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL6_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL6_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL6_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL7_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL7_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL7_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL7_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL7_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL7_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL0_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL0_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL0_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL0_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL0_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL0_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL1_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL1_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL1_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL1_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL1_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL1_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL2_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL2_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL2_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL2_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL2_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL2_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL3_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL3_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL3_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL3_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL3_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL3_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_16_BIT_BUS_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_16_BIT_BUS_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_16_BIT_BUS_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_32_BIT_BUS_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_32_BIT_BUS_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_32_BIT_BUS_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CLKS		(0x00000003)
+
+
+
+/* H/W Assist General Configuration Register Codes */
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_2	(0)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_4	(1<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_8	(2<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_16	(3<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_32	(4<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_64	(5<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_128	(6<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_256	(7<<2)
+
+#define FIM_REG_ADDR(x) (NS92XX_FIM_REG_BASE_PA + (x * NS92XX_FIM_REG_OFFSET)) 
+#define FIM_INSTR_ADDR(x) (NS92XX_FIM_INSTR_BASE_PA + (x * NS92XX_FIM_INSTR_OFFSET))
+#define FIM_HWA_ADDR(x) (NS92XX_FIM_HWA_BASE_PA + (x * NS92XX_FIM_HWA_OFFSET))
+#define FIM_IOHUB_ADDR(x) (NS92XX_FIM_IOHUB_BASE_PA + (x * NS92XX_FIM_IOHUB_OFFSET))
+
+
+#endif	/* __FIM_REG_H */
+
+
+
+
+
+
+
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.c b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.c
new file mode 100644
index 0000000..18d5b18
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.c
@@ -0,0 +1,1071 @@
+/* -*- linux-c -*-
+ *
+ * cpu/arm926ejs/ns921x/fims/fim_sdio.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision: 1.1.1.1 $
+ * !Author:     Luis Galdos
+ * !References: Based on the MMC-driver of Kyle Harris (kharris@nexus-tech.net)
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include <configs/userconfig.h>
+
+#if defined(CONFIG_NS921X_FIM_SDIO)
+
+/* @XXX: This is not the correct place for this macro, need to move to another place */
+#define CONFIG_SUPPORT_MMC_PLUS
+
+#include <asm/arch/ns921x_sys.h>
+#include <asm/arch/ns921x_hub.h>
+#include <asm/arch/ns921x_gpio.h>
+#include <asm/arch/io.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/ns921x_fim.h>
+#include <asm/arch/ns921x_dma.h>
+
+#include <mmc.h>
+#include <asm/errno.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/protocol.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <part.h>
+
+#include "fim_reg.h"
+#include "fim_sdio.h"
+
+#define AUTODETECTION	0
+#define SD_CARD		1
+#define MMC_CARD	2
+
+/* When reading data, print a dot for each 64K read */
+#define BYTES_PROGRESS_DOT	16384
+
+/* Include only the needed firmware header */
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  include "fim_sdio0.h"
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  include "fim_sdio1.h"
+# else
+#  error "FIM number is not valid!"
+# endif
+#elif defined(CONFIG_CME9210)
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  include "fim_sdio0_9210.h"
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  include "fim_sdio1_9210.h"
+# else
+#  error "FIM number is not valid!"
+# endif
+#endif
+
+//#define FIM_SDIO_DEBUG
+# define printk_info(fmt,args...)                   printf(fmt, ##args)
+# define printk_err(fmt,args...)                   printf("[ ERROR ] " fmt, ##args)
+
+#if defined(FIM_SDIO_DEBUG)
+# define printk_debug(fmt,args...)                   printf(fmt, ##args)
+#else
+# define printk_debug(fmt, args...)                  do { } while (0);
+#endif
+
+/* Values for the block read state machine */
+enum fim_blkrd_state {
+	BLKRD_STATE_IDLE		= 0,
+	BLKRD_STATE_WAIT_ACK		= 1, /* Waiting for the block read ACK */
+	BLKRD_STATE_WAIT_DATA		= 2, /* Waiting for the block read data */
+	BLKRD_STATE_WAIT_CRC		= 3, /* Waiting for the CRC */
+	BLKRD_STATE_HAVE_DATA		= 4, /* Have block read data with the CRC */
+	BLKRD_STATE_TIMEOUTED		= 5, /* Timeout response from the PIC */
+	BLKRD_STATE_CRC_ERR		= 6, /* Compared CRC (PIC and card) differs */
+};
+
+/* Values for the command state machine */
+enum fim_cmd_state {
+	CMD_STATE_IDLE			= 0,
+	CMD_STATE_WAIT_ACK		= 1, /* Waiting for the response ACK */
+	CMD_STATE_WAIT_DATA		= 2, /* Waiting for the response data */
+	CMD_STATE_HAVE_RSP		= 3, /* Have response data */
+	CMD_STATE_TIMEOUTED		= 4, /* Timeout response from the PIC */
+	CMD_STATE_CRC_ERR		= 5, /* Compared CRC (PIC and card) differs */
+};
+
+/*
+ * Response receive structure from the Card
+ * resp  : Card response, with a length of 5 or 17 as appropriate
+ * stat  : Opcode of the executed command
+ * crc   : CRC
+ */
+struct fim_sd_rx_resp_t {
+        unsigned char stat;
+        unsigned char resp[FIM_SD_MAX_RESP_LENGTH];
+        unsigned char crc;
+}__attribute__((__packed__));
+
+/*
+ * Transfer command structure for the card
+ * opctl : Control byte for the PIC
+ * blksz : Block size
+ * cmd   : Command to send to the card
+ */
+struct fim_sd_tx_cmd_t {
+	unsigned char opctl;
+	unsigned char blksz_msb;
+        unsigned char blksz_lsb;
+        unsigned char cmd[FIM_SD_TX_CMD_LEN];
+}__attribute__((__packed__));
+
+struct fim_sdio_t {
+	enum fim_cmd_state cmd_state;
+	enum fim_blkrd_state blkrd_state;
+	struct mmc_command *mmc_cmd;
+	int trans_blocks;
+	int trans_sg;
+	int reg;
+
+	int waiting_process_next;
+	int bus_width;
+	struct mmc_card mmc_card;
+
+	uint card_size;
+	uint blk_size;
+	uchar *blkrd_dst;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct fim_sdio_t fim_sdio;
+struct fim_sdio_t *port = &fim_sdio;
+
+/* FIM SD control registers */
+#define FIM_SD_REG_CLOCK_DIVISOR                0
+#define FIM_SD_REG_INTERRUPT                    1
+#define FIM_SDIO_MAIN_REG			5
+#define FIM_SDIO_MAIN_START			(1 << 0)
+
+#if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+static int pic_num = 0;
+extern const unsigned char fim_sdio_firmware0[];
+#define FIM_SDIO_FIRMWARE			(fim_sdio_firmware0)
+#elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+static int pic_num = 1;
+extern const unsigned char fim_sdio_firmware1[];
+#define FIM_SDIO_FIRMWARE			(fim_sdio_firmware1)
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_FAT)
+extern int fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+#endif
+static block_dev_desc_t mmc_dev;
+static uint  card;
+static unsigned char sdhc = 0;
+
+/*
+ * This function is called for obtaining the device to a corresponding device number
+ * (U-Boot) fatls mmc 1:1 /
+ */
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/* Internal function prototypes */
+static void *fim_sd_dma_to_sg(struct fim_sdio_t *port, struct mmc_data *data,
+			      unsigned char *dma_buf, int dma_len);
+
+inline static void fim_sd_parse_resp(struct mmc_command *cmd,
+				     struct fim_sd_rx_resp_t *resp)
+{
+	unsigned char *ptr;
+	ptr = (unsigned char *)cmd->resp;
+	if (cmd->flags & MMC_RSP_136) {
+		*ptr++ = resp->resp[3];
+		*ptr++ = resp->resp[2];
+		*ptr++ = resp->resp[1];
+		*ptr++ = resp->resp[0];
+		*ptr++ = resp->resp[7];
+		*ptr++ = resp->resp[6];
+		*ptr++ = resp->resp[5];
+		*ptr++ = resp->resp[4];
+		*ptr++ = resp->resp[11];
+		*ptr++ = resp->resp[10];
+		*ptr++ = resp->resp[9];
+		*ptr++ = resp->resp[8];
+		*ptr++ = resp->resp[15];
+		*ptr++ = resp->resp[14];
+		*ptr++ = resp->resp[13];
+		*ptr++ = resp->resp[12];
+	} else {
+		*ptr++ = resp->resp[3];
+		*ptr++ = resp->resp[2];
+		*ptr++ = resp->resp[1];
+		*ptr++ = resp->resp[0];
+		*ptr++ = resp->resp[4];
+		*ptr++ = resp->stat;
+	}
+}
+
+/*
+ * This function checks the CRC by block read transfer
+ * The information about the length and content of the CRC was obtained
+ * from the firmware-source code (sd.asm)
+ */
+inline static int fim_sd_check_blkrd_crc(struct fim_sdio_t *port, unsigned char *data,
+                                         int length)
+{
+        int crc_len;
+        unsigned char *pic_crc;
+
+        /*
+         * The CRC length depends on the bus width (see sd.asm)
+         * No CRC enabled : One byte (0x00)
+         * One bit bus    : Four bytes
+         * Four bit bus   : Eight bytes
+         */
+        if (!(port->mmc_cmd->flags & MMC_RSP_CRC)) {
+                crc_len = 1;
+                pic_crc = data;
+        } else if (port->bus_width == MMC_BUS_WIDTH_1) {
+                crc_len = 4;
+                pic_crc = data + 2;
+        } else {
+                crc_len = 16;
+                pic_crc = data + 8;
+        }
+
+        if (crc_len != length) {
+                printk_err("Unexpected CRC length %i (expected %i)\n",
+                       length, crc_len);
+                return -EINVAL;
+        }
+
+
+        /*
+         * Code for forcing a CRC-error and the behavior of the MMC-layer
+         * crc_error = 10 : Error reading the partition table
+         * crc_error = 40 : Error by a block read transfer
+         */
+#ifdef FIM_SD_FORCE_CRC
+        static int crc_error = 0;
+        if (crc_error == 40) {
+                crc_error++;
+                return 1;
+        } else
+                crc_error++;
+#endif
+
+        /* If the CRC is disabled, the PIC only appended a dummy Byte */
+        if (crc_len == 1)
+                return 0;
+
+        return memcmp(data, pic_crc, crc_len >> 1);
+}
+
+static void fim_sd_process_next(struct fim_sdio_t *port)
+{
+	struct mmc_command *cmd;
+
+	/* mmc0: req done (CMD41): 0: 00ff8000 00003fff 00000000 00000000 */
+	cmd = port->mmc_cmd;
+	printk_debug("mmc0: req done (CMD%u): %d: %08x %08x %08x %08x\n",
+		     cmd->opcode, cmd->error,
+		     cmd->resp[0], cmd->resp[1],
+		     cmd->resp[2], cmd->resp[3]);
+
+	port->waiting_process_next = 0;
+}
+
+/*
+ * Called when a receive DMA-buffer was closed.
+ * Unfortunately the data received from the PIC has different formats. Sometimes it
+ * contains a response, sometimes data of a block read request and sometimes the CRC
+ * of the read data. In the case of a read transfer it is really amazing, then
+ * the transfer consists in four DMA-buffers.
+ */
+static void fim_sd_rx_isr(/* struct fim_driver *driver, int irq, */
+			  struct fim_buffer_t *pdata)
+{
+	/* struct fim_sdio_t *port; */
+	struct mmc_command *mmc_cmd;
+	struct fim_sd_rx_resp_t *resp;
+	int len, crc_len;
+	unsigned char *crc_ptr;
+	int is_ack;
+
+	/* Get the correct port from the FIM-driver structure */
+	len = pdata->length;
+	/* port = (struct fim_sdio_t *)driver->driver_data; */
+	/* spin_lock(&port->mmc_lock); */
+
+	/*
+	 * The timeout function can set the command structure to NULL, for this reason
+	 * check here is we can handle the response correctly
+	 */
+	if ((mmc_cmd = port->mmc_cmd) == NULL) {
+		printk_err("Timeouted command response?\n");
+		/* goto exit_unlock; */
+	}
+
+	/*
+	 * Check the current state of the command and update it if required
+	 * IMPORTANT: The buffer can contain response data or the data from a block
+	 * read too, for this reason was implemented the state machine
+	 */
+	resp = (struct fim_sd_rx_resp_t *)pdata->data;
+	is_ack = (pdata->length == 1) ? 1 : 0;
+
+	printk_debug("CMD%i | PIC stat %x | CMD stat %i | BLKRD stat %i | Len %i\n",
+	       mmc_cmd->opcode, resp->stat, port->cmd_state,
+	       port->blkrd_state, pdata->length);
+
+	/*
+	 * By the ACKs the PIC will NOT send a timeout. Timeouts are only
+	 * set by the response and and block read data
+	 */
+	if (is_ack && resp->stat & FIM_SD_RX_TIMEOUT) {
+		mmc_cmd->error = -ETIMEDOUT;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+
+		/* Check the conditions for the BLOCK READ state machine */
+	} else if (port->blkrd_state == BLKRD_STATE_WAIT_ACK && is_ack &&
+		   resp->stat & FIM_SD_RX_BLKRD) {
+		port->blkrd_state = BLKRD_STATE_WAIT_DATA;
+
+		/* Check if the block read data has arrived */
+	} else if (port->blkrd_state == BLKRD_STATE_WAIT_DATA && !is_ack) {
+		crc_len = len - mmc_cmd->data->blksz;
+		crc_ptr = pdata->data + mmc_cmd->data->blksz;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+
+		if (fim_sd_check_blkrd_crc(port, crc_ptr, crc_len)) {
+			mmc_cmd->error = -EILSEQ;
+		} else {
+			/*
+			 * @UBOOT: Only pass the number of data bytes to the copy
+			 * function, otherwise the CRC will be copied too!
+			 */
+			fim_sd_dma_to_sg(port, mmc_cmd->data,
+					 pdata->data, pdata->length - crc_len);
+ 		}
+
+		/* Check if we have a multiple transfer read */
+		port->trans_blocks -= 1;
+		if (port->trans_blocks > 0)
+			port->blkrd_state = BLKRD_STATE_WAIT_DATA;
+
+		/* Check the conditions for the COMMAND state machine */
+	} else if (is_ack && port->cmd_state == CMD_STATE_WAIT_ACK &&
+		   resp->stat & FIM_SD_RX_RSP) {
+		port->cmd_state = CMD_STATE_WAIT_DATA;
+
+	} else if (!is_ack && port->cmd_state == CMD_STATE_WAIT_DATA) {
+		fim_sd_parse_resp(mmc_cmd, resp);
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+
+		/* Check for unexpected acks or opcodes */
+	} else {
+
+		/* @FIXME: Need a correct errror handling for this condition */
+		printk_err("Unexpected RX stat (CMD%i | PIC stat %x | Length %i)\n",
+		       mmc_cmd->opcode, resp->stat, pdata->length);
+	}
+
+	/*
+	 * By errors set the two states machines to the end position for sending
+	 * the error to the MMC-layer
+	 */
+	if (mmc_cmd->error) {
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+	}
+
+	/*
+	 * Now evaluate if need to wait for another RX-interrupt or
+	 * can send the request done to the MMC-layer
+	 */
+	if (port->cmd_state == CMD_STATE_HAVE_RSP &&
+	    port->blkrd_state == BLKRD_STATE_HAVE_DATA)
+		fim_sd_process_next(port);
+
+/*  exit_unlock: */
+	/* spin_unlock(&port->mmc_lock); */
+}
+
+/*
+ * Function called when RD data has arrived
+ * Return value is the pointer of the last byte copied to the scatterlist, it can
+ * be used for appending more data (e.g. in multiple block read transfers)
+ */
+static void *fim_sd_dma_to_sg(struct fim_sdio_t *port, struct mmc_data *data,
+			      unsigned char *dma_buf, int dma_len)
+{
+/*         unsigned int len, cnt, process; */
+/*         struct scatterlist *sg; */
+/*         char *sg_buf; */
+
+/*         sg = data->sg; */
+/*         len = data->sg_len; */
+
+/*         /\* Need a correct error handling *\/ */
+/* #if !defined(FIM_SD_MULTI_BLOCK) */
+/*         if (len > 1) { */
+/*                 printk_err("The FIM-SD host driver only supports single block\n"); */
+/*                 len = 1; */
+/*         } */
+/* #endif */
+
+/*         /\* This loop was tested only with single block transfers *\/ */
+/*         sg_buf = NULL; */
+/*         for (cnt = port->trans_sg; cnt < len && dma_len > 0; cnt++) { */
+/*                 process = dma_len > sg[cnt].length ? sg[cnt].length : dma_len; */
+/*                 sg_buf = sg_virt(&sg[cnt]); */
+/*                 memcpy(sg_buf, dma_buf, process); */
+/*                 dma_buf += process; */
+/*                 dma_len -= process; */
+/*                 data->bytes_xfered += process; */
+/*                 sg_buf += process; */
+/*                 port->trans_sg += 1; */
+/*         } */
+
+/*         return sg_buf; */
+
+	memcpy(port->blkrd_dst, dma_buf, dma_len);
+
+	return NULL;
+}
+
+static struct fim_buffer_t *fim_sd_alloc_cmd(void)
+{
+	static struct fim_sd_tx_cmd_t fim_cmd;
+	static struct fim_buffer_t fim_buf = {
+		.length = sizeof(struct fim_sd_tx_cmd_t),
+		.data = (uchar *)&fim_cmd,
+		.sent = 0,
+		.private = NULL,
+	};
+
+	return &fim_buf;
+}
+
+/* Send a buffer over the FIM-API */
+static int fim_sd_send_buffer(struct fim_buffer_t *buf)
+{
+	int retval;
+
+	if (!buf)
+		return -EINVAL;
+
+	if ((retval = fim_send_buffer(pic_num, buf)))
+		printk_err("FIM send buffer request failed.\n");
+
+	return retval;
+}
+
+/* This function will send the command to the PIC using the TX-DMA buffers */
+static int fim_sd_send_command(struct mmc_command *cmd)
+{
+	struct mmc_data *data;
+	struct fim_buffer_t *buf;
+	struct fim_sd_tx_cmd_t *txcmd;
+	unsigned int block_length, blocks;
+	int retval, length;
+
+	/* @TODO: Send an error response to the MMC-core */
+	buf = fim_sd_alloc_cmd();
+
+	/* Use the buffer data for the TX-command */
+	txcmd = (struct fim_sd_tx_cmd_t *)buf->data;
+	txcmd->opctl = 0;
+
+	/*
+	 * Set the internal flags for the next response sequences
+	 * Assume that we will wait for a command response (not block read).
+	 * By block reads the flag will be modified inside the if-condition
+	 */
+	port->cmd_state = CMD_STATE_WAIT_ACK;
+	port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+	if ((data = cmd->data) != NULL) {
+		block_length = data->blksz;
+		blocks = data->blocks;
+
+#if !defined(FIM_SD_MULTI_BLOCK)
+		if (blocks != 1) {
+			printf("Only supports single block transfer (%i)\n", blocks);
+			cmd->error = -EILSEQ;
+			fim_sd_process_next(port);
+			return -EILSEQ;
+		}
+#endif
+
+		printk_debug("Transfer of %i blocks (len %i)\n", blocks, block_length);
+
+/* 		/\* Reset the scatter list position *\/ */
+/* 		port->trans_sg = 0; */
+		port->trans_blocks = blocks;
+		fim_set_ctrl_reg(pic_num, 2, blocks);
+
+		/* Check if the transfer request is for reading or writing */
+		if (cmd->data->flags & MMC_DATA_READ) {
+			txcmd->opctl |= SDIO_FIFO_TX_BLKRD;
+			port->blkrd_state = BLKRD_STATE_WAIT_ACK;
+		} else
+			txcmd->opctl |= SDIO_FIFO_TX_BLKWR;
+	} else {
+		block_length = 0;
+		blocks = 0;
+	}
+
+	/* Set the correct expected response length */
+	if (cmd->flags & MMC_RSP_136)
+		txcmd->opctl |= SDIO_FIFO_TX_136RSP;
+	else
+		txcmd->opctl |= SDIO_FIFO_TX_48RSP;
+
+	/* Set the correct CRC configuration */
+	if (!(cmd->flags & MMC_RSP_CRC)) {
+		printk_debug("CRC is disabled\n");
+		txcmd->opctl |= SDIO_FIFO_TX_DISCRC;
+	}
+
+	/* Set the correct bus width for the FIM transfer */
+	if (port->bus_width == MMC_BUS_WIDTH_4) {
+		printk_debug("Bus width has four bits\n");
+		txcmd->opctl |= SDIO_FIFO_TX_BW4;
+	}
+
+	txcmd->blksz_msb = (block_length >> 8);
+	txcmd->blksz_lsb =  block_length;
+	txcmd->cmd[0] = SDIO_HOST_TX_HDR | (cmd->opcode & SDIO_HOST_CMD_MASK);
+	txcmd->cmd[1] = cmd->arg >> 24;
+	txcmd->cmd[2] = cmd->arg >> 16;
+	txcmd->cmd[3] = cmd->arg >> 8;
+	txcmd->cmd[4] = cmd->arg;
+
+	/*
+	 * Store the private data for the callback function
+	 * If an error ocurrs when sending the buffer, the timeout function will
+	 * send the error to the MMC-layer
+	 */
+/* 	port->buf = buf; */
+	port->mmc_cmd = cmd;
+/* 	buf->private = port; */
+/* 	mod_timer(&port->mmc_timer, jiffies + msecs_to_jiffies(FIM_SD_TIMEOUT_MS)); */
+	if ((retval = fim_sd_send_buffer(buf))) {
+		printk_err("MMC command %i (err %i)\n", cmd->opcode, retval);
+		goto exit_ok;
+	}
+
+	if (fim_wait_txdma(pic_num)) {
+		ulong ifs;
+
+		/* If we have a timeout then try to get some infos about it */
+		ifs = readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+		printk_err("FIM%i: Timeout sending CMD%u [0x%08x]\n",
+			   pic_num, cmd->opcode, ifs);
+		retval = -EBUSY;
+	}
+
+
+	/*
+	 * If we have a write command then fill a next buffer and send it
+	 * @TODO: We need here an error handling, then otherwise we have started a
+	 * WR-transfer but have no transfer data (perhaps not too critical?)
+	 */
+	if (data && data->flags & MMC_DATA_WRITE) {
+		length = data->blksz * data->blocks;
+/* 		if (!(buf = fim_sd_alloc_buffer(port, length))) { */
+/* 			printk_err("Buffer alloc BLKWR failed, %i\n", length); */
+/* 			goto exit_ok; */
+/* 		} */
+
+/* 		buf->private = port; */
+/* 		fim_sd_sg_to_dma(port, data, buf); */
+/* 		if ((retval = fim_sd_send_buffer(port, buf))) { */
+/* 			printk_err("Send BLKWR-buffer failed, %i\n", retval); */
+/* 			fim_sd_free_buffer(port, buf); */
+/* 		} */
+	}
+
+ exit_ok:
+	return retval;
+}
+
+static int mmc_cmd(u32 opcode, u32 arg, unsigned int flags, struct mmc_data *data)
+{
+	static struct mmc_command mmc_cmd;
+	struct fim_buffer_t *rxbuf;
+
+	/* Send a reset command first */
+	mmc_cmd.opcode = opcode;
+	mmc_cmd.arg = arg;
+	mmc_cmd.data = data;
+	mmc_cmd.flags = flags;
+	mmc_cmd.error = 0;
+	memset(mmc_cmd.resp, 0, sizeof(mmc_cmd.resp));
+	if (fim_sd_send_command(&mmc_cmd))
+		return -ENODEV;
+
+	port->waiting_process_next = 1;
+	while (port->waiting_process_next) {
+
+		if (!(rxbuf = fim_wait_rxdma(pic_num, 1000))) {
+			printk_err("Timeout by RX-DMA %i (INT 0x%08lx)\n",
+				   pic_num, readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT));
+			return -ENODEV;
+		}
+
+		/* A new DMA-buffer is full, so call the handler */
+		fim_sd_rx_isr(rxbuf);
+	}
+
+	return mmc_cmd.error;
+}
+
+static void set_bus_width(int width)
+{
+	u32 flags, arg;
+
+	if(card == MMC_CARD) {
+		flags = 0x0000049d;
+		arg = 0x03b70000 | (width << 7);
+		if (mmc_cmd(MMC_SWITCH, arg, flags, NULL)) {
+			printk_err("Setting the bus width!\n");
+			return;
+		}
+	} else  {
+		/* CMD55: Prepare for the next application command */
+		flags = 0x00000095;
+		if (mmc_cmd(MMC_APP_CMD, port->mmc_card.rca << 16, flags, NULL)) {
+			printk_err("Couldn't prepare the card for the APPCMD6\n");
+			return;
+		}
+
+		/* APCMD6: Set the bus width */
+		flags = 0x00000015;
+		if (mmc_cmd(SD_APP_SET_BUS_WIDTH, width, flags, NULL)) {
+			printk_err("Setting the bus width!\n");
+			return;
+		}
+	}
+}
+
+void get_sd_scr(void)
+{
+	uint scr1, sd_spec;
+	struct mmc_data data;
+
+	/* ACMD51: Get the SCR */
+	mmc_cmd(MMC_APP_CMD, port->mmc_card.rca << 16, 0x000000f5, NULL);
+	data.blocks = 1;
+	data.blksz = 8;
+	data.flags = MMC_DATA_READ;
+	mmc_cmd(SD_APP_SEND_SCR, 0x0, 0x000000b5, &data);
+
+	udelay(1000);
+	scr1 = port->mmc_cmd->resp[0];
+
+	if (scr1 & 0x1<<24)
+		sd_spec = 1;	/* Version 1.10, support CMD6 */
+	else
+		sd_spec = 0;	/* Version 1.0 ~ 1.01 */
+
+	printf("sd_spec = 1.%d(0x%08x)\n", sd_spec, scr1);
+}
+
+uint check_sd_ocr(void)
+{
+	uint i, ret = 0;
+
+	for(i = 0; i < 0x80; i++) {
+		/* CMD55: Prepare for a next Application command (ACMD41) */
+		mmc_cmd(MMC_APP_CMD, 0, 0x000000f5, NULL);
+		/* CMD41: Get the OCR from the card */
+		mmc_cmd(SD_APP_OP_COND, 0x40300000, 0x000000e1, NULL);
+		/*
+		 * If the busy bit is set, then the card informs us that the power up
+		 * procedure is done.
+		 */
+		if (!port->mmc_cmd->error && (port->mmc_cmd->resp[0] & MMC_CARD_BUSY)) {
+			if (port->mmc_cmd->resp[0] & MMC_HIGH_CAPACITY)
+				sdhc = 1;
+			ret = SD_CARD;
+			break;
+		}
+		else
+			udelay(10000);
+	}
+
+	return ret;
+}
+
+uint check_mmc_ocr(void)
+{
+	uint i, ret = 0;
+
+	for(i = 0; i < 5; i++) {
+		/* CMD1: Get the OCR from the card */
+		mmc_cmd(MMC_SEND_OP_COND, 0x40300000, 0x000000e1, NULL);
+		/*
+		 * If the busy bit is set, then the card informs us that the power up
+		 * procedure is done.
+		 */
+		if (!port->mmc_cmd->error && (port->mmc_cmd->resp[0] & MMC_CARD_BUSY)) {
+			if (port->mmc_cmd->resp[0] & MMC_HIGH_CAPACITY)
+				sdhc = 1;
+			ret = MMC_CARD;
+			break;
+		}
+		else
+			udelay(100000);
+	}
+
+	return ret;
+}
+
+/*
+ * Function for reading data from the card
+ * dst : Memory address to transfer the read data to
+ * src : Address inside the card to read from
+ * len : Block size to read (must be configured first)
+ */
+int mmc_block_read(uchar *dst, ulong src, ulong len)
+{
+	struct mmc_data data;
+	int retval;
+	u32 flags;
+
+	port->blkrd_dst = dst;
+
+	/* CMD17: Read a single block from the card */
+	data.blocks = 1;
+	data.blksz = port->blk_size;
+	data.flags = MMC_DATA_READ;
+	flags = 0xb5 | MMC_RSP_CRC;
+
+	if (sdhc) {
+		/* Convert src to Block addressing */
+		src /= port->blk_size;
+	}
+	retval = mmc_cmd(MMC_READ_SINGLE_BLOCK, src, flags, &data);
+
+	return retval;
+}
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	ulong blksz, blocks;
+	ulong cnt;
+	u8 *ptr;
+	u32 progress = 0;
+
+	/* @XXX: Sanity check probably not required */
+	if (size == 0) {
+		printk_err("Zero data to read?\n");
+		return 0;
+	}
+
+	blksz = port->blk_size;
+	blocks = (size) / blksz;
+
+	printk_debug("Read: src %lx to dest %lx (Blocks %i x %luB)\n",
+		    src, (ulong)dst, blocks, blksz);
+
+	/* Main loop for reading the different blocks */
+	for (ptr = dst, cnt = 0; cnt < blocks; cnt++) {
+		if ((mmc_block_read((uchar *)ptr, src, blksz)) < 0) {
+			printk_err("Block read error. Aborting\n");
+			return -1;
+		}
+		if (++progress == BYTES_PROGRESS_DOT / blksz) {
+			printf(".");
+			progress = 0;
+		}
+
+		src += blksz;
+		ptr += blksz;
+	}
+
+	return 0;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	return 0;
+}
+
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+{
+	ulong src = (blknr * port->blk_size)/*  + CFG_MMC_BASE */;
+
+	printk_debug("%s: Read %i block(s) from %i | Dest %p\n",
+		     __func__, blkcnt, blknr, dst);
+
+	/* In some cases the caller pass ZERO as number of blocks to read */
+	blkcnt = (!blkcnt) ? (1) : blkcnt;
+
+        mmc_read(src, (uchar *)dst, blkcnt * port->blk_size);
+        return blkcnt;
+}
+
+/* Below function is coming from the S3C24XX machine code */
+static int fim_sdio_fill_csd(u32 *resp)
+{
+        uint c_size, c_size_multi, read_bl_len;
+	uint csd_struct;
+	uint mb;
+
+	if (card == SD_CARD) {
+		/* CSD struct is at bits [127:126] i.e. R0[31:30]
+		* At this point Response is: R0-R1-R2-R3 where
+		* R0.31 is the MSB and R3.0 the LSB (unshifted) */
+		csd_struct = resp[0] >> 30;
+		switch (csd_struct) {
+			case 0:
+				sdhc = 0;
+				break;
+			case 1:
+				/* SDHC card > 2Gb.
+				* This should have already been discovered
+				* in the OCR data (bit 30), but just in case */
+				sdhc = 1;
+				break;
+			default:
+				printf("ERROR: incorrect CSD Structure version. Card not supported\n");
+				return -1;
+		}
+	}
+
+	/* Common fields for SD/SDHC/MMC */
+        read_bl_len = (resp[1] >> 16) & 0xf;
+        port->blk_size = (1 << read_bl_len);
+        printf("Block Size: %d Bytes\n", port->blk_size);
+
+	if (sdhc) {
+		/* Special size calculation procedure for
+		 * SDHC cards: In theory, they are 22 bits,
+		 * but the specification says that only 16 bits
+		 * are valid. c_size is given in blocks */
+		c_size = resp[2] >> 16;
+		port->card_size = (c_size + 1) << 10;	/* in blocks */
+	} else {
+		/* Standard size calculation procedure for
+		 * SD and MMC cards */
+		c_size = ((resp[1] & 0x3ff) << 2 ) | ((resp[2] >> 30) & 0x3);
+		c_size_multi = ((resp[2] >> 15) & 0x7);
+		port->card_size = (c_size + 1) *
+			    (1 << (c_size_multi + 2)); /* in blocks */
+	}
+	/* Card size in MB + security area */
+	mb = (port->card_size * port->blk_size) / 1048576 + 1;
+	if (mb / 1024 > 0)
+		printf("Card Size: %d.%d GBytes\n",
+			mb / 1024,
+			(mb % 1024)*100/1024);
+	else
+		printf("Card Size: %d MBytes\n", mb);
+
+	return 0;
+}
+
+/*
+ * This function is called over the command "mmcinit"
+ */
+int mmc_init(uint card_type, uint width, uint highspeed)
+{
+ 	int rc = -ENODEV;
+	unsigned int flags;
+	unsigned long clkdiv;
+	int fwver, rca;
+
+	//printk_info("Firmware address 0x%08x\n", FIM_SDIO_FIRMWARE);
+
+	/* Reset sdhc flag */
+	sdhc = 0;
+
+	/* Check if the instruction cache is enabled, otherwise return at this point */
+	if (!icache_status()) {
+		printk_err("Instruction cache required for this operation (icache on)\n");
+		return -EAGAIN;
+	}
+
+	/* Install the FIM-firmware for the SDIO-port */
+        if(fim_core_init(pic_num, FIM_SDIO_FIRMWARE)) {
+		printf("Couldn't install the FIM-firmware\n");
+                return -ENODEV;
+	}
+
+	fwver = fim_get_exp_reg(pic_num, FIM_SDIO_VERSION_SREG);
+	printk_debug("FIM%u: Firmware revision rev%02x\n", pic_num, fwver);
+
+	/* Configure the GPIOs */
+	printk_debug("Configuring GPIOs: %d,%d,%d,%d,%d,%d,%d\n",
+		FIM_SDIO_D0,
+		FIM_SDIO_D1,
+		FIM_SDIO_D2,
+		FIM_SDIO_D3,
+		FIM_SDIO_CD,
+		FIM_SDIO_CLK,
+		FIM_SDIO_CMD);
+	gpio_cfg_set(FIM_SDIO_D0, GPIO_CFG_FUNC_FIM_SDIO_D0);
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+	gpio_cfg_set(FIM_SDIO_D1, GPIO_CFG_FUNC_FIM_SDIO_D1);
+	gpio_cfg_set(FIM_SDIO_D2, GPIO_CFG_FUNC_FIM_SDIO_D2);
+	gpio_cfg_set(FIM_SDIO_D3, GPIO_CFG_FUNC_FIM_SDIO_D3);
+#endif
+	gpio_cfg_set(FIM_SDIO_CD, GPIO_CFG_FUNC_FIM_SDIO_CD);
+	gpio_cfg_set(FIM_SDIO_CLK, GPIO_CFG_FUNC_FIM_SDIO_CLK);
+	gpio_cfg_set(FIM_SDIO_CMD, GPIO_CFG_FUNC_FIM_SDIO_CMD);
+
+	/* Configure the write protect GPIO as input IO */
+	gpio_cfg_set(FIM_SDIO_WP,
+		     GPIO_CFG_INPUT | GPIO_CFG_PULLUP_DISABLE | GPIO_CFG_FUNC_GPIO);
+
+	/* turn on the power */
+	udelay(1000);
+
+	fim_init_rxdma(pic_num);
+
+	/* Configure the clock with 320kHz */
+	clkdiv = 0x70;
+	fim_set_ctrl_reg(pic_num, FIM_SD_REG_CLOCK_DIVISOR, clkdiv);
+
+	/* Start the code execution on the FIM */
+	fim_set_ctrl_reg(pic_num, FIM_SDIO_MAIN_REG, FIM_SDIO_MAIN_START);
+
+	port->bus_width = MMC_BUS_WIDTH_1;
+
+	/* A timeout will happen by this reset-command (but isn't a failure) */
+	mmc_cmd(MMC_GO_IDLE_STATE, 0, 0x000000c0, NULL);
+
+	/* CMD8: Get the Card Specific Data from the card */
+	if ((rc = mmc_cmd(MMC_SEND_EXT_CSD, 0x000001aa, 0x000002f5, NULL))) {
+		/* printk_err("FIM%u: Couldn't get the CSD\n", pic_num); */
+		/* return rc; */
+	}
+
+	switch(card_type) {
+		case AUTODETECTION:
+		case MMC_CARD:
+			if(check_mmc_ocr()) {
+				card = MMC_CARD;
+				printf("MMC card is detected\n");
+				break;
+			}
+		case SD_CARD:
+			if(check_sd_ocr()) {
+				card = SD_CARD;
+				printf("SD%s card is detected\n",
+					sdhc ? "HC" : "" );
+				break;
+			}
+		default:
+			return 1;
+	}
+
+	/* CMD2: Send the CID to the MMC-host */
+	flags = MMC_RSP_R2 | MMC_CMD_BCR;
+	if ((rc = mmc_cmd(MMC_ALL_SEND_CID, 0x0, flags, NULL))) {
+		printk_err("Reading the CID\n");
+		return rc;
+	}
+
+	/* CMD3: Get the relative card address (RCA) */
+	rca = (card & MMC_CARD) ? 0x1 : 0x0;
+	if ((rc = mmc_cmd(MMC_SET_RELATIVE_ADDR, rca << 16, 0x00000075, NULL))) {
+		printk_err("Setting the relative address\n");
+		return rc;
+	}
+	/* Read RCA only on SD cards */
+	if (!rca)
+		rca = port->mmc_cmd->resp[0] >> 16;
+	port->mmc_card.rca = rca;
+
+	/* CMD9: Get the card specific data (CSD) */
+	if ((rc = mmc_cmd(MMC_SEND_CSD, port->mmc_card.rca << 16, 0x00000087, NULL))) {
+		printk_err("Error on CMD9\n");
+		return rc;
+	}
+	fim_sdio_fill_csd(port->mmc_cmd->resp);
+
+	/* CMD7: Select the card for the next operations */
+	if ((rc = mmc_cmd(MMC_SELECT_CARD, port->mmc_card.rca << 16, 0x00000015, NULL))) {
+		printk_err("Error on CMD7\n");
+		return rc;
+	}
+
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+	/* Set bus width to 4 bits in cc(w)9p9215 */
+	port->bus_width = MMC_BUS_WIDTH_4;
+#endif
+	set_bus_width(port->bus_width);
+
+	/* Now, the card can be driven at full speed */
+	fim_set_ctrl_reg(pic_num, FIM_SD_REG_CLOCK_DIVISOR, 0x4);
+
+	/* FAT and ext2 require a block size of 512.
+	 * it needs to be forced despite of the value in CSD */
+	if (MMC_BLOCK_SIZE != port->blk_size)
+		port->blk_size = MMC_BLOCK_SIZE;
+
+	/* CMD16: Set the correct block length to read */
+	flags = 0x00000095; //MMC_RSP_CRC | MMC_CMDAT_R1;
+	while(mmc_cmd(MMC_CMD_SET_BLOCKLEN, port->blk_size, flags, NULL));
+
+	/* Setup the mmc device in order to register a FAT device */
+        mmc_dev.if_type = IF_TYPE_MMC;
+        mmc_dev.part_type = PART_TYPE_DOS;
+        mmc_dev.dev = 0;
+        mmc_dev.lun = 0;
+        mmc_dev.type = 0;
+        mmc_dev.blksz = port->blk_size;
+        mmc_dev.lba = port->card_size;
+        sprintf((char*) mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+                        0x00, 0x1, 0x2, 0x1, 0x2, 0x3);
+        sprintf((char*) mmc_dev.product,"%s","SD/MMC");
+        sprintf((char*) mmc_dev.revision,"%x %x",0x1, 0x1);
+        mmc_dev.removable = 0;
+        mmc_dev.block_read = mmc_bread;
+#if (CONFIG_COMMANDS & CFG_CMD_FAT)
+	fat_register_device(&mmc_dev, MMC_MAX_DEVICE);
+#endif
+	return 0;
+}
+
+int hs_mmc_get_dev(uint card, uint buswidth, uint highspeed)
+{
+
+	return -1;
+}
+
+int hs_mmc_init(uint card, uint buswidth, uint highspeed)
+{
+
+	return -1;
+}
+
+int mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+/* 	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) { */
+/* 		return 1; */
+/* 	} */
+	return 0;
+}
+
+#endif /* CONFIG_NS921X_FIM_SDIO && CONFIG_MMC */
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.h b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.h
new file mode 100644
index 0000000..d291bea
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio.h
@@ -0,0 +1,57 @@
+/* FIM SD registers, flags, and macros */
+
+/* Registers with status information */
+#define FIM_SD_GPIOS_REG			0x02
+#define FIM_SD_GPIOS_REG_CD			0x01
+#define FIM_SD_GPIOS_REG_WP			0x02
+#define FIM_SD_CARD_STATREG			0x00
+
+/* Interrupts from the FIM to the driver */
+#define FIM_SD_INTARM_CARD_DAT1			0x01
+#define FIM_SD_INTARM_CARD_DETECTED		0x02
+
+
+/* Macros for the SDIO-interface to the FIM-firmware */
+#define SDIO_HOST_TX_HDR			0x40
+#define SDIO_HOST_CMD_MASK			0x3f
+#define SDIO_FIFO_TX_48RSP			0x01
+#define	SDIO_FIFO_TX_136RSP			0x02
+#define SDIO_FIFO_TX_BW4			0x04
+#define SDIO_FIFO_TX_BLKWR			0x08
+#define SDIO_FIFO_TX_BLKRD			0x10
+#define SDIO_FIFO_TX_DISCRC			0x20
+
+
+/* User specified macros */
+#define FIM_SD_TIMEOUT_MS			2000
+#define FIM_SD_TX_CMD_LEN			5
+#define FIM_SD_MAX_RESP_LENGTH			17
+
+
+/* Status bits from the PIC-firmware */
+#define FIM_SD_RX_RSP				0x01
+#define FIM_SD_RX_BLKRD				0x02
+#define FIM_SD_RX_TIMEOUT			0x04
+
+
+/* FIM SD control registers */
+#define FIM_SD_REG_CLOCK_DIVISOR		0
+#define FIM_SD_REG_INTERRUPT			1
+
+
+/* Internal flags for the request function */
+#define FIM_SD_REQUEST_NEW			0x00
+#define FIM_SD_REQUEST_CMD			0x01
+#define FIM_SD_REQUEST_STOP			0x02
+#define FIM_SD_SET_BUS_WIDTH			0x04
+
+
+/* Macros for the DMA-configuraton */
+#define FIM_SD_DMA_BUFFER_SIZE			PAGE_SIZE
+#define FIM_SD_DMA_RX_BUFFERS			21
+#define FIM_SD_DMA_TX_BUFFERS			10
+
+/*
+ * Expansion/Status register with the revision number
+ */
+#define FIM_SDIO_VERSION_SREG			(0)
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0.h b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0.h
new file mode 100644
index 0000000..12c99a0
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0.h
@@ -0,0 +1,225 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio.h
+ * Structure     : fim_sdio_firmware0
+ */
+
+static const unsigned char fim_sdio_firmware0[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x2f, 0x03, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x1d, 0x23, 0x83, 0x12,  0x9f, 0x01, 0x9f, 0x14,  
+	0x83, 0x16, 0xff, 0x30,  0x99, 0x00, 0x83, 0x12,  
+	0x83, 0x12, 0x15, 0x1c,  0x16, 0x28, 0x00, 0x30,  
+	0xa6, 0x00, 0x1c, 0x28,  0xa4, 0x01, 0xbb, 0x01,  
+	0xbc, 0x01, 0xbd, 0x01,  0xbe, 0x01, 0xbf, 0x01,  
+	0xc0, 0x01, 0xc1, 0x01,  0xc2, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0xb9, 0x01, 0x3d, 0x20,  
+	0x8c, 0x1d, 0x54, 0x28,  0x2e, 0x20, 0x1c, 0x28,  
+	0x83, 0x16, 0x1a, 0x14,  0x83, 0x12, 0x10, 0x08,  
+	0xac, 0x00, 0xac, 0x0b,  0x33, 0x28, 0x83, 0x16,  
+	0x1a, 0x10, 0x83, 0x12,  0x10, 0x08, 0xac, 0x00,  
+	0xac, 0x0b, 0x3a, 0x28,  0x08, 0x00, 0x22, 0x1c,  
+	0x48, 0x28, 0x83, 0x16,  0x89, 0x1f, 0x46, 0x28,  
+	0x83, 0x12, 0x89, 0x01,  0x22, 0x10, 0x08, 0x00,  
+	0x83, 0x12, 0x08, 0x00,  0x11, 0x1c, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1c,  0x4f, 0x28, 0x83, 0x12,  
+	0x08, 0x00, 0x83, 0x12,  0x22, 0x14, 0x01, 0x30,  
+	0x89, 0x00, 0x08, 0x00,  0x9f, 0x10, 0xa7, 0x01,  
+	0x0f, 0x23, 0xa3, 0x00,  0x0f, 0x23, 0xb5, 0x00,  
+	0x0f, 0x23, 0xb4, 0x00,  0xff, 0x39, 0x03, 0x19,  
+	0x62, 0x28, 0x35, 0x08,  0x01, 0x3e, 0xb5, 0x00,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x8e, 0x20, 0x27, 0x08,  
+	0x75, 0x20, 0x9f, 0x14,  0x23, 0x18, 0x9b, 0x28,  
+	0xa3, 0x18, 0x9b, 0x28,  0x46, 0x29, 0xaa, 0x00,  
+	0x08, 0x30, 0xad, 0x00,  0xaa, 0x0d, 0x83, 0x16,  
+	0x03, 0x18, 0x7e, 0x28,  0x9a, 0x10, 0x7f, 0x28,  
+	0x9a, 0x14, 0x83, 0x12,  0x85, 0x20, 0x2e, 0x20,  
+	0xad, 0x0b, 0x78, 0x28,  0x08, 0x00, 0xa7, 0x13,  
+	0x03, 0x18, 0xa7, 0x17,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x08, 0x00, 0x09, 0x30,  0xa7, 0x06, 0x08, 0x00,  
+	0x07, 0x30, 0xa9, 0x00,  0x03, 0x10, 0xa7, 0x0d,  
+	0xa7, 0x1f, 0x96, 0x28,  0x09, 0x30, 0xa7, 0x06,  
+	0xa9, 0x0b, 0x90, 0x28,  0x03, 0x14, 0xa7, 0x0d,  
+	0x08, 0x00, 0x64, 0x30,  0xab, 0x00, 0xb0, 0x01,  
+	0xa7, 0x01, 0xab, 0x0b,  0xa2, 0x28, 0x1c, 0x29,  
+	0x1f, 0x21, 0x03, 0x18,  0x9f, 0x28, 0x23, 0x1a,  
+	0xe0, 0x28, 0x01, 0x30,  0x18, 0x23, 0x03, 0x10,  
+	0x2d, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0xa3, 0x18, 0xc2, 0x28,  
+	0x8e, 0x20, 0x27, 0x08,  0xa8, 0x00, 0x2c, 0x21,  
+	0x13, 0x23, 0x28, 0x08,  0xa3, 0x19, 0xc0, 0x28,  
+	0x18, 0x23, 0x46, 0x29,  0x13, 0x23, 0x46, 0x29,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x13, 0x23, 0x28, 0x08,  
+	0x18, 0x23, 0x46, 0x29,  0x50, 0x30, 0x84, 0x00,  
+	0x2d, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0xa3, 0x1c,  
+	0x14, 0x29, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x80, 0x00, 0x24, 0x18,  
+	0xfc, 0x29, 0x0b, 0x2a,  0x04, 0x30, 0x18, 0x23,  
+	0x1c, 0x28, 0x23, 0x1a,  0x21, 0x22, 0x83, 0x16,  
+	0x92, 0x18, 0x28, 0x29,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x10, 0x08, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x14, 0x08, 0x00,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x30, 0x08, 0x08, 0x00,  
+	0x23, 0x1a, 0xfc, 0x29,  0xa3, 0x19, 0x4f, 0x29,  
+	0x2e, 0x20, 0x2e, 0x20,  0x2e, 0x20, 0x3d, 0x20,  
+	0x1c, 0x28, 0x2e, 0x20,  0x2e, 0x20, 0xff, 0x30,  
+	0x23, 0x1d, 0x11, 0x30,  0x83, 0x16, 0x98, 0x00,  
+	0xff, 0x3a, 0x99, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x83, 0x16, 0x98, 0x01,  0x83, 0x12, 0x2e, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x0f, 0x23, 0xb8, 0x00,  0x23, 0x19, 0x79, 0x29,  
+	0x08, 0x30, 0xba, 0x00,  0xb8, 0x1b, 0x6f, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x00, 0x30,  
+	0x73, 0x29, 0x83, 0x16,  0x18, 0x14, 0x83, 0x12,  
+	0x01, 0x30, 0xe7, 0x22,  0x2e, 0x20, 0xb8, 0x0d,  
+	0xba, 0x0b, 0x68, 0x29,  0x9e, 0x29, 0x26, 0x18,  
+	0x8c, 0x29, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0x9e, 0x29,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xb8, 0x0e, 0x38, 0x08,  
+	0xa3, 0x1e, 0xe7, 0x22,  0x2e, 0x20, 0x38, 0x08,  
+	0x83, 0x16, 0x98, 0x00,  0x83, 0x12, 0xb8, 0x0e,  
+	0x38, 0x08, 0xa3, 0x1e,  0xe7, 0x22, 0x2e, 0x20,  
+	0xb6, 0x0b, 0x62, 0x29,  0xb7, 0x0b, 0x62, 0x29,  
+	0xa3, 0x1a, 0xaa, 0x29,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0xe7, 0x22,  0xc4, 0x0b, 0xa6, 0x29,  
+	0x10, 0x30, 0xc4, 0x00,  0xc5, 0x01, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x18,  0x45, 0x14, 0xbd, 0x0d,  
+	0xbe, 0x0d, 0x03, 0x18,  0xc5, 0x14, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x18,  0x45, 0x15, 0xc1, 0x0d,  
+	0xc2, 0x0d, 0x03, 0x18,  0xc5, 0x15, 0x26, 0x18,  
+	0xc5, 0x0e, 0x45, 0x08,  0x83, 0x16, 0x98, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0xc4, 0x0b, 0xac, 0x29,  
+	0x83, 0x16, 0xff, 0x30,  0x98, 0x00, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0xff, 0x30, 0x99, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0x2e, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0xd7, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x2e, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0xde, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xe5, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0x10, 0x1c, 0xec, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0x18, 0x23, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xf2, 0x29, 0x83, 0x12,  0x2e, 0x20, 0x2e, 0x20,  
+	0x2e, 0x20, 0x1c, 0x28,  0x24, 0x18, 0x01, 0x2a,  
+	0x21, 0x22, 0x2e, 0x20,  0xfc, 0x29, 0x21, 0x22,  
+	0x2e, 0x20, 0x24, 0x18,  0x01, 0x2a, 0x24, 0x1d,  
+	0x0b, 0x2a, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x1c, 0x28, 0x24, 0x15,  0x01, 0x30, 0x18, 0x23,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xcf, 0x0b,  0x14, 0x2a, 0x28, 0x08,  
+	0x18, 0x23, 0x23, 0x1a,  0xfc, 0x29, 0x2e, 0x20,  
+	0x2e, 0x20, 0x2e, 0x20,  0x1c, 0x28, 0x24, 0x18,  
+	0x32, 0x2a, 0x83, 0x16,  0x10, 0x18, 0x30, 0x2a,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0x18, 0x23, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x23, 0x19, 0x4d, 0x2a,  0x83, 0x16, 0x03, 0x10,  
+	0x10, 0x18, 0x03, 0x14,  0xa1, 0x0d, 0x03, 0x01,  
+	0x10, 0x18, 0x01, 0x30,  0x83, 0x12, 0xa3, 0x1a,  
+	0x41, 0x2a, 0xa4, 0x18,  0xe7, 0x22, 0xb9, 0x0a,  
+	0xb9, 0x1d, 0x08, 0x00,  0x83, 0x16, 0x21, 0x08,  
+	0x83, 0x12, 0x13, 0x23,  0xb9, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0x73, 0x2a, 0x39, 0x19,  
+	0x62, 0x2a, 0x83, 0x16,  0xa1, 0x01, 0x90, 0x19,  
+	0xa1, 0x15, 0x10, 0x19,  0x21, 0x15, 0x90, 0x18,  
+	0xa1, 0x14, 0x10, 0x18,  0x21, 0x14, 0x21, 0x08,  
+	0xa1, 0x0e, 0x83, 0x12,  0x39, 0x15, 0xa3, 0x1a,  
+	0x08, 0x00, 0xa4, 0x18,  0xe7, 0x22, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x19,  0xa1, 0x15, 0x10, 0x19,  
+	0x21, 0x15, 0x90, 0x18,  0xa1, 0x14, 0x10, 0x18,  
+	0x21, 0x14, 0x21, 0x08,  0x83, 0x12, 0x13, 0x23,  
+	0xa3, 0x1a, 0x73, 0x2a,  0xa4, 0x18, 0xe7, 0x22,  
+	0xb9, 0x01, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x81, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x23, 0x1d,  0x02, 0x30, 0xb6, 0x00,  
+	0x01, 0x30, 0xb7, 0x00,  0x08, 0x00, 0x24, 0x10,  
+	0x23, 0x12, 0xa3, 0x1a,  0xe4, 0x2a, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0xe7, 0x22, 0xc4, 0x0b,  
+	0x87, 0x2a, 0x23, 0x19,  0x92, 0x2a, 0x3c, 0x08,  
+	0x13, 0x23, 0x3b, 0x08,  0x18, 0x23, 0x08, 0x00,  
+	0x04, 0x08, 0xe7, 0x00,  0x47, 0x30, 0x84, 0x00,  
+	0x08, 0x30, 0xc4, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x98, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x04, 0x30, 0xc4, 0x00,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x17, 0xc2, 0x0d,  0x03, 0x18, 0x80, 0x15,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x17, 0xc0, 0x0d,  
+	0x03, 0x18, 0x00, 0x15,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x16, 0xbe, 0x0d,  0x03, 0x18, 0x80, 0x14,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x16, 0xbc, 0x0d,  
+	0x03, 0x18, 0x00, 0x14,  0x84, 0x0a, 0xc4, 0x0b,  
+	0xa0, 0x2a, 0x04, 0x30,  0xc4, 0x00, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc1, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xbf, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbd, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbb, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0xbd, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x07, 0x30, 0xc4, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xc4, 0x0b,  0xdc, 0x2a, 0x00, 0x08,  
+	0x18, 0x23, 0x08, 0x00,  0x03, 0x01, 0x18, 0x23,  
+	0x08, 0x00, 0xc3, 0x00,  0xc3, 0x0c, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x1c,  0xf1, 0x2a, 0x21, 0x30,  
+	0xbb, 0x06, 0x10, 0x30,  0xbc, 0x06, 0x23, 0x1d,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0xfc, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x05, 0x2b, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x0f, 0x2b, 0x0f, 0x08,  
+	0x08, 0x00, 0x8c, 0x1b,  0x13, 0x2b, 0x8e, 0x01,  
+	0x8d, 0x00, 0x08, 0x00,  0x8c, 0x1b, 0x18, 0x2b,  
+	0x8e, 0x0a, 0x8d, 0x00,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0x20, 0x2b,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0x28, 0x2b,  
+	0x08, 0x00
+};
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0_9210.h b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0_9210.h
new file mode 100644
index 0000000..540583e
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio0_9210.h
@@ -0,0 +1,197 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio_9210.h
+ * Structure     : fim_sdio_firmware0
+ */
+
+static const unsigned char fim_sdio_firmware0[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0xbf, 0x02, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x01, 0x30, 0x98, 0x00,  0xad, 0x22, 0x83, 0x16,  
+	0x99, 0x01, 0x19, 0x15,  0x19, 0x14, 0x83, 0x12,  
+	0x17, 0x28, 0xa4, 0x01,  0xbb, 0x01, 0xbc, 0x01,  
+	0xbd, 0x01, 0xbe, 0x01,  0xbf, 0x01, 0xc0, 0x01,  
+	0xc1, 0x01, 0xc2, 0x01,  0x83, 0x16, 0xa1, 0x01,  
+	0x83, 0x12, 0xb9, 0x01,  0x8c, 0x1d, 0x37, 0x28,  
+	0x28, 0x20, 0x17, 0x28,  0x83, 0x16, 0x98, 0x14,  
+	0x83, 0x12, 0x10, 0x08,  0xac, 0x00, 0xac, 0x0b,  
+	0x2d, 0x28, 0x83, 0x16,  0x98, 0x10, 0x83, 0x12,  
+	0x10, 0x08, 0xac, 0x00,  0xac, 0x0b, 0x34, 0x28,  
+	0x08, 0x00, 0x83, 0x16,  0x19, 0x11, 0x83, 0x12,  
+	0xa7, 0x01, 0x93, 0x22,  0xa3, 0x00, 0x93, 0x22,  
+	0xb5, 0x00, 0x93, 0x22,  0xb4, 0x00, 0xff, 0x39,  
+	0x03, 0x19, 0x47, 0x28,  0x35, 0x08, 0x01, 0x3e,  
+	0xb5, 0x00, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x75, 0x20,  
+	0x27, 0x08, 0x5c, 0x20,  0x83, 0x16, 0x19, 0x15,  
+	0x83, 0x12, 0x23, 0x18,  0x82, 0x28, 0xa3, 0x18,  
+	0x82, 0x28, 0x2d, 0x29,  0xaa, 0x00, 0x08, 0x30,  
+	0xad, 0x00, 0xaa, 0x0d,  0x83, 0x16, 0x03, 0x18,  
+	0x65, 0x28, 0x18, 0x11,  0x66, 0x28, 0x18, 0x15,  
+	0x83, 0x12, 0x6c, 0x20,  0x28, 0x20, 0xad, 0x0b,  
+	0x5f, 0x28, 0x08, 0x00,  0xa7, 0x13, 0x03, 0x18,  
+	0xa7, 0x17, 0xa7, 0x0d,  0xa7, 0x1f, 0x08, 0x00,  
+	0x09, 0x30, 0xa7, 0x06,  0x08, 0x00, 0x07, 0x30,  
+	0xa9, 0x00, 0x03, 0x10,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x7d, 0x28, 0x09, 0x30,  0xa7, 0x06, 0xa9, 0x0b,  
+	0x77, 0x28, 0x03, 0x14,  0xa7, 0x0d, 0x08, 0x00,  
+	0x64, 0x30, 0xab, 0x00,  0xb0, 0x01, 0xa7, 0x01,  
+	0xab, 0x0b, 0x89, 0x28,  0x03, 0x29, 0x06, 0x21,  
+	0x03, 0x18, 0x86, 0x28,  0x23, 0x1a, 0xc7, 0x28,  
+	0x01, 0x30, 0xa4, 0x22,  0x03, 0x10, 0x14, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0xa3, 0x18,  0xa9, 0x28, 0x75, 0x20,  
+	0x27, 0x08, 0xa8, 0x00,  0x13, 0x21, 0x9b, 0x22,  
+	0x28, 0x08, 0xa3, 0x19,  0xa7, 0x28, 0xa4, 0x22,  
+	0x2d, 0x29, 0x9b, 0x22,  0x2d, 0x29, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x9b, 0x22,  0x28, 0x08, 0xa4, 0x22,  
+	0x2d, 0x29, 0x50, 0x30,  0x84, 0x00, 0x14, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0xa3, 0x1c, 0xfb, 0x28,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x80, 0x00,  0x24, 0x18, 0xac, 0x29,  
+	0xbb, 0x29, 0x04, 0x30,  0xa4, 0x22, 0x17, 0x28,  
+	0x23, 0x1a, 0xd1, 0x21,  0x83, 0x16, 0x10, 0x19,  
+	0x0f, 0x29, 0x83, 0x12,  0x28, 0x20, 0x03, 0x10,  
+	0x08, 0x00, 0x83, 0x12,  0x28, 0x20, 0x03, 0x14,  
+	0x08, 0x00, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x30, 0x08,  0x08, 0x00, 0x23, 0x1a,  
+	0xac, 0x29, 0xa3, 0x19,  0x35, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x28, 0x20,  
+	0x28, 0x20, 0xff, 0x30,  0x01, 0x30, 0x83, 0x16,  
+	0x18, 0x14, 0x19, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x93, 0x22, 0xb8, 0x00,  0x08, 0x30, 0xba, 0x00,  
+	0xb8, 0x1b, 0x51, 0x29,  0x83, 0x16, 0x18, 0x10,  
+	0x83, 0x12, 0x00, 0x30,  0x55, 0x29, 0x83, 0x16,  
+	0x18, 0x14, 0x83, 0x12,  0x01, 0x30, 0x6c, 0x22,  
+	0x28, 0x20, 0xb8, 0x0d,  0xba, 0x0b, 0x4a, 0x29,  
+	0x5b, 0x29, 0xb6, 0x0b,  0x46, 0x29, 0xb7, 0x0b,  
+	0x46, 0x29, 0xa3, 0x1a,  0x67, 0x29, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0x6c, 0x22, 0xc4, 0x0b,  
+	0x63, 0x29, 0x10, 0x30,  0xc4, 0x00, 0xc5, 0x01,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x18, 0x72, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x75, 0x29,  
+	0x83, 0x16, 0x18, 0x14,  0x83, 0x12, 0x28, 0x20,  
+	0xc4, 0x0b, 0x69, 0x29,  0x83, 0x16, 0x18, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x19, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x28, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0x87, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x28, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0x8e, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0x95, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x28, 0x20, 0x83, 0x16,  0x10, 0x1c, 0x9c, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0xa4, 0x22, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xa2, 0x29, 0x83, 0x12,  0x28, 0x20, 0x28, 0x20,  
+	0x28, 0x20, 0x17, 0x28,  0x24, 0x18, 0xb1, 0x29,  
+	0xd1, 0x21, 0x28, 0x20,  0xac, 0x29, 0xd1, 0x21,  
+	0x28, 0x20, 0x24, 0x18,  0xb1, 0x29, 0x24, 0x1d,  
+	0xbb, 0x29, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x17, 0x28, 0x24, 0x15,  0x01, 0x30, 0xa4, 0x22,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x9b, 0x22,  
+	0x84, 0x0a, 0xcf, 0x0b,  0xc4, 0x29, 0x28, 0x08,  
+	0xa4, 0x22, 0x23, 0x1a,  0xac, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x24, 0x18,  
+	0xe2, 0x29, 0x83, 0x16,  0x10, 0x18, 0xe0, 0x29,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0xa4, 0x22, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x83, 0x16, 0x03, 0x10,  0x10, 0x18, 0x03, 0x14,  
+	0xa1, 0x0d, 0x03, 0x01,  0x10, 0x18, 0x01, 0x30,  
+	0x83, 0x12, 0xa3, 0x1a,  0xef, 0x29, 0xa4, 0x18,  
+	0x6c, 0x22, 0xb9, 0x0a,  0xb9, 0x1d, 0x08, 0x00,  
+	0x83, 0x16, 0x21, 0x08,  0x83, 0x12, 0x9b, 0x22,  
+	0xb9, 0x01, 0x83, 0x16,  0xa1, 0x01, 0x83, 0x12,  
+	0xfb, 0x29, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x08, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x02, 0x30,  0xb6, 0x00, 0x01, 0x30,  
+	0xb7, 0x00, 0x08, 0x00,  0x24, 0x10, 0x23, 0x12,  
+	0xa3, 0x1a, 0x69, 0x2a,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0x6c, 0x22,  0xc4, 0x0b, 0x0e, 0x2a,  
+	0x3c, 0x08, 0x9b, 0x22,  0x3b, 0x08, 0xa4, 0x22,  
+	0x08, 0x00, 0x04, 0x08,  0xe7, 0x00, 0x47, 0x30,  
+	0x84, 0x00, 0x08, 0x30,  0xc4, 0x00, 0x80, 0x01,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x1d, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x04, 0x30,  0xc4, 0x00, 0xc2, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xc0, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbe, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbc, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x25, 0x2a,  0x04, 0x30, 0xc4, 0x00,  
+	0xc1, 0x0d, 0x03, 0x18,  0x80, 0x17, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x15,  0xbf, 0x0d, 0x03, 0x18,  
+	0x00, 0x17, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x15,  
+	0xbd, 0x0d, 0x03, 0x18,  0x80, 0x16, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x14,  0xbb, 0x0d, 0x03, 0x18,  
+	0x00, 0x16, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x14,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x42, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x07, 0x30,  0xc4, 0x00, 0x00, 0x08,  
+	0x9b, 0x22, 0x84, 0x0a,  0xc4, 0x0b, 0x61, 0x2a,  
+	0x00, 0x08, 0xa4, 0x22,  0x08, 0x00, 0x03, 0x01,  
+	0xa4, 0x22, 0x08, 0x00,  0xc3, 0x00, 0xc3, 0x0c,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x1c, 0x76, 0x2a,  
+	0x21, 0x30, 0xbb, 0x06,  0x10, 0x30, 0xbc, 0x06,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0x80, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x89, 0x2a, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x93, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x0f, 0x08,  0x00, 0x00, 0x8b, 0x17,  
+	0x08, 0x00, 0x8c, 0x1b,  0x9b, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x8e, 0x01,  0x8d, 0x00, 0x00, 0x00,  
+	0x8b, 0x17, 0x08, 0x00,  0x8c, 0x1b, 0xa4, 0x2a,  
+	0x8b, 0x13, 0x00, 0x00,  0x8e, 0x0a, 0x8d, 0x00,  
+	0x00, 0x00, 0x8b, 0x17,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0xb0, 0x2a,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0xb8, 0x2a,  
+	0x08, 0x00
+};
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1.h b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1.h
new file mode 100644
index 0000000..7f73a0c
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1.h
@@ -0,0 +1,225 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio.h
+ * Structure     : fim_sdio_firmware1
+ */
+
+static const unsigned char fim_sdio_firmware1[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x2f, 0x03, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x1d, 0x23, 0x83, 0x12,  0x9f, 0x01, 0x9f, 0x15,  
+	0x83, 0x16, 0xff, 0x30,  0x99, 0x00, 0x83, 0x12,  
+	0x83, 0x12, 0x15, 0x1c,  0x16, 0x28, 0x01, 0x30,  
+	0xa6, 0x00, 0x1c, 0x28,  0xa4, 0x01, 0xbb, 0x01,  
+	0xbc, 0x01, 0xbd, 0x01,  0xbe, 0x01, 0xbf, 0x01,  
+	0xc0, 0x01, 0xc1, 0x01,  0xc2, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0xb9, 0x01, 0x3d, 0x20,  
+	0x8c, 0x1d, 0x54, 0x28,  0x2e, 0x20, 0x1c, 0x28,  
+	0x83, 0x16, 0x1a, 0x15,  0x83, 0x12, 0x10, 0x08,  
+	0xac, 0x00, 0xac, 0x0b,  0x33, 0x28, 0x83, 0x16,  
+	0x1a, 0x11, 0x83, 0x12,  0x10, 0x08, 0xac, 0x00,  
+	0xac, 0x0b, 0x3a, 0x28,  0x08, 0x00, 0x22, 0x1c,  
+	0x48, 0x28, 0x83, 0x16,  0x89, 0x1f, 0x46, 0x28,  
+	0x83, 0x12, 0x89, 0x01,  0x22, 0x10, 0x08, 0x00,  
+	0x83, 0x12, 0x08, 0x00,  0x11, 0x1c, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1e,  0x4f, 0x28, 0x83, 0x12,  
+	0x08, 0x00, 0x83, 0x12,  0x22, 0x14, 0x01, 0x30,  
+	0x89, 0x00, 0x08, 0x00,  0x9f, 0x11, 0xa7, 0x01,  
+	0x0f, 0x23, 0xa3, 0x00,  0x0f, 0x23, 0xb5, 0x00,  
+	0x0f, 0x23, 0xb4, 0x00,  0xff, 0x39, 0x03, 0x19,  
+	0x62, 0x28, 0x35, 0x08,  0x01, 0x3e, 0xb5, 0x00,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x8e, 0x20, 0x27, 0x08,  
+	0x75, 0x20, 0x9f, 0x15,  0x23, 0x18, 0x9b, 0x28,  
+	0xa3, 0x18, 0x9b, 0x28,  0x46, 0x29, 0xaa, 0x00,  
+	0x08, 0x30, 0xad, 0x00,  0xaa, 0x0d, 0x83, 0x16,  
+	0x03, 0x18, 0x7e, 0x28,  0x9a, 0x11, 0x7f, 0x28,  
+	0x9a, 0x15, 0x83, 0x12,  0x85, 0x20, 0x2e, 0x20,  
+	0xad, 0x0b, 0x78, 0x28,  0x08, 0x00, 0xa7, 0x13,  
+	0x03, 0x18, 0xa7, 0x17,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x08, 0x00, 0x09, 0x30,  0xa7, 0x06, 0x08, 0x00,  
+	0x07, 0x30, 0xa9, 0x00,  0x03, 0x10, 0xa7, 0x0d,  
+	0xa7, 0x1f, 0x96, 0x28,  0x09, 0x30, 0xa7, 0x06,  
+	0xa9, 0x0b, 0x90, 0x28,  0x03, 0x14, 0xa7, 0x0d,  
+	0x08, 0x00, 0x64, 0x30,  0xab, 0x00, 0xb0, 0x01,  
+	0xa7, 0x01, 0xab, 0x0b,  0xa2, 0x28, 0x1c, 0x29,  
+	0x1f, 0x21, 0x03, 0x18,  0x9f, 0x28, 0x23, 0x1a,  
+	0xe0, 0x28, 0x01, 0x30,  0x18, 0x23, 0x03, 0x10,  
+	0x2d, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0xa3, 0x18, 0xc2, 0x28,  
+	0x8e, 0x20, 0x27, 0x08,  0xa8, 0x00, 0x2c, 0x21,  
+	0x13, 0x23, 0x28, 0x08,  0xa3, 0x19, 0xc0, 0x28,  
+	0x18, 0x23, 0x46, 0x29,  0x13, 0x23, 0x46, 0x29,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x13, 0x23, 0x28, 0x08,  
+	0x18, 0x23, 0x46, 0x29,  0x50, 0x30, 0x84, 0x00,  
+	0x2d, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0xa3, 0x1c,  
+	0x14, 0x29, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x80, 0x00, 0x24, 0x18,  
+	0xfc, 0x29, 0x0b, 0x2a,  0x04, 0x30, 0x18, 0x23,  
+	0x1c, 0x28, 0x23, 0x1a,  0x21, 0x22, 0x83, 0x16,  
+	0x92, 0x19, 0x28, 0x29,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x10, 0x08, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x14, 0x08, 0x00,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x30, 0x08, 0x08, 0x00,  
+	0x23, 0x1a, 0xfc, 0x29,  0xa3, 0x19, 0x4f, 0x29,  
+	0x2e, 0x20, 0x2e, 0x20,  0x2e, 0x20, 0x3d, 0x20,  
+	0x1c, 0x28, 0x2e, 0x20,  0x2e, 0x20, 0xff, 0x30,  
+	0x23, 0x1d, 0x11, 0x30,  0x83, 0x16, 0x98, 0x00,  
+	0xff, 0x3a, 0x99, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x83, 0x16, 0x98, 0x01,  0x83, 0x12, 0x2e, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x0f, 0x23, 0xb8, 0x00,  0x23, 0x19, 0x79, 0x29,  
+	0x08, 0x30, 0xba, 0x00,  0xb8, 0x1b, 0x6f, 0x29,  
+	0x83, 0x16, 0x18, 0x12,  0x83, 0x12, 0x00, 0x30,  
+	0x73, 0x29, 0x83, 0x16,  0x18, 0x16, 0x83, 0x12,  
+	0x01, 0x30, 0xe7, 0x22,  0x2e, 0x20, 0xb8, 0x0d,  
+	0xba, 0x0b, 0x68, 0x29,  0x9e, 0x29, 0x26, 0x18,  
+	0x8c, 0x29, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0x9e, 0x29,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xb8, 0x0e, 0x38, 0x08,  
+	0xa3, 0x1e, 0xe7, 0x22,  0x2e, 0x20, 0x38, 0x08,  
+	0x83, 0x16, 0x98, 0x00,  0x83, 0x12, 0xb8, 0x0e,  
+	0x38, 0x08, 0xa3, 0x1e,  0xe7, 0x22, 0x2e, 0x20,  
+	0xb6, 0x0b, 0x62, 0x29,  0xb7, 0x0b, 0x62, 0x29,  
+	0xa3, 0x1a, 0xaa, 0x29,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0xe7, 0x22,  0xc4, 0x0b, 0xa6, 0x29,  
+	0x10, 0x30, 0xc4, 0x00,  0xc5, 0x01, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x18,  0x45, 0x14, 0xbd, 0x0d,  
+	0xbe, 0x0d, 0x03, 0x18,  0xc5, 0x14, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x18,  0x45, 0x15, 0xc1, 0x0d,  
+	0xc2, 0x0d, 0x03, 0x18,  0xc5, 0x15, 0x26, 0x18,  
+	0xc5, 0x0e, 0x45, 0x08,  0x83, 0x16, 0x98, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0xc4, 0x0b, 0xac, 0x29,  
+	0x83, 0x16, 0xff, 0x30,  0x98, 0x00, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0xff, 0x30, 0x99, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0x2e, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1e,  0xd7, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x2e, 0x20, 0x83, 0x16,  
+	0x10, 0x1e, 0xde, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1e,  
+	0xe5, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0x10, 0x1e, 0xec, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0x18, 0x23, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1e,  
+	0xf2, 0x29, 0x83, 0x12,  0x2e, 0x20, 0x2e, 0x20,  
+	0x2e, 0x20, 0x1c, 0x28,  0x24, 0x18, 0x01, 0x2a,  
+	0x21, 0x22, 0x2e, 0x20,  0xfc, 0x29, 0x21, 0x22,  
+	0x2e, 0x20, 0x24, 0x18,  0x01, 0x2a, 0x24, 0x1d,  
+	0x0b, 0x2a, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x1c, 0x28, 0x24, 0x15,  0x01, 0x30, 0x18, 0x23,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xcf, 0x0b,  0x14, 0x2a, 0x28, 0x08,  
+	0x18, 0x23, 0x23, 0x1a,  0xfc, 0x29, 0x2e, 0x20,  
+	0x2e, 0x20, 0x2e, 0x20,  0x1c, 0x28, 0x24, 0x18,  
+	0x32, 0x2a, 0x83, 0x16,  0x10, 0x1a, 0x30, 0x2a,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0x18, 0x23, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x23, 0x19, 0x4d, 0x2a,  0x83, 0x16, 0x03, 0x10,  
+	0x10, 0x1a, 0x03, 0x14,  0xa1, 0x0d, 0x03, 0x01,  
+	0x10, 0x1a, 0x01, 0x30,  0x83, 0x12, 0xa3, 0x1a,  
+	0x41, 0x2a, 0xa4, 0x18,  0xe7, 0x22, 0xb9, 0x0a,  
+	0xb9, 0x1d, 0x08, 0x00,  0x83, 0x16, 0x21, 0x08,  
+	0x83, 0x12, 0x13, 0x23,  0xb9, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0x73, 0x2a, 0x39, 0x19,  
+	0x62, 0x2a, 0x83, 0x16,  0xa1, 0x01, 0x90, 0x1b,  
+	0xa1, 0x15, 0x10, 0x1b,  0x21, 0x15, 0x90, 0x1a,  
+	0xa1, 0x14, 0x10, 0x1a,  0x21, 0x14, 0x21, 0x08,  
+	0xa1, 0x0e, 0x83, 0x12,  0x39, 0x15, 0xa3, 0x1a,  
+	0x08, 0x00, 0xa4, 0x18,  0xe7, 0x22, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1b,  0xa1, 0x15, 0x10, 0x1b,  
+	0x21, 0x15, 0x90, 0x1a,  0xa1, 0x14, 0x10, 0x1a,  
+	0x21, 0x14, 0x21, 0x08,  0x83, 0x12, 0x13, 0x23,  
+	0xa3, 0x1a, 0x73, 0x2a,  0xa4, 0x18, 0xe7, 0x22,  
+	0xb9, 0x01, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x81, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x23, 0x1d,  0x02, 0x30, 0xb6, 0x00,  
+	0x01, 0x30, 0xb7, 0x00,  0x08, 0x00, 0x24, 0x10,  
+	0x23, 0x12, 0xa3, 0x1a,  0xe4, 0x2a, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0xe7, 0x22, 0xc4, 0x0b,  
+	0x87, 0x2a, 0x23, 0x19,  0x92, 0x2a, 0x3c, 0x08,  
+	0x13, 0x23, 0x3b, 0x08,  0x18, 0x23, 0x08, 0x00,  
+	0x04, 0x08, 0xe7, 0x00,  0x47, 0x30, 0x84, 0x00,  
+	0x08, 0x30, 0xc4, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x98, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x04, 0x30, 0xc4, 0x00,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x17, 0xc2, 0x0d,  0x03, 0x18, 0x80, 0x15,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x17, 0xc0, 0x0d,  
+	0x03, 0x18, 0x00, 0x15,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x16, 0xbe, 0x0d,  0x03, 0x18, 0x80, 0x14,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x16, 0xbc, 0x0d,  
+	0x03, 0x18, 0x00, 0x14,  0x84, 0x0a, 0xc4, 0x0b,  
+	0xa0, 0x2a, 0x04, 0x30,  0xc4, 0x00, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc1, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xbf, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbd, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbb, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0xbd, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x07, 0x30, 0xc4, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xc4, 0x0b,  0xdc, 0x2a, 0x00, 0x08,  
+	0x18, 0x23, 0x08, 0x00,  0x03, 0x01, 0x18, 0x23,  
+	0x08, 0x00, 0xc3, 0x00,  0xc3, 0x0c, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x1c,  0xf1, 0x2a, 0x21, 0x30,  
+	0xbb, 0x06, 0x10, 0x30,  0xbc, 0x06, 0x23, 0x1d,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0xfc, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x05, 0x2b, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x0f, 0x2b, 0x0f, 0x08,  
+	0x08, 0x00, 0x8c, 0x1b,  0x13, 0x2b, 0x8e, 0x01,  
+	0x8d, 0x00, 0x08, 0x00,  0x8c, 0x1b, 0x18, 0x2b,  
+	0x8e, 0x0a, 0x8d, 0x00,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0x20, 0x2b,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0x28, 0x2b,  
+	0x08, 0x00
+};
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1_9210.h b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1_9210.h
new file mode 100644
index 0000000..cfb9206
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_sdio1_9210.h
@@ -0,0 +1,197 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio_9210.h
+ * Structure     : fim_sdio_firmware1
+ */
+
+static const unsigned char fim_sdio_firmware1[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0xbf, 0x02, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x01, 0x30, 0x98, 0x00,  0xad, 0x22, 0x83, 0x16,  
+	0x99, 0x01, 0x19, 0x15,  0x19, 0x14, 0x83, 0x12,  
+	0x17, 0x28, 0xa4, 0x01,  0xbb, 0x01, 0xbc, 0x01,  
+	0xbd, 0x01, 0xbe, 0x01,  0xbf, 0x01, 0xc0, 0x01,  
+	0xc1, 0x01, 0xc2, 0x01,  0x83, 0x16, 0xa1, 0x01,  
+	0x83, 0x12, 0xb9, 0x01,  0x8c, 0x1d, 0x37, 0x28,  
+	0x28, 0x20, 0x17, 0x28,  0x83, 0x16, 0x98, 0x14,  
+	0x83, 0x12, 0x10, 0x08,  0xac, 0x00, 0xac, 0x0b,  
+	0x2d, 0x28, 0x83, 0x16,  0x98, 0x10, 0x83, 0x12,  
+	0x10, 0x08, 0xac, 0x00,  0xac, 0x0b, 0x34, 0x28,  
+	0x08, 0x00, 0x83, 0x16,  0x19, 0x11, 0x83, 0x12,  
+	0xa7, 0x01, 0x93, 0x22,  0xa3, 0x00, 0x93, 0x22,  
+	0xb5, 0x00, 0x93, 0x22,  0xb4, 0x00, 0xff, 0x39,  
+	0x03, 0x19, 0x47, 0x28,  0x35, 0x08, 0x01, 0x3e,  
+	0xb5, 0x00, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x75, 0x20,  
+	0x27, 0x08, 0x5c, 0x20,  0x83, 0x16, 0x19, 0x15,  
+	0x83, 0x12, 0x23, 0x18,  0x82, 0x28, 0xa3, 0x18,  
+	0x82, 0x28, 0x2d, 0x29,  0xaa, 0x00, 0x08, 0x30,  
+	0xad, 0x00, 0xaa, 0x0d,  0x83, 0x16, 0x03, 0x18,  
+	0x65, 0x28, 0x18, 0x11,  0x66, 0x28, 0x18, 0x15,  
+	0x83, 0x12, 0x6c, 0x20,  0x28, 0x20, 0xad, 0x0b,  
+	0x5f, 0x28, 0x08, 0x00,  0xa7, 0x13, 0x03, 0x18,  
+	0xa7, 0x17, 0xa7, 0x0d,  0xa7, 0x1f, 0x08, 0x00,  
+	0x09, 0x30, 0xa7, 0x06,  0x08, 0x00, 0x07, 0x30,  
+	0xa9, 0x00, 0x03, 0x10,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x7d, 0x28, 0x09, 0x30,  0xa7, 0x06, 0xa9, 0x0b,  
+	0x77, 0x28, 0x03, 0x14,  0xa7, 0x0d, 0x08, 0x00,  
+	0x64, 0x30, 0xab, 0x00,  0xb0, 0x01, 0xa7, 0x01,  
+	0xab, 0x0b, 0x89, 0x28,  0x03, 0x29, 0x06, 0x21,  
+	0x03, 0x18, 0x86, 0x28,  0x23, 0x1a, 0xc7, 0x28,  
+	0x01, 0x30, 0xa4, 0x22,  0x03, 0x10, 0x14, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0xa3, 0x18,  0xa9, 0x28, 0x75, 0x20,  
+	0x27, 0x08, 0xa8, 0x00,  0x13, 0x21, 0x9b, 0x22,  
+	0x28, 0x08, 0xa3, 0x19,  0xa7, 0x28, 0xa4, 0x22,  
+	0x2d, 0x29, 0x9b, 0x22,  0x2d, 0x29, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x9b, 0x22,  0x28, 0x08, 0xa4, 0x22,  
+	0x2d, 0x29, 0x50, 0x30,  0x84, 0x00, 0x14, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0xa3, 0x1c, 0xfb, 0x28,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x80, 0x00,  0x24, 0x18, 0xac, 0x29,  
+	0xbb, 0x29, 0x04, 0x30,  0xa4, 0x22, 0x17, 0x28,  
+	0x23, 0x1a, 0xd1, 0x21,  0x83, 0x16, 0x10, 0x19,  
+	0x0f, 0x29, 0x83, 0x12,  0x28, 0x20, 0x03, 0x10,  
+	0x08, 0x00, 0x83, 0x12,  0x28, 0x20, 0x03, 0x14,  
+	0x08, 0x00, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x30, 0x08,  0x08, 0x00, 0x23, 0x1a,  
+	0xac, 0x29, 0xa3, 0x19,  0x35, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x28, 0x20,  
+	0x28, 0x20, 0xff, 0x30,  0x01, 0x30, 0x83, 0x16,  
+	0x18, 0x14, 0x19, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x93, 0x22, 0xb8, 0x00,  0x08, 0x30, 0xba, 0x00,  
+	0xb8, 0x1b, 0x51, 0x29,  0x83, 0x16, 0x18, 0x10,  
+	0x83, 0x12, 0x00, 0x30,  0x55, 0x29, 0x83, 0x16,  
+	0x18, 0x14, 0x83, 0x12,  0x01, 0x30, 0x6c, 0x22,  
+	0x28, 0x20, 0xb8, 0x0d,  0xba, 0x0b, 0x4a, 0x29,  
+	0x5b, 0x29, 0xb6, 0x0b,  0x46, 0x29, 0xb7, 0x0b,  
+	0x46, 0x29, 0xa3, 0x1a,  0x67, 0x29, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0x6c, 0x22, 0xc4, 0x0b,  
+	0x63, 0x29, 0x10, 0x30,  0xc4, 0x00, 0xc5, 0x01,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x18, 0x72, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x75, 0x29,  
+	0x83, 0x16, 0x18, 0x14,  0x83, 0x12, 0x28, 0x20,  
+	0xc4, 0x0b, 0x69, 0x29,  0x83, 0x16, 0x18, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x19, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x28, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0x87, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x28, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0x8e, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0x95, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x28, 0x20, 0x83, 0x16,  0x10, 0x1c, 0x9c, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0xa4, 0x22, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xa2, 0x29, 0x83, 0x12,  0x28, 0x20, 0x28, 0x20,  
+	0x28, 0x20, 0x17, 0x28,  0x24, 0x18, 0xb1, 0x29,  
+	0xd1, 0x21, 0x28, 0x20,  0xac, 0x29, 0xd1, 0x21,  
+	0x28, 0x20, 0x24, 0x18,  0xb1, 0x29, 0x24, 0x1d,  
+	0xbb, 0x29, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x17, 0x28, 0x24, 0x15,  0x01, 0x30, 0xa4, 0x22,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x9b, 0x22,  
+	0x84, 0x0a, 0xcf, 0x0b,  0xc4, 0x29, 0x28, 0x08,  
+	0xa4, 0x22, 0x23, 0x1a,  0xac, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x24, 0x18,  
+	0xe2, 0x29, 0x83, 0x16,  0x10, 0x18, 0xe0, 0x29,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0xa4, 0x22, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x83, 0x16, 0x03, 0x10,  0x10, 0x18, 0x03, 0x14,  
+	0xa1, 0x0d, 0x03, 0x01,  0x10, 0x18, 0x01, 0x30,  
+	0x83, 0x12, 0xa3, 0x1a,  0xef, 0x29, 0xa4, 0x18,  
+	0x6c, 0x22, 0xb9, 0x0a,  0xb9, 0x1d, 0x08, 0x00,  
+	0x83, 0x16, 0x21, 0x08,  0x83, 0x12, 0x9b, 0x22,  
+	0xb9, 0x01, 0x83, 0x16,  0xa1, 0x01, 0x83, 0x12,  
+	0xfb, 0x29, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x08, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x02, 0x30,  0xb6, 0x00, 0x01, 0x30,  
+	0xb7, 0x00, 0x08, 0x00,  0x24, 0x10, 0x23, 0x12,  
+	0xa3, 0x1a, 0x69, 0x2a,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0x6c, 0x22,  0xc4, 0x0b, 0x0e, 0x2a,  
+	0x3c, 0x08, 0x9b, 0x22,  0x3b, 0x08, 0xa4, 0x22,  
+	0x08, 0x00, 0x04, 0x08,  0xe7, 0x00, 0x47, 0x30,  
+	0x84, 0x00, 0x08, 0x30,  0xc4, 0x00, 0x80, 0x01,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x1d, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x04, 0x30,  0xc4, 0x00, 0xc2, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xc0, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbe, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbc, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x25, 0x2a,  0x04, 0x30, 0xc4, 0x00,  
+	0xc1, 0x0d, 0x03, 0x18,  0x80, 0x17, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x15,  0xbf, 0x0d, 0x03, 0x18,  
+	0x00, 0x17, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x15,  
+	0xbd, 0x0d, 0x03, 0x18,  0x80, 0x16, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x14,  0xbb, 0x0d, 0x03, 0x18,  
+	0x00, 0x16, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x14,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x42, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x07, 0x30,  0xc4, 0x00, 0x00, 0x08,  
+	0x9b, 0x22, 0x84, 0x0a,  0xc4, 0x0b, 0x61, 0x2a,  
+	0x00, 0x08, 0xa4, 0x22,  0x08, 0x00, 0x03, 0x01,  
+	0xa4, 0x22, 0x08, 0x00,  0xc3, 0x00, 0xc3, 0x0c,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x1c, 0x76, 0x2a,  
+	0x21, 0x30, 0xbb, 0x06,  0x10, 0x30, 0xbc, 0x06,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0x80, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x89, 0x2a, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x93, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x0f, 0x08,  0x00, 0x00, 0x8b, 0x17,  
+	0x08, 0x00, 0x8c, 0x1b,  0x9b, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x8e, 0x01,  0x8d, 0x00, 0x00, 0x00,  
+	0x8b, 0x17, 0x08, 0x00,  0x8c, 0x1b, 0xa4, 0x2a,  
+	0x8b, 0x13, 0x00, 0x00,  0x8e, 0x0a, 0x8d, 0x00,  
+	0x00, 0x00, 0x8b, 0x17,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0xb0, 0x2a,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0xb8, 0x2a,  
+	0x08, 0x00
+};
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_serial.c b/arch/arm/cpu/arm926ejs/ns921x/fim_serial.c
new file mode 100644
index 0000000..590e40e
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_serial.c
@@ -0,0 +1,279 @@
+/*
+ * cpu/arm926ejs/ns921x/fims/fim_serial.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision$
+ * !Author:     Luis Galdos
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ */
+
+#include <common.h>
+#include <configs/userconfig.h>
+
+#ifdef CONFIG_NS921X_FIM_UART
+
+#include <serial.h>             /* serial_device */
+
+#include <asm/arch/ns921x_sys.h>
+#include <asm/arch/ns921x_hub.h>
+#include <asm/arch/ns921x_gpio.h>
+#include <asm/arch/io.h>  /* gpio_readl */
+#include <asm/arch/ns921x_fim.h>
+
+#include "fim_serial.h"
+
+/* Depending on the processor we have different offset */
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+# define FIM_GPIO_OFFSET	68
+#elif defined(CONFIG_CME9210)
+# define FIM_GPIO_OFFSET	0
+#else
+# error "Invalid platform. Couldn't define FIM_GPIO_OFFSET"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* It must be a constant */
+const static int pic_num = CONFIG_UBOOT_FIM_UART_PIC_NUM;
+static unsigned int secByte = 0;
+
+extern const unsigned char fim_serial_firmware[];
+
+void fim_serial_setbrg( void)
+{
+	unsigned int div, prescale = 1;
+	unsigned long clock;
+	int cnt;
+	unsigned int bit_time;
+
+	clock = ahb_clock_freq();
+	clock = (clock * 4) / gd->baudrate;
+	div = (clock / 256) + 1;
+
+	/* Must round up to next power of 2 (see NET+OS driver) */
+	for (cnt = 1; cnt <= 8; cnt++) {
+		if (div < (unsigned int)(1 << cnt)) {
+			div = 1 << cnt;
+			prescale = cnt - 1;
+			break;
+		}
+	}
+
+	/* The Net+OS driver has another calculation of the bit time */
+	bit_time = (clock / div) - 1;
+
+	/* Set the bit time */
+	fim_set_ctrl_reg(pic_num, 0, bit_time);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_BIT_TIME);
+
+	/* Set the prescale value */
+	fim_set_ctrl_reg(pic_num, 0, prescale);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_PRESCALE);
+}
+
+static int fim_sw_flowctrl(void)
+{
+	unsigned short start_match, stop_match;
+
+	start_match = 1;
+	stop_match = 1;
+
+	fim_set_ctrl_reg(pic_num, 0, 0xff);
+	fim_set_ctrl_reg(pic_num, 1, 0xff);
+	fim_set_ctrl_reg(pic_num, 2, 0xff);
+	fim_set_ctrl_reg(pic_num, 3, 0xff);
+	fim_set_ctrl_reg(pic_num, 4, 0x00);
+	fim_set_ctrl_reg(pic_num, 5, 0x00);
+
+	/* Now send the interrupt for the SW flow control */
+	if(fim_send_interrupt(pic_num, FIM_SERIAL_INT_MATCH_CHAR))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Check if there is new input data to get from the RX-FIFO
+ */
+int fim_serial_tstc(void)
+{
+	unsigned int regval;
+
+	regval = fim_get_iohub_reg(pic_num, HUB_INT);
+
+	return (regval & HUB_INT_RX_FIFO_EMPTY) ? 0 : 1;
+}
+
+int fim_serial_isr(int pic_num)
+{
+	unsigned int regval;
+	int bytes;
+
+	/* Was a second character read before from FIFO */
+	if(secByte) {
+		regval = secByte;
+		secByte = 0;
+
+		return regval;
+	}
+
+	/* If the RX-FIFO is empty then returns */
+	do {
+	  regval = fim_get_iohub_reg(pic_num, HUB_INT);
+	} while (regval & HUB_INT_RX_FIFO_EMPTY);
+
+	regval = fim_get_iohub_reg(pic_num, HUB_RX_FIFO_STAT);
+	bytes = HUB_RX_FIFO_BYTE(regval);
+
+	regval = fim_get_iohub_reg(pic_num, HUB_RX_FIFO);
+	/* The FIM firmware always sends two bytes per data byte:
+	 * - The first byte is the data itself
+	 * - The second byte contains information about the serial
+	 * communication (data bits, parity, stop bits).
+	 * The direct IO HUB FIFO is 32 bits long, this means it
+	 * can buffer 4 bytes. Considering the 1-byte overhead
+	 * described above for each data byte, this means:
+	 * if the 'bytes' field of FIFO stat register contains a
+	 * value of 2, we have 1 data byte. If it contains a
+	 * value of 4, we have 2 data bytes. */
+
+	/* Get the second data byte and skip the FIM overhead byte */
+	if (bytes == 4)
+		secByte = (regval & 0xff0000) >> 16;
+
+	/* Return the first data byte */
+	return regval & 0xFF;
+}
+
+int fim_serial_getc(void)
+{
+	return fim_serial_isr(pic_num);
+}
+
+/*
+ * Send a char over an interrupt
+ */
+void fim_serial_putc( const char ch)
+{
+	unsigned int status;
+	unsigned short data = 1;
+
+	if( '\n' == ch ) {
+		fim_serial_putc('\r');
+	}
+
+	/* Check if the PIC is tasked with another send-char request */
+	do {
+		status = fim_get_exp_reg(pic_num, 0);
+	} while (status & FIM_SERIAL_INT_INSERT_CHAR);
+
+	data = (data << FIM_SERIAL_DATA_BITS) | (ch & ((1 << FIM_SERIAL_DATA_BITS) - 1));
+
+	/* And send the char using the interrupt function */
+	fim_set_ctrl_reg(pic_num, 0, data & 0xFF);
+	fim_set_ctrl_reg(pic_num, 1, (data >> 8) & 0xFF);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_INSERT_CHAR);
+
+}
+
+int fim_serial_init(void)
+{
+	unsigned int regval;
+	printf("Loading serial firmware\n");
+	if(fim_core_init(pic_num, fim_serial_firmware))
+		return 1;
+
+	/* Init the register of the PIC */
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG, 0x00);
+
+	/* Set the GPIOs offset */
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_TXIO_REG,
+			 1 << (FIM_UART_TX - FIM_GPIO_OFFSET));
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_RXIO_REG,
+			 1 << (FIM_UART_RX - FIM_GPIO_OFFSET));
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_BIT_POS);
+
+	fim_set_ctrl_reg(pic_num, 0, 0xFF);
+	fim_set_ctrl_reg(pic_num, 1, 0xFF);
+	fim_set_ctrl_reg(pic_num, 2, 0xFF);
+	fim_set_ctrl_reg(pic_num, 3, 0xFF);
+	fim_set_ctrl_reg(pic_num, 4, 0x00);
+	fim_set_ctrl_reg(pic_num, 5, 0x00);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_MATCH_CHAR);
+
+	/* Configure the GPIOs */
+	gpio_cfg_set(FIM_UART_RX, GPIO_CFG_FUNC_FIM_UART);
+	gpio_cfg_set(FIM_UART_TX, GPIO_CFG_FUNC_FIM_UART);
+
+	fim_set_ctrl_reg(pic_num, 0, FIM_SERIAL_TOTAL_BITS);
+	if(fim_send_interrupt(pic_num, FIM_SERIAL_INT_BITS_CHAR))
+		return 1;
+
+	/* Configure the software flow control */
+	if(fim_sw_flowctrl())
+		return 1;
+
+	/* Now set the control status register to the correct value */
+	regval = fim_get_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG);
+	if(regval < 0)
+		return 1;
+	regval &= ~FIM_SERIAL_STAT_HW_FLOW;
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG, regval);
+
+
+	/* After each reconfiguration we need to re-init the FIM-firmware */
+	regval = fim_get_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG);
+	if(regval < 0)
+		return 1;
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG,
+			 regval | FIM_SERIAL_STAT_TX_ENABLE | FIM_SERIAL_STAT_COMPLETE);
+
+	/* baudrate configure before get lost */
+	fim_serial_setbrg();
+
+	/*
+	 * IMPORTANT: Configure the FIM in direct mode, otherwise the other FIM
+	 * probably doesn't work when it tries to use the DMA-engine!
+	 */
+	fim_set_iohub_reg(pic_num, HUB_DMA_RX_CTRL, HUB_DMA_RX_CTRL_DIRECT);
+	fim_set_iohub_reg(pic_num, HUB_DMA_TX_CTRL, HUB_DMA_TX_CTRL_DIRECT);
+	/* fim_set_iohub_reg(pic_num, HUB_RX_INT, 0x20000000); */
+	/* regval = fim_get_iohub_reg(pic_num, HUB_DMA_RX_CTRL); */
+	/* fim_set_iohub_reg(pic_num, HUB_DMA_RX_CTRL, regval | 0x10000000); */
+
+	return 0;
+}
+
+static void fim_serial_tx_flush( void )
+{
+	/* Dummy */
+}
+
+/**
+ * fim_serial_puts - outputs a zero terminated string
+ */
+static void fim_serial_puts( const char* szMsg )
+{
+	while( *szMsg )
+		fim_serial_putc( *szMsg++ );
+}
+
+struct serial_device fim_serial_device = {
+
+	.name     = "fim_serial",
+	.init     = fim_serial_init ,
+	.setbrg   = fim_serial_setbrg,
+	.getc     = fim_serial_getc,
+	.tstc     = fim_serial_tstc,
+	.putc     = fim_serial_putc,
+	.puts     = fim_serial_puts,
+	.tx_flush = fim_serial_tx_flush
+};
+
+#endif  /* CONFIG_NS921X_FIM_UART */
diff --git a/arch/arm/cpu/arm926ejs/ns921x/fim_serial.h b/arch/arm/cpu/arm926ejs/ns921x/fim_serial.h
new file mode 100644
index 0000000..6cf4806
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/fim_serial.h
@@ -0,0 +1,189 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_uart.h
+ * Structure     : fim_serial_firmware
+ */
+
+static const unsigned char fim_serial_firmware[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x16, 0x02, 0x00, 0x00,  0x62, 0x28, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x83, 0x16,
+	0x09, 0x18, 0x19, 0x28,  0x89, 0x18, 0x21, 0x28,
+	0x09, 0x19, 0x2f, 0x28,  0x89, 0x19, 0x33, 0x28,
+	0x09, 0x1a, 0x39, 0x28,  0x89, 0x1a, 0x4f, 0x28,
+	0x09, 0x1b, 0x57, 0x28,  0x18, 0x28, 0x83, 0x12,
+	0x18, 0x14, 0x10, 0x08,  0xc0, 0x00, 0x11, 0x08,
+	0xc1, 0x00, 0x25, 0x14,  0x5b, 0x28, 0x83, 0x12,
+	0x10, 0x08, 0xc2, 0x00,  0x11, 0x08, 0xc3, 0x00,
+	0x12, 0x08, 0xc4, 0x00,  0x13, 0x08, 0xc5, 0x00,
+	0x14, 0x08, 0xc6, 0x00,  0x15, 0x08, 0xc7, 0x00,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xc8, 0x00,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xb5, 0x00,
+	0x11, 0x08, 0xb6, 0x00,  0x5b, 0x28, 0x83, 0x12,
+	0x10, 0x08, 0xbc, 0x00,  0x11, 0x08, 0xbd, 0x00,
+	0x12, 0x08, 0xbe, 0x00,  0x13, 0x08, 0xbf, 0x00,
+	0x3c, 0x08, 0x83, 0x16,  0x98, 0x00, 0x83, 0x12,
+	0xa9, 0x00, 0x3e, 0x08,  0xa9, 0x04, 0x29, 0x08,
+	0xff, 0x3a, 0x83, 0x16,  0x99, 0x00, 0x83, 0x12,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0x07, 0x39,
+	0x83, 0x16, 0x81, 0x00,  0x01, 0x17, 0x83, 0x12,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xc9, 0x00,
+	0x5b, 0x28, 0x89, 0x17,  0xa4, 0x14, 0x21, 0x08,
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,
+	0x8b, 0x17, 0x0b, 0x16,  0x83, 0x16, 0x01, 0x17,
+	0x83, 0x12, 0x04, 0x22,  0x98, 0x01, 0xb0, 0x30,
+	0xb8, 0x00, 0xb9, 0x00,  0xa4, 0x18, 0xf1, 0x21,
+	0x16, 0x1c, 0x6c, 0x28,  0x71, 0x28, 0x7e, 0x20,
+	0x86, 0x28, 0x4e, 0x21,  0x7e, 0x20, 0x4e, 0x21,
+	0x7e, 0x20, 0x4e, 0x21,  0x24, 0x18, 0xe8, 0x21,
+	0xa4, 0x18, 0xf1, 0x21,  0x7e, 0x20, 0x08, 0x00,
+	0x22, 0x1c, 0x82, 0x28,  0xa2, 0x20, 0x08, 0x00,
+	0xa2, 0x19, 0x21, 0x21,  0xfd, 0x20, 0x08, 0x00,
+	0x23, 0x1c, 0x8a, 0x28,  0x79, 0x21, 0x71, 0x28,
+	0x73, 0x20, 0x16, 0x1d,  0x93, 0x28, 0x3f, 0x08,
+	0x83, 0x16, 0x10, 0x05,  0x83, 0x12, 0x03, 0x1d,
+	0x71, 0x28, 0x25, 0x1c,  0x9d, 0x28, 0x40, 0x08,
+	0xaa, 0x00, 0x41, 0x08,  0xb7, 0x00, 0x25, 0x10,
+	0x18, 0x10, 0xc7, 0x21,  0x71, 0x28, 0x96, 0x1c,
+	0x71, 0x28, 0x8c, 0x1d,  0xbf, 0x21, 0x71, 0x28,
+	0x01, 0x08, 0xa8, 0x00,  0x22, 0x1d, 0xab, 0x28,
+	0xa8, 0x1b, 0xab, 0x28,  0xa2, 0x1c, 0xb5, 0x28,
+	0xa2, 0x10, 0x22, 0x11,  0xa8, 0x1b, 0x22, 0x15,
+	0xa2, 0x18, 0x08, 0x00,  0x31, 0x08, 0x28, 0x02,
+	0x03, 0x18, 0xb5, 0x28,  0x08, 0x00, 0x22, 0x11,
+	0xb1, 0x1b, 0x22, 0x15,  0x49, 0x08, 0xb1, 0x07,
+	0x03, 0x1c, 0xbd, 0x28,  0xa2, 0x14, 0x22, 0x1e,
+	0xc1, 0x28, 0x22, 0x12,  0x08, 0x00, 0x03, 0x10,
+	0x3d, 0x08, 0x83, 0x16,  0x10, 0x05, 0x83, 0x12,
+	0x03, 0x19, 0xc9, 0x28,  0x03, 0x14, 0xab, 0x0c,
+	0xad, 0x0b, 0xe1, 0x28,  0x23, 0x18, 0x79, 0x21,
+	0x2b, 0x08, 0xae, 0x00,  0x96, 0x1d, 0xd7, 0x28,
+	0x2b, 0x08, 0x46, 0x05,  0x42, 0x02, 0x03, 0x19,
+	0x26, 0x14, 0x16, 0x1e,  0xde, 0x28, 0x2b, 0x08,
+	0x46, 0x05, 0x44, 0x02,  0x03, 0x19, 0xa6, 0x14,
+	0xab, 0x01, 0x08, 0x30,  0xad, 0x00, 0xac, 0x0b,
+	0x08, 0x00, 0x23, 0x18,  0x79, 0x21, 0xa2, 0x15,
+	0x35, 0x08, 0xb3, 0x00,  0x36, 0x08, 0xb4, 0x00,
+	0x22, 0x10, 0x26, 0x1c,  0xf4, 0x28, 0x26, 0x10,
+	0x2b, 0x08, 0x47, 0x05,  0x43, 0x02, 0x03, 0x19,
+	0xe2, 0x21, 0x08, 0x00,  0xa6, 0x1c, 0x08, 0x00,
+	0xa6, 0x10, 0x2b, 0x08,  0x47, 0x05, 0x45, 0x02,
+	0x03, 0x19, 0xe5, 0x21,  0x08, 0x00, 0x3d, 0x08,
+	0x83, 0x16, 0x10, 0x05,  0x83, 0x12, 0x03, 0x1d,
+	0x20, 0x29, 0x01, 0x08,  0xa8, 0x00, 0x23, 0x18,
+	0x79, 0x21, 0xa2, 0x1d,  0x0a, 0x29, 0x29, 0x21,
+	0xa2, 0x01, 0x22, 0x14,  0x22, 0x16, 0xa8, 0x1b,
+	0x22, 0x15, 0x48, 0x08,  0xac, 0x00, 0xac, 0x19,
+	0x08, 0x30, 0xad, 0x00,  0xab, 0x01, 0x03, 0x10,
+	0x49, 0x0c, 0xa9, 0x00,  0x0a, 0x30, 0x29, 0x02,
+	0x28, 0x07, 0xb1, 0x00,  0x03, 0x1c, 0x1f, 0x29,
+	0xa2, 0x14, 0x08, 0x00,  0x08, 0x00, 0xb3, 0x0b,
+	0x08, 0x00, 0xb4, 0x0b,  0x08, 0x00, 0xa2, 0x11,
+	0x2b, 0x14, 0x29, 0x21,  0x08, 0x00, 0x38, 0x08,
+	0xba, 0x00, 0xba, 0x0a,  0x03, 0x1d, 0x30, 0x29,
+	0xb0, 0x30, 0xba, 0x00,  0x3a, 0x08, 0x39, 0x02,
+	0x03, 0x1d, 0x36, 0x29,  0xdd, 0x21, 0x08, 0x00,
+	0x3a, 0x08, 0xbb, 0x00,  0xbb, 0x0a, 0x03, 0x1d,
+	0x3d, 0x29, 0xb0, 0x30,  0xbb, 0x00, 0x3b, 0x08,
+	0x39, 0x02, 0x03, 0x1d,  0x43, 0x29, 0xdd, 0x21,
+	0x08, 0x00, 0x38, 0x08,  0x84, 0x00, 0x2e, 0x08,
+	0x80, 0x00, 0x3a, 0x08,  0x84, 0x00, 0x2b, 0x08,
+	0x80, 0x00, 0x3b, 0x08,  0xb8, 0x00, 0x08, 0x00,
+	0x8c, 0x1b, 0x74, 0x29,  0x3e, 0x08, 0xff, 0x3a,
+	0x83, 0x16, 0x98, 0x05,  0x83, 0x12, 0x39, 0x08,
+	0x38, 0x02, 0x03, 0x19,  0x08, 0x00, 0x39, 0x08,
+	0x84, 0x00, 0x00, 0x08,  0x39, 0x1c, 0x67, 0x29,
+	0x00, 0x1c, 0x67, 0x29,  0x8b, 0x13, 0x00, 0x00,
+	0x8e, 0x0a, 0x8d, 0x00,  0x00, 0x00, 0x8b, 0x17,
+	0x6e, 0x29, 0x8b, 0x13,  0x00, 0x00, 0x8e, 0x01,
+	0x8d, 0x00, 0x00, 0x00,  0x8b, 0x17, 0x6e, 0x29,
+	0xb9, 0x0a, 0x03, 0x1d,  0x08, 0x00, 0xb0, 0x30,
+	0xb9, 0x00, 0x08, 0x00,  0x3e, 0x08, 0x83, 0x16,
+	0x98, 0x04, 0x83, 0x12,  0x08, 0x00, 0x01, 0x08,
+	0xa7, 0x00, 0x23, 0x1d,  0x82, 0x29, 0xa7, 0x1b,
+	0x82, 0x29, 0xa3, 0x1c,  0x8c, 0x29, 0xa3, 0x10,
+	0x23, 0x11, 0xa7, 0x1b,  0x23, 0x15, 0xa3, 0x18,
+	0x08, 0x00, 0x27, 0x08,  0x32, 0x02, 0x03, 0x1c,
+	0x8c, 0x29, 0x08, 0x00,  0xa3, 0x1d, 0xa0, 0x29,
+	0x3c, 0x08, 0x83, 0x16,  0x98, 0x04, 0x83, 0x12,
+	0x23, 0x1a, 0x9e, 0x29,  0x23, 0x16, 0x23, 0x11,
+	0xb2, 0x1b, 0x23, 0x15,  0x49, 0x08, 0xb2, 0x07,
+	0x03, 0x1c, 0x9d, 0x29,  0xa3, 0x14, 0x08, 0x00,
+	0x23, 0x10, 0x08, 0x00,  0x3c, 0x08, 0x2a, 0x1c,
+	0xa7, 0x29, 0x83, 0x16,  0x98, 0x04, 0x83, 0x12,
+	0xab, 0x29, 0xff, 0x3a,  0x83, 0x16, 0x98, 0x05,
+	0x83, 0x12, 0xaa, 0x0c,  0x23, 0x11, 0xb2, 0x1b,
+	0x23, 0x15, 0x49, 0x08,  0xb2, 0x07, 0x03, 0x1c,
+	0xb4, 0x29, 0xa3, 0x14,  0xaf, 0x0b, 0xb8, 0x29,
+	0xa3, 0x15, 0x08, 0x00,  0xb0, 0x0b, 0x08, 0x00,
+	0x37, 0x08, 0xaa, 0x00,  0x08, 0x30, 0xb0, 0x00,
+	0x08, 0x00, 0xfc, 0x21,  0xaa, 0x00, 0x09, 0x30,
+	0x48, 0x02, 0x03, 0x1c,  0xc7, 0x29, 0xfc, 0x21,
+	0xb7, 0x00, 0x48, 0x08,  0xaf, 0x00, 0x08, 0x30,
+	0xb0, 0x00, 0xa3, 0x01,  0x23, 0x14, 0x01, 0x08,
+	0xb2, 0x00, 0x23, 0x11,  0xb2, 0x1b, 0x23, 0x15,
+	0x49, 0x08, 0xb2, 0x07,  0x03, 0x1c, 0xd7, 0x29,
+	0xa3, 0x14, 0x3c, 0x08,  0xff, 0x3a, 0x83, 0x16,
+	0x98, 0x05, 0x83, 0x12,  0x08, 0x00, 0x24, 0x18,
+	0x08, 0x00, 0x09, 0x15,  0x24, 0x14, 0x08, 0x00,
+	0x09, 0x14, 0x24, 0x14,  0x08, 0x00, 0x89, 0x14,
+	0x24, 0x14, 0x08, 0x00,  0x83, 0x16, 0x89, 0x1f,
+	0xfa, 0x29, 0x83, 0x12,  0x17, 0x08, 0xff, 0x3a,
+	0x89, 0x05, 0x24, 0x10,  0x08, 0x00, 0x83, 0x16,
+	0x09, 0x08, 0x7f, 0x39,  0x03, 0x1d, 0xfa, 0x29,
+	0x83, 0x12, 0x89, 0x13,  0xa4, 0x10, 0x08, 0x00,
+	0x83, 0x12, 0x08, 0x00,  0x8c, 0x19, 0xfc, 0x29,
+	0x8b, 0x13, 0x00, 0x00,  0x0f, 0x08, 0x00, 0x00,
+	0x8b, 0x17, 0x08, 0x00,  0x83, 0x12, 0x20, 0x30,
+	0x84, 0x00, 0x80, 0x01,  0x84, 0x0a, 0x04, 0x08,
+	0x80, 0x3c, 0x03, 0x1d,  0x07, 0x2a, 0xa0, 0x30,
+	0x84, 0x00, 0x80, 0x01,  0x84, 0x0a, 0x04, 0x08,
+	0xff, 0x3c, 0x03, 0x1d,  0x0f, 0x2a, 0x08, 0x00
+
+};
+
+/* Firmware-dependent interrupts from the ARM to the FIM */
+#define FIM_SERIAL_INT_INSERT_CHAR		0x01
+#define FIM_SERIAL_INT_MATCH_CHAR		0x02
+#define FIM_SERIAL_INT_BITS_CHAR		0x04
+#define FIM_SERIAL_INT_CHAR_GAP 		0x08
+#define FIM_SERIAL_INT_BIT_POS			0x10
+#define FIM_SERIAL_INT_PRESCALE			0x20
+#define FIM_SERIAL_INT_BIT_TIME 		0x40
+
+/* Interrupts from the FIM to the driver */
+#define FIM_INT_FROM_MATCH_CHAR1		0x01
+#define FIM_INT_FROM_MATCH_CHAR2		0x02
+#define FIM_INT_FROM_RX_OVERFLOW		0x04
+
+/* FIM status */
+#define FIM_SERIAL_STAT_COMPLETE		0x01
+#define FIM_SERIAL_STAT_TX_ENABLE		0x02
+#define FIM_SERIAL_STAT_HW_FLOW 		0x04
+#define FIM_SERIAL_STAT_MATCH_CHAR1		0x08
+#define FIM_SERIAL_STAT_MATCH_CHAR2		0x10
+
+/* Special control registers */
+#define FIM_SERIAL_TXIO_REG                     0
+#define FIM_SERIAL_RXIO_REG                     1
+#define FIM_SERIAL_CTRL_REG			6
+
+/* Default port configuration */
+#define FIM_SERIAL_DATA_BITS			8
+#define FIM_SERIAL_STOP_BITS			1
+#define FIM_SERIAL_PARITY_BITS			0
+#define FIM_SERIAL_TOTAL_BITS			(FIM_SERIAL_DATA_BITS + \
+						 FIM_SERIAL_STOP_BITS + \
+						 FIM_SERIAL_PARITY_BITS)
+
diff --git a/arch/arm/cpu/arm926ejs/ns921x/ns921x_edt.c b/arch/arm/cpu/arm926ejs/ns921x/ns921x_edt.c
new file mode 100644
index 0000000..287678d
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/ns921x_edt.c
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2009 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <lcd.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns9xxx_mem.h>
+#include <cmd_nvram/partition.h>
+#include <nvram.h>
+#include <linux/mtd/compat.h>
+#if  (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_DIGI_CMD))
+# include "../../../common/digi/cmd_bsp.h"
+#endif
+
+#define EDTQVGA_DISPLAY              \
+{                                    \
+       .name           = "EDTQVGA",  \
+       .vl_col         = 320,        \
+       .vl_row         = 240,        \
+       .vl_bpix        = LCD_BPP     \
+}
+
+#ifdef CONFIG_LCD
+
+#define LCD_CS_OFFSET	0x40000000
+#define	LCD_POINTER	LCD_CS_OFFSET
+#define LCD_DATA	(LCD_CS_OFFSET + 2)
+#define GPIO_RESET_LCD	86
+#define GPIO_ENABLE_LCD	87
+
+struct vidinfo panel_info = EDTQVGA_DISPLAY;
+
+/* Externally used variables */
+void *lcd_base;				/* Start of framebuffer memory	*/
+void *lcd_console_address;		/* Start of console buffer	*/
+short console_col;
+short console_row;
+int lcd_line_length;
+int lcd_color_fg;
+int lcd_color_bg;
+int display_initialized = 0;
+
+int lcd_display_init(void);
+void lcd_ctrl_init( void *lcdbase );
+void lcd_enable( void );
+static int edtdisplay_init_mem( void *lcdbase );
+static int edtdisplay_init( void *lcdbase );
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void write_lcd_reg(uint addr, uint data)
+{
+	writew(addr, LCD_POINTER);
+	writew(data, LCD_DATA);
+}
+
+static void mdelay(int count)
+{
+	for(;count != 0;count--)
+		udelay(1000);
+}
+
+int lcd_display_init(void)
+{
+	display_initialized = 1;
+	return 0;
+}
+
+void config_cs(void)
+{
+	int cs = 0;
+	unsigned int reg;
+
+	/* CS configuration */
+	writel(0x3,   MEM_BASE_PA + MEM_STAT_EXT_WAIT);
+	writel(0x181, MEM_BASE_PA + MEM_STAT_CFG(cs));
+	writel(0x4,   MEM_BASE_PA + MEM_STAT_WAIT_WEN(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_WAIT_OEN(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_RD(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_PAGE(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_WR(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_TURN(cs));
+	/* Enable CS */
+	reg = readl(SYS_BASE_PA + SYS_CS_STATIC_BASE(cs));
+	writel(reg | 0x1, SYS_BASE_PA + SYS_CS_STATIC_BASE(cs));
+}
+
+void lcd_reset(void)
+{
+	gpio_cfg_set(GPIO_RESET_LCD,
+		     GPIO_CFG_FUNC_GPIO | GPIO_CFG_OUTPUT);
+	gpio_ctrl_set(GPIO_RESET_LCD, 0);
+	mdelay(100);
+	gpio_ctrl_set(GPIO_RESET_LCD, 1);
+}
+
+/* Configuration for the EDT QVGA display, most of the settings have
+ * been taken from a Himax application note */
+unsigned char edt_qvga_lcd_init[][3] = {
+	/* Index, value, delay to write next register in ms*/
+	{0x46, 0x94, 0},
+	{0x47, 0x41, 0},
+	{0x48, 0x00, 0},
+	{0x49, 0x33, 0},
+	{0x4a, 0x23, 0},
+	{0x4b, 0x45, 0},
+	{0x4c, 0x44, 0},
+	{0x4d, 0x77, 0},
+	{0x4e, 0x12, 0},
+	{0x4f, 0xcc, 0},
+	{0x50, 0x46, 0},
+	{0x51, 0x82, 0},
+	{0x02, 0x00, 0},	/* Column address start 2 */
+	{0x03, 0x00, 0},	/* Column address start 1 */
+	{0x04, 0x01, 0},	/* Column address end 2 */
+	{0x05, 0x3f, 0},	/* Column address end 1 */
+	{0x06, 0x00, 0},	/* Row address start 2 */
+	{0x07, 0x00, 0},	/* Row address start 1 */
+	{0x08, 0x00, 0},	/* Row address end 2 */
+	{0x09, 0xef, 0},	/* Row address end 1 */
+	{0x01, 0x06, 0},
+	{0x16, 0x68, 0},
+	{0x23, 0x95, 0},
+	{0x24, 0x95, 0},
+	{0x25, 0xff, 0},
+	{0x27, 0x02, 0},
+	{0x28, 0x02, 0},
+	{0x29, 0x02, 0},
+	{0x2a, 0x02, 0},
+	{0x2c, 0x02, 0},
+	{0x2d, 0x02, 0},
+	{0x3a, 0x01, 0},
+	{0x3b, 0x01, 0},
+	{0x3c, 0xf0, 0},
+	{0x3d, 0x00, 20},
+	{0x35, 0x38, 0},
+	{0x36, 0x78, 0},
+	{0x3e, 0x38, 0},
+	{0x40, 0x0f, 0},
+	{0x41, 0xf0, 0},
+	{0x19, 0x49, 0},
+	{0x93, 0x0f, 10},
+	{0x20, 0x40, 0},
+	{0x1d, 0x07, 0},
+	{0x1e, 0x00, 0},
+	{0x1f, 0x04, 0},
+	{0x44, 0x40, 0},
+	{0x45, 0x12, 10},
+	{0x1c, 0x04, 20},
+	{0x43, 0x80, 5},
+	{0x1b, 0x08, 40},
+	{0x1b, 0x10, 40},
+	{0x90, 0x7f, 0},
+	{0x26, 0x04, 40},
+	{0x26, 0x24, 0},
+	{0x26, 0x2c, 40},
+	{0x26, 0x3c, 0},
+	{0x57, 0x02, 0},
+	{0x55, 0x00, 0},
+	{0x57, 0x00, 0}
+};
+
+void edt_init(void)
+{
+	int i;
+
+	for (i=0; i < (sizeof(edt_qvga_lcd_init)/3); i++) {
+
+		write_lcd_reg(edt_qvga_lcd_init[i][0],
+			      edt_qvga_lcd_init[i][1]);
+		mdelay(edt_qvga_lcd_init[i][2]);
+	}
+	/* Prepare to print data */
+	writew(0x22, LCD_POINTER);
+}
+
+void lcd_disable(void)
+{
+	gpio_ctrl_set(GPIO_ENABLE_LCD, 0);
+}
+
+void lcd_enable(void)
+{
+	gpio_cfg_set(GPIO_ENABLE_LCD,
+		     GPIO_CFG_FUNC_GPIO | GPIO_CFG_OUTPUT);
+	gpio_ctrl_set(GPIO_ENABLE_LCD, 1);
+}
+
+void lcd_ctrl_init (void *lcdbase)
+{
+        const nv_param_part_t *part_entry;
+
+	if (NvParamPartFind(&part_entry, NVPT_SPLASH_SCREEN, NVFS_NONE, 0, 0)) {
+		edtdisplay_init_mem(lcdbase);
+		edtdisplay_init(lcdbase);
+		lcd_disable();
+		return;
+	}
+	gd->bd->fb_base = 0xffffffff;
+}
+
+ulong calc_fbsize (void)
+{
+	ulong size;
+	int line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
+
+	size = line_length * panel_info.vl_row;
+	size += PAGE_SIZE;
+
+	return size;
+}
+
+static int edtdisplay_init_mem (void *lcdbase)
+{
+	u_long palette_mem_size;
+	int fb_size = panel_info.vl_row * (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
+
+	panel_info.screen = (u_long)lcdbase;
+
+	panel_info.palette_size = NBITS(panel_info.vl_bpix) == 8 ? 256 : 16;
+	palette_mem_size = panel_info.palette_size * sizeof(u16);
+
+	debug("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
+	/* locate palette and descs at end of page following fb */
+	panel_info.palette = (u_long)lcdbase + fb_size + PAGE_SIZE - palette_mem_size;
+
+	return 0;
+}
+
+static int edtdisplay_init(void *lcdbase)
+{
+	lcd_enable();
+	lcd_reset();
+	config_cs();
+
+	mdelay(50);
+	writeb(0x67, LCD_POINTER);
+	if (readb(LCD_DATA) != 0x47) {
+		printf("error: HX8347 controller not detected\n");
+	}
+
+	edt_init();
+	/* Disable to avoid displaying anything on the
+	 * screen until we have the splash image */
+	lcd_disable();
+
+	return 0;
+}
+
+void lcd_write_pixel(unsigned short val)
+{
+	writew(val, LCD_DATA);
+}
+
+#endif /* CONFIG_LCD */
diff --git a/arch/arm/cpu/arm926ejs/ns921x/ns921x_eth.c b/arch/arm/cpu/arm926ejs/ns921x/ns921x_eth.c
new file mode 100644
index 0000000..4ab79ed
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/ns921x_eth.c
@@ -0,0 +1,986 @@
+/*
+ *  cpu/arm926ejs/ns921x/ns921x_eth.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.2 $
+ *  !Author:     Markus Pietrek
+ *  !References: [1] derived from ns9750_eth.c, 1.29
+*/
+
+#include <common.h>
+#include <net.h>		/* NetSendPacket */
+#include <miiphy.h>		/* miiphy_register */
+
+#include "ns9750_eth.h"		/* for Ethernet and PHY */
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>
+
+#if defined(CONFIG_DRIVER_NS921X_ETHERNET) && \
+	(CONFIG_COMMANDS & CFG_CMD_NET)
+
+/* some definition to make transistion to linux easier */
+
+#define NS921X_DRIVER_NAME	"eth"
+#define KERN_WARNING 		"Warning:"
+#define KERN_ERR 		"Error:"
+#define KERN_INFO 		"Info:"
+
+#if 0
+# define DEBUG
+#endif
+
+#ifdef	DEBUG
+# define printk			printf
+
+# define DEBUG_INIT		0x0001
+# define DEBUG_MINOR		0x0002
+# define DEBUG_RX		0x0004
+# define DEBUG_TX		0x0008
+# define DEBUG_INT		0x0010
+# define DEBUG_POLL		0x0020
+# define DEBUG_LINK		0x0040
+# define DEBUG_MII		0x0100
+# define DEBUG_MII_LOW		0x0200
+# define DEBUG_MEM		0x0400
+# define DEBUG_ERROR		0x4000
+# define DEBUG_ERROR_CRIT	0x8000
+
+static int nDebugLvl = DEBUG_ERROR_CRIT;
+
+# define DEBUG_ARGS0( FLG, a0 ) if( ( nDebugLvl & (FLG) ) == (FLG) ) \
+		printf("%s: " a0, __FUNCTION__, 0, 0, 0, 0, 0, 0 )
+# define DEBUG_ARGS1( FLG, a0, a1 ) if( ( nDebugLvl & (FLG) ) == (FLG)) \
+		printf("%s: " a0, __FUNCTION__, (int)(a1), 0, 0, 0, 0, 0 )
+# define DEBUG_ARGS2( FLG, a0, a1, a2 ) if( (nDebugLvl & (FLG)) ==(FLG))\
+		printf("%s: " a0, __FUNCTION__, (int)(a1), (int)(a2), 0, 0,0,0 )
+# define DEBUG_ARGS3( FLG, a0, a1, a2, a3 ) if((nDebugLvl &(FLG))==(FLG))\
+		printf("%s: "a0,__FUNCTION__,(int)(a1),(int)(a2),(int)(a3),0,0,0)
+# define DEBUG_FN( FLG ) if( (nDebugLvl & (FLG)) == (FLG) ) \
+		printf("\r%s:line %d\n", (int)__FUNCTION__, __LINE__, 0,0,0,0);
+# define ASSERT( expr, func ) if( !( expr ) ) { \
+        	printf( "Assertion failed! %s:line %d %s\n", \
+        	(int)__FUNCTION__,__LINE__,(int)(#expr),0,0,0); \
+        	func }
+#else /* DEBUG */
+# define printk(...)
+# define DEBUG_ARGS0( FLG, a0 )
+# define DEBUG_ARGS1( FLG, a0, a1 )
+# define DEBUG_ARGS2( FLG, a0, a1, a2 )
+# define DEBUG_ARGS3( FLG, a0, a1, a2, a3 )
+# define DEBUG_FN( n )
+# define ASSERT(expr, func)
+#endif /* DEBUG */
+
+#define NS921X_MII_CHECK_FOR_NEG      	(3*CFG_HZ) /* in s */
+#define NS921X_MII_NEG_DELAY      	(5*CFG_HZ) /* in s */
+#define TX_TIMEOUT			(5*CFG_HZ) /* in s */
+#define SPREAD_SPECTRUM_PERCENTAGE	(4)	   /* 4% */
+
+/* @TODO move it to eeprom.h */
+#define FS_EEPROM_AUTONEG_MASK		0x7
+#define FS_EEPROM_AUTONEG_SPEED_MASK	0x1
+#define FS_EEPROM_AUTONEG_SPEED_10	0x0
+#define FS_EEPROM_AUTONEG_SPEED_100	0x1
+#define FS_EEPROM_AUTONEG_DUPLEX_MASK	0x2
+#define FS_EEPROM_AUTONEG_DUPLEX_HALF	0x0
+#define FS_EEPROM_AUTONEG_DUPLEX_FULL	0x2
+#define FS_EEPROM_AUTONEG_ENABLE_MASK	0x4
+#define FS_EEPROM_AUTONEG_DISABLE	0x0
+#define FS_EEPROM_AUTONEG_ENABLE	0x4
+
+/* buffer descriptors taken from [1] p.306 */
+typedef struct
+{
+	unsigned int* punSrc;
+	unsigned int unLen;	/* 11 bits */
+	unsigned int* punDest;	/* unused */
+	union {
+		unsigned int unReg;
+		struct {
+			unsigned uStatus : 16;
+			unsigned uRes : 12;
+			unsigned uFull : 1;
+			unsigned uEnable : 1;
+			unsigned uInt : 1;
+			unsigned uWrap : 1;
+		} bits;
+	} s;
+} rx_buffer_desc_t;
+
+typedef struct
+{
+	unsigned int* punSrc;
+	unsigned int unLen;	/* 10 bits */
+	unsigned int* punDest;	/* unused */
+	union {
+		unsigned int unReg; /* only 32bit accesses may done to NS921X
+				     * eth engine */
+		struct {
+			unsigned uStatus : 16;
+			unsigned uRes : 12;
+			unsigned uFull : 1;
+			unsigned uLast : 1;
+			unsigned uInt : 1;
+			unsigned uWrap : 1;
+		} bits;
+	} s;
+} tx_buffer_desc_t;
+
+static int eth_lowlevel_init( void );
+static int ns921x_eth_init_mac( void );
+static void ns921x_eth_reset_mac( void );
+
+static void ns921x_link_force( void );
+static void ns921x_link_auto_negotiate( void );
+static void ns921x_link_update_egcr( void );
+static void ns921x_link_print_changed( void );
+
+/* the PHY stuff */
+
+static char ns921x_mii_identify_phy( void );
+static unsigned short ns921x_mii_read( unsigned short uiRegister );
+static void ns921x_mii_write( unsigned short uiRegister, unsigned short uiData );
+static unsigned int ns921x_mii_get_clock_divisor( unsigned int unMaxMDIOClk );
+static unsigned int ns921x_mii_poll_busy( void );
+
+static unsigned int nPhyMaxMdioClock = PHY_MDIO_ASS_CLK;
+static unsigned char ucLinkMode =      FS_EEPROM_AUTONEG_ENABLE;
+static unsigned int uiLastLinkStatus;
+static PhyType phyDetected = PHY_NONE;
+
+/* we use only one tx buffer descriptor */
+static tx_buffer_desc_t* pTxBufferDesc =
+	(tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD );
+
+/* we use only one rx buffer descriptor of the 4 */
+static rx_buffer_desc_t rxBufferDesc[PKTBUFSRX];
+static uchar rxBuffer[PKTBUFSRX][(1522 + (0x1f)) & ~0x1f];
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_read based on ns921x_mii_read
+ * @Return: the data read from PHY register reg
+ * @Descr: the data read may be invalid if timed out. If so, a message
+ *         is printed but the invalid data is returned.
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static int ns921x_miiphy_read( char* devname, unsigned char addr, unsigned char reg, unsigned short *value )
+{
+        /* so MII functions can be used independently whether we did
+         * something with ethernet */
+        if( !eth_lowlevel_init() )
+                return -1;
+        
+	/* write MII register to be read */
+	*get_eth_reg_addr(NS9750_ETH_MADR) = addr<<8|reg;
+
+	*get_eth_reg_addr( NS9750_ETH_MCMD ) = NS9750_ETH_MCMD_READ;
+
+	if( !ns921x_mii_poll_busy() )
+	    printk( KERN_WARNING NS921X_DRIVER_NAME
+		    ": MII still busy in read\n" );
+	/* continue to read */
+
+	*get_eth_reg_addr( NS9750_ETH_MCMD ) = 0;
+
+	*value = (unsigned short) (*get_eth_reg_addr( NS9750_ETH_MRDD ) );
+
+	return 0;
+}
+
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_write based on ns921x_mii_write
+ * @Return: != 0 on error
+ * @Descr: writes the data to the PHY register. In case of a timeout,
+ *         no special handling is performed but a message printed
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static int ns921x_miiphy_write (char* devname, unsigned char addr, unsigned char reg, unsigned short value)
+{
+        if( !eth_lowlevel_init() )
+                return -1;
+
+	/* write MII register to be written */
+	*get_eth_reg_addr( NS9750_ETH_MADR)=addr<<8|reg;
+
+	*get_eth_reg_addr( NS9750_ETH_MWTD ) = value;
+
+	if( !ns921x_mii_poll_busy() )
+		printk( KERN_WARNING NS921X_DRIVER_NAME
+			": MII still busy in write\n");
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_initialize
+ * @Return: always 0
+ ***********************************************************************/
+int ns921x_miiphy_initialize( bd_t *bis )
+{
+        miiphy_register( "ns921x", (const char *)ns921x_miiphy_read, ns921x_miiphy_write );
+        return 0;
+}
+
+
+/***********************************************************************
+ * @Function: ns921x_mii_read
+ * @Return: the data read from PHY register uiRegister
+ * @Descr: the data read may be invalid if timed out. If so, a message
+ *         is printed but the invalid data is returned.
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static unsigned short ns921x_mii_read( unsigned short uiRegister )
+{
+        unsigned short val;
+        
+        ns921x_miiphy_read( NULL, NS921X_ETH_PHY_ADDRESS, uiRegister, &val );
+        return val;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_write
+ * @Return: nothing
+ * @Descr: writes the data to the PHY register. In case of a timeout,
+ *         no special handling is performed but a message printed
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static void ns921x_mii_write( unsigned short uiRegister, unsigned short uiData )
+{
+        ns921x_miiphy_write( NULL, NS921X_ETH_PHY_ADDRESS, uiRegister, uiData );
+}
+
+/***********************************************************************
+ * @Function: eth_lowlevel_init
+ * @Return: 0 on failure otherwise 1
+ * @Descr: Initializes the GPIO and low level register not for individual
+ *         frames
+ ***********************************************************************/
+
+static int eth_lowlevel_init( void )
+{
+        static int bAlreadyInitialized = 0;
+	int i;
+
+	DEBUG_FN( DEBUG_INIT );
+
+        if( bAlreadyInitialized )
+                return 1;
+        
+        bAlreadyInitialized = 1;
+
+        /* enable clock and hold it out-of-reset */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_ETH );
+        /* we don't need ETH Phy Int */
+	for( i = 32; i <= 49; i++ )
+                gpio_cfg_set( i, GPIO_CFG_FUNC_0 );
+
+#ifdef GPIO_ETH_PHY_RESET
+        /* take PHY out of reset. Needs to be done after GPIO 42
+           (TX_EN), otherwise the PHY lights yellow activity and blinks
+           green link LED.
+           xmit of frames will start after 35...500ms, [4] 9.5.16.
+           If already done by platform.S due to S4-8, it has no effect */
+        gpio_ctrl_set( GPIO_ETH_PHY_RESET, 1 );
+        gpio_cfg_set( GPIO_ETH_PHY_RESET,
+                      GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO );
+#endif
+        
+	/* no need to check for hardware */
+
+	if( !ns921x_eth_init_mac() )
+		return 0;
+
+	*get_eth_reg_addr( NS9750_ETH_MAC2 ) = NS9750_ETH_MAC2_CRCEN |
+		NS9750_ETH_MAC2_PADEN |
+		NS9750_ETH_MAC2_FULLD;
+
+        return 1;
+}
+
+/***********************************************************************
+ * @Function: eth_init
+ * @Return: -1 on failure otherwise 0
+ * @Descr: Initializes the ethernet engine and uses either FS Forth's default
+ *         MAC addr or the one in environment
+ ***********************************************************************/
+
+int eth_init( bd_t* pbis )
+{
+	int i;
+
+	/* enable hardware */
+        if( !eth_lowlevel_init() )
+                return -1;
+
+	/* prepare DMA descriptors */
+	/* NetRxPackets[ 0 ] is initialized before eth_init is called and never
+	   changes. NetRxPackets is 32bit aligned */
+
+	for (i = 0; i < PKTBUFSRX; ++i) {
+		rxBufferDesc[i].punSrc = (unsigned int*) (rxBuffer[i]);
+		rxBufferDesc[i].unLen = 1522;
+		rxBufferDesc[i].s.bits.uWrap = !(i < PKTBUFSRX - 1);
+		rxBufferDesc[i].s.bits.uInt = 1;
+		rxBufferDesc[i].s.bits.uEnable = 1;
+		rxBufferDesc[i].s.bits.uFull = 0;
+	}
+
+        flush_cache_all();
+        
+	*get_eth_reg_addr( NS9750_ETH_RXAPTR ) = (unsigned int)rxBufferDesc;
+	*get_eth_reg_addr( NS9750_ETH_RXBPTR ) = 0;
+	*get_eth_reg_addr( NS9750_ETH_RXCPTR ) = 0;
+	*get_eth_reg_addr( NS9750_ETH_RXDPTR ) = 0;
+
+	udelay(1); /* This seems to be only needed when compiled under cygwin?? */
+
+	/* pTxBufferDesc is the first possible buffer descriptor */
+	*get_eth_reg_addr( NS9750_ETH_TXPTR ) = 0x0;
+	
+	/* set first descriptor to wrap and disable to avoid unwanted
+	   transmissions */
+	((tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD ))->s.unReg=0x80000000;
+        
+	/* set the next buffer descriptor empty so the tx engine stops on that descriptor */
+	((tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD1 ))->s.unReg=0x0;
+
+	/* enable receive and transmit FIFO, use 10/100 Mbps MII */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) =
+		NS9750_ETH_EGCR1_ERX |
+		NS9750_ETH_EGCR1_ETX |
+		NS9750_ETH_EGCR1_ERXINIT;
+
+	/* [1] Tab. 221 states less than 5us */
+	udelay( 5 );
+	while( !(*get_eth_reg_addr(NS9750_ETH_EGSR) & NS9750_ETH_EGSR_RXINIT))
+		/* wait for finish */
+		udelay( 1 );
+
+        *get_eth_reg_addr(NS9750_ETH_EGSR) = NS9750_ETH_EGSR_RXINIT;
+
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) &= ~NS9750_ETH_EGCR1_ERXINIT;
+	*get_eth_reg_addr( NS9750_ETH_EGCR2 ) = NS9750_ETH_EGCR2_STEN;
+
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) = NS9750_ETH_MAC1_RXEN;
+	*get_eth_reg_addr( NS9750_ETH_SUPP ) &= ~NS9750_ETH_SUPP_RPERMII;
+
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) =
+		NS9750_ETH_EGCR1_ERX |
+		NS9750_ETH_EGCR1_ETX |
+		NS9750_ETH_EGCR1_ERXDMA |
+		NS9750_ETH_EGCR1_ETXDMA |
+		NS9750_ETH_EGCR1_ERXSHT;
+
+	*get_eth_reg_addr(NS9750_ETH_EINTR) |= *get_eth_reg_addr(NS9750_ETH_EINTR);
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_send
+ * @Return: -1 on timeout otherwise 1
+ * @Descr: sends one frame by DMA
+ ***********************************************************************/
+
+int eth_send( volatile void* pPacket, int nLen )
+{
+        unsigned int uiTries = 3;
+        
+	DEBUG_FN( DEBUG_TX );
+
+        /* in case a Tx Error happened, retry transmission a few times */
+        do {
+                ulong ulTimeout;
+                
+                uiTries--;
+                
+                /* clear old status values */
+                *get_eth_reg_addr(NS9750_ETH_EINTR) &= NS9750_ETH_EINTR_TX_MA;
+
+                /* prepare Tx Descriptors */
+                
+                pTxBufferDesc->punSrc = (unsigned int*) pPacket; /* pPacket is 32bit
+                                                                  * aligned */
+                pTxBufferDesc->unLen = nLen;
+                /* only 32bit accesses allowed. wrap, full, interrupt and enabled to 1 */
+                pTxBufferDesc->s.unReg = 0xf0000000;
+                
+                flush_cache_all();
+                
+                /* pTxBufferDesc is the first possible buffer descriptor */
+                *get_eth_reg_addr( NS9750_ETH_TXPTR ) = 0x0;
+
+                /* enable processor for next frame */
+
+                *get_eth_reg_addr( NS9750_ETH_EGCR2 ) &= ~(NS9750_ETH_EGCR2_TCLER | NS9750_ETH_EGCR2_TKICK );
+                *get_eth_reg_addr( NS9750_ETH_EGCR2 ) |= ( NS9750_ETH_EGCR2_TCLER | NS9750_ETH_EGCR2_TKICK );
+
+                DEBUG_ARGS0(DEBUG_TX|DEBUG_MINOR,"Waiting for transmission to finish\n");
+	
+                ulTimeout = get_timer( 0 );
+
+                while( 1 ) {
+                        u32 uiIntr = *get_eth_reg_addr( NS9750_ETH_EINTR );
+
+                        if( get_timer( ulTimeout ) >= TX_TIMEOUT ) {
+                                printf( "Tx Timeout %x %x\n",
+                                        uiIntr, pTxBufferDesc->s.unReg );
+                                break;
+                        }
+
+                        if( uiIntr & NS9750_ETH_EINTR_TXERR ) {
+                                printf( "Tx Error: %08x\n",
+                                        pTxBufferDesc->s.unReg );
+                                break;
+                        } else if( uiIntr & NS9750_ETH_EINTR_TXDONE ) {
+                                uiTries = 0;
+                                break;
+                        }
+                }
+
+                *get_eth_reg_addr( NS9750_ETH_EINTR ) &= NS9750_ETH_EINTR_TX_MA;
+        } while( uiTries );
+        
+        DEBUG_ARGS0( DEBUG_TX|DEBUG_MINOR, "transmitted...\n");
+
+        return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_rx
+ * @Return: size of last frame in bytes or 0 if no frame available
+ * @Descr: gives one frame to U-Boot which has been copied by DMA engine already
+ *         to NetRxPackets[ 0 ].
+ ***********************************************************************/
+
+int eth_rx( void )
+{
+	unsigned int unStatus;
+	int i;
+
+	unStatus = *get_eth_reg_addr(NS9750_ETH_EINTR) & NS9750_ETH_EINTR_RX_MA;
+
+	if( !unStatus )
+		/* no packet available, return immediately */
+		return 0;
+
+	DEBUG_FN( DEBUG_RX );
+
+	/* acknowledge status register */
+	*get_eth_reg_addr(NS9750_ETH_EINTR) = unStatus;
+
+	if (unStatus & NS9750_ETH_EINTR_RXDONEA)  {
+		for (i = 0; i < PKTBUFSRX; ++i) {
+                        invalidate_cache_all();
+
+			if (rxBufferDesc[i].s.bits.uFull) {
+				int len = rxBufferDesc[i].unLen - 4;
+				NetReceive(rxBuffer[i], len);
+
+				rxBufferDesc[i].unLen = 1522;
+				rxBufferDesc[i].s.bits.uFull = 0;
+				*get_eth_reg_addr(NS9750_ETH_RXFREE) |= 0x1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_halt
+ * @Return: n/a
+ * @Descr: we don't do anything here to avoid unnecessary initialization
+ *         again on next command
+ ***********************************************************************/
+
+void eth_halt( void )
+{
+	DEBUG_FN( DEBUG_INIT );
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) &= ~NS9750_ETH_MAC1_RXEN;
+}
+
+/***********************************************************************
+ * @Function: ns921x_eth_init_mac
+ * @Return: 0 on failure otherwise 1
+ * @Descr: initializes the PHY layer,
+ *         performs auto negotiation or fixed modes
+ ***********************************************************************/
+
+static int ns921x_eth_init_mac( void )
+{
+	DEBUG_FN( DEBUG_MINOR );
+
+	/* initialize PHY */
+	*get_eth_reg_addr( NS9750_ETH_SUPP ) = NS9750_ETH_SUPP_RPERMII;
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) = 0;  /* take it out of SoftReset */
+	/* we don't support hot plugging of PHY, therefore we don't reset
+	   phyDetected and nPhyMaxMdioClock here. The risk is if the setting is
+	   incorrect the first open
+	   may detect the PHY correctly but succeding will fail
+	   For reseting the PHY and identifying we have to use the standard
+	   MDIO CLOCK value 2.5 MHz.2.5 MHz are assured by the hardware
+	   reference ns9215 and ns9210. Higher speed can be working. We
+	   will not use higher speed. */
+
+	*get_eth_reg_addr( NS9750_ETH_MCFG ) =
+	    ns921x_mii_get_clock_divisor( nPhyMaxMdioClock );
+
+	/* MII clock has been setup to default, ns9750_mii_identify_phy should
+	   work for all */
+
+	if( !ns921x_mii_identify_phy() ) {
+	    printf( "Unsupported PHY, aborting\n");
+	    return 0;
+	}
+
+	/* PHY has been detected, so there can be no abort reason and we can
+	   finish initializing ethernet */
+
+	uiLastLinkStatus = 0xff; /* undefined */
+
+	if((ucLinkMode&FS_EEPROM_AUTONEG_ENABLE_MASK)==FS_EEPROM_AUTONEG_DISABLE)
+		/* use parameters defined */
+		ns921x_link_force();
+	else
+		ns921x_link_auto_negotiate();
+
+	return 1;
+}
+
+/***********************************************************************
+ * @Function: ns921x_eth_reset_mac
+ * @Return: 0 on failure otherwise 1
+ * @Descr: resets the MAC 
+ ***********************************************************************/
+
+static void ns921x_eth_reset_mac( void )
+{
+	DEBUG_FN( DEBUG_MINOR );
+
+	/* Reset MAC */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) |= (NS9750_ETH_EGCR1_MAC_HRST |
+							NS9750_ETH_EGCR1_ERX |
+							NS9750_ETH_EGCR1_ETX);
+	udelay( 5 ); 		/* according to [1], p.322 */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) &= ~NS9750_ETH_EGCR1_MAC_HRST;
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_force
+ * @Return: void
+ * @Descr: configures eth and MII to use the link mode defined in
+ *         ucLinkMode
+ ***********************************************************************/
+
+static void ns921x_link_force( void )
+{
+	unsigned short uiControl;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	uiControl = ns921x_mii_read( PHY_COMMON_CTRL );
+	uiControl &= ~( PHY_COMMON_CTRL_SPD_MA |
+			PHY_COMMON_CTRL_AUTO_NEG |
+			PHY_COMMON_CTRL_DUPLEX );
+
+	uiLastLinkStatus = 0;
+
+	if( ( ucLinkMode & FS_EEPROM_AUTONEG_SPEED_MASK ) ==
+	    FS_EEPROM_AUTONEG_SPEED_100 ) {
+	    uiControl |= PHY_COMMON_CTRL_SPD_100;
+#ifdef CONFIG_PHY_ICS1893
+	    uiLastLinkStatus |= PHY_ICS1893_QPSTAT_100BTX;
+#endif
+	} else
+	    uiControl |= PHY_COMMON_CTRL_SPD_10;
+
+	if( ( ucLinkMode & FS_EEPROM_AUTONEG_DUPLEX_MASK ) ==
+	    FS_EEPROM_AUTONEG_DUPLEX_FULL ) {
+	    uiControl |= PHY_COMMON_CTRL_DUPLEX;
+#ifdef CONFIG_PHY_ICS1893
+	    uiLastLinkStatus |= PHY_ICS1893_QPSTAT_DUPLEX;
+#endif
+	}
+
+	ns921x_mii_write( PHY_COMMON_CTRL, uiControl );
+
+	ns921x_link_print_changed();
+	ns921x_link_update_egcr();
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_auto_negotiate
+ * @Return: void
+ * @Descr: performs auto-negotation of link.
+ ***********************************************************************/
+
+static void ns921x_link_auto_negotiate( void )
+{
+	unsigned long ulStartJiffies;
+	unsigned short uiStatus;
+        unsigned long uiCheckStart;
+        
+	DEBUG_FN( DEBUG_LINK );
+
+        uiCheckStart = get_timer( 0 );
+        
+        /* determination whether an auto-negotiation is in progress */
+        do {
+                uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+                if( ( uiStatus &
+                      PHY_COMMON_STAT_LNK_STAT) == PHY_COMMON_STAT_LNK_STAT) {
+                        /* we have a link, so no need to trigger auto-negotiation */
+                        ns921x_link_print_changed();
+                        ns921x_link_update_egcr();
+                        return;
+                }
+        } while( get_timer( uiCheckStart ) < NS921X_MII_CHECK_FOR_NEG );
+
+        /* no auto-negotiation seemed to be in progress, and there is no link.
+           run auto-negotation */
+	/* define what we are capable of */
+	ns921x_mii_write( PHY_COMMON_AUTO_ADV,
+			  PHY_COMMON_AUTO_ADV_100BTXFD |
+			  PHY_COMMON_AUTO_ADV_100BTX |
+			  PHY_COMMON_AUTO_ADV_10BTFD |
+			  PHY_COMMON_AUTO_ADV_10BT |
+			  PHY_COMMON_AUTO_ADV_802_3 );
+	/* start auto-negotiation */
+	ns921x_mii_write( PHY_COMMON_CTRL,
+			  PHY_COMMON_CTRL_AUTO_NEG |
+			  PHY_COMMON_CTRL_RES_AUTO );
+
+	/* wait for completion */
+
+	ulStartJiffies = get_ticks();
+	while( get_ticks() < ulStartJiffies + NS921X_MII_NEG_DELAY ) {
+		uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+		if( ( uiStatus &
+		      (PHY_COMMON_STAT_AN_COMP | PHY_COMMON_STAT_LNK_STAT)) ==
+		    (PHY_COMMON_STAT_AN_COMP | PHY_COMMON_STAT_LNK_STAT) ) {
+			/* lucky we are, auto-negotiation succeeded */
+			ns921x_link_print_changed();
+			ns921x_link_update_egcr();
+
+			return;
+		}
+	}
+
+	printf( KERN_WARNING NS921X_DRIVER_NAME
+		":auto-negotiation timed out, forcing 10Mbps/Half\n" );
+
+	/* force mode */
+	ucLinkMode = FS_EEPROM_AUTONEG_SPEED_10 | FS_EEPROM_AUTONEG_DUPLEX_HALF;
+	ns921x_link_force();
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_update_egcr
+ * @Return: void
+ * @Descr: updates the EGCR and MAC2 link status after mode change or
+ *         auto-negotation
+ ***********************************************************************/
+
+static void ns921x_link_update_egcr( void )
+{
+	unsigned int unEGCR;
+	unsigned int unMAC2;
+	unsigned int unIPGT;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	unEGCR = *get_eth_reg_addr( NS9750_ETH_EGCR1 );
+	unMAC2 = *get_eth_reg_addr( NS9750_ETH_MAC2 );
+	unIPGT = *get_eth_reg_addr( NS9750_ETH_IPGT ) & ~NS9750_ETH_IPGT_MA;
+
+	unMAC2 &= ~NS9750_ETH_MAC2_FULLD;
+
+#ifdef CONFIG_PHY_ICS1893
+	if( (uiLastLinkStatus & PHY_ICS1893_QPSTAT_DUPLEX)
+	    == PHY_ICS1893_QPSTAT_DUPLEX ) {
+		unMAC2 |= NS9750_ETH_MAC2_FULLD;
+		unIPGT |= 0x15;	/* see [1] p. 339 */
+	}
+	else
+#endif
+		unIPGT |= 0x12;	/* see [1] p. 339 */
+
+	*get_eth_reg_addr( NS9750_ETH_MAC2 ) = unMAC2;
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) = unEGCR;
+	*get_eth_reg_addr( NS9750_ETH_IPGT ) = unIPGT;
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_print_changed
+ * @Return: void
+ * @Descr: checks whether the link status has changed and if so prints
+ *         the new mode
+ ***********************************************************************/
+
+static void ns921x_link_print_changed( void )
+{
+	unsigned short uiStatus;
+	unsigned short uiControl;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	uiControl = ns921x_mii_read( PHY_COMMON_CTRL );
+
+	if( (uiControl & PHY_COMMON_CTRL_AUTO_NEG) == PHY_COMMON_CTRL_AUTO_NEG) {
+		/* PHY_COMMON_STAT_LNK_STAT is only set on autonegotiation */
+		uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+
+		if( !( uiStatus & PHY_COMMON_STAT_LNK_STAT) ) {
+			printk( KERN_WARNING NS921X_DRIVER_NAME ": link down\n");
+			/* @TODO Linux: carrier_off */
+		} else {
+			/* @TODO Linux: carrier_on */
+#ifdef CONFIG_PHY_ICS1893
+	unsigned short uiStatus_bak;
+			if( phyDetected == PHY_ICS1893BK ) {
+				uiStatus = ns921x_mii_read( PHY_COMMON_AUTO_ADV );
+				uiStatus &= (PHY_ICS1893_QPSTAT_100BTX);
+				uiStatus_bak = uiStatus;
+				uiStatus = ns921x_mii_read( PHY_COMMON_CTRL );
+				uiStatus &= (PHY_ICS1893_QPSTAT_DUPLEX );
+				uiStatus |= uiStatus_bak;
+
+				/* mask out all uninteresting parts */
+			}
+#endif
+			/* other PHYs must store there link information in
+			   uiStatus as PHY_LXT971 */
+		}
+	} else {
+		/* mode has been forced, so uiStatus should be the same as the
+		   last link status, enforce printing */
+		uiStatus = uiLastLinkStatus;
+		uiLastLinkStatus = 0xff;
+	}
+
+	if( uiStatus != uiLastLinkStatus ) {
+		/* save current link status */
+		uiLastLinkStatus = uiStatus;
+	}
+}
+
+/***********************************************************************
+ * the MII low level stuff
+ ***********************************************************************/
+
+/***********************************************************************
+ * @Function: ns921x_mii_identify_phy
+ * @Return: 1 if supported PHY has been detected otherwise 0
+ * @Descr: checks for supported PHY and prints the IDs.
+ ***********************************************************************/
+
+static char ns921x_mii_identify_phy( void )
+{
+	unsigned short uiID1;
+	unsigned short uiID2;
+	char* szName;
+	char cRes = 0;
+        
+	DEBUG_FN( DEBUG_MII );
+
+	uiID1 = ns921x_mii_read( PHY_COMMON_ID1 );
+	phyDetected = (PhyType)uiID1;
+
+	switch( phyDetected ) {
+#ifdef CONFIG_PHY_ICS1893
+	    case PHY_ICS1893BK:
+		szName = "ICS1893BK";
+		uiID2 = ns921x_mii_read( PHY_COMMON_ID2 );
+		cRes = 1;
+		break;
+#endif
+#ifdef CONFIG_PHY_HIRSCHMANN
+	    case PHY_HIRSCHMANN:
+		szName = "Hirschmann";
+		nPhyMaxMdioClock = 0x25000000;
+		cRes = 1;
+		break;
+#endif
+	    case PHY_NONE:
+	    default:
+		/* in case uiID1 == 0 && uiID2 == 0 we may have the wrong
+		   address or reset sets the wrong NS921X_ETH_MCFG_CLKS */
+
+		uiID2 = 0;
+		szName = "unknown";
+		phyDetected = PHY_NONE;
+
+                printf( "Unknown PHY @ %i (0x%x, 0x%x) detected\n",
+                        NS921X_ETH_PHY_ADDRESS,
+                        uiID1,
+                        uiID2 );
+
+	}
+
+	return cRes;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_get_clock_divisor
+ * @Return: the clock divisor that should be used in NS9750_ETH_MCFG_CLKS
+ * @Descr: if no clock divisor can be calculated for the
+ *         current SYSCLK and the maximum MDIO Clock, a warning is printed
+ *         and the greatest divisor is taken
+ ***********************************************************************/
+
+static unsigned int ns921x_mii_get_clock_divisor( unsigned int unMaxMDIOClk )
+{
+	struct
+	{
+		unsigned int unSysClkDivisor;
+		unsigned int unClks; /* field for NS9750_ETH_MCFG_CLKS */
+	} PHYClockDivisors[] = {
+		{  4, NS9750_ETH_MCFG_CLKS_4 },
+		{  6, NS9750_ETH_MCFG_CLKS_6 },
+		{  8, NS9750_ETH_MCFG_CLKS_8 },
+		{ 10, NS9750_ETH_MCFG_CLKS_10 },
+		{ 20, NS9750_ETH_MCFG_CLKS_20 },
+		{ 30, NS9750_ETH_MCFG_CLKS_30 },
+		{ 40, NS9750_ETH_MCFG_CLKS_40 }
+	};
+
+	int nIndexSysClkDiv;
+	int nArraySize = sizeof(PHYClockDivisors) / sizeof(PHYClockDivisors[0]);
+	unsigned int unClks = NS9750_ETH_MCFG_CLKS_40; /* defaults to
+							  greatest div */
+
+	DEBUG_FN( DEBUG_INIT );
+
+	for( nIndexSysClkDiv=0; nIndexSysClkDiv < nArraySize;nIndexSysClkDiv++) {
+		/* find first sysclock divisor that isn't higher than 2.5 MHz
+		   clock */
+		if( AHB_CLK_FREQ /
+		    PHYClockDivisors[ nIndexSysClkDiv ].unSysClkDivisor <=
+		    unMaxMDIOClk ) {
+			unClks = PHYClockDivisors[ nIndexSysClkDiv ].unClks;
+			break;
+		}
+	}
+
+	DEBUG_ARGS2( DEBUG_INIT,
+		     "Taking MDIO Clock bit mask 0x%0x for max clock %i\n",
+		     unClks,
+		     unMaxMDIOClk );
+
+	/* return greatest divisor */
+	return unClks;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_poll_busy
+ * @Return: 0 if timed out otherwise the remaing timeout
+ * @Descr: waits until the MII has completed a command or it times out
+ *         code may be interrupted by hard interrupts.
+ *         It is not checked what happens on multiple actions when
+ *         the first is still being busy and we timeout.
+ ***********************************************************************/
+
+static unsigned int ns921x_mii_poll_busy( void )
+{
+	unsigned int unTimeout = 10000;
+
+	DEBUG_FN( DEBUG_MII_LOW );
+
+	while( (( *get_eth_reg_addr( NS9750_ETH_MIND ) & NS9750_ETH_MIND_BUSY)
+		== NS9750_ETH_MIND_BUSY ) &&
+	       unTimeout )
+		unTimeout--;
+
+	return unTimeout;
+}
+
+/***********************************************************************
+ * @Function: eth_use_mac_from_env
+ * @Return: 0 if ok, < 0 on failure
+ * @Descr: Stores MAC address in chip. Might be called for a not fully
+ * initialized network stack when booting Linux from Flash.
+ ***********************************************************************/
+
+int eth_use_mac_from_env( bd_t* pbis )
+{
+	unsigned char aucMACAddr[ 6 ] = { 0x00,0x04,0xf3,0x00,0x06,0x35 };
+
+	char* pcTmp = getenv( "ethaddr" );
+	char* pcEnd;
+        int   i;
+
+        /* clock is not on when used directly from board_late_init() */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_ETH );
+
+        ns921x_eth_reset_mac();
+
+	if( pcTmp != NULL ) {
+                /* copy MAC address */
+                for( i = 0; i < 6; i++ ) {
+                        aucMACAddr[ i ] = pcTmp ? simple_strtoul( pcTmp, &pcEnd, 16 ) : 0;
+                        /* next char or terminating zero */
+                        pcTmp = (*pcTmp) ? ( pcEnd + 1 ) : pcEnd;
+                }
+        } else
+                eprintf( "Couldn't read MAC address from environment, using default\n" );
+
+
+        /* now set it, so linux can use it */
+	*get_eth_reg_addr( NS9750_ETH_SA1 ) = aucMACAddr[ 5 ]<<8 | aucMACAddr[ 4 ];
+	*get_eth_reg_addr( NS9750_ETH_SA2 ) = aucMACAddr[ 3 ]<<8 | aucMACAddr[ 2 ];
+	*get_eth_reg_addr( NS9750_ETH_SA3 ) = aucMACAddr[ 1 ]<<8 | aucMACAddr[ 0 ];
+
+        sys_rmw32( SYS_CLOCK, & ( ~SYS_CLOCK_ETH ) );
+
+	return 0;
+}
+
+/***********************************************************************
+* @Function: set_mac_from_env
+* @Descr: Stores MAC address in chip. Call careful,because no check is
+* done.
+***********************************************************************/
+
+void set_mac_from_env( void )
+{
+	unsigned char aucMACAddr[ 6 ];
+
+	char* pcTmp = getenv( "ethaddr" );
+	char* pcEnd;
+        int   i;
+
+	if( pcTmp != NULL ) {
+                /* copy MAC address */
+                for( i = 0; i < 6; i++ ) {
+                        aucMACAddr[ i ] = pcTmp ? simple_strtoul( pcTmp, &pcEnd, 16 ) : 0;
+                        /* next char or terminating zero */
+                        pcTmp = (*pcTmp) ? ( pcEnd + 1 ) : pcEnd;
+                }
+        } else
+                eprintf( "Couldn't read MAC address from environment, using default\n" );
+
+
+        /* now set it, so linux can use it */
+	*get_eth_reg_addr( NS9750_ETH_SA1 ) = aucMACAddr[ 5 ]<<8 | aucMACAddr[ 4 ];
+	*get_eth_reg_addr( NS9750_ETH_SA2 ) = aucMACAddr[ 3 ]<<8 | aucMACAddr[ 2 ];
+	*get_eth_reg_addr( NS9750_ETH_SA3 ) = aucMACAddr[ 1 ]<<8 | aucMACAddr[ 0 ];
+}
+
+#endif /* CONFIG_DRIVER_NS921X_ETHERNET */
diff --git a/arch/arm/cpu/arm926ejs/ns921x/reset.S b/arch/arm/cpu/arm926ejs/ns921x/reset.S
new file mode 100644
index 0000000..a98f329
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/reset.S
@@ -0,0 +1,29 @@
+/*
+ *  cpu/arm926ejs/ns921x/reset.S
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Reference:  [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <config.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+
+	.align	4
+.globl reset_cpu
+reset_cpu:
+          ldr   r1, =(SYS_BASE_PA + SYS_PLL)
+          ldr   r2, [r1]
+          str   r2, [r1]
+
+_loop_forever:
+	b	_loop_forever
+        
diff --git a/arch/arm/cpu/arm926ejs/ns921x/serial_ns921x.c b/arch/arm/cpu/arm926ejs/ns921x/serial_ns921x.c
new file mode 100644
index 0000000..1e0f897
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/serial_ns921x.c
@@ -0,0 +1,342 @@
+/*
+ *  cpu/arm926ejs/ns921x/serial_ns921x.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <common.h>
+
+#ifdef CFG_NS921X_UART
+
+#ifdef CONFIG_NS9210
+# define SERIAL_PORT_B_TX	23
+# define SERIAL_PORT_B_RX	19
+# define SERIAL_PORT_D_TX	31
+# define SERIAL_PORT_D_RX	27
+# define GPIO_CFG_FUNC_UART	GPIO_CFG_FUNC_1
+#else
+# define SERIAL_PORT_B_TX	58
+# define SERIAL_PORT_B_RX	54
+# define SERIAL_PORT_D_TX	66
+# define SERIAL_PORT_D_RX	62
+# define GPIO_CFG_FUNC_UART	GPIO_CFG_FUNC_0
+#endif
+
+#include <serial.h>             /* serial_ns921x_devices */
+
+#include <asm/errno.h>              /* EINVAL */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_hub.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+
+
+#define GPIO_TX		0
+#define GPIO_RX		1
+#define GPIO_LAST	1
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Order of GPIOs is GPIO_TX to GPIO_LAST and function
+ * Use always function as last element of the array
+ */
+static const char l_aiGPIO[][3] = {
+	{  7,  3,  GPIO_CFG_FUNC_0 }, /* Port A */
+	{ SERIAL_PORT_B_TX, SERIAL_PORT_B_RX, GPIO_CFG_FUNC_UART }, /* Port B */
+	{ 15, 11, GPIO_CFG_FUNC_0 }, /* Port C */
+	{ SERIAL_PORT_D_TX, SERIAL_PORT_D_RX, GPIO_CFG_FUNC_UART }  /* Port D */
+};
+
+/* the port we are using */
+static int l_iPort = -1;        /* not initialized yet */
+
+/* for caching characters and l_xFIFO */
+static struct {
+        u32 uChars;
+        int iCount;
+} l_xFIFO = { 0, 0 };
+
+/* some functions that map the HUB port  */
+static inline u32 hub_readl( u32 uOffs )
+{
+        return hub_port_readl( l_iPort, uOffs );
+}
+
+static inline u8 hub_readb( u32 uOffs )
+{
+        return hub_port_readb( l_iPort, uOffs );
+}
+
+static inline void hub_writel( u32 uVal, u32 uOffs )
+{
+        hub_port_writel( l_iPort, uVal, uOffs );
+}
+
+static inline void hub_writeb( u8 ucVal, u32 uOffs )
+{
+        hub_port_writeb( l_iPort, ucVal, uOffs );
+}
+
+/**
+ * ns_serial_setbrg - set baudrate register
+ */
+void ns_serial_setbrg( void )
+{
+        u32 uPeriod = NS_CPU_REF_CLOCK / gd->baudrate;
+        u32 uDiv    = uPeriod / 16; /* 16 bit oversampling */
+        /* [1], p. 359 by default we use 8N1. 8 character bit, one start, one
+         * stopbit */
+        static const u32 uCharLen = 10;
+
+        hub_writel( UART_CGAP_CTRL_EN |
+                       UART_CGAP_CTRL_VAL( uCharLen * uPeriod - 1 ), UART_CGAP_CTRL );
+        /* [1], p. 360, 64 characters, 640 bit periods */
+        hub_writel( UART_BGAP_CTRL_EN |
+                       UART_BGAP_CTRL_VAL( 64 * uCharLen * uPeriod - 1 ), UART_BGAP_CTRL );
+
+        /* baudrate divisor */
+        hub_rmw32( UART_LINE_CTRL, | UART_LINE_CTRL_DLAB );
+        hub_writel( UART_BRDL_VAL( uDiv ),      UART_BRDL );
+        hub_writel( UART_BRDM_VAL( uDiv >> 8 ), UART_BRDM );
+        hub_rmw32( UART_LINE_CTRL, & ~UART_LINE_CTRL_DLAB );
+}
+
+/**
+ * ns_serial_init - initialises UART Module
+ */
+static int ns_serial_init( void )
+{
+        int i;
+
+        /* configure GPIOs for special function */
+         for( i = 0; i < ( ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ); i++ )
+                gpio_cfg_set( l_aiGPIO[ l_iPort ][ i ],
+                              l_aiGPIO[ l_iPort ][ ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ] );
+
+        /* enable clock and hold it out-of-reset */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_UART( l_iPort ) );
+        sys_rmw32( SYS_RESET, | SYS_RESET_UART( l_iPort ) );
+
+        /* toggle RX/TX FLUSH for resetting FIFO */
+        hub_writel( UART_WRAPPER_CFG_RX_FLUSH |
+                       UART_WRAPPER_CFG_TX_FLUSH,
+                       UART_WRAPPER_CFG );
+        hub_writel( 0, UART_WRAPPER_CFG );
+
+        /* no DMA, we poke into FIFO */
+        hub_writel( HUB_DMA_RX_CTRL_DIRECT, HUB_DMA_RX_CTRL );
+        hub_writel( HUB_DMA_TX_CTRL_DIRECT, HUB_DMA_TX_CTRL );
+
+        ns_serial_setbrg();
+
+        /* set line control to 8 Data Bits, No Parity, 1 Stop Bit */
+        hub_writel( UART_LINE_CTRL_PAR_NO |
+                       UART_LINE_CTRL_STOP_1  |
+                       UART_LINE_CTRL_WLS_8, UART_LINE_CTRL );
+
+        /* enable UARTs internal Rx/Tx FIFO */
+        hub_writel( UART_FIFO_CTRL_EN, UART_FIFO_CTRL );
+
+        /* This interrupt is needed from HW (Hub) as transmitter holding
+         * register. SW doesn't use it */
+        hub_writel( UART_BAUD_INT_ETBEI, UART_BAUD_INT );
+
+        /* enable wrapper */
+        hub_writel( UART_WRAPPER_CFG_RX_EN      |
+                       UART_WRAPPER_CFG_TX_EN      |
+                       UART_WRAPPER_CFG_TX_FLOW_SW |
+                       UART_WRAPPER_CFG_MODE_UART, UART_WRAPPER_CFG );
+
+        return 0;
+}
+
+/**
+ * ns_serial_deinit - deinitialises UART Module
+ */
+static int ns_serial_deinit( void )
+{
+        int i;
+
+        /* configure GPIOs as INPUT */
+        for( i = 0; i < ( ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ); i++ )
+                gpio_cfg_set( l_aiGPIO[ l_iPort ] [ i ], GPIO_CFG_INPUT );
+
+        /* disable wrapper */
+        hub_writel( 0, UART_WRAPPER_CFG );
+
+        /* disable clock and put in reset */
+        sys_rmw32( SYS_CLOCK, & ~SYS_CLOCK_UART( l_iPort ) );
+        sys_rmw32( SYS_RESET, & ~SYS_RESET_UART( l_iPort ) );
+
+        return 0;
+}
+
+/**
+ * serial_disable - disables UART Module
+ */
+int serial_disable( void )
+{
+#ifdef CONFIG_ALLOW_SERIAL_DISABLE
+	int i;
+
+	for(i=0; i < SERIAL_PORTS_NR; i++) {
+		l_iPort = i;
+		/* disable UARTs internal Rx/Tx FIFO */
+		hub_writel( 0, UART_WRAPPER_CFG );
+	}
+#endif
+	return 0;
+}
+
+/**
+ * ns_serial_start - starts the console.
+ */
+static int ns_serial_start( int iPort )
+{
+        int iRes = -EINVAL;
+
+        if( ( iPort >= 0 ) && ( iPort < 4 ) ) {
+                /* switch to new console */
+                if( -1 != l_iPort )
+                                /* not initialized yet */
+                        ns_serial_deinit();
+
+                l_iPort = iPort;
+                ns_serial_init();
+
+                iRes = 0;
+        } else {
+                /* eprintf may not be available yet */
+                printf( "*** ERROR: Unsupported port\n" );
+                iRes = -EINVAL;
+        }
+
+        return iRes;
+}
+
+/**
+ * ns_serial_putc - outputs one character
+ */
+
+static void ns_serial_putc( const char c )
+{
+        /* generate CR/LF */
+        if( '\n' == c )
+                ns_serial_putc( '\r' );
+
+        /* wait for space available */
+        while( ( hub_readl( HUB_INT ) & HUB_INT_TX_FIFO_FULL ) ) {
+                /* do nothing, wait for character to be sent */
+        }
+
+        hub_writeb( c, HUB_TX_FIFO );
+}
+
+/**
+ * ns_serial_puts - outputs a zero terminated string
+ */
+static void ns_serial_puts( const char* szMsg )
+{
+	while( *szMsg )
+		ns_serial_putc( *szMsg++ );
+}
+
+/**
+ * ns_serial_tstc - checks for input available
+ * @return: 0 if no input available, otherwise != 0
+ */
+int ns_serial_tstc( void )
+{
+        if( !l_xFIFO.iCount ) {
+                /* don't use HUB_RX_FIFO_STAT for checking of empty, it doesn't
+                 * handle buffer closed well. */
+                if( !( hub_readl( HUB_INT ) & HUB_INT_RX_FIFO_EMPTY ) ) {
+                        /* both reads (status and data) must be together */
+                        l_xFIFO.iCount = HUB_RX_FIFO_BYTE( hub_readl( HUB_RX_FIFO_STAT ) );
+
+	                l_xFIFO.uChars = hub_readl( HUB_RX_FIFO );
+                }
+
+                /* uChars may still be undefined if iCount == 0 */
+        }
+
+        return ( l_xFIFO.iCount != 0 );
+}
+
+
+/**
+ * ns_serial_getc - returns one character
+ */
+static int ns_serial_getc( void )
+{
+        u8 ucChar;
+
+        while( !ns_serial_tstc() ) {
+                /* do nothing, wait for incoming character */
+        }
+
+        l_xFIFO.iCount--;
+        ucChar = l_xFIFO.uChars & 0xff;
+        l_xFIFO.uChars >>= 8;
+        return ucChar;
+}
+
+/**
+ * ns_serial_tx_flush - returns when all characters have been flushed out
+ */
+static void ns_serial_tx_flush( void )
+{
+        while( !( hub_readl( HUB_INT ) & HUB_INT_TX_FIFO_EMPTY ) ) {
+                /* do nothing, wait for all characters to be sent */
+        }
+
+        /* wait for character to be really out */
+        while( !( hub_readl( UART_LINE_STAT ) & UART_LINE_STAT_TEMT ) ) {
+                /* do nothing, wait for character to be sent */
+        }
+}
+
+/* some stuff to provide serial0...serial3 */
+#define MK( port ) \
+static int ns_serial_start_##port( void ) \
+{ \
+        ns_serial_start( port ); \
+        return 0; \
+}
+MK( 0 )
+MK( 1 )
+MK( 2 )
+MK( 3 )
+#undef MK
+
+#define MK( port ) \
+        { .name     = "serial"#port,            \
+          .init     = ns_serial_start_##port,   \
+          .setbrg   = ns_serial_setbrg, \
+          .getc     = ns_serial_getc,   \
+          .tstc     = ns_serial_tstc,   \
+          .putc     = ns_serial_putc,   \
+          .puts     = ns_serial_puts,     \
+        }
+
+struct serial_device serial_ns921x_devices[ 4 ] = {
+        MK( 0 ),
+        MK( 1 ),
+        MK( 2 ),
+        MK( 3 )
+};
+#undef MK
+
+#endif  /* CFG_NS921X_UART */
diff --git a/arch/arm/cpu/arm926ejs/ns921x/timer.c b/arch/arm/cpu/arm926ejs/ns921x/timer.c
new file mode 100644
index 0000000..1e97801
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/ns921x/timer.c
@@ -0,0 +1,241 @@
+/*
+ *  cpu/arm926ejs/ns921x/timer.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ *               [2] cc9x/timer.c
+ *  !Descr:      U-Boot uses 4 timers.
+ *               Timer 0 provides a 1ms timer. This is for long
+ *               lasting test using get_timer().
+ *               Timer 1 is concated to Timer 0 and counts the ms since reset.
+ *               This gives a wraparound every 4 Mio. seconds or every 46 days
+ *               Therefore there is no SW encounting of wraparounds
+ *
+ *               Timer 2 and Timer 3 are also concatenated and used for udelay.
+ *               Timer 2 provides a pulse with about 1us resolution.
+ *               Timer 3 is then loaded with usec value of udelay and
+ *               polled for zero.
+ *               This gives quite exact udelays.
+ *               With 149.91360 MHz, udelay(1us) may be range from 1us to 1.7us
+ *
+ *               If only one timer is being used, divisions and multiplications
+ *               are needed. This makes it impossible to achieve
+ *               udelays < 25us because of the calculation overhead.
+ *
+ *               Calibrating an udelay loop is too unprecise, too. Depending on
+ *               the environment it may differ (DMA transfer, framebuffer
+ *               active, cache enabled/disabled ) etc.
+ *
+ *               A precise udelay brings advantage as U-Boot is also being used
+ *               for HW tests.
+*/
+
+#include <common.h>
+
+/* we are only compiled if CONFIG_NS9215 is present  */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+
+#define MS_TIMER		0       /* for ms */
+#define SYSTEM_TIMER		1       /* for get_timer */
+#define US_TIMER		2       /* timer in about 1us resolution */
+#define UDELAY_TIMER		3       /* loaded with usec delay */
+#define SYSTEM_TIMER_RELOAD    	0
+
+#define US_DISABLE \
+        ( SYS_TIMER_CTRL_TCS_M2   | \
+          SYS_TIMER_CTRL_TM_INT   | \
+          SYS_TIMER_CTRL_DOWN     | \
+          SYS_TIMER_CTRL_32       | \
+          SYS_TIMER_CTRL_RELOAD )
+
+#define UDELAY_DISABLE \
+        ( SYS_TIMER_CTRL_TCS_M2   | \
+          SYS_TIMER_CTRL_TM_CONC  | \
+          SYS_TIMER_CTRL_DOWN     | \
+          SYS_TIMER_CTRL_32 )
+
+#define US_ENABLE      ( US_DISABLE     | SYS_TIMER_CTRL_TE )
+#define UDELAY_ENABLE  ( UDELAY_DISABLE | SYS_TIMER_CTRL_TE )
+
+/**
+ * sys_clock_freq - determines system clock frequency based on PLL settings
+ * @return: clock in Hz
+ *
+ * System clock is only calculated on the first call
+ */
+int sys_clock_freq( void )
+{
+        static u32 uiSysClkFreq = 0;
+
+        if( !uiSysClkFreq ) {
+                /* calculate it only once */
+                static const u32 uiRefClk = NS_CPU_REF_CLOCK;
+                u32 uiPLL    = sys_readl( SYS_PLL );
+                u32 uiPLLVC0 = ( uiRefClk / ( SYS_PLL_NR( uiPLL ) + 1 ) ) *
+                        ( SYS_PLL_NF( uiPLL ) + 1 );
+
+                uiSysClkFreq  = uiPLLVC0 / ( SYS_PLL_OD( uiPLL ) + 1 );
+        }
+
+        return uiSysClkFreq;
+}
+
+/**
+ * ahb_clock_freq - determines ahb clock frequency based on clock config settings
+ * @return: clock in Hz
+ */
+int ahb_clock_freq( void )
+{
+        u32 uiClkScale = SYS_CLOCK_CSC( sys_readl( SYS_CLOCK ) );
+        u32 uiAHBClockFreq;
+
+        uiAHBClockFreq = ( sys_clock_freq() / 4 ) >> uiClkScale;
+
+        return uiAHBClockFreq;
+}
+
+/**
+ * cpu_clock_freq - determines cpu clock frequency based on clock config settings
+ * @return: clock in Hz
+ */
+int cpu_clock_freq( void )
+{
+        u32 uiClkFac = ( sys_readl( SYS_CLOCK ) & SYS_CLOCK_CCSEL ) ? 2 : 1;
+        u32 uiCPUClockFreq;
+
+        uiCPUClockFreq = ahb_clock_freq() * uiClkFac;
+
+        return uiCPUClockFreq;
+}
+
+/**
+ * read_timer - returns timer value
+ */
+static inline u32 read_timer( void )
+{
+        return sys_readl( SYS_TIMER_READ( SYSTEM_TIMER ) );
+}
+
+/**
+ * set_timer - sets the timestamp counter
+ */
+void set_timer( ulong t )
+{
+        sys_writel( t, SYS_TIMER_RELOAD( SYSTEM_TIMER ) );
+}
+
+void reset_timer( void )
+{
+        set_timer( 0 );
+}
+
+/**
+ * timer_init -
+ * @return: always 0 on ok
+ *
+ * initializes Timer 0 as ms timer and Timer 1 concatenated as system timer (for msdelay).
+ * initializes Timer 2 as us timer and Timer 3 concatenated for udelay
+ */
+int timer_init( void )
+{
+        u32 uiTicksPerMS = 0;
+
+        sys_writel( 0, SYS_TIMER_CTRL( SYSTEM_TIMER ) );  /* disable all */
+
+        /* configure ms timer */
+        uiTicksPerMS = ( ahb_clock_freq() * 2 ) / 1000;
+        sys_writel( uiTicksPerMS, SYS_TIMER_RELOAD( MS_TIMER ) );
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                    SYS_TIMER_CTRL_TCS_M2   |
+                    SYS_TIMER_CTRL_TM_INT   |
+                    SYS_TIMER_CTRL_DOWN     |
+                    SYS_TIMER_CTRL_32       |
+                    SYS_TIMER_CTRL_RELOAD,
+                    SYS_TIMER_CTRL( MS_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( MS_TIMER ) );
+
+        /* configure system timer, concated to ms timer */
+        reset_timer();
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                    SYS_TIMER_CTRL_TCS_M2   |  /* don't divide input clock*/
+                    SYS_TIMER_CTRL_TM_CONC  |
+                    SYS_TIMER_CTRL_TM_INT   |
+                    SYS_TIMER_CTRL_UP       |
+                    SYS_TIMER_CTRL_32       |
+                    SYS_TIMER_CTRL_RELOAD,
+                    SYS_TIMER_CTRL( SYSTEM_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( SYSTEM_TIMER ) );
+
+        /* configure us timer */
+        sys_writel( uiTicksPerMS / 1000, SYS_TIMER_RELOAD( US_TIMER ) );
+        sys_writel( US_DISABLE,
+                    SYS_TIMER_CTRL( US_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( US_TIMER ) );
+
+        /* configure udelay timer, concated to us timer */
+        sys_writel( UDELAY_DISABLE,
+                    SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( UDELAY_TIMER ) );
+
+        return 0;
+}
+
+ulong get_timer( ulong base )
+{
+	return read_timer() - base;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay( unsigned long usec )
+{
+        if( !usec )
+                return;
+
+        /* disable us and udelay timer. us should be kicked from a known state */
+        sys_writel( US_DISABLE, SYS_TIMER_CTRL( US_TIMER ) );
+        sys_writel( UDELAY_DISABLE, SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        /* load timer 3 with the intended udelay to wait */
+        sys_writel( usec, SYS_TIMER_RELOAD( UDELAY_TIMER ) );
+
+        /* kick them */
+
+        sys_writel( UDELAY_ENABLE, SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        sys_writel( US_ENABLE, SYS_TIMER_CTRL( US_TIMER ) );
+
+        while( sys_readl( SYS_TIMER_READ( UDELAY_TIMER ) ) ) {
+                /* wait for timer to expire, do nothing */
+        }
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks( void )
+{
+	return get_timer( 0 );
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk( void )
+{
+        return CFG_HZ;
+}
diff --git a/arch/arm/cpu/arm926ejs/start.S b/arch/arm/cpu/arm926ejs/start.S
index cf40ce1..4645087 100644
--- a/arch/arm/cpu/arm926ejs/start.S
+++ b/arch/arm/cpu/arm926ejs/start.S
@@ -40,6 +40,9 @@
 #elif defined(CONFIG_OMAP730)
 #include <./configs/omap730.h>
 #endif
+#if defined(CONFIG_JSCC9P9215)
+#include <./configs/digi_common.h>
+#endif
 
 /*
  *************************************************************************
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 0293348..7619594 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -44,6 +44,7 @@ COBJS-y	+= cache-cp15.o
 endif
 COBJS-y	+= interrupts.o
 COBJS-y	+= reset.o
+COBJS-y	+= arm9.o
 
 SRCS	:= $(GLSOBJS:.o=.S) $(GLCOBJS:.o=.c) \
 	   $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
diff --git a/arch/arm/lib/arm9.c b/arch/arm/lib/arm9.c
new file mode 100644
index 0000000..6a3f40a
--- /dev/null
+++ b/arch/arm/lib/arm9.c
@@ -0,0 +1,398 @@
+/*
+ *  lib_arm/arm9.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+ *  !References: [1] ARM Document DDI0198D_926_TRM.pdf
+ *               [2] Cache/TCM initialization (926Dhry)
+ *                   http://www.arm.com/support/downloads/info/2317.html
+ *               [3] DDI0151C_920T_TRM.pdf
+ *  !Descr: dcache on enables also the MMU for a flat memory model, otherwise
+ *          it can't work. The SDRAM
+ *          banks (reported by bdinfo) are configured for caching-writeback.
+ *          dcache off disables the MMU as well.
+ *          No specific commands have been added, so that the least set of
+ *          changes needs to be added to the booting mechanism.
+*/
+
+#include <common.h>
+
+#if defined(CONFIG_ARM926EJS) || defined(CONFIG_ARM920T)
+
+#include <command.h>
+
+/* return byte count of x in megabytes */
+#define MiB( x )	( (x) * 1024 * 1024 )
+
+/* See also ARM926EJ-S Technical Reference Manual */
+#define C1_MMU		(1<<0)		/* mmu off/on */
+#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
+#define C1_DC		(1<<2)		/* dcache off/on */
+
+#define C1_BIG_ENDIAN	(1<<7)		/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)		/* system protection */
+#define C1_ROM_PROT	(1<<9)		/* ROM protection */
+#define C1_IC		(1<<12)		/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)		/* location of vectors: low/high addresses */
+
+#define DOMAIN_USED	15      /* we use only one, no special meaning */
+
+/* domain control (p15,c3) */
+#define DOMAIN_CLIENT		1
+
+/* First Level Descriptor for Section, see [1] 3.2.
+ * Keep this low-level stuff in #define*/
+#define FL_SEC_MAX_ENTRIES	4096
+#define FL_SEC_ALIGNMENT	16384
+
+/* bit fields */
+#define FL_SEC_PAGE		0x00000002  /* section descriptor */
+#define FL_SEC_CACHE_B		0x00000004  /* Bufferable,[1] 4.3, Table 4-4 */
+#define FL_SEC_CACHE_C		0x00000008  /* Cacheable, [1] 4.3, Table 4-4 */
+#define FL_SEC_BACKWARD		0x00000010  /* for backward compatibility */
+#define FL_SEC_DOMAIN(x)	(( ( x ) & 0xf) << 5)
+#define FL_SEC_AP_CLIENT	0x00000400  /* Check against permission */
+#define FL_SEC_BASE(x)		(( ( x ) & (FL_SEC_MAX_ENTRIES - 1 )) << 20)  /* Base register starts at 20 */
+
+/* general settings for our flat memory model */
+#define FL_CFG_PAGE_COMMON	( FL_SEC_PAGE      | \
+               		          FL_SEC_BACKWARD  | \
+                                  FL_SEC_DOMAIN( DOMAIN_USED ) | \
+                                  FL_SEC_AP_CLIENT )
+
+/* No caching by default. Simulating no MMU behaviour */
+#define FL_CFG_PAGE_EXTERN	FL_CFG_PAGE_COMMON
+/* SDRAM is cached-writeback for best performance. Failures in DMA
+   handling are detected most easily */
+#define FL_CFG_PAGE_SDRAM	( FL_CFG_PAGE_COMMON | \
+                                  FL_SEC_CACHE_B     | \
+                                  FL_SEC_CACHE_C )
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ********** local variables ********** */
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* contains the Translation Table/First Level Descriptors
+ * Must be aligned on 16KiB boundary, [1] 3.2.1 */
+static uint32_t auiTranslationTable[ FL_SEC_MAX_ENTRIES ] __attribute__ ((aligned( FL_SEC_ALIGNMENT )));
+#endif
+/* ********** functions ********** */
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__(
+		"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
+		: "=r" (value)
+		:
+		: "memory");
+
+#ifdef MMU_DEBUG
+	printf ("p15/c1 is = %08lx\n", value);
+#endif
+	return value;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+#ifdef MMU_DEBUG
+	printf ("write %08lx to p15/c1\n", value);
+#endif
+	__asm__ __volatile__(
+		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
+		:
+		: "r" (value)
+		: "memory");
+
+	read_p15_c1 ();
+}
+#endif
+/* write to co-processor 15, register #2, (translation table base) */
+static inline void set_translation_table_base( void* pvBase )
+{
+	asm volatile (
+		"mcr	p15, 0, %0, c2, c0, 0   @ write it\n"
+		:
+		: "r" ( pvBase )
+		: "memory");
+}
+
+/* write to co-processor 15, register #3, (domain access control) */
+static inline void set_domain_ctrl( uint32_t uiDomain, uint32_t uiMode )
+{
+	asm volatile (
+		"mcr	p15, 0, %0, c3, c0, 0   @ write it\n"
+		:
+		: "r" ( (uiMode) << ((uiDomain) * 2 ) )
+		: "memory");
+}
+
+void dcache_flush( void )
+{
+        int iDummyForSync;
+
+        if( !dcache_status() )
+                /* no cache */
+                return;
+
+        /* [1], 9.3 */
+#if defined(CONFIG_ARM926EJS)
+	asm volatile(
+                /* clean all cache lines until there are no unclean ones */
+                "1:\n"
+                "mrc p15, 0, r15, c7, c10, 3\n"
+                "bne 1b\n" );
+      /* until no more are unclean */
+#elif defined(CONFIG_ARM920T)
+        /* [1], 2-23 A=6, S=3 from
+         * [3], 4.3 16KiB, 64 ways, 32bytes per line*/
+        /* from linux/arch/arm/mm/proc-arm920.S */
+        asm volatile(
+                "mov	r1, #(8 - 1) << 5	@ 8 segments\n"
+                "1:\n"
+                "orr	r3, r1, #(64 - 1) << 26 @ 64 entries\n"
+                "2:\n"
+                "mcr	p15, 0, r3, c7, c10, 2	@ clean D index\n"
+                "subs	r3, r3, #1 << 26\n"
+                "bcs	2b				@ entries 63 to 0\n"
+                "subs	r1, r1, #1 << 5\n"
+                "bcs	1b				@ segments 7 to 0\n"
+                :
+                :
+                : "r1", "r3"
+                );
+#else
+# error need flush
+#endif
+	asm volatile(
+                /* invalidate I cache */
+                "mcr	p15, 0, ip, c7, c5, 0\n"
+                /* drain writebuffer */
+                "mcr p15, 0, r0,  c7, c10, 4\n"
+                /* nonbuffered store to signal L2 world to synchronize */
+                "mov r0, #0\n"
+                "str r0, %0\n"
+                :
+                : "m" ( iDummyForSync )
+                : "r0"
+                );
+}
+
+void dcache_invalidate( void )
+{
+        if( !dcache_status() )
+                /* no cache */
+                return;
+
+        /* write back the current contents */
+        dcache_flush();
+
+#if defined(CONFIG_ARM926EJS)
+        {
+                int i = 0;
+                /* invalidate data cache only */
+                asm ("mcr p15, 0, %0, c7, c6, 0": :"r" (i));
+        }
+#elif defined(CONFIG_ARM920T)
+        asm volatile(
+                "mov	r1, #(8 - 1) << 5	@ 8 segments\n"
+                "1:\n"
+                "orr	r3, r1, #(64 - 1) << 26 @ 64 entries\n"
+                "2:\n"
+                "mcr	p15, 0, r3, c7, c14, 2	@ clean+invalidateD index\n"
+                "subs	r3, r3, #1 << 26\n"
+                "bcs	2b				@ entries 63 to 0\n"
+                "subs	r1, r1, #1 << 5\n"
+                "bcs	1b				@ segments 7 to 0\n"
+                :
+                :
+                : "r1", "r3"
+                );
+#else
+# error need some implementation
+#endif
+}
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* prepare the translation table so the MMU knows where to find the SDRAM */
+static void translation_table_init( void )
+{
+        uint32_t* puiSection = &auiTranslationTable[ 0 ];
+        int i;
+
+        /* where can the MMU find the first level descriptors/translat */
+        set_translation_table_base( puiSection );
+
+        /* create flat mapping, each page is 1 MiB */
+        for( i = 0; i < ARRAY_SIZE( auiTranslationTable ); i++, puiSection++) {
+                uint32_t uiCfgPage = FL_CFG_PAGE_EXTERN;
+                int j;
+
+                /* check whether we are in SDRAM and return setting */
+                for( j = 0; j < ARRAY_SIZE( gd->bd->bi_dram ); j++ ) {
+                        if( gd->bd->bi_dram[ j ].size &&
+                            ( MiB( i ) >= gd->bd->bi_dram[ j ].start ) &&
+                            ( MiB( i ) < ( gd->bd->bi_dram[ j ].start + gd->bd->bi_dram[ j ].size ) ) ) {
+                                uiCfgPage = FL_CFG_PAGE_SDRAM;
+                                break;
+                        }
+                } /* for( j = 0 ) */
+
+                *puiSection = uiCfgPage | FL_SEC_BASE( i );
+        }
+
+        /* configure how the domain can be used */
+        set_domain_ctrl( DOMAIN_USED, DOMAIN_CLIENT );
+}
+
+static void mmu_dcache_enable( void )
+{
+	int i = 0;
+        
+	/* set up the pages */
+        translation_table_init();
+
+	/* invalidate data cache only */
+	asm ("mcr p15, 0, %0, c7, c6, 0": :"r" (i));
+
+        /* enable mmu */
+        write_p15_c1( read_p15_c1() | ( C1_MMU | C1_DC ) );
+
+        /* two nops for the instruction pipeline. They are read unmapped, but
+         * executed with mapping enabled. There shouldn't be any problems if
+         * these ones are missed, but be safe */
+	asm volatile (
+                "mov r0,r0\n"
+                "mov r0, r0\n"
+                );
+}
+
+static void mmu_dcache_disable( void )
+{
+        dcache_invalidate();
+
+        write_p15_c1( read_p15_c1() & ~( C1_MMU | C1_DC ) );
+
+        /* two nops for the instruction pipeline. They are read mapped, but
+         * executed with mapping disabled. There shouldn't be any problems if
+         * these ones are missed, but be safe */
+	asm volatile (
+                "mov r0,r0\n"
+                "mov r0, r0\n"
+                );
+}
+
+static void cp_delay (void)
+{
+	volatile int i;
+
+	/* copro seems to need some delay between reading and writing */
+	for (i = 0; i < 100; i++);
+}
+#endif
+
+int cpu_init (void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux (void)
+{
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+
+	disable_interrupts ();
+
+        icache_disable();
+        dcache_disable();
+
+	return (0);
+}
+#ifndef CONFIG_NS9215
+int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts ();
+
+        serial_tx_flush();
+
+	reset_cpu (0);
+	/*NOTREACHED*/
+	return (0);
+}
+#endif
+
+void icache_enable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	ulong reg;
+
+	reg = read_p15_c1 ();		/* get control reg. */
+	cp_delay ();
+	write_p15_c1 (reg | C1_IC);
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+void icache_disable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_IC);
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+int icache_status (void)
+{
+	return (read_p15_c1 () & C1_IC) != 0;
+}
+
+void dcache_enable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	if(! dcache_status())
+		/* we need MMU for caching */
+		mmu_dcache_enable();
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+void dcache_disable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	if(dcache_status())
+		mmu_dcache_disable();
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+int dcache_status (void)
+{
+	return (read_p15_c1 () & C1_DC) != 0;
+}
+#endif /* (CONFIG_ARM926EJS) || defined(CONFIG_ARM920T) */
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
index 62ed54f..3b95585 100644
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -55,6 +55,7 @@ static void cache_disable(uint32_t cache_bit)
 }
 #endif
 
+#ifndef CONFIG_NS9215
 #ifdef CONFIG_SYS_NO_ICACHE
 void icache_enable (void)
 {
@@ -86,7 +87,9 @@ int icache_status(void)
 	return (get_cr() & CR_I) != 0;
 }
 #endif
+#endif
 
+#ifndef CONFIG_NS9215
 #ifdef CONFIG_SYS_NO_DCACHE
 void dcache_enable (void)
 {
@@ -118,3 +121,4 @@ int dcache_status(void)
 	return (get_cr() & CR_C) != 0;
 }
 #endif
+#endif
diff --git a/arch/arm/lib/cache.c b/arch/arm/lib/cache.c
index 61ee9d3..eab3719 100644
--- a/arch/arm/lib/cache.c
+++ b/arch/arm/lib/cache.c
@@ -25,6 +25,19 @@
 
 #include <common.h>
 
+#if defined(CONFIG_ARM926EJS) || defined(CONFIG_ARM920T)
+# define HAVE_DCACHE
+void dcache_invalidate( void );
+void dcache_flush( void );
+#endif
+
+void  flush_cache_all( void )
+{
+#ifdef HAVE_DCACHE
+        dcache_flush();
+#endif
+}
+
 void  flush_cache (unsigned long dummy1, unsigned long dummy2)
 {
 #ifdef CONFIG_OMAP2420
@@ -32,5 +45,14 @@ void  flush_cache (unsigned long dummy1, unsigned long dummy2)
 
 	arm1136_cache_flush();
 #endif
+
+        flush_cache_all();
 	return;
 }
+
+void  invalidate_cache_all( void )
+{
+#ifdef HAVE_DCACHE
+        dcache_invalidate();
+#endif
+}
diff --git a/board/cc9c/Makefile b/board/cc9c/Makefile
new file mode 100644
index 0000000..99bd286
--- /dev/null
+++ b/board/cc9c/Makefile
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+DIGI_DIR = $(TOPDIR)/common/digi
+DIGI_BSP = -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+CPPFLAGS += $(DIGI_BSP)
+
+OBJS	:= cc9c.o
+SOBJS	:= platform.o nandboot.o
+
+$(LIB):	$(OBJS) $(SOBJS) $(LIB_BIG)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+$(LIB_BIG):	$(BIGOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)  $(BIGOBJS)
+
+distclean:	clean
+	rm -f $(LIB) $(LIB_BIG) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/cc9c/cc9c.c b/board/cc9c/cc9c.c
new file mode 100644
index 0000000..82def84
--- /dev/null
+++ b/board/cc9c/cc9c.c
@@ -0,0 +1,354 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Copyright (C) 2005 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ * Jonas Dietsche <jdietsche@fsforth.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+ *  !Descr:
+ *  !References: [1] NS9360 HW Reference Manual Rev. 03/2006
+ *               [2] Email "new cc9c -05 deltas" from Bill Kumpf on 01/07/07
+*/
+
+#include <common.h>
+
+#include <ns9750_bbus.h>
+#include <ns9750_sys.h>
+#include <ns9750_mem.h>
+#include <nvram.h>
+#include <net.h>
+
+#ifdef CONFIG_STATUS_LED
+# include <status_led.h>
+static int status_led_fail = 0;
+#endif /* CONFIG_STATUS_LED */
+
+#include <env.h>
+#include <partition.h>
+#include "spi_ver.h"
+
+#define BOOTSTRAP_CS		0x3
+#define BOOTSTRAP_BASE_ADDRESS	0x30000000
+#define WCE_BOOTARGS_ADDR	0x8000
+
+static uint8_t ccx9c_get_bootstrapping( void );
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+extern void run_auto_script(void);
+#endif
+
+/***********************************************************************
+ * @Function: cc9c_flash_init
+ * @Return: Nothing
+ * @Descr: Configures CS1 for NAND flash access
+ ***********************************************************************/
+void cc9c_flash_init (void)
+{
+#ifndef CONFIG_CC9C_NAND
+	/* setup CS1 */
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_BASE( 1 ) ) = 0x50000000;
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_MASK( 1 ) ) = 0xff000001;
+	*get_mem_reg_addr( NS9750_MEM_STAT_CFG( 1 ) ) = NS9750_MEM_STAT_CFG_MW_16 | NS9750_MEM_STAT_CFG_PB;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WAIT_WEN( 1 ) ) = 0x2;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WAIT_OEN( 1 ) ) = 0x2;
+	*get_mem_reg_addr( NS9750_MEM_STAT_RD( 1 ) ) = 0x6;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WR( 1 ) ) = 0x6;
+#endif
+}
+
+/***********************************************************************
+ * @Function: get_sdram_bank_size
+ * @Return: The SDRAM size for the especified bank
+ * @Descr: Returns the sdram size for the especified bank. If the SPI
+ *         loader is used, that information is read from the CS
+ *         configuration.
+ ***********************************************************************/
+static ulong get_sdram_bank_size (int bank)
+{
+	ulong base;
+	ulong size = 0;
+
+	switch (bank) {
+		case 0:
+#ifdef CONFIG_CC9C_NAND
+			base = (*get_sys_reg_addr(NS9750_SYS_CS_DYN_BASE(0)) & 0xFFFFF000);
+			size = ~(*get_sys_reg_addr(NS9750_SYS_CS_DYN_MASK(0)) & 0xFFFFF000) + 1;
+			base += size;
+			if ((*get_sys_reg_addr(NS9750_SYS_CS_DYN_BASE(1)) & 0xFFFFF000) == base)
+				size += size;	/* second bank equipped */
+#else
+			size = PHYS_SDRAM_1_SIZE;
+#endif
+			break;
+		default:	break;
+	}
+	return size;
+}
+
+
+/***********************************************************************
+ * @Function: dram_init
+ * @Return: 0 always
+ * @Descr: Initializes the board SDRAM information
+ ***********************************************************************/
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = get_sdram_bank_size(0);
+
+#if CONFIG_NR_DRAM_BANKS > 1
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+#endif
+
+        /* now we now the memory size, enable dcache */
+	dcache_enable();
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: cc9c_gpio_init
+ * @Return: Nothing
+ * @Descr: Processor GPIO initialization.
+ ***********************************************************************/
+void cc9c_gpio_init (void)
+{
+#if defined(CONFIG_USER_KEY)
+	/* Configure Key1 and Key2 as inputs */
+	set_gpio_cfg_reg_val( USER_KEY1_GPIO, 
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_INPUT);
+	set_gpio_cfg_reg_val( USER_KEY2_GPIO,
+		       	NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_INPUT);
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CONFIG_STATUS_LED)
+	/* Configure Led1 and Led2 as outputs */
+	set_gpio_cfg_reg_val( USER_LED1_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_OUTPUT);
+	set_gpio_cfg_reg_val( USER_LED2_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_OUTPUT);
+	/* Set outputs to off */
+	__led_set( USER_LED1_GPIO, STATUS_LED_OFF );
+	__led_set( USER_LED2_GPIO, STATUS_LED_OFF );
+#endif
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(ENABLE_CONSOLE_GPIO)
+	set_gpio_cfg_reg_val( ENABLE_CONSOLE_GPIO, NS9750_GPIO_CFG_FUNC_GPIO |
+			NS9750_GPIO_CFG_INPUT);
+#endif
+}
+
+/***********************************************************************
+ * @Function: board_init
+ * @Return: 0
+ * @Descr: Enables BBUS modules and other devices
+ ***********************************************************************/
+int board_init( void ) {
+	DECLARE_GLOBAL_DATA_PTR;
+
+	icache_enable();
+        /* dcache is enabled after dram has been initialized */
+
+	/* Active BBUS modules */
+	*get_bbus_reg_addr( NS9750_BBUS_MASTER_RESET ) = 0;
+
+	gd->bd->bi_arch_number = machine_arch_type;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	cc9c_gpio_init();
+
+#if defined(CONFIG_STATUS_LED)
+	status_led_set(STATUS_LED_BOOT,STATUS_LED_ON);
+#endif /* CONFIG_STATUS_LED */
+
+/* this speeds up your boot a quite a bit.  However to make it
+ *  work, you need make sure your kernel startup flush bug is fixed.
+ *  ... rkw ...
+ */
+	cc9c_flash_init();
+
+	return 0;
+}
+
+
+
+#ifdef BOARD_LATE_INIT
+
+/***********************************************************************
+ * @Function: cc9c_run_user_key_commands
+ * @Return: Nothing
+ * @Descr: Runs key1 | key2 macro commands, if the corresponding user
+ *         keys are pressed.
+ ***********************************************************************/
+void cc9c_run_user_key_commands (void)
+{
+#if defined(CONFIG_USER_KEY)
+	char cmd[10];
+
+	if (get_gpio_stat(USER_KEY1_GPIO) == 0) {
+		printf("\nUser Key 1 pressed\n");
+		if (getenv("key1") != NULL) {
+			sprintf(cmd, "run key1");
+			run_command(cmd, 0);
+		}
+	}
+	if (get_gpio_stat(USER_KEY2_GPIO) == 0) {
+		printf("\nUser Key 2 pressed\n");
+		if (getenv("key2") != NULL) {
+			sprintf(cmd, "run key2");
+			run_command(cmd, 0);
+		}
+	}
+#endif /* CONFIG_USER_KEY */
+}
+
+
+/***********************************************************************
+ * @Function: board_late_init
+ * @Return: 0
+ * @Descr: Late initialitation routines.
+ ***********************************************************************/
+int board_late_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	nv_critical_t *pNvram;
+	volatile uint32_t *wce_bootargs = (volatile uint32_t *)WCE_BOOTARGS_ADDR;
+
+	printf( "CPU:   %s @%i.%iMHz\n", CPU, CPU_CLK_FREQ/1000000 , CPU_CLK_FREQ %1000000);
+
+	printf( "Strap: 0x%02x\n", ccx9c_get_bootstrapping() );
+
+#ifdef CONFIG_HAVE_SPI_LOADER
+        ns9xxx_print_spi_version();
+#endif  /* CONFIG_HAVE_SPI_LOADER */
+
+	if (NvCriticalGet(&pNvram)) {
+		/* Pass location of environment in memory to OS through bi */
+		gd->bd->nvram_addr = (unsigned long)pNvram;
+	}
+
+	/* copy bdinfo to start of boot-parameter block */
+ 	memcpy((int*)gd->bd->bi_boot_params, gd->bd, sizeof(bd_t));
+
+	/* Clean Windows CE bootargs signature at address WCE_BOOTARGS_ADDR
+	 * This is necessary to ensure WinCE knows when is in debug mode
+	 * Eboot writes the magic signature on that address */
+	*wce_bootargs = 0;
+
+        eth_use_mac_from_env( gd->bd );
+
+	/* Run keyX commands */
+	cc9c_run_user_key_commands();
+
+
+#if defined(CONFIG_STATUS_LED)
+	if (!status_led_fail) {
+		status_led_set(STATUS_LED_BOOT,STATUS_LED_OFF);
+		status_led_fail = 0;
+  	}
+#endif /* CONFIG_STATUS_LED */
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+	run_auto_script();
+#endif
+
+	return 0;
+}
+#endif /*BOARD_LATE_INIT*/
+
+/***********************************************************************
+ * @Function: ccx9c_get_bootstrapping
+ * @Return:   bootstraping of CCX9C Module
+ * @Descr:    BOOTSTRAP_CS is not routed extern. So we use it to determine the
+ *            pull-up/downed bootstrap info.
+ ***********************************************************************/
+
+static uint8_t ccx9c_get_bootstrapping( void )
+{
+        uint8_t ucBootStrapping = 0;
+
+        /* access it as mentioned in [2] */
+	*get_mem_reg_addr( NS9750_MEM_STAT_CFG( BOOTSTRAP_CS ) ) =
+                ( NS9750_MEM_STAT_CFG_PSMC |
+                  NS9750_MEM_STAT_CFG_BSMC |
+                  NS9750_MEM_STAT_CFG_MW_32 );
+        /* we need a lot of waitstates to have bus
+         * settled because some lines are floating */
+        *get_mem_reg_addr( NS9750_MEM_STAT_RD( BOOTSTRAP_CS ) ) = 0xf;
+
+        /* set CS3 to defaults, [1] p.164 */
+
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_BASE( BOOTSTRAP_CS ) ) =
+                BOOTSTRAP_BASE_ADDRESS;
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_MASK( BOOTSTRAP_CS ) ) =
+                0xf0000001;
+
+        ucBootStrapping = ((*(volatile uint32_t*) BOOTSTRAP_BASE_ADDRESS) >> 24) & 0xff;
+
+        /* we don't need CS3 any longer, disable it */
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_MASK( BOOTSTRAP_CS ) ) = 0xf0000000;
+
+        return ucBootStrapping;
+}
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+void show_boot_progress (int status) {
+#if defined(CONFIG_STATUS_LED)
+	if (status < 0) {
+        	/* ready to transfer to kernel, make sure LED is proper state */
+        	status_led_set(STATUS_LED_BOOT,STATUS_LED_ON);
+        	status_led_fail = 1;
+	}
+#endif /* CONFIG_STATUS_LED */
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+#if defined(CONFIG_SILENT_CONSOLE)
+int test_console_gpio (void)
+{
+#if defined(ENABLE_CONSOLE_GPIO) && defined(CONSOLE_ENABLE_GPIO_STATE)
+	if (get_gpio_stat(ENABLE_CONSOLE_GPIO) == CONSOLE_ENABLE_GPIO_STATE)
+		return 1;
+	else
+		return 0;
+#else
+	return 0;
+#endif
+}
+#endif
diff --git a/board/cc9c/config.mk b/board/cc9c/config.mk
new file mode 100644
index 0000000..0252886
--- /dev/null
+++ b/board/cc9c/config.mk
@@ -0,0 +1,14 @@
+#######################################################################
+#
+# Copyright (C) 2004 by FS Forth-Systeme GmbH.
+# Markus Pietrek <mpietrek@fsforth.de>
+#
+# @TODO
+# Linux-Kernel is expected to be at 0000'8000, entry 0000'8000
+# optionally with a ramdisk at 0080'0000
+#
+# we load ourself to 0010'0000
+
+
+TEXT_BASE = 0x00100000
+DIGI_BOARD = y
diff --git a/board/cc9c/nandboot.S b/board/cc9c/nandboot.S
new file mode 100644
index 0000000..6cbe9af
--- /dev/null
+++ b/board/cc9c/nandboot.S
@@ -0,0 +1,724 @@
+/***********************************************************************
+ *
+ *  Copyright (C) 2006 by FS Forth-Systeme GmbH,
+ *                     a DIGI International Company
+ *  All rights reserved.
+ *
+ *  @Author: Joachim Jaeger
+ *  @Descr: Supports small and large page size with bad-block management and ECC
+ *  @References: [1] nandboot.S for A9M24x0
+ *	         [2] Toshiba's NAND Flash Applications Design Guide Rev. 1.0
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_BOOT_NAND
+
+.globl _nandboot
+
+/***********************************************************************
+ * @Function: _nandboot (unsigned int unStartBlock,
+ *			  unsigned int* punDest, unsigned int unLength)
+ * @Return: always, check for bad blocks and verify ECC bytes
+ * @Descr: copies blocks from NAND to RAM (punDest) until unLength data has been
+ *	   read. unStartBlock
+ *	   autodetects small and large NAND Flashes
+ *	   blinks in an endless loop, if NAND not detected
+ ***********************************************************************/
+
+#define rNF_BASE	CFG_NAND_BASE
+
+#define	oNF_CMD		(rNF_BASE + NAND_FLASH_CMD)
+#define oNF_ADDR	(rNF_BASE + NAND_FLASH_ADR)
+#define oNF_DATA	(rNF_BASE + NAND_FLASH_DAT)
+
+#define oNF_REG_CMD	oNF_CMD
+#define oNF_GPIO_RB	(0x90600040)	@ address of Ready/Busy GPIO
+
+#define vNF_GPIO_RB	(0x08)		@ Ready/Busy GPIO
+#define vNF_BS_LARGE	(0x20000)	@ large block size
+#define vNF_BS_SMALL	(0x4000)	@ small block size
+#define vNF_PS_LARGE	(0x800)		@ large page size
+#define vNF_PS_SMALL	(0x200)		@ small page size
+#define vNF_OOB_LARGE	(0x40)		@ large oob size
+#define vNF_OOB_SMALL	(0x10)		@ small oob size
+#define vNF_BB_POS_L	(0x00)		@ bad block position for large NAND
+#define vNF_BB_POS_S	(0x05)		@ bad block position for small NAND
+#define vNF_CMD_READ0	(0x00)		@ command READ0
+#define vNF_CMD_READS	(0x30)		@ command READ start for large NAND
+#define vNF_CMD_READO	(0x50)		@ command READ OOB for small NAND
+#define vNF_CMD_READID	(0x90)		@ command READ ID
+#define vNF_CMD_RESET	(0xff)		@ command RESET
+#define vNF_CMD_STAT	(0x70)		@ command STATUS
+#define vNF_WAIT	(0xf0)		@ counter for wait loop
+#define vNF_WAIT_RB	(0x0f)		@ counter for ready/busy loop
+#define vNF_CHECK_BAD	(0xff)		@ value to check if block is bad
+
+#define oNF_SP_ADDR	(0x1000)	@ address for SP at end of 4k
+#define vNF_SP_SIZE	(0x40)		@ size for SP (64 Bytes)
+#define vNF_ECC_SIZE	(0x18)		@ size for ECC data (24 Bytes)
+#define vNF_ECC_STEP_S	(0x06)		@ 6 ECC bytes for small NAND
+#define vNF_ECC_STEP_L	(0x18)		@ 24 ECC bytes for large NAND
+#define vNF_ECC_POS	(0x28)		@ start position of ECC data (24 Bytes)
+#define oNF_ECC_DAT_C	(0xe60)		@ calculated ECC data (oNF_SP_ADDR-vNF_SP_SIZE-vNF_ECC_SIZE)
+#define oNF_ECC_DAT_R	(0xe20)		@ read ECC data (oNF_ECC_DAT_C-64bytes)
+#define vNF_ECC_ERROR	(0xffffffff)	@ return value for uncorrectable ECC error
+#define vNF_ECC_DATA	(0x100)		@ ECC is calculated for 256 data bytes
+#define vNF_ECC_BYTES	(0x03)		@ 3 ECC bytes are calculated for 256 data bytes
+#define oNF_ECC_INFO	NAND_ECC_INFO	@ Counter for correctable errors
+
+
+_nandboot:
+	mov	r4, lr
+	ldr	sp, =oNF_SP_ADDR	@ set up SP
+
+	stmdb   sp!, {r4}
+
+	ldr	r3, =oNF_ECC_INFO	@ reset ECC error counter
+	mov	r4, #0x00
+	str	r4, [r3]
+
+	mov	r4, #vNF_CMD_RESET	@ send reset to NAND
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	mov	r3, #0
+2:	mov	r4, #0			@ wait at least 5us before next command
+1:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	1b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	2b
+
+	mov	r4, #vNF_CMD_READID	@ Read ID command
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+        
+	mov	r4, #0x00	        @ ADDR 0
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+
+	ldr	r3, =oNF_DATA
+	ldrb	r4, [r3]		@ get manufacturer ID
+        
+	cmp	r4, #0x20		@ STM
+        cmpne	r4, #0x2C		@ Micron
+        cmpne	r4, #0x98		@ Toshiba
+        cmpne	r4, #0xEC		@ Samsung
+        mov	r8, r4			@ save value for debuging
+        mov	r9, #0x55000000		@ initialize the chip ID register
+        bne	ErrorNand		@ unknown ID
+
+	ldrb	r4, [r3]		@ get chip ID
+        /* check for chips with 512 byte sectors */
+        cmp	r4, #0x33		@ 16 MByte, 1.8V
+        cmpne	r4, #0x73		@ 16 MByte
+        cmpne	r4, #0x35		@ 32 MByte, 1.8V
+        cmpne	r4, #0x75		@ 32 MByte
+        cmpne	r4, #0x36		@ 64 MByte, 1.8V
+        cmpne	r4, #0x76		@ 64 MByte
+        cmpne	r4, #0x39		@ 128 MByte, 1.8V
+        cmpne	r4, #0x78		@ 128 MByte, 1.8V, Samsung only
+        cmpne	r4, #0x79		@ 128 MByte
+        cmpne	r4, #0x71		@ 256 MByte
+        moveq	r6, #vNF_PS_SMALL	@ small page size
+        beq	_nandboot_read_page
+
+        /* check for chips with 2 kbyte sectors */
+        cmp	r4, #0xA2		@ 64 MByte, 1.8V
+        cmpne	r4, #0xF2		@ 64 MByte
+        cmpne	r4, #0xA1		@ 128 MByte, 1.8V
+        cmpne	r4, #0xF1		@ 128 MByte
+        cmpne	r4, #0xAA		@ 256 MByte, 1.8V
+        cmpne	r4, #0xDA		@ 256 MByte
+        cmpne	r4, #0xAC		@ 512 MByte, 1.8V
+        cmpne	r4, #0xDC		@ 512 MByte
+        cmpne	r4, #0xA3		@ 1 GByte, 1.8V
+        cmpne	r4, #0xD3		@ 1 GByte
+        moveq	r6, #vNF_PS_LARGE	@ large page size
+        mov	r9, r4			@ save value for debuging
+        beq	_nandboot_read_page
+ErrorNand:
+/* Debug Blink-LED */
+	ldr	r0, =0x90600104
+        ldr	r1, [r0]		@ load control register
+        ldr	r2, =0x0000F000		@ AND mask, 4 bits per GPIO
+        bic	r1, r1,r2
+        ldr	r2, =0x0000B000		@ OR mask, GPIO with output
+        orr	r1, r1,r2
+        str	r1, [r0]		@ GPIO67 as GPIO output
+300:
+	ldr	r0, =0x90600120
+        ldr	r1, [r0]		@ load control register
+        ldr	r2, =0x00000008
+        bic	r1, r1,r2
+        str	r1, [r0]		@ GPIO67 with high level output
+
+	ldr	r0, =0x200000
+100:
+	mov	r1, r1
+	subs	r0, r0, #1
+	bne	100b
+
+        ldr	r0, =0x90600120
+        ldr	r1, [r0]		@ load control register
+        ldr	r2, =0x00000008		@ OR mask, GPIO high
+        orr	r1, r1,r2
+        str	r1, [r0]		@ GPIO67 with high level output
+
+	ldr	r0, =0x200000
+200:
+	mov	r1, r1
+	subs	r0, r0, #1
+	bne	200b
+
+	b	300b
+/* end blink LED */
+
+_nandboot_read_page:
+	@ read one page
+	mov	ip, lr
+	bl	_nandboot_bb_check	@ first check, if block is bad
+	mov	lr, ip
+
+	mov	r4, #0			@ wait
+3:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	3b
+
+	mov	r4, #vNF_CMD_READ0	@ READ0
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	cmp	r6, #vNF_PS_SMALL
+	beq	4f
+/*NAND_LARGE*/
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000FF 	@ clear upper nibble and start of sector
+	strb	r4, [r3]		@ write A8..11
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3]		@ write A11..18
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A19..26
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A27..31
+
+	mov	r4, #vNF_CMD_READS	@ READ start
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	b	5f
+4:
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #9		@ A8 not relevant here
+	strb	r4, [r3]		@ write A9..16
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A17..24
+  	mov	r4, r4, lsr #8
+        bic	r4, r4, #0x000000FC 	@ clear A2..7
+	strb	r4, [r3]		@ write A25..26
+5:
+	mov	r3, #0
+7:	mov	r4, #0			@ wait
+6:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	6b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	7b
+
+	@ copy always one page size
+	@ r2 is number of bytes overall left after this copy
+	@ r5 is number in page left
+	cmp	r2, r6
+	subge	r2, r2, r6
+	movlt	r2, #0
+	mov	r5, r6
+	ldr	r3, =oNF_DATA
+
+_nandboot_page_copy_to_mem:
+	@ copy page to memory
+	cmp	r5, #0
+	beq	8f
+	sub	r5, r5, #1
+
+	ldrb	r4, [r3]
+	strb	r4, [r1], #1
+	b	_nandboot_page_copy_to_mem
+8:
+	mov	ip, lr
+	bl	_nandboot_calculate_ecc
+	mov	lr, ip
+
+	@ now we check ECC
+	stmdb   sp!, {r0 - r6}
+	mov	r4, r1			@ keep pointer
+	sub	r1, r1, r6		@ set pointer to start of page
+	ldr	r2, =oNF_ECC_DAT_R	@ pointer to ECC data read
+	cmp	r6, #vNF_PS_SMALL
+	beq	_ecc_pos_ok
+	add	r2, r2, #vNF_ECC_POS	@ correct pointer for large NAND Flash
+_ecc_pos_ok:
+	ldr	r3, =oNF_ECC_DAT_C	@ pointer to ECC data calculated
+
+_correct_loop:
+	mov	ip, lr
+	bl	_nandboot_correct_data
+	mov	lr, ip
+
+_ecc_error:
+	cmp	r0, #vNF_ECC_ERROR	@ uncorrectable ECC error
+	beq	_ecc_error
+
+	ldr	r5, =oNF_ECC_INFO
+	ldr	r6, [r5]
+	add	r6, r6, r0		@ count correctable ECC errors
+	str	r6, [r5]
+
+	add	r1, r1, #vNF_ECC_DATA
+	add	r2, r2, #vNF_ECC_BYTES
+	add	r3, r3, #vNF_ECC_BYTES
+	cmp	r1, r4
+	bne	_correct_loop
+
+	ldmia   sp!, {r0 - r6}
+
+	cmp	r2, #0
+	addne	r0, r0, r6          @ select next page
+	bne	_nandboot_read_page
+
+	@ finished, all bytes read
+	ldmia   sp!, {lr}
+	mov	pc, lr
+
+
+/***********************************************************************
+ * @Function: _nandboot_bb_check
+ *
+ * @Descr: checks 1st page of block, if block is bad
+ *	   stores ECC bytes to RAM
+ ***********************************************************************/
+_nandboot_bb_check:
+	stmdb   sp!, {r1, r2, r7 - r9}
+_bb_check_loop:
+	mov	r8, #0x00
+	cmp	r6, #vNF_PS_SMALL
+	beq	19f
+/*NAND_LARGE*/
+	mov	r5, #vNF_BS_LARGE	@ block size
+	mov	r7, #vNF_OOB_LARGE	@ oob size
+	mov	r9, #vNF_BB_POS_L	@ bad block position
+	mov	r4, r0		        @ ADDR
+	cmp	r4, #0x00
+	beq	20f
+	mov	r8, r4, lsl #15		@ we only check 1st page
+	b	20f
+19:
+	mov	r5, #vNF_BS_SMALL	@ block size
+	mov	r7, #vNF_OOB_SMALL	@ oob size
+	mov	r9, #vNF_BB_POS_S	@ bad block position
+	mov	r4, r0		        @ ADDR
+	cmp	r4, #0x00
+	beq	20f
+	mov	r8, r4, lsl #18		@ we only check 1st page
+20:
+	mov	r4, #0			@ wait
+13:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	13b
+
+	mov	r4, #vNF_CMD_READO	@ READ OOB for small NAND
+	cmp	r6, #vNF_PS_SMALL
+	beq	23f
+	mov	r4, #vNF_CMD_READ0	@ READ0
+23:
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	cmp	r6, #vNF_PS_SMALL
+	beq	9f
+/*NAND_LARGE*/
+	mov	r4, r0		        @ ADDR
+	orr	r4, r4, r6
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000F7 	@ clear upper nibble and start of sector
+	strb	r4, [r3]		@ write A8..11
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3]		@ write A11..18
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A19..26
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A27..31
+
+	mov	r4, #vNF_CMD_READS	@ READ start
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	b	10f
+9:
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #9		@ A8 not relevant here
+	strb	r4, [r3]		@ write A9..16
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A17..24
+  	mov	r4, r4, lsr #8
+        bic	r4, r4, #0x000000FC 	@ clear A2..7
+	strb	r4, [r3]		@ write A25..26
+10:
+	mov	r3, #0
+12:	mov	r4, #0			@ wait
+11:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	11b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	12b
+
+	ldr	r1, =oNF_ECC_DAT_R
+	mov	r2, #0x00
+21:
+	ldr	r3, =oNF_DATA
+	ldrb	r4, [r3]
+	strb	r4, [r1, r2]		@ store ECC bytes
+	add	r2, r2, #1
+	cmp	r2, r7			@ read all oob data
+	bne	21b
+
+	cmp	r8, #0x00		@ 1st page of block?
+	bne	22f
+	ldrb	r4, [r1, r9]		@ read bad block info
+	cmp	r4, #vNF_CHECK_BAD	@ bad block?
+	beq	22f
+	add	r0, r0, r5		@ next block
+	b	_bb_check_loop		@ check new block
+22:
+
+	cmp	r9, #vNF_BB_POS_L
+	beq	_bb_check_out
+	ldrb	r4, [r1, #6]		@ move ECC4 to the correct place
+	strb	r4, [r1, #4]
+	ldrb	r4, [r1, #7]		@ move ECC5 to the correct place
+	strb	r4, [r1, #5]
+
+_bb_check_out:
+	ldmia   sp!, {r1, r2, r7 - r9}
+
+	mov	pc, lr
+
+/***********************************************************************
+ * @Function: _nandboot_calculate_ecc
+ *
+ * @Descr: calculates ECC values of read page
+ *	   stores ECC bytes to RAM
+ *	   R1 = raw data read from NAND
+ ***********************************************************************/
+_nandboot_calculate_ecc:
+	stmdb   sp!, {r0 - r7, lr}
+
+	mov	r7, #0
+	sub	r6, r1, r6		@ set pointer to start of page
+	ldr	r4, =oNF_ECC_DAT_C	@ pointer to ECC data
+
+_calc_loop:
+	mov     lr, #0			@ initialize all 0x0
+	strb    lr, [r4, r7]
+	add	r7, r7, #1
+	strb    lr, [r4, r7]
+	add	r7, r7, #1
+	strb    lr, [r4, r7]
+	mov     r5, lr
+	mov     r0, lr
+	mov     ip, lr
+30:	ldrb    r2, [r6, ip]
+	adr     r3, _nandboot_ecc_tbl	@ pointer to ECC table
+	ldrb    r2, [r3, r2]
+	mvn     r3, ip
+	tst     r2, #64
+	eor     r1, r0, r3
+	eor     r3, lr, ip
+	add     ip, ip, #1
+	and     r2, r2, #63
+	andne   lr, r3, #255
+	andne   r0, r1, #255
+	cmp     ip, #255
+	eor     r5, r5, r2
+	ble     30b
+	mov     r1, lr
+	mov     r2, r4
+	sub	r7, r7, #2
+	add	r2, r2, r7
+	bl      _nandboot_trans_result
+	ldrb    r2, [r4, r7]
+	mvn     r2, r2
+	strb    r2, [r4, r7]
+
+	add	r7, r7, #1
+	ldrb    r1, [r4, r7]
+	mvn     r1, r1
+	strb    r1, [r4, r7]
+
+	add	r7, r7, #1
+	mvn     r3, r5
+	mov     r3, r3, lsl #2
+	orr     r3, r3, #3
+	mov     r0, #0
+	strb    r3, [r4, r7]
+
+	mov	r2, #vNF_ECC_STEP_S
+	cmp	r6, #vNF_PS_SMALL
+	beq	31f
+/*NAND_LARGE*/
+	mov	r2, #vNF_ECC_STEP_L
+31:
+	add	r6, r6, #vNF_ECC_DATA
+	add	r7, r7, #1
+	cmp	r7, r2
+	bne	_calc_loop
+
+	ldmia   sp!, {r0 - r7, lr}
+
+	mov	pc, lr
+
+/***********************************************************************
+ * @Function: _nandboot_trans_result
+ *
+ * @Descr: helper function to calculate ECC values
+ *	   stores ECC bytes to RAM
+ ***********************************************************************/
+_nandboot_trans_result:
+	stmdb   sp!, {r0 - r6, lr}
+
+	mov     r5, #0
+	mov     r4, #128
+	mov     r6, r2
+	and     r0, r0, #255
+	and     r1, r1, #255
+	mov     ip, r4
+	mov     r2, r5
+	mov     r3, r5
+40:	tst     r1, r4
+	orrne   r2, r2, ip
+	add     r3, r3, #1
+	mov     ip, ip, lsr #1
+	tst     r0, r4
+	orr     lr, r2, ip
+	and     r3, r3, #255
+	andne   r2, lr, #255
+	cmp     r3, #3
+	mov     r4, r4, lsr #1
+	mov     ip, ip, lsr #1
+	bls     40b
+	mov     ip, #128
+	mov     r3, #0
+41:	tst     r1, r4
+	orrne   r5, r5, ip
+	add     r3, r3, #1
+	mov     ip, ip, lsr #1
+	tst     r0, r4
+	orr     lr, r5, ip
+	and     r3, r3, #255
+	andne   r5, lr, #255
+	cmp     r3, #3
+	mov     r4, r4, lsr #1
+	mov     ip, ip, lsr #1
+	strhib  r5, [r6, #1]
+	strhib  r2, [r6]
+	ldmhiia sp!, {r0 - r6, pc}
+	b       41b
+
+/***********************************************************************
+ * @Table: _nandboot_ecc_tbl
+ *
+ * @Descr: precalculated 256-way 1 byte column parity
+ *
+ ***********************************************************************/
+_nandboot_ecc_tbl:
+        .byte 0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A @/* index 0x00 */
+        .byte 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00
+        .byte 0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F
+        .byte 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65
+
+        .byte 0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C @/* index 0x20 */
+        .byte 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66
+        .byte 0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59
+        .byte 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03
+
+        .byte 0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33 @/* index 0x40 */
+        .byte 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69
+        .byte 0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56
+        .byte 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C
+
+        .byte 0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55 @/* index 0x60 */
+        .byte 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F
+        .byte 0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30
+        .byte 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A
+
+        .byte 0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30 @/* index 0x80 */
+        .byte 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A
+        .byte 0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55
+        .byte 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F
+
+        .byte 0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56 @/* index 0xA0 */
+        .byte 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C
+        .byte 0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33
+        .byte 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69
+
+        .byte 0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59 @/* index 0xC0 */
+        .byte 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03
+        .byte 0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C
+        .byte 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66
+
+        .byte 0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F @/* index 0xE0 */
+        .byte 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65
+        .byte 0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A
+        .byte 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00
+
+/***********************************************************************
+ * @Function: _nandboot_correct_data
+ *
+ * @Descr: compares calculated and read ECC values
+ *	   correct error if possible
+ *	   R0 = return value
+ *	   R1 = raw data read from NAND
+ *	   R2 = ECC read from NAND
+ *	   R3 = calculated ECC
+ ***********************************************************************/
+_nandboot_correct_data:
+	stmdb   sp!, {r1 - r7, r9, sl, lr}
+
+	mov     r7, r3
+	ldrb    r0, [r3, #1]
+	ldrb    sl, [r3]
+	ldrb    lr, [r2]
+	ldrb    r3, [r2, #1]
+	mov     r6, r2
+	ldrb    ip, [r7, #2]
+	ldrb    r2, [r2, #2]
+	eor     r5, r0, r3
+	eor     r4, sl, lr
+	eor     ip, ip, r2
+	orr     r3, r4, r5
+	orrs    r0, ip, r3
+	mov     r9, r1
+	ldmeqia sp!, {r1 - r7, r9, sl, pc}
+	eor     r3, r4, r4, lsr #1
+	eor     r2, r5, r5, lsr #1
+	and     lr, r3, #85		@; 0x55
+	and     r0, r2, #85		@; 0x55
+	eor     r3, ip, ip, lsr #1
+	cmp     lr, #85			@; 0x55
+	cmpeq   r0, #85			@; 0x55
+	and     r2, r3, #84		@; 0x54
+	bne     53f
+	cmp     r2, #84			@; 0x54
+	bne     53f
+	mov     r2, #128		@; 0x80
+	mov     r1, #0
+	mov     lr, r2
+	mov     r3, r1
+50:	add     r3, r3, #1
+	tst     r4, r2
+	and     r3, r3, #255		@; 0xff
+	orrne   r1, r1, lr
+	cmp     r3, #3			@; 0x3
+	mov     r2, r2, lsr #2
+	mov     lr, lr, lsr #1
+	bls     50b
+	mov     r2, #128		@; 0x80
+	mov     r3, #0
+51:	add     r3, r3, #1
+	tst     r5, r2
+	and     r3, r3, #255		@; 0xff
+	orrne   r1, r1, lr
+	cmp     r3, #3			@; 0x3
+	mov     r2, r2, lsr #2
+	mov     lr, lr, lsr #1
+	bls     51b
+	mov     r4, #0
+	mov     r0, #4
+	mov     r2, #128		@; 0x80
+	mov     r3, r4
+52:	add     r3, r3, #1
+	and     r3, r3, #255		@; 0xff
+	tst     ip, r2
+	orrne   r4, r4, r0
+	cmp     r3, #2
+	ldrhib  lr, [r9, r1]
+	mov     r0, r0, lsr #1
+	movhi   r0, #1
+	eorhi   r3, lr, r0, lsl r4
+	mov     r2, r2, lsr #2
+	strhib  r3, [r9, r1]
+	ldmhiia sp!, {r1 - r7, r9, sl, pc}
+	b       52b
+53:	cmp     r4, #0
+	mov     r3, #0
+	beq     55f
+54:	tst     r4, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    r4, r4, lsr #1
+	bne     54b
+55:	cmp     r5, #0
+	beq     57f
+56:	tst     r5, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    r5, r5, lsr #1
+	bne     56b
+57:	cmp     ip, #0
+	beq     59f
+58:	tst     ip, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    ip, ip, lsr #1
+	bne     58b
+59:	cmp     r3, #1
+	streqb  sl, [r6]
+	ldreqb  r3, [r7, #1]
+	streqb  r3, [r6, #1]
+	ldreqb  r3, [r7, #2]
+	moveq   r0, #2
+	mvnne   r0, #0
+	streqb  r3, [r6, #2]
+
+	ldmia   sp!, {r1 - r7, r9, sl, pc}
+
+#endif /* CONFIG_BOOT_NAND */
diff --git a/board/cc9c/platform.S b/board/cc9c/platform.S
new file mode 100644
index 0000000..acfd358
--- /dev/null
+++ b/board/cc9c/platform.S
@@ -0,0 +1,310 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for the NS9750 DevBoard by
+ * (C) Copyright 2004-2005 by FS Forth-Systeme GmbH.
+ * Markus Pietrek <mpietrek@fsforth.de>
+ * @References: [1] NS9750 Hardware Reference/December 2003
+ *	        [2] ns9750_a.cmd from MAJIC configuration
+ *              adapted to Connect Core 9C
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+#  include <./ns9750_sys.h>
+#  include <./ns9750_mem.h>
+#endif
+
+/***********************************************************************
+ * @Function: write_register_block
+ * @Return: nothing
+ * @Descr: Copies the register block of register_offset:register value to
+ *         the registers at base r0. The block is assumed to start in RAM at r1
+ *         and end at r2. The linked RAM base address of U-Boot is assumed to be
+ *	   in r5 while the ROM base address we are running from is r6
+ *         Uses r3 and r4 as tempory registers
+ ***********************************************************************/
+
+.macro	write_register_block
+	@@ map the addresses to high memory
+	sub	r1, r1, r5
+	add	r1, r1, r6
+	sub	r2, r2, r5
+	add	r2, r2, r6
+
+	@@ copy all
+1:
+	@@ Write register/value pair starting at [r1] to register base r0
+	ldr	r3, [r1], #4
+	ldr	r4, [r1], #4
+	str	r4, [r0,r3]
+	cmp	r1, r2
+	blt	1b
+.endm
+
+_TEXT_BASE:
+	.word	TEXT_BASE	@ sdram load addr from config.mk
+_PHYS_FLASH:
+	.word	PHYS_FLASH_1    @ real flash address (without mirroring)
+_CAS_LATENCY:
+	.word	0x00022000	@ for CAS2 latency
+
+#ifdef CONFIG_BOOT_NAND
+_armboot_start:
+	.word _start
+_bss_start:
+	.word __bss_start
+#endif /* CONFIG_BOOT_NAND */
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+.globl lowlevel_init
+#ifndef CONFIG_BOOT_NAND
+lowlevel_init:
+
+	/* U-Boot may be linked to RAM at 0x780000. But this code will run in
+	   flash from 0x0. But in order to enable RAM we have to disable the
+	   mirror bit, therefore we have to jump to our real flash address
+	   beginning at PHYS_FLASH_1 (CS4 Base). Therefore,
+	   _run_at_real_flash_address may be 0x500003b0 while be linked to
+	   0x7803b0. So we must modify our linked addresses */
+
+	@@ branch to high memory address, away from 0x0
+	ldr	r5, _TEXT_BASE
+	ldr	r6, _PHYS_FLASH
+	ldr	r0, =_run_at_real_flash_address
+	sub	r0, r0, r5
+	add	r0, r0, r6
+	mov	pc, r0
+	nop			@ for pipelining
+
+_run_at_real_flash_address:
+	@@ now we are running > PHYS_FLASH_1, safe to enable memory controller
+
+	@@ Write Memory Configuration Registers
+
+	ldr	r0, _NS9750_MEM_MODULE_BASE
+	ldr	r1, =_MEM_CONFIG_START
+	ldr	r2, =_MEM_CONFIG_END
+
+	write_register_block
+
+	@@ Give SDRAM some time to settle
+	@@ @TODO. According to [2] it should be 2 AHB cycles. Check
+
+	ldr	r1, =0x50
+_sdram_settle:
+	subs	r1, r1, #1
+	bne	_sdram_settle
+
+_enable_mappings:
+	@@ Enable SDRAM Mode
+
+	ldr	r1, =_MEM_MODE_START
+	ldr	r2, =_MEM_MODE_END
+
+	write_register_block
+
+	ldr	r3, _CAS_LATENCY @ perform one read from SDRAM
+	ldr	r3, [r3]
+
+	@@ Enable SDRAM and memory mappings
+
+	ldr	r1, =_MEM_ENABLE_START
+	ldr	r2, =_MEM_ENABLE_END
+
+	write_register_block
+
+	@@ Activate AHB monitor
+
+	ldr	r0, =NS9750_SYS_MODULE_BASE
+	ldr	r1, =_AHB_MONITOR_START
+	ldr	r2, =_AHB_MONITOR_END
+
+	write_register_block
+_relocate_lr:
+	/* lr and ip (from cpu_init_crit) are still based on 0x0, relocate it to
+	   PHYS_FLASH. */
+	mov	r1, ip
+	add	r1, r1, r6
+	mov	ip, r1
+
+	mov	r1, lr
+	add	r1, r1, r6
+	mov	lr, r1
+
+	@@ back to arch calling code
+	mov	pc,	lr
+
+	.ltorg
+
+_NS9750_MEM_MODULE_BASE:
+	.word	NS9750_MEM_MODULE_BASE
+
+_MEM_CONFIG_START:
+	/* Table of 2 32bit entries. First word is register address offset
+	   relative to NS9750_MEM_MODULE_BASE, second one is value. They are
+	   written in order of appearance */
+
+	@@ Register values taken from [2]
+	.word	NS9750_MEM_CTRL
+	.word	NS9750_MEM_CTRL_E
+
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x6 & NS9750_MEM_DYN_REFRESH_MA)
+
+	.word	NS9750_MEM_DYN_READ_CFG
+	.word	(0x1 & NS9750_MEM_DYN_READ_CFG_MA)
+
+	.word	NS9750_MEM_DYN_TRP
+	.word	(0x1 & NS9750_MEM_DYN_TRP_MA)
+
+	.word	NS9750_MEM_DYN_TRAS
+	.word	(0x4 & NS9750_MEM_DYN_TRAS_MA)
+
+	.word	NS9750_MEM_DYN_TAPR
+	.word	(0x1 & NS9750_MEM_DYN_TRAS_MA)
+
+	.word	NS9750_MEM_DYN_TDAL
+	.word	(0x5 & NS9750_MEM_DYN_TDAL_MA)
+
+	.word	NS9750_MEM_DYN_TWR
+	.word	(0x1 & NS9750_MEM_DYN_TWR_MA)
+
+	.word	NS9750_MEM_DYN_TRC
+	.word	(0x6 & NS9750_MEM_DYN_TRC_MA)
+
+	.word	NS9750_MEM_DYN_TRFC
+	.word	(0x6 & NS9750_MEM_DYN_TRFC_MA)
+
+	.word	NS9750_MEM_DYN_TRRD
+	.word	(0x1 & NS9750_MEM_DYN_TRRD_MA)
+
+	.word	NS9750_MEM_DYN_TMRD
+	.word	(0x1 & NS9750_MEM_DYN_TMRD_MA)
+
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_PALL | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x1 & NS9750_MEM_DYN_REFRESH_MA)
+	@@ No further register settings after refresh
+_MEM_CONFIG_END:
+
+_MEM_MODE_START:
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x30 & NS9750_MEM_DYN_REFRESH_MA)
+
+	@@ CS 4
+	.word	NS9750_MEM_DYN_CFG(0)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x4500 & NS9750_MEM_DYN_CFG_AM_MA)) @ 4M32
+
+	.word	NS9750_MEM_DYN_RAS_CAS(0)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 5
+	.word	NS9750_MEM_DYN_CFG(1)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(1)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 6
+	.word	NS9750_MEM_DYN_CFG(2)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(2)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 7
+	.word	NS9750_MEM_DYN_CFG(3)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(3)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_MODE | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+_MEM_MODE_END:
+
+_MEM_ENABLE_START:
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_NORMAL | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+
+	@@ CS 4
+	.word	NS9750_MEM_DYN_CFG(0)    @ 4M32
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x4500 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 5
+	.word	NS9750_MEM_DYN_CFG(1)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 6
+	.word	NS9750_MEM_DYN_CFG(2)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 7
+	.word	NS9750_MEM_DYN_CFG(3)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+_MEM_ENABLE_END:
+
+_AHB_MONITOR_START:
+	.word	NS9750_SYS_AHB_TIMEOUT
+	.word	0x01000100	@ @TODO not calculated yet
+
+	.word	NS9750_SYS_AHB_MON
+	.word	(NS9750_SYS_AHB_MON_BMTC_GEN_IRQ | \
+		 NS9750_SYS_AHB_MON_BATC_GEN_IRQ)
+_AHB_MONITOR_END:
+
+#else  /* CONFIG_BOOT_NAND */
+lowlevel_init:
+	mov	pc, lr		@ nothing to do here
+
+#endif /*CONFIG_BOOT_NAND */
+#endif /*CONFIG_SKIP_LOWLEVEL_INIT*/
diff --git a/board/cc9c/u-boot.lds b/board/cc9c/u-boot.lds
new file mode 100644
index 0000000..ce9000a
--- /dev/null
+++ b/board/cc9c/u-boot.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+  __u_boot_cmd_start = .;
+  .u_boot_cmd : { *(.u_boot_cmd) }
+  __u_boot_cmd_end = .;
+
+  __testhw_cmd_start = .;
+  .testhw_cmd : { *(.testhw_cmd) }
+  __testhw_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = . ;
+
+}
diff --git a/board/cc9m2443/Makefile b/board/cc9m2443/Makefile
new file mode 100644
index 0000000..f344d79
--- /dev/null
+++ b/board/cc9m2443/Makefile
@@ -0,0 +1,58 @@
+#
+# (C) Copyright 2000-2006
+# scsuh, Samsung Electronics, sc.suh@samsung.com
+#
+# Derived from Makefiles made by
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+DIGI_DIR = $(TOPDIR)/common/digi
+DIGI_BSP = -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+CPPFLAGS += $(DIGI_BSP)
+
+COBJS	:= cc9m2443.o flash.o
+SOBJS	:= lowlevel_init.o nandboot.o 
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/cc9m2443/cc9m2443.c b/board/cc9m2443/cc9m2443.c
new file mode 100644
index 0000000..8b1eae1
--- /dev/null
+++ b/board/cc9m2443/cc9m2443.c
@@ -0,0 +1,401 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <regs.h>
+#include <nvram.h>
+#include <net.h>
+
+#include <asm/io.h>
+#include <asm-arm/arch-s3c24xx/gpio.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+extern void run_auto_script(void);
+#endif
+
+/* ------------------------------------------------------------------------- */
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n" "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+static void lan9215_pre_init(void)
+{
+
+	s3c_gpio_cfgpin(S3C_GPA13, S3C_GPA_OUTPUT);
+	s3c_gpio_setpin(S3C_GPA13, 1);
+
+	SMBIDCYR5_REG = 0xa;			//Bank1 Idle cycle ctrl.
+	SMBWSTWRR5_REG = 14;			//Bank1 Write Wait State ctrl.
+	SMBWSTOENR5_REG = 0x7;			//Bank1 Output Enable Assertion Delay ctrl.
+	SMBWSTWENR5_REG = 0x7;			//Bank1 Write Enable Assertion Delay ctrl.
+	SMBWSTRDR5_REG = 14;			//Bank1 Read Wait State cont. = 14 clk
+	SMBCR5_REG |=  (1<<0);			//SMWAIT active High, Read Byte Lane Enable
+	SMBCR5_REG |= ((3<<20)|(3<<12));	//SMADDRVALID = always High when Read/Write
+	SMBCR5_REG &= ~(3<<4);			//Clear Memory Width
+	SMBCR5_REG |=  (1<<4);			//Memory Width = 16bit
+}
+
+static void usb_pre_init (void)
+{
+	/* Initialy disable USB_POWEREN line to
+	 * reset any connected USB device.
+	 * This line will be enabled when booting
+	 * the OS or when calling a USB command */
+	s3c_gpio_cfgpin(S3C_GPA14, S3C_GPA_OUTPUT);
+	s3c_gpio_setpin(S3C_GPA14, 1);
+
+	CLKDIV1CON_REG |= 1<<4;
+
+	USB_RSTCON_REG = 0x1;
+	delay(500);
+	USB_RSTCON_REG = 0x2;
+	delay(500);
+	USB_RSTCON_REG = 0x0;
+	delay(500);
+
+	USB_CLKCON_REG |= 0x2;
+
+	/*
+	 * Enable the USB-PHY and reset it, otherwise a connected USB-host will
+	 * try to enumerate the non-available USB-device
+	 */
+	PWRCFG_REG |= 0x10;
+	USB_RSTCON_REG |= 0x01;
+}
+
+/*
+ * When NAND is not used as Boot Device
+ */
+static void nand_pre_init(void)
+{
+	SMBIDCYR1_REG = 0xf;
+	SMBWSTRDR1_REG = 0x1f;
+	SMBWSTWRR1_REG = 0x1f;
+	SMBWSTOENR1_REG = 0;
+	SMBWSTWENR1_REG = 1;
+	SMBCR1_REG = 0x00303000;
+	SMBSR1_REG = 0;
+	SMBWSTBDR1_REG = 0x1f;
+}
+
+static void inline user_key_init(void)
+{
+	s3c_gpio_cfgpin(USER_KEY1_GPIO, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(USER_KEY2_GPIO, S3C_GPIO_INPUT);
+}
+
+static void inline user_led_init(void)
+{
+	s3c_gpio_cfgpin(USER_LED1_GPIO, S3C_GPIO_OUTPUT);
+	s3c_gpio_cfgpin(USER_LED2_GPIO, S3C_GPIO_OUTPUT);
+	s3c_gpio_setpin(USER_LED1_GPIO, 0);
+	s3c_gpio_setpin(USER_LED2_GPIO, 0);
+}
+
+static void inline confiure_S4(void)
+{
+	s3c_gpio_cfgpin(S3C_GPC8, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPC9, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPD0, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPD1, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPD8, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPD9, S3C_GPIO_INPUT);
+}
+
+static void inline disable_wlan(void)
+{
+	GPBCON_REG &= ~(3<<4);
+        GPBCON_REG |=  (1<<4);
+}
+
+int board_init(void)
+{
+	icache_enable();
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	nand_pre_init();
+#endif
+#ifdef CONFIG_DRIVER_SMSC9118
+	 lan9215_pre_init();
+#endif
+#ifdef CONFIG_USB_OHCI
+	usb_pre_init();
+#endif
+#if defined(CONFIG_USER_KEY)
+ 	user_key_init();
+#endif
+	user_led_init();
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(ENABLE_CONSOLE_GPIO)
+	s3c_gpio_cfgpin( ENABLE_CONSOLE_GPIO, S3C_GPIO_INPUT);
+#endif
+
+	disable_wlan();
+	gd->bd->bi_arch_number = MACH_TYPE_CC9M2443JS;
+	gd->bd->bi_boot_params = (PHYS_SDRAM_1+0x100);
+
+	return 0;
+}
+
+ulong get_dram_size (void)
+{
+	ulong dram_size = 0;
+	ulong gpdat = 0;
+
+	s3c_gpio_cfgpin(S3C_GPF4, S3C_GPIO_INPUT);
+	s3c_gpio_cfgpin(S3C_GPF3, S3C_GPIO_INPUT);
+	gpdat  = s3c_gpio_getpin(S3C_GPF3);
+	gpdat |= s3c_gpio_getpin(S3C_GPF4);
+	gpdat  = gpdat >> 3;
+
+	switch (gpdat) {
+		case 0x00000000:
+			dram_size = 0x1000000;
+			break;
+		case 0x000000001:
+			dram_size = 0x4000000;
+			break;
+		case 0x00000002:
+			dram_size = 0x2000000;
+			break;
+		case 0x00000003:
+			dram_size = 0x8000000;
+			break;
+	}
+
+	return dram_size;
+}
+
+/* Writes a magic number to offset 0 of each DRAM bank address
+ * and verifies that the value read is the value written. If so,
+ * the bank exists. Different magic numbers are used for each bank
+ * as some SDRAM controllers mirror the memory from the first bank
+ * to the second if the second doesn't exist. */
+int get_dram_banks(void)
+{
+	ulong magic1 = 0xA9871111;
+	ulong magic2 = 0xFEDC2222;
+	ulong val, offset = 0;
+	int banks = 0;
+
+	writel(magic1, PHYS_SDRAM_1 + offset);
+	writel(magic2, PHYS_SDRAM_2 + offset);
+	val = readl(PHYS_SDRAM_1 + offset);
+	if (val == magic1)
+		banks++;
+	val = readl(PHYS_SDRAM_2 + offset);
+	if (val == magic2)
+		banks++;
+
+	return banks;
+}
+
+int dram_init(void)
+{
+	ulong size;
+	int nrbanks;
+
+	size = get_dram_size();
+	nrbanks = get_dram_banks();
+	if (nrbanks != 1 && nrbanks != 2)
+		nrbanks = 1;
+
+	if (nrbanks > 0) {
+		gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+		gd->bd->bi_dram[0].size = size;
+#if CONFIG_NR_DRAM_BANKS == 2
+		/* Fill the information of the second bank
+		 * with correct address but size 0, for compatibility */
+		gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+		gd->bd->bi_dram[1].size =  0;
+#endif
+	}
+	if (nrbanks > 1) {
+		gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+		gd->bd->bi_dram[1].size = size;
+	}
+
+	dcache_enable();
+
+	return 0;
+}
+
+#if !defined(CONFIG_SPLASH_SCREEN) && !defined(CONFIG_USE_VIDEO_CONSOLE)
+static void SetLcdPort(void)
+{
+	ulong gpdat;
+	/* Enable clock to LCD */
+	HCLKCON_REG |= (1<<10);
+
+	/* To select TFT LCD type */
+	gpdat = readl(MISCCR);
+	gpdat  |= (1<<28);
+	writel(gpdat, MISCCR);
+
+	GPCCON_REG = 0x55505554;
+	GPDCON_REG = 0x55505550;
+
+#ifndef	CONFIG_UBOOT_CRT_VGA
+	/* disalbe LCD_POWER_ENABLE */
+	GPGCON_REG &= ~(3<<8);
+	GPGCON_REG |=  (1<<8);
+	GPGDAT_REG |=  (1<<4);
+#endif
+}
+#endif
+
+#ifdef BOARD_LATE_INIT
+int board_late_init (void)
+{
+	char cmd[60];
+	nv_critical_t *pNvram;
+	printf("CPU:   S3C2443@%dMHz\n", get_ARMCLK()/1000000);
+	printf("       Fclk = %dMHz, Hclk = %dMHz, Pclk = %dMHz\n",
+			get_FCLK()/1000000, get_HCLK()/1000000, get_PCLK()/1000000);
+
+#if !defined(CONFIG_SPLASH_SCREEN) && !defined(CONFIG_USE_VIDEO_CONSOLE)
+	SetLcdPort();
+#endif
+
+	if (NvCriticalGet(&pNvram)) {
+		/* Pass location of environment in memory to OS
+		 *                  * through bi */
+		gd->bd->nvram_addr = (unsigned long)pNvram;
+	}
+	memcpy((int*)gd->bd->bi_boot_params, gd->bd, sizeof(bd_t));
+
+	/*
+	 * Store the MAC-address in the Ethernet-controller, otherwise the
+	 * kernel-driver will not have the correct address.
+	 */
+#if defined(CONFIG_COMMANDS) && defined(CFG_CMD_NET)
+	eth_use_mac_from_env( gd->bd );
+#endif
+
+#if defined(CONFIG_USER_KEY)
+        if (s3c_gpio_get_stat(USER_KEY1_GPIO) == 0)
+        {
+                printf("\nUser Key 1 pressed\n");
+                if (getenv("key1") != NULL)
+                {
+                        sprintf(cmd, "run key1");
+                        run_command(cmd, 0);
+                }
+
+        }
+        if (s3c_gpio_get_stat(USER_KEY2_GPIO) == 0)
+        {
+                printf("\nUser Key 2 pressed\n");
+                if (getenv("key2") != NULL)
+                {
+                        sprintf(cmd, "run key2");
+                        run_command(cmd, 0);
+                }
+        }
+#endif /* CONFIG_USER_KEY */
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+	run_auto_script();
+#endif
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	vu_long *mem_reg = (vu_long*) 0x48000000;
+
+	printf("Board: CC9M2443 ");
+	switch ((*mem_reg>>2) & 0x3) {
+	case 0:
+		puts("SDRAM\n");
+		break;
+
+	case 1:
+		puts("Mobile SDRAM\n");
+		break;
+
+	case 2:
+	case 3:
+		puts("Mobile DDR\n");
+		break;
+
+	default:
+		puts("unknown Memory Type\n");
+	}
+	return (0);
+}
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+ulong virt_to_phy_smdk2443(ulong addr)
+{
+	if ((0xc0000000 <= addr) && (addr < 0xc4000000))
+		return (addr - 0xc0000000 + 0x30000000);
+	else
+		printf("do not support this address : %08lx\n", addr);
+
+	return addr;
+}
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && defined(CFG_NAND_LEGACY)
+#include <linux/mtd/nand.h>
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+
+void nand_init(void)
+{
+	nand_probe(CFG_NAND_BASE);
+	if (nand_dev_desc[0].ChipID != NAND_ChipID_UNKNOWN) {
+		print_size(nand_dev_desc[0].totlen, "\n");
+	}
+}
+#endif
+
+#if defined(CONFIG_SILENT_CONSOLE)
+
+int test_console_gpio (void)
+{
+#if defined(ENABLE_CONSOLE_GPIO) && defined(CONSOLE_ENABLE_GPIO_STATE)
+	if( s3c_gpio_get_stat(ENABLE_CONSOLE_GPIO) == CONSOLE_ENABLE_GPIO_STATE){
+		return 1;
+	}else{
+		return 0;
+	}
+#else
+
+	return 0;
+#endif
+}
+#endif
diff --git a/board/cc9m2443/config.mk b/board/cc9m2443/config.mk
new file mode 100644
index 0000000..d3027db
--- /dev/null
+++ b/board/cc9m2443/config.mk
@@ -0,0 +1,2 @@
+TEXT_BASE = 0x30100000
+DIGI_BOARD = y
diff --git a/board/cc9m2443/flash.c b/board/cc9m2443/flash.c
new file mode 100644
index 0000000..65e696a
--- /dev/null
+++ b/board/cc9m2443/flash.c
@@ -0,0 +1,134 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if !defined(CFG_NO_FLASH)
+#undef FLASH_DEBUG
+
+#undef CFG_FLASH_BASE
+#define CFG_FLASH_BASE 0x08000000
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#undef  CFG_FLASH_WORD_SIZE
+#define CFG_FLASH_WORD_SIZE unsigned short
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#if 0
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+#endif
+#define CFG_FLASH_ADDR0		0x555
+#define CFG_FLASH_ADDR1		0x2AA
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+#define CFG_MONITOR_BASE CFG_FLASH_BASE
+#define CFG_MONITOR_LEN (256*1024)
+
+#include "../common/flash_common.c"
+
+uint nor_flash_base = CFG_FLASH_BASE;
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	unsigned long total_b = 0;
+	unsigned long size_b[CFG_MAX_FLASH_BANKS];
+	int i;
+
+	{
+		vu_long * base_addr = (vu_long*)0x400;
+		ulong temp;
+
+		temp = *base_addr;
+		*base_addr = 0x20764316;
+		if (*base_addr != 0x20764316)
+			nor_flash_base = 0;
+		*base_addr = temp;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		flash_info[i].sector_count = -1;
+		flash_info[i].size = 0;
+
+		/* call flash_get_size() to initialize sector address */
+		size_b[i] = flash_get_size((vu_long *)nor_flash_base, &flash_info[i]);
+		flash_info[i].size = size_b[i];
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifdef FLASH_DEBUG
+			printf("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+			       i, size_b[i], size_b[i] << 20);
+#endif
+			flash_info[i].sector_count = -1;
+			flash_info[i].size = 0;
+		}
+
+
+		total_b += flash_info[i].size;
+	}
+
+#if 0	/* by scsuh. removed for simple usage */
+	/* Monitor protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_MONITOR_BASE,
+			    CFG_MONITOR_BASE + CFG_MONITOR_LEN - 1,
+			    &flash_info[0]);
+#endif
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_ENV_ADDR,
+			    CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1,
+			    &flash_info[0]);
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_ENV_ADDR_REDUND,
+			    CFG_ENV_ADDR_REDUND + CFG_ENV_SECT_SIZE - 1,
+			    &flash_info[0]);
+#endif
+
+	return total_b;
+}
+#endif
+
diff --git a/board/cc9m2443/lowlevel_init.S b/board/cc9m2443/lowlevel_init.S
new file mode 100644
index 0000000..ef91ab3
--- /dev/null
+++ b/board/cc9m2443/lowlevel_init.S
@@ -0,0 +1,235 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#include <regs.h>
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+	mov	r12, lr
+
+ldr     r0, =ELFIN_GPIO_BASE
+        ldr     r1, =0x10
+        str     r1, [r0, #GPBCON_OFFSET]
+
+        ldr     r1, =0x04
+        str     r1, [r0, #GPBDAT_OFFSET]
+/* Disable Watchdog */
+	ldr	r0, =ELFIN_WATCHDOG_BASE
+	mov	r1, #0
+	str	r1, [r0]
+
+	/* Disable main and sub interrupts */
+	ldr	r0, =ELFIN_INTERRUPT_BASE
+	mvn	r1, #0x0
+	str	r1, [r0, #INTMSK_OFFSET]
+	str	r1, [r0, #INTSUBMSK_OFFSET]
+
+	/* Set all interrupts as IRQ */
+	mov	r1, #0x0
+	str	r1, [r0, #INTMOD_OFFSET]
+
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+	/* init system clock */
+	bl system_clock_init
+#endif
+
+	/* simple init for NAND */
+	bl nand_asm_init
+
+	/* when we already run in ram, we don't need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     2f			/* r0 == r1 then skip sdram init   */
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+	ldr     r1, =GPFDAT_REG
+	ldr     r4, [r1]
+	tst     r4, #(0x1 << 3)
+	bne     64f
+	/* 16 or 32 MB ram */
+	tst     r4, #(0x1 << 4)
+	ldrne   r0, =sdram_bank_set_val_32
+	b       4f
+	/* 64 or 128 MB ram */
+64:	tst     r4, #(0x1 << 4)
+	ldreq   r0, =sdram_bank_set_val_64
+	ldrne   r0, =sdram_bank_set_val_128
+
+4:	bl sdr_ctrl_asm_init
+#endif
+2:	ldr     r0, =RSTSTAT_REG
+	ldr 	r1, [r0]
+	ldr	r2, =0x8
+	cmp     r1, r2
+	ldrne	r2, =0x20
+	cmpne   r1, r2
+	bne   	2f
+	/* recover from sleep mode */
+
+	/* PM check */
+	@ Check if this is a wake-up from sleep
+
+	ldr 	r0, =INFORM1_REG	/* INFORM1 register */
+        ldr 	r1, [r0]
+        mov 	pc, r1 			 /* end PM check */
+
+2:	mov	lr, r12
+	mov	pc, lr
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+	ldr	r0, =ELFIN_CLOCK_POWER_BASE
+
+	ldr	r1, [r0, #CLKDIV0CON_OFFSET]
+	bic	r1, r1, #0x37	/* clear HCLKDIV, PREDIV, PCLKDIV */
+	bic	r1, r1, #(0xf<<9) /* clear ARMCLKDIV */
+	ldr     r3, =GPHDAT_REG
+        ldr     r4, [r3]
+        tst     r4, #(1 << 12)
+        ldrne   r2, =0xf    /* FCLK CPU HCLK PCLK Mhz 533 533 133 66 */
+        ldreq   r2, =0x102D  /* FCLK CPU HCLK PCLK MHz 800 400 133 66 */
+	orr	r1, r1, r2
+	str	r1, [r0, #CLKDIV0CON_OFFSET]
+
+	/*Set MPLL Locktime*/
+	ldr	r1, =0xe10
+	str	r1, [r0, #LOCKCON0_OFFSET]
+
+	ldr 	r1, =GPHDAT_REG
+	ldr     r2, [r1]
+	tst     r2, #(1 << 12)
+	ldrne 	r1, =0x00510201    /* CPU Mhz 533 133 66*/
+	ldreq	r1, =0x005c0300    /* CPU MHz 400 133 66 */
+	str	r1, [r0, #MPLLCON_OFFSET]
+
+#if 1
+	ldr	r1, =0x00280101		/*Set EPLL*/
+	str	r1, [r0, #EPLLCON_OFFSET]
+#endif
+
+	/* set CLKSRC to fit MPLL and USB*/
+	ldr	r1, [r0, #CLKSRCCON_OFFSET]
+	orr	r1, r1, #0x50
+	str	r1, [r0, #CLKSRCCON_OFFSET]
+
+#if 0
+	/* wait at least 200us to stablize all clock */
+	mov	r1, #0x10000
+1:	subs	r1, r1, #1
+	bne	1b
+#endif
+
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0xc0000000	/* clock setting in MMU */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mov	pc, lr
+
+/*
+ * Nand Interface Init for smdk2443
+ */
+nand_asm_init:
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, [r0]
+	orr	r1, r1, #(0x3f<<17)
+	str     r1, [r0]
+	/* EVT1 has modification in NAND */
+#if 0
+	ldr	r1, =0x1aa8a
+	str     r1, [r0, #GPADAT_OFFSET]
+#endif
+
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	orr	r1, r1, #0x70
+	orr	r1, r1, #0x7700
+	str     r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	orr	r1, r1, #0x03
+	str     r1, [r0, #NFCONT_OFFSET]
+
+	mov	pc, lr
+
+	.ltorg
+/*
+ * struct sdram_val {
+ *	ulong bankcfg_val;	r5, val of bankcfg
+ *	ulong bankcon1_val;	r6, val of bankcon1
+ *	ulong bankcon2_val;	r7, val of bankcon2
+ *	ulong bankcon3_val;	r8, val of bankcon3
+ *	ulong refresh_val;	r9, val of refresh
+ *	ulong wbtimout_val;	r10, val of write buffer timeout
+ * }
+ */
+sdram_bank_set_val_128:
+       .word   CFG_BANK_CFG_VAL_128
+       .word   CFG_BANK_CON1_VAL
+       .word   CFG_BANK_CON2_VAL_133
+       .word   CFG_BANK_CON3_VAL
+       .word   CFG_BANK_REFRESH_VAL_133_128
+       .word   CFG_BANK_TIMEOUT_VAL_133_128
+
+sdram_bank_set_val_64:
+	.word	CFG_BANK_CFG_VAL_64
+	.word	CFG_BANK_CON1_VAL
+	.word	CFG_BANK_CON2_VAL_133
+	.word	CFG_BANK_CON3_VAL
+	.word	CFG_BANK_REFRESH_VAL_133_64
+	.word   CFG_BANK_TIMEOUT_VAL_133_64
+
+sdram_bank_set_val_32:
+	.word   CFG_BANK_CFG_VAL_32
+	.word   CFG_BANK_CON1_VAL
+	.word   CFG_BANK_CON2_VAL_133
+	.word   CFG_BANK_CON3_VAL
+	.word   CFG_BANK_REFRESH_VAL_133_32
+	.word   CFG_BANK_TIMEOUT_VAL_133_32
+
+#ifdef CONFIG_SDRAM_AUTO_DETECT
+sdram_bank_sel_val_alt:
+	.word	CFG_BANK_CFG_VAL_ALT
+	.word	CFG_BANK_CON1_VAL_ALT
+#endif
+
diff --git a/board/cc9m2443/nandboot.S b/board/cc9m2443/nandboot.S
new file mode 100644
index 0000000..4a697f2
--- /dev/null
+++ b/board/cc9m2443/nandboot.S
@@ -0,0 +1,383 @@
+#include <config.h>
+
+#ifdef CONFIG_BOOT_NAND
+
+.globl _nandboot
+
+/***********************************************************************
+ * @Function: _nandboot (unsigned int unStartBlock,
+ *			  unsigned int* punDest, unsigned int unLength)
+ * @Return: always, check for bad blocks and verify ECC bytes
+ * @Descr: copies blocks from NAND to RAM (punDest) until unLength data has been
+ *	   read. unStartBlock
+ ***********************************************************************/
+
+#define rNF_BASE	(0x4e000000)
+
+#define	oNF_CONF	(0x00)
+#define	oNF_CONT	(0x04)
+#define	oNF_CMD		(0x08)
+#define oNF_ADDR	(0x0c)
+#define oNF_DATA	(0x10)
+#define oNF_STAT	(0x28)
+#define oNF_MECCD0	(0x14)
+#define oNF_MECCD1	(0x18)
+#define oNF_MECC0	(0x34)
+#define oNF_ESTAT0      (0x2c)
+#define oNF_REG_CS	oNF_CONT
+#define oNF_REG_CMD	oNF_CMD
+
+#define vNF_CONF_RESET  (0xf830) /* NAND Controller enable, enable chip,
+	                            TWRPH0 = 3 */
+#define vNF_CS		(0x02)
+
+#define vNF_BS_LARGE	(0x20000)	@ large block size
+#define vNF_BS_SMALL	(0x4000)	@ small block size
+#define vNF_PS_LARGE	(0x800)		@ large page size
+#define vNF_PS_SMALL	(0x200)		@ small page size
+#define vNF_OOB_LARGE	(0x40)		@ large oob size
+#define vNF_OOB_SMALL	(0x10)		@ small oob size
+#define vNF_BB_POS_L	(0x00)		@ bad block position for large NAND
+#define vNF_BB_POS_S	(0x05)		@ bad block position for small NAND
+#define vNF_CMD_READ0	(0x00)		@ command READ0
+#define vNF_CMD_READS	(0x30)		@ command READ start for large NAND
+#define vNF_CMD_READO	(0x50)		@ command READ OOB for small NAND
+#define vNF_CMD_RESET	(0xff)		@ command RESET
+@#define vNF_WAIT	(0x30)		@ counter for wait loop
+#define vNF_WAIT	(0x100)		@ counter for wait loop
+#define vNF_CHECK_BAD	(0xff)		@ value to check if block is bad
+#define vNF_MECCLOCK	(0x80)		@ MainECCLock
+#define vNF_INITMECC	(0x20)		@ Init MainECC
+
+#define oNF_SP_ADDR	(0x1000)	@ address for SP in stepping stone
+#define vNF_ECC_POS	(0x28)		@ start position of ECC data (24 Bytes)
+#define oNF_ECC_DAT_R	(0xe20)		@ read ECC data in steppingstone
+
+
+/* Flash enable by setting low nFCE */
+.macro	flash_enable
+	ldr	r4, [r3, #oNF_REG_CS]
+	bic	r4, r4, #vNF_CS
+	str	r4, [r3, #oNF_REG_CS]
+.endm
+
+/* Flash disable by setting high nFCE */
+.macro	flash_disable
+	ldr	r4, [r3, #oNF_REG_CS]
+	orr	r4, r4, #vNF_CS
+	str	r4, [r3, #oNF_REG_CS]
+.endm
+
+.macro	nand_wait_not_busy
+1:	ldr	r4, [r3, #oNF_STAT]	@ Status register
+	tst	r4, #0x01		@ RnB
+	beq	1b
+.endm
+
+.macro delay reg, numloops
+	ldr	\reg, =\numloops
+2:	subs    \reg, \reg, #1
+	bne	2b
+.endm
+
+.macro ndelay reg, numloops
+	mov	\reg, #0
+3:	add	\reg, \reg, #0x1
+	cmp	\reg, #\numloops
+	blt	3b
+.endm
+
+.macro short_delay
+	nop
+	nop
+.endm
+
+
+_nandboot:
+	mov	r4, lr
+	ldr	sp, =oNF_SP_ADDR	@ set up SP
+
+	stmdb   sp!, {r4}
+
+	mov	r3, #rNF_BASE
+
+	ldr	r4, [r3]
+	tst 	r4, #(0x1 << 3);
+	ldreq	r6, =vNF_PS_SMALL	@ small page size
+	ldrne	r6, =vNF_PS_LARGE	@ large page size
+	flash_enable			@ chip enable
+	ndelay	r4, vNF_WAIT		@ wait
+	mov	r4, #vNF_CMD_RESET	@ send reset to NAND
+	strb	r4, [r3, #oNF_REG_CMD]
+
+	ndelay	r4, vNF_WAIT		@ wait
+	nand_wait_not_busy		@ wait until ready
+	flash_disable			@ disable the chip
+
+_nandboot_read_page:
+	@ read one page
+	mov	ip, lr
+	bl	_nandboot_bb_check	@ first check, if block is bad
+	mov	lr, ip
+
+	flash_enable			@ chip enable
+	ldr     r4, [r3, #oNF_CONT]
+        bic     r4, r4, #vNF_MECCLOCK	@ unlock main area ecc
+        orr	r4, r4, #vNF_INITMECC   @ init/clear main ecc
+	str     r4, [r3, #oNF_CONT]	@ ecc is genarted by hardware,
+					@ while reading page
+	ndelay	r4, vNF_WAIT		@ wait
+	mov	r4, #vNF_CMD_READ0	@ READ0
+	strb	r4, [r3, #oNF_REG_CMD]
+	cmp	r6, #vNF_PS_SMALL
+	beq	512f
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	strb	r4, [r3, #oNF_ADDR]	@ write address byte
+	short_delay			@ short delay to acomplish tALS
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000FF 	@ clear upper nibble and start of sector
+	strb	r4, [r3, #oNF_ADDR]	@ write A8..11
+	short_delay			@ short delay to acomplish tALS
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3, #oNF_ADDR]	@ write A11..18
+	short_delay			@ short delay to acomplish tALS
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3, #oNF_ADDR]	@ write A19..26
+	short_delay			@ short delay to acomplish tALS
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3, #oNF_ADDR]	@ write A27..31
+	mov	r4, #vNF_CMD_READS	@ READ start
+	strb	r4, [r3, #oNF_REG_CMD]
+	b	1f
+512:
+	mov     r4, r0                  @ ADDR
+        bic     r4, r4, #0x000000FF     @ clear A0..7, start of sector
+        strb    r4, [r3, #oNF_ADDR]     @ write address byte
+	short_delay			@ short delay to acomplish tALS
+	mov     r4, r4, lsr #9          @ A8 not relevant here
+        strb    r4, [r3, #oNF_ADDR]     @ write A9..16
+	short_delay			@ short delay to acomplish tALS
+	mov     r4, r4, lsr #8
+        strb    r4, [r3, #oNF_ADDR]     @ write A17..24
+	short_delay			@ short delay to acomplish tALS
+	mov     r4, r4, lsr #8
+        bic     r4, r4, #0x000000FC     @ clear A2..7
+        strb    r4, [r3, #oNF_ADDR]     @ write A25..26
+
+1:	ndelay	r4, vNF_WAIT		@ wait
+	nand_wait_not_busy		@ wait until ready
+
+	@ copy always one page size
+	@ r2 is number of bytes overall left after this copy
+	@ r5 is number in page left
+	cmp	r2, r6
+	subge	r2, r2, r6
+	movlt	r2, #0
+	mov	r5, r6
+
+_nandboot_page_copy_to_mem:
+	@ copy page to memory
+	cmp	r5, #0
+	beq	8f
+	sub	r5, r5, #1
+
+	ldrb	r4, [r3, #oNF_DATA]
+	strb	r4, [r1], #1
+	b	_nandboot_page_copy_to_mem
+
+8:
+	ldr     r4, [r3, #oNF_CONT]
+        orr     r4, r4, #vNF_MECCLOCK	@ lock main area ecc
+        str     r4, [r3, #oNF_CONT]	@ keep ecc
+
+	flash_disable
+
+	@ now we check ECC
+	stmdb   sp!, {r0 - r6}
+	sub	r1, r1, r6		@ set pointer to start of page
+	ldr	r2, =oNF_ECC_DAT_R	@ pointer to ECC data read
+	cmp	r6, #vNF_PS_SMALL
+	addne	r2, r2, #vNF_ECC_POS	@ correct pointer for large NAND Flash
+
+	mov	ip, lr
+	bl	_nandboot_correct_data
+	mov	lr, ip
+	tst 	r0, #2
+	beq	_ecc_correct
+_ecc_error:
+	ldr	r4, =0x56000014
+	ldr	r5, [r4]
+	eor	r5, r5, #0x04
+	str	r5, [r4]
+
+	ndelay	r3, 0x3000000	@ led delay
+	b	_ecc_error
+
+_ecc_correct:
+	ldmia   sp!, {r0 - r6}
+
+	cmp	r2, #0
+	addne	r0, r0, r6          @ select next page
+
+	bne	_nandboot_read_page
+
+	@ finished, all bytes read
+	ldmia   sp!, {lr}
+	mov	pc, lr
+
+
+/***********************************************************************
+ * @Function: _nandboot_bb_check
+ *
+ * @Descr: checks 1st page of block, if block is bad
+ *	   stores ECC bytes to RAM
+ ***********************************************************************/
+_nandboot_bb_check:
+	stmdb   sp!, {r1, r2, r7 - r9}
+_bb_check_loop:
+	mov	r8, #0x00
+
+	cmp	r6, #vNF_PS_SMALL
+	beq 	512f
+	mov	r5, #vNF_BS_LARGE	@ block size
+	mov	r7, #vNF_OOB_LARGE	@ oob size
+	mov	r9, #vNF_BB_POS_L	@ bad block position
+	b	1f
+512:
+	mov     r5, #vNF_BS_SMALL       @ block size
+        mov     r7, #vNF_OOB_SMALL      @ oob size
+        mov     r9, #vNF_BB_POS_S       @ bad block position
+1:
+	mov	r4, r0		        @ ADDR
+	cmp	r4, #0x00
+	beq	20f
+	mov	r8, r4, lsl #15		@ we only check 1st page
+20:
+	flash_enable			@ enable flash chip
+	ndelay	r4, vNF_WAIT		@ wait
+	mov	r4, #vNF_CMD_READO	@ READ OOB for small NAND
+	cmp	r6, #vNF_PS_SMALL
+	beq	23f
+	mov	r4, #vNF_CMD_READ0	@ READ0
+23:	strb	r4, [r3, #oNF_REG_CMD]
+
+	cmp	r6, #vNF_PS_SMALL
+	beq	512f
+	mov	r4, r0		        @ ADDR
+	orr	r4, r4, r6
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	strb	r4, [r3, #oNF_ADDR]	@ write address byte
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000F7 	@ clear upper nibble and start of sector
+	strb	r4, [r3, #oNF_ADDR]	@ write A8..11
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3, #oNF_ADDR]	@ write A11..18
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3, #oNF_ADDR]	@ write A19..26
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3, #oNF_ADDR]	@ write A27..31
+
+	mov	r4, #vNF_CMD_READS	@ READ start
+	strb	r4, [r3, #oNF_REG_CMD]
+	b	1f
+512:
+	mov     r4, r0                  @ ADDR
+        bic     r4, r4, #0x000000FF     @ clear A0..7, start of sector
+        strb    r4, [r3, #oNF_ADDR]     @ write address byte
+        mov     r4, r4, lsr #9          @ A8 not relevant here
+        strb    r4, [r3, #oNF_ADDR]     @ write A9..16
+        mov     r4, r4, lsr #8
+        strb    r4, [r3, #oNF_ADDR]     @ write A17..24
+        mov     r4, r4, lsr #8
+        bic     r4, r4, #0x000000FC     @ clear A2..7
+        strb    r4, [r3, #oNF_ADDR]     @ write A25..26
+1:
+	ndelay	r4, vNF_WAIT		@ wait
+	nand_wait_not_busy		@ wait until ready
+
+	ldr	r1, =oNF_ECC_DAT_R
+	mov	r2, #0x00
+21:
+	ldrb	r4, [r3, #oNF_DATA]
+	strb	r4, [r1, r2]		@ store ECC bytes
+	add	r2, r2, #1
+	cmp	r2, r7			@ read all oob data
+	bne	21b
+
+	cmp	r8, #0x00		@ 1st page of block?
+	bne	22f
+	ldrb	r4, [r1, r9]		@ read bad block info
+	cmp	r4, #vNF_CHECK_BAD	@ bad block?
+	beq	22f
+	add	r0, r0, r5		@ next block
+	flash_disable			@ disable the flash chip
+
+	b	_bb_check_loop		@ check new block
+22:
+	cmp     r6, #vNF_PS_SMALL
+	beq 	512f
+	ldr	r4, =vNF_BB_POS_L
+	b	1f
+512:
+	ldr	r4, =vNF_BB_POS_S
+1:
+	cmp	r9, r4
+	beq	_bb_check_out
+	ldrb	r4, [r1, #6]		@ move ECC4 to the correct place
+	strb	r4, [r1, #4]
+	ldrb	r4, [r1, #7]		@ move ECC5 to the correct place
+	strb	r4, [r1, #5]
+
+_bb_check_out:
+	flash_disable			@ disable the flash chip
+	ldmia   sp!, {r1, r2, r7 - r9}
+	mov	pc, lr
+
+/***********************************************************************
+ * @Function: _nandboot_correct_data
+ *
+ * @Descr: compares calculated and read ECC values
+ *	   correct error if possible
+ *	   R0 = return value  (out)
+ *	   R1 =	start of page (in)
+ *	   R2 = ECC read from NAND (in)
+ ***********************************************************************/
+_nandboot_correct_data:
+	stmdb   sp!, {r1 - r5, sl, lr}
+	ldr	r0, [r2]
+	and 	r4, r0, #0xff00
+	and 	r5, r0,	#0xff
+	orr 	r5, r5,	r4, lsl #8
+	str     r5, [r3, #oNF_MECCD0]
+
+	mov 	r0, r0, lsr #16
+	and 	r4, r0, #0xff00
+	and 	r5, r0, #0xff
+	orr 	r5, r5,	r4, lsl #8
+	str     r5, [r3, #oNF_MECCD1]
+
+	ldr	r0, [r3, #oNF_ESTAT0]
+	and	r0, r0, #0x3
+	cmp 	r0, #0x1
+	bne	out
+	@ correctable error
+	@ (nfestat0 >> 7) & 0x7ff :error byte number
+        @ (nfestat0 >> 4) & 0x7   :error bit number
+	ldr	r5, [r3, #oNF_ESTAT0]
+	mov 	r2, r5, lsl #14
+	mov	r2, r2, lsr #21
+	mov 	r3, r5,	lsr #4
+	and	r3, r3, #0x7
+
+	mov	r4, #0x1
+	mov 	r4, r4, lsl r3	@ pattern to clear error
+	ldrb	r5, [r1, r2]	@ error byte in sdram
+	eor	r5, r5, r4	@ toggle error bit
+	strb	r5, [r1, r2]
+out:
+	ldmia   sp!, {r1 - r5, sl, pc}
+
+#endif /* CONFIG_BOOT_NAND */
diff --git a/board/cc9m2443/u-boot.lds b/board/cc9m2443/u-boot.lds
new file mode 100644
index 0000000..0e92e2c
--- /dev/null
+++ b/board/cc9m2443/u-boot.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/s3c24xx/start.o	(.text)
+	  cpu/s3c24xx/s3c2443/cpu_init.o	(.text)
+	  cpu/s3c24xx/onenand_cp.o	(.text)
+	  cpu/s3c24xx/nand_cp.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	__testhw_cmd_start = .;
+        .testhw_cmd : { *(.testhw_cmd) }
+        __testhw_cmd_end = .;
+	
+	. = ALIGN(4);
+	.mmudata : { *(.mmudata) }
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/cc9p921x/Makefile b/board/cc9p921x/Makefile
new file mode 100644
index 0000000..d2f0570
--- /dev/null
+++ b/board/cc9p921x/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+DIGI_DIR = $(TOPDIR)/common/digi
+DIGI_BSP = -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+CPPFLAGS += $(DIGI_BSP)
+
+OBJS	:= board.o flash.o
+SOBJS	:= platform.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/cc9p921x/board.c b/board/cc9p921x/board.c
new file mode 100644
index 0000000..ebc9323
--- /dev/null
+++ b/board/cc9p921x/board.c
@@ -0,0 +1,362 @@
+/*
+ *  board/cc9p921x/board.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <common.h>
+#include <nvram.h>
+#include <net.h>                /* eth_use_mac_from_env */
+#include <rtc.h>                /* rtc_get */
+
+#include <asm-arm/arch-ns9xxx/ns9xxx_mem.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+#include <config.h>
+#include <status_led.h>         /* also includes io.h */
+
+#include <cmd_chkimg.h>         /* CheckCRC32OfImageInFlash */
+#include <configs/cc9c.h>
+
+#define BOOTSTRAP_CS		0x3
+#define BOOTSTRAP_BASE_ADDRESS	0x30000000
+#define MBitToByte( mbit ) ( ( ( mbit ) * 1024 * 1024 ) / 8 )
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static char l_bBootFailed = 0;
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+extern void run_auto_script(void);
+#endif
+
+/* The following are used to control the SPI chip selects for the SPI command */
+#if (CONFIG_COMMANDS & CFG_CMD_SPI)
+#include <spi.h>
+
+void spi_chipsel_bitbang(int cs)
+{
+	if (cs)
+		gpio_ctrl_set(SPI_EN_GPIO, 0);
+	else
+		gpio_ctrl_set(SPI_EN_GPIO, 1);
+}
+
+spi_chipsel_type spi_chipsel[] = {
+	spi_chipsel_bitbang
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+#endif /* CFG_CMD_SPI */
+
+/**
+ * handle_user_keys - print's status of user keys and executes associated commands
+ */
+
+static void handle_user_keys( void )
+{
+#ifdef CONFIG_USER_KEY
+        static const int aiGPIO[] = {
+#ifdef USER_KEY1_GPIO
+                USER_KEY1_GPIO,
+#endif
+#ifdef USER_KEY2_GPIO
+                USER_KEY2_GPIO
+#endif
+        };
+
+        int i;
+
+        /* check what keys are pressed and whether there is a script */
+        for( i = 0; i < ARRAY_SIZE( aiGPIO ); i++ ) {
+                /* as input */
+                gpio_cfg_set( aiGPIO[ i ],
+                              GPIO_CFG_INPUT | GPIO_CFG_FUNC_GPIO );
+
+                if( !gpio_stat_get( aiGPIO[ i ] ) ) {
+                        char szCmd[ 30 ];
+
+                        printf( "\nUser Key %i pressed\n", i + 1 );
+                        sprintf( szCmd, "key%i", i + 1 );
+
+                        if( getenv( szCmd ) != NULL ) {
+                                sprintf(szCmd, "run key%i", i + 1);
+                                run_command( szCmd, 0 );
+                        }
+                }
+        } /* for( i = 0; ) */
+#endif /* CONFIG_USER_KEY */
+}
+
+/**
+ * board_print_cpu_status - print's some CPU and reset information
+ */
+
+static void print_board_cpu_status( void )
+{
+        const char*      szCause = NULL;
+        u32 uSysClkFreq = sys_clock_freq();
+        u32 uCPUClkFreq = cpu_clock_freq();
+        u32 uAHBClkFreq = ahb_clock_freq();
+        u32 uSysMisc    = sys_readl( SYS_MISC );
+        u32 uReset      = sys_readl( SYS_RESET );
+        u32 uAHB        = sys_readl( SYS_AHB_ERROR2 );
+
+#define CLOCK( clock ) (clock) / 1000000, ( ( (clock) % 1000000 ) / 10 )
+	printf( "CPU:   %s @ %i.%i MHz, SYS %i.%i MHz, AHB %i.%i MHz, Rev %i\n",
+                CPU,
+                CLOCK( uCPUClkFreq ),
+                CLOCK( uSysClkFreq ),
+                CLOCK( uAHBClkFreq ),
+                SYS_MISC_REV( uSysMisc ) );
+#undef CLOCK
+        printf( "Strap: 0x%04x\n", sys_readl(  SYS_GEN_ID ) );
+
+        /* Reset cause */
+        switch( uReset & SYS_RESET_STAT_MA ) {
+            case SYS_RESET_STAT_SW_WDOG:
+                szCause = "CPU Watchdog";
+                break;
+            case SYS_RESET_STAT_AHB:
+                szCause = "AHB";
+                break;
+            case SYS_RESET_STAT_SRESN:
+                szCause = "SRESET";
+                break;
+            case SYS_RESET_STAT_PLL:
+                /* this is the software reset command. This should be normal
+		 * The AHB Error information is not reset during software reset
+		 * and should be considered invalid */
+		return;
+            case SYS_RESET_STAT_RESN:
+                /* normal poweron. The AHB Error information is not reset
+		 * during power up and should be considered invalid */
+		return;
+            default:
+                eprintf( "Unknown reset cause: 0x%08x\n", uReset );
+                break;
+        }
+        if( NULL != szCause )
+                printf( "Reset: %s\n", szCause );
+
+        /* AHB Error */
+        if( uAHB &
+            ( SYS_AHB_ERROR2_IE |
+              SYS_AHB_ERROR2_DE |
+              SYS_AHB_ERROR2_ER ) ) {
+                /* clear it */
+                sys_rmw32( SYS_AHB_MON, | SYS_AHB_MON_EIC );
+                sys_rmw32( SYS_AHB_MON, & ~SYS_AHB_MON_EIC );
+        } /* if( uAHB ) */
+}
+
+static void inline user_led_init(void)
+{
+#ifndef CONFIG_CC9C
+	gpio_cfg_set( USER_LED1_GPIO,
+                              GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO );
+	gpio_cfg_set( USER_LED2_GPIO,
+                              GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO );
+	gpio_ctrl_set(USER_LED1_GPIO, 0);
+	gpio_ctrl_set(USER_LED2_GPIO, 0);
+#endif
+}
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(ENABLE_CONSOLE_GPIO)
+static void init_console_gpio(void)
+{
+	gpio_cfg_set( ENABLE_CONSOLE_GPIO, GPIO_CFG_INPUT | GPIO_CFG_FUNC_GPIO);
+}
+#endif
+
+/**
+ * board_init - early board initialization
+ * @return: always 0
+ */
+int board_init( void )
+{
+        /* icache already initialized in ASM */
+
+        /* we want an interrupt in case of an AHB error */
+        sys_writel( SYS_AHB_MON_SERDC, SYS_AHB_MON );
+
+	gd->bd->bi_arch_number = machine_arch_type;
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	user_led_init();
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(ENABLE_CONSOLE_GPIO)
+	init_console_gpio();
+#endif
+
+#ifdef	SPI_INIT
+	SPI_INIT;
+#endif
+
+	return 0;
+}
+
+/**
+ * misc_init_r -
+ */
+int misc_init_r( void )
+{
+	/* nothing to do */
+	return 0;
+}
+
+void dev_board_info( void )
+{
+	/* Nothing to do */
+}
+
+
+/**
+ * dram_init - initializes board SDRAM information
+ *
+ * @return: always 0
+ *
+ * Either the Debugger or platform.S:lowlevel_init have already setup the
+ * Memory Controller CS0 settings. We take the size information and setup the
+ * system controller's CS0 memory mask. The memory mask is reduced to detect
+ * more easily SW faults using wrong addresses.
+ *
+ * Only CS0 is probed.
+ */
+int dram_init( void )
+{
+        u32 uiSize;             /* in bytes */
+        u32 uiMask;
+        u32 uiMem = mem_readl( MEM_DYN_CFG( 0 ) );
+
+        /* [1], p. 208. Bits 11:9 encodes the size of SDRAM for all kinds of
+           memory. We use this as an index into auiMemSize */
+        static const u32 auiMemSize[ 8 ] = {
+                MBitToByte( 16 ),
+                MBitToByte( 64 ),
+                MBitToByte( 128 ),
+                MBitToByte( 256 ),
+                MBitToByte( 512 ),
+                0,
+                0,
+                0,
+        };
+
+        uiSize = auiMemSize[ MEM_DYN_CFG_AM1_SIZE( uiMem ) ];
+
+        /* set mask for detecting wrong accesses */
+        uiMask = ~(uiSize - 1) & 0xFFFFF000;
+        sys_writel( uiMask | SYS_CS_DYN_MASK_EN, SYS_CS_DYN_MASK( 0 ) );
+
+        /* tell U-Boot what we have */
+	gd->bd->bi_dram[ 0 ].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[ 0 ].size  = uiSize;
+
+        /* dcache depends on bi_dram */
+        dcache_enable();
+
+	return 0;
+}
+
+#if (COMMANDS & CFG_CMD_DATE)
+/**
+ * print_date - prints date/time
+ */
+void print_date( void )
+{
+	struct rtc_time tm;
+
+         /* rtc_get should be called in any case as it kicks a not running
+          * clock */
+      	rtc_get( &tm );
+
+        printf( "Date:  %02d:%02d:%02d - %04d-%02d-%02d\n",
+                tm.tm_hour, tm.tm_min, tm.tm_sec,
+                tm.tm_year, tm.tm_mon, tm.tm_mday );
+}
+#else
+void print_date( void )
+{
+}
+#endif
+
+int eth_use_mac_from_env( bd_t* pbis );
+/**
+ * board_late_init - last step before console
+ */
+int board_late_init( void )
+{
+        const nv_info_t* pInfo  = NULL;
+	nv_critical_t*   pNvram = NULL;
+
+        print_board_cpu_status();
+        print_date();
+
+	if( NvCriticalGet( &pNvram ) )
+                pInfo = NvInfo();
+
+        if( ( pInfo == NULL ) || pInfo->bAnyBad )
+                /* we should really boot with a valid NVRAM. Default Workcopy
+                 * is always present, but shouldn't never happend */
+                l_bBootFailed |= 1;
+
+        /* copy bdinfo to start of boot-parameter block */
+ 	memcpy( (int*)gd->bd->bi_boot_params, gd->bd, sizeof( bd_t ) );
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+        eth_use_mac_from_env( gd->bd );
+#endif
+
+#if defined(CONFIG_UBOOT_CHECK_CRC32_ON_BOOT) && defined(CFG_APPEND_CRC32) && !defined(CFG_NO_FLASH)
+        if( !CheckCRC32OfImageInFlash( 1 ) )
+                l_bBootFailed |= 1;
+#endif
+#ifdef CONFIG_STATUS_LED
+        status_led_set( STATUS_LED_BOOT, STATUS_LED_ON );
+        status_led_set( STATUS_LED_ERROR,
+                        ( l_bBootFailed ? STATUS_LED_ON : STATUS_LED_OFF ) );
+#endif
+        /* handle_user_keys might never return */
+        handle_user_keys();
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+	run_auto_script();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+void show_boot_progress( int status )
+{
+	if( status < 0 ) {
+#ifdef CONFIG_STATUS_LED
+        	/* ready to transfer to kernel, make sure LED is proper state */
+        	status_led_set( STATUS_LED_BOOT, STATUS_LED_ON );
+#endif
+	}
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+#if defined(CONFIG_SILENT_CONSOLE)
+int test_console_gpio (void)
+{
+#if defined(ENABLE_CONSOLE_GPIO) && defined(CONSOLE_ENABLE_GPIO_STATE)
+	if (gpio_stat_get(ENABLE_CONSOLE_GPIO) == CONSOLE_ENABLE_GPIO_STATE)
+		return 1;
+	else
+		return 0;
+#else
+	return 0;
+#endif
+}
+#endif
diff --git a/board/cc9p921x/config.mk b/board/cc9p921x/config.mk
new file mode 100644
index 0000000..908e95a
--- /dev/null
+++ b/board/cc9p921x/config.mk
@@ -0,0 +1,4 @@
+# assume there is at least 8MB RAM.  Linux should be loaded to 0x8000, so
+# U-Boot resides at the high end.
+TEXT_BASE = 0x00100000
+DIGI_BOARD = y
diff --git a/board/cc9p921x/flash.c b/board/cc9p921x/flash.c
new file mode 100644
index 0000000..6595437
--- /dev/null
+++ b/board/cc9p921x/flash.c
@@ -0,0 +1,134 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if !defined(CFG_NO_FLASH)
+#undef FLASH_DEBUG
+
+#undef CFG_FLASH_BASE
+#define CFG_FLASH_BASE 0x50000000
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+#undef  CFG_FLASH_WORD_SIZE
+#define CFG_FLASH_WORD_SIZE unsigned short
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#if 0
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+#endif
+#define CFG_FLASH_ADDR0		0x555
+#define CFG_FLASH_ADDR1		0x2AA
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+#define CFG_MONITOR_BASE CFG_FLASH_BASE
+#define CFG_MONITOR_LEN (256*1024)
+
+#include "../common/flash_common.c"
+
+uint nor_flash_base = CFG_FLASH_BASE;
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	unsigned long total_b = 0;
+	unsigned long size_b[CFG_MAX_FLASH_BANKS];
+	int i;
+
+	{
+		vu_long * base_addr = (vu_long*)0x400;
+		ulong temp;
+
+		temp = *base_addr;
+		*base_addr = 0x20764316;
+		if (*base_addr != 0x20764316)
+			nor_flash_base = 0;
+		*base_addr = temp;
+	}
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		flash_info[i].sector_count = -1;
+		flash_info[i].size = 0;
+
+		/* call flash_get_size() to initialize sector address */
+		size_b[i] = flash_get_size((vu_long *)nor_flash_base, &flash_info[i]);
+		flash_info[i].size = size_b[i];
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifdef FLASH_DEBUG
+			printf("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+			       i, size_b[i], size_b[i] << 20);
+#endif
+			flash_info[i].sector_count = -1;
+			flash_info[i].size = 0;
+		}
+
+
+		total_b += flash_info[i].size;
+	}
+
+#if 0	/* by scsuh. removed for simple usage */
+	/* Monitor protection ON by default */
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_MONITOR_BASE,
+			    CFG_MONITOR_BASE + CFG_MONITOR_LEN - 1,
+			    &flash_info[0]);
+#endif
+
+#ifdef CFG_ENV_IS_IN_FLASH
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_ENV_ADDR,
+			    CFG_ENV_ADDR + CFG_ENV_SECT_SIZE - 1,
+			    &flash_info[0]);
+	(void)flash_protect(FLAG_PROTECT_SET, CFG_ENV_ADDR_REDUND,
+			    CFG_ENV_ADDR_REDUND + CFG_ENV_SECT_SIZE - 1,
+			    &flash_info[0]);
+#endif
+
+	return total_b;
+}
+#endif
+
diff --git a/board/cc9p921x/platform.S b/board/cc9p921x/platform.S
new file mode 100644
index 0000000..1aa6bb0
--- /dev/null
+++ b/board/cc9p921x/platform.S
@@ -0,0 +1,558 @@
+/*
+ *  board/cc9p921x/platform.S
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] Sebastien's bdi2000 debugger config file
+ *               [2] /net/r/TEILE/TM02981/64MSDRAM.pdf
+ *  !Descr:      No autodetection of SDRAM is performed. It is hardcoded into assembler. If different memory is being used
+*/
+
+#include <config.h>
+
+#include <status_led.h>
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+
+#define C1_IC		(1<<12)		/* icache off/on */
+#define DUMMY1		0xdeadbeef  @ For "kicking" the SDRAM controller
+#define DUMMY2		0xbadc0ffe  @ and associated internal cache
+
+/* calibrated using _blink_led: BLINK_ERROR 0x55555555 and BLINK_DELAY 1 */
+#define COUNT_FOR_1MS 	0x9248
+
+
+/**
+ * mdelay - MACRO. Delays for about 1ms or longer (calibrated on
+ *          149 MHz CC9P9215)
+ * @r7: temp
+ * @r8: temp
+ */
+.macro	mdelay ms
+        ldr     r7, =\ms
+1:
+        ldr     r8, =COUNT_FOR_1MS
+2:
+        /* wait approx 1ms */
+        subs    r8, r8, #1
+        bne     2b
+
+        /* count down milliseconds */
+        subs    r7, r7, #1
+        bne     1b
+.endm /* mdelay */
+
+/**
+ * write_register_block - MACRO
+ * @r0: register base address
+ * @r1: start of register set (in RAM)
+ * @r2: end of register set (in RAM)
+ * @r3: linked RAM base address of U-Boot
+ * @r4: ROM base address
+ * @r5: temp
+ * @r6: temp
+ * @return: nothing
+ *
+ * Copies the register block of register_offset/register value to
+ * the registers at base r0
+ */
+
+.macro	write_register_block
+	/* convert the RAM addresses (+TEXT_BASER) to ROM addresses (0x0) */
+	sub	r1, r1, r3
+	add	r1, r1, r4
+	sub	r2, r2, r3
+	add	r2, r2, r4
+
+	/* copy all */
+1:
+	/* Write register/value pair starting at [r1] to register base r0 */
+	ldr	r5, [r1], #4
+	ldr	r6, [r1], #4
+	str	r6, [r0,r5]
+	cmp	r1, r2
+	blt	1b
+.endm /* write_register_block */
+
+/**
+ * gpio_ctrl_set_0 - sets the GPIO to 0
+ * @r0-r4: tmp
+ */
+.macro gpio_ctrl_set_0	gpio
+        ldr	r1, =( GPIO_BASE_PA + GPIO_CTRL_BASE )
+        ldr     r2, =( ( \gpio / 32 ) * 4 )
+        mov     r3, #( \gpio & 0x1f )
+        mov     r4, #1
+        ldr     r0, [r1, r2 ]
+        bic     r0, r0, r4, lsl r3
+        str     r0, [r1, r2 ]
+.endm
+
+/**
+ * gpio_ctrl_set_1 - sets the GPIO to 1
+ * @r0-r4: tmp
+ */
+.macro gpio_ctrl_set_1	gpio
+        ldr	r1, =( GPIO_BASE_PA + GPIO_CTRL_BASE )
+        ldr     r2, =( ( \gpio / 32 ) * 4 )
+        mov     r3, #( \gpio & 0x1f )
+        mov     r4, #1
+        ldr     r0, [r1, r2 ]
+        orr     r0, r0, r4, lsl r3
+        str     r0, [r1, r2 ]
+.endm
+
+/**
+ * gpio_cfg_as_output - MACRO
+ * @r0-r5: tmp
+ *
+ * GPIO is set as output
+ * Copies the register block of register_offset/register value to
+ * the registers at base r0
+ */
+.macro  gpio_cfg_as_output	gpio
+        /* see gpio_cfg_set() */
+        ldr	r1, =( GPIO_BASE_PA + GPIO_CFG_BASE )
+        ldr     r2, =( \gpio / 4 ) * 4
+        ldr     r3, =( ( \gpio & 0x3 ) * 8 )
+        ldr     r4, =(GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO)
+        ldr     r5, =GPIO_CFG_MA
+        ldr     r0, [r1, r2 ]
+        bic     r0, r0, r5, lsl r3
+        orr     r0, r0, r4, lsl r3
+        str     r0, [r1, r2 ]
+.endm
+
+/**
+ * gpio_block_cfg_as_func0 - configures a block of gpio, start at gpio_start
+ * and ending at gpio_end, as func0
+ * @r0-r8: tmp
+ */
+.macro  gpio_block_cfg_as_func0	gpio_start, gpio_end
+        ldr     r6, =\gpio_start
+        ldr     r7, =\gpio_end
+        ldr	r1, =( GPIO_BASE_PA + GPIO_CFG_BASE )
+        ldr     r4, =GPIO_CFG_FUNC_0
+        ldr     r5, =GPIO_CFG_MA
+        ldr     r8, =~0x3
+1:
+        /* see gpio_cfg_set() */
+        mov     r2, r6
+        and     r2, r2, r8
+        mov     r3, r6
+        and     r3, r3, #0x3
+        mov     r3, r3, lsl #0x3
+        ldr     r0, [r1, r2 ]
+        bic     r0, r0, r5, lsl r3
+        orr     r0, r0, r4, lsl r3
+        str     r0, [r1, r2 ]
+
+        add     r6, r6, #1
+        cmp     r6, r7
+        ble     1b
+.endm
+
+#define BLINK_ERROR     0xA8CCC2A0 /* SOS, 3 short, 3 long, 3 short */
+#define BLINK_DELAY	0x00000100
+
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+#include <asm-arm/arch-ns9xxx/ns9xxx_mem.h>
+
+/* ********** defines ********** */
+
+#define CS0     	0
+#define CS1		1
+
+#define CS0_MODE	0x00019800 /* [2], Burst length = 3, CAS latency = 3 */
+
+/* Memory Setup Definitions:
+ * struct { u32 uOffs; u32 uVal; } axCfg[];
+ * for each axCfg[i], uVal needs to be written to r0+uOffs
+
+/* Boot flash, [1] */
+_CS1_CFG_START:
+        .word	MEM_STAT_CFG( CS1 )
+        .word	MEM_STAT_CFG_PB | \
+                MEM_STAT_CFG_MW_16
+
+        .word	MEM_STAT_WAIT_WEN( CS1 )
+        .word	MEM_STAT_WAIT_WEN_VAL( 0 )
+
+        .word	MEM_STAT_WAIT_OEN( CS1 )
+        .word	MEM_STAT_WAIT_OEN_VAL( 1 )
+
+        .word	MEM_STAT_RD( CS1 )
+        .word	MEM_STAT_RD_VAL( 0x8 )
+
+        .word	MEM_STAT_WR( CS1 )
+        .word	MEM_STAT_WR_VAL( 0x8 )
+
+        .word	MEM_STAT_PAGE( CS1 )
+        .word	MEM_STAT_PAGE_VAL( 0 )
+
+        .word	MEM_STAT_TURN( CS1 )
+        .word	MEM_STAT_TURN_VAL( 2 )
+_CS1_CFG_END:
+
+/* Main SDRAM, [1] */
+_CS0_CFG_BASE_START:
+        .word   MEM_DYN_REFRESH
+        .word   MEM_DYN_REFRESH_VAL( 0x18 )
+
+        .word   MEM_DYN_READ_CFG
+        .word   MEM_DYN_READ_CFG_DELAY0 /*Command delayed strategy, using CLKDELAY (command delayed, clock out not delayed) */
+
+        .word   MEM_DYN_TRP
+        .word   MEM_DYN_TRP_VAL( 1 )  /* tRP = 27ns (min) => 2xAHB_CLK */
+
+        .word   MEM_DYN_TRAS
+        .word   MEM_DYN_TRAS_VAL( 4 )  /* tRAS = 67ns (min) => 5xAHB_CLK */
+
+        .word   MEM_DYN_TSREX
+        .word   MEM_DYN_TSREX_VAL( 5 )  /*tSREX = 80ns (min) => 6xAHB_CLK */
+
+        .word   MEM_DYN_TAPR
+        .word   MEM_DYN_TAPR_VAL( 1 )  /* value programmed in tRP - 1 */
+
+        .word   MEM_DYN_TDAL
+        .word   MEM_DYN_TDAL_VAL( 5 )  /* tDAL/APW = 6tCK (min) => 6xAHB_CLK */
+
+        .word   MEM_DYN_TWR
+        .word   MEM_DYN_TWR_VAL( 1 )  /* tWR/DPL/RWL/RDL = 2tCK (min) => 2xAHB_CLK */
+
+        .word   MEM_DYN_TRC
+        .word   MEM_DYN_TRC_VAL( 6 )  /* tRC = 80ns */
+
+        .word   MEM_DYN_TRFC
+        .word   MEM_DYN_TRFC_VAL( 6 )  /* tRFC = 80ns */
+
+        .word   MEM_DYN_TXSR
+        .word   MEM_DYN_TXSR_VAL( 5 )  /* tXSR = 80ns (min) */
+
+        .word   MEM_DYN_TRRD
+        .word   MEM_DYN_TRRD_VAL( 1 )  /* tRRD = 2tCK (min) => 2xAHB_CLK */
+
+        .word   MEM_DYN_TMRD
+        .word   MEM_DYN_TMRD_VAL( 1 )  /* tMRC = 2tCK (min) => 2xAHB_CLK */
+
+_CS0_CFG_BASE_END:
+
+_CS0_CFG_BASE2_START:
+        .word   MEM_DYN_RAS_CAS( CS0 )
+        .word   MEM_DYN_RAS_CAS_CAS( 0x3 ) | \
+                MEM_DYN_RAS_CAS_RAS( 0x3 )
+
+        .word   MEM_DYN_CTRL
+        .word   MEM_DYN_CTRL_I_PALL | \
+                MEM_DYN_CTRL_BIT1   | \
+                MEM_DYN_CTRL_CE
+
+        .word   MEM_DYN_REFRESH
+        .word   MEM_DYN_REFRESH_VAL( 0x1 ) /* Set to minimum for having eight
+                                               SDRAM access during the
+                                              1ms wait time */
+_CS0_CFG_BASE2_END:
+
+/* a delay needs to be done before setting CFG_MODE values after CFG_BASE */
+_CS0_CFG_MODE_START:
+        .word   MEM_DYN_REFRESH
+        .word   MEM_DYN_REFRESH_VAL( 0x18 ) /*((64e-3 / 4096) * 75e+6) / 16 = 73 = 0x49 */
+
+        .word   MEM_DYN_CTRL
+        .word   MEM_DYN_CTRL_I_MODE | \
+                MEM_DYN_CTRL_BIT1   | \
+                MEM_DYN_CTRL_CE
+_CS0_CFG_MODE_END:
+
+/* the memory needs to be configured by reading before setting CFG_NORMAL */
+_CS0_CFG_NORMAL_START:
+        .word   MEM_DYN_CTRL
+        .word   MEM_DYN_CTRL_I_NORMAL | \
+                MEM_DYN_CTRL_BIT1     | \
+                MEM_DYN_CTRL_CE
+_CS0_CFG_NORMAL_END:
+#endif /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+_PHYS_FLASH_1:
+	.word	PHYS_FLASH_1    /* real flash address on CS1 */
+
+/** _blink_led - blinks the bit pattern in r0, starting from 0.
+ * @r0:  contains the 32bit pattern, e.g. BLINK_ERROR
+ * @r1: temp (register address of GPIO)
+ * @r2: temp (GPIO register)
+ * @r3: temp (bit position in GPIO register)
+ * @r4: temp (always #1)
+ * @r5: temp (bit position in r0)
+ * @r6: GPIO control register
+ * @return: never *
+ *
+ * bit set to 1 means light, 0 means off
+ */
+
+	.type _blink_led,function
+_blink_led:
+        /* determine GPIO address */
+        ldr	r1, =( GPIO_BASE_PA + GPIO_CTRL_BASE )
+        ldr     r2, =( ( STATUS_LED_BIT / 32 ) * 4 )
+        mov     r3, #( STATUS_LED_BIT & 0x1f )
+        ldr     r6, [r1, r2 ]   /* get current GPIO value */
+        mov     r4, #1
+
+_blink_led_pattern:
+        mov     r5, #0         /* start at bit 0 in r0 */
+
+_blink_led_pattern_bit:
+        tst     r0, r4, lsl r5  @ what bit is set in r0
+        biceq   r6, r6, r4, lsl r3
+        orrne   r6, r6, r4, lsl r3
+        str     r6, [r1, r2 ]   /* light or darken LED based on bit in r0 */
+
+        mdelay  BLINK_DELAY     /* human eyes are so sloooowwwwww */
+
+        /* determine next bit to be displayed*/
+        add     r5, r5, #1
+        cmp     r5, #32
+        bne	_blink_led_pattern_bit
+
+        /* continue from beginning */
+        b       _blink_led_pattern
+
+/** _handle_data_mismatch - blinks SOS on data mismatch
+ * @r0: address1 _after_ error
+ * @r1: address2 _after_ bogus word
+ * @r3: data word from address1
+ * @r4: data word from address2
+ *
+ * r0,r1 will be moved to r7,r8 and r3,r4 to r12,r13, so a debugger might
+ * return it.
+ */
+
+	.type _handle_data_mismatch,function
+        .globl _handle_data_mismatch
+_handle_data_mismatch:
+        mov     r7,  r0
+        mov     r8,  r1
+        mov     r12, r3
+        mov     r13, r4
+        ldr     r0, =BLINK_ERROR
+        b       _blink_led
+
+/** lowlevel_init - configure memory settings and error LED
+ *
+ * r12 and r14 both contain link registers from cpu_init_critical and reset.
+ * They mustn't be changed.
+ */
+	.type lowlevel_init,function
+        .globl lowlevel_init
+lowlevel_init:
+__full_cpu_clock_and_low_power:
+        /* CPU will be run with 2*x AHB clock, not necessary modules are
+           disabled for EMI */
+        ldr     r1, =( SYS_BASE_PA + SYS_CLOCK )
+        ldr     r2, =( SYS_CLOCK_CSC_1     | \
+                       SYS_CLOCK_MAX_CSC_1 | \
+                       SYS_CLOCK_CCSEL     | \
+                       SYS_CLOCK_MCCOUT( 0 ) | \
+                       SYS_CLOCK_IO )
+        str     r2, [r1]
+
+_error_led_set_on:
+        gpio_ctrl_set_0    STATUS_LED_BIT
+
+_error_led_cfg_as_output:
+        gpio_cfg_as_output STATUS_LED_BIT
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+_enable_icache:
+        /* boost instruction processing */
+        mrc     15, 0, r0, cr1, cr0
+        orr     r0, r0, #C1_IC
+        mcr     15, 0, r0, cr1, cr0
+#endif
+
+#ifdef CFG_STRAP_PUT_ETH_OUT_OF_RESET
+        /* is strapping pin set? */
+        ldr     r1, = (SYS_BASE_PA + SYS_GEN_ID)
+        ldr     r2, [r1]
+        ldr     r3, =CFG_STRAP_PUT_ETH_OUT_OF_RESET
+        ands     r2, r2, r3
+        bne     _phy_cfg_done  /* not wanted, e.g. to save power */
+
+_put_phy_out_of_reset:
+        /* strapping is set, reduce network setup time by doing it here.
+           This means more power and EMI */
+        ldr     r1, = (SYS_BASE_PA + SYS_CLOCK)
+        ldr     r2, [r1]
+        ldr     r3, = SYS_CLOCK_ETH
+        orr     r2, r2, r3
+        str     r2, [r1]
+
+_configure_eth_gpios:
+        /* the phy needs the correct signals */
+        gpio_block_cfg_as_func0 32, 49
+
+_take_phy_out_of_reset:
+        gpio_ctrl_set_1    GPIO_ETH_PHY_RESET
+        gpio_cfg_as_output GPIO_ETH_PHY_RESET
+_phy_cfg_done:
+#endif /* CFG_STRAP_PUT_ETH_OUT_OF_RESET */
+
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+_configure_mem_ctrl:
+        /* where we relocate data from/to. */
+       	ldr	r3, _TEXT_BASE
+	ldr	r4, _PHYS_FLASH_1
+        /* don't touch r3 and r4 any longer. They will be needed a lot */
+_finetune_cs1:
+        ldr	r0, =MEM_BASE_PA
+	ldr	r1, =_CS1_CFG_START
+	ldr	r2, =_CS1_CFG_END
+
+	write_register_block
+
+_check_running_from_PHYS_FLASH_1:
+        /* check to see if we are running from 0x0 (normal reset) or
+         * already from PHYS_FLASH_1 (software jump to 0x50000000).
+         * Then there is no relocate + PHYS_FLASH_1 */
+        mov     r0, pc
+        ldr     r1, =_PHYS_FLASH_1
+        cmp     r0, r1
+        bgt     _setup_cs0_from_cs1
+
+_prepare_jump_to_cs1:
+       	/* at this point, we are running from 0x0, which will be CS0
+           Adjust pc and lr to be on CS1 */
+        add     lr, lr, r4      /* return to CS1:cpu_init_crit, not 0:cpu_init_crit. This has been called from 0x0, not TEXT_BASE */
+        add     ip, ip, r4      /* return to CS1:reset, not 0:reset */
+
+      	ldr	r0, =_setup_cs0_from_cs1
+	sub	r0, r0, r3      /* PC is also on CS1 */
+	add	r0, r0, r4
+	mov	pc, r0
+	nop			/* for pipelining */
+
+_setup_cs0_from_cs1:
+	/* now we are running from CS1 (PHYS_FLASH_1), safe to
+         *  hazzle with CS0 */
+
+	/* Enable SDRAM */
+	ldr	r0, =MEM_BASE_PA
+	ldr	r1, =MEM_CTRL_E
+	str	r1, [r0, #MEM_CTRL]
+
+	/* NOP SDRAM command */
+#define NOP_SDRAM	0x183
+	ldr	r1, =NOP_SDRAM
+	str	r1, [r0, #MEM_DYN_CTRL]
+
+	/* Wait at least for 200ms before PALL command */
+	mdelay	200
+
+	ldr	r0, =MEM_BASE_PA
+	ldr	r1, =_CS0_CFG_BASE_START
+	ldr	r2, =_CS0_CFG_BASE_END
+
+	write_register_block
+
+	/* Set Dynamic Memory Configuration 0 register
+	   depending on content of GEN_ID */
+
+	ldr     r1, =(SYS_BASE_PA + SYS_GEN_ID)
+	ldr     r9, [r1]
+	mov	r9, r9, lsr #8
+	and	r9, r9, #7
+	rsb	r9, r9, #8
+
+	ldr	r5, =0x80
+	orr	r9, r5, r9, lsl #9
+	ldr	r1, =(MEM_BASE_PA + MEM_DYN_CFG(CS0))
+	str	r9, [r1]
+
+	/* RAS/CAS, PALL command, REFRESH 1 */
+	ldr	r0, =MEM_BASE_PA
+	ldr	r1, =_CS0_CFG_BASE2_START
+	ldr	r2, =_CS0_CFG_BASE2_END
+
+	write_register_block
+
+	/* Give the SDRAM some time to stabilize by executing
+	 * some dummy operations */
+#define DUMMY_REG	0xa0900000
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+	ldr	r1, =DUMMY_REG
+	ldr	r2, [r0, #0]
+
+       	ldr	r1, =_CS0_CFG_MODE_START
+	ldr	r2, =_CS0_CFG_MODE_END
+
+	write_register_block
+
+        ldr     r5, =CS0_MODE
+	/* if bit 10 is set -> need to shift one more */
+	tst	r9, #0x400
+	movne	r5, r5, lsl #1
+        ldr     r6, [r5] /* A read transaction from the SDRAM memory programs the mode register */
+
+       	ldr	r1, =_CS0_CFG_NORMAL_START
+	ldr	r2, =_CS0_CFG_NORMAL_END
+
+	write_register_block
+
+	ldr	r5, =MEM_DYN_CFG_BDMC
+	orr	r9, r9, r5
+	ldr	r1, =(MEM_BASE_PA + MEM_DYN_CFG(CS0))
+	str	r9, [r1]
+
+	/* Do some dummy reads, writes, and then more reads (from
+	 * locations we didn't write to) in the hopes that there
+	 * SDRAM controller will become stable and the internal
+	 * cache will be sane */
+	mov	r0, #0
+	ldr	r1, [r0, #0x0]
+	ldr	r1, [r0, #0x4]
+	ldr	r1, [r0, #0x8]
+	ldr	r1, [r0, #0xc]
+
+	ldr	r1, =DUMMY1
+	ldr	r2, =DUMMY2
+	str	r1, [r0, #0x0]
+	str	r2, [r0, #0x4]
+	str	r1, [r0, #0x8]
+	str	r2, [r0, #0xc]
+
+	ldr	r1, [r0, #0x10]
+	ldr	r1, [r0, #0x14]
+	ldr	r1, [r0, #0x18]
+	ldr	r1, [r0, #0x1c]
+        /* all registers, even r3,r4  can now be modified */
+
+        /* Detect SDRAM */
+#endif /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+
+       	mov	pc, lr		/* cpu_init_crit will continue */
diff --git a/board/cc9p921x/u-boot.lds b/board/cc9p921x/u-boot.lds
new file mode 100644
index 0000000..6d5b1cf
--- /dev/null
+++ b/board/cc9p921x/u-boot.lds
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+        __testhw_cmd_start = .;
+        .testhw_cmd : { *(.testhw_cmd) }
+        __testhw_cmd_end = .;
+
+	. = ALIGN(4);
+
+        __u_boot_crc32 = .; /* will be filled with append_crc32 */
+	__bss_start = . + 4; /* immediately after __u_boot_crc32 */
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/cc9p9xxx/Makefile b/board/cc9p9xxx/Makefile
new file mode 100644
index 0000000..8b6b3b9
--- /dev/null
+++ b/board/cc9p9xxx/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+DIGI_DIR = $(TOPDIR)/common/digi
+DIGI_BSP = -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+CPPFLAGS += $(DIGI_BSP)
+
+OBJS	:= cc9p9xxx.o fpga.o 
+SOBJS	:= platform.o nandboot.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff --git a/board/cc9p9xxx/cc9p9xxx.c b/board/cc9p9xxx/cc9p9xxx.c
new file mode 100644
index 0000000..2a03d8b
--- /dev/null
+++ b/board/cc9p9xxx/cc9p9xxx.c
@@ -0,0 +1,328 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Copyright (C) 2004-2005 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ * Markus Pietrek <mpietrek@fsforth.de>
+ * derived from omap1610innovator.c
+ * @References: [1] NS9750 Hardware Reference/December 2003
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <ns9750_bbus.h>
+#include <ns9750_mem.h>
+#include <ns9750_sys.h>
+#include <nvram.h>
+#include <net.h>
+#include "spi_ver.h"
+
+#ifdef CONFIG_STATUS_LED
+# include <status_led.h>
+static int status_led_fail = 0;
+#endif /* CONFIG_STATUS_LED */
+
+#ifdef CONFIG_IEEE1588
+#include "fpga_checkbitstream.h"
+#endif
+
+void flash__init( void );
+void ether__init( void );
+static void cc9p9360_gpio_init (void);
+#ifdef CONFIG_A9M9750DEV
+static void a9m9750dev_fpga_init(void);
+#endif
+#ifdef CONFIG_IEEE1588
+static void ieee1588_load_firmware(void);
+#endif
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+extern void run_auto_script(void);
+#endif
+
+#define WCE_BOOTARGS_ADDR	0x8000
+
+/***********************************************************************
+ * @Function: board_init
+ * @Return: 0
+ * @Descr: Enables BBUS modules and other devices
+ ***********************************************************************/
+int board_init( void )
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	icache_enable();
+        /* dcache is enabled after dram has been initialized */
+
+	/* Active BBUS modules */
+	*get_bbus_reg_addr( NS9750_BBUS_MASTER_RESET ) = 0;
+
+	gd->bd->bi_arch_number = machine_arch_type;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+
+	cc9p9360_gpio_init();
+
+#ifdef CONFIG_A9M9750DEV
+	a9m9750dev_fpga_init();
+#endif
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: cc9p9360_gpio_init
+ * @Return: Nothing
+ * @Descr: Processor GPIO initialization on cc9p9360 module
+ ***********************************************************************/
+static void cc9p9360_gpio_init (void)
+{
+#if defined(CONFIG_USER_KEY)
+	/* Configure Key1 and Key2 as inputs */
+	set_gpio_cfg_reg_val( USER_KEY1_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_INPUT);
+	set_gpio_cfg_reg_val( USER_KEY2_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_INPUT);
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CONFIG_STATUS_LED)
+	/* Configure Led1 and Led2 as outputs */
+	set_gpio_cfg_reg_val( USER_LED1_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_OUTPUT);
+	set_gpio_cfg_reg_val( USER_LED2_GPIO,
+			NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_OUTPUT);
+	/* Set outputs to off */
+	__led_set( USER_LED1_GPIO, STATUS_LED_OFF );
+	__led_set( USER_LED2_GPIO, STATUS_LED_OFF );
+#endif
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(ENABLE_CONSOLE_GPIO)
+	set_gpio_cfg_reg_val( ENABLE_CONSOLE_GPIO, NS9750_GPIO_CFG_FUNC_GPIO |
+			NS9750_GPIO_CFG_INPUT);
+#endif
+}
+
+#ifdef CONFIG_A9M9750DEV
+static void a9m9750dev_fpga_init(void)
+{
+	/* setup CS0 */
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_BASE( 0 ) ) = 0x40000000;
+	*get_sys_reg_addr( NS9750_SYS_CS_STATIC_MASK( 0 ) ) = 0xfffff001;
+	*get_mem_reg_addr( NS9750_MEM_STAT_CFG( 0 ) ) = NS9750_MEM_STAT_CFG_MW_8 | NS9750_MEM_STAT_CFG_PB;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WAIT_WEN( 0 ) ) = 0x2;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WAIT_OEN( 0 ) ) = 0x2;
+	*get_mem_reg_addr( NS9750_MEM_STAT_RD( 0 ) ) = 0x6;
+	*get_mem_reg_addr( NS9750_MEM_STAT_WR( 0 ) ) = 0x6;
+
+	/* setup CS2 */
+        *get_sys_reg_addr( NS9750_SYS_CS_STATIC_BASE( 2 ) ) = 0x60000000;
+        *get_sys_reg_addr( NS9750_SYS_CS_STATIC_MASK( 2 ) ) = 0xff000001;
+        *get_mem_reg_addr( NS9750_MEM_STAT_CFG( 2 ) ) = NS9750_MEM_STAT_CFG_MW_16 | NS9750_MEM_STAT_CFG_PB;
+        *get_mem_reg_addr( NS9750_MEM_STAT_WAIT_WEN( 2 ) ) = 0x2;
+        *get_mem_reg_addr( NS9750_MEM_STAT_WAIT_OEN( 2 ) ) = 0x2;
+        *get_mem_reg_addr( NS9750_MEM_STAT_RD( 2 ) ) = 0x6;
+        *get_mem_reg_addr( NS9750_MEM_STAT_WR( 2 ) ) = 0x6;
+}
+#endif
+
+#ifdef CONFIG_IEEE1588
+static void ieee1588_load_firmware(void)
+{
+	int ret;
+	const nv_param_part_t* pPartEntry;
+
+	if(!NvParamPartFind(&pPartEntry, NVPT_FPGA, NVFS_NONE, 0, 0))
+		ret = LOAD_FPGA_FAIL;
+	else {
+		PartRead(pPartEntry, (void *)CFG_LOAD_ADDR, CFG_FPGA_SIZE, 1);
+		ret = fpga_checkbitstream((void *)CFG_LOAD_ADDR, CFG_FPGA_SIZE);
+	}
+	if(ret == LOAD_FPGA_OK) {
+		printf("FPGA: bitstream ok, loading to device...\n");
+		ret = fpga_load((void *)CFG_LOAD_ADDR, CFG_FPGA_SIZE);
+	}
+	if(ret != LOAD_FPGA_OK) {
+		run_command("setenv bootcmd", 0);
+		printf("autoboot disabled due to FPGA problems!\n");
+	}
+}
+#endif
+
+
+int misc_init_r (void)
+{
+	/* currently empty */
+	return (0);
+}
+
+void dev_board_info( void )
+{
+	/* Nothing to do */
+}
+
+/***********************************************************************
+ * @Function: Get_SDRAM_Size
+ * @Return: The SDRAM size for the first bank
+ * @Descr: Returns the sdram size for the first bank. The information
+ *         is read from the CS configuration.
+ ***********************************************************************/
+static ulong Get_SDRAM_Size(void)
+{
+	/* !!!This function is only working, if the correct SPI bootloader is used!!! */
+        ulong size;
+	ulong base;
+
+	base = (*get_sys_reg_addr(NS9750_SYS_CS_DYN_BASE(0)) & 0xFFFFF000);
+	size = ~(*get_sys_reg_addr(NS9750_SYS_CS_DYN_MASK(0)) & 0xFFFFF000) + 1;
+	base += size;
+
+	if ((*get_sys_reg_addr(NS9750_SYS_CS_DYN_BASE(1)) & 0xFFFFF000) == base)
+		size += size;	/* second bank equipped */
+
+	return size;
+}
+
+/***********************************************************************
+ * @Function: dram_init
+ * @Return: 0 always
+ * @Descr: Initializes the board SDRAM information
+ ***********************************************************************/
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = Get_SDRAM_Size();
+
+#if CONFIG_NR_DRAM_BANKS > 1
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+#endif
+
+        /* now we now the memory size, enable dcache */
+        dcache_enable();
+        
+	return 0;
+}
+
+#ifdef BOARD_LATE_INIT
+int board_late_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	nv_critical_t *pNvram;
+	volatile uint32_t *wce_bootargs = (volatile uint32_t *)WCE_BOOTARGS_ADDR;
+	char cmd[60];
+
+	printf("CPU:   %s @ %i.%iMHz\n", CPU, CPU_CLK_FREQ/1000000 , CPU_CLK_FREQ %1000000);
+
+#ifdef CONFIG_HAVE_SPI_LOADER
+        ns9xxx_print_spi_version();
+#endif  /* CONFIG_HAVE_SPI_LOADER */
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP)
+	if (NvCriticalGet(&pNvram)) {
+		/* Pass location of environment in memory to OS through bi */
+		gd->bd->nvram_addr = (unsigned long)pNvram;
+	}
+#endif
+	 /* copy bdinfo to start of boot-parameter block */
+ 	memcpy((int*)gd->bd->bi_boot_params, gd->bd, sizeof(bd_t));
+
+	/* Clean Windows CE bootargs signature at address WCE_BOOTARGS_ADDR
+	 * This is necessary to ensure WinCE knows when is in debug mode
+	 * Eboot writes the magic signature on that address */
+	*wce_bootargs = 0;
+
+#ifdef CONFIG_IEEE1588
+	ieee1588_load_firmware();
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+        eth_use_mac_from_env( gd->bd );
+#endif
+
+#if defined(CONFIG_USER_KEY)
+        if (get_gpio_stat(USER_KEY1_GPIO) == 0)
+        {
+                printf("\nUser Key 1 pressed\n");
+                if (getenv("key1") != NULL)
+                {
+                        sprintf(cmd, "run key1");
+                        run_command(cmd, 0);
+                }
+
+        }
+        if (get_gpio_stat(USER_KEY2_GPIO) == 0)
+        {
+                printf("\nUser Key 2 pressed\n");
+                if (getenv("key2") != NULL)
+                {
+                        sprintf(cmd, "run key2");
+                        run_command(cmd, 0);
+                }
+        }
+#endif /* CONFIG_USER_KEY */
+
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+	run_auto_script();
+#endif
+
+	return 0;
+}
+#endif /*BOARD_LATE_INIT*/
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+void show_boot_progress (int status) {
+#if defined(CONFIG_STATUS_LED)
+	if (status < 0) {
+        	/* ready to transfer to kernel, make sure LED is proper state */
+        	status_led_set(STATUS_LED_BOOT,STATUS_LED_ON);
+        	status_led_fail = 1;
+	}
+#endif /* CONFIG_STATUS_LED */
+}
+#endif /* CONFIG_SHOW_BOOT_PROGRESS */
+
+#if defined(CONFIG_SILENT_CONSOLE)
+
+int test_console_gpio (void)
+{
+#if defined(ENABLE_CONSOLE_GPIO) && defined(CONSOLE_ENABLE_GPIO_STATE)
+	if (get_gpio_stat(ENABLE_CONSOLE_GPIO) == CONSOLE_ENABLE_GPIO_STATE)
+		return 1;
+	else
+		return 0;
+#else
+	return 0;
+#endif
+}
+#endif
diff --git a/board/cc9p9xxx/config.mk b/board/cc9p9xxx/config.mk
new file mode 100644
index 0000000..c7ae1ac
--- /dev/null
+++ b/board/cc9p9xxx/config.mk
@@ -0,0 +1,14 @@
+#######################################################################
+#
+# Copyright (C) 2004 by FS Forth-Systeme GmbH.
+# Markus Pietrek <mpietrek@fsforth.de>
+#
+# @TODO
+# Linux-Kernel is expected to be at 0000'8000, entry 0000'8000
+# optionally with a ramdisk at 0080'0000
+#
+# we load ourself to 00f8'0000
+
+
+TEXT_BASE = 0x00100000
+DIGI_BOARD = y
diff --git a/board/cc9p9xxx/fpga.c b/board/cc9p9xxx/fpga.c
new file mode 100644
index 0000000..bdd9871
--- /dev/null
+++ b/board/cc9p9xxx/fpga.c
@@ -0,0 +1,209 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2008 by Digi International GmbH.
+ * All rights reserved.
+ *
+ * $Id: fpga.c,v 1.1 2008-01-30 14:42:51 mludwig Exp $
+ * @Author: Matthias Ludwig
+ * @Descr: Defines helper functions for loading fpga firmware
+ * @Usage: 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *  
+ ***********************************************************************/
+#include <common.h>
+#include <command.h>
+
+#ifdef CONFIG_IEEE1588
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#include <nand.h>
+#endif
+
+#include <ns9750_bbus.h>
+#include <ns9750_mem.h>
+
+#include <fpga_checkbitstream.h>
+
+#define PIN_RESET	23		/* reset fpga -> to programming-mode */
+#define PIN_INIT	58		/* FPGA ready to program */
+#define PIN_DONE	66		/* FPGA done with programing */
+
+#define FPGA_BASE	0x60000000	/* use default base address for cs2 */
+#define FPGA_MASK	0xF0000001	/* minimal size (4k) and enable bit */
+
+#define PIO_INPUT(pin)	set_gpio_cfg_reg_val(pin, NS9750_GPIO_CFG_FUNC_GPIO|NS9750_GPIO_CFG_INPUT)
+#define PIO_OUTPUT(pin)	set_gpio_cfg_reg_val(pin, NS9750_GPIO_CFG_FUNC_GPIO|NS9750_GPIO_CFG_OUTPUT)
+#define PIO_GET(pin)	get_gpio_stat(pin)
+
+ulong checksum_calc, checksum_read, fpgadatasize;
+
+static unsigned char WaitForPIO(int pin)
+{
+	int i;
+
+        /* 10ms max lock time, see Xilinux Spartan-3 datasheet */
+	for (i=0; i<10000; i++)
+		udelay(1);
+
+	if (PIO_GET(pin) == 0)
+		return 0;
+
+	return 1;
+}
+
+int fpga_load(volatile u_char *buf, ulong bsize) 
+{
+	int i;
+
+	/* setup GPIOs */
+	PIO_INPUT(PIN_INIT);
+	PIO_INPUT(PIN_DONE);
+
+	/* already in programming mode? */
+	if (!WaitForPIO(PIN_INIT)) {
+		/* reset fpga to programming mode */
+		*get_gpio_stat_reg_addr(PIN_RESET) = *get_gpio_stat_reg_addr(PIN_RESET)
+			| (1 << (((PIN_RESET) % 32))) ^ (1 << (((PIN_RESET) % 32)));
+		PIO_OUTPUT(PIN_RESET);
+		for (i = 0; i<10000; i++)
+			udelay(1);
+		*get_gpio_stat_reg_addr(PIN_RESET) = *get_gpio_stat_reg_addr(PIN_RESET)
+			| (1 << (((PIN_RESET) % 32)));
+
+		/* wait for fpga to become ready */
+		if (!WaitForPIO(PIN_INIT)) {
+			printf("FPGA: PIN_INIT not set\n");
+			return LOAD_FPGA_FAIL;
+		}
+	}
+
+	/* CS2 is used for FPGA code download. */
+	/* Map to FPGA_BASE address, 32 bit width, 1 read wait states, 2 write waitstates. */
+	*get_mem_reg_addr(NS9750_MEM_STAT_CFG(2)) = NS9750_MEM_STAT_CFG_MW_32 | NS9750_MEM_STAT_CFG_PB;
+	*get_mem_reg_addr(NS9750_MEM_STAT_WAIT_WEN(2))	= 0;
+	*get_mem_reg_addr(NS9750_MEM_STAT_WAIT_OEN(2))	= 0;
+	*get_mem_reg_addr(NS9750_MEM_STAT_RD(2))	= 0x1;
+	*get_mem_reg_addr(NS9750_MEM_STAT_PAGE(2))	= 0;
+	*get_mem_reg_addr(NS9750_MEM_STAT_WR(2))	= 0x2;
+	*get_mem_reg_addr(NS9750_MEM_STAT_TURN(2))	= 0;
+	*get_sys_reg_addr(NS9750_SYS_CS_STATIC_BASE(2)) = FPGA_BASE;
+	*get_sys_reg_addr(NS9750_SYS_CS_STATIC_MASK(2)) = FPGA_MASK;
+
+	/* send firmware */
+	for(; bsize > 0; buf++, bsize--)
+		*(volatile uchar *)FPGA_BASE = *buf;
+
+	/* disable CS2 */
+	*get_sys_reg_addr(NS9750_SYS_CS_STATIC_MASK(2)) = 0;
+
+	/* wait for fpga to prcess data */
+	if (!WaitForPIO(PIN_DONE)) {
+		printf("FPGA: PIN_DONE not set\n");
+		return LOAD_FPGA_FAIL;
+	}
+
+	return LOAD_FPGA_OK;
+}
+
+int fpga_checkbitstream(unsigned char* fpgadata, ulong size) {
+	unsigned int length;
+	unsigned int swapsize;
+	char buffer[80];
+	unsigned char *dataptr;
+	unsigned int i;
+
+	dataptr = (unsigned char *)fpgadata;
+
+	/* skip the first bytes of the bitsteam, their meaning is unknown */
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	dataptr+=length;
+
+	/* get design name (identifier, length, string) */
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	if (*dataptr++ != 0x61) {
+		printf("\nFPGA:  Design name identifier not recognized in bitstream\n" );
+		return LOAD_FPGA_FAIL;
+	}
+
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	for(i=0;i<length;i++)
+		buffer[i]=*dataptr++;
+        printf("FPGA: %s", buffer);
+
+	/* get part number (identifier, length, string) */
+	if (*dataptr++ != 0x62) {
+		printf("\nFPGA: Part number identifier not recognized in bitstream\n");
+		return LOAD_FPGA_FAIL;
+	}
+
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	for(i=0;i<length;i++)
+		buffer[i]=*dataptr++;
+	printf(", part = \"%s\"", buffer);
+
+	/* get date (identifier, length, string) */
+	if (*dataptr++ != 0x63) {
+		printf("\nFPGA: Date identifier not recognized in bitstream\n");
+		return LOAD_FPGA_FAIL;
+	}
+
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	for(i=0;i<length;i++)
+		buffer[i]=*dataptr++;
+        printf(", %s", buffer);
+
+	/* get time (identifier, length, string) */
+	if (*dataptr++ != 0x64) {
+		printf("\nFPGA: Time identifier not recognized in bitstream\n");
+		return LOAD_FPGA_FAIL;
+	}
+
+	length = (*dataptr << 8) + *(dataptr+1);
+	dataptr+=2;
+	for(i=0;i<length;i++)
+		buffer[i]=*dataptr++;
+        printf(", %s\n", buffer);
+
+	/* get fpga data length (identifier, length) */
+	if (*dataptr++ != 0x65) {
+		printf("FPGA: Data length identifier not recognized in bitstream\n");
+		return LOAD_FPGA_FAIL;
+	}
+	swapsize = ((unsigned int) *dataptr     <<24) +
+	           ((unsigned int) *(dataptr+1) <<16) +
+	           ((unsigned int) *(dataptr+2) <<8 ) +
+	           ((unsigned int) *(dataptr+3)     ) ;
+	dataptr+=4;
+
+	/* check consistency of length obtained */
+	int headersize = dataptr - (unsigned char *)fpgadata;
+
+        /* fpgaloadsize has been checked by update command */
+	if (size != (swapsize + headersize)) {
+		printf("FPGA: Could not find right length of data in bitstream\n");
+		return LOAD_FPGA_FAIL;
+	}
+	
+	return LOAD_FPGA_OK;
+}
+
+#endif
diff --git a/board/cc9p9xxx/nandboot.S b/board/cc9p9xxx/nandboot.S
new file mode 100644
index 0000000..2d8de7b
--- /dev/null
+++ b/board/cc9p9xxx/nandboot.S
@@ -0,0 +1,732 @@
+/***********************************************************************
+ *
+ *  Copyright (C) 2006 by FS Forth-Systeme GmbH,
+ *                     a DIGI International Company
+ *  All rights reserved.
+ *
+ *  @Author: Joachim Jaeger
+ *  @Descr: Supports small and large page size with bad-block management and ECC
+ *  @References: [1] nandboot.S for A9M24x0
+ *	         [2] Toshiba's NAND Flash Applications Design Guide Rev. 1.0
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_BOOT_NAND
+
+.globl _nandboot
+
+/***********************************************************************
+ * @Function: _nandboot (unsigned int unStartBlock,
+ *			  unsigned int* punDest, unsigned int unLength)
+ * @Return: always, check for bad blocks and verify ECC bytes
+ * @Descr: copies blocks from NAND to RAM (punDest) until unLength data has been
+ *	   read. unStartBlock
+ *	   autodetects small and large NAND Flashes
+ *	   blinks in an endless loop, if NAND not detected or ecc error
+ ***********************************************************************/
+
+#define rNF_BASE	CFG_NAND_BASE
+
+#define	oNF_CMD		(rNF_BASE + NAND_FLASH_CMD)
+#define oNF_ADDR	(rNF_BASE + NAND_FLASH_ADR)
+#define oNF_DATA	(rNF_BASE + NAND_FLASH_DAT)
+
+#define oNF_REG_CMD	oNF_CMD
+#define oNF_GPIO_RB	(0x90600044)	@ address of Ready/Busy GPIO
+
+#define vNF_GPIO_RB	(0x20000)	@ Ready/Busy GPIO
+
+#define oNF_GPIO_CFG_LED	(0x90600024)	@ GPIO control LED
+#define vNF_GPIO_CFG_LED_MASK	(0xF0000000)
+#define vNF_GPIO_CFG_LED_VAL	(0xB0000000)
+#define oNF_GPIO_CTRL_LED	(0x90600034)	@ GPIO control LED
+#define vNF_GPIO_CTRL_LED_MASK	(0x00008000)
+
+#define vNF_BS_LARGE	(0x20000)	@ large block size
+#define vNF_BS_SMALL	(0x4000)	@ small block size
+#define vNF_PS_LARGE	(0x800)		@ large page size
+#define vNF_PS_SMALL	(0x200)		@ small page size
+#define vNF_OOB_LARGE	(0x40)		@ large oob size
+#define vNF_OOB_SMALL	(0x10)		@ small oob size
+#define vNF_BB_POS_L	(0x00)		@ bad block position for large NAND
+#define vNF_BB_POS_S	(0x05)		@ bad block position for small NAND
+#define vNF_CMD_READ0	(0x00)		@ command READ0
+#define vNF_CMD_READS	(0x30)		@ command READ start for large NAND
+#define vNF_CMD_READO	(0x50)		@ command READ OOB for small NAND
+#define vNF_CMD_READID	(0x90)		@ command READ ID
+#define vNF_CMD_RESET	(0xff)		@ command RESET
+#define vNF_CMD_STAT	(0x70)		@ command STATUS
+#define vNF_WAIT	(0xf0)		@ counter for wait loop
+#define vNF_WAIT_RB	(0x50)		@ counter for ready/busy loop
+#define vNF_CHECK_BAD	(0xff)		@ value to check if block is bad
+
+#define oNF_SP_ADDR	(0x1000)	@ address for SP at end of 4k
+#define vNF_SP_SIZE	(0x40)		@ size for SP (64 Bytes)
+#define vNF_ECC_SIZE	(0x18)		@ size for ECC data (24 Bytes)
+#define vNF_ECC_STEP_S	(0x06)		@ 6 ECC bytes for small NAND
+#define vNF_ECC_STEP_L	(0x18)		@ 24 ECC bytes for large NAND
+#define vNF_ECC_POS	(0x28)		@ start position of ECC data (24 Bytes)
+#define oNF_ECC_DAT_C	(0xe60)		@ calculated ECC data (oNF_SP_ADDR-vNF_SP_SIZE-vNF_ECC_SIZE)
+#define oNF_ECC_DAT_R	(0xe20)		@ read ECC data (oNF_ECC_DAT_C-64bytes)
+#define vNF_ECC_ERROR	(0xffffffff)	@ return value for uncorrectable ECC error
+#define vNF_ECC_DATA	(0x100)		@ ECC is calculated for 256 data bytes
+#define vNF_ECC_BYTES	(0x03)		@ 3 ECC bytes are calculated for 256 data bytes
+#define oNF_ECC_INFO	NAND_ECC_INFO	@ Counter for correctable errors
+
+
+_nandboot:
+	mov	r4, lr
+	ldr	sp, =oNF_SP_ADDR	@ set up SP
+
+	stmdb   sp!, {r4}
+
+	ldr	r3, =oNF_ECC_INFO	@ reset ECC error counter
+	mov	r4, #0x00
+	str	r4, [r3]
+
+	mov	r4, #vNF_CMD_RESET	@ send reset to NAND
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	mov	r3, #0
+2:	mov	r4, #0			@ wait at least 5us before next command
+1:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	1b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	2b
+
+	mov	r4, #vNF_CMD_READID	@ Read ID command
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	mov	r4, #0x00	        @ ADDR 0
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+
+	ldr	r3, =oNF_DATA
+	ldrb	r4, [r3]		@ get manufacturer ID
+        
+	cmp	r4, #0x20		@ STM
+        cmpne	r4, #0x2C		@ Micron
+        cmpne	r4, #0x98		@ Toshiba
+        cmpne	r4, #0xEC		@ Samsung
+        mov	r8, r4			@ save value for debuging
+        mov	r9, #0x55000000		@ initialize the chip ID register
+        bne	ErrorNand		@ unknown ID
+
+	ldrb	r4, [r3]		@ get chip ID
+        /* check for chips with 512 byte sectors */
+        cmp	r4, #0x33		@ 16 MByte, 1.8V
+        cmpne	r4, #0x73		@ 16 MByte
+        cmpne	r4, #0x35		@ 32 MByte, 1.8V
+        cmpne	r4, #0x75		@ 32 MByte
+        cmpne	r4, #0x36		@ 64 MByte, 1.8V
+        cmpne	r4, #0x76		@ 64 MByte
+        cmpne	r4, #0x39		@ 128 MByte, 1.8V
+        cmpne	r4, #0x78		@ 128 MByte, 1.8V, Samsung only
+        cmpne	r4, #0x79		@ 128 MByte
+        cmpne	r4, #0x71		@ 256 MByte
+        moveq	r6, #vNF_PS_SMALL	@ small page size
+        beq	_nandboot_read_page
+
+        /* check for chips with 2 kbyte sectors */
+        cmp	r4, #0xA2		@ 64 MByte, 1.8V
+        cmpne	r4, #0xF2		@ 64 MByte
+        cmpne	r4, #0xA1		@ 128 MByte, 1.8V
+        cmpne	r4, #0xF1		@ 128 MByte
+        cmpne	r4, #0xAA		@ 256 MByte, 1.8V
+        cmpne	r4, #0xDA		@ 256 MByte
+        cmpne	r4, #0xAC		@ 512 MByte, 1.8V
+        cmpne	r4, #0xDC		@ 512 MByte
+        cmpne	r4, #0xA3		@ 1 GByte, 1.8V
+        cmpne	r4, #0xD3		@ 1 GByte
+        moveq	r6, #vNF_PS_LARGE	@ large page size
+        mov	r9, r4			@ save value for debuging
+        beq	_nandboot_read_page
+ErrorNand:
+/* Debug Blink-LED */
+	ldr	r0, =oNF_GPIO_CFG_LED
+        ldr	r1, [r0]		@ load config register
+        ldr	r2, =vNF_GPIO_CFG_LED_MASK		@ AND mask, 4 bits per GPIO
+        bic	r1, r1,r2
+        ldr	r2, =vNF_GPIO_CFG_LED_VAL		@ OR mask, GPIO with output
+        orr	r1, r1,r2
+        str	r1, [r0]		@ GPIO47 as GPIO output
+300:
+	ldr	r0, =oNF_GPIO_CTRL_LED
+        ldr	r1, [r0]		@ load control register
+        ldr	r2, =vNF_GPIO_CTRL_LED_MASK
+        bic	r1, r1,r2
+        str	r1, [r0]		@ GPIO47 with high level output
+
+	ldr	r0, =0x200000
+100:
+	mov	r1, r1
+	subs	r0, r0, #1
+	bne	100b
+
+	ldr	r0, =oNF_GPIO_CTRL_LED
+        ldr	r1, [r0]		@ load control register
+        ldr	r2, =vNF_GPIO_CTRL_LED_MASK
+        orr	r1, r1,r2
+        str	r1, [r0]		@ GPIO47 with high level output
+
+	ldr	r0, =0x200000
+200:
+	mov	r1, r1
+	subs	r0, r0, #1
+	bne	200b
+
+	b	300b
+/* end blink LED */
+
+_nandboot_read_page:
+	@ read one page
+	mov	ip, lr
+	bl	_nandboot_bb_check	@ first check, if block is bad
+	mov	lr, ip
+
+	mov	r4, #0			@ wait
+3:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	3b
+
+	mov	r4, #vNF_CMD_READ0	@ READ0
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	cmp	r6, #vNF_PS_SMALL
+	beq	4f
+/*NAND_LARGE*/
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000FF 	@ clear upper nibble and start of sector
+	strb	r4, [r3]		@ write A8..11
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3]		@ write A11..18
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A19..26
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A27..31
+
+	mov	r4, #vNF_CMD_READS	@ READ start
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	b	5f
+4:
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #9		@ A8 not relevant here
+	strb	r4, [r3]		@ write A9..16
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A17..24
+  	mov	r4, r4, lsr #8
+        bic	r4, r4, #0x000000FC 	@ clear A2..7
+	strb	r4, [r3]		@ write A25..26
+5:
+	mov	r3, #0
+7:	mov	r4, #0			@ wait
+6:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	6b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	7b
+
+	@ copy always one page size
+	@ r2 is number of bytes overall left after this copy
+	@ r5 is number in page left
+	cmp	r2, r6
+	subge	r2, r2, r6
+	movlt	r2, #0
+	mov	r5, r6
+	ldr	r3, =oNF_DATA
+
+_nandboot_page_copy_to_mem:
+	@ copy page to memory
+	cmp	r5, #0
+	beq	8f
+	sub	r5, r5, #1
+
+	ldrb	r4, [r3]
+	strb	r4, [r1], #1
+	b	_nandboot_page_copy_to_mem
+8:
+#ifndef BOOT_NAND_SKIP_ECC
+	mov	ip, lr
+	bl	_nandboot_calculate_ecc
+	mov	lr, ip
+
+	@ now we check ECC
+	stmdb   sp!, {r0 - r6}
+	mov	r4, r1			@ keep pointer
+	sub	r1, r1, r6		@ set pointer to start of page
+	ldr	r2, =oNF_ECC_DAT_R	@ pointer to ECC data read
+	cmp	r6, #vNF_PS_SMALL
+	beq	_ecc_pos_ok
+	add	r2, r2, #vNF_ECC_POS	@ correct pointer for large NAND Flash
+_ecc_pos_ok:
+	ldr	r3, =oNF_ECC_DAT_C	@ pointer to ECC data calculated
+
+_correct_loop:
+	mov	ip, lr
+	bl	_nandboot_correct_data
+	mov	lr, ip
+
+	cmp	r0, #vNF_ECC_ERROR	@ uncorrectable ECC error
+	beq	ErrorNand
+
+	ldr	r5, =oNF_ECC_INFO
+	ldr	r6, [r5]
+	add	r6, r6, r0		@ count correctable ECC errors
+	str	r6, [r5]
+
+	add	r1, r1, #vNF_ECC_DATA
+	add	r2, r2, #vNF_ECC_BYTES
+	add	r3, r3, #vNF_ECC_BYTES
+	cmp	r1, r4
+	bne	_correct_loop
+
+	ldmia   sp!, {r0 - r6}
+#endif
+
+	cmp	r2, #0
+	addne	r0, r0, r6          @ select next page
+	bne	_nandboot_read_page
+
+	@ finished, all bytes read
+	ldmia   sp!, {lr}
+	mov	pc, lr
+
+
+/***********************************************************************
+ * @Function: _nandboot_bb_check
+ *
+ * @Descr: checks 1st page of block, if block is bad
+ *	   stores ECC bytes to RAM
+ ***********************************************************************/
+_nandboot_bb_check:
+	stmdb   sp!, {r1, r2, r7 - r9}
+_bb_check_loop:
+	mov	r8, #0x00
+	cmp	r6, #vNF_PS_SMALL
+	beq	19f
+/*NAND_LARGE*/
+	mov	r5, #vNF_BS_LARGE	@ block size
+	mov	r7, #vNF_OOB_LARGE	@ oob size
+	mov	r9, #vNF_BB_POS_L	@ bad block position
+	mov	r4, r0		        @ ADDR
+	cmp	r4, #0x00
+	beq	20f
+	mov	r8, r4, lsl #15		@ we only check 1st page
+	b	20f
+19:
+	mov	r5, #vNF_BS_SMALL	@ block size
+	mov	r7, #vNF_OOB_SMALL	@ oob size
+	mov	r9, #vNF_BB_POS_S	@ bad block position
+	mov	r4, r0		        @ ADDR
+	cmp	r4, #0x00
+	beq	20f
+	mov	r8, r4, lsl #18		@ we only check 1st page
+20:
+	mov	r4, #0			@ wait
+13:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	13b
+
+	mov	r4, #vNF_CMD_READO	@ READ OOB for small NAND
+	cmp	r6, #vNF_PS_SMALL
+	beq	23f
+	mov	r4, #vNF_CMD_READ0	@ READ0
+23:
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	cmp	r6, #vNF_PS_SMALL
+	beq	9f
+/*NAND_LARGE*/
+	mov	r4, r0		        @ ADDR
+	orr	r4, r4, r6
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #8		@ A8..11
+        bic	r4, r4, #0x000000F7 	@ clear upper nibble and start of sector
+	strb	r4, [r3]		@ write A8..11
+	mov	r4, r0		        @ again whole ADDR
+  	mov	r4, r4, lsr #11
+	strb	r4, [r3]		@ write A11..18
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A19..26
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A27..31
+
+	mov	r4, #vNF_CMD_READS	@ READ start
+	ldr	r3, =oNF_REG_CMD
+	strb	r4, [r3]
+
+	b	10f
+9:
+	mov	r4, r0		        @ ADDR
+        bic	r4, r4, #0x000000FF 	@ clear A0..7, start of sector
+	ldr	r3, =oNF_ADDR
+	strb	r4, [r3]		@ write address byte
+  	mov	r4, r4, lsr #9		@ A8 not relevant here
+	strb	r4, [r3]		@ write A9..16
+  	mov	r4, r4, lsr #8
+	strb	r4, [r3]		@ write A17..24
+  	mov	r4, r4, lsr #8
+        bic	r4, r4, #0x000000FC 	@ clear A2..7
+	strb	r4, [r3]		@ write A25..26
+10:
+	mov	r3, #0
+12:	mov	r4, #0			@ wait
+11:	add	r4, r4, #0x1
+	cmp	r4, #vNF_WAIT
+	blt	11b
+
+	add	r3, r3, #0x1
+	cmp	r3, #vNF_WAIT_RB
+	blt	12b
+
+	ldr	r1, =oNF_ECC_DAT_R
+	mov	r2, #0x00
+21:
+	ldr	r3, =oNF_DATA
+	ldrb	r4, [r3]
+	strb	r4, [r1, r2]		@ store ECC bytes
+	add	r2, r2, #1
+	cmp	r2, r7			@ read all oob data
+	bne	21b
+
+	cmp	r8, #0x00		@ 1st page of block?
+	bne	22f
+	ldrb	r4, [r1, r9]		@ read bad block info
+	cmp	r4, #vNF_CHECK_BAD	@ bad block?
+	beq	22f
+	add	r0, r0, r5		@ next block
+	b	_bb_check_loop		@ check new block
+22:
+
+	cmp	r9, #vNF_BB_POS_L
+	beq	_bb_check_out
+	ldrb	r4, [r1, #6]		@ move ECC4 to the correct place
+	strb	r4, [r1, #4]
+	ldrb	r4, [r1, #7]		@ move ECC5 to the correct place
+	strb	r4, [r1, #5]
+
+_bb_check_out:
+	ldmia   sp!, {r1, r2, r7 - r9}
+
+	mov	pc, lr
+
+/***********************************************************************
+ * @Function: _nandboot_calculate_ecc
+ *
+ * @Descr: calculates ECC values of read page
+ *	   stores ECC bytes to RAM
+ *	   R1 = raw data read from NAND
+ ***********************************************************************/
+_nandboot_calculate_ecc:
+	stmdb   sp!, {r0 - r7, lr}
+
+	mov	r7, #0
+	sub	r6, r1, r6		@ set pointer to start of page
+	ldr	r4, =oNF_ECC_DAT_C	@ pointer to ECC data
+
+_calc_loop:
+	mov     lr, #0			@ initialize all 0x0
+	strb    lr, [r4, r7]
+	add	r7, r7, #1
+	strb    lr, [r4, r7]
+	add	r7, r7, #1
+	strb    lr, [r4, r7]
+	mov     r5, lr
+	mov     r0, lr
+	mov     ip, lr
+30:	ldrb    r2, [r6, ip]
+	adr     r3, _nandboot_ecc_tbl	@ pointer to ECC table
+	ldrb    r2, [r3, r2]
+	mvn     r3, ip
+	tst     r2, #64
+	eor     r1, r0, r3
+	eor     r3, lr, ip
+	add     ip, ip, #1
+	and     r2, r2, #63
+	andne   lr, r3, #255
+	andne   r0, r1, #255
+	cmp     ip, #255
+	eor     r5, r5, r2
+	ble     30b
+	mov     r1, lr
+	mov     r2, r4
+	sub	r7, r7, #2
+	add	r2, r2, r7
+	bl      _nandboot_trans_result
+	ldrb    r2, [r4, r7]
+	mvn     r2, r2
+	strb    r2, [r4, r7]
+
+	add	r7, r7, #1
+	ldrb    r1, [r4, r7]
+	mvn     r1, r1
+	strb    r1, [r4, r7]
+
+	add	r7, r7, #1
+	mvn     r3, r5
+	mov     r3, r3, lsl #2
+	orr     r3, r3, #3
+	mov     r0, #0
+	strb    r3, [r4, r7]
+
+	mov	r2, #vNF_ECC_STEP_S
+	cmp	r6, #vNF_PS_SMALL
+	beq	31f
+/*NAND_LARGE*/
+	mov	r2, #vNF_ECC_STEP_L
+31:
+	add	r6, r6, #vNF_ECC_DATA
+	add	r7, r7, #1
+	cmp	r7, r2
+	bne	_calc_loop
+
+	ldmia   sp!, {r0 - r7, lr}
+
+	mov	pc, lr
+
+/***********************************************************************
+ * @Function: _nandboot_trans_result
+ *
+ * @Descr: helper function to calculate ECC values
+ *	   stores ECC bytes to RAM
+ ***********************************************************************/
+_nandboot_trans_result:
+	stmdb   sp!, {r0 - r6, lr}
+
+	mov     r5, #0
+	mov     r4, #128
+	mov     r6, r2
+	and     r0, r0, #255
+	and     r1, r1, #255
+	mov     ip, r4
+	mov     r2, r5
+	mov     r3, r5
+40:	tst     r1, r4
+	orrne   r2, r2, ip
+	add     r3, r3, #1
+	mov     ip, ip, lsr #1
+	tst     r0, r4
+	orr     lr, r2, ip
+	and     r3, r3, #255
+	andne   r2, lr, #255
+	cmp     r3, #3
+	mov     r4, r4, lsr #1
+	mov     ip, ip, lsr #1
+	bls     40b
+	mov     ip, #128
+	mov     r3, #0
+41:	tst     r1, r4
+	orrne   r5, r5, ip
+	add     r3, r3, #1
+	mov     ip, ip, lsr #1
+	tst     r0, r4
+	orr     lr, r5, ip
+	and     r3, r3, #255
+	andne   r5, lr, #255
+	cmp     r3, #3
+	mov     r4, r4, lsr #1
+	mov     ip, ip, lsr #1
+	strhib  r5, [r6, #1]
+	strhib  r2, [r6]
+	ldmhiia sp!, {r0 - r6, pc}
+	b       41b
+
+/***********************************************************************
+ * @Table: _nandboot_ecc_tbl
+ *
+ * @Descr: precalculated 256-way 1 byte column parity
+ *
+ ***********************************************************************/
+_nandboot_ecc_tbl:
+        .byte 0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A @/* index 0x00 */
+        .byte 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00
+        .byte 0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F
+        .byte 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65
+
+        .byte 0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C @/* index 0x20 */
+        .byte 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66
+        .byte 0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59
+        .byte 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03
+
+        .byte 0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33 @/* index 0x40 */
+        .byte 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69
+        .byte 0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56
+        .byte 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C
+
+        .byte 0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55 @/* index 0x60 */
+        .byte 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F
+        .byte 0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30
+        .byte 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A
+
+        .byte 0x6A, 0x3F, 0x3C, 0x69, 0x33, 0x66, 0x65, 0x30 @/* index 0x80 */
+        .byte 0x30, 0x65, 0x66, 0x33, 0x69, 0x3C, 0x3F, 0x6A
+        .byte 0x0F, 0x5A, 0x59, 0x0C, 0x56, 0x03, 0x00, 0x55
+        .byte 0x55, 0x00, 0x03, 0x56, 0x0C, 0x59, 0x5A, 0x0F
+
+        .byte 0x0C, 0x59, 0x5A, 0x0F, 0x55, 0x00, 0x03, 0x56 @/* index 0xA0 */
+        .byte 0x56, 0x03, 0x00, 0x55, 0x0F, 0x5A, 0x59, 0x0C
+        .byte 0x69, 0x3C, 0x3F, 0x6A, 0x30, 0x65, 0x66, 0x33
+        .byte 0x33, 0x66, 0x65, 0x30, 0x6A, 0x3F, 0x3C, 0x69
+
+        .byte 0x03, 0x56, 0x55, 0x00, 0x5A, 0x0F, 0x0C, 0x59 @/* index 0xC0 */
+        .byte 0x59, 0x0C, 0x0F, 0x5A, 0x00, 0x55, 0x56, 0x03
+        .byte 0x66, 0x33, 0x30, 0x65, 0x3F, 0x6A, 0x69, 0x3C
+        .byte 0x3C, 0x69, 0x6A, 0x3F, 0x65, 0x30, 0x33, 0x66
+
+        .byte 0x65, 0x30, 0x33, 0x66, 0x3C, 0x69, 0x6A, 0x3F @/* index 0xE0 */
+        .byte 0x3F, 0x6A, 0x69, 0x3C, 0x66, 0x33, 0x30, 0x65
+        .byte 0x00, 0x55, 0x56, 0x03, 0x59, 0x0C, 0x0F, 0x5A
+        .byte 0x5A, 0x0F, 0x0C, 0x59, 0x03, 0x56, 0x55, 0x00
+
+/***********************************************************************
+ * @Function: _nandboot_correct_data
+ *
+ * @Descr: compares calculated and read ECC values
+ *	   correct error if possible
+ *	   R0 = return value
+ *	   R1 = raw data read from NAND
+ *	   R2 = ECC read from NAND
+ *	   R3 = calculated ECC
+ ***********************************************************************/
+_nandboot_correct_data:
+	stmdb   sp!, {r1 - r7, r9, sl, lr}
+
+	mov     r7, r3
+	ldrb    r0, [r3, #1]
+	ldrb    sl, [r3]
+	ldrb    lr, [r2]
+	ldrb    r3, [r2, #1]
+	mov     r6, r2
+	ldrb    ip, [r7, #2]
+	ldrb    r2, [r2, #2]
+	eor     r5, r0, r3
+	eor     r4, sl, lr
+	eor     ip, ip, r2
+	orr     r3, r4, r5
+	orrs    r0, ip, r3
+	mov     r9, r1
+	ldmeqia sp!, {r1 - r7, r9, sl, pc}
+	eor     r3, r4, r4, lsr #1
+	eor     r2, r5, r5, lsr #1
+	and     lr, r3, #85		@; 0x55
+	and     r0, r2, #85		@; 0x55
+	eor     r3, ip, ip, lsr #1
+	cmp     lr, #85			@; 0x55
+	cmpeq   r0, #85			@; 0x55
+	and     r2, r3, #84		@; 0x54
+	bne     53f
+	cmp     r2, #84			@; 0x54
+	bne     53f
+	mov     r2, #128		@; 0x80
+	mov     r1, #0
+	mov     lr, r2
+	mov     r3, r1
+50:	add     r3, r3, #1
+	tst     r4, r2
+	and     r3, r3, #255		@; 0xff
+	orrne   r1, r1, lr
+	cmp     r3, #3			@; 0x3
+	mov     r2, r2, lsr #2
+	mov     lr, lr, lsr #1
+	bls     50b
+	mov     r2, #128		@; 0x80
+	mov     r3, #0
+51:	add     r3, r3, #1
+	tst     r5, r2
+	and     r3, r3, #255		@; 0xff
+	orrne   r1, r1, lr
+	cmp     r3, #3			@; 0x3
+	mov     r2, r2, lsr #2
+	mov     lr, lr, lsr #1
+	bls     51b
+	mov     r4, #0
+	mov     r0, #4
+	mov     r2, #128		@; 0x80
+	mov     r3, r4
+52:	add     r3, r3, #1
+	and     r3, r3, #255		@; 0xff
+	tst     ip, r2
+	orrne   r4, r4, r0
+	cmp     r3, #2
+	ldrhib  lr, [r9, r1]
+	mov     r0, r0, lsr #1
+	movhi   r0, #1
+	eorhi   r3, lr, r0, lsl r4
+	mov     r2, r2, lsr #2
+	strhib  r3, [r9, r1]
+	ldmhiia sp!, {r1 - r7, r9, sl, pc}
+	b       52b
+53:	cmp     r4, #0
+	mov     r3, #0
+	beq     55f
+54:	tst     r4, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    r4, r4, lsr #1
+	bne     54b
+55:	cmp     r5, #0
+	beq     57f
+56:	tst     r5, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    r5, r5, lsr #1
+	bne     56b
+57:	cmp     ip, #0
+	beq     59f
+58:	tst     ip, #1
+	add     r2, r3, #1
+	andne   r3, r2, #255		@; 0xff
+	movs    ip, ip, lsr #1
+	bne     58b
+59:	cmp     r3, #1
+	streqb  sl, [r6]
+	ldreqb  r3, [r7, #1]
+	streqb  r3, [r6, #1]
+	ldreqb  r3, [r7, #2]
+	moveq   r0, #2
+	mvnne   r0, #0
+	streqb  r3, [r6, #2]
+
+	ldmia   sp!, {r1 - r7, r9, sl, pc}
+
+#endif /* CONFIG_BOOT_NAND */
diff --git a/board/cc9p9xxx/platform.S b/board/cc9p9xxx/platform.S
new file mode 100644
index 0000000..301b699
--- /dev/null
+++ b/board/cc9p9xxx/platform.S
@@ -0,0 +1,310 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for the NS9750 DevBoard by
+ * (C) Copyright 2004 by FS Forth-Systeme GmbH.
+ * Markus Pietrek <mpietrek@fsforth.de>
+ * @References: [1] NS9750 Hardware Reference/December 2003
+ *	        [2] ns9750_a.cmd from MAJIC configuration
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+#  include <./ns9750_sys.h>
+#  include <./ns9750_mem.h>
+#endif
+
+/***********************************************************************
+ * @Function: write_register_block
+ * @Return: nothing
+ * @Descr: Copies the register block of register_offset:register value to
+ *         the registers at base r0. The block is assumed to start in RAM at r1
+ *         and end at r2. The linked RAM base address of U-Boot is assumed to be
+ *	   in r5 while the ROM base address we are running from is r6
+ *         Uses r3 and r4 as tempory registers
+ ***********************************************************************/
+
+.macro	write_register_block
+	@@ map the addresses to high memory
+	sub	r1, r1, r5
+	add	r1, r1, r6
+	sub	r2, r2, r5
+	add	r2, r2, r6
+
+	@@ copy all
+1:
+	@@ Write register/value pair starting at [r1] to register base r0
+	ldr	r3, [r1], #4
+	ldr	r4, [r1], #4
+	str	r4, [r0,r3]
+	cmp	r1, r2
+	blt	1b
+.endm
+
+_TEXT_BASE:
+	.word	TEXT_BASE	@ sdram load addr from config.mk
+_PHYS_FLASH:
+	.word	PHYS_FLASH_1    @ real flash address (without mirroring)
+_CAS_LATENCY:
+	.word	0x00022000	@ for CAS2 latency
+
+#ifdef CONFIG_BOOT_NAND
+_armboot_start:
+	.word _start
+_bss_start:
+	.word __bss_start
+#endif /* CONFIG_BOOT_NAND */
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+.globl lowlevel_init
+#ifndef CONFIG_BOOT_NAND
+lowlevel_init:
+
+	/* U-Boot may be linked to RAM at 0x780000. But this code will run in
+	   flash from 0x0. But in order to enable RAM we have to disable the
+	   mirror bit, therefore we have to jump to our real flash address
+	   beginning at PHYS_FLASH_1 (CS4 Base). Therefore,
+	   _run_at_real_flash_address may be 0x500003b0 while be linked to
+	   0x7803b0. So we must modify our linked addresses */
+
+	@@ branch to high memory address, away from 0x0
+	ldr	r5, _TEXT_BASE
+	ldr	r6, _PHYS_FLASH
+	ldr	r0, =_run_at_real_flash_address
+	sub	r0, r0, r5
+	add	r0, r0, r6
+	mov	pc, r0
+	nop			@ for pipelining
+
+_run_at_real_flash_address:
+	@@ now we are running > PHYS_FLASH_1, safe to enable memory controller
+
+	@@ Write Memory Configuration Registers
+
+	ldr	r0, _NS9750_MEM_MODULE_BASE
+	ldr	r1, =_MEM_CONFIG_START
+	ldr	r2, =_MEM_CONFIG_END
+
+	write_register_block
+
+	@@ Give SDRAM some time to settle
+	@@ @TODO. According to [2] it should be 2 AHB cycles. Check
+
+	ldr	r1, =0x50
+_sdram_settle:
+	subs	r1, r1, #1
+	bne	_sdram_settle
+
+_enable_mappings:
+	@@ Enable SDRAM Mode
+
+	ldr	r1, =_MEM_MODE_START
+	ldr	r2, =_MEM_MODE_END
+
+	write_register_block
+
+	ldr	r3, _CAS_LATENCY @ perform one read from SDRAM
+	ldr	r3, [r3]
+
+	@@ Enable SDRAM and memory mappings
+
+	ldr	r1, =_MEM_ENABLE_START
+	ldr	r2, =_MEM_ENABLE_END
+
+	write_register_block
+
+	@@ Activate AHB monitor
+
+	ldr	r0, =NS9750_SYS_MODULE_BASE
+	ldr	r1, =_AHB_MONITOR_START
+	ldr	r2, =_AHB_MONITOR_END
+
+	write_register_block
+_relocate_lr:
+	/* lr and ip (from cpu_init_crit) are still based on 0x0, relocate it to
+	   PHYS_FLASH. */
+	mov	r1, ip
+	add	r1, r1, r6
+	mov	ip, r1
+
+	mov	r1, lr
+	add	r1, r1, r6
+	mov	lr, r1
+
+	@@ back to arch calling code
+	mov	pc,	lr
+
+	.ltorg
+
+_NS9750_MEM_MODULE_BASE:
+	.word	NS9750_MEM_MODULE_BASE
+
+_MEM_CONFIG_START:
+	/* Table of 2 32bit entries. First word is register address offset
+	   relative to NS9750_MEM_MODULE_BASE, second one is value. They are
+	   written in order of appearance */
+
+	@@ Register values taken from [2]
+	.word	NS9750_MEM_CTRL
+	.word	NS9750_MEM_CTRL_E
+
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x6 & NS9750_MEM_DYN_REFRESH_MA)
+
+	.word	NS9750_MEM_DYN_READ_CFG
+	.word	(0x1 & NS9750_MEM_DYN_READ_CFG_MA)
+
+	.word	NS9750_MEM_DYN_TRP
+	.word	(0x1 & NS9750_MEM_DYN_TRP_MA)
+
+	.word	NS9750_MEM_DYN_TRAS
+	.word	(0x4 & NS9750_MEM_DYN_TRAS_MA)
+
+	.word	NS9750_MEM_DYN_TAPR
+	.word	(0x1 & NS9750_MEM_DYN_TRAS_MA)
+
+	.word	NS9750_MEM_DYN_TDAL
+	.word	(0x5 & NS9750_MEM_DYN_TDAL_MA)
+
+	.word	NS9750_MEM_DYN_TWR
+	.word	(0x1 & NS9750_MEM_DYN_TWR_MA)
+
+	.word	NS9750_MEM_DYN_TRC
+	.word	(0x6 & NS9750_MEM_DYN_TRC_MA)
+
+	.word	NS9750_MEM_DYN_TRFC
+	.word	(0x6 & NS9750_MEM_DYN_TRFC_MA)
+
+	.word	NS9750_MEM_DYN_TRRD
+	.word	(0x1 & NS9750_MEM_DYN_TRRD_MA)
+
+	.word	NS9750_MEM_DYN_TMRD
+	.word	(0x1 & NS9750_MEM_DYN_TMRD_MA)
+
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_PALL | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x1 & NS9750_MEM_DYN_REFRESH_MA)
+	@@ No further register settings after refresh
+_MEM_CONFIG_END:
+
+_MEM_MODE_START:
+	.word	NS9750_MEM_DYN_REFRESH
+	.word	(0x30 & NS9750_MEM_DYN_REFRESH_MA)
+
+	@@ CS 4
+	.word	NS9750_MEM_DYN_CFG(0)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x4500 & NS9750_MEM_DYN_CFG_AM_MA)) @ 4M32
+
+	.word	NS9750_MEM_DYN_RAS_CAS(0)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 5
+	.word	NS9750_MEM_DYN_CFG(1)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(1)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 6
+	.word	NS9750_MEM_DYN_CFG(2)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(2)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	@@ CS 7
+	.word	NS9750_MEM_DYN_CFG(3)
+	.word	(NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	.word	NS9750_MEM_DYN_RAS_CAS(3)
+	.word	((0x200 & NS9750_MEM_DYN_RAS_CAS_CAS_MA) | \
+		 (0x03 & NS9750_MEM_DYN_RAS_CAS_RAS_MA))
+
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_MODE | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+_MEM_MODE_END:
+
+_MEM_ENABLE_START:
+	.word	NS9750_MEM_DYN_CTRL
+	.word	(NS9750_MEM_DYN_CTRL_I_NORMAL | \
+		 NS9750_MEM_DYN_CTRL_BIT1 | \
+		 NS9750_MEM_DYN_CTRL_CE )
+
+	@@ CS 4
+	.word	NS9750_MEM_DYN_CFG(0)    @ 4M32
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x4500 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 5
+	.word	NS9750_MEM_DYN_CFG(1)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 6
+	.word	NS9750_MEM_DYN_CFG(2)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+
+	@@ CS 7
+	.word	NS9750_MEM_DYN_CFG(3)
+	.word	(NS9750_MEM_DYN_CFG_BDMC | \
+		 NS9750_MEM_DYN_CFG_AM | \
+		 (0x280 & NS9750_MEM_DYN_CFG_AM_MA))
+_MEM_ENABLE_END:
+
+_AHB_MONITOR_START:
+	.word	NS9750_SYS_AHB_TIMEOUT
+	.word	0x01000100	@ @TODO not calculated yet
+
+	.word	NS9750_SYS_AHB_MON
+	.word	(NS9750_SYS_AHB_MON_BMTC_GEN_IRQ | \
+		 NS9750_SYS_AHB_MON_BATC_GEN_IRQ)
+_AHB_MONITOR_END:
+
+#else  /* CONFIG_BOOT_NAND */
+lowlevel_init:
+	mov	pc, lr		@ nothing to do here
+
+#endif /* CONFIG_BOOT_NAND */
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT*/
+
diff --git a/board/cc9p9xxx/u-boot.lds b/board/cc9p9xxx/u-boot.lds
new file mode 100644
index 0000000..16e4eb6
--- /dev/null
+++ b/board/cc9p9xxx/u-boot.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+        __testhw_cmd_start = .;
+        .testhw_cmd : { *(.testhw_cmd) }
+        __testhw_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+
+}
diff --git a/board/common/flash_common.c b/board/common/flash_common.c
new file mode 100644
index 0000000..bb79df9
--- /dev/null
+++ b/board/common/flash_common.c
@@ -0,0 +1,588 @@
+/*
+ * (C) Copyright 2004-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002 Jun Gu <jung@artesyncp.com>
+ * Add support for Am29F016D and dynamic switch setting.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Modified 4/5/2001
+ * Wait for completion of each sector erase command issued
+ * 4/5/2001
+ * Chris Hallinan - DS4.COM, Inc. - clh@net1plus.com
+ */
+
+#include <common.h>
+#include <configs/cc9c.h>
+#include "configs/cc9c.h"
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+#undef DEBUG_FLASH
+#ifdef DEBUG_FLASH
+#define DEBUGF(fmt,args...) printf(fmt ,##args)
+#else
+#define DEBUGF(fmt,args...)
+#endif
+
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];	/* info for FLASH chips        */
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static int write_word(flash_info_t * info, ulong dest, ulong data);
+
+void flash_print_info(flash_info_t * info)
+{
+	int i;
+	int k;
+	int size;
+	int erased;
+	volatile unsigned long *flash;
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf("missing or unknown FLASH type\n");
+		return;
+	}
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case FLASH_MAN_AMD:
+		printf("AMD ");
+		break;
+	case FLASH_MAN_STM:
+		printf("STM ");
+		break;
+	case FLASH_MAN_FUJ:
+		printf("FUJITSU ");
+		break;
+	case FLASH_MAN_SST:
+		printf("SST ");
+		break;
+	default:
+		printf("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case FLASH_AM040:
+		printf("AM29F040 (512 Kbit, uniform sector size)\n");
+		break;
+	case FLASH_AM400B:
+		printf("AM29LV400B (4 Mbit, bottom boot sect)\n");
+		break;
+	case FLASH_AM400T:
+		printf("AM29LV400T (4 Mbit, top boot sector)\n");
+		break;
+	case FLASH_AM800B:
+		printf("AM29LV800B (8 Mbit, bottom boot sect)\n");
+		break;
+	case FLASH_AM800T:
+		printf("AM29LV800T (8 Mbit, top boot sector)\n");
+		break;
+	case FLASH_AMD016:
+		printf("AM29F016D (16 Mbit, uniform sector size)\n");
+		break;
+	case FLASH_AM160B:
+		printf("AM29LV160B (16 Mbit, bottom boot sect)\n");
+		break;
+	case FLASH_AM160T:
+		printf("AM29LV160T (16 Mbit, top boot sector)\n");
+		break;
+	case FLASH_AM320B:
+		printf("AM29LV320B (32 Mbit, bottom boot sect)\n");
+		break;
+	case FLASH_AM320T:
+		printf("AM29LV320T (32 Mbit, top boot sector)\n");
+		break;
+	case FLASH_AM033C:
+		printf("AM29LV033C (32 Mbit, top boot sector)\n");
+		break;
+	case FLASH_SST800A:
+		printf("SST39LF/VF800 (8 Mbit, uniform sector size)\n");
+		break;
+	case FLASH_SST160A:
+		printf("SST39LF/VF160 (16 Mbit, uniform sector size)\n");
+		break;
+	case FLASH_STMW320DT:
+		printf ("M29W320DT (32 M, top sector)\n");
+		break;
+	default:
+		printf("Unknown Chip Type\n");
+		break;
+	}
+
+	printf("  Size: %ld KB in %d Sectors\n",
+	       info->size >> 10, info->sector_count);
+
+	printf("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+		/*
+		 * Check if whole sector is erased
+		 */
+		if (i != (info->sector_count - 1))
+			size = info->start[i + 1] - info->start[i];
+		else
+			size = info->start[0] + info->size - info->start[i];
+		erased = 1;
+		flash = (volatile unsigned long *)info->start[i];
+		size = size >> 2;	/* divide by 4 for longword access */
+		for (k = 0; k < size; k++) {
+			if (*flash++ != 0xffffffff) {
+				erased = 0;
+				break;
+			}
+		}
+
+		if ((i % 5) == 0)
+			printf("\n   ");
+		printf(" %08lX%s%s", info->start[i],
+		       erased ? " E" : "  ", info->protect[i] ? "RO " : "   ");
+	}
+	printf("\n");
+	return;
+}
+
+
+/*
+ * The following code cannot be run from FLASH!
+ */
+static ulong flash_get_size(vu_long * addr, flash_info_t * info)
+{
+	short i;
+	CFG_FLASH_WORD_SIZE value;
+	ulong base = (ulong) addr;
+	volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) addr;
+
+	DEBUGF("FLASH ADDR: %08x\n", (unsigned)addr);
+
+	/* Write auto select command: read Manufacturer ID */
+	addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+	addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+	addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00900090;
+	udelay(1000);
+
+	value = addr2[0];
+	DEBUGF("FLASH MANUFACT: %x\n", value);
+
+	switch (value) {
+	case (CFG_FLASH_WORD_SIZE) AMD_MANUFACT:
+		info->flash_id = FLASH_MAN_AMD;
+		break;
+	case (CFG_FLASH_WORD_SIZE) FUJ_MANUFACT:
+		info->flash_id = FLASH_MAN_FUJ;
+		break;
+	case (CFG_FLASH_WORD_SIZE) SST_MANUFACT:
+		info->flash_id = FLASH_MAN_SST;
+		break;
+	case (CFG_FLASH_WORD_SIZE) STM_MANUFACT:
+		info->flash_id = FLASH_MAN_STM;
+		break;
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		info->sector_count = 0;
+		info->size = 0;
+		return (0);	/* no or unknown flash  */
+	}
+
+	value = addr2[1];	/* device ID	*/
+	DEBUGF("\nFLASH DEVICEID: %x\n", value);
+
+	switch (value) {
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV040B:
+		info->flash_id += FLASH_AM040;
+		info->sector_count = 8;
+		info->size = 0x0080000;	/* => 512 ko */
+		break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F040B:
+		info->flash_id += FLASH_AM040;
+		info->sector_count = 8;
+		info->size = 0x0080000;	/* => 512 ko */
+		break;
+
+	case (CFG_FLASH_WORD_SIZE) STM_ID_M29W040B:
+		info->flash_id += FLASH_AM040;
+		info->sector_count = 8;
+		info->size = 0x0080000;	/* => 512 ko */
+		break;
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_F016D:
+		info->flash_id += FLASH_AMD016;
+		info->sector_count = 32;
+		info->size = 0x00200000;
+		break;		/* => 2 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV033C:
+		info->flash_id += FLASH_AMDLV033C;
+		info->sector_count = 64;
+		info->size = 0x00400000;
+		break;		/* => 4 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400T:
+		info->flash_id += FLASH_AM400T;
+		info->sector_count = 11;
+		info->size = 0x00080000;
+		break;		/* => 0.5 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV400B:
+		info->flash_id += FLASH_AM400B;
+		info->sector_count = 11;
+		info->size = 0x00080000;
+		break;		/* => 0.5 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800T:
+		info->flash_id += FLASH_AM800T;
+		info->sector_count = 19;
+		info->size = 0x00100000;
+		break;		/* => 1 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV800B:
+		info->flash_id += FLASH_AM800B;
+		info->sector_count = 19;
+		info->size = 0x00100000;
+		break;		/* => 1 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160T:
+		info->flash_id += FLASH_AM160T;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		break;		/* => 2 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE) AMD_ID_LV160B:
+		info->flash_id += FLASH_AM160B;
+		info->sector_count = 35;
+		info->size = 0x00200000;
+		break;		/* => 2 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE)AMD_ID_LV320T:
+		info->flash_id += FLASH_AM320T;
+		info->sector_count = 67;
+		info->size = 0x00400000;
+		break;		/* => 4 MB	*/
+
+	case (CFG_FLASH_WORD_SIZE)AMD_ID_LV320B:
+		info->flash_id += FLASH_AM320B;
+		info->sector_count = 67;
+		info->size = 0x00400000;
+		break;		/* => 4 MB	*/
+
+	default:
+		info->flash_id = FLASH_UNKNOWN;
+		return (0);	/* => no or unknown flash */
+	}
+
+	/* set up sector start address table */
+	if (((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) ||
+	    ((info->flash_id & FLASH_TYPEMASK) == FLASH_AM040) ||
+	    ((info->flash_id & FLASH_TYPEMASK) == FLASH_AMD016)) {
+		for (i = 0; i < info->sector_count; i++)
+			info->start[i] = base + (i * 0x00010000);
+	}
+	else {
+		if (info->flash_id & FLASH_BTYPE) {
+			/* set sector offsets for bottom boot block type        */
+			info->start[0] = base + 0x00000000;
+			info->start[1] = base + 0x00004000;
+			info->start[2] = base + 0x00006000;
+			info->start[3] = base + 0x00008000;
+			for (i = 4; i < info->sector_count; i++) {
+				info->start[i] =
+				    base + (i * 0x00010000) - 0x00030000;
+			}
+		}
+		else {
+			/* set sector offsets for top boot block type           */
+			i = info->sector_count - 1;
+			info->start[i--] = base + info->size - 0x00004000;
+			info->start[i--] = base + info->size - 0x00006000;
+			info->start[i--] = base + info->size - 0x00008000;
+			for (; i >= 0; i--) {
+				info->start[i] = base + i * 0x00010000;
+			}
+		}
+	}
+
+	/* check for protected sectors */
+	for (i = 0; i < info->sector_count; i++) {
+		/* read sector protection at sector address, (A7 .. A0) = 0x02 */
+		/* D0 = 1 if protected */
+		addr2 = (volatile CFG_FLASH_WORD_SIZE *)(info->start[i]);
+
+		/* For AMD29033C flash we need to resend the command of *
+		 * reading flash protection for upper 8 Mb of flash     */
+		if (i == 32) {
+			addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0xAAAAAAAA;
+			addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x55555555;
+			addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x90909090;
+		}
+
+		if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST)
+			info->protect[i] = 0;
+		else
+			info->protect[i] = addr2[2] & 1;
+	}
+
+	/* issue bank reset to return to read mode */
+	addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;
+
+	return (info->size);
+}
+
+static int wait_for_DQ7_1(flash_info_t * info, int sect)
+{
+	ulong start, now, last;
+	volatile CFG_FLASH_WORD_SIZE *addr =
+	    (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+	start = get_timer(0);
+	last = start;
+	while ((addr[0] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+	       (CFG_FLASH_WORD_SIZE) 0x00800080) {
+		if ((now = get_timer(start)) > CFG_FLASH_ERASE_TOUT) {
+			printf("Timeout\n");
+			return -1;
+		}
+		/* show that we're waiting */
+		if ((now - last) > CFG_HZ) {	/* every second */
+//			putc('.');
+			last = now;
+		}
+	}
+	return 0;
+}
+
+int flash_erase(flash_info_t * info, int s_first, int s_last)
+{
+	volatile CFG_FLASH_WORD_SIZE *addr = (CFG_FLASH_WORD_SIZE *) (info->start[0]);
+	volatile CFG_FLASH_WORD_SIZE *addr2;
+	int flag, prot, sect, l_sect;
+	int i;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		if (info->flash_id == FLASH_UNKNOWN) {
+			printf("- missing\n");
+		}
+		else {
+			printf("- no sectors to erase\n");
+		}
+		return 1;
+	}
+
+	if (info->flash_id == FLASH_UNKNOWN) {
+		printf("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+
+	if (prot) {
+		printf("- Warning: %d protected sectors will not be erased!\n", prot);
+	}
+	else {
+		printf("\n");
+	}
+
+	l_sect = -1;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) {	/* not protected */
+			addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[sect]);
+
+			if ((info->flash_id & FLASH_VENDMASK) == FLASH_MAN_SST) {
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+				addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+				addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+				addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00500050;	/* block erase */
+				for (i = 0; i < 50; i++)
+					udelay(1000);	/* wait 1 ms */
+			}
+			else {
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+				addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00800080;
+				addr[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+				addr[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+				addr2[0] = (CFG_FLASH_WORD_SIZE) 0x00300030;	/* sector erase */
+			}
+			l_sect = sect;
+			/*
+			 * Wait for each sector to complete, it's more
+			 * reliable.  According to AMD Spec, you must
+			 * issue all erase commands within a specified
+			 * timeout.  This has been seen to fail, especially
+			 * if printf()s are included (for debug)!!
+			 */
+			wait_for_DQ7_1(info, sect);
+			printf("%d ", sect);
+		}
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts();
+
+	/* wait at least 80us - let's wait 1 ms */
+	udelay(1000);
+
+	/* reset to read mode */
+	addr = (CFG_FLASH_WORD_SIZE *) info->start[0];
+	addr[0] = (CFG_FLASH_WORD_SIZE) 0x00F000F0;	/* reset bank */
+
+	printf(" done\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff(flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp, data;
+	int i, l, rc;
+
+	wp = (addr & ~3);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+		for (; i < 4 && cnt > 0; ++i) {
+			data = (data << 8) | *src++;
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 4; ++i, ++cp) {
+			data = (data << 8) | (*(uchar *) cp);
+		}
+
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 4;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 4) {
+		data = 0;
+		memcpy(&data, src, 4);
+		src+=4;
+
+		if ((rc = write_word(info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 4;
+		cnt -= 4;
+	}
+
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 4 && cnt > 0; ++i, ++cp) {
+		data = (data << 8) | *src++;
+		--cnt;
+	}
+	for (; i < 4; ++i, ++cp) {
+		data = (data << 8) | (*(uchar *) cp);
+	}
+
+	return (write_word(info, wp, data));
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+static int write_word(flash_info_t * info, ulong dest, ulong data)
+{
+	volatile CFG_FLASH_WORD_SIZE *addr2 = (CFG_FLASH_WORD_SIZE *) (info->start[0]);
+	volatile CFG_FLASH_WORD_SIZE *dest2 = (CFG_FLASH_WORD_SIZE *) dest;
+	volatile CFG_FLASH_WORD_SIZE *data2 = (CFG_FLASH_WORD_SIZE *) & data;
+	ulong start;
+	int i;
+
+	/* Check if Flash is (sufficiently) erased */
+	if ((*((vu_long *)dest) & data) != data) {
+		return (2);
+	}
+
+	for (i = 0; i < 4 / sizeof(CFG_FLASH_WORD_SIZE); i++) {
+		int flag;
+
+		/* Disable interrupts which might cause a timeout here */
+		flag = disable_interrupts();
+
+		addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00AA00AA;
+		addr2[CFG_FLASH_ADDR1] = (CFG_FLASH_WORD_SIZE) 0x00550055;
+		addr2[CFG_FLASH_ADDR0] = (CFG_FLASH_WORD_SIZE) 0x00A000A0;
+
+		dest2[i] = data2[i];
+		/* show '.' */
+		if (((ulong)(&dest2[i]) & 0x0000ffff) == 0x00000000)
+			putc('.');
+
+		/* re-enable interrupts if necessary */
+		if (flag)
+			enable_interrupts();
+
+		/* data polling for D7 */
+		start = get_timer(0);
+		while ((dest2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080) !=
+		       (data2[i] & (CFG_FLASH_WORD_SIZE) 0x00800080)) {
+
+			if (get_timer(start) > CFG_FLASH_WRITE_TOUT) {
+				return (1);
+			}
+		}
+	}
+
+	return (0);
+}
+
diff --git a/builduboot.sh b/builduboot.sh
new file mode 100755
index 0000000..f521cdc
--- /dev/null
+++ b/builduboot.sh
@@ -0,0 +1,6 @@
+PATH="/home/robert/Downloads/buildroot-2011.05/output/host/bin:/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin:/home/robert/Downloads/buildroot-2011.05/output/host/usr/sbin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" AR="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ar" AS="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-as" LD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ld" NM="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-nm" CC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gcc" GCC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gcc" CPP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-cpp" CXX="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-g++" FC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gfortran" RANLIB="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ranlib" STRIP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-strip" OBJCOPY="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-objcopy" OBJDUMP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-objdump" AR_FOR_BUILD="/usr/bin/ar" AS_FOR_BUILD="/usr/bin/as" CC_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/gcc" GCC_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/gcc" CXX_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/g++" FC_FOR_BUILD="/usr/bin/ld" LD_FOR_BUILD="/usr/bin/ld" CFLAGS_FOR_BUILD="-O2 -I/home/robert/Downloads/buildroot-2011.05/output/host/include -I/home/robert/Downloads/buildroot-2011.05/output/host/usr/include" CXXFLAGS_FOR_BUILD="-I/home/robert/Downloads/buildroot-2011.05/output/host/include -I/home/robert/Downloads/buildroot-2011.05/output/host/usr/include" LDFLAGS_FOR_BUILD="-L/home/robert/Downloads/buildroot-2011.05/output/host/lib -L/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib -Wl,-rpath,/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib" FCFLAGS_FOR_BUILD="" DEFAULT_ASSEMBLER="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-as" DEFAULT_LINKER="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ld" CFLAGS=" -Os  -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64" CXXFLAGS=" -Os  -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64" LDFLAGS="" FCFLAGS="" PKG_CONFIG="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/pkg-config" PERLLIB="/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib/perl" STAGING_DIR="/home/robert/Downloads/buildroot-2011.05/output/host/usr/arm-unknown-linux-gnueabi/sysroot"       \
+            CONFIG_NOSOFTFLOAT=1 \
+                    /usr/bin/make V=1  -C /home/robert/Downloads/buildroot-2011.05/output/build/u-boot-2010.09 \
+                            CROSS_COMPILE="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-" ARCH=arm \
+                                    cc9p9215_config 
+
diff --git a/cc9files b/cc9files
new file mode 100644
index 0000000..ad3a3d7
--- /dev/null
+++ b/cc9files
@@ -0,0 +1,37 @@
+./include/configs/cc9c.h
+./include/configs/cc9p9210.h
+./include/configs/cc9p9360.h
+./include/configs/cc9p9750.h
+./include/configs/cc9p9215.h
+./include/configs/cc9m2443.h
+./common/digi/cmd_testhw/cpu/cc9m2443_adc.c
+./common/digi/cmd_testhw/cpu/cc9m2443_lcd.c
+./common/digi/cmd_testhw/cpu/cc9p9215_lcd.c
+./common/digi/cmd_testhw/cpu/cc9m2443_serial.c
+./cc9files
+./board/cc9m2443/config.mk
+./board/cc9m2443/Makefile
+./board/cc9m2443/nandboot.S
+./board/cc9m2443/flash.c
+./board/cc9m2443/cc9m2443.c
+./board/cc9m2443/lowlevel_init.S
+./board/cc9m2443/u-boot.lds
+./board/cc9p9xxx/config.mk
+./board/cc9p9xxx/platform.S
+./board/cc9p9xxx/Makefile
+./board/cc9p9xxx/cc9p9xxx.c
+./board/cc9p9xxx/nandboot.S
+./board/cc9p9xxx/fpga.c
+./board/cc9p9xxx/u-boot.lds
+./board/cc9p921x/config.mk
+./board/cc9p921x/platform.S
+./board/cc9p921x/Makefile
+./board/cc9p921x/board.c
+./board/cc9p921x/u-boot.lds
+./board/cc9c/config.mk
+./board/cc9c/platform.S
+./board/cc9c/Makefile
+./board/cc9c/nandboot.S
+./board/cc9c/cc9c.c
+./board/cc9c/u-boot.lds
+./rtc/cc9c_rtc.c
diff --git a/cleanuboot.sh b/cleanuboot.sh
new file mode 100755
index 0000000..7b088f3
--- /dev/null
+++ b/cleanuboot.sh
@@ -0,0 +1,5 @@
+PATH="/home/robert/Downloads/buildroot-2011.05/output/host/bin:/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin:/home/robert/Downloads/buildroot-2011.05/output/host/usr/sbin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games" AR="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ar" AS="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-as" LD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ld" NM="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-nm" CC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gcc" GCC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gcc" CPP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-cpp" CXX="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-g++" FC="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-gfortran" RANLIB="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ranlib" STRIP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-strip" OBJCOPY="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-objcopy" OBJDUMP="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-objdump" AR_FOR_BUILD="/usr/bin/ar" AS_FOR_BUILD="/usr/bin/as" CC_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/gcc" GCC_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/gcc" CXX_FOR_BUILD="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/ccache /usr/bin/g++" FC_FOR_BUILD="/usr/bin/ld" LD_FOR_BUILD="/usr/bin/ld" CFLAGS_FOR_BUILD="-O2 -I/home/robert/Downloads/buildroot-2011.05/output/host/include -I/home/robert/Downloads/buildroot-2011.05/output/host/usr/include" CXXFLAGS_FOR_BUILD="-I/home/robert/Downloads/buildroot-2011.05/output/host/include -I/home/robert/Downloads/buildroot-2011.05/output/host/usr/include" LDFLAGS_FOR_BUILD="-L/home/robert/Downloads/buildroot-2011.05/output/host/lib -L/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib -Wl,-rpath,/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib" FCFLAGS_FOR_BUILD="" DEFAULT_ASSEMBLER="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-as" DEFAULT_LINKER="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-ld" CFLAGS=" -Os  -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64" CXXFLAGS=" -Os  -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64" LDFLAGS="" FCFLAGS="" PKG_CONFIG="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/pkg-config" PERLLIB="/home/robert/Downloads/buildroot-2011.05/output/host/usr/lib/perl" STAGING_DIR="/home/robert/Downloads/buildroot-2011.05/output/host/usr/arm-unknown-linux-gnueabi/sysroot"       \
+            CONFIG_NOSOFTFLOAT=1 \
+                    /usr/bin/make V=1  -C /home/robert/Downloads/u-boot/u-boot-2010.09 \
+                            CROSS_COMPILE="/home/robert/Downloads/buildroot-2011.05/output/host/usr/bin/arm-none-linux-gnueabi-" ARCH=arm clean
+
diff --git a/common/Makefile b/common/Makefile
index 2c37073..9b69602 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -40,6 +40,7 @@ COBJS-y += s_record.o
 COBJS-$(CONFIG_SERIAL_MULTI) += serial.o
 COBJS-y += stdio.o
 COBJS-y += xyzModem.o
+COBJS-y += helper.o
 
 # core command
 COBJS-y += cmd_boot.o
@@ -128,7 +129,9 @@ COBJS-$(CONFIG_CMD_OTP) += cmd_otp.o
 ifdef CONFIG_PCI
 COBJS-$(CONFIG_CMD_PCI) += cmd_pci.o
 endif
+ifdef CONFIG_CMD_PCMCIA
 COBJS-y += cmd_pcmcia.o
+endif
 COBJS-$(CONFIG_CMD_PORTIO) += cmd_portio.o
 COBJS-$(CONFIG_CMD_REGINFO) += cmd_reginfo.o
 COBJS-$(CONFIG_CMD_REISER) += cmd_reiser.o
diff --git a/common/cmd_boot.c b/common/cmd_boot.c
index 72dacaa..2aa8ef7 100644
--- a/common/cmd_boot.c
+++ b/common/cmd_boot.c
@@ -24,6 +24,15 @@
 /*
  * Misc boot support
  */
+#include <configs/cc9p9215.h>
+#define CFG_MAX_FLASH_SECT (256)
+#define CONFIG_NR_DRAM_BANKS 1
+#define CONFIG_ENV_SIZE 0x10000
+#ifndef CONFIG_SYS_LOAD_ADDR
+#define CONFIG_SYS_LOAD_ADDR 0x100000
+#endif
+#define CONFIG_SYS_MAXARGS 32
+#define CONFIG_SYS_MAX_FLASH_BANKS 1
 #include <common.h>
 #include <command.h>
 #include <net.h>
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 4c6ed48..41a52f6 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -25,6 +25,17 @@
 /*
  * Boot support
  */
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_SIZE 0x10000
+#ifndef CONFIG_SYS_LOAD_ADDR
+#define CONFIG_SYS_LOAD_ADDR 0x100000
+#endif
+#define CONFIG_SYS_MAXARGS 32
+#define CONFIG_SYS_MAX_FLASH_BANKS 1
+#include <configs/cc9p9215.h>
+#ifdef CONFIG_CC9P9215
+#undef CONFIG_CMD_USB
+#endif
 #include <common.h>
 #include <watchdog.h>
 #include <command.h>
diff --git a/common/cmd_help.c b/common/cmd_help.c
index 8c8178e..bc2138f 100644
--- a/common/cmd_help.c
+++ b/common/cmd_help.c
@@ -23,6 +23,8 @@
 
 #include <common.h>
 #include <command.h>
+#define CONFIG_SYS_MAXARGS 32
+#define CONFIG_SYS_MAX_FLASH_BANKS 1
 
 int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 {
diff --git a/common/cmd_load.c b/common/cmd_load.c
index dad0303..bfcaf9f 100644
--- a/common/cmd_load.c
+++ b/common/cmd_load.c
@@ -24,6 +24,10 @@
 /*
  * Serial up- and download support
  */
+#ifndef CONFIG_SYS_LOAD_ADDR
+#define CONFIG_SYS_LOAD_ADDR 0x100000
+#endif
+
 #include <common.h>
 #include <command.h>
 #include <s_record.h>
diff --git a/common/cmd_net.c b/common/cmd_net.c
index 3ffb9df..5db4c2d 100644
--- a/common/cmd_net.c
+++ b/common/cmd_net.c
@@ -91,7 +91,7 @@ U_BOOT_CMD(
 );
 #endif
 
-static void netboot_update_env (void)
+void netboot_update_env (void)
 {
 	char tmp[22];
 
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index c941b95..8fd4660 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -42,6 +42,7 @@
 #include <common.h>
 #include <command.h>
 #include <environment.h>
+#include <configs/digi_common.h>
 #if defined(CONFIG_CMD_EDITENV)
 #include <malloc.h>
 #endif
@@ -53,6 +54,7 @@
 #include <net.h>
 #endif
 
+#define CONFIG_ENV_IS_IN_FLASH	1
 DECLARE_GLOBAL_DATA_PTR;
 
 #if !defined(CONFIG_ENV_IS_IN_EEPROM)	&& \
@@ -174,7 +176,13 @@ int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
  * This function will ONLY work with a in-RAM copy of the environment
  */
 
-int _do_setenv (int flag, int argc, char * const argv[])
+/* int _do_setenv (int flag, int argc, char * const argv[]) */
+#ifndef CONFIG_ENV_OVERRIDE
+int _do_setenv (int flag, int argc, char *argv[])
+#else
+        extern int _do_setenv (int flag, int argc, char *argv[]);
+        int _do_orig_setenv (int flag, int argc, char *argv[])
+#endif  /* CONFIG_ENV_OVERRIDE */
 {
 	int   i, len, oldval;
 	int   console = -1;
diff --git a/common/cmd_spi.c b/common/cmd_spi.c
index bafa217..a6fdf7f 100644
--- a/common/cmd_spi.c
+++ b/common/cmd_spi.c
@@ -29,6 +29,8 @@
 #include <command.h>
 #include <spi.h>
 
+#if (CONFIG_COMMANDS & CFG_CMD_SPI)
+
 /*-----------------------------------------------------------------------
  * Definitions
  */
@@ -37,20 +39,20 @@
 #   define MAX_SPI_BYTES 32	/* Maximum number of bytes we can handle */
 #endif
 
-#ifndef CONFIG_DEFAULT_SPI_BUS
-#   define CONFIG_DEFAULT_SPI_BUS	0
-#endif
-#ifndef CONFIG_DEFAULT_SPI_MODE
-#   define CONFIG_DEFAULT_SPI_MODE	SPI_MODE_0
-#endif
+/*
+ * External table of chip select functions (see the appropriate board
+ * support for the actual definition of the table).
+ */
+extern spi_chipsel_type spi_chipsel[];
+extern int spi_chipsel_cnt;
 
 /*
  * Values from last command.
  */
-static unsigned int	device;
-static int   		bitlen;
-static uchar 		dout[MAX_SPI_BYTES];
-static uchar 		din[MAX_SPI_BYTES];
+static int   device;
+static int   bitlen;
+static uchar dout[MAX_SPI_BYTES];
+static uchar din[MAX_SPI_BYTES];
 
 /*
  * SPI read/write
@@ -63,9 +65,8 @@ static uchar 		din[MAX_SPI_BYTES];
  * The command prints out the hexadecimal string received via SPI.
  */
 
-int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	struct spi_slave *slave;
 	char  *cp = 0;
 	uchar tmp;
 	int   j;
@@ -102,34 +103,28 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 	}
 
-	if ((bitlen < 0) || (bitlen >  (MAX_SPI_BYTES * 8))) {
-		printf("Invalid bitlen %d, giving up.\n", bitlen);
+	if ((device < 0) || (device >=  spi_chipsel_cnt)) {
+		printf("Invalid device %d, giving up.\n", device);
 		return 1;
 	}
-
-	/* FIXME: Make these parameters run-time configurable */
-	slave = spi_setup_slave(CONFIG_DEFAULT_SPI_BUS, device, 1000000,
-			CONFIG_DEFAULT_SPI_MODE);
-	if (!slave) {
-		printf("Invalid device %d, giving up.\n", device);
+	if ((bitlen < 0) || (bitlen >  (MAX_SPI_BYTES * 8))) {
+		printf("Invalid bitlen %d, giving up.\n", bitlen);
 		return 1;
 	}
 
-	debug ("spi chipsel = %08X\n", device);
+	debug ("spi_chipsel[%d] = %08X\n",
+		device, (uint)spi_chipsel[device]);
 
-	spi_claim_bus(slave);
-	if(spi_xfer(slave, bitlen, dout, din,
-				SPI_XFER_BEGIN | SPI_XFER_END) != 0) {
+	if(spi_xfer(spi_chipsel[device], bitlen, dout, din) != 0) {
 		printf("Error with the SPI transaction.\n");
 		rcode = 1;
 	} else {
+		cp = (char *)din;
 		for(j = 0; j < ((bitlen + 7) / 8); j++) {
-			printf("%02X", din[j]);
+			printf("%02X", *cp++);
 		}
 		printf("\n");
 	}
-	spi_release_bus(slave);
-	spi_free_slave(slave);
 
 	return rcode;
 }
@@ -138,9 +133,11 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 U_BOOT_CMD(
 	sspi,	5,	1,	do_spi,
-	"SPI utility commands",
+	"sspi    - SPI utility commands\n",
 	"<device> <bit_len> <dout> - Send <bit_len> bits from <dout> out the SPI\n"
 	"<device>  - Identifies the chip select of the device\n"
 	"<bit_len> - Number of bits to send (base 10)\n"
-	"<dout>    - Hexadecimal string that gets sent"
+	"<dout>    - Hexadecimal string that gets sent\n"
 );
+
+#endif	/* CFG_CMD_SPI */
diff --git a/common/console.c b/common/console.c
index 7e01886..6cc6c21 100644
--- a/common/console.c
+++ b/common/console.c
@@ -20,7 +20,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
  */
-
+#include <configs/digi_common.h>
 #include <common.h>
 #include <stdarg.h>
 #include <malloc.h>
diff --git a/common/digi/Makefile b/common/digi/Makefile
new file mode 100644
index 0000000..d1cbedd
--- /dev/null
+++ b/common/digi/Makefile
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+DIGI_DIR = $(TOPDIR)/common/digi
+
+LIB	= libdigi.a
+
+COBJS	= cmd_bsp.o \
+	  cmd_compat.o \
+	  cmd_chkimg.o \
+	  vscanf.o atoi.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+CFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -DUBOOT
+CPPFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -DUBOOT
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/common/digi/atoi.c b/common/digi/atoi.c
new file mode 100644
index 0000000..af845ab
--- /dev/null
+++ b/common/digi/atoi.c
@@ -0,0 +1,24 @@
+/*
+ *  common/digi/atoi.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$: 
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides atoi and similar
+*/
+
+#include <common.h>             /* simple_strtol */
+
+#include "atoi.h"
+
+int atoi( const char* szStr )
+{
+        return simple_strtol( szStr, NULL, 10 );
+}
diff --git a/common/digi/atoi.h b/common/digi/atoi.h
new file mode 100644
index 0000000..b89ddcf
--- /dev/null
+++ b/common/digi/atoi.h
@@ -0,0 +1,6 @@
+#ifndef __DIGI_ATOI_H
+#define __DIGI_ATOI_H
+
+extern int atoi( const char* szStr );
+
+#endif  /* __DIGI_ATOI_H */
diff --git a/common/digi/cmd_bsp.c b/common/digi/cmd_bsp.c
new file mode 100644
index 0000000..4c04639
--- /dev/null
+++ b/common/digi/cmd_bsp.c
@@ -0,0 +1,1691 @@
+/*
+ *  /targets/U-Boot.cvs/common/digi/cmd_bsp.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] http://www.linux-mtd.infradead.org/doc/nand.html
+*/
+
+/*
+ * Digi CC specific functions
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#if (CONFIG_COMMANDS & CFG_CMD_BSP)
+#include <command.h>
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <nand.h>
+#endif
+
+#include <jffs2/jffs2.h>
+#include <net.h>                /* DHCP */
+#include <dvt.h>                /* DVTHadError */
+#if defined(CONFIG_CC9M2443) || defined(CONFIG_CCW9M2443)
+ #include <asm/arch/gpio.h>
+#endif
+#if defined(CONFIG_NS9360)
+ #include <usb.h>	/* usb_stop */
+#endif
+#include "cmd_bsp.h"
+#include "env.h"
+#include "fpga_checkbitstream.h"
+#include "nvram.h"
+#include "partition.h"          /* MtdGetEraseSize */
+#include "mtd.h"
+#include "helper.h"
+/* ------------*/
+#include <configs/digi_common_post.h>
+/* ----------- */
+#define SNFS	"snfs"
+#define SMTD	"smtd"
+#define NPATH	"npath"
+#define RIMG    "rimg"
+#define USRIMG  "usrimg"
+#define CONSOLE "console"
+
+/* Constants for bootscript download timeouts */
+#define AUTOSCRIPT_TFTP_MSEC	100
+#define AUTOSCRIPT_TFTP_CNT	15
+#define AUTOSCRIPT_START_AGAIN	100
+
+/* to transform a value into a string, from environment.c */
+
+#define CE( sCmd ) \
+        do { \
+                if( !(sCmd) )                   \
+                        goto error; \
+        } while( 0 )
+
+#ifdef CFG_CONS_INDEX_SUB_1
+# define CONSOLE_INDEX ((CONFIG_CONS_INDEX)-1)
+#else
+# define CONSOLE_INDEX (CONFIG_CONS_INDEX)
+#endif
+
+#if defined( CFG_APPEND_CRC32 )
+# define UBOOT_IMG_HAS_CRC32 1
+#else
+# define UBOOT_IMG_HAS_CRC32 0
+#endif
+
+#ifdef CFG_NETOS_SWAP_ENDIAN
+# define NETOS_SWAP_ENDIAN 1
+#else
+# define NETOS_SWAP_ENDIAN 0
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+typedef enum {
+        IS_TFTP,
+        IS_NFS,
+        IS_FLASH,
+        IS_USB,
+        IS_MMC,
+        IS_HSMMC,
+} image_source_e;
+
+/* ********** local typedefs ********** */
+
+typedef struct {
+        nv_os_type_e   eOSType;
+        const char*    szName;       /*! short OS name */
+        const char*    szEnvVar;
+        nv_part_type_e ePartType;
+        char           bForBoot;
+        /* a compressed image can't be used for booting from TFTP/USB/NFS
+         * because we can't decompress it on the fly */
+        char           bForBootFromFlashOnly;
+        char           bRootFS;
+        char           bCRC32Appended;
+        char           bSwapEndian;
+} part_t;
+
+typedef struct {
+        const char*    szEnvVar;
+        const char*    szEnvDflt;
+} env_default_t;
+
+typedef struct {
+        image_source_e eType;
+        const char*    szName;       /*! short image name */
+} image_source_t;
+
+/* ********** local functions ********** */
+
+static int do_digi_dboot( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] );
+static int do_digi_update( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] );
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+static int jffs2_mark_clean (long long offset, long long size);
+#endif
+
+static int WhatPart(
+        const char* szPart, char bForBoot,
+        const part_t** ppPart,
+        const nv_param_part_t** ppPartEntry,
+        char bPartEntryRequired );
+static const image_source_t* WhatImageSource( const char* szSrc );
+static int RunCmd( const char* szCmd );
+static int GetIntFromEnvVar( /*@out@*/ int* piVal, const char* szVar,
+                             char bSilent );
+static int AppendPadding( const nv_param_part_t* pPart, void* pvImage,
+                          /*@out@*/ int* piFileSize );
+static size_t GetEraseSize( const nv_param_part_t* pPart );
+static size_t GetPageSize( const nv_param_part_t* pPart );
+static const nv_param_part_t* FindPartition( const char* szName );
+static int GetDHCPEnabled( char* pcEnabled );
+static int DoDHCP( void );
+static int IsValidUImage( image_header_t* pHeader );
+static int GetUImageSize( const nv_param_part_t* pPart,
+                          size_t* piSize, char* pbCompressed );
+int findpart_tableentry(  const part_t **ppPart,
+	const nv_param_part_t *pPartEntry,
+        int            iCount );
+void setup_before_os_jump(nv_os_type_e eOSType, image_source_e eType);
+
+image_header_t header;
+extern int NetSilent;		/* Whether to silence the net commands output */
+extern ulong TftpRRQTimeoutMSecs;
+extern int TftpRRQTimeoutCountMax;
+extern unsigned long NetStartAgainTimeout;
+
+/* ********** local variables ********** */
+
+static const env_default_t l_axEnvDynamic[] = {
+	{ CONSOLE,       NULL                         	   },  /* auto-generated */
+#ifdef CONFIG_MODULE_NAME_WCE
+	{ "ebootaddr",   MK_STR( CFG_LOAD_ADDR )           },
+        { "eimg",        "eboot-"CONFIG_MODULE_NAME_WCE    },
+#endif
+#ifdef CFG_FPGA_SIZE
+        { "fimg",        "wifi.biu"                        },
+#endif
+	{ "ip",          "ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:" CONFIG_MODULE_NAME ":eth0:off" },
+	{ "loadaddr",    MK_STR( CFG_LOAD_ADDR )           },
+	{ "loadaddr_initrd",    MK_STR( CFG_INITRD_LOAD_ADDR )           },
+        { "kimg",        CONFIG_LINUX_IMAGE_NAME           },
+        { NPATH,         "/exports/nfsroot-"CONFIG_MODULE_NAME },
+	{ "linuxloadaddr", MK_STR( CFG_LOAD_ADDR )           },
+#ifdef CONFIG_AUTOLOAD_BOOTSCRIPT
+	{ "loadbootsc",	"yes" },
+	{ "bootscript", CONFIG_MODULE_NAME"-bootscript" },
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_MMC)
+	{ "mmc_rpart",	DEFAULT_ROOTFS_MMC_PART		},
+#endif
+	{ "netosloadaddr", MK_STR( CFG_NETOS_LOAD_ADDR )   },
+#ifdef CONFIG_IS_NETSILICON
+        /* NET+OS exists only for these platforms */
+        { "nimg",        "image-"CONFIG_MODULE_NAME_NETOS".bin"},
+# ifdef PART_NETOS_LOADER_SIZE
+        { "nloader",     "rom-"CONFIG_MODULE_NAME_NETOS".bin"},
+# endif
+#endif  /* CONFIG_IS_NETSILICON */
+        { RIMG,          NULL                              }, /* auto-generated */
+#if (CONFIG_COMMANDS & CFG_CMD_USB) || (CONFIG_COMMANDS & CFG_CMD_MMC)
+	{ "rootdelay",	MK_STR(ROOTFS_DELAY)		},
+#endif
+	{ SMTD,          ""                                },
+	{ SNFS,          "root=nfs nfsroot=${serverip}:"   },
+#ifdef CONFIG_UBOOT_SPLASH
+        { "simg",        "splash.bmp"                      },
+#endif
+        { "std_bootarg", ""                                },
+        { "uimg",        CONFIG_UBOOT_IMAGE_NAME           },
+        { USRIMG,        NULL                              }, /* auto-generated */
+#if (CONFIG_COMMANDS & CFG_CMD_USB)
+	{ "usb_rpart",	DEFAULT_ROOTFS_USB_PART		},
+#endif
+#ifdef VIDEO_DISPLAY
+        { "video",       VIDEO_DISPLAY                     },
+#endif
+#ifdef CONFIG_MODULE_NAME_WCE
+	{ "wceloadaddr",   MK_STR( CFG_WCE_LOAD_ADDR )     },
+        { "wimg",        "wce-"CONFIG_MODULE_NAME_WCE      },
+        { "wzimg",       "wcez-"CONFIG_MODULE_NAME_WCE     },
+#endif
+};
+
+static const part_t l_axPart[] = {
+        { NVOS_LINUX, "linux",  "kimg",   NVPT_LINUX,      .bForBoot = 1 },
+#ifdef CONFIG_MODULE_NAME_WCE
+        { NVOS_EBOOT, "eboot",  "eimg",   NVPT_EBOOT,      .bForBoot = 1 },
+        { NVOS_WINCE, "wce",    "wimg",   NVPT_WINCE,      .bForBoot = 1 },
+        { NVOS_WINCE, "wcez",   "wzimg",  NVPT_WINCE,      .bCRC32Appended = 1 },
+#endif
+
+#ifdef CONFIG_IS_NETSILICON
+# ifdef PART_NETOS_LOADER_SIZE
+        { NVOS_NETOS_LOADER, "netos_loader", "nloader", NVPT_NETOS_LOADER,
+          .bSwapEndian = NETOS_SWAP_ENDIAN },
+# endif
+        { NVOS_NETOS, "netos",  "nimg",   NVPT_NETOS,
+          .bSwapEndian = NETOS_SWAP_ENDIAN, .bForBoot = 1 },
+#endif  /* CONFIG_IS_NETSILICON */
+
+        { NVOS_UBOOT, "uboot",  "uimg",   NVPT_UBOOT,
+          .bCRC32Appended = UBOOT_IMG_HAS_CRC32                          },
+#ifdef CFG_FPGA_SIZE
+        { NVOS_NONE,  "fpga",   "fimg",   NVPT_FPGA,                     },
+#endif
+#ifdef CONFIG_UBOOT_SPLASH
+	{ NVOS_NONE,  "splash",  "simg",  NVPT_SPLASH_SCREEN,            },
+#endif
+        { NVOS_NONE,  "rootfs", RIMG,     NVPT_FILESYSTEM, .bRootFS = 1  },
+        { NVOS_NONE,  "userfs", USRIMG,   NVPT_FILESYSTEM,               },
+};
+
+/* use MK because we later use l_axImgSrc[ IS_FLASH ] */
+#define MK(x,y) [x] = { .eType = x, .szName = y }
+static const image_source_t l_axImgSrc[] = {
+        MK( IS_TFTP,  "tftp"  ),
+        MK( IS_NFS,   "nfs"   ),
+        MK( IS_FLASH, "flash" ),
+        MK( IS_USB,   "usb"   ),
+        MK( IS_MMC,   "mmc"   ),
+        MK( IS_HSMMC, "hsmmc" ),
+};
+#undef MK
+
+/* struct for wce bootargs */
+const static struct {
+	char* arg;
+	int   val;
+} wce_args[] = {
+	{ "kitl_ttyS0",		0x01000000 },
+	{ "kitl_ttyS1",		0x02000000 },
+	{ "kitl_ttyUSB",	0x03000000 },
+	{ "kitl_ethUSB",	0x04000000 },
+	{ "kitl_eth",		0x05000000 },
+	{ "cleanhive",		0x00010000 },
+	{ "cleanboot",		0x00000100 },
+	{ "formatpart",		0x00000001 },
+};
+
+/* ********** local functions ********** */
+
+static size_t GetEraseSize( const nv_param_part_t* pPart )
+{
+        if( NULL == pPart )
+                /* no specific sector, take the first one which might be wrong
+                 * for NOR */
+                return MtdGetEraseSize( 0, 0 );
+        else
+                return MtdGetEraseSize( pPart->uiChip, pPart->ullStart );
+}
+
+static size_t GetPageSize( const nv_param_part_t* pPart )
+{
+        size_t iPageSize;
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+        iPageSize = nand_info[ 0 ].writesize;
+#else
+        /* NOR doesn't know anthing about pages */
+        iPageSize = GetEraseSize( pPart );
+#endif
+
+        return iPageSize;
+}
+
+static int SetBootargs( int argc, char* args[] )
+{
+	int i, index = 0;
+	/* default clean boot */
+	int commands = 0x00000100;
+	bd_t *bdinfo;
+
+	if(argc > 3) {
+		for( i=3; i < argc; i++ )
+			for( index = 0; index < ARRAY_SIZE( wce_args); index++ )
+				if( !strcmp( args[i], wce_args[index].arg ) )
+					commands |= wce_args[index].val;
+	}
+
+	bdinfo = (bd_t *) gd->bd->bi_boot_params;
+	bdinfo->bi_boot_params = commands;
+
+	return 0;
+}
+
+static int do_digi_dboot( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        int iLoadAddr    = -1;
+        char bAppendMtdRootToBootargs = 1;
+        const part_t* pPart = NULL;
+        const char*   szTmp           = NULL;
+        const image_source_t* pImgSrc = NULL;
+        const nv_param_part_t* pPartEntry = NULL;
+        char bCanDetectImageSize = 0;
+	char szCmd[ 80 ]  = "";
+	char szImg[ 60 ]  = "";
+        char bIsNFSRoot   = 0;
+        char bDHCPEnabled = 0;
+	int iLoadAddrInitRD = 0;
+        nv_os_type_e eOSType = NVOS_NONE;
+
+        if( ( argc < 2 ) || ( argc > 6 ) )
+                goto usage;
+
+        clear_ctrlc();
+
+        /* check what to boot */
+
+        if( argc > 2 )
+                pImgSrc = ( ( NVOS_EBOOT != pPart->eOSType ) ?
+                            WhatImageSource( argv[ 2 ] ) :
+                            &l_axImgSrc[ IS_FLASH ] );
+        else
+                pImgSrc = &l_axImgSrc[ IS_TFTP ];
+
+        if( NULL == pImgSrc )
+                goto usage;
+
+        /* determine OS and/or partition */
+        CE( WhatPart( argv[ 1 ], 1, &pPart, &pPartEntry, 0 ) );
+        if( NULL != pPartEntry ) {
+                switch( pPartEntry->eType ) {
+                    case NVPT_LINUX:
+                        eOSType = NVOS_LINUX;
+                        bCanDetectImageSize = 1;
+                        break;
+                    case NVPT_WINCE:
+                        eOSType = NVOS_WINCE;
+                        bCanDetectImageSize = 1;
+                        break;
+                    case NVPT_EBOOT: eOSType = NVOS_EBOOT; break;
+                    case NVPT_NETOS:
+                        eOSType = NVOS_NETOS;
+                        bCanDetectImageSize = 1;
+                        break;
+                    default: break;    /* to avoid compiler warnings */
+                }
+        } else if( NULL != pPart )
+                /* no partition available, e.g. dboot linux tftp */
+                eOSType = pPart->eOSType;
+
+        if( NVOS_NONE == eOSType ) {
+                eprintf( "OS Type not detected for %s\n", argv[ 1 ] );
+                goto error;
+        }
+
+        /* determine file to boot */
+        if (argc == 4)
+		szTmp = argv[3];
+	else if (argc == 6)
+		szTmp = argv[5];
+        else if( NULL != pPart ) {
+                /* not present, but we have a partition definition */
+                szTmp = GetEnvVar( pPart->szEnvVar, 0 );
+                CE( NULL != szTmp );
+        } else {
+                eprintf( "Require filename\n" );
+                goto error;
+        }
+        strncat( szImg, szTmp, sizeof( szImg ) );
+
+        CE( GetDHCPEnabled( &bDHCPEnabled ) );
+
+        /* user input processed, determine addresses */
+        switch( eOSType ) {
+            case NVOS_LINUX:
+                CE( GetIntFromEnvVar( &iLoadAddr, "linuxloadaddr", 0 ) );
+                break;
+            case NVOS_WINCE:
+                CE( GetIntFromEnvVar( &iLoadAddr, "wceloadaddr", 0 ) );
+                break;
+            case NVOS_EBOOT:
+                CE( GetIntFromEnvVar( &iLoadAddr, "ebootaddr", 0 ) );
+                break;
+            case NVOS_NETOS:
+                CE( GetIntFromEnvVar( &iLoadAddr, "netosloadaddr", 0 ) );
+                break;
+            default:
+                (void) GetIntFromEnvVar( &iLoadAddr, "loadaddr", 1 );
+                eprintf( "Operating system not supported\n" );
+        }
+
+        if( -1 == iLoadAddr ) {
+                eprintf( "variable loadaddr does not exist\n" );
+                goto error;
+        }
+
+	if( bDHCPEnabled &&
+	    (( IS_TFTP == pImgSrc->eType ) || ( IS_NFS == pImgSrc->eType )) )
+		/* makes no sense for USB or FLASH download to need DHCP */
+		CE( DoDHCP() );
+
+        /* run boot scripts and get images into RAM */
+        switch( pImgSrc->eType ) {
+            case IS_TFTP:
+                bAppendMtdRootToBootargs = 0;  /* everything is loaded by network */
+                sprintf( szCmd, "tftp 0x%x %s", iLoadAddr, szImg );
+                CE( RunCmd( szCmd ) );
+                bIsNFSRoot = 1;
+                break;
+            case IS_NFS:
+                bAppendMtdRootToBootargs = 0;  /* everything is loaded by network */
+                sprintf( szCmd, "nfs 0x%x %s/%s",
+                         iLoadAddr, GetEnvVar( NPATH, 0 ), szImg );
+                CE( RunCmd( szCmd ) );
+                bIsNFSRoot = 1;
+                break;
+            case IS_USB:
+	    {
+		char kdevpart[8];
+		char kfs[8];
+
+		bAppendMtdRootToBootargs = 0;  /* everything is loaded from media */
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload usb %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load usb %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("usb reset"));
+		CE(RunCmd(szCmd));
+	        break;
+	    }
+	    case IS_MMC:
+	    {
+		char kdevpart[8];
+		char kfs[8];
+
+                bAppendMtdRootToBootargs = 0;  /* everything is loaded from media */
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload mmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load mmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("mmcinit"));
+		CE(RunCmd(szCmd));
+	        break;
+	    }
+	    case IS_HSMMC:
+	    {
+		char kdevpart[8];
+		char kfs[8];
+
+                bAppendMtdRootToBootargs = 0;  /* everything is loaded from media */
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload hsmmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load hsmmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("hsmmcinit"));
+		CE(RunCmd(szCmd));
+	        break;
+	    }
+
+            case IS_FLASH:
+            {
+                    size_t iSize = 0;
+                    char   bCompressed = 0;
+
+                    if( NULL == pPartEntry ) {
+                            eprintf( "No partition to boot from\n" );
+                            goto error;
+                    }
+
+                    if( bCanDetectImageSize )
+                            CE( GetUImageSize( pPartEntry, &iSize, &bCompressed ) );
+
+                    /* copy kernel partition */
+                    if( bCompressed ) {
+                            iLoadAddr = ntohl( header.ih_load );
+                            CE( PartReadAndDecompress( pPartEntry,
+                                                       (void*) iLoadAddr,
+                                                       iSize ) );
+                    } else
+                            CE( PartRead( pPartEntry, (void*) iLoadAddr, iSize, 0 ) );
+
+                    /* !TODO. Should only be done for linux
+                     * !TODO. Should also be able to use uncompression */
+                    if( NvParamPartFind( &pPartEntry, NVPT_FILESYSTEM,
+                                         NVFS_INITRD, 1, 0 ) ) {
+                            /* we have a bootable initrd, copy it, too */
+                            if( GetIntFromEnvVar( &iLoadAddrInitRD,
+                                                  "loadaddr_initrd", 0 ) )
+                                    CE( PartRead( pPartEntry, (void*) iLoadAddrInitRD, 0, 0 ) );
+                    }
+
+                    break;
+            }
+        } /* switch( pImgSrc->eType ) */
+
+        CE( !DVTError() );
+
+	/* Platform setup before jumping to the OS */
+	setup_before_os_jump(eOSType, pImgSrc->eType);
+
+        /* boot operating system */
+        switch( eOSType ) {
+            case NVOS_LINUX:
+            {
+                    char szBootargs[ 2048 ];
+                    strcpy( szBootargs, "setenv bootargs " );
+                     /* no snprintf, therefore strncat */
+                    strncat( szBootargs, GetEnvVar( "std_bootarg", 0 ), sizeof( szBootargs ) );
+
+                    if( !bDHCPEnabled || bIsNFSRoot ) {
+                            /* Userspace can't do DHCP then. Therefore we give
+                             * the DHCP settings here. Otherwise they are the
+                             * values from NVRAM */
+                            strncat( szBootargs, " ", sizeof( szBootargs ) );
+                            strncat( szBootargs, GetEnvVar( "ip", 0 ), sizeof( szBootargs ) );
+                    }
+
+                    strncat( szBootargs, " ", sizeof( szBootargs ) );
+                    strncat( szBootargs, GetEnvVar( "console", 0 ), sizeof( szBootargs ) );
+
+                    strncat( szBootargs, " ", sizeof( szBootargs ) );
+                    if( bIsNFSRoot ) {
+                            strncat( szBootargs, GetEnvVar( SNFS, 0 ), sizeof( szBootargs ) );
+                            strncat( szBootargs, GetEnvVar( NPATH, 0 ), sizeof( szBootargs ) );
+                    } else
+                            strncat( szBootargs, GetEnvVar( SMTD, 0 ), sizeof( szBootargs ) );
+
+                    /*
+                     * When booting from USB or MMC the rootfs is expected in
+                     * a partition of that media. The partition number to use
+                     * must be stored in variable 'rpart' otherwise, the
+                     * default partition is used (DEFAULT_ROOTFS_PARTITION)
+                     */
+                    if (pImgSrc->eType == IS_MMC || pImgSrc->eType == IS_HSMMC) {
+			strncat(szBootargs, " root=", sizeof( szBootargs ) );
+			if (GetEnvVar("mmc_rpart", 1))
+				strncat(szBootargs, GetEnvVar("mmc_rpart", 1), sizeof(szBootargs));
+			else
+				strncat(szBootargs, DEFAULT_ROOTFS_MMC_PART, sizeof(szBootargs));
+			/* A delay is needed to allow the media to
+			 * be properly initialized before being able
+			 * to mount the rootfs
+			 */
+			strncat(szBootargs, " rootdelay=", sizeof(szBootargs));
+			if (GetEnvVar("rootdelay", 1))
+				strncat(szBootargs, GetEnvVar("rootdelay", 1), sizeof(szBootargs));
+			else
+				sprintf(szBootargs, "%s%d", szBootargs, ROOTFS_DELAY);
+                    }
+                    else if (pImgSrc->eType == IS_USB) {
+			strncat(szBootargs, " root=", sizeof( szBootargs ) );
+			if (GetEnvVar("usb_rpart", 1))
+				strncat(szBootargs, GetEnvVar("usb_rpart", 1), sizeof(szBootargs));
+			else
+				strncat(szBootargs, DEFAULT_ROOTFS_USB_PART, sizeof(szBootargs));
+			/* A delay is needed to allow the media to
+			 * be properly initialized before being able
+			 * to mount the rootfs
+			 */
+			strncat(szBootargs, " rootdelay=", sizeof(szBootargs));
+			if (GetEnvVar("rootdelay", 1))
+				strncat(szBootargs, GetEnvVar("rootdelay", 1), sizeof(szBootargs));
+			else
+				sprintf(szBootargs, "%s%d", szBootargs, ROOTFS_DELAY);
+                    }
+                    else {
+                            if( bAppendMtdRootToBootargs ) {
+                                    strncat( szBootargs, " ", sizeof( szBootargs ) );
+                                    CE( PartStrAppendRoot( szBootargs, sizeof( szBootargs ) ) );
+                            }
+                    }
+		    /* MTD partitions */
+                    strncat( szBootargs, " ", sizeof( szBootargs ) );
+                    CE( PartStrAppendParts( szBootargs, sizeof( szBootargs ) ) );
+
+                    if(GetEnvVar( "video", 1 ) ) {
+                            strncat( szBootargs, " video=", sizeof( szBootargs ) );
+                            strncat( szBootargs, GetEnvVar( "video", 1 ), sizeof( szBootargs ) );
+                    }
+
+                    CE( RunCmd( szBootargs ) );
+		    if(iLoadAddrInitRD)
+			    sprintf( szCmd, "bootm 0x%x 0x%x", iLoadAddr, iLoadAddrInitRD);
+		    else
+			    sprintf( szCmd, "bootm 0x%x", iLoadAddr);
+                    break;
+            }
+            case NVOS_WINCE:
+		    SetBootargs( argc, argv );
+	    case NVOS_EBOOT:
+                sprintf( szCmd, "go 0x%x", iLoadAddr );
+                break;
+            case NVOS_NETOS:
+                sprintf( szCmd, "bootm 0x%x", iLoadAddr );
+                break;
+            default:
+                eprintf( "Operating system not supported\n" );
+        } /* switch( eOSType ) */
+
+        printf( "%s will be booted now\n", argv[ 1 ] );
+
+        /* maybe an OS (e.g. WinCE) checks the Workcopys CRC32 */
+	/* TODO this is a waste of time, optimize... */
+        NvWorkcopyUpdateCRC32();
+
+        /* check from what source to boot */
+        return !RunCmd( szCmd );
+
+usage:
+#ifdef CFG_SYS_LONGHELP
+        printf( "Usage:\n%s\n%s\n", cmdtp->usage, cmdtp->help );
+#else
+        printf( "Usage:\n%s\n", cmdtp->usage);
+#endif
+        return 1;
+
+error:
+        return 1;
+}
+
+static int do_digi_update( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        int iLoadAddr  = -1;
+        const image_source_t* pImgSrc = NULL;
+        const part_t* pPart           = NULL;
+        const char*   szTmp           = NULL;
+        const nv_param_part_t* pPartEntry = NULL;
+        int iFileSize  = 0;
+        int iCRCSize   = 0;
+        crc32_t uiCRC;
+	char szCmd[ 80 ] = "";
+	char szImg[ 60 ] = "";
+        char bDHCPEnabled = 0;
+        static const char* szUpdating = "Updating";
+#ifdef CFG_HAS_WIRELESS
+	wcd_data_t *pWCal;
+#endif
+
+        if( ( argc < 2 ) || ( argc > 6 ) )
+                goto usage;
+
+        clear_ctrlc();
+
+        /* check what to update */
+        CE( WhatPart( argv[ 1 ], 0, &pPart, &pPartEntry, 1 ) );
+
+        if( pPartEntry->flags.bReadOnly || pPartEntry->flags.bFixed )
+                /* U-Boot is always marked read-only, but has been checked
+                 * above already  */
+                CE( WaitForYesPressed( "Partition marked read-only / fixed."
+			" Do you want to continue?", szUpdating ) );
+
+        if( argc >= 3 )
+                pImgSrc = WhatImageSource( argv[ 2 ] );
+        else
+                pImgSrc = &l_axImgSrc[ IS_TFTP ];
+
+        if( NULL == pImgSrc )
+                goto usage;
+
+        /* determine file to update */
+        if( argc == 4 )
+                szTmp = argv[ 3 ];
+	else if (argc == 6)
+		szTmp = argv[5];
+        else if( NULL != pPart ) {
+                /* not present, but we have a partition definition */
+                szTmp = GetEnvVar( pPart->szEnvVar, 0 );
+                CE( NULL != szTmp );
+        } else {
+                eprintf( "Require filename\n" );
+                goto error;
+        }
+        strncat( szImg, szTmp, sizeof( szImg ) );
+
+        CE( GetDHCPEnabled( &bDHCPEnabled ) );
+
+        /* we check result later, it may be set otherwise */
+        (void) GetIntFromEnvVar( &iLoadAddr, "loadaddr", 1 );
+
+        /* we require it being set from download tool */
+        setenv( "filesize", "" );
+
+	if( bDHCPEnabled &&
+	    (( IS_TFTP == pImgSrc->eType ) || ( IS_NFS == pImgSrc->eType )) )
+		/* makes no sense for USB or FLASH download to need DHCP */
+		CE( DoDHCP() );
+
+        /* get images into RAM */
+        switch( pImgSrc->eType ) {
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+            case IS_TFTP:
+                sprintf( szCmd, "tftp 0x%x %s", iLoadAddr, szImg );
+                CE( RunCmd( szCmd ) );
+                break;
+            case IS_NFS:
+                sprintf( szCmd, "nfs 0x%x %s/%s",
+                         iLoadAddr, GetEnvVar( NPATH, 0 ), szImg );
+                CE( RunCmd( szCmd ) );
+                break;
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_USB)
+            case IS_USB:
+            {
+		char kdevpart[8];
+		char kfs[8];
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload usb %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load usb %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("usb reset"));
+		CE(RunCmd(szCmd));
+	        break;
+	    }
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_MMC)
+            case IS_MMC:
+            {
+		char kdevpart[8];
+		char kfs[8];
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload mmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load mmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("mmcinit"));
+		CE(RunCmd(szCmd));
+	        break;
+	    }
+
+	    case IS_HSMMC:
+	    {
+		char kdevpart[8];
+		char kfs[8];
+
+		/* Device number can be given as argument
+		 * Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kdevpart, argv[3]);
+		else
+			strcpy(kdevpart, DEFAULT_KERNEL_DEVPART);
+
+		/* File system can be given as argument
+		* Otherwise, default value is used */
+		if (argc > 4)
+			strcpy(kfs, argv[4]);
+		else
+			strcpy(kfs, DEFAULT_KERNEL_FS);
+
+		if (!strcmp(kfs, "fat") || !strcmp(kfs, "vfat"))
+			sprintf(szCmd, "fatload hsmmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else if (!strcmp(kfs, "ext2") || !strcmp(kfs, "ext3"))
+			sprintf(szCmd, "ext2load hsmmc %s 0x%x %s", kdevpart, iLoadAddr, szImg);
+		else {
+			printf("error: invalid value for filesystem (must be 'fat', 'vfat', 'ext2', 'ext3'\n");
+			goto error;
+		}
+
+		CE(RunCmd("hsmmcinit"));
+		CE(RunCmd(szCmd));
+		break;
+	    }
+#endif
+            case IS_FLASH:
+	    default:
+                /* makes really no sense in the update func */
+                goto usage;
+        }
+
+        CE( !DVTError() );
+
+        /* should be set by download tool */
+        CE( GetIntFromEnvVar( &iFileSize, "filesize", 0 ) );
+
+        iCRCSize = iFileSize - ( (NULL != pPart && pPart->bCRC32Appended) ?
+		   sizeof( uiCRC ) : 0 );
+	if (iCRCSize <= 0) {
+		printf("Partition requires checksum but provided file is to small \
+			to contain a checksum\n");
+		goto error;
+	}
+        uiCRC = crc32( 0, (uchar*) iLoadAddr, iCRCSize );
+        printf( "Calculated checksum = 0x%x\n", uiCRC );
+
+        if (NULL != pPart && pPart->bCRC32Appended) {
+                /* check CRC32 in File */
+                crc32_t uiCRCFile;
+                /* works independent whether the CRC is aligned or not. We
+                   * don't know what the image does. */
+                memcpy( &uiCRCFile, (const crc32_t*) ( iLoadAddr + iCRCSize ),
+                        sizeof( uiCRCFile ) );
+                if( uiCRCFile != uiCRC ) {
+                        eprintf( "CRC32 mismatch: Image reports 0x%0x - ",
+                                 uiCRCFile );
+                        CE( WaitForYesPressed( "Continue", szUpdating ) );
+                }
+        }
+
+        /* run some checks based on the image */
+
+        switch( pPartEntry->eType ) {
+            case NVPT_UBOOT:
+                CE( WaitForYesPressed( "Do you really want to overwrite U-Boot flash partition", szUpdating ) );
+                break;
+#ifdef CFG_HAS_WIRELESS
+            case NVPT_NVRAM:
+                if( !strcmp( argv[ 1 ], "wifical" ) ) {
+                        CE( WaitForYesPressed(
+			    "Do you really want to update the Wireless Calibration Information", szUpdating ) );
+                        pWCal = (wcd_data_t *)iLoadAddr;
+                        if ( !NvPrivWCDSetInNvram( pWCal ) ) {
+                                eprintf( "Invalid calibration data file\n" );
+                                goto error;
+                        }
+                        saveenv();
+                        goto done;
+                }
+                break;
+#endif
+            case NVPT_FPGA:
+            {
+#ifdef CFG_FPGA_SIZE
+                    if( CFG_FPGA_SIZE != ( iFileSize - 4 ) ) {
+                            /* +4 because of checksum added */
+                            eprintf( "Expecting FPGA to have size 0x%x\n",
+                                     CFG_FPGA_SIZE );
+                            goto error;
+                    }
+
+                    printf( "Updating FPGA firmware ...\n" );
+                    if( LOAD_FPGA_FAIL == fpga_checkbitstream( (uchar*) iLoadAddr, iFileSize ) ) {
+                            eprintf( "Updating FPGA firmware failed\n" );
+                            goto error;
+                    }
+
+                    /* fpga_checkbitstream doesn't print \0 */
+                    printf( "\n" );
+                    CE( WaitForYesPressed( "Do you really want to overwrite FPGA firmware", szUpdating ) );
+#else  /* CONFIG_FPGA_SIZE */
+                    printf( "No FPGA available\n" );
+#endif  /* CONFIG_FPGA_SIZE */
+                    break;
+            }
+            default: break;  /* avoid compiler warnings */
+        }
+
+#ifdef CONFIG_PARTITION_SWAP
+        if( ( NULL != pPart ) && pPart->bSwapEndian ) {
+                /* swapping is done on 16/32bit. Ensure that there is space */
+                int iFileSizeAligned = ( iFileSize + 0x3 ) & ~0x3;
+                /* fill swapped areas with empty character */
+                memset( (void*) iLoadAddr + iFileSize, 0xff, iFileSizeAligned - iFileSize );
+                iFileSize = iFileSizeAligned;
+        }
+#endif
+
+        /* update images */
+
+        /* fit we into it? */
+        if( PartSize( pPartEntry ) < iFileSize ) {
+                /* 0 means to end of flash */
+                eprintf( "Partition too small\n" );
+                goto error;
+        }
+
+        CE( PartProtect( pPartEntry, 0 ) );
+
+        /* erase complete partition */
+        CE( PartErase( pPartEntry ) );
+        CE( AppendPadding( pPartEntry, (void*) iLoadAddr, &iFileSize ) );
+
+#ifdef CONFIG_PARTITION_SWAP
+        if( ( NULL != pPart ) && pPart->bSwapEndian )
+                /* do it before writing. Swapping not supported for user
+                 * named partitions */
+                CE( PartSwap( pPartEntry, (void*) iLoadAddr, iFileSize ) );
+#endif
+
+        /* write partition */
+        CE( PartWrite( pPartEntry, (void*) iLoadAddr, iFileSize ) );
+        /* verify it */
+        CE( PartVerify( pPartEntry, (void*) iLoadAddr, iFileSize ) );
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+        if( pPartEntry->uiChip )
+                /* !TODO */
+                eprintf( "*** Chip %i not supported yet\n" );
+
+        if( ( NVPT_FILESYSTEM == pPartEntry->eType ) &&
+            ( NVFS_JFFS2      == pPartEntry->flags.fs.eType ) ) {
+                printf( "Writing cleanmarkers\n" );
+                CE( jffs2_mark_clean( pPartEntry->ullStart,
+                                      pPartEntry->ullSize ) );
+        }
+#endif
+
+        if( pPartEntry->flags.bFixed || pPartEntry->flags.bReadOnly)
+                CE( PartProtect( pPartEntry, 1 ) );
+
+        switch( pPartEntry->eType ) {
+            case NVPT_FPGA:
+            case NVPT_UBOOT:
+                /* be user friendly. fpga is not loaded */
+                printf( "Reboot system so update takes effect\n" );
+                break;
+            default:
+                break;
+        }
+#ifdef CFG_HAS_WIRELESS
+done:
+#endif
+        printf( "Update successful\n" );
+
+        return 0;
+usage:
+#ifdef CFG_SYS_LONGHELP
+        printf( "Usage:\n%s\n%s\n", cmdtp->usage, cmdtp->help );
+#else
+        printf( "Usage:\n%s\n%s\n", cmdtp->usage );
+#endif
+error:
+        if( ( NULL != pPartEntry ) &&
+            ( pPartEntry->flags.bFixed || pPartEntry->flags.bReadOnly ) )
+                /* it might have been unprotected */
+                PartProtect( pPartEntry, 1 );
+
+        return 1;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+static int jffs2_mark_clean (long long offset, long long size)
+{
+	struct mtd_info *nand;
+	struct mtd_oob_ops oob_ops;
+	int i, magic_ofs, magic_len;
+	long long end;
+	unsigned char magic[] = {0x85, 0x19, 0x03, 0x20, 0x08, 0x00, 0x00, 0x00};
+
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++) {
+		if (nand_info[i].name)
+			break;
+	}
+	nand = &nand_info[i];
+        /* !see [1] */
+	switch(nand->oobsize) {
+		case 8:
+			magic_ofs = 0x06;
+			magic_len = 0x02;
+                        break;
+		case 16:
+			magic_ofs = 0x08;
+			magic_len = 0x08;
+			break;
+		case 64:
+			magic_ofs = 0x10;
+			magic_len = 0x08;
+			break;
+		default:
+			printf("Cannot set markers on this oobsize!\n");
+                        goto error;
+	}
+
+	oob_ops.mode = MTD_OOB_PLACE;
+	oob_ops.ooblen = magic_len;
+	oob_ops.oobbuf = magic;
+	oob_ops.datbuf = NULL;
+	oob_ops.ooboffs = magic_ofs;
+
+	/* calculate end */
+	for(end = offset + size; offset < end; offset += nand->erasesize) {
+		/* skip if block is bad */
+		if(nand->block_isbad(nand, offset))
+			continue;
+
+		/* modify oob */
+		 if(nand->write_oob(nand, offset, &oob_ops))
+			 goto error;
+
+	} /* for( end=offset) */
+
+	return 1;
+
+error:
+	return 0;
+}
+#endif  /* CONFIG_COMMANDS & CFG_CMD_NAND */
+
+static int do_envreset( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+	switch( argc ) {
+		case 1:
+		break;
+
+            default:
+		printf( "Usage:\n%s\n", cmdtp->usage );
+		return -1;
+	}
+
+	printf( "Environment will be set to Default now!\n" );
+
+        NvEnvUseDefault();
+
+        return saveenv();
+}
+
+static int do_printenv_dynamic( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        int i;
+
+        for( i = 0; i < ARRAY_SIZE( l_axEnvDynamic ); i++ ) {
+                const char* szVar = l_axEnvDynamic[ i ].szEnvVar;
+                printf( "%s=%s\n", szVar,  GetEnvVar( szVar, 0 ) );
+        }
+
+        return 0;
+}
+
+static int do_erase_pt( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        const nv_param_part_t* pPartEntry = NULL;
+
+        if( argc != 2 )
+                goto usage;
+
+        clear_ctrlc();
+
+        /* determine OS and/or partition */
+        CE( WhatPart( argv[ 1 ], 0, NULL, &pPartEntry, 1 ) );
+
+        switch( pPartEntry->eType ) {
+            case NVPT_UBOOT:
+            case NVPT_NVRAM:
+                /* protect against silly stuff. Use update/envreset */
+                eprintf( "Can't erase a critical partition\n" );
+                goto error;
+            default:
+                break;
+        }
+
+        if( pPartEntry->flags.bReadOnly || pPartEntry->flags.bFixed )
+                CE( WaitForYesPressed( "Partition marked read-only /fixed. Do you want to continue?", "Erasing" ) );
+
+        CE( PartProtect( pPartEntry, 0 ) );
+        CE( PartErase( pPartEntry ) );
+        if( pPartEntry->flags.bFixed || pPartEntry->flags.bReadOnly)
+                CE( PartProtect( pPartEntry, 1 ) );
+
+        return 0;
+
+usage:
+#ifdef CONFIG_STATUS_LED
+        printf( "Usage:\n%s\n%s\n", cmdtp->usage, cmdtp->help );
+#else
+        printf( "Usage:\n%s\n%s\n", cmdtp->usage );
+#endif
+
+error:
+        return 1;
+}
+
+static int WhatPart(
+        const char* szPart, char bForBoot,
+        const part_t** ppPart,
+        const nv_param_part_t** ppPartEntry,
+        char bPartEntryRequired )
+{
+        int iPartition = 0;  /* later for multi-partition support */
+        int i = 0;
+        const part_t* pPart = NULL;
+        const nv_param_part_t* pPartEntry = NULL;
+
+	/* Search in l_axPart by the abreviated name */
+        while( i < ARRAY_SIZE( l_axPart ) ) {
+                if( !strcmp( szPart, l_axPart[ i ].szName ) &&
+                    ( !bForBoot || l_axPart[ i ].bForBoot ) ) {
+                        pPart = &l_axPart[ i ];
+
+                        /* abbreviated name found, does it exists? */
+                        /* find first rootfs partition */
+                        NvParamPartFind( &pPartEntry, pPart->ePartType,
+                                         NVFS_NONE, pPart->bRootFS, iPartition );
+                        break;
+                }
+		pPart = NULL;	/* Reset if not found */
+                i++;
+        } /* !while */
+
+        if( NULL == pPart ) {
+                /* internal abbrevation name userfs/rootfs/u-boot/not found,
+                   try it with szPart as partition name.
+		   wifical lives inside the NVRAM partition. Tweak that if
+                   that is what we are looking for */
+#ifdef CFG_HAS_WIRELESS
+		if( !strcmp( szPart, "wifical" ) )
+                        pPartEntry = FindPartition( "NVRAM" );
+                else
+#endif
+                        pPartEntry = FindPartition( szPart );
+                if( NULL == pPartEntry ) {
+                        eprintf( "Partition %s not found\n", szPart );
+                        goto error;
+                }
+		else {
+			/* Find the first partition in l_axPart array that
+			* matches the partition type of the partition
+			* located in NVRAM */
+			findpart_tableentry(&pPart, pPartEntry, 0);
+		}
+        }
+
+        if( bPartEntryRequired && ( NULL == pPartEntry ) ) {
+                eprintf( "Partition %s not found\n", szPart );
+                goto error;
+        }
+
+	if( NULL != pPart )
+		*ppPart = pPart;
+
+	if( NULL != pPartEntry)
+		*ppPartEntry = pPartEntry;
+
+	return 1;
+
+error:
+        return 0;
+}
+
+static const image_source_t* WhatImageSource( const char* szSrc )
+{
+        int i = 0;
+
+        while( i < ARRAY_SIZE( l_axImgSrc ) ) {
+                if( !strcmp( szSrc, l_axImgSrc[ i ].szName ) )
+                        return &l_axImgSrc[ i ];
+
+                i++;
+        } /* !while */
+
+        return NULL;
+}
+
+/*! \brief Runs command and prints error on failure */
+/*! \return 0 on failure otherwise 1
+ */
+static int RunCmd( const char* szCmd )
+{
+        int iRes;
+
+        clear_ctrlc();
+
+        iRes = ( run_command( szCmd, 0 ) >= 0 );
+
+	if( ctrlc() || had_ctrlc() )
+                iRes = 0;
+
+        if( !iRes )
+                eprintf( "command %s failed\n", szCmd );
+
+        return iRes;
+}
+
+/*! \brief Returns dynamic or normal environment variable */
+/*! \param bSilent true if not existant should not be reported
+ */
+const char* GetEnvVar( const char* szVar, char bSilent )
+{
+        const char* szTmp = NULL;
+        static char szTmpBuf[ 128 ];
+	static char sEraseSize[ 8 ];
+        static char ending[ 10 ];
+
+	szTmp = getenv( (char*) szVar );
+        if( ( NULL == szTmp ) ) {
+                /* variable not yet defined, try to read it in l_axPart */
+                if( !strcmp( szVar, RIMG ) || !strcmp( szVar, USRIMG ) ) {
+                        char bRIMG = !strcmp( szVar, RIMG );
+                        const nv_param_part_t* pPartEntry;
+                        size_t iEraseSize = GetEraseSize( NULL );
+
+                        /* find first rootfs partition */
+                        if( !NvParamPartFind( &pPartEntry, NVPT_FILESYSTEM,
+                                              NVFS_NONE, bRIMG, 0 ) )
+                                return "";
+
+                        iEraseSize = GetEraseSize( pPartEntry );
+			memset(sEraseSize,0,sizeof(sEraseSize));
+
+			if( bRIMG ) {
+				switch( pPartEntry->flags.fs.eType) {
+					case NVFS_JFFS2:
+						sprintf(sEraseSize, "-%i", iEraseSize / 1024);
+						strcpy( ending, "jffs2");
+						break;
+					case NVFS_CRAMFS:
+						strcpy( ending, "cramfs");
+						break;
+					case NVFS_INITRD:
+						strcpy( ending, "initrd");
+						break;
+					case NVFS_SQUASHFS:
+						strcpy( ending, "squashfs");
+						break;
+					case NVFS_ROMFS :
+						strcpy( ending, "romfs");
+						break;
+					default:
+						sprintf(sEraseSize, "-%i", iEraseSize / 1024);
+						strcpy( ending, "jffs2");
+						break;
+				}
+				sprintf( szTmpBuf, "%s%s.%s",
+					( (CONFIG_IMAGE_JFFS2_BASENAME == NULL) ? "rootfs-"CONFIG_MODULE_NAME :
+					  CONFIG_IMAGE_JFFS2_BASENAME ), sEraseSize, ending );
+			} else
+				sprintf( szTmpBuf, "userfs-%s-%i.jffs2",
+						CONFIG_MODULE_NAME, iEraseSize / 1024 );
+			szTmp = szTmpBuf;
+		} else if( !strcmp( szVar, CONSOLE ) ) {
+			sprintf( szTmpBuf, "console="CFG_CONSOLE"%i,%s",
+					CONSOLE_INDEX,
+					getenv( "baudrate" ) );
+			szTmp = szTmpBuf;
+		} else {
+			int i = 0;
+
+			while( i < ARRAY_SIZE( l_axEnvDynamic ) ) {
+				if( !strcmp( l_axEnvDynamic[ i ].szEnvVar, szVar ) ) {
+					szTmp = l_axEnvDynamic[ i ].szEnvDflt;
+					break;
+				}
+				i++;
+			} /* while */
+		}
+
+		if( ( NULL == szTmp ) && !bSilent )
+			eprintf( "variable %s does not exists\n", szVar );
+	}
+
+        return szTmp;
+}
+
+/*! \brief Converts an environment variable to an integer */
+/*! \return 0 on failure otherwise 1
+ */
+static int GetIntFromEnvVar( int* piVal, const char* szVar, char bSilent )
+{
+        int iRes = 0;
+        const char* szVal = GetEnvVar( szVar, bSilent );
+
+        if( NULL != szVal ) {
+                *piVal = simple_strtoul( szVal, NULL, 16 );
+                iRes = 1;
+        }
+
+        return iRes;
+}
+
+/*! \brief padds the image, also adds JFFS2 Padding if it's a jffs2 partition. */
+/*! \return 0 on failure otherwise wise 1
+ */
+static int AppendPadding( const nv_param_part_t* pPart, void* pvImage,
+                          int* piFileSize )
+{
+        int iPageSize = GetPageSize( pPart );
+        int iBytesFreeInBlock;
+
+        if( !iPageSize )
+                return 0;
+
+        iBytesFreeInBlock = iPageSize - (*piFileSize % iPageSize);
+
+        if( ( NVPT_FILESYSTEM == pPart->eType ) &&
+            ( NVFS_JFFS2      == pPart->flags.fs.eType ) &&
+            ( iBytesFreeInBlock >= sizeof( struct jffs2_unknown_node ) ) ) {
+                /* JFFS CRC32 starts from 0xfffffff, our crc32 from 0x0 */
+                uint32_t uiStart = 0xffffffff;
+                /* write padding to avoid Empty block messages.
+                   see linux/fs/jffs2/wbuf.c:flush_wbuf */
+                struct jffs2_unknown_node* pNode = (struct jffs2_unknown_node*) ( pvImage + *piFileSize );
+
+                printf( "Padding last sector\n" );
+
+                /* 0 for JFFS2 PADDING Type, see wbuf.c */
+                memset( pvImage + *piFileSize, 0x0, iBytesFreeInBlock );
+
+                *piFileSize       += iBytesFreeInBlock;
+                iBytesFreeInBlock -= sizeof( *pNode );
+
+                CLEAR( *pNode );
+
+                /* no cpu_to_je16, it's always host endianess in U-Boot */
+                pNode->magic    = JFFS2_MAGIC_BITMASK;
+                pNode->nodetype = JFFS2_NODETYPE_PADDING;
+
+                pNode->totlen   = iBytesFreeInBlock;
+                /* don't CRC32 the hdr_crc itself */
+                pNode->hdr_crc  = crc32( uiStart, (uchar*) pNode, sizeof( *pNode ) - 4 ) ^ uiStart;
+        } else {/* if( JFFS2 ) */
+                /* clear remaining stuff */
+                memset( pvImage + *piFileSize, 0xff, iBytesFreeInBlock );
+        }
+
+        return 1;
+}
+
+static const nv_param_part_t* FindPartition( const char* szName )
+{
+        nv_critical_t*               pCrit      = NULL;
+        const nv_param_part_table_t* pPartTable = NULL;
+        unsigned int u;
+
+        if( !CW( NvCriticalGet( &pCrit ) ) )
+                return NULL;
+
+        pPartTable = &pCrit->s.p.xPartTable;
+
+        for( u = 0; u < pPartTable->uiEntries; u++ )
+		if( !strcmp( szName, pPartTable->axEntries[ u ].szName) )
+                        return &pPartTable->axEntries[ u ];
+
+        return NULL;
+}
+
+static int GetDHCPEnabled( char* pcEnabled )
+{
+        nv_critical_t* pCrit = NULL;
+
+        *pcEnabled = 0;
+        CE( NvCriticalGet( &pCrit ) );
+
+        *pcEnabled = pCrit->s.p.xIP.axDevice[ 0 ].flags.bDHCP;
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/*! \brief performs a DHCP/BOOTP request without loading any file */
+/*! \return 0 on failure otherwise 1
+ */
+static int DoDHCP( void )
+{
+        int  iRes = 0;
+        char szTmp[ 80 ];
+
+        /* get current value */
+        strncpy( szTmp, getenv( "autoload" ), sizeof( szTmp ) );
+        /* autoload is used in BOOTP to do TFTP itself.
+           We do tftp ourself because we don't need bootfile */
+        setenv( "autoload", "n" );
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+        if( NetLoop( DHCP ) >= 0 ) {
+                /* taken from netboot_common. But we don't need autostart */
+                netboot_update_env();
+                iRes = 1;
+        }
+#endif
+        /* restore old autoload */
+        setenv( "autoload", szTmp );
+
+        return iRes;
+}
+
+static int IsValidUImage( image_header_t* pHeader )
+{
+        int iRes = 0;
+
+        /* check image */
+        if( ( ntohl( pHeader->ih_magic ) == IH_MAGIC ) ) {
+                ulong ulCRC32 = ntohl( pHeader->ih_hcrc );
+                pHeader->ih_hcrc = 0;
+                if( crc32( 0, (uchar*)  pHeader, sizeof( *pHeader ) ) == ulCRC32 )
+                        /* image header is correct */
+                        iRes = 1;
+                pHeader->ih_hcrc = htonl( ulCRC32 );
+        }
+
+        return iRes;
+}
+
+static int GetUImageSize( const nv_param_part_t* pPart,
+                          size_t* piSize, char* pbCompressed )
+{
+        *piSize = 0;
+        *pbCompressed = 0;
+
+        if( pPart->ullSize >= sizeof( header ) ) {
+                CE( PartRead( pPart, &header, sizeof( header ), 1 ) );
+
+                if( IsValidUImage( &header ) ) {
+                        *piSize = ntohl( header.ih_size ) + sizeof( header );
+                        /* only support for gzip */
+                        *pbCompressed = ( IH_COMP_GZIP == header.ih_comp );
+                }
+
+                /* when image is not correct, dboot will read whole partition
+                 * and boot. This is more safe in respect of
+                 * unsupported images than complaining here */
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_AUTOSCRIPT) && defined(CONFIG_AUTOLOAD_BOOTSCRIPT)
+void run_auto_script(void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+	int iLoadAddr = -1, ret;
+	char szCmd[ 80 ]  = "";
+	char *s, *bootscript;
+	/* Save original timeouts */
+        ulong saved_rrqtimeout_msecs = TftpRRQTimeoutMSecs;
+        int saved_rrqtimeout_count = TftpRRQTimeoutCountMax;
+	ulong saved_startagain_timeout = NetStartAgainTimeout;
+
+	/* Check if we really have to try to run the bootscript */
+	s = (char *)GetEnvVar("loadbootsc", 1);
+	bootscript = (char *)GetEnvVar("bootscript", 1 );
+	if (s && !strcmp(s, "yes") && bootscript) {
+		CE( GetIntFromEnvVar( &iLoadAddr, "loadaddr", 1 ) );
+		printf("Autoscript from TFTP... ");
+
+		/* set timeouts for bootscript */
+		TftpRRQTimeoutMSecs = AUTOSCRIPT_TFTP_MSEC;
+		TftpRRQTimeoutCountMax = AUTOSCRIPT_TFTP_CNT;
+		NetStartAgainTimeout = AUTOSCRIPT_START_AGAIN;
+
+		/* Silence net commands during the bootscript download */
+		NetSilent = 1;
+		sprintf( szCmd, "tftp 0x%x %s", iLoadAddr, bootscript );
+		ret = run_command( szCmd, 0 );
+		/* First restore original values of global variables
+		 * and then evaluate the result of the run_command */
+		NetSilent = 0;
+		/* Restore original timeouts */
+		TftpRRQTimeoutMSecs = saved_rrqtimeout_msecs;
+		TftpRRQTimeoutCountMax = saved_rrqtimeout_count;
+		NetStartAgainTimeout = saved_startagain_timeout;
+
+		if (ret < 0)
+			goto error;
+
+		printf("[ready]\nRunning bootscript...\n");
+		/* Launch bootscript */
+		ret = autoscript( iLoadAddr );
+	}
+	return;
+
+error:
+	printf( "[not available]\n" );
+#endif
+}
+#else
+void run_auto_script(void) {}
+#endif
+
+/* Looks in the l_axPart table, the iCount'th entry
+ * that matches the given partition type */
+int findpart_tableentry(
+        const part_t **ppPart,
+	const nv_param_part_t *pPartEntry,
+        int            iCount )
+{
+	unsigned int u = 0;
+	int iFound = 0;
+
+	*ppPart = NULL;
+
+	/* search the iCount'th partition entry */
+	while( u < ARRAY_SIZE( l_axPart ) ) {
+		if( pPartEntry->eType == l_axPart[u].ePartType ) {
+			/* found one occurence */
+			if( iFound == iCount ) {
+				/* it's the n'th occurence we look for */
+				*ppPart = (part_t *)&l_axPart[u];
+				return 1;
+			}
+			iFound++;
+		} /* if( pPartEntry->eType */
+
+		u++;
+	} /* while( u ) */
+
+	return 0;
+}
+
+/**
+ * Setup function for initialization/deinitialization needed
+ * for each platform before jumping to the OS
+ **/
+void setup_before_os_jump(nv_os_type_e eOSType, image_source_e eType)
+{
+#if defined(CONFIG_NS9360)
+	if (NVOS_LINUX == eOSType) {
+		/* If booting Linux stop USB */
+		usb_stop();
+	}
+#endif
+
+#if defined(CONFIG_CC9M2443) || defined(CONFIG_CCW9M2443)
+	/* Enable USB_POWEREN line before booting the OS */
+	s3c_gpio_setpin(S3C_GPA14, 0);
+#endif
+
+	/* Halt Ethernet controller to avoid interrupts
+	 * before the OS has fully initialized */
+	eth_halt();
+}
+
+U_BOOT_CMD(
+	dboot,	6,	0,	do_digi_dboot,
+	"dboot   - Digi modules boot commands\n",
+	"OS [source [device:part filesystem] [file]]\n"
+	"  - boots 'OS' of 'source' of 'device' with 'filesystem'\n"
+	"    values for 'OS': linux, wce, eboot, netos or any partition name\n"
+	"    values for 'source': flash, tftp, nfs, usb, mmc, hsmmc\n"
+	"    'device[:part]': number of device [and partition], for 'usb', 'mmc', 'hsmmc' sources\n"
+	"    values for 'filesystem': fat|vfat, ext2|ext3\n"
+	"    values for 'file'  : the file to be used for booting\n"
+	"\n"
+	"For wce following bootargs are possible:\n"
+/* hide for user */
+/*	"    ktil_ttyS0,kitl_ttyS1, kitl_ttyUSB, kitl_ethUSB, kitl_eth\n"
+	"    cleanhive, cleanboot, formatpart\n"
+*/
+	"    cleanhive\n"
+);
+
+U_BOOT_CMD(
+	update,	6,	0,	do_digi_update,
+	"update  - Digi modules update commands\n",
+	"partition [source [device:part filesystem] [file]]\n"
+	"  - updates 'partition' via 'source'\n"
+	"    values for 'partition': uboot, linux, rootfs, userfs, eboot, wce, wcez, netos,\n"
+        "                            netos_loader, splash, or any partition name\n"
+	"    values for 'source': tftp, nfs, usb, mmc, hsmmc\n"
+	"    'device:part': number of device and partition, for 'usb', 'mmc', 'hsmmc' sources\n"
+	"    values for 'filesystem': fat|vfat, ext2|ext3\n"
+	"    values for 'file'  : the file to be used for updating\n"
+);
+
+U_BOOT_CMD(
+	envreset,	1,	0,	do_envreset,
+	"envreset- Sets environment variables to default setting\n",
+	"\n"
+	"  - overwrites all current variables\n"
+);
+
+U_BOOT_CMD(
+	printenv_dynamic,	1,	0,	do_printenv_dynamic,
+	"printenv_dynamic- Prints all dynamic variables\n",
+	"\n"
+	"  - Prints all dynamic variables\n"
+);
+
+U_BOOT_CMD(
+	erase_pt,	2,	0,	do_erase_pt,
+	"erase_pt- Erases the partition\n",
+	"\npartition - the name of the partition\n"
+);
+
+#endif	/* (CONFIG_COMMANDS & CFG_CMD_BSP) */
diff --git a/common/digi/cmd_bsp.h b/common/digi/cmd_bsp.h
new file mode 100644
index 0000000..137c393
--- /dev/null
+++ b/common/digi/cmd_bsp.h
@@ -0,0 +1,21 @@
+/*
+ *  common/digi/cmd_bsp.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+*/
+
+#ifndef __DIGI_CMD_BSP_H
+#define __DIGI_CMD_BSP_H
+
+const char* GetEnvVar( const char* szVar, char bSilent );
+#endif  /* __DIGI_CMD_BSP_H */
diff --git a/common/digi/cmd_chkimg.c b/common/digi/cmd_chkimg.c
new file mode 100644
index 0000000..2dc3955
--- /dev/null
+++ b/common/digi/cmd_chkimg.c
@@ -0,0 +1,71 @@
+/*
+ *  common/digi/cmd_chkimg.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides chkimg and CheckCRC32OfImageInFlash
+ *               The linker file may contain an entry __u_boot_crc32. This
+ *               needs to be exactly 4 Bytes before .bss.
+ *               u-boot.bin will not have these values set, so run append_crc32
+ *               on it (or a copy of it). Then you can use chkimg to check a
+ *               running U-Boot against it's CRC32.
+ *               This CRC32 is different to the one reported by update_flash,
+ *               because they 
+ *               This checks that the U-Boot image in NOR/NAND flash matches
+ *               it.
+*/
+
+#include <common.h>
+#if defined(CFG_APPEND_CRC32) && !defined(CFG_NO_FLASH)
+
+#include <command.h>
+#include "cmd_chkimg.h"
+
+/* set from linker file */
+const ulong __u_boot_crc32;
+extern const void* _start;
+
+int CheckCRC32OfImageInFlash( char bSilent )
+{
+        ulong ulCRC;
+        int   iRes = 0;
+
+#if !defined(CFG_NO_FLASH)
+	ulCRC = crc32( 0, (const unsigned char*) CFG_FLASH_BASE,
+                       (int) &__u_boot_crc32 - (int) &_start );
+#else
+# error How should I determine crc32 on nand? PartRead?, PartCRC32?
+#endif
+
+        iRes = ( ulCRC == __u_boot_crc32 );
+
+        if( iRes ) {
+                if( !bSilent )
+                        printf( "CRC32: match: 0x%08x\n", ulCRC );
+        } else
+                printf( "CRC32: expected U-Boot to have 0x%08x, is 0x%08x\n",
+                        __u_boot_crc32, ulCRC );
+
+        return iRes;
+}
+
+static int do_digi_chkimg( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        return !CheckCRC32OfImageInFlash( 0 );
+}
+
+U_BOOT_CMD(
+	chkimg,	1,	0,	do_digi_chkimg,
+	"chkimg  - Checks that the U-Boot image in flash matches it's \n",
+        NULL
+);
+
+#endif  /* CFG_APPEND_CRC32 */
diff --git a/common/digi/cmd_chkimg.h b/common/digi/cmd_chkimg.h
new file mode 100644
index 0000000..012e9fe
--- /dev/null
+++ b/common/digi/cmd_chkimg.h
@@ -0,0 +1,17 @@
+/*
+ *  common/digi/cmd_chkimg.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+#ifndef __DIGI_CMD_CHKIMG_H
+#define __DIGI_CMD_CHKIMG_H
+
+extern int CheckCRC32OfImageInFlash( char bSilent );
+
+#endif  /* __DIGI_CMD_BSP_H */
diff --git a/common/digi/cmd_compat.c b/common/digi/cmd_compat.c
new file mode 100644
index 0000000..f6e697a
--- /dev/null
+++ b/common/digi/cmd_compat.c
@@ -0,0 +1,416 @@
+/*
+ *  common/digi/cmd_compat.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides the compatibility functions to migrate U-Boot 1.1.3
+ *               environment variables to U-Boot 1.1.4 NVRAM
+ *  !References: [1] common/env_eeprom.c:env_init
+ *               [2] common/digi/cmd_nvram/env.c
+*/
+
+#include <common.h>
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_COMPAT))
+
+#include <command.h>            /* U_BOOT_CMD */
+#include <environment.h>        /* env_t */
+
+#include "cmd_bsp.h"            /* GetEnvVar */
+#include "nvram.h"              /* NvCriticalGet */
+#include "env.h"                /* CE */
+#include "helper.h"             /* WaitForYesPressed */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define CONSOLE_VAR "console="
+
+/* ********** local typedefs ********** */
+
+/*! what should be done with a 1.1.3 environment variable */
+typedef enum {
+        ENV_DROP, /*! isn't used any longer */
+        ENV_CONV, /*! format or usage has changed. Requires env_conv_e */
+} env_action_e;
+
+/*! when action is ENV_CONV, describe ay of conversion */
+typedef enum {
+        ENVC_ETHADDR,    /*! ethaddr can't be written directly any longer */
+        ENVC_STDBOOTARG, /*! console= is in printenv_dynamic */
+        ENVC_BOOTCMD,    /*! he will probably want a completely different
+                          *  bootcmd */
+        ENVC_GATEWAY,    /*! new variable name */
+        ENVC_DNS,        /*! new variable name */
+} env_conv_e;
+    
+/*! Configures an action for a specific environment variable */
+typedef struct {
+        const char*  szEnvVar;  /*! variable to set */
+        env_action_e eAction;   /*! action for it */
+        env_conv_e   eConv;     /*! when converting, how to convert.*/
+} env_action_t;
+
+/* ********** global stuff ********** */
+
+extern int _do_orig_setenv( int flag, int argc, char *argv[] );
+    
+/* ********** local functions ********** */
+
+static const env_action_t* FindConvertAction( const char* szEnvVar );
+static void SetEnvIfNotSet( const char* szEnvVar, const char* szEnvVal );
+static void HandleOldEnv( const char* szEnvVar, const char* szEnvVal );
+static int  GetI2CEnv( void );
+static int  do_digi_upgrade( cmd_tbl_t* cmdtp, int flag,int argc,char* argv[]);
+
+/* ********** local variables ********** */
+
+/* crc32 + data( zero terminated szString list of "env=value" )*/
+static char  l_acEnv[ CMD_BSP_COMPAT_ENV_SIZE ];
+/* zero terminated szString list of "env=value" */
+static char* l_pcEnvData = &l_acEnv[ offsetof( env_t, data ) ];
+
+#define MK_DROP( szVar )    { .szEnvVar = szVar, .eAction = ENV_DROP  }
+#define MK_CONV( szVar, eHowToConv ) \
+        { .szEnvVar = szVar, .eAction = ENV_CONV, .eConv = eHowToConv  }
+/*! these environment variables are taken directly from 1.1.3 and
+ *  copied to this U-Boot's NVRAM with setenv */
+static env_action_t l_axEnvAction[] = {
+        /* auto generated */
+        MK_DROP( "bootfile"       ),
+        MK_DROP( "filesize"       ),
+        MK_DROP( "fileaddr"       ),
+        MK_DROP( "wcesize"       ),
+
+        /* needs to be adjusted to new syntax */
+        MK_CONV( "std_bootarg", ENVC_STDBOOTARG  ),
+        MK_CONV( "ethaddr",     ENVC_ETHADDR     ),
+        MK_CONV( "bootcmd",     ENVC_BOOTCMD     ),
+        MK_CONV( "gw",          ENVC_GATEWAY     ),
+        MK_CONV( "dns",         ENVC_DNS     ),
+
+        /* 1.1.3 stuff replaced by U-Boot 'dboot' and 'update' */
+        MK_DROP( "update_kernel_tftp" ),
+        MK_DROP( "update_rootfs_tftp" ),
+        MK_DROP( "update_uboot_tftp"  ),
+        MK_DROP( "update_wce_tftp"    ),
+        MK_DROP( "update_eboot_tftp"  ),
+        MK_DROP( "update_kernel_usb"  ),
+        MK_DROP( "update_rootfs_usb"  ),
+        MK_DROP( "update_uboot_usb"   ),
+        MK_DROP( "update_wce_usb"     ),
+        MK_DROP( "update_eboot_usb"   ),
+        MK_DROP( "update_ns_usb"      ),
+        MK_DROP( "update_ns_tftp"     ),
+        MK_DROP( "boot_flash"         ),
+        MK_DROP( "boot_ns_flash"      ),
+        MK_DROP( "boot_net"           ),
+        MK_DROP( "boot_ns_net"        ),
+        MK_DROP( "boot_usb"           ),
+        MK_DROP( "boot_ns_usb"        ),
+        MK_DROP( "boot_wce_flash"     ),
+        MK_DROP( "boot_wce_net"       ),
+        MK_DROP( "boot_wce_usb"       ),
+        MK_DROP( "connect_to_pb"      ),
+        MK_DROP( "set_esize"          ),
+        MK_DROP( "set_ebsize"         ),
+        MK_DROP( "set_wcesize"        ),
+        MK_DROP( "ffxaddr"            ),
+        MK_DROP( "ffxsize"            ),
+        MK_DROP( "pou"                ),
+        MK_DROP( "splashimage"        ),
+        MK_DROP( "gtk"                ),
+        MK_DROP( "gtr"                ),
+        MK_DROP( "gtu"                ),
+        MK_DROP( "gtn"                ),
+        MK_DROP( "gtw"                ),
+        MK_DROP( "gte"                ),
+        MK_DROP( "gfk"                ),
+        MK_DROP( "gfn"                ),
+        MK_DROP( "gfe"                ),
+        MK_DROP( "gfw"                ),
+        MK_DROP( "guk"                ),
+        MK_DROP( "gur"                ),
+        MK_DROP( "guu"                ),
+        MK_DROP( "gun"                ),
+        MK_DROP( "guw"                ),
+        MK_DROP( "gue"                ),
+        MK_DROP( "wfr"                ),
+        MK_DROP( "wfk"                ),
+        MK_DROP( "wfu"                ),
+        MK_DROP( "wfn"                ),
+        MK_DROP( "wfe"                ),
+        MK_DROP( "wfw"                ),
+        MK_DROP( "cfr"                ),
+        MK_DROP( "cfk"                ),
+        MK_DROP( "cfu"                ),
+        MK_DROP( "cfw"                ),
+        MK_DROP( "cfe"                ),
+        MK_DROP( "smtd"               ),
+        MK_DROP( "snfs"               ),
+        MK_DROP( "nsldr"              ),
+        MK_DROP( "nsexe"              ),
+
+        /* replaced by flpart */
+        MK_DROP( "flashsize"          ),
+        MK_DROP( "flashpartsize"      ),
+        MK_DROP( "loadaddr"           ),
+};
+#undef MK_DROP
+#undef MK_CONV
+
+/* ********** local functions ********** */
+
+/*! \brief determines what to do with I2C szEnv */
+static const env_action_t* FindConvertAction( const char* szEnvVar )
+{
+        const env_action_t* pAction = NULL;
+        int i = 0;
+
+        while( i < ARRAY_SIZE( l_axEnvAction ) ) {
+                const env_action_t* pIt = &l_axEnvAction[ i ];
+                if( !strcmp( pIt->szEnvVar, szEnvVar ) ) {
+                        /* found action */
+                        pAction = pIt;
+                        break;
+                }
+
+                i++;
+        } /* while( i < ARRAY_SIZE ) */
+
+        return pAction;
+}
+
+/*! don't store the same value. This skips internal handling stuff like setting
+ *  baudrate.
+ * When a variable is kept, it is printed. */ 
+static void SetEnvIfNotSet( const char* szEnvVar, const char* szEnvVal )
+{
+        const char* szDefault = GetEnvVar( szEnvVar, 1 );
+
+        if( ( NULL == szDefault ) || strcmp( szEnvVal, szDefault ) ) {
+                /* print what we keep */
+                printf( "  %s=%s\n", szEnvVar, szEnvVal );
+                /* keep it */
+                setenv( (char*) szEnvVar, (char*) szEnvVal );
+        }
+}
+
+/*! \brief takes an old environment variable and converts/drops/reuses it */
+/*! If no special handling is defined, the environment variables is reused */
+static void HandleOldEnv( const char* szEnvVar, const char* szEnvVal )
+{
+        const env_action_t* pAction = FindConvertAction( szEnvVar );
+        char  bDrop = 0;
+
+        if( NULL != pAction ) {
+                switch( pAction->eAction ) {
+                    case ENV_DROP: bDrop = 1; break;
+                    case ENV_CONV:
+                        bDrop = 1;
+                        switch( pAction->eConv ) {
+                            case ENVC_GATEWAY:
+                                /* gw->gateway. Use new variable */
+                                bDrop = 0;
+                                szEnvVar = "gateway";
+                                break;
+                            case ENVC_DNS:
+                                /* dns->dnsip. Use new variable */
+                                bDrop = 0;
+                                szEnvVar = "dnsip";
+                                break;
+                            case ENVC_BOOTCMD:
+                                eprintf( " Can't upgrade \"bootcmd=%s\" automatically. Please provide the correct \"dboot\"\n",
+                                         szEnvVal );
+                                break;
+                            case ENVC_STDBOOTARG:
+                            {
+                                    /* try to extract the console= part
+                                     which is now in printenv_dynamic*/
+                                    char  szBootArg[ 512 ];
+                                    char  szConsole[ 64 ];
+                                    char* szOrigConsole = strstr( szEnvVal, CONSOLE_VAR );
+
+                                    if( NULL != szOrigConsole ) {
+                                            /* extract console= */
+                                            char* szEnd = strchr( szOrigConsole, ' ' );
+                                            int   iLen; 
+                                            int   iLenAssign = strlen( CONSOLE_VAR );
+
+                                            if( NULL == szEnd )
+                                                    iLen = strlen( szOrigConsole );
+                                            else
+                                                    iLen = szEnd - szOrigConsole;
+
+                                            iLen -= iLenAssign;  /* length of argument */
+
+                                            strncpy( szConsole, szOrigConsole + iLenAssign,
+                                                     min( ARRAY_SIZE( szConsole ) - 1, iLen ) );
+                                            szBootArg[ 0 ] = 0;
+
+                                            /* remove console= from old argument */
+                                            /* stuff preceeding console= */
+                                            strncat( szBootArg,
+                                                     szEnvVal,
+                                                     min( ARRAY_SIZE( szBootArg ),
+                                                          ( szOrigConsole - szEnvVal ) ) );
+                                            if( NULL != szEnd ) {
+                                                    /* stuff following space after console=...*/
+                                                    if( szOrigConsole != szEnvVal )
+                                                            /* console= was in middle, add space  */
+                                                            strncat( szBootArg,
+                                                                     " ",
+                                                                     ARRAY_SIZE( szBootArg ) - strlen( szBootArg ) );
+                                                    strncat( szBootArg,
+                                                             szEnd + 1,
+                                                             ARRAY_SIZE( szBootArg ) - strlen( szBootArg ) );
+                                            }
+                                            
+                                            SetEnvIfNotSet( "std_bootarg", szBootArg );
+                                            SetEnvIfNotSet( "console",     szConsole );
+                                    } else
+                                            /* try to keep it */
+                                            bDrop = 0;
+                                    break;
+                            } /* ENVC_STDBOOTARG */
+                            case ENVC_ETHADDR:
+                            {
+                                    /* ethaddr is write protected, see [2] */
+                                    nv_critical_t* pCritical = NULL;
+                                    nv_mac_t       xMAC;
+                                    if( NvCriticalGet( &pCritical ) &&
+                                        NvToMAC( &xMAC, szEnvVal ) ) {
+                                            pCritical->s.p.xID.axMAC[ 0 ] = xMAC;
+                                            /* param 0 (flag) not used */
+                                            const char* argv[] = { "setenv", "ethaddr", szEnvVal };
+                                            _do_orig_setenv( 0, ARRAY_SIZE( argv ), (char**) argv );
+                                    }
+                                    else
+                                            eprintf( " Couldn't convert MAC %s\n",
+                                                     szEnvVal );
+                                    break;
+                            } /* ENVC_ETHADDR */
+                        } /* switch( pAction->eConv ) */
+                        break;  /* ENV_CONV */
+                } /* switch( pAction->eAction ) */
+        } /* NULL != pAction */
+        /* if not found, must be from user, keep it */
+        
+        if( !bDrop )
+                SetEnvIfNotSet( szEnvVar, szEnvVal );
+}
+
+/*! \brief copies the I2C EEPROM to if valid */
+/*! \return 0 if I2C EEPROM not present or wrong CRC */
+static int GetI2CEnv( void )
+{
+        ulong ulCRC32Calc;
+        ulong ulCRC32Read;
+        
+        /* copy data to RAM */
+
+        if( eeprom_read( CFG_I2C_EEPROM_ADDR, CMD_BSP_COMPAT_ENV_OFFSET,
+                         (uchar*) l_acEnv, sizeof( l_acEnv ) ) ) {
+                eprintf( "I2C Read Error\n" );
+                goto error;
+        }
+
+        /* get CRC32 in EEPROM */
+        memcpy( &ulCRC32Read, &l_acEnv[ offsetof( env_t, crc ) ], sizeof( ulong ) );
+
+        /* calculate new CRC32, only of remaining data, see [1] */
+        ulCRC32Calc = crc32( 0, (uchar*) l_pcEnvData,
+                             l_acEnv + sizeof( l_acEnv ) - l_pcEnvData );
+
+        if( ulCRC32Calc != ulCRC32Read ) {
+                eprintf( "CRC Error: I2C not initialized by U-Boot 1.1.3?\n" );
+                goto error;
+        }
+
+        /* I2C Data is valid */
+
+        return 1;
+        
+error:
+        return 0;
+}
+
+/*! \brief Upgrades I2C Environment to NVRAM */
+/*! \return 1 on failure otherwise 0 */
+static int do_digi_upgrade(
+        cmd_tbl_t* cmdtp,
+        int flag,
+        int argc, char* argv[] )
+{
+        char* szEnvLine = l_pcEnvData;
+        const nv_info_t* pInfo = NULL;
+
+        /* copy I2C EEPROM area to RAM if present and valid */
+
+        if( !CW( GetI2CEnv() ) )
+            goto error;
+
+        /* I2C exists, now check whether we already have NVRAM */
+        /* does  */
+        pInfo = NvInfo();
+        if( ( NULL != pInfo ) && pInfo->bGood )
+                CE( WaitForYesPressed( "NVRAM in Flash already exists. Overwrite it", "Upgrade" ) );
+        
+        /* we can upgrade from now */
+
+        /* scan all environment variables and handle them
+           (store, convert, drop) */
+
+        printf( "Keeping non-default environment variables:\n" );
+        while( szEnvLine < ( l_acEnv + sizeof( l_acEnv ) ) ) {
+                const char* szAssign;
+                char  szEnvVar[ 64 ];
+                int   iLen = strlen( szEnvLine );
+                int   iLenName;
+                
+                if( !iLen )
+                        /* no more entries */
+                        break;
+
+                /* extract only name part  */
+                szAssign = strchr( szEnvLine, '=' );
+                iLenName = szAssign - szEnvLine;  /* may be <0 if szAssign == NULL*/
+                /* convert/reuse/drop variable */
+                if( ( NULL != szAssign ) && ( iLenName < sizeof( szEnvVar ))){
+                        strncpy( szEnvVar, szEnvLine, iLenName );
+                        szEnvVar[ iLenName ] = 0;
+                        HandleOldEnv( szEnvVar, szAssign + 1 ); /* skip '=' */
+                } else
+                        eprintf( "Can't handle line %s\n", szEnvLine );
+                
+                /* next line */
+                szEnvLine += iLen + 1;
+        } /* while( szEnvLine ) */
+
+        if( !CW( NvSave() ) )
+            goto error;
+        
+        /* save nvram */
+
+        printf( "I2C EEPROM upgraded to NVRAM\n" );
+
+        return 0;
+        
+error:
+        return 1;
+}
+
+U_BOOT_CMD(
+	upgrade, 1, 0, do_digi_upgrade,
+	"upgrade - Upgrades U-Boot Environment variables to 1.1.4\n",
+	"Converts U-Boot 1.1.3 Environment to U_Boot 1.1.4 NVRAM Structure\n"
+);
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_CMD_BSP_COMPAT))*/
diff --git a/common/digi/cmd_nvram/Makefile b/common/digi/cmd_nvram/Makefile
new file mode 100644
index 0000000..f01065c
--- /dev/null
+++ b/common/digi/cmd_nvram/Makefile
@@ -0,0 +1,55 @@
+#
+# (C) Copyright 2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+DIGI_DIR = $(TOPDIR)/common/digi
+
+LIB	= libnvram.a
+
+COBJS	= mtd.o \
+	  lib/src/nvram.o lib/src/nvram_cmdline.o \
+	  cmd.o nvram_priv_uboot.o env.o \
+	  partition.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+CFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CPPFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/common/digi/cmd_nvram/cmd.c b/common/digi/cmd_nvram/cmd.c
new file mode 100644
index 0000000..ab622f3
--- /dev/null
+++ b/common/digi/cmd_nvram/cmd.c
@@ -0,0 +1,111 @@
+/*
+ *  U-Boot/common/digi/cmd_nvram/cmd.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$: 
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides
+ *                "internal_nvram": the NVRAM functions to access MAC, IP etc.
+ *                                  for U-Boot
+ *                "partition": a GUI for modifying the partition table.
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & (CFG_CMD_BSP ) )
+
+#include <command.h>
+#include <dvt.h>
+
+#include "nvram.h"
+#include "env.h"
+#include "partition.h"
+
+extern void set_mac_from_env( void );
+
+static int do_nvram( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        if( !CW( NvCmdLine( argc - 1, (const char**) &argv[ 1 ] ) ) )
+                return 1;
+
+        CE( !DVTError() );
+
+        if( ( argc > 1 ) &&
+            ( !strcmp( "set", argv[ 1 ] ) || !strcmp( "reset", argv[ 1 ] ) ) ) {
+                /* update U-Boot variables */
+                NvEnvUpdateFromNVRAM();
+		
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+		if(argc > 3 && !strncmp(argv[ 3 ],"ethaddr1",7))
+			set_mac_from_env();
+#endif
+	}
+        /* called from U-Boot */
+        return 0;
+
+error:
+        return 1;
+}
+
+/***********************************************************************
+ * !Function: do_partition
+ * !Return:   1 on failure otherwise 0
+ * !Descr:    handles the partition command
+ ***********************************************************************/
+
+static int do_partition( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        int iRes = 0;
+
+        if( 1 == argc )
+                iRes = PartGUI();
+        else if( ( argc == 2 ) && !strcmp( "setenv_mtdparts", argv[ 1 ] ) ) {
+                char szMtdParts[ 2048 ];
+                szMtdParts[ 0 ] = 0;
+                iRes = PartStrAppendParts( szMtdParts, sizeof( szMtdParts ) );
+                if( iRes ) {
+                        printf( "Setting mtdparts variable\n" );
+                        setenv( "mtdparts", szMtdParts );
+                }
+        } else if( ( argc == 2 ) && !strcmp( "setenv_mtdroot", argv[ 1 ] ) ) {
+                char szMtdRoot[ 2048 ];
+                szMtdRoot[ 0 ] = 0;
+                iRes = PartStrAppendRoot( szMtdRoot, sizeof( szMtdRoot ) );
+                if( iRes ) {
+                        printf( "Setting mtdroot variable\n" );
+                        setenv( "mtdroot", szMtdRoot );
+                }
+        } else
+                printf( "Usage:\n%s\n", cmdtp->usage );
+
+        return !iRes;
+}
+
+/* ********** U-Boot command table ********** */
+
+U_BOOT_CMD(
+	intnvram, 100, 0, do_nvram,
+	"intnvram- displays or modifies NVRAM contents like IP or partition table\n",
+	"[help]\n"
+        "This is an internal command. Use \"intnvram help\" for detailed help\n"
+);
+
+U_BOOT_CMD(
+	flpart, 2, 0, do_partition,
+	"flpart  - displays or modifies the partition table.\n",
+	"[ setenv_mtdparts | setenv_mtdroot ]\n"
+        "Is a GUI frontend to the partition part of internal_nvram\n"
+        " o if setenv_mtdparts is present, the partition table is stored in the\n"
+        "   U-Boot environment variable mtdparts for use with linux\n"
+        " o if setenv_mtdroot is present, the partition table configuration of rootfs\n"
+        "   is stored in the U-Boot environment variable mtdroot for use with linux"
+);
+
+#endif  /* CONFIG_COMMANDS */
diff --git a/common/digi/cmd_nvram/env.c b/common/digi/cmd_nvram/env.c
new file mode 100644
index 0000000..5d9d7d8
--- /dev/null
+++ b/common/digi/cmd_nvram/env.c
@@ -0,0 +1,417 @@
+/*
+ *  common/digi/cmd_nvram/env.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$ 
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Replaces do_saveenv by an implementation that works with the
+ *               nvram library.
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <nand.h>
+#endif  /* CFG_CMD_NAND */
+
+#include <command.h>
+#include <environment.h>        /* env_t */
+
+#include "nvram.h"
+#include "env.h"
+
+#undef DBG_ENV
+
+#define OFFS( x ) \
+        .iOffs = ( (char*) &((nv_critical_t*) NULL)->s.p.x -       \
+                   (char*) NULL )
+
+#undef DEBUG                    /* defined by nand.h */
+#ifdef DBG_ENV
+# define DEBUG( szFormat, ... ) \
+        printf( szFormat, ##__VA_ARGS__ )
+#else
+# define DEBUG( szFormat, ... ) do { } while( 0 )
+#endif  /* DBG_ENV */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* references to names in env_common.c */
+extern uchar default_environment[];
+
+env_t* env_ptr = NULL;
+char * env_name_spec = "Digi NVRAM";
+
+/* ********** local typedefs **********/
+
+
+typedef enum {
+        ENV_IP,
+        ENV_BOOL_ON,            /* should be printed ON/OFF */
+        ENV_MAC
+} env_type_e;
+    
+typedef struct env_param {
+        const char* szName;
+        env_type_e  eType;
+        int         iOffs;
+        char        bReadOnly;
+} env_param_t;
+
+/* it is not static so we can set it manually for debugging */
+char g_bOptDetailed = 0;
+
+/* ********** extern stuff **********/
+
+extern env_t* env_ptr;          /* common/env_<nand/eeprom>.c */
+extern int _do_setenv( int flag, int argc, char *argv[] );  /* common/cmd_nvedit.c */
+extern int _do_orig_setenv (int flag, int argc, char *argv[]);
+
+/* ********** local functions **********/
+
+static const env_param_t* EnvVarInNVRAM( const char* szArg );
+static int EnvVarStoreToNVRAM( const env_param_t* pParam, const char* szVal );
+
+/* ********** local variables **********/
+
+static const env_param_t l_axParam[] = {
+        { "ethaddr",      ENV_MAC, OFFS( xID.axMAC[ 0 ] ), 1 },
+        { "wlanaddr",     ENV_MAC, OFFS( xID.axMAC[ 1 ] ), 1 },
+        { "ipaddr",       ENV_IP,  OFFS( xIP.axDevice[ 0 ].uiIP ) },
+        { "ipaddr_wlan",  ENV_IP,  OFFS( xIP.axDevice[ 1 ].uiIP ) },
+        { "netmask",      ENV_IP,  OFFS( xIP.axDevice[ 0 ].uiNetMask ) },
+        { "netmask_wlan", ENV_IP,  OFFS( xIP.axDevice[ 1 ].uiNetMask ) },
+        { "serverip",     ENV_IP,  OFFS( xIP.uiIPServer ) },
+        { "gatewayip",    ENV_IP,  OFFS( xIP.uiIPGateway) },
+        { "dnsip",        ENV_IP,  OFFS( xIP.auiIPDNS[ 0 ] ) },
+        { "dnsip2",       ENV_IP,  OFFS( xIP.auiIPDNS[ 1 ] ) },
+        { "dhcp",         ENV_BOOL_ON, OFFS( xIP.axDevice[ 0 ].flags.bDHCP ) },
+        { "dhcp_wlan",    ENV_BOOL_ON, OFFS( xIP.axDevice[ 1 ].flags.bDHCP ) },
+};
+   
+
+
+/* ********** global functions **********/
+int _do_setenv( int flag, int argc, char* argv[] )
+{
+        int iRes = 1;
+        const env_param_t* pParam;
+        
+        if( argc >= 2 ) {
+                pParam = EnvVarInNVRAM( argv[ 1 ] );
+                if( NULL != pParam ) {
+                        /* variable is maintained in NVRAM and not by U-Boot
+                         * environment */
+                        if( !pParam->bReadOnly ) {
+                                if( argc != 2 )
+                                        iRes = EnvVarStoreToNVRAM( pParam, argv[ 2 ] );
+                                else {
+                                        iRes = 0;
+                                        eprintf( "Variable %s can't be deleted\n",
+                                                 argv[ 1 ] );
+                                }
+                        } else {
+                                iRes  = 0;
+                                eprintf( "Variable %s can't be changed by setenv\n",
+                                         argv[ 1 ] );
+                        } /* if( !pParam->bReadOnly ) */
+                } /* if( NULL != pParam */
+        } /* if( argc >= 2 ) */
+
+        if( iRes )
+                iRes = ( _do_orig_setenv( flag, argc, argv ) >= 0 );
+
+        return ( iRes ? 0 : -1 );
+}
+
+int saveenv( void )
+{
+        int iRes;
+        int i;
+        char* argvSetEnv[ 4 ] = { "setenv", NULL, NULL };
+        
+        /* remove environment variables used by us */
+        for( i = 0; i < ARRAY_SIZE( l_axParam ); i++ ) {
+                argvSetEnv[ 1 ] = (char*) l_axParam[ i ].szName;
+                DEBUG( "Removing from U-Boot NVRAM %s\n",
+                         argvSetEnv[ 1 ] );
+                /* ignore if it works or not */
+                _do_orig_setenv( 0, ARRAY_SIZE( argvSetEnv ), argvSetEnv );
+        }
+
+        iRes = CW( NvOSCfgSet( NVOS_UBOOT, env_ptr, CFG_ENV_SIZE ) );
+        if( iRes )
+                iRes &= CW( NvSave() );
+
+        CW( NvEnvUpdateFromNVRAM() );
+        
+        return ( iRes ? 0 : -1 );
+}
+
+/*! \brief adds the NVRAM variables to U-Boot Environment variables */
+/*! \return 0 on failure otherwise 1 */
+
+int NvEnvUpdateFromNVRAM( void )
+{
+        int iRes = 1;
+        int i;
+        nv_critical_t* pCrit;
+        char szTmp[ 40 ];
+
+        if( !CW( NvCriticalGet( &pCrit ) ) ) 
+            return 0;
+
+        for( i = 0; i < ARRAY_SIZE( l_axParam ); i++ ) {
+                char* argvSetEnv[] = { "setenv", NULL, NULL };
+                const env_param_t* pParam = &l_axParam[ i ];
+                void* pvAddr;
+
+                argvSetEnv[ 1 ] = (char*) pParam->szName;
+                argvSetEnv[ 2 ] = szTmp;
+                
+                pvAddr = (char*) pCrit + pParam->iOffs;
+                switch( pParam->eType ) {
+                    case ENV_MAC:
+                        strncpy( szTmp,
+                                 NvToStringMAC( *(nv_mac_t*) pvAddr ),
+                                 sizeof( szTmp ));
+                        break;
+                    case ENV_IP:
+                    {
+                            nv_ip_t ip = *(nv_ip_t*) pvAddr;
+                            strncpy( szTmp,
+                                     NvToStringIP( ip ),
+                                     sizeof( szTmp ));
+                    }
+                    break;
+                    case ENV_BOOL_ON:
+                        sprintf( szTmp, "%s",
+                                 ( *(char*) pvAddr ? "on" : "off" ) );
+                        break;
+                }
+
+                DEBUG( "Adding to U-Boot from NVRAM %s=%s\n",
+                       argvSetEnv[ 1 ], argvSetEnv[ 2 ] );
+                
+                _do_orig_setenv( 0, ARRAY_SIZE( argvSetEnv ), argvSetEnv );
+        }
+
+        return iRes;
+}
+
+/*! \brief returns the partition information of the first JFFS2 partition */
+/*! \param pPartInfo offset and size are modified when a partition is found.
+ * \return 1 if there is a JFFS2 partition in the partition table  */
+
+int NvEnvGetFirstJFFS2Part( struct part_info* pPartInfo )
+{
+        int iRes = 0;
+        const nv_param_part_t* pPart;
+
+        iRes = NvParamPartFind(
+                &pPart,
+                NVPT_FILESYSTEM,
+                NVFS_JFFS2,
+                0,
+                1 );
+
+        if( iRes ) {
+                pPartInfo->offset = pPart->ullStart;
+                pPartInfo->size   = pPart->ullSize;
+        }
+
+        return iRes;
+}
+
+/*! \brief checks whether szArg is maintained by NVRAM */
+/*! When maintained in NVRAM, it shouldn't be stored in U-Boot Environment
+ *  variables persistent
+* \return 1 if szArg is in NVRAM */
+
+static const env_param_t* EnvVarInNVRAM( const char* szArg )
+{
+        int i;
+        const env_param_t* pParam = NULL;
+        
+        for( i = 0; i < ARRAY_SIZE( l_axParam ); i++ ) {
+                
+                if( !strcmp( szArg, l_axParam[ i ].szName ) ) {
+                        pParam = &l_axParam[ i ];
+                        break;
+                }
+        }
+
+        return pParam;
+}
+
+/*! \brief adds the U-Boot environment variables to NVRAM */
+/*! \return 0 on failure otherwise 1 */
+
+static int EnvVarStoreToNVRAM( const env_param_t* pParam, const char* szVal )
+{
+        int iRes = 0;
+        nv_critical_t* pCrit;
+        void* pvAddr;
+        
+        if( !CW( NvCriticalGet( &pCrit ) ) ) 
+            return 0;
+
+        pvAddr = (char*) pCrit + pParam->iOffs;
+
+        switch( pParam->eType ) {
+            case ENV_MAC:
+                iRes = NvToMAC( (nv_mac_t*) pvAddr, szVal );
+                break;
+
+            case ENV_IP:
+                iRes = NvToIP( (nv_ip_t*) pvAddr, szVal );
+                break;
+
+            case ENV_BOOL_ON:
+                if( !strcmp( szVal, "no" ) || !strcmp( szVal, "off" ) ) {
+                        *(char*) pvAddr = 0;
+                        iRes = 1;
+                } else if( !strcmp( szVal, "yes" ) || !strcmp( szVal, "on" ) ) {
+                        *(char*) pvAddr = 1;
+                        iRes = 1;
+                }
+                break;
+        }
+
+        /* we did change it, printall should reflect it */
+        CW( iRes );
+        
+        return iRes;
+}
+
+uchar env_get_char_spec (int index)
+{
+	return ( *((uchar *)(gd->env_addr + index)) );
+}
+
+/* this is called before nand_init()
+ * so we can't read Nand to validate env data.
+ * Mark it OK for now. env_relocate() in env_common.c
+ * will call our relocate function which will does
+ * the real validation.
+ */
+
+int env_init( void )
+{
+	gd->env_addr  = (ulong)&default_environment[0];
+        /* to call env_relocate_spec */
+	gd->env_valid = 1;
+
+	return (0);
+}
+
+void env_relocate_spec( void )
+{
+        size_t iSize;
+        static char bAlreadyInitialized = 0;
+        int iRes = 1;
+        nv_repair_e eMode = NVR_AUTO;
+
+#ifdef CONFIG_DOWNLOAD_BY_DEBUGGER
+        /* if debugger is used, we always want to use defaults, e.g. ops */
+        eMode = NVR_IGNORE;
+#endif
+        
+        if( !bAlreadyInitialized ) {
+                iRes = CW( NvInit( eMode ) );
+                /* env_relocate sets env_addr on return. This invalidates all
+                 * variables we use  */
+                gd->env_addr = (ulong)&(env_ptr->data);
+                bAlreadyInitialized = 1;
+        }
+
+        if( iRes )
+                iRes = CW( NvOSCfgGet( NVOS_UBOOT, env_ptr, CFG_ENV_SIZE, &iSize ) );
+
+	if( !iRes || ( CFG_ENV_SIZE != iSize ) ||
+            ( crc32( 0, env_ptr->data, ENV_SIZE ) != env_ptr->crc ) ) {
+                puts ("*** Warning - bad CRC or NAND, using default environment\n\n");
+                NvEnvUseDefault();
+        } else {
+                gd->env_valid = 1;
+                CW( NvEnvUpdateFromNVRAM() );
+        }
+
+#ifdef CFG_HAS_WIRELESS
+	{
+		/* 
+		 * For wireless modules, read also the mac addr and calibration information. 
+		 * That information is placed at address 0x1000 to allow the OS accessing 
+		 * to that information. 
+		 */
+		unsigned char *pMac = (unsigned char *)(gd->bd->bi_boot_params + 0xf00);
+		wcd_data_t *pWCal = (wcd_data_t *)(gd->bd->bi_boot_params + 0xf08);
+		nv_critical_t *pNvram = NULL;
+
+		iRes = CW( NvOSCfgGet( NVOS_WCAL_DATA, pWCal, sizeof( wcd_data_t ), &iSize ) );
+		if( iRes && ( iSize == sizeof( wcd_data_t ) ) ) {
+			iRes = NvPrivWirelessCalDataCheck( pWCal );
+			if ( !iRes )
+				puts ("*** Warning - Wireless Calibration Data corrupted!\n\n");
+		}
+		
+		iRes = NvCriticalGet( &pNvram );
+		if ( iRes != 0 ) {
+			memcpy((unsigned char *)pMac, &pNvram->s.p.xID.axMAC[1], 6);
+		}
+	}
+#endif
+}
+
+void NvEnvUseDefault( void )
+{
+	memset( env_ptr, 0, sizeof(env_t) );
+	memcpy( env_ptr->data,
+                default_environment,
+                CFG_ENV_SIZE );
+
+	env_ptr->crc = crc32( 0, env_ptr->data, CFG_ENV_SIZE );
+	gd->env_valid = 1;
+
+        CW( NvEnvUpdateFromNVRAM() );
+}
+
+void NvEnvPrintError( const char* szFormat, ... )
+{
+        const char* szError    = NULL;
+        const char* szWhat = NULL;
+        const char* szFunc = NULL;
+        const char* szFile = NULL;
+        int iLine;
+
+        va_list ap;
+
+        /*eprintf may not be present here because no stderr set */
+        printf( "*** Error: " );
+        if( g_bOptDetailed ) {
+                /*@-formatconst@*/
+                va_start( ap, szFormat );
+                vprintf( szFormat, ap );
+                va_end( ap );
+                printf( ": " );
+                /*@+formatconst@*/
+        }
+
+        if( NVE_GOOD != NvErrorMsg( &szError, &szWhat, &szFunc, &szFile, &iLine ) ) {
+                if( g_bOptDetailed )
+                        printf( " %s: (%s) @ %s:%i (%s)",
+                                 szError, szWhat, szFile, iLine, szFunc );
+                else
+                        printf( " %s: (%s)",
+                                szError, szWhat);
+        }
+        
+        printf( "\n" );
+}
diff --git a/common/digi/cmd_nvram/env.h b/common/digi/cmd_nvram/env.h
new file mode 100644
index 0000000..9d9db6f
--- /dev/null
+++ b/common/digi/cmd_nvram/env.h
@@ -0,0 +1,44 @@
+/*
+ *  common/digi/cmd_nvram/env.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines the functions to combine the U-Boot environment with
+ *               NVRAM
+ */
+
+#ifndef __DIGI_CMD_NVRAM_ENV_H
+#define __DIGI_CMD_NVRAM_ENV_H
+
+#include <jffs2/load_kernel.h>  /* part_info */
+
+# define CW( cmd ) \
+        ({                          \
+                int _iRes = (cmd);               \
+                if( !_iRes ) \
+                        NvEnvPrintError( #cmd );      \
+                (_iRes); \
+        })
+
+#define CE( sCmd ) \
+        do { \
+                if( !(sCmd) )       \
+                        goto error; \
+        } while( 0 )
+
+struct nv_param_part;
+
+extern int NvEnvUpdateFromNVRAM( void );
+extern int NvEnvGetFirstJFFS2Part( struct part_info* pPartInfo );
+extern void NvEnvUseDefault( void );
+extern void NvEnvPrintError( const char* szFormat, ... );
+
+#endif /* __DIGI_CMD_NVRAM_ENV_H */
diff --git a/common/digi/cmd_nvram/lib/README.txt b/common/digi/cmd_nvram/lib/README.txt
new file mode 100644
index 0000000..2adf03b
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/README.txt
@@ -0,0 +1,6 @@
+This library is distributed to different OS by having set a symbolic link in
+the CVS repository.
+
+OS are:
+o LxNETES_toolchain/packages/nvram/lib
+o U-Boot/common/digi/cmd_nvram/lib
diff --git a/common/digi/cmd_nvram/lib/include/nvram.h b/common/digi/cmd_nvram/lib/include/nvram.h
new file mode 100644
index 0000000..e2928aa
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/include/nvram.h
@@ -0,0 +1,441 @@
+/*
+ *  nvram/include/nvram.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides the NVRAM functions to access MAC, IP etc.
+ */
+
+#ifndef NVRAM_H
+#define NVRAM_H
+
+#include "nvram_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ********** constants ********** */
+
+#define NV_MAGIC_CRITICAL	"NVRAMC"
+#define NV_MAX_PARTITIONS	10
+#define NV_MAX_ETH_DEVICES	2
+#define NV_PART_NAME_LENGTH	20
+#define NV_PRODUCT_LENGTH	20
+#define NV_SERIAL_LENGTH	12
+#define NV_RESERVED_CRITICAL_SIZE 2048
+
+#define WCD_MAGIC		"WCALDATA"
+#define WCD_MAX_CAL_POINTS	8
+#define WCD_CHANNELS_BG		14
+#define WCD_CHANNELS_A		35
+
+/* ********** typedefs ********** */
+
+/*! \brief Image types supported. */
+typedef enum {
+        NVCL_ORIGINAL = 0,          /*! original image */
+        NVCL_MIRROR   = 1,          /*! mirror image  */
+        NVCL_WORKCOPY,              /*! for setting data */
+        NVCL_LAST,                  /*! for defining array sizes for nv_os_type_e */
+} nv_critical_loc_e;
+
+/*! The operating system for which an operation should be performed  */
+typedef enum {
+        NVOS_NONE,              /*! no operating system */
+        NVOS_CRITICAL,          /*! for all (critical parameter) */
+        NVOS_OS_META,           /*! metainfo for OS configuration table */
+        NVOS_UBOOT,             /*! U-Boot Environment variables  */
+        NVOS_LINUX,             /*! Linux settings */
+        NVOS_EBOOT,             /*! WinCE EBoot Loader */
+        NVOS_WINCE,
+        NVOS_NETOS,
+        NVOS_UNKNOWN,           /*! Operating System not known, store it in flash  */
+        NVOS_APPL,              /*! so user can store his data */
+        NVOS_NETOS_LOADER,      /*! NET+OS rom.bin */
+        NVOS_USER_DEFINED,      /*! User defined partition table */
+        NVOS_WCAL_DATA,         /*! Wireless calibration data */
+	NVOS_LAST               /*! for defining array sizes for nv_os_type_e */
+} nv_os_type_e;
+
+/*! \brief Defines the usage of the partition. */
+/*! Enhanced checks can be performed if the type is known*/
+typedef enum {
+        NVPT_UBOOT,             /*! U-Boot image */
+        NVPT_NVRAM,             /*! NVRAM table for U-Boot environment. The
+                                 *  first one is used. */
+        NVPT_FPGA,              /*! FPGA image needed by U-Boot  */
+        NVPT_LINUX,             /*! Linux kernel  */
+        NVPT_EBOOT,             /*! WinCE eboot  */
+        NVPT_WINCE,             /*! WinCE kernel */
+	NVPT_NETOS,             /*! NetOS kernel  */
+        NVPT_FILESYSTEM,        /*! Linux rootfs (rootfs or initrd)  */
+        NVPT_WINCE_REGISTRY,    /*! WindCE Registry  */
+        NVPT_UNKNOWN,           /*! Other usage */
+        NVPT_SPLASH_SCREEN,     /*! splash screen contents  */
+        NVPT_NETOS_LOADER,      /*! NET+OS rom.bin loader */
+        NVPT_NETOS_NVRAM,       /*! NET+OS NVRAM partition */
+        NVPT_LAST               /*! for defining array sizes for nv_part_type_e  */
+} nv_part_type_e;
+
+/*! \brief Defines the filesystem that is used on that partition. */
+/*! Enhanced checks can be performed if the type is known*/
+typedef enum {
+        NVFS_NONE,              /*! Not used for filesystem storage. */
+        NVFS_JFFS2,             /*! JFFS2 */
+        NVFS_CRAMFS,            /*! CRAMFS */
+        NVFS_INITRD,            /*! InitRD */
+        NVFS_FLASHFX,           /*! FlashFX */
+	NVFS_UNKNOWN,           /*! Unknown */
+        NVFS_YAFFS,             /*! YAFFS (Net+OS) */
+        NVFS_EXFAT,		/*! Extended FAT */
+        NVFS_SQUASHFS,          /*! SQUASHFS */
+	NVFS_ROMFS,             /*! ROMFS */
+	NVFS_LAST               /*! for defining array sizes for nv_fs_type_e  */
+} nv_fs_type_e;
+
+/*! \brief Error codes of the library */
+typedef enum {
+        NVE_GOOD = 0,           /*! no error happened */
+        NVE_NO_DEV,             /*! no device */
+        NVE_IO,                 /*! I/O error */
+        NVE_CRC,                /*! CRC error */
+        NVE_MIRROR,             /*! Mirror image failure */
+        NVE_NO_SPACE,           /*! no space for operation */
+        NVE_NOT_INITIALIZED,    /*! not initialized yet */
+        NVE_NOT_IMPLEMENTED,    /*! feature not implemented yet */
+        NVE_VERSION,            /*! for defining array sizes for nv_error_e  */
+        NVE_MAGIC,              /*! wrong magic */
+        NVE_MATCH,              /*! image doesn't match */
+        NVE_INVALID_ARG,        /*! invalid/unknown argument */
+        NVE_WRONG_VALUE,        /*! wrong value */
+        NVE_NOT_FOUND  ,        /*! not found */
+        NVE_LAST                /*! for defining array sizes for nv_error_e  */
+} nv_error_e;
+
+/*! \brief How image errors should be corrected. */
+typedef enum {
+        NVR_MANUAL,             /* no repair */
+        NVR_AUTO,               /* automatically repair by copying good image.*/
+        NVR_IGNORE,             /* ignore state of NVRAM */
+} nv_repair_e;
+            
+/* big endian. setting it to 0.0.0.0 means undefined. */
+typedef uint32_t nv_ip_t;
+        
+#pragma pack(push)
+typedef struct {
+        union {
+                uchar_t c[6];
+                uint32_t for_alignment[2];
+        } u;
+} nv_mac_t;
+
+/* All parameters are stored in NVRAM, so don't
+ * let the compiler mess around with sizes and alignments.
+ * Alinment is 64bit, so it works even on the x86 host.*/
+
+/*! \brief The module static parameters. */
+/*! These parameters should be set only in production*/
+typedef struct nv_param_module_id {
+        /*! \brief Product Type, e.g. 0363 or 55001167- */
+        char_t  szProductType[ NV_PRODUCT_LENGTH ];
+        /*! \brief Serial Number, e.g. B06500001*/
+        char_t  szSerialNr[ NV_SERIAL_LENGTH ];
+        /*! \brief Revision of the module. Hex Coded  */
+        uint32_t uiRevision;
+        /*! \brief Patchlevel of the module  */
+        uint32_t uiPatchLevel;
+        /*! \brief MAC address. 0 is internal ethernet,
+            1 is WiFi or reserved  */
+        nv_mac_t axMAC[ NV_MAX_ETH_DEVICES ];
+        /*! \brief who knows what comes?  */
+        uint32_t auiReserved[ 2 ];
+} nv_param_module_id_t;
+
+/*! \brief The module device dependant ip parameters. */
+typedef struct nv_param_ip_device {
+        /*! \brief the IP address, e.g. 192.168.42.30 */
+        nv_ip_t uiIP;
+        /*! \brief the netmaks, e.g. 255.255.255.0 */
+        nv_ip_t uiNetMask;
+        struct {
+                /*! \brief 1 if DHCP should be used on this device */
+                uint8_t bDHCP;
+                uint8_t acReserved[ 3 ];
+        } flags;
+        /*! \brief who knows what comes? IPv6? Reserve at least 128 bit */
+        uint32_t  auiReserved[ 5 ];
+} nv_param_ip_device_t;
+
+/*! \brief The module ip parameters that are not device dependant. */
+typedef struct nv_param_ip {
+        /*! \brief the gateway's IP */
+        nv_ip_t uiIPGateway;
+        /*! \brief the DNS IP addresses */
+        nv_ip_t auiIPDNS[ 2 ];
+        /*! \brief for the TFTP/NFS server. */
+        nv_ip_t uiIPServer;
+        /*! \brief for a NetConsole server. */
+        nv_ip_t uiIPNetConsole;
+        /*! \brief 0 for the internal, a second one for the external */
+        nv_param_ip_device_t axDevice[ NV_MAX_ETH_DEVICES ];
+        /*! \brief who knows what comes? IPv6? reserve at least one. */
+        uint32_t  auiReserved[ 5 ];
+} nv_param_ip_t;
+
+/*! \brief The parameters for one partition. Overlapping is allowed. */
+typedef struct nv_param_part {
+        /*! \brief the name that is used e.g. in /proc/mtd. */
+        char_t   szName[ NV_PART_NAME_LENGTH ];
+
+        /*! \brief the flash chip this partition entry is for. */
+        /*! 0 is the onboard boot flash */
+        uint32_t uiChip;
+        /*! \brief the start address of the partition on this chip. */
+        uint64_t ullStart;
+        /*! \brief the size of the partition. */
+        uint64_t ullSize;
+        /*! \brief the type of the partition. */
+        nv_part_type_e eType;
+
+        struct {
+                /*! \brief this entry is fixed and can't be changed. */
+                /*! Library ensures that bFixed entries are not overwritten.
+                 */
+                uint8_t  bFixed;
+
+                /*! \brief The partition itself is read-only.
+                  Only true if partition is NVPT_FILESYSTEM */
+                uint8_t  bReadOnly;
+
+                uint8_t  aucReserved[ 6 ];
+
+                /* the filesystem flags */
+                struct {
+                        /*! \brief The filesystem is mounted read-only. */
+                        uint8_t  bMountReadOnly;
+                        /*! \brief 1 if this is the rootfilesystem */
+                        uint8_t  bRoot;
+
+                        uint8_t  aucReserved2[ 2 ];
+                        
+                        /*! \brief the filesystem type of the partition. */
+                        /* Is NVFS_NONE if the partition type is not NVPT_FILESYSTEM.*/
+                        nv_fs_type_e eType;
+                        
+                        /*! \brief the file systems version. 0 if not used. */
+                        uint32_t  uiVersion;
+                } fs;
+        } flags;
+        uint32_t  auiReserved[ 6 ];
+} nv_param_part_t;
+
+/*! \brief The partition table. */
+typedef struct nv_param_part_table {
+        /*! \brief the number of partitions valid. Holes are not allowed. */
+        uint32_t  uiEntries;
+        /*! \brief who knows what comes? */
+        uint32_t  auiReserved[ 3 ];
+        /*! \brief the partition entries. 64bit aligned. */
+        nv_param_part_t axEntries[ NV_MAX_PARTITIONS ];
+} nv_param_part_table_t;
+
+/*! \brief The os entry for combining different operating systems
+     configuration*/
+/*! Multiple OS share config parameters in one NVRAM erase block.
+ *  The first NVPT_NVRAM entry is taken. And it must be */
+typedef struct nv_param_os_cfg {
+        /*! \brief the type of the os. */
+        nv_os_type_e eType;
+        /*! \brief the start offset inside that partition for the OS.*/
+        /*! It's only 32bit because there won't be an NVRAM partition > 4GB.*/
+        uint32_t uiStart;
+        /*! \brief the size of the os configuration params */
+        uint32_t uiSize;
+        /*! \brief who knows what comes? */
+        uint32_t auiReserved[ 2 ];
+} nv_param_os_cfg_t;
+    
+/*! \brief The os table for combining different operating systems configuration
+ */
+typedef struct nv_param_os_cfg_table {
+        /*! \brief the number of os configuration parameters used.*/
+        /*! Holes are not allowed. */
+        uint32_t  uiEntries;
+        /*! \brief who knows what comes? */
+        uint32_t  auiReserved[ 3 ];
+        /*! \brief The table pointing to the os configuration parameters */
+        nv_param_os_cfg_t axEntries[ 8 ];
+} nv_param_os_cfg_table_t;
+
+
+/*! \brief The wireless calibration information
+ */
+typedef struct nv_wcd_header {
+	char_t	magic_string[8];	/* WCALDATA */
+	char_t	ver_major;		/* Major version in ascii */
+	char_t	ver_minor;		/* Minor version in ascii */
+	uint16_t hw_platform;		/* Hardware Platform used for calibration */
+	uint8_t	numcalpoints;		/* Number of points per curve */
+	uint8_t	padding[107];		/* Reserved for future use */
+	uint32_t wcd_len;		/* Total length of the data section */
+	uint32_t wcd_crc;		/* Data section crc32 */
+} nv_wcd_header_t;
+
+
+typedef struct wcd_point {
+	int16_t	 out_power;		/* Output Power */
+	uint16_t adc_val;		/* Measured ADC val */
+	uint8_t  power_index;		/* Airoha Power Index */
+	uint8_t  reserved[3];		/* For future use */
+} wcd_point_t;
+
+typedef struct wcd_curve {
+	uint8_t  max_power_index;	/* Airoha Max Power Index */
+	uint8_t  reserved[3];		/* Resered for future use */
+	wcd_point_t points[WCD_MAX_CAL_POINTS];	/* Calibration curve points */
+} wcd_curve_t;
+
+typedef struct wcd_data {
+	nv_wcd_header_t  header;
+	wcd_curve_t cal_curves_bg[WCD_CHANNELS_BG][2];
+        wcd_curve_t cal_curves_a[WCD_CHANNELS_A];
+} wcd_data_t;
+
+    
+/*! \brief The partition table. */
+typedef struct nv_critical {
+        struct {
+                /*! \brief NV_MAGIC_CRITICAL */
+                char_t   szMagic[ 8 ];
+                /*! \brief the major version of these parameters. */
+                /*! There are incompatible changes if major version is increased. */
+                uint32_t  uiVerMajor;
+                /*! \brief the minor version of these parameters. */
+                /*! Only reserved entries are defined. */
+                uint32_t  uiVerMinor;
+                    
+                /* \brief everything in p can change from major version to
+                   major version. */
+                struct {
+                        /*! \brief the module identification */
+                        nv_param_module_id_t  xID;
+                        /*! \brief the partition table */
+                        nv_param_part_table_t xPartTable;
+                        /*! \brief the ip configuration */
+                        nv_param_ip_t         xIP;
+                        /*! \brief the os configuration block */
+                        nv_param_os_cfg_table_t xOSTable;
+                        /*! \brief who knows what comes? */
+                        uint32_t  auiReserved[ 16 ];
+                } p;
+        } s;
+            
+        /* \brief the checksum for s */
+        crc32_t  uiCRC32; 
+        uint32_t uiPadding; 
+} nv_critical_t;
+
+/*! \brief The information of the OS table. */
+typedef struct nv_os_meta {
+        /*! \brief the checksum for begin to end of erase block*/
+        crc32_t  uiCRC32;
+        uint32_t auiReserved[ 31 ];
+} nv_os_meta_t;
+            
+#pragma pack(pop)
+    
+typedef struct nv_info {
+        /*! \brief 1 if at least ORIGINAL or MIRROR is good */
+        uint8_t bGood;
+        uint8_t bAnyBad;
+        uint8_t bFlashOriginalGood;
+        uint8_t bFlashMirrorGood;
+        uint8_t bFlashMirrorMatch;
+        uint8_t bOriginalGood;
+        uint8_t bMirrorGood;
+        uint8_t bMirrorMatch;
+        uint8_t bOSGood;
+        uint8_t bOSOriginalGood;
+        uint8_t bDefault;       /* enabled if default's are used */
+} nv_info_t;
+
+/* ********** prototypes ********** */
+
+/*@-exportlocal@*/ // this is a library include filed. some code may be unused
+extern int NvInit( nv_repair_e eRepair );
+extern int NvFinish( void );
+extern int NvEnableOutput( char bEnable );
+extern nv_error_e NvError( void );
+extern nv_error_e NvErrorMsg( /*@out@*/ /*@null@*/ const char** pszError,
+                           /*@out@*/ /*@null@*/ const char** pszWhat,
+                           /*@out@*/ /*@null@*/ const char** pszFunc,
+                           /*@out@*/ /*@null@*/ const char** pszFile,
+                           /*@out@*/ /*@null@*/ int* piLine );
+extern void NvGetVersion( /*@out@*/ uint32_t* puiVerMajor,
+                          /*@out@*/ uint32_t* puiVerMinor );
+
+extern const struct nv_info* NvInfo( void );
+extern int NvPrintStatus( void );
+extern int NvSave( void );
+extern int NvWorkcopyUpdateCRC32( void );
+
+extern int NvWorkcopyReset( void );
+extern int NvCriticalGet(
+        /*@out@*/ struct nv_critical** ppCritical );
+extern int NvParamPartFind(
+        /*@out@*/ const struct nv_param_part** ppPart,
+        nv_part_type_e ePartType,
+        nv_fs_type_e   eFSType,
+        char           bRoot,
+        int            iCount );
+extern int NvCriticalPartAdd( const struct nv_param_part* pNewPart );
+extern int NvCriticalPartDelete( uint32_t uiPartition );
+extern int NvCriticalPartReset( nv_os_type_e eForOS );
+
+extern int NvOSCfgAdd( nv_os_type_e eType, size_t iSize );
+extern int NvOSCfgGet( nv_os_type_e eType,/*@out@*/  void* pvBuf,
+                       size_t iMaxSize, /*@out@*/ size_t* piSize );
+extern int NvOSCfgSet( nv_os_type_e eType, const void*  pvBuf,  size_t  iSize );
+extern int NvOSCfgFind( /*@out@*/ struct nv_param_os_cfg* pCfg,
+                        nv_os_type_e eType );
+extern int NvCmdLine( int argc, const char* argv[] );
+extern int NvPrintHelp( void );
+
+extern const char* NvToStringMAC( const nv_mac_t xMAC );
+extern int NvToMAC( /*@out@*/ nv_mac_t* pMAC, const char* szMAC );
+extern const char* NvToStringIP( nv_ip_t uiIP );
+extern int NvToIP( /*@out@*/ nv_ip_t* pIP, const char* szIP );
+extern const char* NvToStringPart( nv_part_type_e ePart );
+extern int NvToPart( /*@out@*/ nv_part_type_e* pePart, const char* szOS );
+extern const char* NvToStringFS( nv_fs_type_e eFS );
+extern int NvToFS( /*@out@*/ nv_fs_type_e* peFS, const char* szFS );
+extern const char* NvToStringOS( nv_os_type_e eOS );
+extern int NvToOS( /*@out@*/ nv_os_type_e* peOS, const char* szOS );
+extern const char* NvToStringLoc( nv_critical_loc_e eLoc );
+/*@+exportlocal@*/
+extern const char* NvToStringSize64( const uint64_t ullVal );
+extern int NvToSize64( /*@out@*/ uint64_t* pullVal, const char* szVal );
+extern int NvPrivAnyFlashImageGood(void);
+
+#ifdef CFG_HAS_WIRELESS
+extern int NvPrivWirelessCalDataCheck( wcd_data_t *pWCal );
+extern int NvPrivWCDGetFromFlashAndSetInNvram( void );
+extern int NvPrivWCDSaveInFlash( wcd_data_t *pWCal );
+extern int NvPrivWCDSetInNvram( wcd_data_t *pWCal );
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NVRAM_H */
diff --git a/common/digi/cmd_nvram/lib/include/nvram_priv.h b/common/digi/cmd_nvram/lib/include/nvram_priv.h
new file mode 100644
index 0000000..47a9399
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/include/nvram_priv.h
@@ -0,0 +1,110 @@
+/*
+ *  nvram/lib/include/nvram_priv.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines the private functions needed by the nvram core to
+ *               access I2C, Flash and a console.
+ */
+
+#ifndef NVRAM_PRIV_H
+#define NVRAM_PRIV_H
+
+#include "nvram.h"
+
+#define RETURN_NOT_IMPLEMENTED() \
+        return NV_SET_ERROR( NVE_NOT_IMPLEMENTED, "" )
+
+#define NV_SET_ERROR( eError, szWhat ) \
+        NvPrivSetError( eError, szWhat, __FUNCTION__, __FILE__, __LINE__ )
+
+#define CE( sCmd ) \
+        do { \
+                if( !(sCmd) )       \
+                        goto error; \
+        } while( 0 )
+
+#define CE_SET_ERROR_EXT( sCmd, iError, szWhat )           \
+        do { \
+                if( !(sCmd) ) {   \
+                        NV_SET_ERROR( (iError), (szWhat) );   \
+                        goto error; \
+                } \
+        } while( 0 )
+#define CE_SET_ERROR( sCmd, iError )           \
+        CE_SET_ERROR_EXT( sCmd, iError, "" )
+        
+#define CE_WRONG_VALUE( sCmd, szWhat )       \
+        CE_SET_ERROR_EXT( sCmd, NVE_WRONG_VALUE, szWhat )
+
+#define REQUIRE_INITIALIZED() \
+        CE_SET_ERROR_EXT( g_bInitialized, NVE_NOT_INITIALIZED, "" )
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ********** global types ********** */
+
+typedef struct nv_priv_flash_status {
+        size_t  iEraseSize;
+        uint8_t bBad;
+	uint8_t type;   /* flash type */
+} nv_priv_flash_status_t;
+
+extern char      g_bInitialized;
+extern nv_info_t g_xInfo;
+extern nv_critical_t* g_pWorkcopy;
+
+/* ********** global private functions implemented in nvram.c already ********** */
+
+extern int NvPrivSetError( nv_error_e eError, const char* szWhat,
+                           const char* szFunc,
+                           const char* szFile, int iLine );
+extern char NvPrivIsOutputEnabled( void );
+
+/* ********** global private functions that are os specific ********** */
+
+extern int NvPrivOSInit( void );
+extern int NvPrivOSPostInit( void );
+extern int NvPrivOSFinish( void );
+
+extern int NvPrivOSCriticalPostReset(
+        struct nv_critical* pCrit );
+extern int NvPrivOSCriticalPartReset( /*@out@*/ struct nv_critical* pCrit,
+                                      nv_os_type_e eForOS );
+
+extern int NvPrivOSFlashOpen( char bForWrite );
+extern int NvPrivOSFlashClose( void );
+// iOffs must be on a sector of it's own and iLength must be < iEraseSize
+extern int NvPrivOSFlashRead(  /*@out@*/ void* pvBuf,
+                               loff_t iOffs, size_t iLength );
+extern int NvPrivOSFlashErase(
+        loff_t iOffs );
+extern int NvPrivOSFlashWrite( /*@in@*/ const void* pvBuf,
+                               loff_t iOffs, size_t iLength );
+extern int NvPrivOSFlashInfo(
+        loff_t iOffs,
+        /*@out@*/ struct nv_priv_flash_status* pStatus );
+extern int NvPrivOSFlashProtect( loff_t iOffs, size_t iLength, char bProtect );
+
+extern void NvPrivOSPrintf( const char* szFormat, ...);
+extern void NvPrivOSPrintfError( const char* szFormat, ...);
+extern int  NvPrivImageRepair( void );
+
+/* ********** global private variables ********** */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* NVRAM_PRIV_H */
diff --git a/common/digi/cmd_nvram/lib/include/nvram_types.h b/common/digi/cmd_nvram/lib/include/nvram_types.h
new file mode 100644
index 0000000..38600de
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/include/nvram_types.h
@@ -0,0 +1,116 @@
+/*
+ *  nvram/lib/include/nvram_types.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines standard types
+ */
+
+#ifndef NVRAM_TYPES_H
+#define NVRAM_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(LINUX)
+# include <string.h>            /* memset */
+# include <stdio.h>             /* snprintf */
+# include <stdint.h>            /* uint8 */
+# include <unistd.h>            /* size_t */
+# include <assert.h>            /* assert */
+# include <sys/types.h>         /* loff_t */
+# include <mtd/mtd-abi.h>       /* MTD_NORFLASH */
+/* digilib_ */
+# include <crc32.h>             /* crc32 */
+
+# define ARRAY_SIZE( x ) (sizeof(x)/sizeof(*(x)))
+# define ASSERT( expr ) assert( expr )
+# define PRINTF_QUAD "ll"
+# define CMD_NAME "nvram"
+# ifdef S_SPLINT_S
+/* splint checks for posixlibs, so we need to add some linux stuff */
+typedef uint64_t loff_t;
+extern /*@null@*/ /*@only@*/ char *strdup (char *s) /*@*/ ;
+# endif  /* S_SPLINT_S */
+
+# define strnicmp(a,b,c)	strncasecmp(a,b,c)
+# define memcpy32(a,b,c)	memcpy(a,b,c)
+
+#elif defined(UBOOT)
+# include <common.h>            /* panic */
+# include <linux/types.h>       /* loff_t */
+# include <linux/mtd/mtd-abi.h> /* MTD_NORFLASH */
+# include <malloc.h>            /* malloc */
+
+# include "../common/digi/vscanf.h"            /* vscanf/scanf */
+# include "../common/digi/atoi.h"              /* atoi */
+# define PRINTF_QUAD "q"
+# define CMD_NAME "intnvram"
+# define ASSERT( expr ) \
+        do { \
+                if( !(expr) )                                           \
+                        printf( "**** ASSERT %s@%s:%s", __FILE__, __LINE__, #expr ); \
+        } while( 0 )
+
+/* eprintf may fail in early steps before EEPROM is initialized, therefor printf*/
+
+typedef ulong crc32_t;
+#elif defined(WINCE)
+# include <windows.h> /**/
+# include <oal.h>	 /* OAL macros */
+#ifdef MX51
+# include <mx51_iomux.h> /* GPIO settings */
+# include <mx51_ddk.h> /* clock settings */
+#endif
+# include <args.h>	 /* BSP_ARGS */
+# include <crc32.h>  /* crc32 */
+/* defines */
+# define ARRAY_SIZE( x ) (sizeof(x)/sizeof(*(x)))
+# define PRINTF_QUAD "ll"
+# define CMD_NAME "nvram"
+# define memcpy32(a,b,c)	memcpy(a,b,c)
+/* MTD Flash device information */
+#define MTD_NORFLASH            3
+#define MTD_NANDFLASH           4
+/* typedefs */
+typedef unsigned long crc32_t;
+typedef UINT64 uint64_t;
+typedef INT64  int64_t;
+typedef UINT32 uint32_t;
+typedef INT32  int32_t;
+typedef UINT16 uint16_t;
+typedef INT16  int16_t;
+typedef UINT8  uint8_t;
+typedef INT8   int8_t;
+typedef uint64_t loff_t;
+#else
+# error "operating system not defined"
+#endif  /* LINUX */
+
+/* we want it identical for all os */
+#define CLEAR( x ) 		memset( &x, 0, sizeof( x ) )
+
+typedef unsigned char uchar_t;
+typedef char          char_t;
+
+#ifdef __GNUC__
+# define IDX(x) [x] =
+#else
+        /* e.g. Windows */
+# define IDX(x)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* NVRAM_TYPES_H */
diff --git a/common/digi/cmd_nvram/lib/src/nvram.c b/common/digi/cmd_nvram/lib/src/nvram.c
new file mode 100644
index 0000000..befac5e
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/src/nvram.c
@@ -0,0 +1,1385 @@
+/*
+ *  nvram/lib/src/nvram.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$: 
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides the NVRAM functions to access MAC, IP etc.
+ */
+
+#include "nvram.h"
+#include "nvram_priv.h"
+#include "nvram_version.h"
+#define memcpy32(a,b,c)	memcpy(a,b,c)
+
+#define NV_RESERVED_CRITICAL_SIZE 2048
+
+#define NVRAM "NVRAM: "
+
+#define FREE( pvPtr ) \
+        do { \
+                free( pvPtr );                  \
+                pvPtr = NULL;                   \
+        } while( 0 )
+
+/* ********** local function declarations ********** */
+
+static int NvPrivImagesRead( void );
+static int NvPrivImageWrite( nv_critical_loc_e eType );
+static int NvPrivImageRead( nv_critical_loc_e eType, /*@out@*/ void* pvTmp );
+static int NvPrivImageUpdate( nv_critical_loc_e eImage );
+static int NvPrivCriticalRead( /*@out@*/ nv_critical_t* pParamCrit,
+                               nv_critical_loc_e eType );
+static int NvPrivFlashDetermineOffs( nv_critical_loc_e eType,
+                                     /*@out@*/ loff_t* piOffs );
+static int NvPrivFlashProtectAll( void );
+
+static int NvPrivFindInTable(
+        /*@out@*/ int* piIdx,
+        const char* szWhat, const char** aszTable,
+        size_t iSize );
+
+/* ********** local variables ********** */
+
+#define MK(x) IDX(x) #x
+static const char* l_aszErrors[] = {
+        MK( NVE_GOOD ),
+        MK( NVE_NO_DEV ),
+        MK( NVE_IO ),
+        MK( NVE_CRC ),
+        MK( NVE_MIRROR ),
+        MK( NVE_NO_SPACE ),
+        MK( NVE_NOT_INITIALIZED ),
+        MK( NVE_NOT_IMPLEMENTED ),
+        MK( NVE_VERSION ),
+        MK( NVE_MAGIC ),
+        MK( NVE_MATCH ),
+        MK( NVE_INVALID_ARG ),
+        MK( NVE_WRONG_VALUE ),
+        MK( NVE_NOT_FOUND ),
+};
+#undef MK
+
+/* string tables with more human readable code */
+#define MK(x,y) IDX(x) y
+
+static const char* l_aszCritLoc[] = {
+        MK( NVCL_ORIGINAL, "Original"  ),
+        MK( NVCL_MIRROR,   "Mirror"    ),
+        MK( NVCL_WORKCOPY, "Workcopy"  ),
+};
+
+static const char* l_aszPartTypes[] = {
+        MK( NVPT_UBOOT,      "U-Boot" ),
+        MK( NVPT_NVRAM,      "NVRAM" ),
+        MK( NVPT_FPGA,       "FPGA" ),
+        MK( NVPT_LINUX,      "Linux-Kernel" ),
+        MK( NVPT_EBOOT,      "WinCE-EBoot" ),
+        MK( NVPT_WINCE,      "WinCE-Kernel" ),
+        MK( NVPT_NETOS,      "NET+OS-Kernel" ),
+        MK( NVPT_FILESYSTEM, "Filesystem" ),
+        MK( NVPT_WINCE_REGISTRY, "WinCE-Registry" ),
+        MK( NVPT_UNKNOWN,    "Unknown" ),
+        MK( NVPT_SPLASH_SCREEN,"Splash-Screen" ),
+        MK( NVPT_NETOS_LOADER, "NET+OS-Loader"  ),
+        MK( NVPT_NETOS_NVRAM, "NET+OS-NVRAM"  ),
+};
+
+static const char* l_aszFSTypes[] = {
+        MK( NVFS_NONE,    "None"    ),
+        MK( NVFS_JFFS2,   "JFFS2"   ),
+        MK( NVFS_SQUASHFS,"SQUASHFS"),
+	MK( NVFS_CRAMFS,  "CRAMFS"  ),
+        MK( NVFS_INITRD,  "INITRD"  ),
+	MK( NVFS_ROMFS,   "ROMFS"   ),
+        MK( NVFS_FLASHFX, "FlashFX" ),
+        MK( NVFS_EXFAT,   "ExFAT"   ),
+        MK( NVFS_UNKNOWN, "Unknown" ),
+        MK( NVFS_YAFFS,   "YAFFS"   ),
+};
+
+static const char* l_aszOSTypes[] = {
+        MK( NVOS_NONE,    "None"   ),
+        MK( NVOS_CRITICAL,"Critical" ),
+        MK( NVOS_OS_META, "OS-Meta" ),
+        MK( NVOS_UBOOT,   "U-Boot" ),
+        MK( NVOS_LINUX,   "Linux"  ),
+        MK( NVOS_EBOOT,   "EBoot"  ),
+        MK( NVOS_WINCE,   "WinCE"  ),
+        MK( NVOS_NETOS,   "NET+OS" ),
+        MK( NVOS_UNKNOWN, "Unknown"  ),
+        MK( NVOS_APPL,    "Application"  ),
+        MK( NVOS_USER_DEFINED,  "User defined" ),
+	MK( NVOS_NETOS_LOADER, "NET+OS-Loader"  ),
+        MK( NVOS_WCAL_DATA, "Wireless Calibration"  ),
+};
+#undef MK
+
+static struct {
+        nv_error_e  eType;
+        const char* szFunc;
+        const char* szFile;
+        int         iLine;
+        char        szBuf[ 64 ];
+} l_xError;
+
+char           g_bInitialized = 0;
+nv_info_t      g_xInfo;
+nv_critical_t* g_pWorkcopy = NULL;
+
+/*!\brief stores one erase block */
+static void*       l_pvWorkcopy   = NULL;
+static void*       l_pvFlashInput = NULL;
+static char        l_bOutputEnabled = 1;
+static size_t      l_iEraseSize     = 0;
+static nv_os_meta_t* l_pWorkcopyOSMeta = NULL;
+
+#ifdef WINCE
+# define strnicmp( s1, s2, len ) _strnicmp( s1, s2, len )
+#endif  /* WINCE */
+
+/* ********** global functions ********** */
+
+/*! \brief initializes the NVRAM library */
+/*! \return 0 on failure */
+int NvInit( nv_repair_e eRepair )
+{
+        nv_priv_flash_status_t xStatus;
+        int iRes = 0;
+
+        if( g_bInitialized )
+                NvFinish();
+
+        /* some sanity checks, e.g. string table set up correctly */
+        ASSERT( ARRAY_SIZE( l_aszErrors )    == NVE_LAST  );
+        ASSERT( ARRAY_SIZE( l_aszPartTypes ) == NVPT_LAST );
+        ASSERT( ARRAY_SIZE( l_aszFSTypes )   == NVFS_LAST );
+        ASSERT( ARRAY_SIZE( l_aszOSTypes )   == NVOS_LAST );
+        ASSERT( ARRAY_SIZE( l_aszCritLoc )   == NVCL_LAST );
+
+        /* structure changes should be detected here */
+        ASSERT( sizeof( nv_critical_t )           == 1328 );
+        ASSERT( sizeof( nv_param_module_id_t )    == 64   );
+        ASSERT( sizeof( nv_param_ip_t )           == 104  );
+        ASSERT( sizeof( nv_param_part_table_t )   == 896  );
+        ASSERT( sizeof( nv_param_part_t )         == 88   );
+        ASSERT( sizeof( nv_param_os_cfg_table_t ) == 176  );
+        ASSERT( sizeof( nv_param_os_cfg_t )       == 20  );
+        ASSERT( sizeof( nv_os_meta_t )            == 128  );
+
+        ASSERT( NV_RESERVED_CRITICAL_SIZE > sizeof( nv_critical_t ) );
+
+        /* initialize static variables */
+        CLEAR( l_xError );
+        l_xError.eType = NVE_GOOD;
+
+        CLEAR( g_xInfo );
+
+        CE( NvPrivOSInit() );
+
+        CE( NvPrivOSFlashOpen( 0 ) );
+        iRes  = NvPrivOSFlashInfo( 0, &xStatus );
+        l_iEraseSize = xStatus.iEraseSize;
+        /* protect the whole NVRAM partition for unwanted access */
+        iRes &= NvPrivFlashProtectAll();
+        iRes &= NvPrivOSFlashClose();
+        CE( iRes );
+
+        /* we need a buffer to keep the workcopy page in NVRAM */
+        l_pvWorkcopy = malloc( xStatus.iEraseSize );
+        CE_SET_ERROR_EXT( NULL != l_pvWorkcopy, NVE_NO_SPACE, "malloc" );
+
+        l_pWorkcopyOSMeta = (nv_os_meta_t*) l_pvWorkcopy;
+        g_pWorkcopy       = (nv_critical_t*) ( l_pWorkcopyOSMeta + 1 );
+
+        g_bInitialized = 1;
+
+        if( NVR_IGNORE != eRepair ) {
+                l_pvFlashInput = malloc( xStatus.iEraseSize );
+                CE_SET_ERROR_EXT( NULL != l_pvFlashInput, NVE_NO_SPACE, "malloc (flash input)" );
+                /* now we can read */
+                CE( NvPrivImagesRead() );
+                FREE( l_pvFlashInput );
+
+                if( g_xInfo.bGood && g_xInfo.bAnyBad && ( eRepair == NVR_AUTO ) )
+                        /* only when something is good and something is bad */
+                        if(! NvPrivImageRepair() )
+				eRepair = NVR_IGNORE;
+        } 
+	
+	if( NVR_IGNORE == eRepair ) {
+                /* the current content is ignored and contents not repaired */
+                g_xInfo.bDefault = 1;
+                CE( NvWorkcopyReset() );
+                CE( NvPrintStatus() );
+        }
+
+        CE( NvPrivOSPostInit() );
+
+        return 1;
+
+error:
+        FREE( l_pvFlashInput );
+
+        return 0;
+}
+
+/*! \brief closes the NVRAM library */
+/*! \return 0 on failure */
+int NvFinish( void )
+{
+        int iRes = 0;
+
+        FREE( l_pvWorkcopy );
+
+        iRes = NvPrivOSFinish();
+
+        g_bInitialized = 0;
+
+        return iRes;
+}
+
+/*! \brief enables the output to the console. If disabled, then output is lost
+ */
+/*! \return always 1 */
+int NvEnableOutput( char bEnable )
+{
+        l_bOutputEnabled = bEnable;
+
+        return 1;
+}
+
+nv_error_e NvError( void )
+{
+        return l_xError.eType;
+}
+
+/*! \brief returns the error code as a number and can set a more descriptive
+           strings in pszError */
+/*!
+  \param  pszError will be set to error message if not NULL
+  \return the last error code.
+*/
+
+/*@-mustdefine@*/
+/* there is a bug in splint that doesn't detect that NULL ptr can't be
+   assigned. */
+extern nv_error_e NvErrorMsg(
+        const char** pszError,
+        const char** pszWhat,
+        const char** pszFunc,
+        const char** pszFile,
+        int* piLine )
+{
+        if( NULL != pszError )
+                /* eError is used internally. So we are always within limits */
+                *pszError = l_aszErrors[ l_xError.eType ];
+
+        if( NULL != pszWhat )
+                *pszWhat = l_xError.szBuf;
+
+        if( NULL != pszFunc )
+                *pszFunc = l_xError.szFunc;
+
+        if( NULL != pszFile )
+                *pszFile = l_xError.szFile;
+
+        if( NULL != piLine )
+                *piLine = l_xError.iLine;
+
+        return l_xError.eType;
+}
+/*@+mustdefine@*/
+
+void NvGetVersion( uint32_t* puiVerMajor, uint32_t* puiVerMinor )
+{
+        *puiVerMajor = NVV_MAJOR;
+        *puiVerMinor = NVV_MINOR;
+}
+
+const struct nv_info* NvInfo( void )
+{
+        return ( g_bInitialized ? &g_xInfo : NULL );
+}
+
+/*! \brief Prints the status of the NVRAM. */
+/*! May be used in delayed printing, e.g. in U-Boot, because baudrate in NVRAM
+ *  may differ from default. */
+int NvPrintStatus( void )
+{
+        if( !g_xInfo.bDefault ) {
+                /* the flash contents is available */
+                if( !g_xInfo.bOriginalGood )
+                        NvPrivOSPrintfError( NVRAM "Original Critical is BAD\n" );
+                if( !g_xInfo.bMirrorGood )
+                        NvPrivOSPrintfError( NVRAM "Mirror Critical is BAD\n" );
+                if( !g_xInfo.bFlashOriginalGood )
+                        NvPrivOSPrintfError( NVRAM "Original Flash is BAD\n" );
+                if( !g_xInfo.bFlashMirrorGood )
+                        NvPrivOSPrintfError( NVRAM "Mirror Flash is BAD\n" );
+                if( !g_xInfo.bFlashMirrorMatch )
+                        NvPrivOSPrintfError( NVRAM "Original Flash and Mirror Flash don't match\n" );
+                if( !g_xInfo.bMirrorMatch )
+                        NvPrivOSPrintfError( NVRAM "Original and Mirror don't match\n" );
+                if( !g_xInfo.bFlashMirrorMatch )
+                        NvPrivOSPrintfError( NVRAM "Original and Mirror Flash don't match\n" );
+
+                if( !g_xInfo.bGood )
+                        NvPrivOSPrintfError( NVRAM "No NVRAM contents usable\n" );
+                else if( !g_xInfo.bOriginalGood ) 
+                        NvPrivOSPrintfError( NVRAM "Using Mirror\n" );
+        } else
+                NvPrivOSPrintfError( NVRAM "Using defaults\n" );
+
+        return 1;
+}
+
+/*! Both, mirror and original are written with this algorithm.
+ *  a) No mirror present
+       Write original and verify it.
+    b) original is good or bad and mirror is good
+       At first write original and verify it. If it is OK, do same for mirror
+       If original failed, don't touch mirror.
+    c) original is good and mirror is bad.
+       At first write mirror and verify it. If it is OK, do same for original
+       If mirror failed, don't touch original.
+*/
+int NvSave( void )
+{
+        nv_critical_loc_e eFirstToWrite = NVCL_ORIGINAL;
+
+        REQUIRE_INITIALIZED();
+
+        NvPrivOSPrintf( "Writing Parameters to NVRAM\n" );
+
+        CE( NvWorkcopyUpdateCRC32() );
+
+        if( g_xInfo.bFlashOriginalGood &&
+            !g_xInfo.bFlashMirrorGood )
+                eFirstToWrite = NVCL_MIRROR;
+
+        CE( NvPrivImageUpdate( eFirstToWrite ) );
+        CE( NvPrivImageUpdate( ( ( NVCL_ORIGINAL == eFirstToWrite ) ?
+                                 NVCL_MIRROR : NVCL_ORIGINAL ) ) );
+
+        /* only reached when written correctly */
+        g_xInfo.bGood              = 1;
+        g_xInfo.bAnyBad            = 0;
+        g_xInfo.bFlashOriginalGood = 1;
+        g_xInfo.bFlashMirrorGood   = 1;
+        g_xInfo.bFlashMirrorMatch  = 1;
+        g_xInfo.bOriginalGood      = 1;
+        g_xInfo.bMirrorGood        = 1;
+        g_xInfo.bMirrorMatch       = 1;
+        g_xInfo.bOSGood            = 1;
+        g_xInfo.bOSOriginalGood    = 1;
+        g_xInfo.bDefault           = 0;  /* not any longer */
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/*! Updates the internals checksum */
+/*  It is only used to NvWorkcopyUpdateCRC32 on the outside,
+   when the workcopy in RAM is used instead of interchanged OS,
+   e.g.
+*/
+int NvWorkcopyUpdateCRC32( void )
+{
+        REQUIRE_INITIALIZED();
+
+        /* calculate CRC32 */
+        g_pWorkcopy->uiCRC32 = crc32( 0,
+                                      (const unsigned char*) &g_pWorkcopy->s,
+                                      sizeof( g_pWorkcopy->s ) );
+
+        l_pWorkcopyOSMeta->uiCRC32 = crc32( 0, (const unsigned char*) (&l_pWorkcopyOSMeta->uiCRC32 + 1),
+                                          l_iEraseSize - sizeof( l_pWorkcopyOSMeta->uiCRC32 ) );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvWorkcopyReset( void )
+{
+        REQUIRE_INITIALIZED();
+
+        NvPrivOSPrintfError( NVRAM "Resetting Workcopy\n" );
+
+        /* FLASH is initialized to 0xff */
+        memset( l_pvWorkcopy, 0xff, l_iEraseSize );
+
+        /*  g_pWorkcopy may be part of l_pvWorkcopy if pure NAND,
+            otherwise it is separated */
+        CLEAR( *g_pWorkcopy );
+        strncpy( g_pWorkcopy->s.szMagic,
+                 NV_MAGIC_CRITICAL,
+                 sizeof( g_pWorkcopy->s.szMagic ) );
+
+        g_pWorkcopy->s.uiVerMajor = NVV_MAJOR;
+        g_pWorkcopy->s.uiVerMinor = NVV_MINOR;
+        g_xInfo.bGood = 1;
+
+        /* set defaults */
+        CE( NvToIP( &g_pWorkcopy->s.p.xIP.axDevice[ 0 ].uiIP,
+                    "192.168.42.30" ) );
+        CE( NvToIP( &g_pWorkcopy->s.p.xIP.axDevice[ 0 ].uiNetMask,
+                    "255.255.255.0" ) );
+        CE( NvToIP( &g_pWorkcopy->s.p.xIP.axDevice[ 1 ].uiIP,
+                    "192.168.43.30" ) );
+        CE( NvToIP( &g_pWorkcopy->s.p.xIP.axDevice[ 1 ].uiNetMask,
+                    "255.255.255.0" ) );
+        CE( NvToIP( &g_pWorkcopy->s.p.xIP.uiIPServer,
+                    "192.168.42.1" ) );
+        CE( NvToMAC( &g_pWorkcopy->s.p.xID.axMAC[ 0 ],
+                     "00:04:F3:FF:FF:FA" ) );
+        CE( NvToMAC( &g_pWorkcopy->s.p.xID.axMAC[ 1 ],
+                     "00:04:F3:FF:FF:FB" ) );
+
+        /* it must be immediately after NV_RESERVED_CRITICAL_SIZE */
+        NvOSCfgAdd( NVOS_OS_META, sizeof( nv_os_meta_t ) );
+
+        /* add our own critical parameters here */
+        NvOSCfgAdd( NVOS_CRITICAL, NV_RESERVED_CRITICAL_SIZE );
+
+        CE( NvPrivOSCriticalPartReset( g_pWorkcopy, NVOS_NONE ) );
+
+#ifdef CFG_HAS_WIRELESS
+        NvOSCfgAdd( NVOS_WCAL_DATA, sizeof( wcd_data_t ) );
+#endif
+        /* the image is clean now. But maybe the OS wants to define some
+         * standard values. */
+        CE( NvPrivOSCriticalPostReset( g_pWorkcopy ) );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvCriticalGet(
+        /*@out@*/ struct nv_critical** ppCritical )
+{
+        *ppCritical = g_pWorkcopy;
+
+        return 1;
+}
+
+/*! \brief Locates the iCount'th partition table entry of ePartType.*/
+/*! if ePartType is
+ *  NVPT_FILESYSTEM, also eFSType is used for search.
+ * \param pPart     where to store a copy of the partition table 
+ * \param ePartType partition type to look forth.
+ * \param eFSType   filesystem to look for if NVPT_FILESYSTEM. NVFS_NONE takes
+ *                  any. 
+ * \param bRoot     if 1, filesystem must be rootfs, too. Otherwise, also
+ *                  non-roots are used.
+ * \param iCount    (iCount + 1 )'th occurent
+ * \return 1 if there is a JFFS2 partition in the partition table  */
+
+int NvParamPartFind(
+        const struct nv_param_part** ppPart,
+        nv_part_type_e ePartType,
+        nv_fs_type_e   eFSType,
+        char           bRoot,
+        int            iCount )
+{
+	unsigned int u = 0;	
+        int iFound = 0;
+        const nv_param_part_table_t* pPartTable = &g_pWorkcopy->s.p.xPartTable;
+
+        REQUIRE_INITIALIZED();
+
+	*ppPart = NULL;
+
+        /* search the iCount'th partition entry */
+        while( u < pPartTable->uiEntries ) {
+                const nv_param_part_t* pPartEntry = &pPartTable->axEntries[ u];
+                if( pPartEntry->eType == ePartType ) {
+                        if( ( NVPT_FILESYSTEM != ePartType ) ||
+                            ( ( ( eFSType == pPartEntry->flags.fs.eType ) ||
+                                ( NVFS_NONE == eFSType ) ) &&
+                              ( bRoot == pPartEntry->flags.fs.bRoot ) ) ) {
+                                /* found one occurence */
+                                if( iFound == iCount ) {
+                                        /* it's the n'th occurence we look for */
+                                        *ppPart = pPartEntry;
+                                        return 1;
+                                }
+                                iFound++;
+                        }
+                } /* if( pPartEntry->eType */
+
+                u++;
+        } /* while( u ) */
+
+        NV_SET_ERROR( NVE_NOT_FOUND, NvToStringPart( ePartType ) );
+
+error:
+        return 0;
+}
+
+int NvCriticalPartAdd( const struct nv_param_part* pNewPart )
+{
+        nv_param_part_table_t* pPartTable = &g_pWorkcopy->s.p.xPartTable;
+        nv_param_part_t* pPart;
+
+        REQUIRE_INITIALIZED();
+
+        CE_SET_ERROR( pPartTable->uiEntries < ARRAY_SIZE( pPartTable->axEntries ),
+                      NVE_NO_SPACE );
+
+        pPart = &pPartTable->axEntries[ pPartTable->uiEntries ];
+
+        /* add it */
+        if( NULL == pNewPart ) {
+                pPart->eType    = NVPT_UNKNOWN;
+                CLEAR( *pPart );
+        } else
+                *pPart = *pNewPart;
+
+        pPartTable->uiEntries++;
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvCriticalPartDelete( uint32_t uiPartition )
+{
+        nv_param_part_table_t* pPartTable = &g_pWorkcopy->s.p.xPartTable;
+
+        REQUIRE_INITIALIZED();
+
+        /* move partitions down */
+        memcpy( &pPartTable->axEntries[ uiPartition ],
+                &pPartTable->axEntries[ uiPartition + 1 ],
+                (sizeof(pPartTable->axEntries[ 0 ] ) * ( ARRAY_SIZE( pPartTable->axEntries ) - uiPartition - 1 ) ) );
+        /* reset last partition */
+        CLEAR( pPartTable->axEntries[ ARRAY_SIZE( pPartTable->axEntries ) - 1 ] );
+        pPartTable->uiEntries--;
+
+        /* !TODO. Maybe we should move ullStart of all immediately following
+         * partitions */
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvCriticalPartReset( nv_os_type_e eForOS )
+{
+        REQUIRE_INITIALIZED();
+
+        g_pWorkcopy->s.p.xPartTable.uiEntries = 0;
+
+        return NvPrivOSCriticalPartReset( g_pWorkcopy, eForOS );
+
+error:
+        return 0;
+}
+
+int NvOSCfgAdd( nv_os_type_e eType, size_t iSize )
+{
+        nv_param_os_cfg_t xCfg;
+        nv_param_os_cfg_table_t* pOSTable = &g_pWorkcopy->s.p.xOSTable;
+        nv_param_os_cfg_t* pCfg;
+        uint32_t uiStart = 0;
+        unsigned int u = 0;
+
+        REQUIRE_INITIALIZED();
+
+        /* check the sizes and the start addr */
+        if( NvOSCfgFind( &xCfg, eType ) ) {
+                /* partition already exists */
+                if( iSize != xCfg.uiSize ) {
+                        char szBuf[ 64 ];
+                        sprintf( szBuf,
+                                 "Can't set OS Configuration to %i bytes, it already exists with %i bytes\n",
+                                 (int) iSize, xCfg.uiSize );
+                        NV_SET_ERROR( NVE_NO_SPACE, szBuf );
+                        goto error;
+                }
+        }
+
+        CE_SET_ERROR( pOSTable->uiEntries < ARRAY_SIZE( pOSTable->axEntries ),
+                      NVE_NO_SPACE );
+
+        pCfg = &pOSTable->axEntries[ pOSTable->uiEntries ];
+
+        /* determine start addr */
+
+        /* append it after other configurations. */
+        /* !TODO. Detect overlapps */
+        for( u = 0; u < pOSTable->uiEntries; u++ )
+                uiStart += pOSTable->axEntries[ u ].uiSize;
+
+        CE_SET_ERROR_EXT( ( ( uiStart + iSize ) < l_iEraseSize ),
+                          NVE_NO_SPACE,
+                          "OS config beyond erase block" );
+
+        /* add it */
+        CLEAR( *pCfg );
+        pCfg->eType   = eType;
+        pCfg->uiStart = uiStart;
+        pCfg->uiSize  = iSize;
+        pOSTable->uiEntries++;
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvOSCfgGet( nv_os_type_e eType, void* pvBuf, size_t iMaxSize,
+                size_t* piSize )
+{
+        nv_param_os_cfg_t xCfg;
+
+        REQUIRE_INITIALIZED();
+
+        CE( NvOSCfgFind( &xCfg, eType ) );
+        CE_SET_ERROR( ( xCfg.uiSize <= iMaxSize ), NVE_NO_SPACE );
+        *piSize = xCfg.uiSize;
+
+        memcpy32( pvBuf, (char*) l_pvWorkcopy + xCfg.uiStart, xCfg.uiSize );
+        *piSize = xCfg.uiSize;
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvOSCfgSet( nv_os_type_e eType, const void*  pvBuf,  size_t iSize )
+{
+        nv_param_os_cfg_t xCfg;
+
+        REQUIRE_INITIALIZED();
+
+        CE( NvOSCfgFind( &xCfg, eType ) );
+        CE_SET_ERROR( ( xCfg.uiSize >= iSize ), NVE_NO_SPACE );
+
+        memcpy32( (char*) l_pvWorkcopy + xCfg.uiStart, pvBuf, iSize );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvOSCfgFind( /*@out@*/ struct nv_param_os_cfg* pCfg, nv_os_type_e eType )
+{
+        unsigned int u = 0;
+        const nv_param_os_cfg_table_t* pOSTable = &g_pWorkcopy->s.p.xOSTable;
+
+        REQUIRE_INITIALIZED();
+
+        CLEAR( *pCfg );
+
+        /* search the iCount'th partition entry */
+        while( u < pOSTable->uiEntries ) {
+                const nv_param_os_cfg_t* pOSEntry = &pOSTable->axEntries[ u ];
+                if( pOSEntry->eType == eType ) {
+                        /* it's the n'th occurence we look for */
+                        *pCfg = *pOSEntry;
+                        return 1;
+                } /* if( pOSEntry */
+
+                u++;
+        } /* while( u ) */
+
+        NV_SET_ERROR( NVE_NOT_FOUND, NvToStringOS( eType ) );
+
+error:
+        return 0;
+}
+
+
+/* ********** private functions ********** */
+
+/*! \brief set's the error code */
+/*!
+  \param  eError the error code
+  \return always 0 so it can be used like return NvPrivSetError()
+*/
+int NvPrivSetError( nv_error_e eError, const char* szWhat,
+                    const char* szFunc,
+                    const char* szFile, int iLine )
+{
+        l_xError.eType  = eError;
+        l_xError.szFunc = szFunc;
+        l_xError.szFile = szFile;
+        strncpy( l_xError.szBuf, szWhat, sizeof( l_xError.szBuf ) );
+        l_xError.iLine  = iLine;
+
+        return 0;
+}
+
+/*! \brief returns whether output is enabled */
+/*!
+  \return on true, NvPrivOSPrintf shouldn't output anything.
+*/
+char NvPrivIsOutputEnabled( void )
+{
+        return l_bOutputEnabled;
+}
+
+const char* NvToStringMAC( const nv_mac_t xMAC )
+{
+        static char acBuffer[ 20 ];
+
+        sprintf( acBuffer, "%02X:%02X:%02X:%02X:%02X:%02X",
+                 xMAC.u.c[ 0 ],
+                 xMAC.u.c[ 1 ],
+                 xMAC.u.c[ 2 ],
+                 xMAC.u.c[ 3 ],
+                 xMAC.u.c[ 4 ],
+                 xMAC.u.c[ 5 ] );
+
+        return acBuffer;
+}
+
+int NvToMAC( nv_mac_t* pMAC, const char* szMAC )
+{
+        uint32_t auiMAC[ 6 ];
+        int i;
+	int format_ok = 0, consumed_chars = 0;
+
+	/*
+	 * While on U-Boot the format of the MAC address is correctly detected,
+	 * in Linux it is not. The reason is the different behaviour of the
+	 * implementation of sscanf. For exactly the same string with a
+	 * correct MAC (szMAC) the last parameter (consumed_chars) is 0 in
+	 * U-Boot but is the string length in Linux. So this workaround to
+	 * overcome the problem.
+	 */
+#ifdef LINUX
+	format_ok = strlen(szMAC);
+#endif
+
+	/* %n is not reached, if the format is correct */
+	if( sscanf( szMAC, "%02X:%02X:%02X:%02X:%02X:%02X%n",
+	    &auiMAC[ 0 ], &auiMAC[ 1 ], &auiMAC[ 2 ], &auiMAC[ 3 ],
+	    &auiMAC[ 4 ], &auiMAC[ 5 ], &consumed_chars) != 6 ||
+	    consumed_chars != format_ok)
+		return NV_SET_ERROR( NVE_WRONG_VALUE, szMAC );
+
+        for( i = 0; i < 6; i++ ) {
+                if( auiMAC[ i ] > 255 )
+                        return NV_SET_ERROR( NVE_WRONG_VALUE, szMAC );
+                else
+                        pMAC->u.c[ i ] = auiMAC[ i ];
+        }
+
+        return 1;
+}
+
+const char* NvToStringIP( nv_ip_t uiIP )
+{
+        static char acBuffer[ 20 ];
+
+        sprintf( acBuffer, "%u.%u.%u.%u",
+                 (uiIP) & 0xff,
+                 (uiIP >> 8)  & 0xff,
+                 (uiIP >> 16) & 0xff,
+                 (uiIP >> 24) & 0xff );
+
+        return acBuffer;
+}
+
+int NvToIP( nv_ip_t* pIP, const char* szIP )
+{
+        uint32_t auiIP[ 4 ];
+        int i;
+
+        if( sscanf( szIP, "%u.%u.%u.%u",
+                    &auiIP[ 0 ],
+                    &auiIP[ 1 ],
+                    &auiIP[ 2 ],
+                    &auiIP[ 3 ] ) != 4 )
+                return NV_SET_ERROR( NVE_WRONG_VALUE, szIP );
+
+        for( i = 0; i < 4; i++ )
+                if( auiIP[ i ] > 255 )
+                        return NV_SET_ERROR( NVE_WRONG_VALUE, szIP );
+
+        *pIP = ( auiIP[ 0 ] |
+                 ( auiIP[ 1 ] << 8 ) |
+                 ( auiIP[ 2 ] << 16 ) |
+                 ( auiIP[ 3 ] << 24 ) );
+
+        return 1;
+}
+
+const char* NvToStringPart( nv_part_type_e ePartType )
+{
+        /* can be out-of-range when reading from NVRAM */
+        return ( ePartType < ARRAY_SIZE( l_aszPartTypes ) ) ?
+                l_aszPartTypes[ ePartType ] : 
+                "Out-Of-Range Partition Type";
+}
+
+int NvToPart( nv_part_type_e* pePart, const char* szPart )
+{
+        return NvPrivFindInTable( (int*) pePart, szPart, l_aszPartTypes,
+                                  ARRAY_SIZE( l_aszPartTypes ) );
+}
+
+const char* NvToStringFS( nv_fs_type_e eFS )
+{
+        /* can be out-of-range when reading from NVRAM */
+        return ( eFS < ARRAY_SIZE( l_aszFSTypes ) ) ?
+                l_aszFSTypes[ eFS ] : 
+                "Out-Of-Range FS Type";
+}
+
+int NvToFS( nv_fs_type_e* peFS, const char* szFS )
+{
+        return NvPrivFindInTable( (int*) peFS, szFS, l_aszFSTypes,
+                                  ARRAY_SIZE( l_aszFSTypes ) );
+}
+
+const char* NvToStringOS( nv_os_type_e eOS )
+{
+        /* can be out-of-range when reading from NVRAM */
+        return ( eOS < ARRAY_SIZE( l_aszOSTypes ) ) ?
+                l_aszOSTypes[ eOS ] : 
+                "Out-Of-Range OS Type";
+}
+
+int NvToOS( nv_os_type_e* peOS, const char* szOS )
+{
+        return NvPrivFindInTable( (int*) peOS, szOS, l_aszOSTypes,
+                                  ARRAY_SIZE( l_aszOSTypes ) );
+}
+
+const char* NvToStringLoc( nv_critical_loc_e eLoc )
+{
+        /* can be out-of-range when reading from NVRAM */
+        return ( eLoc < ARRAY_SIZE( l_aszCritLoc ) ) ?
+                l_aszCritLoc[ eLoc ] : 
+                "Out-Of-Range Loc Type";
+}
+
+const char* NvToStringSize64( const uint64_t ullVal )
+{
+        static char szBuffer[ 20 ];
+
+        if( ullVal && !(ullVal & 0xfffff ) )
+                sprintf( szBuffer, "%i MiB", (int) ( ullVal >> 20 ) );
+        else if( ullVal && !(ullVal & 0x3ff) )
+                sprintf( szBuffer, "%i KiB", (int) ( ullVal >> 10 ) );
+        else if( !ullVal )
+                /* no hex prefix */
+                sprintf( szBuffer, "0" );
+        else
+                sprintf( szBuffer, "0x%09" PRINTF_QUAD "x", ullVal );
+
+        return szBuffer;
+}
+
+/*! \brief retreives a 64bit Value */
+/*!
+  \param  pullVal the resulting number
+  \param  szVal   can be hex number, number in MiB, Number K[iB], Number M[iB]
+  \return 0 on failure
+*/
+int NvToSize64( /*@out@*/ uint64_t* pullVal, const char* szVal )
+{
+        int iRes = 1;
+
+        /* when 0x is present, use the number */
+        if( sscanf( szVal, "0x%Lx", pullVal ) != 1 ) {
+                unsigned int uVal = 0;
+                char         szBuffer[ 20 ];
+                int          iNum = sscanf( szVal, "%u%19s", &uVal, szBuffer );
+
+                if( 1 <= iNum ) {
+                        const char* szUnit = szBuffer;
+                        int         iFac   = 1;
+
+                        /* skip spaces characters */
+                        while( ' ' == *szUnit )
+                                szUnit++;
+
+                        if( ( 1 == iNum ) ||
+                            !strnicmp( "MiB", szUnit, 3 ) ||
+                            !strnicmp( "M",   szUnit, 1 ) )
+                                /* decimal number without unit means MiB */
+                                iFac = 1024*1024;
+                        else if( !strnicmp( "KiB", szUnit, 3 ) ||
+                                 !strnicmp( "K",   szUnit, 1 ) )
+                                iFac = 1024;
+                        else
+                                iRes = 0;
+
+                        if( iRes )
+                                *pullVal = uVal * iFac;
+                } else
+                        iRes = 0;
+        } /* if( sscanf() */
+
+        return iRes;
+}
+
+/* ********** local functions ********** */
+
+static int NvPrivImageUpdate( nv_critical_loc_e eImage )
+{
+        void* pvTmp = NULL;
+
+        pvTmp = malloc( l_iEraseSize );
+        CE_SET_ERROR_EXT( NULL != pvTmp, NVE_NO_SPACE, "malloc" );
+
+        CE( NvPrivImageWrite( eImage ) );
+        /* read back */
+        CE( NvPrivImageRead( eImage, pvTmp ) );
+        CE_SET_ERROR_EXT( !memcmp( l_pvWorkcopy, pvTmp, l_iEraseSize ),
+                          NVE_MATCH, NvToStringLoc( eImage ) );
+
+        FREE( pvTmp );
+        return 1;
+
+error:
+        FREE( pvTmp );
+        return 0;
+}
+
+static int NvPrivImagesRead( void )
+{
+        int iRes = 0;
+        nv_critical_loc_e eLoc = NVCL_ORIGINAL;
+        nv_critical_t axCritical[ 2 ];
+
+        REQUIRE_INITIALIZED();
+
+        /* initialize both parameters with different values to detect any
+         * read errors */
+        memset( &axCritical[ NVCL_ORIGINAL ], 0,
+                sizeof( axCritical[ NVCL_ORIGINAL ] ) );
+        memset( &axCritical[ NVCL_MIRROR ], 1,
+                sizeof( axCritical[ NVCL_MIRROR ] ) );
+
+        /* process original image */
+        iRes = NvPrivImageRead( NVCL_ORIGINAL, l_pvFlashInput );
+        g_xInfo.bFlashOriginalGood = iRes;
+        if( iRes )
+                /* everything ok, copy it */
+                memcpy32( l_pvWorkcopy, l_pvFlashInput, l_iEraseSize );
+
+
+        if( iRes )
+                iRes = NvPrivCriticalRead( &axCritical[ NVCL_ORIGINAL ],
+                                           NVCL_ORIGINAL );
+        g_xInfo.bOriginalGood   = iRes;
+
+        /* process mirror image */
+        iRes = NvPrivImageRead( NVCL_MIRROR, l_pvFlashInput );
+        g_xInfo.bFlashMirrorGood = iRes;
+        if( iRes && !g_xInfo.bFlashOriginalGood )
+                /* everything ok and we don't have a workcopy yet */
+                memcpy32( l_pvWorkcopy, l_pvFlashInput, l_iEraseSize );
+
+        if( iRes )
+                iRes = NvPrivCriticalRead( &axCritical[ NVCL_MIRROR ],
+                                           NVCL_MIRROR );
+
+        g_xInfo.bMirrorGood   = iRes;
+        g_xInfo.bFlashMirrorMatch = 0;
+        if( g_xInfo.bFlashMirrorGood && g_xInfo.bFlashOriginalGood )
+                g_xInfo.bFlashMirrorMatch = !memcmp(
+                        l_pvWorkcopy,
+                        l_pvFlashInput,
+                        l_iEraseSize );
+
+        g_xInfo.bMirrorMatch = 0;
+        if( g_xInfo.bMirrorGood && g_xInfo.bOriginalGood )
+                g_xInfo.bMirrorMatch = !memcmp(
+                        &axCritical[ NVCL_ORIGINAL ],
+                        &axCritical[ NVCL_MIRROR ],
+                        sizeof( axCritical[ 0 ] ) );
+
+        g_xInfo.bGood   = (  g_xInfo.bFlashOriginalGood ||  g_xInfo.bFlashMirrorGood );
+        g_xInfo.bAnyBad = ( !g_xInfo.bFlashOriginalGood || !g_xInfo.bFlashMirrorGood );
+
+        if( g_xInfo.bGood && !g_xInfo.bOriginalGood )
+                eLoc = NVCL_MIRROR;
+
+        CE( NvPrintStatus() );
+
+        if( !g_xInfo.bGood ) {
+                /* no data available, clear everything */
+                NvWorkcopyReset();
+        } else {
+                /* use existing and checked image */
+                *g_pWorkcopy = axCritical[ eLoc ];
+
+                /* increase minor number because reserved entries may change */
+                if( g_pWorkcopy->s.uiVerMinor <= NVV_MINOR )
+                        /* <= to get rid of a compiler warning */
+                        g_pWorkcopy->s.uiVerMinor = NVV_MINOR;
+
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/*! \brief Reads the original or the mirror image. */
+/*! The image is checked whether the CRC is ok, the magic matches and the
+    version is supported.
+  \param  eType the image to read
+  \return 0 on failure otherwise 1
+*/
+static int NvPrivCriticalRead(
+        nv_critical_t* pParamCrit,
+        nv_critical_loc_e eType )
+{
+        crc32_t uiCRC32;
+
+        REQUIRE_INITIALIZED();
+
+        CLEAR( *pParamCrit );
+
+        /* take it from our flash copy */
+        memcpy32( pParamCrit, (char*) l_pvFlashInput + sizeof( nv_os_meta_t ),
+                  sizeof( *pParamCrit ) );
+
+        /* verify checksum */
+        uiCRC32 = crc32( 0,
+                         (const unsigned char*) &pParamCrit->s,
+                         sizeof( pParamCrit->s ) );
+        if( uiCRC32 == pParamCrit->uiCRC32 ) {
+                /* check magic */
+                if( !strncmp( pParamCrit->s.szMagic,
+                              NV_MAGIC_CRITICAL,
+                              sizeof( pParamCrit->s.szMagic ) ) ) {
+
+                        /* check version */
+                        if( NVV_MAJOR != pParamCrit->s.uiVerMajor ) {
+                                NV_SET_ERROR( NVE_VERSION, "" );
+                                goto error;
+                        }
+                } else {
+                        NV_SET_ERROR( NVE_MAGIC, pParamCrit->s.szMagic );
+                        goto error;
+                }
+        } else {
+                NV_SET_ERROR( NVE_CRC, "" );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int NvPrivImageWrite( nv_critical_loc_e eType )
+{
+        loff_t iOffs = 0;
+        int    iRes  = 0;
+
+        REQUIRE_INITIALIZED();
+
+        CE( NvPrivOSFlashOpen( 1 ) );
+        if( NvPrivFlashDetermineOffs( eType, &iOffs ) &&
+            NvPrivOSFlashProtect( iOffs, l_iEraseSize, 0 ) ) {
+                iRes = NvPrivOSFlashErase( iOffs );
+                if( iRes )
+                        iRes = NvPrivOSFlashWrite( l_pvWorkcopy, iOffs, l_iEraseSize );
+                iRes &= NvPrivOSFlashProtect( iOffs, l_iEraseSize, 1 );
+        }
+
+        iRes &= NvPrivOSFlashClose();
+        CE( iRes );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int NvPrivImageRead( nv_critical_loc_e eType, /*@out@*/ void* pvImage )
+{
+        crc32_t uiCRC32;
+        loff_t  iOffsBase = 0;
+        int     iRes = 0;
+
+        REQUIRE_INITIALIZED();
+
+        CE( NvPrivOSFlashOpen( 0 ) );
+        iRes = NvPrivFlashDetermineOffs( eType, &iOffsBase );
+        if( iRes )
+                iRes = NvPrivOSFlashRead( pvImage, iOffsBase, l_iEraseSize );
+        iRes &= NvPrivOSFlashClose();
+        CE( iRes );
+		uiCRC32 = crc32( 0, sizeof( crc32_t ) + (uchar_t*) pvImage,
+                                 l_iEraseSize - sizeof( crc32_t ) );
+        CE_SET_ERROR( uiCRC32 == *(const crc32_t*) pvImage, NVE_CRC );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/*! \brief Determines the offset for an image of eType in the NVRAM partition. */
+/*!
+  \param  eType the image to determine the offset in the
+  \param  piOffs the offset will be stored here when no error happens.
+          Otherwise it is undefined
+  \return 0 on failure otherwise 1
+*/
+static int NvPrivFlashDetermineOffs( nv_critical_loc_e eType, loff_t* piOffs )
+{
+        nv_priv_flash_status_t xStatus;
+        int  iGood  = 0;
+
+        ASSERT( ( eType == NVCL_ORIGINAL ) || ( eType == NVCL_MIRROR ) );
+
+        *piOffs = 0;
+
+        /* The parameters stored on the first good block. The mirrors is
+         * stored on the next good block */
+        do {
+                /* NvPrivOSFlashInfo will return 0 if out of range */
+                if( !NvPrivOSFlashInfo( *piOffs, &xStatus ) )
+                        /* error is set */
+                        return 0;
+
+                /* check whether our algorithm can work, the critical
+                 * parameters can fit into one erase size */
+                if( xStatus.iEraseSize < sizeof( nv_critical_t ) )
+                        return NV_SET_ERROR( NVE_IO, "NvFlashDetermineOffs: erase size too small" );
+
+                if( !xStatus.bBad )
+                        iGood++;
+
+                if( ( ( 1 == iGood ) && ( NVCL_ORIGINAL ) == eType ) ||
+                    ( ( 2 == iGood ) && ( NVCL_MIRROR ) == eType ) )
+                        return 1;
+
+                *piOffs += xStatus.iEraseSize;
+        } while( 1 );
+
+        /* algorithm will always terminate because the flash partition is not
+         * endless */ 
+        return NV_SET_ERROR( NVE_NO_SPACE, "" );
+}
+
+int NvPrivFlashProtectAll( void )
+{
+        loff_t iOffs = 0;
+        int    iCount = 0;
+
+        /* flash every block of NVRAM partition. Depending on the type of
+         * FLASH, there can be only 2 blocks (NOR) or more than 2 blocks for
+         * NAND bad block management */
+        while( 1 ) {
+                /* for every block */
+                nv_priv_flash_status_t xStatus;
+                
+		int iRes = NvPrivOSFlashInfo(iOffs, &xStatus);
+		if (xStatus.type == MTD_NORFLASH)
+			break;
+		if( !iRes ) {
+                        if( iCount < 2 )
+                                /* we need at least two pages for NVRAM */
+                                CE( !iOffs );
+                        else
+                                /* no more blocks for NVRAM, this is ok */
+                                break;
+                } /* if( NvPrivOSFlashInfo */
+
+                CE( NvPrivOSFlashProtect( iOffs, l_iEraseSize, 1 ) );
+
+                iOffs += l_iEraseSize;
+                iCount++;
+        } /* while( 1 ) */
+
+        return 1;
+
+error:
+        printf( "error %i\n", iCount );
+        return 0;
+}
+
+int NvPrivAnyFlashImageGood(void)
+{
+	return (g_xInfo.bFlashMirrorGood || g_xInfo.bFlashOriginalGood);
+}
+
+int NvPrivImageRepair( void )
+{
+        REQUIRE_INITIALIZED();
+
+        if(  !g_xInfo.bFlashMirrorGood || !g_xInfo.bFlashOriginalGood ) {
+                nv_critical_loc_e eToWrite = ( g_xInfo.bFlashOriginalGood ? NVCL_MIRROR : NVCL_ORIGINAL );
+
+                NvPrivOSPrintf( NVRAM "Repairing %s\n",
+                                l_aszCritLoc[ eToWrite ] );
+                /* at least one is good */
+                CE( NvPrivImageUpdate( eToWrite ) );
+        }
+
+        return 1;
+error:
+        return 0;
+}
+
+static int NvPrivFindInTable(
+        /*@out@*/ int* piIdx,
+        const char* szWhat, const char** aszTable,
+        size_t iSize )
+{
+        int iRes = 1;
+	size_t i = 0;
+        char bFound = 0;
+
+        while( i < iSize ) {
+                if( !strcmp( szWhat, aszTable[ i ] ) ) {
+                        bFound = 1;
+                        break;
+                }
+
+                i++;
+        }
+
+        *piIdx = i;
+        if( !bFound )
+                iRes = NV_SET_ERROR( NVE_WRONG_VALUE, szWhat );
+
+        return iRes;
+}
+
+
+#ifdef CFG_HAS_WIRELESS
+
+#include <mtd.h>
+#define MAX_SECTORS_TO_CHECK_4_WCD	10
+int NvPrivWirelessCalDataCheck( wcd_data_t *pWCal )
+{
+	nv_wcd_header_t *pH = &pWCal->header;
+        crc32_t uiCRC32;
+  
+        /* Start with the sanity checks */
+        if( !strncmp( pH->magic_string, WCD_MAGIC, sizeof( pH->magic_string ) ) ) {
+                /* check version */
+                if( ( (pH->ver_major >= '1') && (pH->ver_major <= '9') ) &&
+                    ( (pH->ver_minor >= '0') && (pH->ver_minor <= '9') ) ) {
+                        uiCRC32 = crc32( 0, 
+                                        (const unsigned char*) pWCal->cal_curves_bg,
+                                        pH->wcd_len );
+                        if( uiCRC32 == pH->wcd_crc )
+                                return 1;                        
+                }
+        }
+        return 0;
+}
+
+/*! \brief Sets the Wireless Calibration inside the nvram structure */
+/*! \return 0 on failure */
+int NvPrivWCDSetInNvram( wcd_data_t *pWCal )
+{
+        /* Check if valid and then set in nvram */
+        if ( NvPrivWirelessCalDataCheck( pWCal ) ) {
+                return NvOSCfgSet( NVOS_WCAL_DATA, pWCal, sizeof( wcd_data_t ) );
+        }
+        return 0;
+}
+
+/*! \brief Gets the Wireless Calibration from the last Sectors of the Flash */
+/*! \return 0 on failure */
+int NvPrivWCDGetFromFlashAndSetInNvram( void )
+{
+	wcd_data_t *pWCal;
+	nv_priv_flash_status_t xStatus;
+	size_t l_iFlashSize = 0;
+	int iRes, j;
+
+	/* Calibration data is stored at the end of the flash */
+	if( NvPrivOSFlashInfo( 0, &xStatus ) == 0 )
+		return 0;
+
+	pWCal = malloc( xStatus.iEraseSize );
+	if( pWCal == NULL )
+		return 0;
+
+	l_iFlashSize = MtdSize( 0 );
+
+	for ( j = 1; j < MAX_SECTORS_TO_CHECK_4_WCD; j++ ) {
+		if( MtdBlockIsBad( 0, l_iFlashSize - (xStatus.iEraseSize * j) ) )
+			continue;	/* Skip bad blocks */
+
+		iRes = MtdRead( 0, l_iFlashSize - (xStatus.iEraseSize * j),
+				xStatus.iEraseSize, pWCal );
+		if ( iRes ) {
+			if ( NvPrivWCDSetInNvram( pWCal ) ) {
+				FREE( pWCal );
+				return 1;
+			}
+		}
+	}
+
+	FREE( pWCal );
+	return 0;
+}
+
+/*! \brief Writes the Wireless Calibration data into the last sectors
+           of the flash, 2 times */
+/*! \return 0 on failure */
+int NvPrivWCDSaveInFlash( wcd_data_t *pWCal )
+{
+	nv_priv_flash_status_t xStatus;
+	size_t l_iFlashSize = 0;
+	int iRes, j, i = 0;
+
+	if ( (pWCal != NULL) && NvPrivWirelessCalDataCheck( pWCal ) ) {
+		if( NvPrivOSFlashInfo( 0, &xStatus ) == 0 )
+			return 0;
+
+		l_iFlashSize = MtdSize( 0 );
+
+		for ( j = 1; j < MAX_SECTORS_TO_CHECK_4_WCD; j++ ) {
+			if( MtdBlockIsBad( 0, l_iFlashSize - (xStatus.iEraseSize * j) ) )
+				continue;	/* Skip bad blocks */
+
+			if( !MtdErase( 0, l_iFlashSize - (xStatus.iEraseSize * j),
+			    xStatus.iEraseSize ) ) {
+				char szErr[ 64 ];
+		      		sprintf( szErr, "Flash Erase @ 0x%08qx, length = %i",
+				         l_iFlashSize - (xStatus.iEraseSize * j),
+					 xStatus.iEraseSize );
+				goto error;
+			}
+
+			iRes = MtdWrite( 0, l_iFlashSize - (xStatus.iEraseSize * j),
+					 xStatus.iEraseSize, pWCal );
+			if ( iRes ) {
+				/* The data is written in 2 different sectors */
+				i++;
+				if ( i >= 2 )
+					break;
+			}
+		}
+	}
+error:
+	return (i >= 2);
+}
+#endif
diff --git a/common/digi/cmd_nvram/lib/src/nvram_cmdline.c b/common/digi/cmd_nvram/lib/src/nvram_cmdline.c
new file mode 100644
index 0000000..e89c921
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/src/nvram_cmdline.c
@@ -0,0 +1,955 @@
+/*
+ *  nvram/lib/src/nvram_cmdline.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$: 
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides the NvCmdLine function and helper
+ */
+
+#include "nvram.h"
+#include "nvram_priv.h"
+#include "nvram_version.h"
+
+#define FOR_MODULE    .eMode = NVPM_MODULE
+#define FOR_IP        .eMode = NVPM_IP
+#define FOR_PARTITION .eMode = NVPM_PARTITION
+#define FOR_OS        .eMode = NVPM_OS
+
+#define NEEDS_VAL \
+        .bNeedsVal = 1
+
+#define OFFS(x) \
+        (((char*) &(((nv_critical_t*) NULL)->x)) - \
+         ((char*) NULL))
+
+#define OFFS_NONE \
+        .iOffs = 0                             \
+        
+#define OFFS_HARDCODED \
+        .bHardcoded = 1, \
+        NEEDS_VAL,   \
+        OFFS_NONE
+
+#define OFFS_MODULE( x )   \
+        FOR_MODULE, \
+        NEEDS_VAL,                                          \
+       .iOffs = OFFS( s.p.xID.x )
+
+#define OFFS_IP( x )   \
+        FOR_IP, \
+        NEEDS_VAL,                                          \
+       .iOffs = OFFS( s.p.xIP.x )
+
+#define OFFS_PART( x )   \
+        FOR_PARTITION,                                                \
+        NEEDS_VAL,                                          \
+       .iOffs = ( (char*) &((nv_critical_t*) NULL)->s.p.xPartTable.axEntries[ 0 ].x - \
+                   (char* )&((nv_critical_t*) NULL)->s.p.xPartTable.axEntries[ 0 ] )
+#define OFFS_OS( x )   \
+        FOR_OS, \
+        NEEDS_VAL,                                          \
+       .iOffs = ( (char*) &((nv_critical_t*) NULL)->s.p.xOSTable.axEntries[ 0 ].x - \
+                   (char* )&((nv_critical_t*) NULL)->s.p.xOSTable.axEntries[ 0 ] )
+
+#define ALLOW_CHANGE_WHEN_FIXED \
+        .bAllowChangeWhenFixed = 1
+
+#define COPY_TO_SET( x, szStr )                 \
+        ({                                      \
+                int _iRes = 1; \
+                if( strlen( szStr ) < sizeof( g_pWorkcopy->s.p.x ) ) { \
+                        CLEAR( *g_pWorkcopy->s.p.x );             \
+                        strncpy( g_pWorkcopy->s.p.x,             \
+                                 szStr,                                 \
+                                 sizeof( g_pWorkcopy->s.p.x ) ); \
+                } else \
+                        _iRes = NV_SET_ERROR( NVE_WRONG_VALUE, szStr ); \
+                (_iRes);                                                \
+        })                                                              \
+
+#define PRINT_RESERVED( szLabel, auiReserved )                \
+        do { \
+                int _i;                         \
+                const char* _pucRes = (const char*) auiReserved; \
+                NvPrivOSPrintf( "%s", szLabel ); \
+                for( _i = 0; _i < sizeof( auiReserved ); _i++ ) \
+                        NvPrivOSPrintf( "%s%02x ", _i ? " " : "", \
+                                _pucRes[ _i ] );      \
+                NvPrivOSPrintf( "\n" ); \
+        } while( 0 )
+
+
+/* ********** local typedefs ********** */
+
+typedef enum {
+        NVPM_ANY,
+        NVPM_MODULE,
+        NVPM_IP,
+        NVPM_PARTITION,
+        NVPM_OS,
+} nv_param_mode_e;
+    
+typedef enum {
+        NVAT_ACTION_MODE_SEL,
+        NVAT_ACTION_ADD,
+        NVAT_ACTION_SEL,
+        NVAT_ACTION_DEL,
+        NVAT_BOOL,
+        NVAT_UINT32,
+        NVAT_UINT64,
+        NVAT_IP,
+        NVAT_MAC,
+        NVAT_PRODUCT_TYPE,
+        NVAT_SERIAL_NR,
+        NVAT_PART_NAME,
+        NVAT_OS_TYPE,
+        NVAT_PART_TYPE,
+        NVAT_FS_TYPE,
+#ifdef CFG_HAS_WIRELESS
+        NVAT_WCD_LOAD,
+#endif
+} nv_param_type_e;
+
+typedef struct nv_param {
+        const char*     szName;
+        nv_param_type_e eType;
+        void*           pvAddr;
+        int             iOffs;
+        nv_param_mode_e eMode;
+        char            bHardcoded;
+        char            bNeedsVal;
+        char            bAllowChangeWhenFixed;
+} nv_param_t;
+
+/* ********** local function declarations ********** */
+
+static int NvPrivCriticalPrintContents( char bReserved );
+static int NvPrivCriticalPrintContentsFromArgV(
+        int argc,
+        const char* argv[] );
+static int NvPrivPrintCritical(
+        nv_critical_loc_e eType,
+        char bPrintReserved );
+static int NvPrivFindParam(
+        /*@out@*/ const nv_param_t** ppParam,
+        const char* szArg,
+        /*@out@*/ /*@null@*/ const char** pszValue,
+        const nv_param_mode_e eMode,
+        char bForSet );
+static int NvPrivCriticalSetFromArgV( int argc, const char* argv[] );
+static void NvPrivPrintParamModule(
+        /*@in@*/ const struct nv_param_module_id* pModule,
+        char bPrintReserved );
+static void NvPrivPrintParamIP(
+        /*@in@*/ const struct nv_param_ip* pIP,
+        char bPrintReserved );
+static void NvPrivPrintParamPartitionTable(
+        /*@in@*/ const struct nv_param_part_table* pPartTable,
+        char bPrintReserved );
+static void NvPrivPrintParamOSTable(
+        /*@in@*/ const struct nv_param_os_cfg_table* pOSTable,
+        char bPrintReserved );
+
+/* ********** local variables ********** */
+
+/* uint32 are always hexadecimal */
+static const nv_param_t l_axArg[] = {
+        /* module */
+        { "module",      NVAT_ACTION_MODE_SEL,   FOR_MODULE, OFFS_NONE, ALLOW_CHANGE_WHEN_FIXED },
+
+        { "producttype", NVAT_PRODUCT_TYPE, FOR_MODULE, OFFS_MODULE( szProductType ) },
+        { "serialnr",    NVAT_SERIAL_NR,    FOR_MODULE, OFFS_MODULE( szSerialNr ) }, 
+        { "revision",    NVAT_UINT32,       OFFS_MODULE( uiRevision ) },
+        { "patchlevel",  NVAT_UINT32,       OFFS_MODULE( uiPatchLevel ) },
+        { "ethaddr1",    NVAT_MAC,          OFFS_MODULE( axMAC[ 0 ] ) },
+        { "ethaddr2",    NVAT_MAC,          OFFS_MODULE( axMAC[ 1 ] ) },
+#ifdef CFG_HAS_WIRELESS
+        { "wifical",     NVAT_WCD_LOAD,     FOR_MODULE,  OFFS_NONE  },
+#endif
+        /* ip, it's default */
+        { "network",     NVAT_ACTION_MODE_SEL,   FOR_IP, OFFS_NONE, ALLOW_CHANGE_WHEN_FIXED },
+
+        { "gateway",     NVAT_IP,     OFFS_IP( uiIPGateway ) },
+        { "dns1",        NVAT_IP,     OFFS_IP( auiIPDNS[ 0 ] ) },
+        { "dns2",        NVAT_IP,     OFFS_IP( auiIPDNS[ 1 ] ) },
+        { "server",      NVAT_IP,     OFFS_IP( uiIPServer ) },
+        { "netconsole",  NVAT_IP,     OFFS_IP( uiIPNetConsole ) },
+        { "ip1",         NVAT_IP,     OFFS_IP( axDevice[ 0 ].uiIP ) },
+        { "netmask1",    NVAT_IP,     OFFS_IP( axDevice[ 0 ].uiNetMask ) },
+        { "dhcp1",       NVAT_BOOL,   OFFS_IP( axDevice[ 0 ].flags.bDHCP ) },
+        { "ip2",         NVAT_IP,     OFFS_IP( axDevice[ 1 ].uiIP ) },
+        { "netmask2",    NVAT_IP,     OFFS_IP( axDevice[ 1 ].uiNetMask ) },
+        { "dhcp2",       NVAT_BOOL,   OFFS_IP( axDevice[ 1 ].flags.bDHCP ) },
+
+        /* partititon table */
+        { "partition",   NVAT_ACTION_MODE_SEL,   FOR_PARTITION, OFFS_NONE, ALLOW_CHANGE_WHEN_FIXED },
+        { "add",         NVAT_ACTION_ADD,    FOR_PARTITION, OFFS_NONE, ALLOW_CHANGE_WHEN_FIXED },
+        { "del" ,        NVAT_ACTION_DEL,    FOR_PARTITION, OFFS_NONE },
+        { "select",      NVAT_ACTION_SEL,    FOR_PARTITION, OFFS_HARDCODED, ALLOW_CHANGE_WHEN_FIXED },
+
+        { "name",        NVAT_PART_NAME,     OFFS_PART( szName ) },
+        { "chip",        NVAT_UINT32,        OFFS_PART( uiChip ) },
+        { "start",       NVAT_UINT64,	     OFFS_PART( ullStart ) },
+        { "size",        NVAT_UINT64,        OFFS_PART( ullSize ) },
+        { "type",        NVAT_PART_TYPE,     OFFS_PART( eType ) },
+        { "flag_fixed",  NVAT_BOOL,	     OFFS_PART( flags.bFixed ), ALLOW_CHANGE_WHEN_FIXED },
+        { "flag_readonly", NVAT_BOOL,	     OFFS_PART(flags.bReadOnly)},
+        { "flag_fs_mount_readonly", NVAT_BOOL, OFFS_PART( flags.fs.bMountReadOnly ) },
+        { "flag_fs_root",    NVAT_BOOL,      OFFS_PART( flags.fs.bRoot ) },
+        { "flag_fs_type",    NVAT_FS_TYPE,   OFFS_PART( flags.fs.eType ) },
+        { "flag_fs_version", NVAT_UINT32,    OFFS_PART(flags.fs.uiVersion)},
+
+        /* os configuration table */
+        { "os",       NVAT_ACTION_MODE_SEL,   FOR_OS, OFFS_NONE, ALLOW_CHANGE_WHEN_FIXED },
+        { "add",      NVAT_ACTION_ADD,    FOR_OS, OFFS_NONE },
+        { "del",      NVAT_ACTION_DEL,    FOR_OS, OFFS_NONE },
+        { "select",   NVAT_ACTION_SEL,    FOR_OS, OFFS_HARDCODED },
+
+        { "type",     NVAT_OS_TYPE,       OFFS_OS( eType ) },
+        { "start",    NVAT_UINT32,        OFFS_OS( uiStart ) },
+        { "size",     NVAT_UINT32,        OFFS_OS( uiSize ) },
+};
+
+/* ********** global functions ********** */
+
+int NvCmdLine( int argc, const char* argv[] )
+{
+        REQUIRE_INITIALIZED();
+
+        if( !argc )
+                return NvPrintHelp();
+
+        if( ( argc > 1 ) && !strcmp( "set", argv[ 0 ] ) ) {
+                int i = 1;
+                CE( NvPrivCriticalSetFromArgV( argc - i, &argv[ i ] ) );
+        } else if( ( argc > 1 ) && !strcmp( "print", argv[ 0 ] ) ) {
+                CE( NvPrivCriticalPrintContentsFromArgV( argc - 1,
+                                                           &argv[ 1 ] ) );
+        } else if( !strcmp( "printall", argv[ 0 ] ) ) {
+                char bReserved = ( ( argc > 1 ) &&
+                                   !strcmp( "--reserved", argv[ 1 ] ) );
+                
+                CE( NvPrivCriticalPrintContents( bReserved ) );
+        } else if( !strcmp( "save", argv[ 0 ] ) ) {
+                CE( NvSave() );
+                /* reload */
+                CE( NvInit( NVR_MANUAL ) );
+        } else if( !strcmp( "repair", argv[ 0 ] ) ) {
+                CE( NvPrivImageRepair() );
+        } else if ( !strcmp( "reset", argv[ 0 ] ) ) {
+                CE( NvWorkcopyReset() );
+        } else if( !strcmp( "help", argv[ 0 ] ) ) {
+                CE( NvPrintHelp() );
+        } else
+                CE( NvPrintHelp() );
+                 
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrintHelp( void )
+{
+        int i;
+
+        /* seems that U-Boot crashes when I concat just the lines.
+         * !TODO. Do we have a hidden bug? */
+        static const char* aszHelp[] = {
+                " \n",
+                "  help     : prints this\n",
+                "  print    : prints selected parameters.\n",
+                "             E.g.: print module mac serialnr\n",
+                "  printall : prints complete contents and metainfo\n",
+                "  repair   : Repairs the contents. If one image is\n",
+                "             bad, the good one is copied onto it.\n",
+                "             If both are good or bad, nothing happens.\n",
+                "  reset    : resets everything to factory default values.\n",
+                "  save     : saves the parameters\n",
+                "  set      : sets parameters.\n",
+                "\n",
+        };
+
+        NvPrivOSPrintf( "Arguments: help|print <params>|printall|repair|reset|save|set <params>\n" );
+
+                
+        for( i = 0; i < ARRAY_SIZE( aszHelp ); i++ )
+                NvPrivOSPrintf( "%s", aszHelp[ i ] );
+
+        NvPrivOSPrintf( "  params for \"set\" or \"print\" can be" );
+        
+        /* @TODO: Add Description */
+        for( i = 0; i < ARRAY_SIZE( l_axArg ); i++ ) {
+                const nv_param_t* pArg = &l_axArg[ i ];
+                char bModeSel          = ( NVAT_ACTION_MODE_SEL == pArg->eType );
+                const char* szAssign   = pArg->bNeedsVal ? "=" : "";
+
+                if( bModeSel )
+                        NvPrivOSPrintf( "\n     %-10s", pArg->szName );
+                else
+                        NvPrivOSPrintf( " [%s%s]", pArg->szName, szAssign );
+        }
+        NvPrivOSPrintf( "\n\nParams trailed with '=' require a value in the set command. In the print command, '=' mustn't be used.\n" );
+
+        /* they user may want to know what strings he can use */
+        NvPrivOSPrintf( "\nPossible Values are\n" );
+        NvPrivOSPrintf( "  os type:        " );
+        for( i = 0; i < NVOS_LAST; i++ )
+                NvPrivOSPrintf( "%s%s", ( i > 0 ? "," : "" ), NvToStringOS( i ) );
+        NvPrivOSPrintf( "\n" );
+
+        NvPrivOSPrintf( "  partition type: " );
+        for( i = 0; i < NVPT_LAST; i++ )
+                NvPrivOSPrintf( "%s%s", ( i > 0 ? "," : "" ), NvToStringPart( i ) );
+        NvPrivOSPrintf( "\n" );
+
+        NvPrivOSPrintf( "  flag_fs_type:   " );
+        for( i = 0; i < NVFS_LAST; i++ )
+                NvPrivOSPrintf( "%s%s", ( i > 0 ? "," : "" ), NvToStringFS( i ) );
+        NvPrivOSPrintf( "\n" );
+
+        NvPrivOSPrintf( "\nExamples:\n"
+                        "  %s print module ethaddr1 serialnr : prints mac address and serial number\n"
+                        "  %s print partition select=0 name select=1 name: prints first and second partition name\n"
+                        "  %s set network ip1=192.168.42.30 : changes the IP address\n", CMD_NAME , CMD_NAME , CMD_NAME );
+
+        return 1;
+}
+
+static int NvPrivCriticalPrintContents( char bReserved )
+{
+        REQUIRE_INITIALIZED();
+
+        /* dump meta information */
+        NvPrivOSPrintf( "NVRAM Critical Parameter Status: \n" );
+        if( !g_xInfo.bDefault ) {
+                /* flash is present */
+                NvPrivOSPrintf( "  Original is %s\n", g_xInfo.bOriginalGood ? "OK " : "NOT OK" );
+                NvPrivOSPrintf( "  Mirror is %s\n", g_xInfo.bMirrorGood ? "OK " : "NOT OK" );
+                NvPrivOSPrintf( "  Mirror %s\n",
+                                g_xInfo.bMirrorMatch ? "matches" : "mismatches" );
+                
+                NvPrivOSPrintf( "NVRAM Flash (OS Cfg) Status: \n" );
+                NvPrivOSPrintf( "  Original is %s\n", g_xInfo.bFlashOriginalGood ? "OK " : "NOT OK" );
+                NvPrivOSPrintf( "  Mirror is %s\n", g_xInfo.bFlashMirrorGood ? "OK " : "NOT OK" );
+                NvPrivOSPrintf( "  Mirror %s\n",
+                                g_xInfo.bFlashMirrorMatch ? "matches" : "mismatches" );
+        } else
+                NvPrivOSPrintf( "  Using defaults\n" );
+        
+        NvPrivOSPrintf( "Workcopy: \n" );
+        CE( NvPrivPrintCritical( NVCL_WORKCOPY, bReserved ) );
+        
+        return 1;
+
+error:
+        return 0;
+}
+
+static int NvPrivPrintCritical(
+        nv_critical_loc_e eType,
+        char bPrintReserved )
+{
+        uint32_t uiLibVerMajor;
+        uint32_t uiLibVerMinor;
+        const nv_critical_t* pParam = g_pWorkcopy;
+        
+        NvGetVersion( &uiLibVerMajor, &uiLibVerMinor );
+
+        NvPrivOSPrintf( "  Magic: %s\n", pParam->s.szMagic );
+
+        /* version and do some checks */
+        NvPrivOSPrintf( "  Version: %02u.%02u",
+                pParam->s.uiVerMajor,
+                pParam->s.uiVerMinor );
+
+        if( pParam->s.uiVerMajor != uiLibVerMajor )
+                return NV_SET_ERROR( NVE_VERSION, "" );
+                
+        if( pParam->s.uiVerMinor != uiLibVerMinor ) {
+                bPrintReserved = 1;
+                NvPrivOSPrintf( "  (differs to library %02u.%02u)",
+                        uiLibVerMajor, uiLibVerMinor );
+        }
+        
+        NvPrivOSPrintf( "\n" );
+
+        NvPrivPrintParamModule( &pParam->s.p.xID,  bPrintReserved );
+        NvPrivPrintParamIP( &pParam->s.p.xIP,      bPrintReserved );
+        NvPrivPrintParamPartitionTable( &pParam->s.p.xPartTable, bPrintReserved );
+        NvPrivPrintParamOSTable( &pParam->s.p.xOSTable,          bPrintReserved );
+
+        return 1;
+}
+
+static int NvPrivCriticalPrintContentsFromArgV(
+        int argc, const char* argv[] )
+{
+        int i     = 0;
+        int iEntry = -1;
+        const nv_param_part_table_t*   pPartTable = &g_pWorkcopy->s.p.xPartTable;
+        const nv_param_os_cfg_table_t* pOSTable   = &g_pWorkcopy->s.p.xOSTable;
+        nv_param_mode_e eMode = NVPM_IP;
+
+        REQUIRE_INITIALIZED();
+        
+        while( i < argc ) {
+                const nv_param_t* pParam = NULL;
+                const char* szArg = NULL;
+                const void*       pvAddr = NULL;
+                char bIntValid  = 0;
+                int  iIntArg    = 0;
+                
+                CE( NvPrivFindParam( &pParam, argv[ i ], &szArg, eMode, 0 ) );
+
+                eMode = pParam->eMode;
+
+                if( !pParam->bNeedsVal ) {
+                        i++;
+                        continue;
+                }
+                bIntValid = ( sscanf( szArg, "%i", &iIntArg ) == 1 );
+
+                if( NVAT_ACTION_MODE_SEL != pParam->eType ) {
+                        /* get base address parameters */
+                        switch( eMode ) {
+                            case NVPM_PARTITION:
+                                if( ( NVAT_ACTION_SEL != pParam->eType ) && 
+                                    ( NVAT_ACTION_ADD != pParam->eType ) )
+                                        CE_WRONG_VALUE( -1 != iEntry, "no partition selected" );
+                                pvAddr = &pPartTable->axEntries[ iEntry ];
+                                break;
+                            case NVPM_OS:
+                                if( ( NVAT_ACTION_SEL != pParam->eType ) && 
+                                    ( NVAT_ACTION_ADD != pParam->eType ) )
+                                        CE_WRONG_VALUE( -1 != iEntry, "no os selected" );
+                                pvAddr = &pOSTable->axEntries[ iEntry ];
+                                break;
+                            case NVPM_MODULE:  /* no break */
+                            case NVPM_IP:
+                                pvAddr = g_pWorkcopy;
+                                break;
+                            case NVPM_ANY:
+                                ASSERT( eMode != NVPM_ANY );
+                                break;
+                        }
+                }
+                
+                pvAddr += pParam->iOffs;
+
+                if( pParam->eType == NVAT_ACTION_MODE_SEL ) {
+                        i++;
+                        continue;
+                }
+                
+                if( !pParam->bHardcoded )
+                        NvPrivOSPrintf( "%s=", pParam->szName );
+
+                /* do some action */
+                switch( pParam->eType ) {
+                    case NVAT_ACTION_MODE_SEL:
+                        CE_WRONG_VALUE( bIntValid, szArg );
+                        
+                        switch( eMode ) {
+                            case NVPM_PARTITION:
+                                CE_WRONG_VALUE(
+                                        ( iIntArg >= 0 ) &&
+                                        ( iIntArg < pPartTable->uiEntries ), szArg );
+                                break;
+                            case NVPM_OS:
+                                CE_WRONG_VALUE(
+                                        ( iIntArg >= 0 ) &&
+                                        ( iIntArg < pPartTable->uiEntries ), szArg );
+                                break;
+                            default:
+                                CE_WRONG_VALUE( 0, argv[ i ] );
+                        }
+                        eMode = pParam->eMode;
+                        break;
+
+                    case NVAT_BOOL:
+                        NvPrivOSPrintf( "%i", *((uint8_t*) pvAddr ) );
+                        break;
+
+                    case NVAT_MAC:
+                        NvPrivOSPrintf( "%s",
+                                        NvToStringMAC( *(nv_mac_t*) pvAddr ) );
+                        break;
+
+                    case NVAT_PRODUCT_TYPE:  /* no break */
+                    case NVAT_SERIAL_NR:  /* no break */
+                    case NVAT_PART_NAME:  /* no break */
+                        NvPrivOSPrintf( "%s", (const char*) pvAddr );
+                        break;
+
+                    case NVAT_IP:
+                        NvPrivOSPrintf( "%s",
+                                        NvToStringIP( *(nv_ip_t*) pvAddr ) );
+                        break;
+
+                    case NVAT_FS_TYPE:
+                        NvPrivOSPrintf( "%s",
+                                        NvToStringFS( *(nv_fs_type_e*) pvAddr ) );
+                        break;
+
+                    case NVAT_PART_TYPE:
+                        NvPrivOSPrintf( "%s",
+                                        NvToStringPart( *(nv_part_type_e*) pvAddr ) );
+                        break;
+
+                    case NVAT_OS_TYPE:
+                        NvPrivOSPrintf( "%s",
+                                        NvToStringOS( *(nv_os_type_e*) pvAddr ) );
+                        break;
+
+                    case NVAT_UINT32:
+                        NvPrivOSPrintf( "0x%x", *(uint32_t*) pvAddr );
+                        break;
+                        
+                    case NVAT_UINT64:
+                        NvPrivOSPrintf( "0x%" PRINTF_QUAD "x",
+                                        *(uint64_t*) pvAddr );
+                        break;
+                        
+                    case NVAT_ACTION_SEL: 
+                    {
+                            CE_WRONG_VALUE( bIntValid, szArg );
+                            
+                            switch( eMode ) {
+                                case NVPM_PARTITION:
+                                    CE_WRONG_VALUE(
+                                            ( iIntArg >= 0 ) &&
+                                            ( iIntArg < pPartTable->uiEntries ), szArg );
+                                    break;
+                                case NVPM_OS:
+                                    CE_WRONG_VALUE(
+                                            ( iIntArg >= 0 ) &&
+                                            ( iIntArg < pOSTable->uiEntries ), szArg );
+                                    break;
+                                default:
+                                    CE_WRONG_VALUE( 0, argv[ i ] );
+                            }
+                            
+                            iEntry = iIntArg;
+                            break;
+                    }
+
+                    case NVAT_ACTION_ADD:  /* no break */
+                    case NVAT_ACTION_DEL:
+#ifdef CFG_HAS_WIRELESS
+                    case NVAT_WCD_LOAD:
+#endif
+                        /* will not be reached, satisfy compiler */
+                        break;
+                } /* switch */
+
+                if( !pParam->bHardcoded )
+                        NvPrivOSPrintf( "\n" );
+
+                i++;
+        } /* while( i < argc ) */
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int NvPrivCriticalSetFromArgV( int argc, const char* argv[] )
+{
+        int i     = 0;
+        int iEntry = -1;
+        nv_param_part_table_t* pPartTable = &g_pWorkcopy->s.p.xPartTable;
+        nv_param_os_cfg_table_t* pOSTable = &g_pWorkcopy->s.p.xOSTable;
+        nv_param_mode_e eMode = NVPM_IP;
+        char bFixed = 0;
+        
+        REQUIRE_INITIALIZED();
+
+        while( i < argc ) {
+                const nv_param_t* pParam = NULL;
+                const char* szArg;
+                char bIntValid  = 0;
+                int  iIntArg    = 0;
+                void* pvAddr    = NULL;
+                
+                CE( NvPrivFindParam( &pParam, argv[ i ], &szArg, eMode, 1 ) );
+
+                eMode     = pParam->eMode;
+                bIntValid = ( sscanf( szArg, "%i", &iIntArg ) == 1 );
+
+                if( NVAT_ACTION_MODE_SEL != pParam->eType ) {
+                        /* get base address parameters */
+                        switch( eMode ) {
+                            case NVPM_PARTITION:
+                                if( ( NVAT_ACTION_SEL != pParam->eType ) && 
+                                    ( NVAT_ACTION_ADD != pParam->eType ) )
+                                        CE_WRONG_VALUE( -1 != iEntry, "no partition selected" );
+                                pvAddr = &pPartTable->axEntries[ iEntry ];
+                                break;
+                            case NVPM_OS:
+                                if( ( NVAT_ACTION_SEL != pParam->eType ) && 
+                                    ( NVAT_ACTION_ADD != pParam->eType ) )
+                                        CE_WRONG_VALUE( -1 != iEntry, "no os selected" );
+                                pvAddr = &pOSTable->axEntries[ iEntry ];
+                                break;
+                            case NVPM_MODULE:  /* no break */
+                            case NVPM_IP:
+                                pvAddr = g_pWorkcopy;
+                                break;
+                            case NVPM_ANY:
+                                ASSERT( eMode != NVPM_ANY );
+                                break;
+                        }
+                }
+
+                pvAddr += pParam->iOffs;
+
+                if( NVAT_ACTION_SEL != pParam->eType ) {
+                        char szBuf[ 64 ];
+                        sprintf( szBuf,
+                                 "parameter '%s' is fixed", argv[ i ] );
+                        CE_WRONG_VALUE( !bFixed || pParam->bAllowChangeWhenFixed, szBuf );
+                }
+                
+                /* do some action */
+                switch( pParam->eType ) {
+                    case NVAT_ACTION_MODE_SEL:
+                        eMode = pParam->eMode;
+                        bFixed = 0;
+                        break;
+
+                    case NVAT_BOOL:
+			if (!strcmp(szArg, "on") || !strcmp(szArg, "yes"))
+				*((uint8_t *) pvAddr) = 1;
+			else
+				*((uint8_t *) pvAddr) = atoi(szArg);
+                        break;
+
+                    case NVAT_MAC:
+                        CE_WRONG_VALUE( NvToMAC( (nv_mac_t*) pvAddr, szArg ), szArg );
+                        break;
+
+                    case NVAT_PRODUCT_TYPE:
+                        CE_WRONG_VALUE( COPY_TO_SET( xID.szProductType, szArg ), szArg );
+                        break;
+
+                    case NVAT_SERIAL_NR:
+                        CE_WRONG_VALUE( COPY_TO_SET( xID.szSerialNr, szArg ), szArg );
+                        break;
+#ifdef CFG_HAS_WIRELESS
+                    case NVAT_WCD_LOAD:
+                        if ( !NvPrivWCDGetFromFlashAndSetInNvram() ) {
+                                NvPrivOSPrintfError( "*** Error: loading Wifi Calibration Data from flash\n" );
+                        }
+                        break;
+#endif
+                    case NVAT_IP:
+                        CE_WRONG_VALUE( NvToIP( (nv_ip_t*) pvAddr, szArg ), szArg );
+                        break;
+
+                    case NVAT_FS_TYPE:
+                        CE_WRONG_VALUE( NvToFS( (nv_fs_type_e*) pvAddr, szArg ), szArg );
+                        break;
+
+                    case NVAT_PART_TYPE:
+                        CE_WRONG_VALUE( NvToPart( (nv_part_type_e*) pvAddr, szArg ), szArg );
+                        break;
+
+                    case NVAT_OS_TYPE:
+                        CE_WRONG_VALUE( NvToOS( (nv_os_type_e*) pvAddr, szArg ), szArg );
+                        break;
+
+                    case NVAT_UINT32:  /* no break */
+                    case NVAT_UINT64: 
+                    {
+                            unsigned long long ullVal;
+                            CE_WRONG_VALUE( 1 == sscanf( szArg, "%Lx", &ullVal ), szArg );
+
+                            if( NVAT_UINT32 == pParam->eType )
+                                    *((uint32_t*) pvAddr ) = ullVal;
+                            else if( NVAT_UINT64 == pParam->eType )
+                                    *((uint64_t*) pvAddr ) = ullVal;
+                            else
+                                    CE_WRONG_VALUE( 0, szArg );
+                            
+                            break;
+                    } /* case NVAT_UINT* */
+
+                    case NVAT_ACTION_SEL: 
+                    {
+                            bFixed = 0;
+                            
+                            CE_WRONG_VALUE( bIntValid, szArg );
+                            
+                            switch( eMode ) {
+                                case NVPM_PARTITION:
+                                    CE_WRONG_VALUE(
+                                            ( iIntArg >= 0 ) &&
+                                            ( iIntArg < pPartTable->uiEntries ), szArg );
+                                    bFixed = pPartTable->axEntries[ iIntArg ].flags.bFixed;
+                                    break;
+                                case NVPM_OS:
+                                    CE_WRONG_VALUE(
+                                            ( iIntArg >= 0 ) &&
+                                            ( iIntArg < pOSTable->uiEntries ), szArg );
+                                    break;
+                                default:
+                                    CE_WRONG_VALUE( 0, argv[ i ] );
+                            }
+                            
+                            iEntry = iIntArg;
+                            break;
+                    }
+
+                    case NVAT_ACTION_ADD:
+                        switch( eMode ) {
+                            case NVPM_PARTITION:
+                                iEntry = pPartTable->uiEntries;
+                                CE( NvCriticalPartAdd( NULL ) );
+                                break;
+                            case NVPM_OS:
+                                iEntry = pOSTable->uiEntries;
+                                CE( NvOSCfgAdd( NVOS_NONE, 0 ) );
+                                break;
+                            default:
+                                CE_WRONG_VALUE( 0, argv[ i ] );
+                        }
+                        
+                        break; /* NVAT_ACTION_ADD */
+                        
+                    case NVAT_ACTION_DEL:
+                        switch( eMode ) {
+                            case NVPM_PARTITION:
+                                CE_WRONG_VALUE( pPartTable->uiEntries > 0, argv[ i ] );
+                                CE( NvCriticalPartDelete( iEntry ) );
+                                if( pPartTable->uiEntries <= iEntry )
+                                        bFixed = 0;
+                                else
+                                        bFixed = pPartTable->axEntries[ iEntry ].flags.bFixed;
+                                break;
+                            case NVPM_OS:
+                                CE_WRONG_VALUE( pOSTable->uiEntries > 0, argv[ i ] );
+                                /* move partitions down */
+                                memcpy( &pOSTable->axEntries[ iEntry ],
+                                        &pOSTable->axEntries[ iEntry + 1 ],
+                                        ARRAY_SIZE( pOSTable->axEntries ) - iEntry - 1 );
+                                /* reset last partition */
+                                CLEAR( pOSTable->axEntries[ ARRAY_SIZE( pOSTable->axEntries ) - 1 ] );
+                                pOSTable->uiEntries--;
+                                break;
+                            default:
+                                CE_WRONG_VALUE( 0, argv[ i ] );
+                        }
+
+                        iEntry = -1; /* invalidate it */
+                        break;  /* NVAT_ACTION_DEL */
+
+                    case NVAT_PART_NAME: 
+                        CE_WRONG_VALUE( COPY_TO_SET( xPartTable.axEntries[ iEntry ].szName,
+                                                     szArg ), szArg );
+                        break;
+
+                } /* switch */
+                
+                i++;
+        } /* while( i < argc ) */
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int NvPrivFindParam(
+        const nv_param_t** ppParam,
+        const char* szArg,
+        const char** pszValue,
+        const nv_param_mode_e eMode,
+        char bForSet )
+{
+        int i = 0;
+        int iRes = 1;
+        const nv_param_t* pParamFound = NULL;
+
+        if( NULL != pszValue )
+                *pszValue = NULL;
+
+        for( i = 0; i < ARRAY_SIZE( l_axArg ); i++ ) {
+                const nv_param_t* pParam = &l_axArg[ i ];
+                int iLen = strlen( pParam->szName );
+                
+                if( !strncmp( pParam->szName, szArg, iLen ) &&
+                    ( ( NVPM_ANY == eMode ) ||
+                      ( NVAT_ACTION_MODE_SEL == pParam->eType ) ||
+                      ( pParam->eMode == eMode ) ) ) {
+                        /* szArg can be longer than szName, ensure that it has
+                         * either "=" or nothing */
+                        char bHasAssign = ( '=' == szArg[ iLen ] );
+                        char bIsEOS = !szArg[ iLen ];/* has at least len iLen*/
+                        char bFound = 0;
+
+                        if( bHasAssign || bIsEOS ) {
+                                /* everything for set */
+                                bFound |= ( bForSet &&
+                                            ( ( pParam->bNeedsVal  && bHasAssign ) ||
+                                              ( !pParam->bNeedsVal && bIsEOS ) ) );
+                                /* mac= or mac */
+                                bFound |= ( !bForSet && !bHasAssign && bIsEOS );
+                                /* partition selection=5 */
+                                bFound |= ( !bForSet &&
+                                            ( pParam->eType == NVAT_ACTION_SEL ) &&
+                                            bHasAssign );
+                                if( bFound ) {
+                                        if( NULL != pszValue )
+                                                *pszValue = &szArg[ iLen + bHasAssign];
+                                        pParamFound = pParam;
+                        
+                                        break;
+                                }
+                        }
+                }
+        }
+
+        *ppParam = pParamFound;
+
+        if( NULL == pParamFound )
+                iRes = NV_SET_ERROR( NVE_INVALID_ARG, szArg );
+
+        return iRes;
+}
+
+static void NvPrivPrintParamModule(
+        /*@in@*/ const struct nv_param_module_id* pModule,
+        char bPrintReserved )
+{
+        int i;
+        
+        NvPrivOSPrintf( "  Module ID\n" );
+        NvPrivOSPrintf( "    P/N:          %s\n", pModule->szProductType );    
+        NvPrivOSPrintf( "    S/N:          %s\n", pModule->szSerialNr );     
+        NvPrivOSPrintf( "    Revision:     %x\n", pModule->uiRevision );
+        NvPrivOSPrintf( "    Patchlevel:   %u\n", pModule->uiPatchLevel );
+
+        /* printf MAC for each device */
+        for( i = 0; i < ARRAY_SIZE( pModule->axMAC ); i++ )
+                NvPrivOSPrintf( "    MAC %2i:       %s\n", i + 1,
+                        NvToStringMAC( pModule->axMAC[ i ] ) );
+
+        if( bPrintReserved )
+                PRINT_RESERVED( "    Reserved: ",
+                                pModule->auiReserved );
+}
+
+static void NvPrivPrintParamIP(
+        /*@in@*/ const struct nv_param_ip* pIP,
+        char bPrintReserved )
+{
+        int i;
+        
+        NvPrivOSPrintf( "  IP\n" );
+        for( i = 0; i < ARRAY_SIZE( pIP->axDevice ); i++ ) {
+                const nv_param_ip_device_t* pDev = &pIP->axDevice[ i ];
+                NvPrivOSPrintf( "    Device %i\n", i );
+                NvPrivOSPrintf( "      IP:       %s\n",
+                        NvToStringIP( pDev->uiIP ) );
+                NvPrivOSPrintf( "      NetMask:  %s\n",
+                        NvToStringIP( pDev->uiNetMask ) );
+                NvPrivOSPrintf( "      DHCP:     %s\n",
+                        pDev->flags.bDHCP ? "yes" : "no" );
+                if( bPrintReserved )
+                        PRINT_RESERVED( "      Reserved: ",pDev->auiReserved );
+        }
+        
+        NvPrivOSPrintf( "    Gateway:    %s\n", NvToStringIP( pIP->uiIPGateway ) );
+        for( i = 0; i < ARRAY_SIZE( pIP->auiIPDNS ); i++ )
+                NvPrivOSPrintf( "    DNS %i:      %s\n",
+                                i,
+                                NvToStringIP( pIP->auiIPDNS[ i ] ) );
+
+        NvPrivOSPrintf( "    Server:     %s\n", NvToStringIP( pIP->uiIPServer ) );
+        NvPrivOSPrintf( "    NetConsole: %s\n", NvToStringIP( pIP->uiIPNetConsole ) );
+        if( bPrintReserved )
+                PRINT_RESERVED( "    Reserved: ", pIP->auiReserved );
+}
+
+static void NvPrivPrintParamPartitionTable(
+        /*@in@*/ const struct nv_param_part_table* pPartTable,
+        char bPrintReserved )
+{
+        int i;
+        
+        NvPrivOSPrintf( "  Partition Table\n" );
+        if( !pPartTable->uiEntries )
+                return;
+
+        NvPrivOSPrintf( "   Nr | Name                 | Chip | Start       | Size        | Type         | FS      | Flags\n" );
+        NvPrivOSPrintf( "   ---|----------------------|------|-------------|-------------|--------------|---------|------\n" );
+        for( i = 0; i < pPartTable->uiEntries; i++ ) {
+                const nv_param_part_t* pPart = &pPartTable->axEntries[ i ];
+
+                NvPrivOSPrintf( "   %2i | %-20s | %-4i | 0x%09" PRINTF_QUAD "x | 0x%09" PRINTF_QUAD "x | %-12s | %-7s | ",
+                                i, pPart->szName,
+                                pPart->uiChip,
+                                pPart->ullStart, pPart->ullSize,
+                                NvToStringPart( pPart->eType ),
+                                NvToStringFS( pPart->flags.fs.eType ) );
+
+                if( pPart->flags.bFixed )
+                        NvPrivOSPrintf( "fixed " );
+                if( pPart->flags.bReadOnly )
+                        NvPrivOSPrintf( "readonly " );
+
+                /* they don't make sense if not FS, but print them always */
+                if( pPart->flags.fs.bMountReadOnly )
+                        NvPrivOSPrintf( "mount-readonly " );
+                if( pPart->flags.fs.bRoot )
+                        NvPrivOSPrintf( "rootfs " );
+
+                if( pPart->flags.fs.uiVersion )
+                        NvPrivOSPrintf( " FS Version: %u",
+                                        pPart->flags.fs.uiVersion );
+
+                NvPrivOSPrintf( "\n" );
+
+                if( bPrintReserved )
+                        PRINT_RESERVED( "        Reserved: ",pPart->auiReserved);
+        }
+
+        if( bPrintReserved )
+                PRINT_RESERVED( "    Reserved: ", pPartTable->auiReserved );
+}
+
+static void NvPrivPrintParamOSTable(
+        /*@in@*/ const struct nv_param_os_cfg_table* pOSTable,
+        char bPrintReserved )
+{
+        int i;
+
+        NvPrivOSPrintf( "  OS Configuration Table\n" );
+        if( !pOSTable->uiEntries )
+                return;
+        
+        NvPrivOSPrintf( "   Type        | Start      | Size     \n" );
+        NvPrivOSPrintf( "   ------------|------------|-----------\n" );
+        
+        for( i = 0; i < pOSTable->uiEntries; i++ ) {
+                const nv_param_os_cfg_t* pOS = &pOSTable->axEntries[ i ];
+                NvPrivOSPrintf( "   %-11s | 0x%08x | 0x%08x\n",
+                                NvToStringOS( pOS->eType ),
+                                pOS->uiStart, pOS->uiSize );
+                if( bPrintReserved )
+                        PRINT_RESERVED( "    Reserved: ", pOS->auiReserved );
+        }
+        
+        if( bPrintReserved )
+                PRINT_RESERVED( "    Reserved: ", pOSTable->auiReserved );
+}
diff --git a/common/digi/cmd_nvram/lib/src/nvram_version.h b/common/digi/cmd_nvram/lib/src/nvram_version.h
new file mode 100644
index 0000000..b97ac59
--- /dev/null
+++ b/common/digi/cmd_nvram/lib/src/nvram_version.h
@@ -0,0 +1,20 @@
+/*
+ *  common/digi/cmd_nvram/lib/src/nvram_version.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !History:    
+ *               V1.1: Added NVOS_NETOS_LOADER and NVPT_NETOS_LOADER
+ *               V1.0: Initial Release
+*/
+
+#define NVV_MAJOR 1
+#define NVV_MINOR 2
diff --git a/common/digi/cmd_nvram/mtd.c b/common/digi/cmd_nvram/mtd.c
new file mode 100644
index 0000000..1cbe243
--- /dev/null
+++ b/common/digi/cmd_nvram/mtd.c
@@ -0,0 +1,417 @@
+/*
+ *  cmd_nvram/mtd.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides interface for NAND and NOR access
+*/
+
+#include <common.h>
+
+#include <dvt.h>                /* DVTIsEnabled */
+
+#include "mtd.h"
+#include "nvram_types.h"        /* CLEAR */
+# define memcpy32(a,b,c)	memcpy(a,b,c)
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# define HAVE_NAND
+# include <nand.h>
+#elif (CONFIG_COMMANDS & CFG_CMD_FLASH)
+# undef HAVE_NAND
+# include <flash.h>
+extern flash_info_t flash_info[];
+#else
+# error "Select NAND or NOR support"
+#endif  /* CFG_CMD_NAND */
+
+/**
+ * MtdRead - reads from NAND/NOR flash
+ *
+ * @return: 0 on failure otherwise 1
+ */
+
+int MtdRead( int iChip, uint64_t ullOffs, size_t iLength, void* pvBuf )
+{
+        int iRes = 0;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        size_t iRetBlock;
+
+        iRes = !pChip->read( pChip, ullOffs, iLength, &iRetBlock, pvBuf );
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+        memcpy32( pvBuf, ((const char*) pChip->start[ 0 ] ) + ullOffs, iLength );
+        iRes = 1;
+#endif
+
+        return iRes;
+}
+
+int MtdRewrite( int iChip, uint64_t ullOffs, size_t iLength, const void* pvBuf )
+{
+        int iRes = 0;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        size_t iRetBlock;
+        struct erase_info xErase;
+
+        CLEAR( xErase );
+
+	xErase.mtd  = pChip;
+	xErase.addr = ullOffs;
+	xErase.len  = pChip->erasesize;
+	xErase.callback = 0;
+        
+	iRes = !pChip->erase( pChip, &xErase );
+	if (!iRes)
+		printf("MtdRewrite: erase failed\n");
+
+	iRes = !pChip->write( pChip, ullOffs, iLength, &iRetBlock, pvBuf);
+	if (iRes)
+		printf("MtdRewrite: rewrite succes\n");
+	else
+		printf("MtdRewrite: rewrite failed. Maybe this is a bad block.\n");
+#else
+	iRes = 1;
+#endif
+	return iRes;
+}
+
+int MtdWrite( int iChip, uint64_t ullOffs, size_t iLength, const void* pvBuf )
+{
+        int iRes = 0;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        size_t iRetBlock;
+
+        iRes = !pChip->write( pChip, ullOffs, iLength, &iRetBlock, pvBuf );
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+        iRes = ( flash_write( (char*) pvBuf, pChip->start[ 0 ] + ullOffs, iLength ) == ERR_OK );
+#endif
+
+        return iRes;
+}
+
+/**
+ * MtdErase - erases an aligned memory area
+ * @return:
+ */
+int MtdErase( int iChip, uint64_t ullOffs, size_t iLength )
+{
+        int iRes = 0;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        struct erase_info xErase;
+
+        CLEAR( xErase );
+
+	xErase.mtd  = pChip;
+	xErase.addr = ullOffs;
+	xErase.len  = pChip->erasesize;
+	xErase.callback = 0;
+        iRes = !pChip->erase( pChip, &xErase );
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+        ulong ulStart = pChip->start[ 0 ] + ullOffs;
+        char  bNeedErase = 1;
+
+        DVTPrintOnlyOnce( "Sectors will be erased even if already empty\n " );
+
+        if( !DVTIsEnabled() ) {
+                /* checks if the block is already empty. Flashing is slooowwww
+                 * on NOR */
+                flash_info_t* pChip = &flash_info[ iChip ];
+                const char* pucBlock = ( const char*) pChip->start[ 0 ] + ullOffs;
+                const u32* puiBlock    = (const u32*) pucBlock;
+                const u32* puiBlockEnd = (const u32*) (pucBlock + iLength );
+
+                bNeedErase = 0;
+                while( puiBlock < puiBlockEnd ) {
+                        if( *puiBlock != 0xFFFFFFFF ) {
+                                /* contains data, no need to go further */
+                                bNeedErase = 1;
+                                break;
+                        }
+
+                        puiBlock++;
+                }
+        } /* if( !DVTIsEnabled() */
+
+        if( bNeedErase )
+#ifndef CONFIG_NS9215
+                iRes = !flash_sect_erase( ulStart, ulStart + iLength - 1, 1 );
+#else
+                iRes = !flash_sect_erase( ulStart, ulStart + iLength - 1);
+#endif
+        else
+                /* not necessary */
+                iRes = 1;
+#endif
+
+        return iRes;
+}
+
+uint64_t MtdSize( int iChip )
+{
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+#endif
+        return pChip->size;
+}
+
+size_t MtdGetEraseSize( int iChip, uint64_t ullOffs )
+{
+        size_t iEraseSize;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        iEraseSize = pChip->erasesize;
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+        flash_sect_t  sect  = find_sector( pChip, pChip->start[ 0 ] + ullOffs );
+
+        if( sect < pChip->sector_count - 1  )
+                /* there can be sectors with different erase size */
+                iEraseSize = pChip->start[ sect + 1 ] - pChip->start[ sect ];
+        else if( sect == pChip->sector_count - 1 )
+                /* last sector */
+                iEraseSize = pChip->size - ( pChip->start[ sect ] - pChip->start[ 0 ] );
+        else
+                iEraseSize = 0;
+#endif  /* HAVE_NAND */
+
+        return iEraseSize;
+}
+
+char MtdBlockIsBad( int iChip, uint64_t ullOffs )
+{
+        char bBad;
+
+#ifdef HAVE_NAND
+        nand_info_t* pChip = &nand_info[ iChip ];
+        bBad = pChip->block_isbad( pChip, ullOffs );
+#else
+        bBad = 0;/* NOR is never bad */
+#endif
+
+        return bBad;
+}
+
+int MtdProtect( int iChip, uint64_t ullOffs, size_t iLength, char bProtect )
+{
+        int iRes;
+
+#ifdef HAVE_NAND
+        iRes = 1; /* no protect available */
+#else
+        flash_info_t* pChip = &flash_info[ iChip ];
+        ulong ulStart = pChip->start[ 0 ] + ullOffs;
+
+        flash_protect( ( bProtect ? FLAG_PROTECT_SET : FLAG_PROTECT_CLEAR ),
+                       ulStart, ulStart + iLength - 1, pChip );
+        iRes = 1;               /* no error available */
+#endif
+
+        return iRes;
+}
+
+/**
+ * MtdVerifyAllocBuf - preallocates a buffer used in multiple verification
+ *
+ * For NOR technology, a buffer is not created because it can be compared
+ * immediately in NOR Flash
+ */
+void* MtdVerifyAllocBuf( size_t iLength )
+{
+        void* pvBuf = NULL;
+
+#ifdef HAVE_NAND
+        pvBuf = malloc( iLength );
+        if( NULL == pvBuf )
+                printf( ERROR "Not enough mem for verify buffer\n" );
+#endif
+
+        return pvBuf;
+}
+
+int MtdVerifyFreeBuf( void* pvBuf )
+{
+        if( NULL != pvBuf )
+                free( pvBuf );
+
+        return 1;
+}
+
+int MtdVerify(
+        int iChip,
+        uint64_t ullOffs,
+        size_t iLength,
+        const void* pvSrc,
+        void* pvBuf )
+{
+        loff_t lOffsDiff;
+
+#ifdef HAVE_NAND
+        if( !MtdRead( iChip, ullOffs, iLength, pvBuf ) ) {
+                printf( ERROR "Read for verify @ 0x%08qx failed\n", ullOffs );
+                goto error;
+        }
+#else
+        /* no need to copy in RAM */
+        flash_info_t* pChip = &flash_info[ iChip ];
+        pvBuf = ((char*) pChip->start[ 0 ] ) + ullOffs;
+#endif
+
+        lOffsDiff = MemCmp( pvSrc, pvBuf, iLength );
+
+        if( -1 != lOffsDiff ) {
+                printf( "\n" ERROR "Difference @ 0x%08x\n",
+                        ullOffs + lOffsDiff );
+                printf( "Original:\n" );
+                MemDump( pvBuf, lOffsDiff, 64 );
+                printf( "Flash:\n" );
+                MemDump( pvSrc, lOffsDiff, 64 );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+loff_t MemCmp8( const char* pcS1, const char* pcS2, size_t iSize )
+{
+        loff_t iOffset = 0;
+
+        while( iOffset < iSize ) {
+                if( *pcS2 != *pcS1 )
+                        return iOffset;
+
+                pcS2++;
+                pcS1++;
+                iOffset++;
+        }
+
+        return -1;
+}
+
+/**
+ * MemCmp32 - performes Mem
+ * @return: offset of failure or -1 if none
+ */
+loff_t MemCmp32( const u32* puiS1, const u32* puiS2, size_t iSize )
+{
+        loff_t iOffset = 0;
+        int iRemaining = iSize & 0x3;
+        int iRes;
+
+        /* count in 32bit words */
+        iSize >>= 2;
+
+        while( iOffset < iSize ) {
+                if( *puiS2 != *puiS1 ) {
+                        /* determine exact byte position */
+                        iOffset <<= 2;  /* get it in bytes */
+                        /* words are different, therefore MemCmp8 will
+                           return >=0 */
+                        iOffset += MemCmp8( (const char*) puiS1,
+                                            (const char*) puiS2,
+                                            sizeof( u32 ) );
+                        return iOffset;
+                }
+                puiS2++;
+                puiS1++;
+                iOffset++;
+        }
+
+        iRes = ( iRemaining ?
+                 MemCmp8( (const char*) puiS1,
+                          (const char*) puiS2,
+                          iRemaining ) :
+                 -1 );
+
+        return iRes;
+}
+
+/**
+ * MemCmp - compares memory
+ * @return: offset of failure or -1 if none
+ */
+loff_t MemCmp(  const void* pvS1, const void* pvS2, size_t iSize )
+{
+        loff_t iOffs;
+
+        if( ( ( ( int ) pvS1 ) & 0x3 ) ||
+            ( ( ( int ) pvS2 ) & 0x3 ) )
+                iOffs = MemCmp8( (const char*) pvS1, (const char*) pvS2, iSize );
+        else
+                iOffs = MemCmp32( (const u32*) pvS1, (const u32*) pvS2, iSize );
+
+        return iOffs;
+}
+
+/**
+ * MemDump - Prints memory from pvbase + iOffset to pvBase + iOffset + iLen
+ */
+void MemDump( const void* pvBase, loff_t iOffset, size_t iLen )
+{
+	const unsigned char* pucBuf = (const unsigned char*) pvBase + iOffset;
+	const int COLUMN_COUNT = 16;
+	int i;
+
+	for( i = 0; i < iLen; i += COLUMN_COUNT ) {
+        	/* print one row */
+        	int j, iRowLen;
+
+                if( ( i + COLUMN_COUNT ) <= iLen )
+                        iRowLen = COLUMN_COUNT;
+                else
+                        iRowLen = iLen - i;
+
+                printf( "%08qx  ", (long long) iOffset );
+
+                /* print hexadecimal representation */
+                for( j=0; j < iRowLen; j++ ) {
+                        printf( "%02x ", *( pucBuf + j ) );
+                        if( ( ( COLUMN_COUNT / 2 ) - 1 ) == j )
+                                /* additional separator*/
+                                printf( "   " );
+                }
+
+                printf( "  " );
+
+                /* print character representation row */
+                for( j=0; j < iRowLen; j++ ) {
+                        unsigned char c = *( pucBuf + j );
+                        if( ( c < 32 ) || ( c > 127 ) )
+                                c = '.';
+
+                        if( ( ( COLUMN_COUNT / 2 ) - 1 ) == j )
+                                /* additional separator*/
+                                printf( " " );
+
+                        printf( "%c", c );
+                }
+
+                printf( "\r\n" );
+                pucBuf += COLUMN_COUNT;
+                iOffset += iRowLen;
+	}
+}
diff --git a/common/digi/cmd_nvram/mtd.h b/common/digi/cmd_nvram/mtd.h
new file mode 100644
index 0000000..e9a73ac
--- /dev/null
+++ b/common/digi/cmd_nvram/mtd.h
@@ -0,0 +1,38 @@
+/*
+ *  common/digi/cmd_nvram/mtd.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides interface for NAND and NOR 
+*/
+
+#ifndef _MTD_H
+#define _MTD_H
+
+#define ERROR "*** ERROR: "
+
+extern int MtdRead(  int iChip, uint64_t ullOffs, size_t iLength, void* pvBuf );
+extern int MtdRewrite( int iChip, uint64_t ullOffs, size_t iLength, const void* pvBuf );
+extern int MtdWrite( int iChip, uint64_t ullOffs, size_t iLength, const void* pvBuf );
+extern int MtdErase( int iChip, uint64_t ullOffs, size_t iLength );
+extern int MtdInfo(  int iChip, uint64_t ullOffs, uchar* pbBad, size_t* piEraseSize );
+extern uint64_t MtdSize( int iChip );
+extern char     MtdBlockIsBad( int iChip, uint64_t ullOffs );
+extern size_t   MtdGetEraseSize( int iChip, uint64_t ullOffs );
+extern int      MtdProtect( int iChip, uint64_t ullOffs, size_t iLength, char bProtect );
+extern void*    MtdVerifyAllocBuf( size_t iLength );
+extern int      MtdVerifyFreeBuf( void* pvBuf );
+extern int      MtdVerify( int iChip, uint64_t ullOffs, size_t iLength,
+                           const void* pvSrc, void* pvBuf );
+extern loff_t MemCmp(  const void* pvS1, const void* pvS2, size_t iSize );
+extern void   MemDump( const void* pvBase, loff_t iOffset, size_t iLen );
+
+#endif  /* _MTD_H */
diff --git a/common/digi/cmd_nvram/nvram_priv_uboot.c b/common/digi/cmd_nvram/nvram_priv_uboot.c
new file mode 100644
index 0000000..172b21f
--- /dev/null
+++ b/common/digi/cmd_nvram/nvram_priv_uboot.c
@@ -0,0 +1,549 @@
+/*
+ *  cmd_nvram/nvram_priv_uboot.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines the private functions needed by the nvram core to
+ *               access Flash and a console for U-Boot.
+ */
+
+#include <common.h>
+
+#include "nvram_priv.h"
+#include "env.h"
+#include "mtd.h"
+#include "partition.h"
+
+#define OFFS( x ) ( PART_UBOOT_SIZE + ( x ) )
+
+#define CE( sCmd ) \
+        do { \
+                if( !(sCmd) )       \
+                        goto error;    \
+        } while( 0 )
+
+#ifndef PART_FPGA_SIZE
+# define PART_FPGA_SIZE 0
+#endif
+
+#define NVRAM_CHIP 0
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern size_t nvram_part_size;
+
+/* ********** local functions ********** */
+
+/* Returns the total size of the partitions before the
+ * one passed as parameter */
+uint64_t sizeof_partsbelow(nv_param_part_t *table, int part)
+{
+	uint64_t size = 0;
+
+	while (part-- > 0)
+		size += table[part].ullSize;
+
+	return size;
+}
+
+static int NvPrivOSIntInRange( loff_t iOffs, size_t iLength )
+{
+        int iRes = 1;
+
+        if( ( iOffs + iLength ) > nvram_part_size )
+                iRes = NV_SET_ERROR( NVE_NO_SPACE, "" );
+
+        return iRes;
+}
+
+static void NvPrivOSAddPartitions(
+        nv_critical_t* pCrit,
+        const nv_param_part_t* pTable,
+        size_t iEntries )
+{
+        int i;
+        uint64_t ullSizeFromEnd = 0;
+
+        /* the partition table in flash only knows positive start addresses.
+         * To support placing partitions from the end, we allow that
+         * pTable->ullStart is actual signed and negative. If < 0 then
+         * partitions runs from end. If partitions grow big enough that this
+         * becomes a problem, I'll be happy that it survived that long. */
+
+        /* determine how much space are counted from end-of-flash*/
+        for( i = 0; i < iEntries; i++ ) {
+                if( (int64_t) pTable[ i ].ullStart < 0 )
+                        ullSizeFromEnd += pTable[ i ].ullSize;
+        }
+
+        /* now do all partitions coming from 0 */
+        for( i = 0; i < iEntries; i++ ) {
+                nv_param_part_t* pPart = &pCrit->s.p.xPartTable.axEntries[ pCrit->s.p.xPartTable.uiEntries ];
+
+                if( (int64_t) pTable[ i ].ullStart < 0 )
+                        continue;
+
+                ASSERT( i < ARRAY_SIZE( pCrit->s.p.xPartTable.axEntries ) - 1 );
+                *pPart = pTable[ i ];
+
+                if( !pPart->ullSize )
+                        /* convert 0 to to-end-of-flash */
+                        pPart->ullSize = PartSize( pPart ) - ullSizeFromEnd;
+
+                pCrit->s.p.xPartTable.uiEntries++;
+        }
+
+        /* now do all partitions coming from end of flash */
+        for( i = 0; i < iEntries; i++ ) {
+                nv_param_part_t* pPart = &pCrit->s.p.xPartTable.axEntries[ pCrit->s.p.xPartTable.uiEntries ];
+
+                if( (int64_t) pTable[ i ].ullStart >= 0 )
+                        continue;
+
+                ASSERT( i < ARRAY_SIZE( pCrit->s.p.xPartTable.axEntries ) - 1 );
+                *pPart = pTable[ i ];
+
+                if( (int64_t) pPart->ullStart < 0 ) {
+                        /* convert 0 to to-end-of-flash */
+                        pPart->ullStart += MtdSize( pPart->uiChip );
+                }
+
+                pCrit->s.p.xPartTable.uiEntries++;
+        }
+}
+
+/* ********** global functions ********** */
+
+int NvPrivOSInit( void )
+{
+        return 1;
+}
+
+int NvPrivOSPostInit( void )
+{
+        int i;
+        const nv_critical_t* pCrit;
+
+        /* protects all fixed and read-only partitions against accidently
+         * modifications.
+         * This is called right after NVRAM/Partition table has been read, so
+         * protects it early */
+        CE( NvCriticalGet( (nv_critical_t**) &pCrit ) );
+
+        for( i = 0; i < pCrit->s.p.xPartTable.uiEntries; i++ ) {
+                /* each parttition */
+                const nv_param_part_t* pPart = &pCrit->s.p.xPartTable.axEntries[ i ];
+
+                if( pPart->flags.bFixed || pPart->flags.bReadOnly )
+                        /* avoid accidently changes */
+                        PartProtect( pPart, 1 );
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSFinish( void )
+{
+        return 1;
+}
+
+int NvPrivOSCriticalPostReset(
+        struct nv_critical* pCrit )
+{
+        CE( NvOSCfgAdd( NVOS_UBOOT, CFG_ENV_SIZE ) );
+
+        /* nothing to do */
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSCriticalPartReset(
+        struct nv_critical* pCrit,
+        nv_os_type_e eForOS )
+{
+        static nv_param_part_t axPartitionTable[10];
+	int part;
+
+#ifndef CONFIG_NETOS_BRINGUP
+	/* Loader partitions */
+	/* U-Boot */
+	part = 0;
+	strcpy(axPartitionTable[part].szName, "U-Boot");
+	axPartitionTable[part].eType = NVPT_UBOOT;
+	axPartitionTable[part].flags.bFixed = 1;
+	axPartitionTable[part].ullStart = 0;
+	axPartitionTable[part].ullSize = PART_UBOOT_SIZE;
+	/* NVRAM */
+	part++;
+	strcpy(axPartitionTable[part].szName, "NVRAM");
+	axPartitionTable[part].eType = NVPT_NVRAM;
+	axPartitionTable[part].flags.bFixed = 1;
+	axPartitionTable[part].ullStart  = sizeof_partsbelow(axPartitionTable, part);
+	axPartitionTable[part].ullSize = nvram_part_size;
+# if PART_FPGA_SIZE > 0
+	/* FPGA */
+	part++;
+	strcpy(axPartitionTable[part].szName, "FPGA");
+	axPartitionTable[part].eType = NVPT_FPGA;
+	axPartitionTable[part].flags.bFixed = 1;
+	axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+	axPartitionTable[part].ullSize = PART_FPGA_SIZE;
+# endif
+#else
+	/* NETOS bringup partitions */
+	/* Loader */
+	part = 0;
+	strcpy(axPartitionTable[part].szName, "NET+OS-Loader");
+	axPartitionTable[part].eType = NVPT_NETOS_LOADER;
+	axPartitionTable[part].flags.bFixed = 1;
+	axPartitionTable[part].ullStart = 0;
+#ifdef CONFIG_NS9215
+	/* Start address of NETOS kernel is fixed and depends
+	* on the module memory variant. Consequently the size
+	* of the loader partition will be different (to push the
+	* start address of the kernel partition)
+	* Implemented only for NS9215 platforms */
+	if (MtdSize(0) < (16*1024*1024))
+		axPartitionTable[part].ullSize  = PART_NETOS_LOADER_SIZE_VARIANT1;
+	else
+		axPartitionTable[part].ullSize  = PART_NETOS_LOADER_SIZE_VARIANT2;
+#else
+	axPartitionTable[part].ullSize  = PART_NETOS_LOADER_SIZE_VARIANT1;
+#endif
+	/* Kernel */
+	part++;
+	strcpy(axPartitionTable[part].szName, "NET+OS-Kernel");
+	axPartitionTable[part].eType = NVPT_NETOS;
+	axPartitionTable[part].flags.bFixed = 0;
+	axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+	axPartitionTable[part].ullSize  = PART_NETOS_KERNEL_SIZE;
+	/* NVRAM */
+	part++;
+	strcpy(axPartitionTable[part].szName, "NET+OS-NVRAM");
+	axPartitionTable[part].eType = NVPT_NETOS_NVRAM;
+	axPartitionTable[part].flags.bFixed = 1;
+	/* negative start means start from end of flash*/
+	axPartitionTable[part].ullStart = (int64_t) -PART_NETOS_NVRAM_SIZE;
+	axPartitionTable[part].ullSize  = PART_NETOS_NVRAM_SIZE;
+#endif
+
+	switch( eForOS ) {
+		case NVOS_NONE:
+		break;
+#ifndef CONFIG_NETOS_BRINGUP
+		case NVOS_LINUX:
+			/* Linux partitions */
+#ifdef CONFIG_UBOOT_SPLASH
+			/* Splash */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Splash");
+			axPartitionTable[part].eType = NVPT_SPLASH_SCREEN;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_SPLASH_SIZE;
+#endif
+			/* Kernel */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Kernel");
+			axPartitionTable[part].eType = NVPT_LINUX;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_KERNEL_SIZE;
+			/* Rootfs */
+			part++;
+			strcpy(axPartitionTable[part].szName, "RootFS");
+			axPartitionTable[part].eType = NVPT_FILESYSTEM;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_ROOTFS_SIZE;
+#ifdef SQUASH_ROOTFS
+			axPartitionTable[part].flags.fs.eType = NVFS_SQUASHFS;
+#else
+			axPartitionTable[part].flags.fs.eType = NVFS_JFFS2;
+#endif
+			axPartitionTable[part].flags.fs.bRoot = 1;
+#if PART_ROOTFS_SIZE > 0
+			/* UserFS */
+			part++;
+			strcpy(axPartitionTable[part].szName, "UserFS");
+			axPartitionTable[part].eType = NVPT_FILESYSTEM;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = 0;	/* if 0, means to end-of-flash */
+			axPartitionTable[part].flags.fs.eType = NVFS_JFFS2;
+#endif
+		break;
+
+#if PART_WINCE_SIZE > 0
+		case NVOS_WINCE:
+			/* WinCE partitions */
+#ifdef PART_WINCE_REG_SIZE
+			/* Registry */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Registry");
+			axPartitionTable[part].eType = NVPT_WINCE_REGISTRY;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_WINCE_REG_SIZE;
+			axPartitionTable[part].flags.fs.eType = NVFS_NONE;
+			axPartitionTable[part].flags.fs.bRoot = 0;
+#endif
+#ifdef CONFIG_UBOOT_SPLASH
+			/* Splash */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Splash");
+			axPartitionTable[part].eType = NVPT_SPLASH_SCREEN;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_SPLASH_SIZE;
+#endif
+			/* Kernel */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Kernel");
+			axPartitionTable[part].eType = NVPT_WINCE;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_WINCE_SIZE;
+			axPartitionTable[part].flags.fs.eType = NVFS_NONE;
+			/* File system */
+			part++;
+			strcpy(axPartitionTable[part].szName, "Filesys");
+			axPartitionTable[part].eType = NVPT_FILESYSTEM;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = PART_WINCE_FS_SIZE;
+			axPartitionTable[part].flags.fs.eType = NVFS_EXFAT;
+		break;
+#endif /* PART_WINCE_SIZE */
+#endif /* NETOS_BRINGUP */
+
+#ifdef PART_NETOS_KERNEL_SIZE
+		case NVOS_NETOS:
+			/* NETOS partitions */
+			/* Loader, Kernel and NVRAM are setup in the bringup section */
+
+			/* File system */
+			part++;
+			strcpy(axPartitionTable[part].szName, "NET+OS-FS");
+			axPartitionTable[part].eType = NVPT_FILESYSTEM;
+			axPartitionTable[part].flags.bFixed = 0;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize = 0;	/* to end of flash */
+			axPartitionTable[part].flags.fs.eType = NVFS_YAFFS;
+			axPartitionTable[part].flags.fs.bRoot = 0;
+		break;
+#endif
+
+#ifdef CONFIG_PARTITION
+		case NVOS_USER_DEFINED:
+#if defined(CONFIG_PARTITION_2) && !(PART_FPGA_SIZE > 0)
+			part++;
+			strcpy(axPartitionTable[part].szName, CONFIG_PARTITION_NAME_2);
+			axPartitionTable[part].eType = CONFIG_PARTITION_TYPE_2;
+			axPartitionTable[part].flags.bFixed = PARTITION_FIXED_2;
+			axPartitionTable[part].flags.bReadOnly = PARTITION_READONLY_2;
+			axPartitionTable[part].flags.fs.eType = CONFIG_PARTITION_FS_2;
+			axPartitionTable[part].flags.fs.bRoot = PARTITION_ROOTFS_2;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize = CONFIG_PARTITION_SIZE_2 * 1024;
+#endif
+#ifdef CONFIG_PARTITION_3
+			part++;
+			strcpy(axPartitionTable[part].szName, CONFIG_PARTITION_NAME_3);
+			axPartitionTable[part].eType = CONFIG_PARTITION_TYPE_3;
+			axPartitionTable[part].flags.bFixed = PARTITION_FIXED_3;
+			axPartitionTable[part].flags.bReadOnly = PARTITION_READONLY_3;
+			axPartitionTable[part].flags.fs.eType = CONFIG_PARTITION_FS_3;
+			axPartitionTable[part].flags.fs.bRoot = PARTITION_ROOTFS_3;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = CONFIG_PARTITION_SIZE_3 * 1024;
+#endif
+#ifdef CONFIG_PARTITION_4
+			part++;
+			strcpy(axPartitionTable[part].szName, CONFIG_PARTITION_NAME_4);
+			axPartitionTable[part].eType = CONFIG_PARTITION_TYPE_4;
+			axPartitionTable[part].flags.bFixed = PARTITION_FIXED_4;
+			axPartitionTable[part].flags.bReadOnly = PARTITION_READONLY_4;
+			axPartitionTable[part].flags.fs.eType = CONFIG_PARTITION_FS_4;
+			axPartitionTable[part].flags.fs.bRoot = PARTITION_ROOTFS_4;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = CONFIG_PARTITION_SIZE_4 * 1024;
+#endif
+#ifdef CONFIG_PARTITION_5
+			part++;
+			strcpy(axPartitionTable[part].szName, CONFIG_PARTITION_NAME_5);
+			axPartitionTable[part].eType = CONFIG_PARTITION_TYPE_5;
+			axPartitionTable[part].flags.bFixed = PARTITION_FIXED_5;
+			axPartitionTable[part].flags.bReadOnly = PARTITION_READONLY_5;
+			axPartitionTable[part].flags.fs.eType = CONFIG_PARTITION_FS_5;
+			axPartitionTable[part].flags.fs.bRoot = PARTITION_ROOTFS_5;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = CONFIG_PARTITION_SIZE_5 * 1024;
+#endif
+#ifdef CONFIG_PARTITION_6
+			part++;
+			strcpy(axPartitionTable[part].szName, CONFIG_PARTITION_NAME_6);
+			axPartitionTable[part].eType = CONFIG_PARTITION_TYPE_6;
+			axPartitionTable[part].flags.bFixed = PARTITION_FIXED_6;
+			axPartitionTable[part].flags.bReadOnly = PARTITION_READONLY_6;
+			axPartitionTable[part].flags.fs.eType = CONFIG_PARTITION_FS_6;
+			axPartitionTable[part].flags.fs.bRoot = PARTITION_ROOTFS_6;
+			axPartitionTable[part].ullStart = sizeof_partsbelow(axPartitionTable, part);
+			axPartitionTable[part].ullSize  = CONFIG_PARTITION_SIZE_6 * 1024;
+#endif
+		break;
+#endif /* CONFIG_PARTITION */
+		default:
+			NV_SET_ERROR( NVE_NOT_IMPLEMENTED, NvToStringOS( eForOS ) );
+			goto error;
+		break;
+	}
+
+	/* Add partition table to NVRAM */
+        NvPrivOSAddPartitions( pCrit, axPartitionTable, part + 1 );
+
+        return 1;
+
+error:
+        return 0;
+}
+int NvPrivOSFlashOpen( char bForWrite )
+{
+        /* not necessary */
+        return 1;
+}
+
+int NvPrivOSFlashClose( void )
+{
+        /* not necessary */
+        return 1;
+}
+
+int NvPrivOSFlashRead( void* pvBuf, loff_t iOffs, size_t iLength )
+{
+        CE( NvPrivOSIntInRange( iOffs, iLength ) );
+
+        if( !MtdRead( NVRAM_CHIP, OFFS( iOffs ), iLength, pvBuf ) ) {
+                char szErr[ 64 ];
+                sprintf( szErr, "Flash Read @ 0x%08qx, length = %i",
+                         OFFS( iOffs ), iLength );
+
+                NV_SET_ERROR( NVE_IO, szErr );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSFlashErase( loff_t iOffs )
+{
+        nv_priv_flash_status_t xStatus;
+
+        CE( NvPrivOSFlashInfo( iOffs, &xStatus ) );
+        if( !MtdErase( NVRAM_CHIP, OFFS( iOffs ), xStatus.iEraseSize ) ) {
+                char szErr[ 64 ];
+                sprintf( szErr, "Flash Erase @ 0x%08qx, length = %i",
+                         OFFS( iOffs ), xStatus.iEraseSize );
+
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSFlashWrite( /*@in@*/ const void* pvBuf, loff_t iOffs, size_t iLength )
+{
+        CE( NvPrivOSIntInRange( iOffs, iLength ) );
+        if( !MtdWrite( NVRAM_CHIP, OFFS( iOffs ), iLength, pvBuf ) ) {
+                char szErr[ 64 ];
+                sprintf( szErr, "Flash Write @ 0x%08qx, length = %i",
+                         OFFS( iOffs ), iLength );
+
+                NV_SET_ERROR( NVE_IO, szErr );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSFlashProtect( loff_t iOffs, size_t iLength, char bProtect )
+{
+        CE( NvPrivOSIntInRange( iOffs, iLength ) );
+
+        if( !MtdProtect( NVRAM_CHIP, OFFS( iOffs ), iLength, bProtect ) ) {
+                char szErr[ 64 ];
+                sprintf( szErr, "%s failed @ 0x%08qx, length = %i",
+                         ( bProtect ? "Protect" : "Unprotect" ),
+                         OFFS( iOffs ), iLength );
+
+                NV_SET_ERROR( NVE_IO, szErr );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+int NvPrivOSFlashInfo(
+        loff_t iOffs,
+        /*@out@*/ struct nv_priv_flash_status* pStatus )
+{
+        if( !NvPrivOSIntInRange( iOffs, 1 ) )
+                /* the sector needs to be present */
+                return 0;
+
+        CLEAR( *pStatus );
+        pStatus->bBad       = MtdBlockIsBad( NVRAM_CHIP, OFFS( iOffs ) );
+        pStatus->iEraseSize = MtdGetEraseSize(  NVRAM_CHIP, OFFS( iOffs ) );
+
+        return 1;
+}
+
+void NvPrivOSPrintf( const char* szFormat, ...)
+{
+        va_list ap;
+
+        if( !NvPrivIsOutputEnabled() )
+                return;
+
+        va_start( ap, szFormat );
+        vprintf( szFormat, ap );
+        va_end( ap );
+}
+
+void NvPrivOSPrintfError( const char* szFormat, ...)
+{
+        va_list ap;
+
+        if( !NvPrivIsOutputEnabled() )
+                return;
+
+        /* it's not stderr, put there is no vfprintf( stderr )*/
+        va_start( ap, szFormat );
+        vprintf( szFormat, ap );
+        va_end( ap );
+}
diff --git a/common/digi/cmd_nvram/partition.c b/common/digi/cmd_nvram/partition.c
new file mode 100644
index 0000000..949e607
--- /dev/null
+++ b/common/digi/cmd_nvram/partition.c
@@ -0,0 +1,1642 @@
+/*
+ *  U-Boot/common/digi/cmd_nvram/partition.c
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides a GUI frontend to "internal_nvram".
+ *               We don't use NvPrivOSFlashXXX functions, because they are
+ *               intended only for the flash NVRAM partition.
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <nand.h>
+#endif  /* CFG_CMD_NAND */
+#ifdef USE_UBOOT_VERSION
+#include <zlib.h>               /* inflate */
+#endif
+#include <u-boot/zlib.h>               /* inflate */
+
+#include "nvram.h"
+#include "env.h"                /* CW */
+#include "mtd.h"
+#include "partition.h"
+#include "../arch/arm/include/asm/string.h"
+
+/* ********** defines ********** */
+
+#define CTRL_C 0x3
+#define KiB(x) ((x)/1024)
+
+#define MAX( a, b ) ( (a) > (b) ? (a) : (b) )
+
+/* ********** typedefs ********** */
+
+struct cmd_info;
+
+typedef struct cmd_info {
+        char        cKey;
+        const char* szDescr;
+/* a NULL function means exit */
+        int (*pfFunc) ( const struct cmd_info* pCmdInfo );
+        int         iInfo;
+} cmd_info_t;
+
+/* from cmd_bootm */
+#define HEAD_CRC	2
+#define EXTRA_FIELD	4
+#define ORIG_NAME	8
+#define COMMENT		0x10
+#define RESERVED	0xe0
+
+#define DEFLATED	8
+extern void *zalloc(void *x, unsigned items, unsigned size);
+extern void zfree(void *x, void *addr, unsigned nb);
+
+
+/* ********** local functions ********** */
+
+static int  PartCmdAppend( const struct cmd_info* pCmdInfo );
+static int  PartCmdDelete( const struct cmd_info* pCmdInfo );
+static int  PartCmdModify( const struct cmd_info* pCmdInfo );
+static int  PartCmdPrintPartTable( const struct cmd_info* pCmdInfo );
+static int  PartCmdReset( const struct cmd_info* pCmdInfo );
+
+/* helper commands to set local variables */
+static int  PartCmdPTSelect( const struct cmd_info* pCmdInfo );
+static int  PartCmdFSSelect( const struct cmd_info* pCmdInfo );
+static int  PartCmdOSSelect( const struct cmd_info* pCmdInfo );
+
+static int  PartCmdTableLoop(
+        const char* szWhat,
+        const struct cmd_info* pCmdInfoTable, size_t iSize,
+        char bOnlyOnce, int iInit );
+static void PartCmdTablePrint( const struct cmd_info* pCmdInfoTable, size_t iSize );
+
+static int  PartAutoAdjust( unsigned int uiPartition, uint8_t* pbMoved );
+static int  PartModifyProperties(
+        /*@out@*/ struct nv_param_part* pPart, char bPrintCurrent,
+        int iIndex );
+static int  PartSelectPart( const char* szWhat, /*@out@*/ uint32_t* puiPart );
+static int  PartGetSize( const char* szMsg,
+                         /*@out@*/ uint64_t* pullVal, char bModify );
+static int  PartGetUInt( const char* szMsg,
+                         /*@out@*/ uint32_t* puiVal, char bModify );
+static int  PartGetBool( const char* szMsg,
+                         /*@out@*/ uint8_t*  pbVal, char bModify );
+static int  getsn( /*@out@*/ char* szOut, size_t iSize, char bModify );
+static int PartGetChip( const struct nv_param_part* pPart );
+static int PartGetThrottle( const struct nv_param_part* pPart, uint64_t ullSize );
+static void PrintProgress( int iPercentage, int iThrottle,
+                           const char* szFmt, ... );
+
+/* ********** local variables ********** */
+
+/* function tables */
+#define EXIT() \
+        { .cKey = 'q', .szDescr = "Quit", .pfFunc = NULL }
+
+#define MK( key, descr, func ) \
+        { .cKey = key, .szDescr = descr, .pfFunc = func }
+
+static const cmd_info_t l_axCmdGlobal[] = {
+        MK( 'a', "Append partition",      PartCmdAppend     ),
+        MK( 'd', "Delete partition",      PartCmdDelete     ),
+        MK( 'm', "Modify partition",      PartCmdModify     ),
+        MK( 'p', "Print partition table", PartCmdPrintPartTable ),
+        MK( 'r', "Reset partition table", PartCmdReset      ),
+        EXIT(),
+};
+#undef MK
+
+#define MK( key, descr, info )                         \
+        { .cKey = key, .szDescr = descr, .pfFunc = PartCmdPTSelect, .iInfo = info }
+static cmd_info_t l_axCmdPartType[] = {
+        MK( 'e', NULL, NVPT_EBOOT ),
+        MK( 'f', NULL, NVPT_FILESYSTEM ),
+        MK( 'l', NULL, NVPT_LINUX ),
+        MK( 'n', NULL, NVPT_NVRAM ),
+        MK( 'o', NULL, NVPT_NETOS ),
+        MK( 'O', NULL, NVPT_NETOS_LOADER   ),
+        MK( 'N', NULL, NVPT_NETOS_NVRAM    ),
+        MK( 'r', NULL, NVPT_WINCE_REGISTRY ),
+        MK( 's', NULL, NVPT_SPLASH_SCREEN  ),
+        MK( 'u', NULL, NVPT_UBOOT ),
+        MK( 'w', NULL, NVPT_WINCE ),
+        MK( 'F', NULL, NVPT_FPGA  ),
+        MK( '0', NULL, NVPT_UNKNOWN ),
+};
+#undef MK
+
+#define MK( key, descr, info )                         \
+        { .cKey = key, .szDescr = descr, .pfFunc = PartCmdFSSelect, .iInfo = info }
+static cmd_info_t l_axCmdFSType[] = {
+        /* NVFS_NONE not used */
+        MK( 'j', NULL, NVFS_JFFS2   ),
+        MK( 's', NULL, NVFS_SQUASHFS),
+	MK( 'c', NULL, NVFS_CRAMFS  ),
+        MK( 'i', NULL, NVFS_INITRD  ),
+	MK( 'r', NULL, NVFS_ROMFS   ),
+        MK( 'f', NULL, NVFS_FLASHFX ),
+        MK( 'e', NULL, NVFS_EXFAT   ),
+        MK( 'y', NULL, NVFS_YAFFS   ),
+        MK( '0', NULL, NVFS_UNKNOWN ),
+};
+#undef MK
+
+#define MK( key, descr, info )                         \
+        { .cKey = key, .szDescr = descr, .pfFunc = PartCmdOSSelect, .iInfo = info }
+static cmd_info_t l_axCmdOSType[] = {
+        MK( 'n', NULL, NVOS_NONE   ),
+#ifndef CONFIG_NETOS_BRINGUP
+        MK( 'l', NULL, NVOS_LINUX  ),
+#ifdef PART_WINCE_SIZE
+        MK( 'w', NULL, NVOS_WINCE  ),
+#endif
+#endif
+# ifdef PART_NETOS_KERNEL_SIZE
+        MK( 'o', NULL, NVOS_NETOS  ),
+# endif
+#ifdef CONFIG_PARTITION
+	        MK( 'u', NULL, NVOS_USER_DEFINED ),
+#endif
+};
+#undef MK
+
+static nv_param_part_table_t* l_pPartTable = NULL;
+static nv_part_type_e l_ePartType          = NVPT_LAST;
+static nv_fs_type_e   l_eFSType            = NVFS_LAST;
+static nv_os_type_e   l_eOSType            = NVOS_LAST;
+static char l_bAbort = 0;
+
+/* ********** global functions ********** */
+
+/*! \brief Erases the partition */
+/*! \return 0 on failure otherwise 1 */
+
+int PartErase( const struct nv_param_part* pPart )
+{
+        int               iChip   = PartGetChip( pPart );
+        uint64_t          ullSize = PartSize( pPart );
+        uint64_t          ullEnd  = pPart->ullStart + ullSize;
+        int               iThrottle = PartGetThrottle( pPart, ullSize );
+        uint64_t          ullAddr = pPart->ullStart;
+
+        if( iChip < 0 )
+                return 0;
+
+        ullAddr = pPart->ullStart;
+        while( ullAddr < ullEnd ) {
+                size_t iEraseSize = MtdGetEraseSize( iChip, ullAddr );
+
+                if( ctrlc() || had_ctrlc() )
+                        goto error;
+
+                if( !MtdBlockIsBad( iChip, ullAddr ) ) {
+			if(ullSize >> 8)
+				PrintProgress(((((ullAddr - pPart->ullStart) >> 8) * 100) / (ullSize >> 8)),
+                                       iThrottle, "Erasing %i KiB @ 0x%08x:", KiB(iEraseSize), ullAddr);
+			else
+				PrintProgress((((ullAddr - pPart->ullStart) * 100) / ullSize),
+                                       iThrottle, "Erasing %i KiB @ 0x%08x:", KiB(iEraseSize), ullAddr);
+
+                        CE( MtdErase( iChip, ullAddr, iEraseSize ) );
+
+                        /* clean markers are set in a separate function,
+                           because that was being used with "nand erase" */
+                }
+
+                ullAddr += iEraseSize;
+        }
+
+        printf( "\rErasing:   complete                                      \n" );
+
+        return 1;
+
+error:
+        printf( "\n" ERROR "Erase failed\n" );
+        return 0;
+}
+
+/*! \brief Reads iSize bytes from pvBuf of flash partition */
+/*!
+  \param iSize if 0, the whole partition is read.
+  \param bSilent if 0, no progress output is done
+  \return 0 on failure otherwise 1 */
+
+int PartRead(
+        const struct nv_param_part* pPart,
+        void*  pvBuf,
+        size_t iSize,
+        char   bSilent )
+{
+        int      iChip     = PartGetChip( pPart );
+        uint64_t ullAddr   = pPart->ullStart;
+        uint64_t ullEnd    = pPart->ullStart + PartSize( pPart );
+        size_t   iRead     = 0;
+        size_t   iSizeLeft;
+        int      iThrottle;
+
+        if( iChip < 0 )
+                return 0;
+
+        if( !iSize )
+                /* read whole partition */
+                iSize = ullEnd - ullAddr;
+        iSizeLeft = iSize;
+
+        iThrottle = PartGetThrottle( pPart, iSize );
+        /* there is a small cosmetic failure. If there are bad sectors, our
+         * progressbar never reaches 100% because we don't count them */
+
+        while( iSizeLeft && ( ullAddr < ullEnd ) ) {
+                size_t iBytesToRead = min( iSizeLeft, MtdGetEraseSize( iChip, ullAddr ) );
+
+                if( ctrlc() || had_ctrlc() )
+                        goto error;
+
+                if( !MtdBlockIsBad( iChip, ullAddr ) ) {
+                        if( !bSilent ) {
+				if(iSize >> 8)
+					PrintProgress((((iRead >> 8) * 100) / (iSize >> 8)),
+							iThrottle, "Reading:");
+				else
+					PrintProgress(((iRead * 100) / iSize),
+							iThrottle, "Reading:");
+			}
+                        CE( MtdRead( iChip, ullAddr, iBytesToRead, pvBuf ) );
+
+                        iSizeLeft -= iBytesToRead;
+                        pvBuf     += iBytesToRead;
+                        iRead     += iBytesToRead;
+                }
+
+                ullAddr   += MtdGetEraseSize( iChip, ullAddr );
+        } /* while( iSizeLeft */
+
+        if( !bSilent )
+                printf( "\rReading:   complete                                      \n" );
+
+        return 1;
+
+error:
+        printf( "\n" ERROR "Read failed at block @ 0x%08qx\n", ullAddr );
+        return 0;
+}
+
+/*! \brief Reads iSize bytes from pvBuf of flash partition with on-the-fly decompression*/
+/*!
+ * \param iSize if 0, the whole partition is read.
+ * \return 0 on failure otherwise 1
+ *
+ * It is assumed that a U-Boot header is at the start of the partition
+ * as it contains the information that the image is zipped.
+ * That is not checked but skipped automatically
+*/
+
+int PartReadAndDecompress(
+        const struct nv_param_part* pPart,
+        void*  pvBuf,
+        size_t iSize )
+{
+        int      iChip     = PartGetChip( pPart );
+        /* skip U_Boot header telling to be compressed */
+        uint64_t ullAddr   = pPart->ullStart + sizeof( image_header_t );
+        uint64_t ullEnd    = pPart->ullStart + PartSize( pPart );
+        size_t   iRead     = 0;
+        char     bGzipInit = 0;
+        int      iZipRes   = Z_STREAM_END;
+        size_t   iSizeLeft;
+        int      iThrottle;
+        unsigned char* pucTmp = NULL;
+        size_t   iBufSize = 0;
+	z_stream xStream;
+
+        if( iChip < 0 )
+                return 0;
+
+        if( !iSize )
+                /* read whole partition */
+                iSize = ullEnd - ullAddr;
+        iSizeLeft = iSize;
+
+        CLEAR( xStream );
+
+        iThrottle = PartGetThrottle( pPart, iSize );
+        /* there is a small cosmetic failure. If there are bad sectors, our
+         * progressbar never reaches 100% because we don't count them */
+
+        while( iSizeLeft && ( ullAddr < ullEnd ) ) {
+                size_t iEraseSize = MtdGetEraseSize( iChip, ullAddr );
+                size_t iBytesToRead = min( iSizeLeft, iEraseSize );
+
+                if( iEraseSize > iBufSize ) {
+			iBufSize = iEraseSize;
+
+			if( NULL == pucTmp)
+				free( pucTmp );
+			pucTmp = (unsigned char*) malloc( 2 * iBufSize );
+
+			if( NULL == pucTmp ) {
+				eprintf( "No temporary memory for decompression\n" );
+				goto error;
+			}
+                }
+
+                if( ctrlc() || had_ctrlc() )
+                        goto error;
+
+                if( !MtdBlockIsBad( iChip, ullAddr ) ) {
+
+			if(iSize >> 8)
+				PrintProgress((((iRead >> 8) * 100) / (iSize >> 8)),
+						iThrottle, "Unzipping:");
+			else
+				PrintProgress(((iRead * 100) / iSize),
+						iThrottle, "Unzipping:");
+
+                        CE( MtdRead( iChip, ullAddr, iBytesToRead, pucTmp ) );
+
+                        if( !bGzipInit ) {
+                                /* see common/cmd_bootm:gunzip */
+                                int i, flags;
+
+                                /* skip header */
+                                i     = 10;
+                                flags = pucTmp[3];
+                                if( ( DEFLATED != pucTmp[2] ) ||
+                                    (flags & RESERVED) ) {
+                                        eprintf( "Error: Bad gzipped data\n" );
+                                        goto error;
+                                }
+                                if( flags & EXTRA_FIELD )
+                                        i = 12 + pucTmp[ 10 ] +
+                                                ( pucTmp [ 11 ] << 8 );
+                                if( flags & ORIG_NAME )
+                                        i += strlen( (char*) &pucTmp[ i ] ) + 1;
+                                if( flags & COMMENT )
+                                        i += strlen( (char*) &pucTmp[ i ] ) + 1;
+                                if( flags & HEAD_CRC )
+                                        i += 2;
+
+                                xStream.zalloc = zalloc;
+                                xStream.zfree = zfree;
+                                xStream.outcb = Z_NULL;
+
+                                iZipRes = inflateInit2( &xStream, -MAX_WBITS );
+                                if( Z_OK != iZipRes ) {
+                                        eprintf( "Error: inflateInit2() returned %d\n", iZipRes );
+                                        goto error;
+                                }
+                                xStream.avail_in  = iBytesToRead - i;
+                                xStream.next_in   = pucTmp + i;
+                                xStream.next_out  = pvBuf;
+                                xStream.avail_out = 0x7fffffff;
+
+                                bGzipInit = 1;
+                        } else {
+                                xStream.next_in = pucTmp;
+                                xStream.avail_in  = iBytesToRead;
+                        }
+
+                        /* decompress */
+                        iZipRes = inflate( &xStream, Z_FULL_FLUSH );
+                        if( ( Z_OK != iZipRes ) &&
+                            ( Z_STREAM_END != iZipRes ) ) {
+                                eprintf( "Error: inflate() returned %d\n",
+                                         iZipRes );
+                                goto error;
+                        }
+
+                        /* update compressed statistics */
+
+                        iSizeLeft -= iBytesToRead;
+                        iRead     += iBytesToRead;
+                }
+
+                ullAddr   += MtdGetEraseSize( iChip, ullAddr );
+        } /* while( iSizeLeft */
+
+        printf( "\rUnzipping:   %s                                \n",
+                ( Z_STREAM_END == iZipRes ) ? "complete" : "failed" );
+
+        free( pucTmp );
+
+        inflateEnd( &xStream );
+
+        return 1;
+
+error:
+        if( bGzipInit )
+                inflateEnd( &xStream );
+
+        if( NULL != pucTmp )
+                free( pucTmp );
+
+        printf( "\n" ERROR "Read failed at block @ 0x%08qx\n", ullAddr );
+        return 0;
+}
+
+/*! \brief Writes iSize bytes of pvBuf to flash partition */
+/*! Blocks are _NOT_ verified after writing
+  \return 0 on failure otherwise 1 */
+
+int PartWrite(
+        const struct nv_param_part* pPart,
+        const void* pvBuf,
+        size_t iSize )
+{
+        int      iChip     = PartGetChip( pPart );
+        uint64_t ullAddr   = pPart->ullStart;
+        uint64_t ullEnd    = pPart->ullStart + PartSize( pPart );
+        size_t   iWritten  = 0;
+        size_t   iSizeLeft = iSize;
+        int      iThrottle;
+
+        if( iChip < 0 )
+                return 0;
+
+        iThrottle = PartGetThrottle( pPart, iSize );
+
+        while( iSizeLeft && ( ullAddr < ullEnd ) ) {
+                size_t iBytesToWrite = min( iSizeLeft, MtdGetEraseSize( iChip, ullAddr ) );
+
+                if( ctrlc() || had_ctrlc() )
+                        goto error;
+
+                if( !MtdBlockIsBad( iChip, ullAddr ) ) {
+			if( iSize >> 8 )
+				PrintProgress((((iWritten >> 8) * 100) / (iSize >> 8)),
+						iThrottle, "Writing:");
+			else
+				PrintProgress(((iWritten  * 100) / iSize),
+						iThrottle, "Writing:");
+
+                        if ((!MtdWrite( iChip, ullAddr, iBytesToWrite, pvBuf )) &&
+				(!MtdRewrite(iChip, ullAddr, iBytesToWrite, pvBuf)))
+				goto error;
+
+                        iSizeLeft -= iBytesToWrite;
+                        pvBuf     += iBytesToWrite;
+                        iWritten  += iBytesToWrite;
+                } /* if( !MtdBlockIsBad */
+
+                ullAddr   += MtdGetEraseSize( iChip, ullAddr );
+        } /* while( iSizeLeft ) */
+
+        printf( "\rWriting:   complete                                      \n" );
+
+        if( iSizeLeft ) {
+                printf( "\n" ERROR "Partition was too small\n" );
+                goto error;
+        }
+
+        return 1;
+
+error:
+        printf( "\n" ERROR "Write failed at block @ 0x%08qx\n", ullAddr );
+        return 0;
+}
+
+/*! \brief Verifies iSize bytes of pvBuf to flash partition */
+/*! \return 0 on failure otherwise 1 */
+
+int PartVerify(
+        const struct nv_param_part* pPart,
+        const void* pvBuf,
+        size_t iSize )
+{
+        int      iChip     = PartGetChip( pPart );
+        uint64_t ullAddr   = pPart->ullStart;
+        uint64_t ullEnd    = pPart->ullStart + PartSize( pPart );
+        size_t   iVerified = 0;
+        size_t   iSizeLeft = iSize;
+        void*    pvTmp     = NULL;
+        int      iThrottle;
+        int      iEraseSize = MtdGetEraseSize( iChip, ullAddr );
+
+        if( iChip < 0 )
+                return 0;
+
+        /* allocate temporay buffer for reading */
+	/* FIXME NOR flash has not the same erasesize for all blocks.
+	 * Instead of iEraseSize the max erasesize should be taken */
+        pvTmp = MtdVerifyAllocBuf( iEraseSize );
+
+        iThrottle = PartGetThrottle( pPart, iSize );
+
+        /* all blocks */
+        while( iSizeLeft && ( ullAddr < ullEnd ) ) {
+                size_t iBytesToVerify = min( iSizeLeft, MtdGetEraseSize( iChip, ullAddr ));
+
+                if( ctrlc() || had_ctrlc() )
+                        goto error;
+
+                if( !MtdBlockIsBad( iChip, ullAddr ) ) {
+			if( iSize >> 8 )
+				PrintProgress((((iVerified >> 8) * 100) / (iSize >> 8)),
+						iThrottle, "Verifying:");
+			else
+				PrintProgress(((iVerified * 100) / iSize),
+						iThrottle, "Verifying:");
+
+
+                        /* verify it */
+                        CE( MtdVerify( iChip, ullAddr, iBytesToVerify, pvBuf, pvTmp ) );
+
+                        iSizeLeft -= iBytesToVerify;
+                        pvBuf     += iBytesToVerify;
+                        iVerified += iBytesToVerify;
+                } /* if( !MtdBlockIsBad */
+
+                ullAddr   += MtdGetEraseSize( iChip, ullAddr );
+        } /* while( iSizeLeft ) */
+
+        printf( "\rVerifying: complete                                      \n" );
+
+        if( iSizeLeft ) {
+                printf( "\n" ERROR "Partition was too small\n" );
+                goto error;
+        }
+
+        MtdVerifyFreeBuf( pvTmp );
+
+        return 1;
+
+error:
+        MtdVerifyFreeBuf( pvTmp );
+
+        printf( ERROR "Verify failed\n" );
+
+        return 0;
+}
+
+int PartProtect(
+        const struct nv_param_part* pPart,
+        char bProtect )
+{
+        return MtdProtect( pPart->uiChip, pPart->ullStart, pPart->ullSize, bProtect );
+}
+
+#ifdef CONFIG_PARTITION_SWAP
+/*! \brief swaps the partition as needed for the partition/memory chip*/
+/*!
+ * Supported swaps from "ABCDEFGH" to
+ *   o BADCFEHG (16bit flash connected on Bits 16:31)
+ * \return 0 on failure, otherwise 1
+ */
+int PartSwap(
+        const struct nv_param_part* pPart,
+        void* pvBuf,
+        size_t iSize )
+{
+        unsigned char* pucBuf = (unsigned char*) pvBuf;
+        unsigned char* pucEnd = pucBuf + iSize;
+
+        if( iSize & 0x3 ) {
+                printf( ERROR "Wrong Size for Swap" );
+                goto error;
+        }
+
+        /* "ABCDEFGH" -> "BADCFEHG" */
+        for( ; pucBuf < pucEnd; pucBuf += 2 ) {
+                unsigned char ch = *pucBuf;
+                *pucBuf = *( pucBuf + 1 );
+                *(pucBuf + 1) = ch;
+        }
+
+        printf( "Swapping:  complete\n" );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+#endif
+
+/*! \return the size for the flash partition */
+uint64_t PartSize( const struct nv_param_part* pPart )
+{
+        uint64_t ullSize = 0;
+        int iChip = PartGetChip( pPart );
+
+        if( iChip >= 0 ) {
+                ullSize = pPart->ullSize;
+
+                if( !ullSize )
+                        /* to end of flash */
+                        ullSize = MtdSize( iChip ) - pPart->ullStart;
+        }
+
+        return ullSize;
+}
+
+/*! \brief something like fdisk for flash partition */
+/*! \return 0 on failure otherwise 1 */
+
+int PartGUI( void )
+{
+        nv_critical_t* pCritical = NULL;
+        int i;
+        int iRes;
+        nv_param_part_table_t xBackup;
+        char bSave      = 0;
+        char bKeepInMem = 0;
+
+        l_pPartTable = NULL;
+        l_bAbort     = 0;
+
+        if( !CW( NvCriticalGet( &pCritical ) ) )
+                return 0;
+        l_pPartTable = &pCritical->s.p.xPartTable;
+
+        /* make a copy so we can detect differences. Lazy solution, but we have
+         * 128kB of stack, and part table is < 1KiB  */
+        xBackup = *l_pPartTable;
+
+        /* don't use ASSERT, PartGUI is an application that should work even if
+         * we missed something */
+        if( NVPT_LAST != ARRAY_SIZE( l_axCmdPartType ) )
+                printf( ERROR "Missing partition entries, provide %i of %i ***\n",
+                        ARRAY_SIZE( l_axCmdPartType ), NVPT_LAST );
+
+        /* we don't have type NVFS_NONE in our l_axCmdFSType table.
+           Our GUI is ensuring that fs types are only asked for FILESYSTEM
+           partitions */
+        if( NVFS_LAST != ( ARRAY_SIZE( l_axCmdFSType ) + 1 ) )
+                printf( ERROR "Missing fs entries, provide %i of %i ***\n",
+                        ARRAY_SIZE( l_axCmdFSType ), NVFS_LAST );
+
+        /* OS is not checked for completeness */
+
+        /* fill l_axCmdPartType and l_axCmdFSType.
+         * we don't autogenerate everything, e.g. numbering keys, because 'u'
+         * for U-Boot is more intuitive than '0' */
+        for( i = 0; i < ARRAY_SIZE( l_axCmdPartType ); i++ )
+                if( PartCmdPTSelect == l_axCmdPartType[ i ].pfFunc )
+                        l_axCmdPartType[ i ].szDescr = strdup( NvToStringPart( (nv_part_type_e) l_axCmdPartType[ i ].iInfo ) );
+        for( i = 0; i < ARRAY_SIZE( l_axCmdFSType ); i++ )
+                if( PartCmdFSSelect == l_axCmdFSType[ i ].pfFunc )
+                        l_axCmdFSType[ i ].szDescr = strdup( NvToStringFS( (nv_fs_type_e) l_axCmdFSType[ i ].iInfo ) );
+
+        for( i = 0; i < ARRAY_SIZE( l_axCmdOSType ); i++ )
+                if( PartCmdOSSelect == l_axCmdOSType[ i ].pfFunc )
+                l_axCmdOSType[ i ].szDescr = strdup( NvToStringOS( (nv_os_type_e) l_axCmdOSType[ i ].iInfo ) );
+
+        PartCmdPrintPartTable( NULL );
+
+        /* execute commands */
+        printf( "Commands: \n" );
+        iRes = PartCmdTableLoop( "Cmd",
+                                 l_axCmdGlobal, ARRAY_SIZE( l_axCmdGlobal ), 0, -1 );
+
+        if( iRes &&
+            memcmp( l_pPartTable, &xBackup, sizeof( xBackup ) ) ) {
+                printf( "Partition table has been modified. " );
+
+                {
+                        uint8_t bQuerySave = 1;
+
+                        if( PartGetBool( "Save? ",
+                                         &bQuerySave, 1 ) && bQuerySave )
+                                bSave = 1;
+                }
+        }
+
+        /* free memory */
+        for( i = 0; i < ARRAY_SIZE( l_axCmdPartType ); i++ )
+                if( PartCmdPTSelect == l_axCmdPartType[ i ].pfFunc ) {
+                        free( (void*) l_axCmdPartType[ i ].szDescr );
+                        l_axCmdPartType[ i ].szDescr = NULL;
+                }
+        for( i = 0; i < ARRAY_SIZE( l_axCmdFSType ); i++ )
+                if( PartCmdFSSelect == l_axCmdFSType[ i ].pfFunc ) {
+                        free( (void*) l_axCmdFSType[ i ].szDescr );
+                        l_axCmdFSType[ i ].szDescr = NULL;
+                }
+
+        for( i = 0; i < ARRAY_SIZE( l_axCmdOSType ); i++ )
+                if( PartCmdOSSelect == l_axCmdOSType[ i ].pfFunc ) {
+                        free( (void*) l_axCmdOSType[ i ].szDescr );
+                        l_axCmdOSType[ i ].szDescr = NULL;
+                }
+
+        if( bSave )
+                iRes = CW( NvSave() );
+        else {
+                if( !bKeepInMem ) {
+                        /* restore */
+                        pCritical->s.p.xPartTable = xBackup;
+                        printf( "Partition table NOT changed!\n" );
+                } else
+                        printf( "Partition table NOT stored persistent!\n" );
+        }
+
+        return iRes;
+}
+
+#define APPEND_CMDLINE( szWhat ) \
+        strncat( szCmdLine, szWhat, iMaxSize )
+
+/*! \brief Appends mtdparts info to szCmdline */
+/*! From linux/drivers/mtd/cmdlinepart.c
+ * mtdparts=<mtddef>[;<mtddef]
+ * <mtddef>  := <mtd-id>:<partdef>[,<partdef>]
+ * <partdef> := <size>[@offset][<name>][ro]
+ * <mtd-id>  := unique name used in mapping driver/device (mtd->name)
+ * <size>    := standard linux memsize OR "-" to denote all remaining space
+ * <name>    := '(' NAME ')'
+\return 0 on failure otherwise 1 */
+
+int PartStrAppendParts( char* szCmdLine, size_t iMaxSize )
+{
+        nv_critical_t* pCrit = NULL;
+        const nv_param_part_table_t* pPartTable = NULL;
+        uint32_t uiLastChip  = 0xffff;
+        int      i;
+
+        CE( 0 != iMaxSize );
+        CE( NvCriticalGet( &pCrit ) );
+
+        APPEND_CMDLINE( "mtdparts=" );
+
+        pPartTable = &pCrit->s.p.xPartTable;
+
+        /* append partitions */
+        for( i = 0; i < pPartTable->uiEntries; i++ ) {
+                char  acTmp[ 64 ];
+                const nv_param_part_t* pPart = &pPartTable->axEntries[ i ];
+                if( i )
+                        APPEND_CMDLINE( "," );
+
+                if( uiLastChip != pPart->uiChip ) {
+                        /* new chip device, add mtddef */
+                        uiLastChip = pPart->uiChip;
+                        if( !pPart->uiChip )
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215) || defined(CONFIG_CME9210) || \
+    defined(CONFIG_INC20OTTER) || defined(CONFIG_CC9P9210)
+				APPEND_CMDLINE( "physmap-flash.0" );
+#else
+				APPEND_CMDLINE( "onboard_boot" );
+#endif
+			else {
+                                char szBuffer[ 20 ];
+                                sprintf( szBuffer, "device_%u", pPart->uiChip );
+                                APPEND_CMDLINE( szBuffer );
+                        }
+                        APPEND_CMDLINE( ":" );
+                }
+                /* size */
+                if( pPart->ullSize ) {
+                        sprintf( acTmp, "0x%" PRINTF_QUAD "x", pPart->ullSize );
+                        APPEND_CMDLINE( acTmp );
+                } else
+                        APPEND_CMDLINE( "-" );
+                /* start */
+                if( pPart->ullStart ) {
+                        sprintf( acTmp, "@0x%" PRINTF_QUAD "x", pPart->ullStart );
+                        APPEND_CMDLINE( acTmp );
+                }
+
+                /* name */
+                APPEND_CMDLINE( "(" );
+                APPEND_CMDLINE( pPart->szName );
+                APPEND_CMDLINE( ")" );
+
+                /* flags */
+                if( pPart->flags.bReadOnly )
+                        APPEND_CMDLINE( "ro" );
+        } /* for( i = 0) */
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/*! \brief Appends root=/dev/mtdblock??? and filesystem info to szCmdLine */
+int PartStrAppendRoot( char* szCmdLine, size_t iMaxSize )
+{
+        nv_critical_t* pCrit = NULL;
+        int iRootFSPart      = -1;
+        int i;
+        const nv_param_part_table_t* pPartTable;
+
+        if( !CW( NvCriticalGet( &pCrit ) ) )
+                return 0;
+
+        pPartTable = &pCrit->s.p.xPartTable;
+
+        /* find first rootfs partition */
+        for( i = 0; i < pPartTable->uiEntries; i++ ) {
+                const nv_param_part_t* pPart = &pPartTable->axEntries[ i ];
+                if( ( NVPT_FILESYSTEM == pPart->eType ) && pPart->flags.fs.bRoot ) {
+                        iRootFSPart = i;
+                        break;
+                }
+        } /* for( i = 0; ) */
+
+        /* append rootfs parameters for root partition */
+        if( -1 != iRootFSPart ) {
+                const nv_param_part_t* pPart = &pPartTable->axEntries[ iRootFSPart ];
+                char szBuffer[ 30 ];
+                const char* szFSType = NULL;
+                char bOnMTD = 0;
+
+                switch( pPart->flags.fs.eType ) {
+                    case NVFS_JFFS2:
+                        bOnMTD   = 1;
+                        szFSType = "jffs2";
+                        break;
+		    case NVFS_SQUASHFS:
+			bOnMTD   = 1;
+			szFSType = "squashfs";
+			break;
+                    case NVFS_CRAMFS:
+                        bOnMTD   = 1;
+                        szFSType = "cramfs";
+                        break;
+                    case NVFS_INITRD:
+                        bOnMTD   = 0;
+                        szFSType = "cramfs";  /* we use cramfs instead of ext2, writing makes no sense on initrd*/
+                        break;
+		    case NVFS_ROMFS:
+			bOnMTD   = 1;
+			szFSType = "romfs";
+			break;
+                    default:
+                        eprintf( "*** Unsupported filesystem 0x%x",
+                                 pPart->flags.fs.eType );
+                }
+
+                APPEND_CMDLINE( "root=/dev/" );
+
+                if( bOnMTD )
+                        sprintf( szBuffer, "mtdblock%i",
+                                 iRootFSPart );
+                else
+                        sprintf( szBuffer, "ram" );
+                APPEND_CMDLINE( szBuffer );
+
+                if( NULL != szFSType ) {
+                        APPEND_CMDLINE( " rootfstype=" );
+                        APPEND_CMDLINE( szFSType );
+                }
+
+                APPEND_CMDLINE( pPart->flags.fs.bMountReadOnly ? " ro" : " rw" );
+        } /* if( -1 != iRootFSPart */
+
+        return 1;
+}
+
+#undef APPEND_CMDLINE
+
+/* ********** local functions ********** */
+
+static int PartCmdAppend( const struct cmd_info* pCmdInfo )
+{
+        nv_param_part_t xPart;
+        uint64_t        ullSizeLast = 0;
+
+        if( l_pPartTable->uiEntries == ARRAY_SIZE( l_pPartTable->axEntries ) ) {
+                printf( "*** Partition table full ***\n" );
+                goto error;
+        }
+
+        if( l_pPartTable->uiEntries ) {
+                /* check that we have room */
+                /* !TODO. Add multiple chip support */
+                nv_param_part_t* pPartLast = &l_pPartTable->axEntries[ l_pPartTable->uiEntries - 1 ];
+                int iChip = PartGetChip( pPartLast );
+                uint64_t ullSize;
+
+                CE( iChip >= 0 );
+
+                ullSize = MtdSize( iChip );
+                ullSizeLast = pPartLast->ullSize;
+                while( !ullSizeLast ||
+                       ( ( pPartLast->ullStart + ullSizeLast ) >= ullSize ) ) {
+                        /* allow only sizes that don't go beyond chip size */
+                        char szBuffer[ 80 ];
+
+                        printf( "Last partition %i had already maximum size.\n",
+                                l_pPartTable->uiEntries - 1 );
+
+                        sprintf( szBuffer, "  Size  (in MiB, 0 for auto, %s max) ",
+                                 NvToStringSize64( ullSize - pPartLast->ullStart ) );
+
+                        CE( PartGetSize( szBuffer, &ullSizeLast, 1 ) );
+                        l_pPartTable->axEntries[ l_pPartTable->uiEntries - 1 ].ullSize = ullSizeLast;
+                }
+        } /* if( l_pPartTable->uiEntries */
+
+        CLEAR( xPart );
+
+        printf( "Adding partition # %i\n", l_pPartTable->uiEntries );
+
+        CE( PartModifyProperties( &xPart, 0, l_pPartTable->uiEntries ) );
+
+        CE( NvCriticalPartAdd( &xPart ) );
+
+        printf( "Partition %u added\n", l_pPartTable->uiEntries - 1 );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartCmdDelete( const struct cmd_info* pCmdInfo )
+{
+        uint32_t uiPartition = 0xffff;
+        uint8_t  bMoved = 0;
+        const nv_param_part_t* pPart = NULL;
+
+        CE( PartSelectPart( "Delete", &uiPartition ) );
+
+        pPart = &l_pPartTable->axEntries[ uiPartition ];
+        if( pPart->flags.bFixed ) {
+                printf( "*** Partition is fixed, can't be deleted ***\n" );
+                return 1;
+        }
+
+        CE( NvCriticalPartDelete( uiPartition ) );
+
+        if( uiPartition < l_pPartTable->uiEntries )
+                /* there exist partitions behind us */
+                CE( PartAutoAdjust( uiPartition, &bMoved ) );
+
+        PartCmdPrintPartTable( NULL );
+
+        printf( "Partition %u deleted, start addresses%s adjusted\n",
+                uiPartition,
+                ( bMoved ? "" : " not" ) );
+
+        /* !TODO. Add auto-adjust */
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartCmdModify( const struct cmd_info* pCmdInfo )
+{
+        uint32_t uiPartition = 0xffff;
+        nv_param_part_t xPart;
+
+        CE( PartSelectPart( "Modify", &uiPartition ) );
+
+        /* rmw of partition */
+        xPart = l_pPartTable->axEntries[ uiPartition ];
+        CE( PartModifyProperties( &xPart, 1, uiPartition ) );
+        l_pPartTable->axEntries[ uiPartition ] = xPart;
+
+        if( ( uiPartition < ( l_pPartTable->uiEntries - 1 ) ) &&
+            ( ( xPart.ullStart + xPart.ullSize ) !=
+              l_pPartTable->axEntries[ uiPartition + 1 ].ullStart ) ) {
+                /* adjust partitions to fit behind changed entry */
+                uint8_t bMoved = 0;
+
+                CE( PartAutoAdjust( uiPartition + 1, &bMoved ) );
+                if( bMoved )
+                        printf( "Start addresses adjusted\n" );
+        }
+
+        PartCmdPrintPartTable( NULL );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartCmdReset( const struct cmd_info* pCmdInfo )
+{
+        l_eOSType = NVOS_UNKNOWN;
+        printf( "  OS Types: \n" );
+        CE( PartCmdTableLoop( "OS", l_axCmdOSType, ARRAY_SIZE( l_axCmdOSType ), 1, -1 ) );
+
+        CE( NvCriticalPartReset( l_eOSType ) );
+
+        printf( "Partition table reset\n" );
+        PartCmdPrintPartTable( NULL );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartCmdPrintPartTable( const struct cmd_info* pCmdInfo )
+{
+        int i;
+        int iPrinted     = 0;
+        int iMaxNameLen  = 0;
+        int iMaxPTLen    = 0;
+        int iMaxFSLen    = 0;
+        char bAllOnChip0 = 1;
+
+        /* determine max sizes for best fit on screen */
+        for( i = 0; i < l_pPartTable->uiEntries; i++ ) {
+                const nv_param_part_t* pPart = &l_pPartTable->axEntries[ i ];
+                iMaxNameLen = MAX( iMaxNameLen, strlen( pPart->szName ) );
+                iMaxPTLen   = MAX( iMaxPTLen, strlen( NvToStringPart( pPart->eType ) ) );
+                iMaxFSLen   = MAX( iMaxFSLen, strlen( NvToStringFS( pPart->flags.fs.eType ) ) );
+                bAllOnChip0 &= (!pPart->uiChip);
+        }
+
+        /* print header */
+        printf( "Nr | Name%-*s |%s Start     | Size       | Type%-*s | FS%-*s | Flags%n\n",
+                iMaxNameLen - 4 /* strlen ("Name") */ , "", /* for * alignment */
+                ( bAllOnChip0 ? " " : " Chip |" ),
+                iMaxPTLen - 4 /* strlen( "Type" ) */, "", /* for * alignment */
+                iMaxFSLen - 2 /* strlen( "FS" ) */, "", /* for * alignment */
+                &iPrinted );
+
+        /* print separator */
+        while( iPrinted-- )
+                printf( "-" );
+        printf( "\n" );
+
+        for( i = 0; i < l_pPartTable->uiEntries; i++ ) {
+                /* print one partition entry */
+                const nv_param_part_t* pPart = &l_pPartTable->axEntries[ i ];
+                char szTmp1[ 20 ];
+                char szTmp2[ 20 ];
+
+                printf( "%2i | %-*s | ", i, iMaxNameLen, pPart->szName );
+                if( !bAllOnChip0 )
+                        printf( " %-3i | ", pPart->uiChip );
+
+                /* they use a static buffer, can't have two calls in one printf */
+                strcpy( szTmp1, NvToStringSize64( pPart->ullStart ) );
+                strcpy( szTmp2, NvToStringSize64( pPart->ullSize ) );
+
+                printf( "%10" PRINTF_QUAD "s | %10" PRINTF_QUAD "s | %-*s | %-*s | ",
+                        szTmp1,
+                        szTmp2,
+                        iMaxPTLen, NvToStringPart( pPart->eType ),
+                        iMaxFSLen, ( ( NVPT_FILESYSTEM == pPart->eType ) ?
+                                     NvToStringFS( pPart->flags.fs.eType ) :
+                                     "" ) );
+
+                if( pPart->flags.bFixed )
+                        printf( "fixed " );
+                if( pPart->flags.bReadOnly )
+                        printf( "readonly " );
+
+                if( NVPT_FILESYSTEM == pPart->eType ) {
+                        /* this information is only used for filesysystems.
+                           They are not unset on modify, to easily switch back
+                        */
+                        /* they don't make sense if not FS, but print them always */
+                        if( pPart->flags.fs.bMountReadOnly )
+                                printf( "mounted readonly " );
+                        if( pPart->flags.fs.bRoot )
+                                printf( "rootfs " );
+
+                        if( pPart->flags.fs.uiVersion )
+                                printf( " FS Version: %u",
+                                        pPart->flags.fs.uiVersion );
+                } /* if( NVPT_FILESYSTEM ) */
+
+                printf( "\n" );
+        } /* for( i = 0; */
+
+        return 1;
+}
+
+static int PartCmdPTSelect( const struct cmd_info* pCmdInfo )
+{
+        l_ePartType = (nv_part_type_e) pCmdInfo->iInfo;
+        return 1;
+}
+
+static int PartCmdFSSelect( const struct cmd_info* pCmdInfo )
+{
+        l_eFSType = (nv_part_type_e) pCmdInfo->iInfo;
+        return 1;
+}
+
+static int PartCmdOSSelect( const struct cmd_info* pCmdInfo )
+{
+        l_eOSType = (nv_os_type_e) pCmdInfo->iInfo;
+        return 1;
+}
+
+/*! \brief processes user input on pCmdTable */
+/*! \return 0 on failure otherwise 1 */
+static int PartCmdTableLoop(
+        const char* szWhat,
+        const struct cmd_info* pCmdInfoTable, size_t iSize,
+        char bOnlyOnce, int iInit )
+{
+        int iRes;
+
+        if( iInit < 0 )
+                /* so we know what we can enter */
+                PartCmdTablePrint( pCmdInfoTable, iSize );
+
+        do {
+                char bFound = 0;
+                char cKey;
+                int i;
+                const char* szDescr = "";
+                const cmd_info_t* pCmdInfo = NULL;
+                const cmd_info_t* pDfltCmdInfo = NULL;
+
+                iRes = 1;
+
+                if( iInit >= 0 ) {
+                        /* find command for that key */
+                        for( i = 0, pCmdInfo = pCmdInfoTable; i < iSize;
+                             i++, pCmdInfo++ ) {
+                                if( iInit == pCmdInfo->iInfo ) {
+                                        /* found */
+                                        pDfltCmdInfo = pCmdInfo;
+                                        szDescr      = pDfltCmdInfo->szDescr;
+                                        break;
+                                }
+                        } /* for( i = 0 */
+                        printf( "%s (%s, ? for help)> ", szWhat, szDescr );
+                } else /* if( iInit */
+                        printf( "%s (? for help)> ", szWhat );
+
+                while( !tstc() ) {
+                        /* wait for key to be pressed */
+                }
+
+                cKey = getc();
+                if( CTRL_C == cKey ) {
+                        l_bAbort = 1;
+                        iRes = 0;
+                        break;
+                } else if( ( '\r' == cKey ) && ( NULL != pDfltCmdInfo ) ) {
+                        /* use initial one */
+                        printf( "\n" );
+                        pDfltCmdInfo->pfFunc( pDfltCmdInfo );
+                        break;
+                }
+
+                printf( "%c\n", cKey );
+
+                /* find command for that key */
+                for( i = 0, pCmdInfo = pCmdInfoTable; i < iSize;
+                     i++, pCmdInfo++ ) {
+                        if( cKey == pCmdInfo->cKey ) {
+                                /* found */
+                                bFound = 1;
+                                break;
+                        }
+                } /* for( i = 0 */
+
+                if( bFound ) {
+                        if( NULL == pCmdInfo->pfFunc )
+                                /* NULL is exit */
+                                break;
+                        else {
+                                /* execute func */
+                                iRes = pCmdInfo->pfFunc( pCmdInfo );
+                                CW( iRes );
+                                if( iRes && bOnlyOnce )
+                                        break;
+                               /* l_bAbort may be set */
+                        }
+                } else
+                        /* anything else */
+                        PartCmdTablePrint( pCmdInfoTable, iSize );
+	} while( !l_bAbort && ( iRes || !bOnlyOnce ) );
+
+        return iRes;
+}
+
+static void PartCmdTablePrint( const struct cmd_info* pCmdInfoTable, size_t iSize )
+{
+        int i;
+
+        for( i = 0; i < iSize; i++, pCmdInfoTable++ )
+                printf( "   %c) %s\n",
+                        pCmdInfoTable->cKey,
+                        pCmdInfoTable->szDescr );
+}
+
+static int PartAutoAdjust( unsigned int uiPartition, uint8_t* pbMoved )
+{
+        uint8_t bAutoAdjust = 1;
+        uint8_t bAnyFixedAfter = 0;
+        uint32_t u;
+
+        *pbMoved = 0;
+
+        /* are we allowed to change the partitions? */
+        for( u = uiPartition; u < l_pPartTable->uiEntries; u++ )
+                bAnyFixedAfter |= l_pPartTable->axEntries[ u ].flags.bFixed;
+
+        if( !bAnyFixedAfter ) {
+                CE( PartGetBool( "  Auto-Adjust start of succeeding partition? ",
+                                 &bAutoAdjust, 1 ) );
+
+                if( bAutoAdjust ) {
+                        uint64_t ullStart = 0;
+
+                        /* move existing partitions so they follow each other*/
+                        if( uiPartition )
+                                ullStart = l_pPartTable->axEntries[ uiPartition - 1 ].ullStart + l_pPartTable->axEntries[ uiPartition -1 ].ullSize;
+
+                        for( u = uiPartition; u < l_pPartTable->uiEntries; u++ ) {
+                                if( ( ullStart + l_pPartTable->axEntries[ u ].ullSize ) > MtdSize( PartGetChip( &l_pPartTable->axEntries[ u ] ) ) ) {
+                                        eprintf( "*** Warning: Partition %u would expand behind chip size, don't adjusting it \n", u );
+                                        break;
+                                }
+
+                                l_pPartTable->axEntries[ u ].ullStart = ullStart;
+                                ullStart += l_pPartTable->axEntries[ u ].ullSize;
+                                *pbMoved = 1;
+                        }
+                }
+        } else {
+                printf( "*** Can't adjust start addresses because of fixed partitions ***\n" );
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartModifyProperties(
+        struct nv_param_part* pPart,
+        char bPrintCurrent,
+        int iIndex )
+{
+        int      iChip = PartGetChip( pPart );
+        uint64_t ullSize;
+	uint64_t erase_block;
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	struct nand_chip *chip = nand_info[0].priv;
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
+	extern flash_info_t flash_info[];
+#endif
+        if( iChip < 0 )
+                return 0;
+
+        ullSize = MtdSize( iChip );
+        if( pPart->flags.bFixed ) {
+                uint8_t bModify = 0;
+
+                CE( PartGetBool( "Partition is marked fixed, do you still"
+				       " want to modify it? ", &bModify, 0 ) );
+
+                if( !bModify )
+                        return 1;
+        }
+
+        printf( "  Name  " );
+        CE( getsn( pPart->szName, ARRAY_SIZE( pPart->szName ), 1 ) );
+        CE( PartGetUInt( "  Chip  ", &pPart->uiChip, 1 ) );
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	if(chip->numchips <= pPart->uiChip) {
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_FLASH)
+	if( (pPart->uiChip + 1) > CFG_MAX_FLASH_BANKS ||
+		flash_info[pPart->uiChip].size < 2) {
+#endif
+		printf("Invalid chip\n");
+		return 0;
+	}
+
+        /* enter start address */
+        do {
+                /* allow only start addresses < chip size */
+                CE( PartGetSize( "  Start (in MiB, 0 for auto) ",
+                                 &pPart->ullStart, 1 ) );
+		/* allow only start addresses which are
+		 * aligened to erase blocks */
+		erase_block = MtdGetEraseSize(iChip, pPart->ullStart);
+		if (pPart->ullStart % erase_block)
+			printf("Must be a multiple of Flash erase block size (%lu KiB)\n",
+				(erase_block >> 10));
+        } while( pPart->ullStart >= ullSize ||
+		 pPart->ullStart % erase_block );
+
+        if( iIndex > 0 ) {
+                if( !pPart->ullStart ) {
+                        /* auto-calc start */
+                        nv_param_part_t* pPartLast = &l_pPartTable->axEntries[ iIndex - 1 ];
+
+                        if( pPart->uiChip == pPartLast->uiChip ) {
+                                /* same chip, place us behind */
+                                pPart->ullStart = pPartLast->ullStart + pPartLast->ullSize;
+				erase_block = MtdGetEraseSize(iChip, pPart->ullStart);
+				/* align to erase blocks */
+				if (pPart->ullStart % erase_block)
+					pPart->ullStart += erase_block -
+						(pPart->ullStart % erase_block);
+				/* Check that it fits in the flash */
+				if (pPart->ullStart >= ullSize) {
+					printf("Calculated address is out of bounds\n");
+					return 0;
+				}
+                                printf( "   --> Set to %s\n", NvToStringSize64( pPart->ullStart ) );
+                        }
+                }
+
+                if( ( l_pPartTable->axEntries[ iIndex - 1 ].ullStart + l_pPartTable->axEntries[ iIndex - 1 ].ullSize ) > pPart->ullStart ) {
+                        eprintf( "*** Warning: Partition %u intersects partition %u\n",
+                                 iIndex, iIndex - 1 );
+                }
+        }
+        /* enter size */
+        do {
+                /* allow only sizes that don't go beyond chip size */
+                char szBuffer[ 80 ];
+
+                sprintf( szBuffer, "  Size  (in MiB, 0 for auto, %s max) ",
+                         NvToStringSize64( MtdSize( iChip ) - pPart->ullStart ) );
+
+                CE( PartGetSize( szBuffer, &pPart->ullSize, 1 ) );
+		if (pPart->ullSize % erase_block)
+			printf("Must be a multiple of Flash erase block size (%lu KiB)\n",
+				(erase_block >> 10));
+        } while( pPart->ullSize > ( ullSize - pPart->ullStart ) ||
+		pPart->ullSize % erase_block );
+
+        if( !pPart->ullSize ) {
+                /* write the fixed size, makes reading it easier */
+                pPart->ullSize = ullSize - pPart->ullStart;
+                printf( "   --> Set to %s\n", NvToStringSize64( pPart->ullSize ) );
+        }
+
+        l_ePartType = pPart->eType;
+        printf( "  Partition Types\n" );
+        CE( PartCmdTableLoop( "Partition Type",
+                              l_axCmdPartType, ARRAY_SIZE( l_axCmdPartType ), 1, l_ePartType ) );
+        pPart->eType = l_ePartType;
+
+        CE( PartGetBool( "  Fixed  ", &pPart->flags.bFixed, 1 ) );
+
+        CE( PartGetBool( "  Readonly  ", &pPart->flags.bReadOnly, 1 ) );
+
+        if( NVPT_FILESYSTEM == pPart->eType ) {
+                l_eFSType = pPart->flags.fs.eType;
+                printf( "  Filesystem Types \n" );
+                CE( PartCmdTableLoop( "Filesystem", l_axCmdFSType, ARRAY_SIZE( l_axCmdFSType ), 1, l_eFSType ) );
+                pPart->flags.fs.eType = l_eFSType;
+
+                CE( PartGetBool( "  Root-FS  ", &pPart->flags.fs.bRoot, 1 ) );
+
+                CE( PartGetBool( "  Mount Readonly  ",
+                                 &pPart->flags.fs.bMountReadOnly, 1 ) );
+
+                /* we skip version as it is not used yet and can be
+                 * modified with intnvram */
+        }
+
+        return 1;
+
+error:
+        return 0;
+}
+
+static int PartSelectPart( const char* szWhat, /*@out@*/ uint32_t* puiPart )
+{
+        char szMsg[ 64 ] = "";
+
+        if( !l_pPartTable->uiEntries ) {
+                printf( "*** No partitions available ***\n" );
+                goto error;
+        }
+
+        sprintf( szMsg, "%s Which Partition? ", szWhat );
+
+        do {
+                CE( PartGetUInt( szMsg, puiPart, 0 ) );
+                if( *puiPart >= l_pPartTable->uiEntries )
+                        printf( "*** Partition %u not available ***\n",
+                                *puiPart );
+        } while( *puiPart >= l_pPartTable->uiEntries );
+
+        return 1;
+error:
+        return 0;
+}
+
+static int PartGetSize( const char* szMsg, uint64_t* pullVal, char bModify )
+{
+        int iRes = 0;
+
+        do {
+                char szBuffer[ 20 ] = "";
+
+                printf( "%s", szMsg );
+
+                if( bModify )
+                        strncpy( szBuffer, NvToStringSize64( *pullVal ), ARRAY_SIZE( szBuffer ) );
+                if( getsn( szBuffer, ARRAY_SIZE( szBuffer ), bModify ) )
+                        iRes = NvToSize64( pullVal, szBuffer );
+                else
+                        printf( "\n" );
+
+                if( !iRes && !l_bAbort )
+                        printf( "*** Wrong value, try again\n" );
+        } while( !iRes && !l_bAbort );
+
+        return iRes;
+}
+
+static int PartGetUInt( const char* szMsg, uint32_t* puiVal, char bModify )
+{
+        int iRes = 0;
+
+        do {
+                char szBuffer[ 20 ] = "";
+
+                printf( "%s", szMsg );
+
+                if( bModify )
+                        sprintf( szBuffer, "%u", *puiVal );
+                if( getsn( szBuffer, ARRAY_SIZE( szBuffer ), bModify ) )
+                        iRes = ( 1 == sscanf( szBuffer, "%u", puiVal ) );
+                else
+                        printf( "\n" );
+
+                if( !iRes && !l_bAbort )
+                        printf( "*** Wrong value, try again\n" );
+        } while( !iRes && !l_bAbort );
+
+        return iRes;
+}
+
+static int PartGetBool( const char* szMsg, uint8_t* pbVal, char bModify )
+{
+        int iRes = 0;
+
+        do {
+                char szBuffer[ 20 ] = "";
+
+                printf( "%s", szMsg );
+
+                if( bModify )
+                        sprintf( szBuffer, "%s", *pbVal ? "y" : "n" );
+                if( getsn( szBuffer, ARRAY_SIZE( szBuffer ), bModify ) ) {
+                        char szTmp[ 4 ];
+                        if( sscanf( szBuffer, "%4s", &szTmp ) == 1 ) {
+                                if( !strcmp( "y", szBuffer ) ) {
+                                        *pbVal = 1;
+                                        iRes   = 1;
+                                } else if( !strcmp( "n", szBuffer ) ) {
+                                        *pbVal = 0;
+                                        iRes   = 1;
+                                }
+                        }
+                } else
+                        printf( "\n" );
+
+                if( !iRes && !l_bAbort )
+                        printf( "*** Wrong value, try again\n" );
+        } while( !iRes && !l_bAbort );
+
+        return iRes;
+}
+
+/*! \brief returns a string of max iSize.*/
+/*! if ePartType is
+ *  NVPT_FILESYSTEM, also eFSType is used for search.
+ * \param szOut     output string
+ * \param iSize max size with 0
+ * \param bModify if 1, s is reused
+ * \return 0 on Ctrl-C otherwise 1
+ */
+static int getsn( char* szOut, size_t iSize, char bModify )
+{
+        int   i       = 0;
+        int   iRes    = 1;
+        char  bBreak  = 0;
+        char  acBuffer[ 256 ];
+        char* pcStart = acBuffer;
+        char* s       = pcStart;
+
+        acBuffer[ 0 ] = 0;
+
+        if( bModify )
+                printf( "(%s): ", szOut );
+
+        while( !bBreak ) {
+                char cKey;
+
+                while( !tstc() ) {
+                        /* wait for key to be pressed */
+                }
+
+                cKey = getc();
+
+                switch( cKey ) {
+                    case '\r':
+                        /* enter */
+                        *s     = 0;
+                        bBreak = 1;
+                        break;
+
+                    case CTRL_C:
+                        *pcStart = 0;
+                        bBreak   = 1;
+                        l_bAbort = 1;
+                        iRes     = 0;
+                        break;
+
+                    case 0x7f:
+                        /* backspace */
+                        printf( "\b \b" );
+                        /* backspace */
+                        if( i ) {
+                                i--;
+                                s--;
+                        }
+                        break;
+
+                    default:
+                        printf( "%c", cKey );
+                        *s = cKey;
+                        i++;
+                        s++;
+                        break;
+                }
+
+                if( i == ( iSize - 1 ) ) {
+                        /* terminate it */
+                        *(s-1) = 0;
+                        bBreak = 1;
+                }
+        }
+
+        if( iRes ) {
+                if( !bModify || ( s != pcStart ) )
+                        strncpy( szOut, acBuffer, iSize );
+                else
+                        printf( "%s", szOut );
+
+                /* if bModify and nothing entered, take default */
+                printf( "\n" );
+        }
+
+        return iRes;
+}
+
+/*! \return the chip for the flash partition */
+static int PartGetChip( const struct nv_param_part* pPart )
+{
+        return pPart->uiChip;
+}
+
+/*! \brief throttles output to avoid to many serial messages */
+/*! If we have much to read, print more messages. If we have little to read,
+ *  just print a few lines. */
+static int PartGetThrottle(
+        const struct nv_param_part* pPart,
+        uint64_t ullSize )
+{
+        int iChip   = PartGetChip( pPart );
+        int iBlocks = ullSize / MtdGetEraseSize( iChip, 0 );  /* not exact for top/bottom sectors */
+        int iThrottle;
+
+        /* just some numbers, finetuned for linux  */
+        if( iBlocks > 80 )
+                iThrottle = 10;
+        else if( iBlocks > 20 )
+                iThrottle = 20;
+        else
+                iThrottle = 50;
+
+        return iThrottle;
+}
+
+/*! \brief print progress if changed */
+static void PrintProgress( int iPercentage, int iThrottle,
+                           const char* szFmt, ... )
+{
+        static int iLastPercentage = -1;
+        int iThrottled = iPercentage / iThrottle;
+
+        if( iThrottled != iLastPercentage ) {
+                va_list args;
+
+                iLastPercentage = iThrottled;
+
+                va_start( args, szFmt );
+                vprintf( szFmt, args );
+                printf( "% 3i%%          \r", iPercentage );
+                va_end( args );
+        }
+}
+
diff --git a/common/digi/cmd_nvram/partition.h b/common/digi/cmd_nvram/partition.h
new file mode 100644
index 0000000..e4b3727
--- /dev/null
+++ b/common/digi/cmd_nvram/partition.h
@@ -0,0 +1,55 @@
+/*
+ *  U-Boot/common/digi/cmd_nvram/partition.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides a GUI frontend to "internal_nvram".
+*/
+
+#ifndef __DIGI_CMD_NVRAM_PARTITION_H
+#define __DIGI_CMD_NVRAM_PARTITION_H
+
+struct nv_param_part;
+
+extern int PartErase( const struct nv_param_part* pPart );
+extern int PartRead(
+        const struct nv_param_part* pPart,
+        void* pvBuf,
+        size_t iSize,
+        char bSilent );
+extern int PartReadAndDecompress(
+        const struct nv_param_part* pPart,
+        void* pvBuf,
+        size_t iSize );
+extern int PartWrite(
+        const struct nv_param_part* pPart,
+        const void* pvBuf,
+        size_t iSize );
+extern int PartVerify(
+        const struct nv_param_part* pPart,
+        const void* pvBuf,
+        size_t iSize );
+extern int PartProtect(
+        const struct nv_param_part* pPart,
+        char bProtect );
+#ifdef CONFIG_PARTITION_SWAP
+extern int PartSwap(
+        const struct nv_param_part* pPart,
+        void* pvBuf,
+        size_t iSize );
+#endif
+extern uint64_t PartSize( const struct nv_param_part* pPart );
+
+extern int PartGUI( void );
+extern int PartStrAppendParts( char* szCmdLine, size_t iMaxSize );
+extern int PartStrAppendRoot( char* szCmdLine, size_t iMaxSize );
+
+#endif  /* __DIGI_CMD_NVRAM_PARTITION_H */
diff --git a/common/digi/cmd_testhw/Makefile b/common/digi/cmd_testhw/Makefile
new file mode 100755
index 0000000..a5ab128
--- /dev/null
+++ b/common/digi/cmd_testhw/Makefile
@@ -0,0 +1,75 @@
+#
+# (C) Copyright 2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+DIGI_DIR = $(TOPDIR)/common/digi
+
+LIB	= libtesthw.a
+
+AOBJS	= \
+	cpu/ns9360_asm.o
+
+COBJS = cmd.o \
+	common/dvt.o  \
+	common/i2c.o  \
+	common/nand.o \
+	common/nor.o \
+	common/time.o \
+	wireless/vBPiper.o \
+	wireless/wireless.o \
+	wireless/gui_tst_wifi.o \
+	wireless/adc081C021.o \
+	wireless/calibration.o \
+	wireless/commandswifi.o \
+	cpu/ns921x.o  \
+	cpu/ns921x_powersave.o \
+	cpu/ns921x_rtc.o \
+	cpu/ns921x_sysclock.o \
+	cpu/ns9215_adc.o \
+	cpu/ns9360.o \
+	cpu/cc9m2443_lcd.o\
+	cpu/cc9p9215_lcd.o\
+	cpu/cc9m2443_adc.o\
+	cpu/cc9m2443_serial.o
+
+OBJS	= $(AOBJS) $(COBJS)
+
+CFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -DUBOOT
+CPPFLAGS += -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/lib/include \
+	-I $(DIGI_DIR)/cmd_nvram -DUBOOT
+
+all:	$(LIB) $(AOBJS)
+
+$(LIB): .depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/common/digi/cmd_testhw/cmd.c b/common/digi/cmd_testhw/cmd.c
new file mode 100644
index 0000000..4ffcf23
--- /dev/null
+++ b/common/digi/cmd_testhw/cmd.c
@@ -0,0 +1,122 @@
+/*
+ *  common/digi/cmd_testhw/cmd.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides access to various general/CPU/module/baseboard test
+ *               functions/commands
+ *               The list of functions can be retrieved with "testhw help".
+ *               This differs from U-Boot convention, so it is hiding the stuff
+ *               a little bit.
+ *
+ *               To add new commands:
+ *                  1) Create a new C file in cpu/ or module/
+ *                  2) Add obj file to common/digi/Makefile
+ *                  3) Use TESTHW_CMD in C file
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW))
+
+#include <command.h>            /* U_BOOT_CMD */
+
+#include <cmd_testhw/testhw.h>
+
+/* ********** global variables ********** */
+
+/* the linker inserts the commands after __testhw_cmd_start and
+   __testhw_cmd_end */
+
+const testhw_cmd_entry_t __testhw_cmd_start;
+const testhw_cmd_entry_t __testhw_cmd_end;
+
+/* ********** local functions ********** */
+
+/*! \brief Locates the command entry for szName */
+/*! \return NULL if szName not found, otherwise the entry for szName */
+static const testhw_cmd_entry_t* FindCmd( const char* szName )
+{
+        const testhw_cmd_entry_t* pCmdEntry = NULL;
+        const testhw_cmd_entry_t* pIt       = &__testhw_cmd_start;
+
+        while( pIt < &__testhw_cmd_end ) {
+                if( !strcmp( szName, pIt->szName ) ) {
+                        /* found */
+                        pCmdEntry = pIt;
+                        break;
+                }
+                
+                pIt++;
+        }
+
+        return pCmdEntry;
+}
+
+/*! \brief performs a test command */
+/*! \return 1 on failure, otherwise 0 */
+static int do_testhw( cmd_tbl_t* cmdtp, int flag, int argc, char* argv[] )
+{
+        const testhw_cmd_entry_t* pCmdEntry = NULL;
+        
+        if( argc < 2 ) {
+                eprintf( "Usage:\n%s\n", cmdtp->usage );
+                goto error;
+        }
+
+        pCmdEntry = FindCmd( argv[ 1 ] );
+        if( NULL == pCmdEntry ) {
+                eprintf( "Test not found: %s\n", argv[ 1 ] );
+                goto error;
+        }
+
+        /* execute test command */
+        if( !pCmdEntry->pfHandler( argc - 2, &argv[ 2 ] ) ) {
+                TESTHW_ERROR( "Test failed: %s", argv[ 1 ] );
+                goto error;
+        } else
+                printf( "Test OK\n" );
+        
+        return 0;
+
+error:
+        return 1;
+}
+
+/*! \brief implements "testhw help", printing all registered commands */
+/*! \return always 0 (OK) */
+static int do_testhw_help( int argc, char* argv[] )
+{
+        const testhw_cmd_entry_t* pCmdEntry = &__testhw_cmd_start;
+
+        printf( "Commands:\n" );
+        while( pCmdEntry < &__testhw_cmd_end ) {
+                printf( " %-24s - %s\n", pCmdEntry->szName, pCmdEntry->szHelp);
+                pCmdEntry++;
+        }
+
+        return 1;
+}
+
+/* ********** U-Boot command table ********** */
+
+U_BOOT_CMD(
+	testhw, 255, 0, do_testhw,
+	"testhw  - Internal hardware test functions\n",
+        "- This is an internal command.\n"
+);
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( help,
+            "This help" );
+
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW)) */
diff --git a/common/digi/cmd_testhw/common/dvt.c b/common/digi/cmd_testhw/common/dvt.c
new file mode 100644
index 0000000..2b2e97f
--- /dev/null
+++ b/common/digi/cmd_testhw/common/dvt.c
@@ -0,0 +1,83 @@
+/*
+ *  common/digi/cmd_testhw/common/dvt.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides commands:
+ *                dvt on|off
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CONFIG_DVT_PROVIDED)
+
+#include <stdarg.h>             /* va_start */
+
+#include <dvt.h>
+#include <cmd_testhw/testhw.h>
+
+#define USAGE "on|off|reset"
+
+char g_bDVTIsEnabled     = 0;
+char g_bDVTStatusChanged = 0;
+char g_bDVTHadError      = 0;
+char g_bDVTHadWarning    = 0;
+
+static void DVTEnable( char bEnabled ) 
+{
+        /* reset status, print any pending errors */
+        DVTReset();
+
+        g_bDVTIsEnabled = bEnabled;
+
+        printf( "DVT specific handling is %s\n",
+                ( g_bDVTIsEnabled ? "On" : "Off" ) );
+}
+
+/**
+ * do_testhw_udelay - trigger and wait in seconds
+ */
+static int do_testhw_dvt( int argc, char* argv[] )
+{
+        int iRes;
+        
+        if( 1 != argc ) {
+                eprintf( "Usage: dvt %s\n", USAGE );
+                goto error;
+        }
+
+        iRes = !DVTError();
+
+        if( !strcmp( argv[ 0 ], "on" ) )
+                DVTEnable( 1 );
+        else if( !strcmp( argv[ 0 ], "off" ) )
+                DVTEnable( 0 );
+        else if( !strcmp( argv[ 0 ], "reset" ) )
+                /* only error register */
+                DVTReset();
+        else {
+                printf( "Unknown options %s\n", argv[ 0 ] );
+                goto error;
+        }
+        
+        return iRes;
+
+error:
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( dvt, USAGE );
+
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_BSP) ... */
diff --git a/common/digi/cmd_testhw/common/i2c.c b/common/digi/cmd_testhw/common/i2c.c
new file mode 100644
index 0000000..11c3b23
--- /dev/null
+++ b/common/digi/cmd_testhw/common/i2c.c
@@ -0,0 +1,62 @@
+/*
+ *  common/digi/cmd_testhw/common/i2c.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides commands:
+ *                 i2c speed [<speed>]
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CFG_I2C_SPEED)
+
+#include <i2c.h>                /* i2c_speed */
+
+#include <cmd_testhw/testhw.h>
+
+/* ********** local functions ********** */
+
+/**
+ * do_testhw_i2c - trigger and wait us
+ */
+static int do_testhw_i2c_speed( int argc, char* argv[] )
+{
+        int iSpeed;
+        
+        if( argc > 1 ) {
+                eprintf( "Usage: i2c_speed [<kHz>]\n" );
+                goto error;
+        }
+
+        if( 1 == argc  )
+                /* new value */
+                i2c_init( simple_strtoul( argv[ 0 ], NULL, 10 ) * 1000, 0 );
+
+        iSpeed = i2c_speed();
+        
+        printf( "Current I2C Speed is %i kHz\n", iSpeed / 1000 );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( i2c_speed, "[<kHz>]" );
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_BSP) ... */
+
+
diff --git a/common/digi/cmd_testhw/common/nand.c b/common/digi/cmd_testhw/common/nand.c
new file mode 100644
index 0000000..e436a8c
--- /dev/null
+++ b/common/digi/cmd_testhw/common/nand.c
@@ -0,0 +1,274 @@
+/*
+ *  /common/digi/cmd_testhw/common/nand.o
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Implements commands:
+ *                   nand_pattern <start> <size> <loop>
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) && \
+    (CONFIG_COMMANDS & CFG_CMD_NAND) && \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW)
+
+#include <nand.h>            
+#include <nvram_types.h>        /* CLEAR */
+#include <mtd.h>                /* MemDump */
+#include <dvt.h>                /* DVTError */
+
+#include <cmd_testhw/testhw.h>
+
+#define USAGE "<start> <size> <count> [<stop_on_error>]"     
+
+static int inline rewrite( nand_info_t* pChip, struct erase_info xErase, uint64_t ullOffs, size_t iLength, uchar_t* pvBuf )
+{
+	        int iRes = 0;
+		size_t iRetBlock;
+		xErase.addr = ullOffs;
+		xErase.callback = 0;
+
+		printf("try to rewrite block ...\n");
+		iRes = !pChip->erase( pChip, &xErase );
+		if (!iRes) {
+			printf("NandPattern: erase for rewrite failed\n");
+			return iRes;
+		}
+		
+		iRes = !pChip->write( pChip, ullOffs, iLength, &iRetBlock, pvBuf);
+		if (iRes)
+			printf("NandPattern: rewrite successful\n");
+		else
+			printf("NandPattern: rewrite failed. Maybe this is a bad block.\n");
+		
+		return iRes;
+}
+
+/* ********** local functions ********** */
+
+static int NandPattern(
+        loff_t lStart,
+        size_t iSize,
+        int    iLoop,
+        char   bStopOnError )
+{
+        struct erase_info xErase;
+        nand_info_t*      pChip = &nand_info[ 0 ];
+        uchar_t*          pucBuf    = NULL;
+        uchar_t*          pucBufVer = NULL;
+        loff_t            lAddr;
+        char   bOk         = 0;
+        char   bFailedOnce = 0;
+        int i;
+        
+        CLEAR( xErase );
+
+        xErase.mtd  = pChip;
+        xErase.addr = lStart;
+        xErase.len  = xErase.mtd->erasesize;
+
+        /* prepare data buffer */
+
+        pucBuf    = malloc( xErase.mtd->erasesize );
+        pucBufVer = malloc( xErase.mtd->erasesize );
+        if( ( NULL == pucBuf ) || ( NULL == pucBufVer ) ) {
+                eprintf( "\nOut of Memory for buffer\n" );
+                goto out;
+        }
+
+        /* Each page starts with +1 offset from next.
+         * Each run the test is run +1 from previous run to distinguish from errors*/
+        for( i = 0; i < xErase.len; i++ )
+                pucBuf[ i ] = i + iLoop + ( i / pChip->writesize );
+
+        printf( "Run: % 9id\r", iLoop );
+
+        /* erase region */
+        while( xErase.addr < lStart + iSize ) {
+                if( !pChip->block_isbad( pChip, xErase.addr ) ) {
+                        if( pChip->erase( pChip, &xErase ) ) {
+                                eprintf( "\nErase failed at block 0x%08x\n",
+                                         xErase.addr );
+                                if( bStopOnError )
+                                        goto out;
+                                else
+                                        bFailedOnce = 1;
+                        }
+                }
+                xErase.addr += xErase.mtd->erasesize;
+        } /* while() */
+
+        /* verify each block that it is correctly erased */
+        lAddr = lStart;
+        while( lAddr < lStart + iSize ) {
+                if( !pChip->block_isbad( pChip, lAddr ) ) {
+                        size_t iRetBlock;
+                        loff_t lOffs;
+                        
+                        if( pChip->read( pChip, lAddr, xErase.mtd->erasesize, &iRetBlock, pucBufVer ) ) {
+                                eprintf( "\nRead after erase failed at block 0x%08x\n",
+                                         lAddr );
+                                if( bStopOnError )
+                                        goto out;
+                                else
+                                        bFailedOnce = 1;
+                        }
+                        for( lOffs = 0; lOffs < xErase.mtd->erasesize; lOffs++ ) {
+                                if( 0xff != pucBufVer[ lOffs ] ) {
+                                        eprintf( "\nNot erased @ 0x%08x\n", lAddr );
+                                        MemDump( pucBufVer, lOffs, 64 );
+                                        if( bStopOnError )
+                                                goto out;
+                                        else {
+                                                bFailedOnce = 1;
+                                                break;
+                                        }
+                                }
+                        }
+                }
+                lAddr += xErase.mtd->erasesize;
+        } /* while(  ) */
+
+        /* write each block */
+        lAddr = lStart;
+        while( lAddr < lStart + iSize ) {
+                if( !pChip->block_isbad( pChip, lAddr ) ) {
+                        size_t iRetBlock;
+                        
+                        if( pChip->write( pChip, lAddr, xErase.mtd->erasesize, &iRetBlock, pucBuf ) ) {
+                                eprintf( "\nWrite failed at block 0x%08x\n",
+                                         lAddr );
+				if ( !rewrite( pChip, xErase, lAddr, xErase.mtd->erasesize, pucBuf )){	
+					if( bStopOnError )
+						goto out;
+					else
+						bFailedOnce = 1;
+				}
+			}
+                }
+                lAddr += xErase.mtd->erasesize;
+        } /* while( ) */
+        
+        /* verify each block */
+        lAddr = lStart;
+        while( lAddr < lStart + iSize ) {
+                if( !pChip->block_isbad( pChip, lAddr ) ) {
+                        size_t iRetBlock;
+                        loff_t lOffs;
+                        
+                        if( pChip->read( pChip, lAddr, xErase.mtd->erasesize, &iRetBlock, pucBufVer ) ) {
+                                eprintf( "\nRead failed at block 0x%08x\n",
+                                         lAddr );
+                                if( bStopOnError )
+                                        goto out;
+                                else
+                                        bFailedOnce = 1;
+                        }
+                        lOffs = MemCmp( pucBuf, pucBufVer, xErase.mtd->erasesize );
+                        if( -1 != lOffs ) {
+                                eprintf( "\nDifference @ 0x%08x\n", lAddr );
+                                eprintf( "Original:\n" );
+                                MemDump( pucBuf,    lOffs, 64 );
+                                eprintf( "Flash:\n" );
+                                MemDump( pucBufVer, lOffs, 64 );
+                                if( bStopOnError )
+                                        goto out;
+                                else
+                                        bFailedOnce = 1;
+                        }
+                }
+                lAddr += xErase.mtd->erasesize;
+        } /* while(  ) */
+
+        bOk = !bFailedOnce;
+
+out:
+        printf( "\r" );
+
+        if( NULL != pucBuf )
+                free( pucBuf );
+        if( NULL != pucBufVer )
+                free( pucBufVer );
+
+        return bOk;
+}
+
+/*! \brief Writes a  */
+static int do_testhw_nand_pattern( int argc, char* argv[] )
+{
+        loff_t lStart;
+        size_t iLength;
+        int    iCount;
+        char   bStopOnError = 0;
+        char   bOk   = 1;
+        int    iLoop = 1;
+	long check_val;
+        
+        DVTReset();
+
+        if( ( argc < 3 ) || ( argc > 4 ) ) {
+                eprintf( "Usage: nand_pattern %s\n", USAGE );
+                goto error;
+        }
+
+#ifndef CONFIG_MTD_NAND_VERIFY_WRITE
+        printf( "Write Verification without ECC is disabled\n" );
+#endif
+        
+        lStart  = get_input(argv[ 0 ]);
+        iLength = get_input(argv[ 1 ]);
+	if((long) lStart == -1 || (long) iLength == -1)
+		return 0;
+        iCount  = simple_strtoul( argv[ 2 ], NULL, 10 );
+        if( argc == 4 ) {
+                check_val = get_input(argv[ 3 ]);
+		if(check_val == -1)
+			return 0;
+		bStopOnError = (char) check_val;
+	}
+
+        while( !iCount || ( iLoop <= iCount ) ) {
+                if( !NandPattern( lStart, iLength, iLoop, bStopOnError ) ) {
+                        bOk = 0;
+                        if( bStopOnError )
+                                break;
+                }
+
+                if( ctrlc() ) {
+                        clear_ctrlc();
+                        printf( "\nAborted by User\n" );
+                        break;
+                }
+                
+                iLoop++;
+        }
+
+        printf( "\n" );
+
+        if( DVTError() )
+                goto error;
+
+        return bOk;
+
+error:
+        
+        return 0;
+}
+
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( nand_pattern, USAGE );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW))*/
+
+
diff --git a/common/digi/cmd_testhw/common/nor.c b/common/digi/cmd_testhw/common/nor.c
new file mode 100644
index 0000000..64b9f76
--- /dev/null
+++ b/common/digi/cmd_testhw/common/nor.c
@@ -0,0 +1,243 @@
+/*
+ *  common/digi/cmd_testhw/common/nor.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Implements commands:
+ *                   nor_pattern <start> <size> <loop>
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) && \
+    (CONFIG_COMMANDS & CFG_CMD_FLASH) && \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW)
+
+#include <nvram_types.h>        /* CLEAR */
+#include <mtd.h>                /* MemDump */
+#include <dvt.h>                /* DVTError */
+#include <mtd.h>
+
+#include <cmd_testhw/testhw.h>
+
+#define USAGE "<start> <size> <count> [<stop_on_error>]"     
+
+#define CHIP 0 /* BOOT */
+
+/* ********** local functions ********** */
+
+static int NORPattern(
+        loff_t lStart,
+        size_t iSize,
+        int    iLoop,
+        char   bStopOnError )
+{
+        uchar_t* pucBuf    = NULL;
+        uchar_t* pucBufVer = NULL;
+        char     bOk         = 0;
+        char     bFailedOnce = 0;
+        loff_t   lEnd        = lStart + iSize;
+        size_t   iMaxEraseSize;
+        loff_t   lAddr;
+        int i;
+
+        /* determine maximum erase size of area */
+        iMaxEraseSize = 0;
+        lAddr = lStart;
+        while( lAddr < lEnd ) {
+                size_t iEraseSize = MtdGetEraseSize( CHIP, lAddr );
+
+                if( iMaxEraseSize < iEraseSize )
+                        iMaxEraseSize = iEraseSize;
+                lAddr += iEraseSize;
+        }
+        
+        /* prepare data buffer */
+
+        pucBuf    = malloc( iMaxEraseSize );
+        pucBufVer = malloc( iMaxEraseSize );
+        if( ( NULL == pucBuf ) || ( NULL == pucBufVer ) ) {
+                eprintf( "\nOut of Memory for buffer\n" );
+                goto out;
+        }
+
+        /* Each run the test is run +1 from previous run to distinguish from errors*/
+        for( i = 0; i < iMaxEraseSize; i++ )
+                pucBuf[ i ] = i + iLoop;
+
+        printf( "Run: % 9id\r", iLoop );
+
+        lAddr = lStart;
+        /* erase region */
+        while( lAddr < lEnd ) {
+                size_t iEraseSize = MtdGetEraseSize( CHIP, lAddr );
+                if( !MtdErase( CHIP, lAddr, iEraseSize ) ) {
+                        eprintf( "\nErase failed at block 0x%08x\n", lAddr );
+                        if( bStopOnError )
+                                goto out;
+                        else
+                                bFailedOnce = 1;
+                }
+                lAddr += iEraseSize;
+        } /* while() */
+
+        /* verify each block that it is correctly erased */
+        lAddr = lStart;
+        while( lAddr < lEnd ) {
+                loff_t lOffs;
+                size_t iEraseSize = MtdGetEraseSize( CHIP, lAddr );
+                
+                if( !MtdRead( CHIP, lAddr, iEraseSize, pucBufVer ) ) {
+                        eprintf( "\nRead after erase failed at block 0x%08x\n",
+                                 lAddr );
+                        if( bStopOnError )
+                                goto out;
+                        else
+                                bFailedOnce = 1;
+                }
+                for( lOffs = 0; lOffs < iEraseSize; lOffs++ ) {
+                        if( 0xff != pucBufVer[ lOffs ] ) {
+                                eprintf( "\nNot erased @ 0x%08x\n", lAddr );
+                                MemDump( pucBufVer, lOffs, 64 );
+                                if( bStopOnError )
+                                        goto out;
+                                else {
+                                        bFailedOnce = 1;
+                                        break;
+                                }
+                        }
+                }
+                lAddr += iEraseSize;
+        } /* while(  ) */
+
+        /* write each block */
+        lAddr = lStart;
+        while( lAddr < lEnd ) {
+                size_t iEraseSize = MtdGetEraseSize( CHIP, lAddr );
+                if( !MtdWrite( CHIP, lAddr, iEraseSize, pucBuf ) ) {
+                        eprintf( "\nWrite failed at block 0x%08x\n",
+                                 lAddr );
+                        if( bStopOnError )
+                                goto out;
+                        else
+                                bFailedOnce = 1;
+                }
+                lAddr += iEraseSize;
+        } /* while( ) */
+        
+        /* verify each block */
+        lAddr = lStart;
+        while( lAddr < lEnd ) {
+                loff_t lOffs;
+                
+                size_t iEraseSize = MtdGetEraseSize( CHIP, lAddr );
+                if( !MtdRead( CHIP, lAddr, iEraseSize, pucBufVer ) ) {
+                        eprintf( "\nRead failed at block 0x%08x\n",
+                                 lAddr );
+                        if( bStopOnError )
+                                goto out;
+                        else
+                                bFailedOnce = 1;
+                }
+                lOffs = MemCmp( pucBuf, pucBufVer, iEraseSize );
+                if( -1 != lOffs ) {
+                        eprintf( "\nDifference @ 0x%08x\n", lAddr );
+                        eprintf( "Original:\n" );
+                        MemDump( pucBuf,    lOffs, 64 );
+                        eprintf( "Flash:\n" );
+                        MemDump( pucBufVer, lOffs, 64 );
+                        if( bStopOnError )
+                                goto out;
+                        else
+                                bFailedOnce = 1;
+                }
+                lAddr += iEraseSize;
+        } /* while(  ) */
+
+        bOk = !bFailedOnce;
+
+out:
+        printf( "\r" );
+
+        if( NULL != pucBuf )
+                free( pucBuf );
+        if( NULL != pucBufVer )
+                free( pucBufVer );
+
+        return bOk;
+}
+
+/*! \brief Writes a test pattern to flash and verifies it */
+static int do_testhw_nor_pattern( int argc, char* argv[] )
+{
+        loff_t lStart;
+        size_t iLength;
+        int    iCount;
+        char   bStopOnError = 0;
+        char   bOk   = 1;
+        int    iLoop = 1;
+        long check_val;
+
+        DVTReset();
+
+        if( ( argc < 3 ) || ( argc > 4 ) ) {
+                eprintf( "Usage: nor_pattern %s\n", USAGE );
+                goto error;
+        }
+
+        lStart  = get_input(argv[ 0 ]);
+        iLength = get_input(argv[ 1 ]);
+	if((long) lStart == -1 || (long) iLength == -1)
+		return 0;
+        iCount  = simple_strtoul( argv[ 2 ], NULL, 10 );
+        if( argc == 4 ) {
+                check_val = get_input(argv[ 3 ]);
+		if(check_val == -1)
+			return 0;
+		bStopOnError = (char) check_val;
+	}
+
+        while( !iCount || ( iLoop <= iCount ) ) {
+                if( !NORPattern( lStart, iLength, iLoop, bStopOnError ) ) {
+                        bOk = 0;
+                        if( bStopOnError )
+                                break;
+                }
+
+                if( ctrlc() ) {
+                        clear_ctrlc();
+                        printf( "\nAborted by User\n" );
+                        break;
+                }
+                
+                iLoop++;
+        }
+
+        printf( "\n" );
+
+        if( DVTError() )
+                goto error;
+
+        return bOk;
+
+error:
+        
+        return 0;
+}
+
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( nor_pattern, USAGE );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW))*/
+
+
diff --git a/common/digi/cmd_testhw/common/time.c b/common/digi/cmd_testhw/common/time.c
new file mode 100644
index 0000000..6bc5281
--- /dev/null
+++ b/common/digi/cmd_testhw/common/time.c
@@ -0,0 +1,124 @@
+/*
+ *  common/digi/cmd_testhw/common/time.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Implements commands:
+ *                   udelay : Trigger LED for measuring exact times and wait
+ *                            using udelay
+ *                   sleep  : Triger LED for measuring and wait in s using
+ *                            system timer
+ *               On ns9xxx, 2 different timers are used, one for udelay, one
+ *                            for system
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CONFIG_STATUS_LED)
+
+#include <status_led.h>
+#include <cmd_testhw/testhw.h>
+
+/* ********** local functions ********** */
+
+/* we need also the GPIO because we use __led_set directly for improved
+ * precision in udelay */
+#if defined( STATUS_LED_BIT3 )
+# define GPIO STATUS_LED_BIT3
+#elif defined( STATUS_LED_BIT2 )
+# define GPIO STATUS_LED_BIT2
+#elif defined( STATUS_LED_BIT1 )
+# define GPIO STATUS_LED_BIT1
+#elif defined( STATUS_LED_BIT )
+# define GPIO STATUS_LED_BIT
+#else
+# error Need STATUS_LED_BIT set
+#endif
+
+/**
+ * do_testhw_udelay - trigger and wait us
+ */
+static int do_testhw_udelay( int argc, char* argv[] )
+{
+        int iDelay = 1;
+        
+        if( ( argc > 1 ) ) {
+                eprintf( "Usage: udelay <us>\n" );
+                goto error;
+        }
+
+        iDelay  = simple_strtoul( argv[ 0 ], NULL, 10 );
+        printf( "Delaying for %i us. Signal on status LED (GPIO %i)\n", iDelay, GPIO );
+
+        /* disable it */
+        __led_set( GPIO, STATUS_LED_OFF );
+
+        /* enable it for trigger */
+        __led_set( GPIO, STATUS_LED_ON );
+        udelay( iDelay );
+        /* disable it */
+        __led_set( GPIO, STATUS_LED_OFF );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/**
+ * do_testhw_udelay - trigger and wait in seconds
+ */
+static int do_testhw_sleep( int argc, char* argv[] )
+{
+        int iDelay = 1;
+        ulong ulStart;
+        ulong ulWait;
+        
+        if( ( argc > 1 ) ) {
+                eprintf( "Usage: sleep <s>\n" );
+                goto error;
+        }
+
+        iDelay  = simple_strtoul( argv[ 0 ], NULL, 10 );
+        printf( "Sleeping for %i s. Signal on status LED (GPIO %i)\n", iDelay, GPIO );
+
+        ulWait = CFG_HZ * iDelay;
+
+        /* disable it */
+        __led_set( GPIO, STATUS_LED_OFF );
+
+        /* enable it for trigger */
+        __led_set( GPIO, STATUS_LED_ON );
+
+        ulStart = get_timer( 0 );
+        while( get_timer( ulStart ) < ulWait ) {
+                /* wait for timer to expire, do nothing */
+        }
+
+        /* disable it */
+        __led_set( GPIO, STATUS_LED_OFF );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( udelay, "<us>" );
+TESTHW_CMD( sleep,  "<s>"  );
+
+#endif /* (CONFIG_COMMANDS & CFG_CMD_BSP) ... */
+
+
diff --git a/common/digi/cmd_testhw/cpu/cc9m2443_adc.c b/common/digi/cmd_testhw/cpu/cc9m2443_adc.c
new file mode 100644
index 0000000..7a04606
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/cc9m2443_adc.c
@@ -0,0 +1,192 @@
+/*
+ *  common/digi/cmd_testhw/cpu/cc9m2443_adc.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     (defined(CONFIG_CC9M2443) || defined(CONFIG_CCW9M2443)))
+
+#include <cmd_testhw/testhw.h>
+#include <lib/include/nvram_priv.h>  /* CE */
+#include <regs.h>
+#define USAGE	"adc <channel> <delta between samples us> <samples> [<clock kHz>]"
+
+#define ADC_DEFAULT_CLOCK	1000
+#define CHANNELS 9 
+static u32 l_uiChannel = 0;
+
+static inline u32 timeToMS( unsigned long ulTime )
+{
+        return ( ulTime ) / ( CFG_HZ / 1000);
+}
+
+/**
+ * adc_clock_set - sets clock (in Hz) and keeps waitstates
+ */
+static int adc_clock_set( u32 uiClock )
+{
+        u32 uiDiv;
+	
+	if( uiClock < 1000 || uiClock > 2500 ) {
+		eprintf( "The valid range is from 1000 to 2500 KHz.\n" );
+		goto error;
+	}
+        
+	uiDiv = ((get_PCLK() / 1000 ) / uiClock) -1;
+	ADCCON_REG &= ~(0x7F << 6);
+	ADCCON_REG |= (uiDiv & 0x7f) << 6;
+	
+	return 1;
+error:
+	return 0;
+}
+
+/**
+ * adc_clock_get - calculates the current sampling clock
+ */
+static u32 adc_clock_get( void )
+{
+        u32 uiDiv = (ADCCON_REG >> 6) & 0x7F ;
+        u32 uiClock = get_PCLK() / ( uiDiv + 1 );
+
+        return uiClock;
+}
+
+/**
+ * adc_channel_set - will use uiChannel next time and print the pins
+ */
+static int adc_channel_set( u32 uiChannel )
+{
+
+        /* check user input */
+        if(uiChannel > CHANNELS) {
+                eprintf( "Wrong channel, ignoring it\n" );
+                goto error;
+        }
+        
+        l_uiChannel = uiChannel;
+	ADCMUX_REG = (l_uiChannel & 0xF);
+        
+	printf("Using Channel %i\n", l_uiChannel);
+        return 1;
+
+error:
+        return 0;
+}
+
+/**
+ * adc_init - low level initialization
+ */
+static void adc_init( void )
+{
+        static char bAlreadyInitialized = 0;
+        if( bAlreadyInitialized )
+                return;
+
+        bAlreadyInitialized = 1;
+	
+	ADCDLY_REG = 0x1;
+	ADCCON_REG &= ~(STDBM);
+	ADCCON_REG |= (PRSCEN | READ_START);
+}
+
+
+static int adc_series( u32 uiSamples, u32 uiDelta )
+{
+        typedef struct {
+                u32 uiLevel;
+                unsigned long ulTimeStamp;
+        } sample_t;
+        
+        u32 u;
+        ulong ulStart;
+        ulong ulEnd;
+        sample_t* pSampleBase = (sample_t*) malloc( uiSamples * sizeof( sample_t ) );
+        sample_t* pSampleEnd = pSampleBase + uiSamples;
+        sample_t* pSample = pSampleBase;
+
+        if( NULL == pSampleBase ) {
+                eprintf( "Out-Of-Memory\n" );
+                goto error;
+        }
+
+	/* clear the output of adc */	
+	pSample->uiLevel = (ADCDAT0_REG & 0x3FF);
+	udelay(10);
+        
+	/* sample everything first before output */
+        ulStart = get_timer( 0 );
+        
+	for( ; pSample < pSampleEnd; pSample++ ) {
+                pSample->uiLevel     = (ADCDAT0_REG & 0x3FF);
+                pSample->ulTimeStamp = get_timer( ulStart );
+                udelay( uiDelta );
+        }
+        ulEnd = get_timer( ulStart );
+        /* print results */
+        printf( "Overall sampling time: %i ms\n", timeToMS( ulEnd ) );
+
+        pSample = pSampleBase;
+        printf( "Sample,     ms,  Level\n" );
+        for( pSample = pSampleBase, u = 0; pSample < pSampleEnd; u++, pSample++ ) {
+		printf( "%6u, %6u, %6u\n",
+                       u,
+                        timeToMS( pSample->ulTimeStamp),
+                        pSample->uiLevel );
+	}
+        free( pSampleBase );
+        
+        return 1;
+        
+error:
+        return 0;
+}
+
+/**
+ * do_testhw_adc - provides adc commands
+ */
+static int do_testhw_adc( int argc, char* argv[] )
+{
+        u32 uiDelta;
+        u32 uiSamples;
+
+        if( ( argc < 3 ) || ( argc > 4 ) )
+                goto usage;
+
+        
+	CE( adc_channel_set( simple_strtoul( argv[ 0 ], NULL, 10 ) ) );
+        uiDelta   = simple_strtoul( argv[ 1 ], NULL, 10 );
+        uiSamples = simple_strtoul( argv[ 2 ], NULL, 10 );
+        
+	adc_init();
+
+        CE( adc_clock_set( ( argc >= 4 ) ?
+                           simple_strtoul( argv[ 3 ], NULL, 10 ) :
+                           ADC_DEFAULT_CLOCK ) );
+
+        printf( "Current ADC Clock is %i kHz\n",
+                adc_clock_get() / 1000 );
+        adc_series( uiSamples, uiDelta ) ;
+     
+     	return 1;
+
+usage:
+        eprintf( "Usage: %s\n", USAGE );
+
+error:        
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( adc, USAGE );
+
+#endif
diff --git a/common/digi/cmd_testhw/cpu/cc9m2443_lcd.c b/common/digi/cmd_testhw/cpu/cc9m2443_lcd.c
new file mode 100644
index 0000000..413b87a
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/cc9m2443_lcd.c
@@ -0,0 +1,56 @@
+#include <common.h>
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+		defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+		(defined(CONFIG_CC9M2443) || defined(CONFIG_CCW9M2443))) && \
+		defined(CONFIG_LCD)
+DECLARE_GLOBAL_DATA_PTR;
+#include <cmd_testhw/testhw.h>
+#include <regs.h>
+
+#define LOADADDR  0x30200000 /*same like loadaddr */
+extern void lcd_enable( void );
+
+static int do_testhw_lcd( int argc, char* argv[] )
+{
+	const char szCmd [60];
+	int ret, x, y, x2, y2;
+	#ifndef CONFIG_SPLASH_SCREEN
+	extern void lcd_ctrl_init (void *lcdbase);
+	extern void lcd_enable (void);
+	#endif
+
+	if( argc != 1 ) {
+		eprintf( "Usage: lcd image_ name \n" );
+		goto error;
+	}
+	sprintf((char *)szCmd, "tftp 0x%x %s", LOADADDR, argv[ 0 ] );
+	ret = (run_command( szCmd, 0 ) >=  0);
+
+	/* The test image is 320x240 and must be horizontally
+	 * and vertically flipped */
+	u16 data;
+	u16 *pdata = (u16 *)LOADADDR;
+	u16 *plcd;
+	for (y = 239, y2 = 0; y >= 0; y--, y2++) {
+		for (x = 319, x2 = 0; x >= 0; x--, x2++) {
+			data = *(pdata + (y * 320) + x);
+			plcd = (u16 *)(gd->fb_base) + (y2 * 320) + x2;
+			*plcd = data;
+		}
+	}
+
+	if(!ret)
+		goto error;
+
+#ifndef CONFIG_SPLASH_SCREEN
+	lcd_ctrl_init((void *) gd->fb_base);
+#endif
+	lcd_enable();
+	return 1;
+error:
+	return 0;
+}
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( lcd, "loads given image via tftp into framebuffer.");
+#endif
diff --git a/common/digi/cmd_testhw/cpu/cc9m2443_serial.c b/common/digi/cmd_testhw/cpu/cc9m2443_serial.c
new file mode 100644
index 0000000..4a70810
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/cc9m2443_serial.c
@@ -0,0 +1,133 @@
+/*
+ *  common/digi/cmd_testhw/cpu/cc9m2443_serial.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+#include <common.h>
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+		defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+		(defined(CONFIG_CC9M2443) || defined(CONFIG_CCW9M2443)))
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#include <cmd_testhw/testhw.h>
+#include <regs.h>
+#define UART_BASE(x) (ELFIN_UART_BASE + (x * 0x4000)) 
+
+static int test_putc(S3C24X0_UART *uart, const char c)
+{
+	int timeout = 1000;
+	/* wait for room in the tx FIFO */
+	while (!(uart->UTRSTAT & 0x2));
+
+	while (!(uart->UMSTAT & 0x1)&& timeout) {
+		udelay(10);
+		timeout--;
+	}
+
+	if(!timeout) {
+		printf("putc: timeout\n");
+		return 0;
+	}
+	uart->UTXH = c;
+	return 1;
+}
+
+
+static int test_getc(S3C24X0_UART *uart)
+{
+	int timeout = 1000;
+	
+	while (!(uart->UTRSTAT & 0x1) && timeout) {
+		udelay(10);
+		timeout --;
+	}
+	
+	if(!timeout) {
+		printf("getc: timeout\n");
+		return -1;
+	}
+
+	return uart->URXH & 0xff;
+}
+
+static int init_uart(S3C24X0_UART *uart)
+{
+	unsigned int reg = 0;
+	
+	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
+	reg = get_PCLK() / (16 * gd->baudrate) - 1;
+
+	/* FIFO enable, Tx/Rx FIFO clear */
+	uart->UFCON = 0x07;
+	uart->UMCON = 0x0;
+	/* Normal,No parity,1 stop,8 bit */
+	uart->ULCON = 0x3;
+	/*
+	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
+	 * normal,interrupt or polling
+	 */
+	uart->UCON = 0x245;
+	uart->UBRDIV = reg;
+	
+	return 1;
+}
+
+static int do_testhw_serial(int argc, char* argv[])
+{
+	S3C24X0_UART* uart;
+	int i, timeout;
+	char b, a = 0x0;
+
+
+	/* configure gpio RTS CTS Port B and C */
+	GPHCON_REG &= ~(0xf << 20 | 0xfff0);
+	GPHCON_REG |= 0x00a0faa0; 	
+	
+	for (i = 1; i < 3; i++) {
+		uart = S3C24X0_GetBase_UART(i);
+
+		a = 0x0;
+		init_uart(uart);
+
+		/* test RTS signal */
+		uart->UMCON = 0x0;	/* RTS down */
+		timeout = 1000;
+		while (!(uart->UMSTAT & 0x1)&& timeout) {
+			udelay(10);
+			timeout--;
+		}
+		if(timeout) {
+			printf("Error on serial port %d rts/cts does"
+				" not work correct\n", i);
+			return 0;
+		}	
+		uart->UMCON = 0x1;	/* RTS up */
+		
+		while(a != 0xFE) {
+			test_putc(uart, a);
+			b = (char)test_getc(uart);
+			if(b != a) {
+				printf("Error on serial port %d expected"
+					" 0x%x, but getting 0x%x\n", i, a, b);
+				return 0;
+			}
+			a++;
+		}
+	}
+	
+	return 1;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( serial, "Tests serial ports B and C with loopback\n"
+		"Jumper J4 and J5 has to be set to 1-2 to enable rts/cts port C.");
+
+#endif
+
diff --git a/common/digi/cmd_testhw/cpu/cc9p9215_lcd.c b/common/digi/cmd_testhw/cpu/cc9p9215_lcd.c
new file mode 100644
index 0000000..9ff219d
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/cc9p9215_lcd.c
@@ -0,0 +1,170 @@
+/*common/digi/cmd_testhw/cpu/cc9p9215_lcd.c
+ * Init part taken from
+ * http://www.trulydisplays.com/tft/specs/TFT IC Spec for -148W Himax HX8347.pdf
+ */
+
+#include <common.h>
+#include <asm-arm/io.h>
+#include <asm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm/arch-ns9xxx/io.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+		defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+		(defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)))
+
+#include <cmd_testhw/testhw.h>
+
+#define LOADADDR  0x200000 /*same like loadaddr */
+#define LCD_CS_OFFSET	0x40000000
+#define	LCD_POINTER	LCD_CS_OFFSET
+#define LCD_DATA	(LCD_CS_OFFSET + 2)
+#define RESET_GPIO	86
+static void write_lcd_reg(uint addr, uint data)
+{
+	writew(addr, LCD_POINTER);
+	writew(data, LCD_DATA);
+}
+
+static void mdelay(int count)
+{
+	for(;count != 0;count--)
+		udelay(1000);
+}
+
+static int do_testhw_lcd( int argc, char* argv[] )
+{
+const char szCmd [60];
+int ret, x, y;
+
+if( argc != 1 ) {
+	eprintf( "Usage: lcd image_ name \n" );
+	goto error;
+}
+
+sprintf((char *)szCmd, "tftp 0x%x %s", LOADADDR, argv[ 0 ] );
+ret = (run_command( szCmd, 0 ) >=  0);
+if(!ret)
+	goto error;
+
+	/* setup chipselect */
+	writel(0x3,   0xa0700080);
+	writel(0x181, 0xa0700200);
+	writel(0x4,   0xa0700204);
+	writel(0x0,   0xa0700208);
+	writel(0x0,   0xa070020c);
+	writel(0x0,   0xa0700210);
+	writel(0x0,   0xa0700214);
+	writel(0x0,   0xa0700218);
+
+	/* RESET */
+	gpio_cfg_set(RESET_GPIO, GPIO_CFG_FUNC_GPIO | GPIO_CFG_OUTPUT);
+	gpio_ctrl_set(RESET_GPIO, 0);
+	mdelay(150);   /* After Inter-MicroP Program (load OTP) */
+	gpio_ctrl_set(RESET_GPIO, 1);
+
+	mdelay(50);   /* After Inter-MicroP Program (load OTP) */
+	writew(0x22, LCD_POINTER);
+
+	/* Gamma for CMO 2.8 */
+	write_lcd_reg(0x46,0x94);
+	write_lcd_reg(0x47,0x41);
+	write_lcd_reg(0x48,0x00);
+	write_lcd_reg(0x49,0x33);
+	write_lcd_reg(0x4A,0x23);
+	write_lcd_reg(0x4B,0x45);
+	write_lcd_reg(0x4C,0x44);
+	write_lcd_reg(0x4D,0x77);
+	write_lcd_reg(0x4E,0x12);
+	write_lcd_reg(0x4F,0xCC);
+	write_lcd_reg(0x50,0x46);
+	write_lcd_reg(0x51,0x82);
+
+	/* 240x320 window setting */
+	write_lcd_reg(0x02,0x00); /* Column address start2 */
+	write_lcd_reg(0x03,0x00); /* Column address start1 */
+	write_lcd_reg(0x04,0x01); /* Column address end2 */
+	write_lcd_reg(0x05,0x3F); /* Column address end1 */
+	write_lcd_reg(0x06,0x00); /* Row address start2 */
+	write_lcd_reg(0x07,0x00); /* Row address start1 */
+	write_lcd_reg(0x08,0x00); /* Row address end2 */
+	write_lcd_reg(0x09,0xEF); /* Row address end1 */
+
+	/* Display Setting */
+	write_lcd_reg(0x01,0x06); /* IDMON=0, INVON=1, NORON=1, PTLON=0 */
+	write_lcd_reg(0x16,0x68); /* MY=0, MX=0, MV=0, ML=1, BGR=0, TEON=0 */
+
+	write_lcd_reg(0x23,0x95); /* N_DC=1001 0101 */
+	write_lcd_reg(0x24,0x95); /* P_DC=1001 0101 */
+	write_lcd_reg(0x25,0xFF); /* I_DC=1111 1111 */
+
+	write_lcd_reg(0x27,0x02); /* N_BP=0000 0110 */
+	write_lcd_reg(0x28,0x02); /* N_FP=0000 0110 */
+	write_lcd_reg(0x29,0x02); /* P_BP=0000 0110 */
+	write_lcd_reg(0x2A,0x02); /* P_FP=0000 0110 */
+	write_lcd_reg(0x2C,0x02); /* I_BP=0000 0110 */
+	write_lcd_reg(0x2D,0x02); /* I_FP=0000 0110 */
+	write_lcd_reg(0x3A,0x01); /* N_RTN=0000, N_NW=001 */
+	write_lcd_reg(0x3B,0x01); /* P_RTN=0000, P_NW=000 */
+	write_lcd_reg(0x3C,0xF0); /* I_RTN=1111, I_NW=000 */
+	write_lcd_reg(0x3D,0x00); /* DIV=00 */
+	mdelay(20);
+	write_lcd_reg(0x35,0x38); /* EQS=38h */
+	write_lcd_reg(0x36,0x78); /* EQP=78h */
+	write_lcd_reg(0x3E,0x38); /* SON=38h */
+	write_lcd_reg(0x40,0x0F); /* GDON=0Fh */
+	write_lcd_reg(0x41,0xF0); /* GDOFF */
+
+	/* Power Supply Setting */
+	write_lcd_reg(0x19,0x49); /* OSCADJ=10 0000, OSD_EN=1 60Hz */
+	write_lcd_reg(0x93,0x0F); /* RADJ=1100 */
+	mdelay(10);
+	write_lcd_reg(0x20,0x40); /* BT=0100 */
+	write_lcd_reg(0x1D,0x07); /* VC1=111 */
+	write_lcd_reg(0x1E,0x00); /* VC3=000 */
+	write_lcd_reg(0x1F,0x04); /* VRH=0100 */
+
+	/* VCOM Setting for CMO 2.8 Panel */
+	write_lcd_reg(0x44,0x40);     /* VCM=101 0000 */
+	write_lcd_reg(0x45,0x12);     /* VDV=1 0001 */
+	mdelay(10);
+	write_lcd_reg(0x1C,0x04);     /* AP=100 */
+	mdelay(20);
+	write_lcd_reg(0x43,0x80);     /* Set VCOMG=1 */
+	mdelay(5);
+	write_lcd_reg(0x1B,0x08);     /* GASENB=0, PON=1, DK=1, XDK=0,
+					 DDVDH_TRI=0, STB=0 */
+	mdelay(40);
+	write_lcd_reg(0x1B,0x10);     /* GASENB=0, PON=1, DK=0, XDK=0,
+					 DDVDH_TRI=0, STB=0*/
+	mdelay(40);
+	/* Display ON Setting */
+	write_lcd_reg(0x90,0x7F);     /* SAP=0111 1111 */
+	write_lcd_reg(0x26,0x04);     /* GON=0, DTE=0, D=01 */
+	mdelay(40);
+	write_lcd_reg(0x26,0x24);     /* GON=1, DTE=0, D=01 */
+	write_lcd_reg(0x26,0x2C);     /* GON=1, DTE=0, D=11 */
+	mdelay(40);
+	write_lcd_reg(0x26,0x3C);     /* GON=1, DTE=1, D=11 */
+	write_lcd_reg(0x57,0x02);     /* GON=1, DTE=1, D=11 */
+	write_lcd_reg(0x55,0x00);     /* GON=1, DTE=1, D=11 */
+	write_lcd_reg(0x57,0x00);     /* GON=1, DTE=1, D=11 */
+
+	writew(0x22, LCD_POINTER);
+	u16 data;
+	u16 *pdata = (u16 *)LOADADDR;
+	for (y = 239; y >= 0; y--) {
+		for (x = 319; x >= 0; x--) {
+
+			data = *(pdata + (y * 320) + x);
+			writew(data, LCD_DATA);
+		}
+	}
+
+	return 1;
+error:
+return 0;
+}
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( lcd, "loads given image via tftp into framebuffer.");
+#endif
diff --git a/common/digi/cmd_testhw/cpu/ns9215_adc.c b/common/digi/cmd_testhw/cpu/ns9215_adc.c
new file mode 100644
index 0000000..dfae1b1
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns9215_adc.c
@@ -0,0 +1,260 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns9215_adc.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides commands:
+ *                 adc
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS9215))
+
+#include <cmd_testhw/testhw.h>
+#include <lib/include/nvram_priv.h>  /* CE */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns9215_adc.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* adc_readl */
+
+#define USAGE	"adc <channel> <delta between samples us> <samples> [<clock kHz>]"
+
+#define ADC_DEFAULT_CLOCK	14000000
+#define ADC_DEFAULT_WAIT_EXT	0
+
+static u32 l_uiChannel = 0;
+
+static inline u32 timeToMS( unsigned long ulTime )
+{
+        return ( 1000 * ulTime ) / CFG_HZ;
+}
+
+/**
+ * adc_int_clear - clears the interrupt to be able to detect new samples
+ */
+
+static inline void adc_int_clear( void )
+{
+        adc_rmw32( ADC_CFG, | ADC_CFG_INTCLR );
+        adc_rmw32( ADC_CFG, & (~ADC_CFG_INTCLR) );
+}
+
+/**
+ * adc_clock_wait_set - sets clock (in Hz) and waitstates
+ */
+static void adc_clock_wait_set( u32 uiClock, u32 uiWait )
+{
+        u32 uiDiv = ( ( sys_clock_freq() / uiClock ) - 1 ) / 2;
+
+        adc_writel( ADC_CLOCK_CFG_N_SET( uiDiv ) |
+                       ADC_CLOCK_CFG_WAIT_SET( uiWait ), ADC_CLOCK_CFG );
+}
+
+/**
+ * adc_clock_set - sets clock (in Hz) and keeps waitstates
+ */
+static int adc_clock_set( u32 uiClock )
+{
+        if( !uiClock ) {
+                eprintf( "0 Hz not allowed\n" );
+                goto error;
+        }
+        
+        adc_clock_wait_set( uiClock,
+                            ADC_CLOCK_CFG_WAIT_GET( adc_readl( ADC_CLOCK_CFG ) ) );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/**
+ * adc_clock_get - calculates the current sampling clock
+ */
+static u32 adc_clock_get( void )
+{
+        u32 uiDiv = ADC_CLOCK_CFG_N_GET( adc_readl( ADC_CLOCK_CFG ) );
+        u32 uiClock = sys_clock_freq() / ( 2 * ( uiDiv + 1 ) );
+
+        return uiClock;
+}
+
+/**
+ * adc_level - returns the level after the next sampling
+ */
+static inline u32 adc_level( void )
+{
+        /* wait until the channel has been latched into output register */
+        do {
+                adc_int_clear();
+        } while( ADC_CFG_INTSTAT( adc_readl( ADC_CFG ) ) != l_uiChannel );
+
+        /* return the sample */
+        return adc_readl( ADC_OUTPUT( l_uiChannel ) );
+}
+
+/**
+ * adc_channel_set - will use uiChannel next time and print the pins
+ */
+static int adc_channel_set( u32 uiChannel )
+{
+#define MK( ch, szPin ) [ ch ] = szPin
+        static const char* aszPin[ 8 ] = {
+                MK( 0, "X21-C17" ),
+                MK( 1, "X21-D17" ),
+                MK( 2, "X20-A18" ),
+                MK( 3, "X20-B18" ),
+                MK( 4, "X21-C18" ),
+                MK( 5, "X21-D18" ),
+                MK( 6, "X20-A19" ),
+                MK( 7, "X20-B19" ),
+        };
+#undef MK
+
+        /* check user input */
+        if( l_uiChannel >= ARRAY_SIZE( aszPin ) ) {
+                eprintf( "Wrong channel, ignoring it" );
+                goto error;
+        }
+        
+        l_uiChannel = uiChannel;
+
+        /* avoig FAQ "where the heck is that channel" */
+        printf( "Using Channel %i on JumpStart %s\n",
+                l_uiChannel, aszPin[ l_uiChannel ] );
+
+        return 1;
+
+error:
+        return 0;
+}
+
+/**
+ * adc_init - low level initialization
+ */
+static void adc_init( void )
+{
+        static char bAlreadyInitialized = 0;
+
+        if( bAlreadyInitialized )
+                return;
+
+        bAlreadyInitialized = 1;
+
+        /* power it on */ 
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_ADC );
+        sys_rmw32( SYS_RESET, | SYS_RESET_ADC );
+
+        /* configure ADC */
+        adc_writel( ADC_CFG_EN     |
+                       ADC_CFG_INTCLR |
+                       ADC_CFG_SEL_SET( 0x7 ), ADC_CFG );
+        adc_clock_wait_set( ADC_DEFAULT_CLOCK, ADC_DEFAULT_WAIT_EXT );
+
+        adc_int_clear();
+
+        printf( "Ensure that VREF_ADC is connected (X21-D19), e.g. to 3.3V (X20-A20)\n" );
+
+        adc_channel_set( 0 );
+}
+
+static int adc_series( u32 uiSamples, u32 uiDelta )
+{
+        typedef struct {
+                u32 uiLevel;
+                unsigned long ulTimeStamp;
+        } sample_t;
+        
+        u32 u;
+        ulong ulStart;
+        ulong ulEnd;
+        sample_t* pSampleBase = (sample_t*) malloc( uiSamples * sizeof( sample_t ) );
+        sample_t* pSampleEnd = pSampleBase + uiSamples;
+        sample_t* pSample;
+
+        if( NULL == pSampleBase ) {
+                eprintf( "Out-Of-Memory\n" );
+                goto error;
+        }
+
+        /* sample everything first before output */
+        ulStart = get_timer( 0 );
+        for( pSample = pSampleBase; pSample < pSampleEnd; pSample++ ) {
+                pSample->uiLevel     = adc_level();
+                pSample->ulTimeStamp = get_timer( ulStart );
+                udelay( uiDelta );
+        }
+        ulEnd = get_timer( ulStart );
+
+        /* print results */
+        printf( "Overall sampling time: %i ms\n", timeToMS( ulEnd ) );
+
+        pSample = pSampleBase;
+        printf( "Sample,     ms,  Level\n" );
+        for( pSample = pSampleBase, u = 0; pSample < pSampleEnd; u++, pSample++ )
+                printf( "%6u, %6u, %6u\n",
+                        u,
+                        timeToMS( pSample->ulTimeStamp ),
+                        pSample->uiLevel );
+
+        free( pSampleBase );
+        
+        return 1;
+        
+error:
+        return 0;
+}
+
+/**
+ * do_testhw_adc - provides adc commands
+ */
+static int do_testhw_adc( int argc, char* argv[] )
+{
+        u32 uiDelta;
+        u32 uiSamples;
+        
+        adc_init();
+
+        if( ( argc < 3 ) || ( argc > 4 ) )
+                goto usage;
+
+        CE( adc_channel_set( simple_strtoul( argv[ 0 ], NULL, 10 ) ) );
+        uiDelta   = simple_strtoul( argv[ 1 ], NULL, 10 );
+        uiSamples = simple_strtoul( argv[ 2 ], NULL, 10 );
+
+        CE( adc_clock_set( ( argc >= 4 ) ?
+                           simple_strtoul( argv[ 3 ], NULL, 10 ) * 1000 :
+                           ADC_DEFAULT_CLOCK ) );
+
+        printf( "Current ADC Clock is %i kHz\n",
+                adc_clock_get() / 1000 );
+        CE( adc_series( uiSamples, uiDelta ) );
+        
+        return 1;
+
+usage:
+        eprintf( "Usage: %s\n", USAGE );
+
+error:        
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( adc, USAGE );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS921X))*/
+
diff --git a/common/digi/cmd_testhw/cpu/ns921x.c b/common/digi/cmd_testhw/cpu/ns921x.c
new file mode 100644
index 0000000..bbc474a
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns921x.c
@@ -0,0 +1,70 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns921x.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Implements NS921x specific commands
+ *                  watchdog_reset
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS921X))
+
+#include <cmd_testhw/testhw.h>
+
+#include "asm-arm/arch-ns9xxx/ns921x_sys.h"
+#include "asm-arm/arch-ns9xxx/io.h"
+
+/* ********** local functions ********** */
+
+/*! \return never */
+static void TriggerWatchdogResetAndWait( void )
+{
+        sys_writel( 0x1, SYS_SW_WDOG_TIMER );
+
+        /* trigger watchdog for immediately reset */
+        sys_writel( SYS_SW_WDOG_CFG_SWWE  |
+                       SYS_SW_WDOG_CFG_SWWIC |
+                       SYS_SW_WDOG_CFG_SWTCS_2,
+                       SYS_SW_WDOG_CFG );
+
+        while( 1 ) {
+                /* do nothing, wait for reset */
+        }
+
+        /* never reached */
+}
+
+/*! \brief resets the system */
+/*! It will never return */
+static int do_testhw_watchdog_reset( int argc, char* argv[] )
+{
+        printf( "Resetting system\n" );
+
+        serial_tx_flush();
+
+        TriggerWatchdogResetAndWait();
+
+        /* never reached  */
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( watchdog_reset,
+            "Performs a watchdog reset" );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS921X))*/
+
+
diff --git a/common/digi/cmd_testhw/cpu/ns921x_powersave.c b/common/digi/cmd_testhw/cpu/ns921x_powersave.c
new file mode 100644
index 0000000..5023c13
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns921x_powersave.c
@@ -0,0 +1,153 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns921x_powersave.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides commands:
+ *                 powersave
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS921X))
+
+#include <cmd_testhw/testhw.h>
+
+#include <asm-arm/proc-armv/system.h>  /* local_irq_enable */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* sys_readl */
+
+#include <status_led.h>         /* must be included after our io.h */
+
+#define GPIO_WAKEUP	4
+#define EXT_INT_WAKEUP	2
+
+/**
+ * wakeup_irq_ack - acknowledges the wakeup irq on all aspects. 
+ */
+static void wakeup_irq_ack( void )
+{
+        /* ack edge sensitive irq */
+        sys_rmw32( SYS_EXT_INT_CTRL( EXT_INT_WAKEUP ), | SYS_EXT_INT_CTRL_CLR );
+        sys_rmw32( SYS_EXT_INT_CTRL( EXT_INT_WAKEUP ), & ~SYS_EXT_INT_CTRL_CLR );
+
+        /* ack wake IRQ */
+        sys_rmw32( SYS_POWER, | SYS_POWER_WAKE_INT_CLR );
+        sys_rmw32( SYS_POWER, & ~SYS_POWER_WAKE_INT_CLR );
+
+        /* ack irq, will be done in linux automatically */
+        sys_writel( 0, SYS_ISADDR );
+}
+
+/**
+ * wakeup_irq_handler - system is up again
+ */
+static void wakeup_irq_handler( void* pvData )
+{
+        wakeup_irq_ack();
+
+        /* light LED here so we know that CPU is up even if something later the
+         * initialization might fail */
+        status_led_set( STATUS_LED_BOOT, STATUS_LED_ON );
+}
+
+/**
+ * do_testhw_powersave - sleeps until wakeup is pressed
+ */
+static int do_testhw_powersave( int argc, char* argv[] )
+{
+        u32 uiClock;
+        u32 uiTimer;
+        unsigned long ulFlags;
+
+        /* prepare going down */
+        printf( "I'll be back if you press \"Wakeup\".\n"
+                "You shouldn't have anything connected on Serial Port A\n" );
+
+        serial_tx_flush();      /* we are going down really fast */
+
+        gpio_cfg_set( GPIO_WAKEUP, GPIO_CFG_FUNC_1 );
+
+        /* wakeup emits an interrupt. Prepare to handle it. */
+        irq_install_handler( SYS_ISD_WAKEUP, wakeup_irq_handler, NULL );
+        /* configure int 0 directly until we have have a fully implemented
+         * irq_install_handler */
+        sys_writel( SYS_EXT_INT_CTRL_PLTY_L |
+                       SYS_EXT_INT_CTRL_EDGE, SYS_EXT_INT_CTRL( EXT_INT_WAKEUP ) );
+        /* don't know the state yet. Acknowledge so it doesn't raise the
+         * interrupt to early */
+        wakeup_irq_ack();
+
+        /* prepare IRQ */
+        sys_writel( 0, SYS_INT_VEC_ADR_BASE );
+        sys_writel( ( SYS_INT_CFG_IE  |
+                         SYS_INT_CFG_IRQ |
+                         SYS_INT_CFG_ISD( SYS_ISD_WAKEUP ) ) << 24, SYS_INT_CFG_BASE );
+
+        local_save_flags( ulFlags );
+        local_irq_enable();
+
+        /*
+         * now put everything that is possible into sleep. Note that we don't
+         * put ETH Phy into reset mode on purpose. */
+
+        /* disable timer */
+        uiTimer = sys_readl( SYS_TIMER_MASTER_CTRL );
+        sys_writel( 0, SYS_TIMER_MASTER_CTRL );
+
+        uiClock = sys_readl( SYS_CLOCK );
+
+        /* reduce power and clock */
+        sys_writel( SYS_POWER_SELF_REFRESH |
+                       SYS_POWER_HW_CLOCK     |
+                       SYS_POWER_WAKE_INT_EXT( EXT_INT_WAKEUP ),
+                       SYS_POWER );
+
+        sys_writel( SYS_CLOCK_CSC_16     |
+                       SYS_CLOCK_MAX_CSC_16 |
+                       SYS_CLOCK_MCCOUT( 0 ), SYS_CLOCK );
+
+        status_led_set( STATUS_LED_BOOT, STATUS_LED_OFF );
+
+        /* sleep until someone pressed wakeup */
+        asm volatile(
+                "mcr p15, 0, %0, c7, c0, 4"
+                :
+                : "r" ( 0 ) );
+
+        /* go back into running mode */
+        sys_writel( 0, SYS_POWER );
+
+        /* restore modules clocks */
+        sys_writel( uiClock, SYS_CLOCK );
+        sys_writel( uiTimer, SYS_TIMER_MASTER_CTRL );
+
+        sys_writel( 0, SYS_INT_CFG_BASE );
+        irq_free_handler( SYS_ISD_WAKEUP );
+        local_irq_restore( ulFlags );
+
+        /* don't need wakeup any longer */
+        gpio_cfg_set( GPIO_WAKEUP, GPIO_CFG_FUNC_GPIO );
+
+        return 1;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( powersave, "sleeps CPU and waits for wakeup event" );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS921X))*/
+
diff --git a/common/digi/cmd_testhw/cpu/ns921x_rtc.c b/common/digi/cmd_testhw/cpu/ns921x_rtc.c
new file mode 100644
index 0000000..70ad376
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns921x_rtc.c
@@ -0,0 +1,120 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns921x_rtc.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides:
+ *                 rtc: Checks rtc clock accuracy against system clock
+ *                      System clock has to be checked first
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS921X) && \
+     defined(CONFIG_RTC_NS921X))
+
+#include <cmd_testhw/testhw.h>
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_rtc.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* sys_readl */
+
+#define AHB_CLOCK_TIMER		5
+
+/* from rtc/ns921x_rtc. */
+extern void rtc_lowlevel_init( void );
+
+/**
+ * rtc_wait_for_second_toggle - waits until the RTC tells one second has elpased
+ */
+static inline void rtc_wait_for_second_toggle( void )
+{
+        while( ! ( rtc_readl( RTC_EVENT ) & RTC_EVENT_SEC ) ) {
+                /* wait for second to elapse */
+        }
+}
+
+/**
+ * rtc_calc_and_print_deviation - determine RTC deviation based on AHB clock
+ */
+static void rtc_calc_and_print_deviation( void )
+{
+        u32 uiAHBTicks;
+        int iDelta;
+        int iPPM;
+
+        /* the event field might be already set. clear it to wait for next
+         * second. */
+        rtc_readl( RTC_EVENT );
+        
+        rtc_wait_for_second_toggle();
+        /* go, go, go */
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) );
+        /* now measure how long a second is */
+        rtc_wait_for_second_toggle();
+
+        /* get elapses uiAHBTicks. */
+        uiAHBTicks = sys_readl( SYS_TIMER_READ( AHB_CLOCK_TIMER ) );
+
+        /* calculate deviation in ppm */
+        iDelta = uiAHBTicks - ahb_clock_freq();
+
+        /* use floats to avoid integer overflow at 2^31 */
+        iPPM = ( ( (float ) iDelta ) * 1000000 ) / ahb_clock_freq();
+        if( iPPM < 0 )
+                iPPM = -iPPM;
+        
+        printf( "Deviation is %i ticks = %i ppm relative to system clock accuracy\n",
+                iDelta, iPPM );
+}
+
+/**
+ * do_testhw_rtc - checks clock accuracy
+ */
+static int do_testhw_rtc( int argc, char* argv[] )
+{
+        /* prepare timer. AHB_CLOCK_TIMER counts all AHB clocks until
+         * rtc reports 1s elapsed. */
+
+        /* don't know the state. Ensure it doesn't start counting immediately*/
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   & ~SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) );
+
+        sys_writel( 0, SYS_TIMER_RELOAD( AHB_CLOCK_TIMER ) );
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                       SYS_TIMER_CTRL_TCS_1    |
+                       SYS_TIMER_CTRL_TM_INT   |
+                       SYS_TIMER_CTRL_UP       |
+                       SYS_TIMER_CTRL_32,
+                       SYS_TIMER_CTRL( AHB_CLOCK_TIMER ) );
+
+        /* initialize RTC */
+        rtc_lowlevel_init();
+
+        rtc_calc_and_print_deviation();
+
+        /* disable timer */
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   & ~SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) );
+        sys_writel( 0, SYS_TIMER_CTRL( AHB_CLOCK_TIMER ) );
+        
+        return 1;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( rtc, "checks rtc clock accuracy" );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS921X))*/
+
diff --git a/common/digi/cmd_testhw/cpu/ns921x_sysclock.c b/common/digi/cmd_testhw/cpu/ns921x_sysclock.c
new file mode 100644
index 0000000..c4a8c68
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns921x_sysclock.c
@@ -0,0 +1,117 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns921x_sysclock.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides:
+ *                 sysclock: Checks system clock accuracy against an external
+ *                           clock
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS921X))
+
+#include <cmd_testhw/testhw.h>
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* sys_readl */
+
+#define MHz( x )		( ( x ) * 1000000 )
+#define EXT_CLOCK_GPIO		78
+#define EXT_CLOCK_FUNC		GPIO_CFG_FUNC_2
+#define EXT_CLOCK_WHERE		"X20/B12"
+#define EXT_CLOCK_FREQ		MHz( 10 )
+#define EXT_CLOCK_TIMER		4 /* timer 0-3 are used by U-Boots:timer.c */
+#define AHB_CLOCK_TIMER		5
+
+/**
+ * do_testhw_sysclock - checks clock accuracy
+ */
+static int do_testhw_sysclock( int argc, char* argv[] )
+{
+        u32 uiAHBTicks;
+        int iDelta;
+        int iPPM;
+        
+        printf( "Expecting reference clock of %i MHz on GPIO %i @ %s\n",
+                EXT_CLOCK_FREQ / MHz( 1 ),
+                EXT_CLOCK_GPIO, EXT_CLOCK_WHERE );
+
+        /* configure external clock input */
+        gpio_cfg_set( EXT_CLOCK_GPIO, EXT_CLOCK_FUNC );
+
+        /* prepare timers. AHB_CLOCK_TIMER counts all AHB clocks until
+         * EXT_CLOCK_FREQ has counted 10 MHz ticks. Then it stops.
+         * If no clock is present, the test runs endless. */
+
+        /* don't know the state. Ensure it doesn't start counting immediately*/
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   & ~( SYS_TIMER_MASTER_CTRL_EN( EXT_CLOCK_TIMER ) |
+                        SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) ) );
+
+        sys_writel( 0, SYS_TIMER_RELOAD( AHB_CLOCK_TIMER ) );
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                       SYS_TIMER_CTRL_TCS_1    |
+                       SYS_TIMER_CTRL_TM_INT   |
+                       SYS_TIMER_CTRL_UP       |
+                       SYS_TIMER_CTRL_32,
+                       SYS_TIMER_CTRL( AHB_CLOCK_TIMER ) );
+
+        sys_writel( EXT_CLOCK_FREQ, SYS_TIMER_RELOAD( EXT_CLOCK_TIMER ) );
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                       SYS_TIMER_CTRL_TCS_EXT  |
+                       SYS_TIMER_CTRL_TM_INT   |
+                       SYS_TIMER_CTRL_DOWN     |
+                       SYS_TIMER_CTRL_32,
+                       SYS_TIMER_CTRL( EXT_CLOCK_TIMER ) );
+
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | ( SYS_TIMER_MASTER_CTRL_EN( EXT_CLOCK_TIMER ) |
+                       SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) ) );
+
+        while( sys_readl( SYS_TIMER_READ( EXT_CLOCK_TIMER ) ) ) {
+                /* wait for 1s to expire */
+        }
+
+        uiAHBTicks = sys_readl( SYS_TIMER_READ( AHB_CLOCK_TIMER ) );
+
+        /* disable timers and GPIO */
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   & ~( SYS_TIMER_MASTER_CTRL_EN( EXT_CLOCK_TIMER ) |
+                        SYS_TIMER_MASTER_CTRL_EN( AHB_CLOCK_TIMER ) ) );
+        sys_writel( 0, SYS_TIMER_CTRL( AHB_CLOCK_TIMER ) );
+        sys_writel( 0, SYS_TIMER_CTRL( EXT_CLOCK_TIMER ) );
+
+        gpio_cfg_set( EXT_CLOCK_FUNC, GPIO_CFG_FUNC_GPIO );
+
+        /* calculate deviation in ppm */
+        iDelta = uiAHBTicks - ahb_clock_freq();
+
+        /* use floats to avoid integer overflow at 2^31 */
+        iPPM = ( ( (float ) iDelta ) * 1000000 ) / ahb_clock_freq();
+        if( iPPM < 0 )
+                iPPM = -iPPM;
+        
+        printf( "Deviation is %i ticks = %i ppm\n", iDelta, iPPM );
+        
+        return 1;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( sysclock, "checks system clock accuracy" );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS921X))*/
+
diff --git a/common/digi/cmd_testhw/cpu/ns9360.c b/common/digi/cmd_testhw/cpu/ns9360.c
new file mode 100644
index 0000000..8142452
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns9360.c
@@ -0,0 +1,97 @@
+/*
+ *  /common/digi/cmd_testhw/cpu/ns9360.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Implements NS9360 specific commands
+ *                  bigendian_watchdog_reset_switch
+ *                  watchdog_reset
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS9360))
+
+#include <cmd_testhw/testhw.h>
+
+#include "ns9750_ser.h"		/* for serial configuration */
+#include "ns9750_sys.h"
+
+/* ********** global functions ********** */
+
+/* from bigendian_watchdog_reset_switch.S */
+extern void testhw_bigendian_watchdog_reset_switch( void ); 
+
+/* ********** local functions ********** */
+
+/*! \return never */
+static void TriggerWatchdogResetAndWait( void )
+{
+        /* trigger watchdog for immediately reset */
+        *get_sys_reg_addr( NS9750_SYS_SW_WDOG_TIMER ) = 0x1;
+        *get_sys_reg_addr( NS9750_SYS_SW_WDOG_CFG   ) = 
+                NS9750_SYS_SW_WDOG_CFG_SWWE    |       
+                NS9750_SYS_SW_WDOG_CFG_SWWIC   |
+                NS9750_SYS_SW_WDOG_CFG_SWTCS_2;
+
+        while( 1 ) {
+                /* do nothing, wait for reset */
+        }
+
+        /* never reached */
+}
+
+/*! \brief resets the system */
+/*! Performs a switch to big-endianess and then a watchdog reset
+ *  On some modules (CC9P9360 Rev. 5) it will hang, simulating
+ *  a behaviour like NET+OS
+ *  It will never return */
+static int do_testhw_bigendian_watchdog_reset( int argc, char* argv[] )
+{
+        printf( "Resetting system\n" );
+
+        serial_tx_flush();
+
+        /* jump to assembler code performing the switch over and reset */
+        testhw_bigendian_watchdog_reset_switch();
+
+        TriggerWatchdogResetAndWait();
+
+        /* never reached  */
+        return 0;
+}
+
+/*! \brief resets the system */
+/*! It will never return */
+static int do_testhw_watchdog_reset( int argc, char* argv[] )
+{
+        printf( "Resetting system\n" );
+
+        serial_tx_flush();
+
+        TriggerWatchdogResetAndWait();
+
+        /* never reached  */
+        return 0;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD( bigendian_watchdog_reset,
+            "Performs a bigendian switch and then a watchdog reset" );
+TESTHW_CMD( watchdog_reset,
+            "Performs a watchdog reset" );
+
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS9360))*/
+
+
diff --git a/common/digi/cmd_testhw/cpu/ns9360_asm.S b/common/digi/cmd_testhw/cpu/ns9360_asm.S
new file mode 100644
index 0000000..dc10ad9
--- /dev/null
+++ b/common/digi/cmd_testhw/cpu/ns9360_asm.S
@@ -0,0 +1,70 @@
+/*
+ *  common/digi/cmd_testhw/cpu/ns9360_asm.S
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides
+ *                   void testhw_bigendian_watchdog_reset_switch( void ).
+ *  !References: [1] spi.S Rev. 1.5
+*/
+
+#include <config.h>
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) &&    \
+     defined(CONFIG_NS9360))
+
+#include <ns9750_sys.h>
+#include <ns9750_mem.h>
+        
+/*! \brief switches to big-endian and performs watchdog-reset */
+/*! void testhw_bigendian_watchdog_reset_switch( void );
+    Will never return.
+    r0 will be used as a base register, r1 as a data register
+ */
+.globl testhw_bigendian_watchdog_reset_switch
+testhw_bigendian_watchdog_reset_switch:
+        stmdb 	sp!, {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}
+
+switch_to_big:
+        /* see [1], EndianSwitchBig */
+
+        /* set memory controller to big endian */
+	ldr	r0, =( NS9750_MEM_MODULE_BASE + NS9750_MEM_CFG )
+	ldr	r1, [r0]
+	orr	r1, r1, #NS9750_MEM_CFG_N   /* force big endian */
+	str	r1, [r0]
+
+        /* set system controller to big endian */
+	ldr	r0, =( NS9750_SYS_MODULE_BASE + NS9750_SYS_MISC )
+	ldr	r1, [r0]
+	orr	r1, r1, #NS9750_SYS_MISC_ENDM /* force big endian */
+	str	r1, [r0]
+
+	/* set the strapped endian bits in BBus Endian Config Register */
+	ldr	r0, =( NS9750_BBUS_MODULE_BASE + NS9750_BBUS_ENDIAN_CFG )
+	ldr	r1, [r0]
+	ldr	r2, =( NS9750_BBUS_ENDIAN_CFG_AHBM | \
+                       NS9750_BBUS_ENDIAN_CFG_USBHOST | \
+                       NS9750_BBUS_ENDIAN_CFG_DMA ) /* force big endian */
+	orr	r1,r1,r2
+	str	r1, [r0]
+
+	/* set endian bit in CP15 R1.*/
+	ldr	r1, =0x00001005
+	mrc	p15, 0, r0, c1, c0, 0	/* read value from control register (CP15 r1 into r0) */
+	orr	r0, r0, #0x00000080
+	mcr	p15, 0, r0, c1, c0, 0	/* write back */
+
+        /* return */
+        ldmia 	sp!, {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}
+        mov     pc, lr
+        
+#endif /*(CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && defined(CONFIG_NS9360))*/
diff --git a/common/digi/cmd_testhw/files/QVGA_565_bar.fb0 b/common/digi/cmd_testhw/files/QVGA_565_bar.fb0
new file mode 100644
index 0000000..d913bb9
Binary files /dev/null and b/common/digi/cmd_testhw/files/QVGA_565_bar.fb0 differ
diff --git a/common/digi/cmd_testhw/testhw.h b/common/digi/cmd_testhw/testhw.h
new file mode 100644
index 0000000..1eeebc9
--- /dev/null
+++ b/common/digi/cmd_testhw/testhw.h
@@ -0,0 +1,42 @@
+/*
+ *  common/digi/cmd_testhw/testhw.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Provides TESTHW_CMD
+*/
+
+/* in convention with U-Boot returns 1 on failure and 0 on ok */
+typedef int ( *testhw_cmd_func_t )( int argc, char* argv[] );
+
+typedef struct {
+        const char*       szName;
+        const char*       szHelp;
+        testhw_cmd_func_t pfHandler;
+} testhw_cmd_entry_t;
+    
+extern const testhw_cmd_entry_t __testhw_cmd_start;
+extern const testhw_cmd_entry_t __testhw_cmd_end;
+
+/* the handler function needs to be named do_testhw_#name */
+#define TESTHW_CMD( name, help ) \
+        testhw_cmd_entry_t __testhw_cmd_##name \
+        __attribute__ ((unused,section (".testhw_cmd"))) = {       \
+                .szName    = #name, \
+                .szHelp    = help,  \
+                .pfHandler = do_testhw_##name \
+        }
+
+#define TESTHW_ERROR( szFormat, ... ) \
+        eprintf( "** ERROR: " szFormat "\n", __VA_ARGS__ )
+
+#define TESTHW_WARNING( szFormat, ... ) \
+        eprintf( "** WARNING: " szFormat "\n", __VA_ARGS__ )
diff --git a/common/digi/cmd_testhw/wireless/AIROHA_7230.h b/common/digi/cmd_testhw/wireless/AIROHA_7230.h
new file mode 100644
index 0000000..10bb7d4
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/AIROHA_7230.h
@@ -0,0 +1,120 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+/*********************/
+/* OTHER DEFINITIONS */
+/*********************/
+//#define AIROHA_PWR_CALIBRATION
+
+#ifndef _AIROHA_H
+#define _AIROHA_H
+
+// AIROHA specific RF transceiver frequency divider for each channel
+static const struct 
+{
+	uint32 integer;
+	uint32 fraction;
+	uint32 addres4Airoha;
+	uint32 channelNumber;
+	uint32 channelFrequency;
+	
+} freqTableAiroha_7230[] = {
+	{ 0, 0, 0, 0, 0},
+	// 2.4 GHz band (802.11b/g)
+	{ 0x00379, 0x13333, 0x7FD78,   1, 2412},
+	{ 0x00379, 0x1B333, 0x7FD78,   2, 2417},
+	{ 0x00379, 0x03333, 0x7FD78,   3, 2422},
+	{ 0x00379, 0x0B333, 0x7FD78,   4, 2427},
+	{ 0x0037A, 0x13333, 0x7FD78,   5, 2432},
+	{ 0x0037A, 0x1B333, 0x7FD78,   6, 2437},
+	{ 0x0037A, 0x03333, 0x7FD78,   7, 2442},
+	{ 0x0037A, 0x0B333, 0x7FD78,   8, 2447},
+	{ 0x0037B, 0x13333, 0x7FD78,   9, 2452},
+	{ 0x0037B, 0x1B333, 0x7FD78,  10, 2457},
+	{ 0x0037B, 0x03333, 0x7FD78,  11, 2462},
+	{ 0x0037B, 0x0B333, 0x7FD78,  12, 2467},
+	{ 0x0037C, 0x13333, 0x7FD78,  13, 2472},
+	{ 0x0037C, 0x06666, 0x7FD78,  14, 2484},
+	// 5 GHz band (802.11a)
+	{ 0x0FF52, 0x00000, 0x67F78, 184, 4920}, //15
+	{ 0x0FF52, 0x0AAAA, 0x77F78, 188, 4940}, //16
+	{ 0x0FF53, 0x15555, 0x77F78, 192, 4960}, //17
+	{ 0x0FF53, 0x00000, 0x67F78, 196, 4980}, //18
+	{ 0x0FF54, 0x00000, 0x67F78,   8, 5040}, //19
+	{ 0x0FF54, 0x0AAAA, 0x77F78,  12, 5060}, //20
+	{ 0x0FF55, 0x15555, 0x77F78,  16, 5080}, //21
+	{ 0x0FF56, 0x05555, 0x77F78,  34, 5170}, //22
+	{ 0x0FF56, 0x0AAAA, 0x77F78,  36, 5180}, //23
+	{ 0x0FF57, 0x10000, 0x77F78,  38, 5190}, //24
+	{ 0x0FF57, 0x15555, 0x77F78,  40, 5200}, //25
+	{ 0x0FF57, 0x1AAAA, 0x77F78,  42, 5210}, //26
+	{ 0x0FF57, 0x00000, 0x67F78,  44, 5220}, //27
+	{ 0x0FF57, 0x05555, 0x77F78,  46, 5230}, //28
+	{ 0x0FF57, 0x0AAAA, 0x77F78,  48, 5240}, //29
+	{ 0x0FF58, 0x15555, 0x77F78,  52, 5260}, //30
+	{ 0x0FF58, 0x00000, 0x67F78,  56, 5280}, //31
+	{ 0x0FF58, 0x0AAAA, 0x77F78,  60, 5300}, //32
+	{ 0x0FF59, 0x15555, 0x77F78,  64, 5320}, //33
+	{ 0x0FF5C, 0x15555, 0x77F78, 100, 5500}, //34
+	{ 0x0FF5C, 0x00001, 0x67F78, 104, 5520}, //35
+	{ 0x0FF5C, 0x0AAAA, 0x77F78, 108, 5540}, //36
+	{ 0x0FF5D, 0x15555, 0x77F78, 112, 5560}, //37
+	{ 0x0FF5D, 0x00000, 0x67F78, 116, 5580}, //38
+	{ 0x0FF5D, 0x0AAAA, 0x77F78, 120, 5600}, //39
+	{ 0x0FF5E, 0x15555, 0x77F78, 124, 5620}, //40
+	{ 0x0FF5E, 0x00000, 0x67F78, 128, 5640}, //41
+	{ 0x0FF5E, 0x0AAAA, 0x77F78, 132, 5660}, //42
+	{ 0x0FF5F, 0x15555, 0x77F78, 136, 5680}, //43
+	{ 0x0FF5F, 0x00000, 0x67F78, 140, 5700}, //44
+	{ 0x0FF60, 0x18000, 0x77F78, 149, 5745}, //45
+	{ 0x0FF60, 0x02AAA, 0x77F78, 153, 5765}, //46
+	{ 0x0FF60, 0x0D555, 0x77F78, 157, 5785}, //47
+	{ 0x0FF61, 0x18000, 0x77F78, 161, 5805}, //48
+	{ 0x0FF61, 0x02AAA, 0x77F78, 165, 5825}  //49
+};
+
+/*********************/
+/* OTHER DEFINITIONS */
+/*********************/
+#define RF_AIROHA_7230 	0
+
+#define RF_24GHZ 	0
+#define RF_50GHZ 	1
+
+// Useful RSSI range in dbm
+#define RSSI_LOW    (-90)
+#define RSSI_HIGH   (-30)
+
+#define	GEN_RESET		0x527f0000	// Reset state
+#define	GEN_INIT		0x37780005	// Initial state
+#define	GEN_INIT_MAXIM		0x37780005	// Initial state; PA_ON= active low; bit 25
+
+#if SIMULATING_NETOS
+	#define	GEN_INIT_AIROHA_24GHZ	0x317C0005	// Initial state; 2.4GHZ_PA_ON= active low; bit 25
+#else
+	#define	GEN_INIT_AIROHA_24GHZ	0x317C0005	// Initial state; 2.4GHZ_PA_ON= active low; bit 25
+#endif
+
+#if SIMULATING_NETOS
+	#define	GEN_INIT_AIROHA_50GHZ	0x337C0008	// Initial state; 5.0GHZ_PA_ON= active high; bit 25
+#else
+	#define	GEN_INIT_AIROHA_50GHZ	0x337C0008	// Initial state; 5.0GHZ_PA_ON= active high; bit 25
+#endif
+
+#define	SPI_INIT_AIROHA		0x00000018      // AIROHA-specific SPI length
+
+// TRUE if channel number in 5 GHz band
+#define	CHAN_5G(chan)		( (chan) > 14)
+#define CHAN_4920_4980(chan)	(((chan) > 14) && ((chan) < 19))
+#define CHAN_5150_5350(chan)	(((chan) > 21) && ((chan) < 34))
+#define CHAN_5470_5725(chan)	(((chan) > 33) && ((chan) < 44))
+#define CHAN_5725_5825(chan)	(((chan) > 44) && ((chan) < 50))
+
+
+#endif
+
+#endif /* CFG_HAS_WIRELESS */
+
diff --git a/common/digi/cmd_testhw/wireless/adc081C021.c b/common/digi/cmd_testhw/wireless/adc081C021.c
new file mode 100644
index 0000000..77550b4
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/adc081C021.c
@@ -0,0 +1,95 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#include <common.h>
+#include <i2c.h>
+#include "adc081C021.h"
+
+/* initialize I2C interface for ADC */
+int init_adc_pc(void)
+{
+	
+	//i2c_init(400, ADC_SLAVE_ADDR << 1);
+	write_adc_pc_char (ADC_CONF, 0x20);
+	//write_adc_pc_char (ADC_CONV_RESULT, 0x00);
+	return 0;
+}
+
+
+int read_conversion (unsigned char *buffer)
+{	
+	unsigned char aux[2];
+	unsigned char error;
+	
+	error = i2c_read (ADC_SLAVE_ADDR, ADC_CONV_RESULT, 0x1, aux, sizeof(aux));
+	*buffer = 0;
+	*buffer = (aux[0] << 4) | (aux[1] >> 4);  
+	
+	return error;
+}
+
+int read_max_conversion (unsigned char *buffer)
+{	
+	unsigned char aux[2];
+	unsigned char error;
+	
+	error = i2c_read (ADC_SLAVE_ADDR, ADC_CONV_HIGHEST, 0x1, aux, sizeof(aux));
+	*buffer = 0;
+	*buffer = (aux[0] << 4) | (aux[1] >> 4);  
+	
+	return error;
+}
+
+int read_max_min_avg_conversion (unsigned char numOfAverages, unsigned char *buffer)
+{
+	unsigned char value, instantadc, minadc, maxadc;
+	unsigned long avgadc;
+	unsigned char loopadc;
+
+	avgadc = 0;
+	minadc = 255;
+	maxadc = 0;
+	
+	for(loopadc=0; loopadc<numOfAverages; loopadc++) 
+	{	
+		udelay(1000);
+		value = read_conversion (&instantadc);
+		if (value)
+			return value;
+	   	avgadc += instantadc;
+	   	if (instantadc > maxadc) maxadc = instantadc;
+	   	if (instantadc < minadc) minadc = instantadc;
+	}
+	avgadc /= numOfAverages;
+
+	buffer[0] = avgadc;
+	buffer[1] = maxadc;
+	buffer[2] = minadc;
+
+	return 0;
+}
+
+int reset_max_min_values (void)
+{
+	unsigned int aux;
+
+	aux = CLEARLOWESTVAL;
+	if(i2c_write (ADC_SLAVE_ADDR, ADC_CONV_LOWEST, 0x1, (unsigned char*) &aux, 2 * sizeof(unsigned char)) != 0)
+		return 1;
+	aux = CLEARHIGHESTVAL;
+	if (i2c_write (ADC_SLAVE_ADDR, ADC_CONV_HIGHEST, 0x1, (unsigned char*) &aux, 2 * sizeof(unsigned char)) != 0)
+		return 1;
+
+	return 0;
+}
+
+
+int write_adc_pc_char (unsigned int address, unsigned char buffer)
+{
+	return i2c_write (ADC_SLAVE_ADDR, address, 0x1, &buffer, sizeof(unsigned char));
+}
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/adc081C021.h b/common/digi/cmd_testhw/wireless/adc081C021.h
new file mode 100644
index 0000000..974253d
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/adc081C021.h
@@ -0,0 +1,43 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#ifndef _ADC081C021_H_
+#define _ADC081C021_H_
+
+// ADC121C021/ADC121C027 registers
+#define ADC_CONV_RESULT		0x0
+#define ADC_ALERT_STATUS	0x1
+#define ADC_CONF		0x2
+#define ADC_LOW_LIMIT		0x3
+#define ADC_HIGH_LIMIT		0x4
+#define ADC_HYST		0x5
+#define ADC_CONV_LOWEST		0x6
+#define ADC_CONV_HIGHEST	0x7
+
+/* ADC081C027 && ADDR==GND */
+#define ADC_SLAVE_ADDR          0x51
+
+#define CLEARLOWESTVAL		0x0FF0
+#define CLEARHIGHESTVAL		0x0000
+
+
+/* initialize I2C interface for ADC */
+int init_adc_pc(void);
+
+/* Reading */
+int read_conversion (unsigned char *buffer);
+int read_max_conversion (unsigned char *buffer);
+int read_max_min_avg_conversion (unsigned char numOfAverages, unsigned char *buffer);
+
+/* Resseting */
+int reset_max_min_values (void);
+
+/* Writing */
+int write_adc_pc_char (unsigned int address, unsigned char buffer);
+
+#endif
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/calibration.c b/common/digi/cmd_testhw/wireless/calibration.c
new file mode 100644
index 0000000..985f433
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/calibration.c
@@ -0,0 +1,808 @@
+#include <common.h>
+#include "calibration.h"
+#include "adc081C021.h"
+#include "vBPiper.h"
+#include <nvram.h>
+
+#include "gui_tst_wifi.h" /* MACROS FOR RATES */
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+//#include <stdarg.h>
+//#include <linux/types.h>
+//#include <linux/string.h>
+//#include <linux/ctype.h>
+//#include <nvram_types.h>
+#include <mtd.h>
+
+static unsigned char numPoints;
+
+/*static int getSLongConsoleNOREAD(char *auxConBuff, long *returned, char **p)
+{
+	*returned = simple_strtol (auxConBuff, p, 10);
+
+	return 0;
+}*/
+
+int getConsoleNOREAD(char *auxConBuff, void *toReturn, char **p, unsigned char size, unsigned char isSigned)
+{
+	if (size == sizeof(char_t))
+	{
+		if (isSigned)
+		{
+			char_t *returned;
+			returned = (char_t *) toReturn;
+			*returned = (char_t) simple_strtol (auxConBuff, p, 10);
+			return 0;
+		}
+		else
+		{
+			uchar_t *returned;
+			returned = (uchar_t *) toReturn;
+			*returned = (uchar_t) simple_strtoul (auxConBuff, p, 10);
+			return 0;
+		}
+	}
+	else if (size == sizeof(int16_t))
+	{
+		if (isSigned)
+		{
+			int16_t *returned;
+			returned = (int16_t *) toReturn;
+			*returned = (int16_t) simple_strtol (auxConBuff, p, 10);
+			return 0;
+		}
+		else
+		{
+			uint16_t *returned;
+			returned = (uint16_t *) toReturn;
+			*returned = (uint16_t) simple_strtoul (auxConBuff, p, 10);
+			return 0;
+		}
+	}
+	else if (size == sizeof(int32_t))
+	{
+		if (isSigned)
+		{
+			int32_t *returned;
+			returned  = (int32_t *) toReturn;
+			*returned = (int32_t) simple_strtol (auxConBuff, p, 10);
+			return 0;
+		}
+		else
+		{
+			uint32_t *returned;
+			returned = (uint32_t *) toReturn;
+			*returned = (uint32_t) simple_strtoul (auxConBuff, p, 10);
+			return 0;
+		}
+	}
+	return 1;
+}
+
+
+int retrieveCalHeaderConsole (nv_wcd_header_t *auxHeader, unsigned char decimalSeparator, \
+			      unsigned char valuesSeparator, unsigned char endProcessSeparator)
+{
+	int aux;
+	char *p = NULL;
+		
+	printf ("Input_Header_Line >>");	
+	aux = readline("");
+	if (aux > 0)
+       	{
+		strcpy(auxHeader->magic_string, WCD_MAGIC);
+		
+		/* ver_major */
+		getConsoleNOREAD(console_buffer, &(auxHeader->ver_major), &p, sizeof(auxHeader->ver_major), 0);
+		p++;
+		
+		/* ver_minor */	
+		getConsoleNOREAD(p, &(auxHeader->ver_minor), &p, sizeof(auxHeader->ver_minor), 0);
+		p++;
+				
+		/* hw_platform */	
+		getConsoleNOREAD(p, &(auxHeader->hw_platform), &p, sizeof(auxHeader->hw_platform), 0);
+		p++;
+		
+		/* bNumCalPoint */	
+		getConsoleNOREAD(p, &(auxHeader->numcalpoints), &p, sizeof(auxHeader->numcalpoints), 0);
+		p++;
+		
+		numPoints = auxHeader->numcalpoints;
+
+		/* uCalDataLen */	
+		getConsoleNOREAD(p, &(auxHeader->wcd_len), &p, sizeof(auxHeader->wcd_len), 0);
+		p++;
+		
+		/* uCalDataCrc */	
+		getConsoleNOREAD(p, &(auxHeader->wcd_crc), &p, sizeof(auxHeader->wcd_crc), 0);
+
+		/*auxCrc32 = crc32 (0, (unsigned char*) auxHeader, sizeof(nv_wcd_header_t));*/
+
+		if (1)/*auxCrc32 == auxHeader->uCalDataCrc)*/
+			return 0; /* Header Correct */
+		else
+			return -1; /* Error in header */
+
+	}
+	return aux;
+}
+
+int retrieveCalPointConsole (wcd_point_t *auxPoint, unsigned char decimalSeparator, \
+			     unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			     unsigned char channelNumber, unsigned char modulationType, unsigned char point)
+{
+	int aux;
+	char *p = NULL;
+		
+	printf ("Point_%i_CH_%i_MOD_%s >>", (int) point, (int) channelNumber, nTs_modulation_type[modulationType]);
+	aux = readline("");
+	if (aux > 0)
+       	{
+		/* out_power */	
+		getConsoleNOREAD(console_buffer, &(auxPoint->out_power), &p, sizeof(auxPoint->out_power), 1);
+		p++;
+
+		/* adc_val */	
+		getConsoleNOREAD(p, &(auxPoint->adc_val), &p, sizeof(auxPoint->adc_val), 0);
+		p++;
+
+		/* power_index */	
+		getConsoleNOREAD(p, &(auxPoint->power_index), &p, sizeof(auxPoint->power_index), 0);
+
+		auxPoint->reserved[0] = 0;
+		auxPoint->reserved[1] = 0;
+		auxPoint->reserved[2] = 0;
+
+		return 0;
+	}
+	return aux;
+}
+
+int retrieveCalCurveConsole (wcd_curve_t *auxCurve, unsigned char decimalSeparator, \
+			     unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			     unsigned char channelNumber, unsigned char modulationType)
+{
+	int aux;
+	char *p = NULL;
+	
+	printf ("Curve_CH_%i_MOD_%s >>", (int) channelNumber, nTs_modulation_type[modulationType]);
+	aux = readline("");
+	if (aux > 0)
+       	{
+		auxCurve->reserved[0] = 0;
+		auxCurve->reserved[1] = 0;
+		auxCurve->reserved[2] = 0;
+
+		/* max_power_index */	
+		getConsoleNOREAD(console_buffer, &(auxCurve->max_power_index), &p, sizeof(auxCurve->max_power_index), 0);
+
+		/* points */
+		for(aux = 0; aux < numPoints; aux++)
+		{
+			retrieveCalPointConsole(&(auxCurve->points[aux]), decimalSeparator, \
+				valuesSeparator, endProcessSeparator, channelNumber, modulationType, aux + 1);
+		}
+		return 0;
+	}
+	return aux;
+}
+
+int retrieveCalData (wcd_data_t *auxData, unsigned char decimalSeparator, \
+		     unsigned char valuesSeparator, unsigned char endProcessSeparator)
+{
+	int i,j;
+	//char *p = NULL;
+
+	printf("1");
+	retrieveCalHeaderConsole(&(auxData->header), '.',',',';');
+
+	printf ("\n-------------------------------------\n");
+	printf ("--- CALIBRATION DATA FOR BAND B/G ---\n");
+	printf ("-------------------------------------\n\n");
+
+	/* Retrieve curves B/G */
+	for(j=0; j<WCD_NUM_MOD_BG; j++)
+	{
+		for(i=0; i<WCD_CHANNELS_BG; i++)
+		{
+		
+			retrieveCalCurveConsole(&(auxData->cal_curves_bg[i][j]), decimalSeparator, \
+				valuesSeparator, endProcessSeparator, i+1, j);
+		}
+	}
+
+	printf ("\n-----------------------------------\n");
+	printf ("--- CALIBRATION DATA FOR BAND A ---\n");
+	printf ("-----------------------------------\n\n");
+
+	/* Retrieve curves A */
+	for(i=0; i<WCD_CHANNELS_A; i++)
+	{
+		retrieveCalCurveConsole(&(auxData->cal_curves_a[i]), decimalSeparator, \
+			valuesSeparator, endProcessSeparator, i+15, 1);
+	}
+
+	//auxData->header.wcd_len = sizeof(wcd_curve_t)*WCD_CHANNELS_BG*2 + sizeof(wcd_curve_t)*WCD_CHANNELS_A;
+	//auxData->header.wcd_crc = crc32( 0, (const unsigned char*) auxData->cal_curves_bg, auxData->header.wcd_len);
+	
+	return 0;
+}
+
+int printCalHeaderConsole (nv_wcd_header_t *auxHeader)
+{
+	printf("%s", auxHeader->magic_string);
+		
+	/* ver_major */	
+	printf("%i, ", auxHeader->ver_major);
+	
+	/* ver_minor */	
+	printf("%i, ", auxHeader->ver_minor);
+	
+	/* hw_platform */	
+	printf("%i, ", auxHeader->hw_platform);
+	
+	/* bNumCalPoint */	
+	printf("%i, ", auxHeader->numcalpoints);
+	
+	/* uCalDataLen */	
+	printf("%x, ", auxHeader->wcd_len);
+	
+	/* uCalDataCrc */	
+	printf("%x\n", auxHeader->wcd_crc);
+
+	return 0;
+}
+
+int printCalPointConsole (wcd_point_t *auxPoint, \
+			     unsigned char channelNumber, unsigned char modulationType, unsigned char point)
+{
+	printf ("Point_%i_CH_%i_MOD_%s -- ", point, channelNumber, nTs_modulation_type[modulationType]);
+	
+	/* out_power */	
+	printf("%i, ", auxPoint->out_power);
+	
+	/* adc_val */	
+	printf("%i, ", auxPoint->adc_val);
+
+	/* power_index */	
+	printf("%i\n", auxPoint->power_index);
+
+	return 0;
+}
+
+int printCalCurveConsole (wcd_curve_t *auxCurve, \
+			     unsigned char channelNumber, unsigned char modulationType)
+{
+	unsigned char aux;
+
+	printf ("Curve_CH_%i_MOD_%s -- ", channelNumber, nTs_modulation_type[modulationType]);
+	
+	/* max_power_index */	
+	printf("%i --> \n", auxCurve->max_power_index);
+
+	/* points */
+	for(aux = 0; aux < numPoints; aux++)
+	{
+		printCalPointConsole(&(auxCurve->points[aux]),channelNumber, modulationType, aux + 1);
+	}
+
+	return 0;
+}
+
+int printCalData (wcd_data_t *auxData)
+{
+	int i,j;
+
+	//char *p = NULL;
+
+	printCalHeaderConsole(&(auxData->header));
+
+	printf ("\n-------------------------------------\n");
+	printf ("--- CALIBRATION DATA FOR BAND B/G ---\n");
+	printf ("-------------------------------------\n\n");
+
+	/* Retrieve curves B/G */
+	for(j=0; j<WCD_NUM_MOD_BG; j++)
+	{
+		for(i=0; i<WCD_CHANNELS_BG; i++)
+		{
+			printCalCurveConsole(&(auxData->cal_curves_bg[i][j]), i+1, j);
+		}
+	}
+
+	printf ("\n-----------------------------------\n");
+	printf ("--- CALIBRATION DATA FOR BAND A ---\n");
+	printf ("-----------------------------------\n\n");
+
+	/* Retrieve curves A */
+	for(i=0; i<WCD_CHANNELS_A; i++)
+	{
+		printCalCurveConsole(&(auxData->cal_curves_a[i]), i+15, 0);
+	}
+
+
+	printf("CRC's %X %x\n", crc32( 0, (const unsigned char*) auxData->cal_curves_bg, sizeof(wcd_curve_t)*WCD_CHANNELS_BG*2 + sizeof(wcd_curve_t)*WCD_CHANNELS_A), auxData->header.wcd_crc);
+
+	return 0;
+}
+
+/* returns Airoha Index based in RF output Power and calibration data */
+/* TO BE MODIFIED */
+#if 0
+unsigned char getAIfromPW(wcd_data_t *auxCalData, int16_t powerOutputRF, unsigned int channel, unsigned int rate)
+{
+	unsigned char lowCalAI, highCalAI, desiredAI;
+	unsigned char i, auxModulation;
+
+	
+	if (!CHAN_5G(channel))
+	{
+		/* Band B/G */
+
+		if (IS_CCK_DSSS(rate))
+			auxModulation = 0;
+		else
+			auxModulation = 1;
+		
+		if (auxCalData->cal_curves_bg[channel][auxModulation].points[0].out_power >= powerOutputRF)
+			desiredAI = 0;
+		else if (auxCalData->cal_curves_bg[channel][auxModulation].points[WCD_MAX_CAL_POINTS - 1].out_power < powerOutputRF)
+			desiredAI = auxCalData->cal_curves_bg[channel][auxModulation].max_power_index;
+		else
+		{
+			/* Search bottom index */
+			i = 0;
+			while (auxCalData->cal_curves_bg[channel][auxModulation].points[i].out_power <= powerOutputRF)
+			{
+				i++;
+				if (i > WCD_MAX_CAL_POINTS - 1)
+					break;
+			}
+			
+			desiredAI = i-1;
+
+			/* Calculate ADC for desired power */
+			desiredAI = (unsigned char) \
+			((powerOutputRF * auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index) / \
+			(auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].out_power));
+		}
+	}
+	else
+	{
+		/* Band A */
+		/* Search bottom index */
+		i = 0;
+		while (auxCalData->cal_curves_a[channel].points[i].out_power < powerOutputRF)
+		{
+			i++;
+		} 
+			
+		lowCalAI = i;
+		highCalAI = i+1;
+
+		/* Calculate Airoha Index for desired power */
+		desiredAI = (unsigned char) \
+		((powerOutputRF * auxCalData->cal_curves_a[channel].points[lowCalAI].power_index) / \
+		(auxCalData->cal_curves_a[channel].points[lowCalAI].out_power));
+	}
+	
+	return desiredAI;
+}
+#endif
+
+/* returns Airoha Index based in RF output Power and calibration data */
+unsigned char getADCfromPW(wcd_data_t *auxCalData, int16_t powerOutputRF, unsigned int channel, unsigned int rate)
+{
+	unsigned char lowCalADC, highCalADC, desiredADC;
+	unsigned char i, auxModulation;
+
+	signed int deltaRF = 0;
+	signed int deltaADC = 0;//signed int
+	float minRF = 0;//int
+	
+	if (!CHAN_5G(channel))
+	{
+		/* Band B/G */
+
+		if (IS_CCK_DSSS(rate))
+			auxModulation = 0; /* CCK/DSSS */
+		else
+			auxModulation = 1; /* OFDM */
+
+		/* Calculate ADC for desired power */
+		if (auxCalData->cal_curves_bg[channel][auxModulation].points[0].out_power >= powerOutputRF)
+		{
+			desiredADC = auxCalData->cal_curves_bg[channel][auxModulation].points[0].adc_val;
+		}
+		else if (auxCalData->cal_curves_bg[channel][auxModulation].points[auxCalData->header.numcalpoints - 1].out_power < powerOutputRF)
+		{
+			desiredADC = auxCalData->cal_curves_bg[channel][auxModulation].points[auxCalData->header.numcalpoints - 1].adc_val;
+		}
+		else
+		{
+			/* Search bottom index */
+			i = 0;
+			while (auxCalData->cal_curves_bg[channel][auxModulation].points[i].out_power <= powerOutputRF)
+			{
+				i++;
+				if (i > auxCalData->header.numcalpoints - 1)
+					break;
+			}
+			
+			lowCalADC = i-1;
+			highCalADC = i;
+			
+			/* Calculate ADC for desired power */
+			/*desiredADC = (unsigned char) \
+			((powerOutputRF * auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val) / \
+			(auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].out_power));*/
+
+			minRF = auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].out_power;
+			deltaRF = auxCalData->cal_curves_bg[channel][auxModulation].points[highCalADC].out_power - minRF;
+			deltaADC = auxCalData->cal_curves_bg[channel][auxModulation].points[highCalADC].adc_val \
+				- auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val; 
+
+			desiredADC = (unsigned char) ( (float) (powerOutputRF - minRF) * ( (float) deltaADC / (float) deltaRF) \
+				+ auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val );
+			
+			/*desiredADC = (unsigned char) ( ((powerOutputRF - minRF) * ( deltaADC*1000000 / deltaRF*1000000))/1000000 \
+				+ auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val );*/
+
+		}
+	}
+	else
+	{
+		/* Band A */
+		/* Calculate ADC for desired power */
+		
+		/* Calculate ADC for desired power */
+		channel = channel - 15;
+
+		if (auxCalData->cal_curves_a[channel].points[0].out_power >= powerOutputRF)
+		{
+			desiredADC = auxCalData->cal_curves_a[channel].points[0].adc_val;
+		}
+		else if (auxCalData->cal_curves_a[channel].points[auxCalData->header.numcalpoints - 1].out_power < powerOutputRF)
+		{
+			desiredADC = auxCalData->cal_curves_a[channel].points[auxCalData->header.numcalpoints - 1].adc_val;
+		}
+		else
+		{
+			/* Search bottom index */
+			i = 0;
+			while (auxCalData->cal_curves_a[channel].points[i].out_power <= powerOutputRF)
+			{
+				i++;
+				if (i > auxCalData->header.numcalpoints - 1)
+					break;
+			}
+			
+			lowCalADC = i-1;
+			highCalADC = i;
+			
+			/* Calculate ADC for desired power */
+			/*desiredADC = (unsigned char) \
+			((powerOutputRF * auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val) / \
+			(auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].out_power));*/
+
+			minRF = auxCalData->cal_curves_a[channel].points[lowCalADC].out_power;
+			deltaRF = auxCalData->cal_curves_a[channel].points[highCalADC].out_power - minRF;
+			deltaADC = auxCalData->cal_curves_a[channel].points[highCalADC].adc_val \
+				- auxCalData->cal_curves_a[channel].points[lowCalADC].adc_val; 
+
+			desiredADC = (unsigned char) ( (float) (powerOutputRF - minRF) * ( (float) deltaADC / (float) deltaRF) \
+				+ auxCalData->cal_curves_a[channel].points[lowCalADC].adc_val );
+			
+			/*desiredADC = (unsigned char) ( ((powerOutputRF - minRF) * ( deltaADC*1000000 / deltaRF*1000000))/1000000 \
+				+ auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalADC].adc_val );*/
+		}
+	}
+	
+	return desiredADC;
+}
+
+/* returns Airoha Index based in RF output Power and calibration data */
+unsigned char getAIfromADC(wcd_data_t *auxCalData, int16_t ADC, unsigned int channel, unsigned int rate)
+{
+	unsigned char lowCalAI, highCalAI, desiredAI, minADC = 0;
+	unsigned char i, auxModulation;
+
+	signed int deltaADC = 0;
+	signed int deltaAI = 0;
+	
+	highCalAI = 0;
+	lowCalAI = 0;
+
+	if (!CHAN_5G(channel))
+	{
+		/* Band B/G */
+
+		if (IS_CCK_DSSS(rate))
+			auxModulation = 0;
+		else
+			auxModulation = 1;
+		
+		
+		if (auxCalData->cal_curves_bg[channel][auxModulation].points[0].adc_val >= ADC)
+			desiredAI = 0;
+		else if (auxCalData->cal_curves_bg[channel][auxModulation].points[auxCalData->header.numcalpoints - 1].adc_val < ADC)
+			desiredAI = auxCalData->cal_curves_bg[channel][auxModulation].max_power_index;
+		else
+		{
+			/* Search bottom index */
+			i = 0;
+			while (auxCalData->cal_curves_bg[channel][auxModulation].points[i].adc_val <= ADC)
+			{
+				i++;
+				if (i > auxCalData->header.numcalpoints - 1)
+					break;
+			}
+			
+			lowCalAI = i-1;
+			highCalAI = i;
+
+			/* Calculate Airoha Index for desired power */
+			/*desiredAI = (unsigned char) \
+			((ADC * auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index) / \
+			(auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].adc_val));*/
+			
+			minADC = auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].adc_val;
+			deltaADC = auxCalData->cal_curves_bg[channel][auxModulation].points[highCalAI].adc_val - minADC;
+			deltaAI = auxCalData->cal_curves_bg[channel][auxModulation].points[highCalAI].power_index \
+				- auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index;
+
+			desiredAI = (unsigned char) ( (float) (ADC - minADC) * ((float) deltaAI / (float) deltaADC) \
+				+ auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index );
+		}
+		#if CALIBRATIONTEST
+		printf("Input to function: adc-> %i, channel-> %i\n", ADC, channel);
+		printf("Points measured: lowindex-> %i, highindex-> %i, powerindex-> %i, adc-> %i\n", lowCalAI, highCalAI, auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index, auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].adc_val);
+		#endif
+	}
+	else
+	{
+		/*Band A*/
+		channel = channel - 15;
+
+		if (auxCalData->cal_curves_a[channel].points[0].adc_val >= ADC)
+			desiredAI = 0;
+		else if (auxCalData->cal_curves_a[channel].points[auxCalData->header.numcalpoints - 1].adc_val < ADC)
+			desiredAI = auxCalData->cal_curves_a[channel].max_power_index;
+		else
+		{
+			/* Search bottom index */
+			i = 0;
+			while (auxCalData->cal_curves_a[channel].points[i].adc_val <= ADC)
+			{
+				i++;
+				if (i > auxCalData->header.numcalpoints - 1)
+					break;
+			}
+			
+			lowCalAI = i-1;
+			highCalAI = i;
+
+			/* Calculate Airoha Index for desired power */
+			/*desiredAI = (unsigned char) \
+			((ADC * auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].power_index) / \
+			(auxCalData->cal_curves_bg[channel][auxModulation].points[lowCalAI].adc_val));*/
+			
+			minADC = auxCalData->cal_curves_a[channel].points[lowCalAI].adc_val;
+			deltaADC = auxCalData->cal_curves_a[channel].points[highCalAI].adc_val - minADC;
+			deltaAI = auxCalData->cal_curves_a[channel].points[highCalAI].power_index \
+				- auxCalData->cal_curves_a[channel].points[lowCalAI].power_index;
+
+			desiredAI = (unsigned char) ( (float) (ADC - minADC) * ((float) deltaAI / (float) deltaADC) \
+				+ auxCalData->cal_curves_a[channel].points[lowCalAI].power_index );
+		}
+		#if CALIBRATIONTEST
+		printf("Input to function: adc-> %i, channel-> %i\n", ADC, channel);
+		printf("Points measured: lowindex-> %i, highindex-> %i, powerindex-> %i, adc-> %i\n", lowCalAI, highCalAI, auxCalData->cal_curves_a[channel].points[lowCalAI].power_index, auxCalData->cal_curves_a[channel].points[lowCalAI].adc_val);
+		#endif
+	}
+	
+	return desiredAI;
+}
+
+unsigned char PIDController (wcd_data_t *auxCalData, unsigned int desiredPower, unsigned int channel, unsigned int rate)
+{
+	float previous_error = 0;
+	float error = 0, dt, output = 0, derivative = 0, integral = 0;
+	float kp, ki, kd;
+	
+	unsigned char desiredADC;
+	unsigned char measuredADC;
+	signed int avgADC;
+	signed int acceptableError;
+	unsigned char newAI;
+	unsigned char auxModulation;
+
+	/* Only for loop interaction with GUI */
+	signed int value;
+	char *argv[CFG_MAXARGS + 1], argc, *p = '\0';
+	signed int errorMeasuredADC = 0;
+	unsigned char flagsMessagues = 1;
+
+	/* Stable procedure */
+	unsigned char auxStable = 0;
+
+	auxModulation = 1;
+	if (!CHAN_5G(channel) && IS_CCK_DSSS(rate))
+		auxModulation = 0;
+
+	if (auxModulation)
+	{
+		/* Initial conditions loop */
+		dt = (float) 40; // from 20
+		kp = (float) 15.76; //from 15,76 to 15
+		kd = (float) 2.0 * 15.76; // from 2.0 to 2.5 
+		ki = (float) 15.76 / 2.0;
+		acceptableError = 5;
+	}
+	else
+	{
+		/* Initial conditions loop */
+		dt = (float) 20; // from 20
+		kp = (float) 15.76; //from 15,76 to 15
+		kd = (float) 2.0 * 15.76; // from 2.0 to 2.5 
+		ki = (float) 15.76 / 2.0;
+		acceptableError = 3;
+	}
+
+	/* Estimate ADC reading based in desired Output Power */
+	desiredADC = getADCfromPW(auxCalData, desiredPower, channel-1, rate);
+	#if CALIBRATIONTEST
+	printf("First desired ADC value: %i\n", desiredADC);
+	#endif
+	
+	/* Sets Airoha Index to estimated */
+	newAI = getAIfromADC(auxCalData, (unsigned int) desiredADC, channel-1, rate);
+	#if CALIBRATIONTEST
+	printf("First desired AI value: %i\n", newAI);
+	#endif
+	MacSetDirectTxPower(newAI);
+	
+	/* Performs first reading after estimation */
+	reset_max_min_values();
+	waitUS(30000);
+	read_max_conversion ((unsigned char *) &avgADC); // int before
+
+	while (1)
+	{
+		while (!tstc())
+		{
+
+			error = (float) (desiredADC - (avgADC + errorMeasuredADC));
+			#if CALIBRATIONTEST
+			printf ("Error: %i, desiredADC: %i, measuredADC: %i, AI: %i\n", (int) error, desiredADC, (avgADC + errorMeasuredADC), newAI);
+			#endif
+			
+			if ( error > acceptableError || error < (-1 * acceptableError) ) // 5 is ok, 4 is ok
+			{
+				/* PID calculations */
+				integral += error * dt;
+				derivative = (error - previous_error) / dt;
+				output = desiredADC + (kp * error + ki * integral + kd * derivative)/1000;//1000 before
+				
+				/* Limiting output values */
+				if ( output > 255)
+					output = 255.0;
+					//newAI = 63;
+				else if (output < 0)
+					output = 0;
+				
+				/* Airoha Index Estimation */
+				newAI = getAIfromADC(auxCalData, (unsigned int) output, channel-1, rate);
+				
+				/* Limiting index values */
+				/* DElete when confirmed that output limit is enough. */
+				//if (CHAN_5G(channel))
+				//	if (newAI > auxCalData->cal_curves_a[channel].max_power_index)
+				//		newAI = auxCalData->cal_curves_a[channel].max_power_index;
+				//else
+				//	if (newAI > auxCalData->cal_curves_bg[channel][auxModulation].max_power_index)
+				//		newAI = auxCalData->cal_curves_bg[channel][auxModulation].max_power_index;
+
+				MacSetDirectTxPower(newAI);
+
+				#if CALIBRATIONTEST
+				printf ("----------------------------\n");
+				printf ("Integral: %i\n", (int) integral);
+				printf ("Derivative: %i\n", (int) derivative);
+				printf ("kp * error: %i\n", (int) (kp * error));
+				printf ("ki * integral: %i\n", (int) (ki * integral));
+				printf ("kd * derivative: %i\n", (int) (kd * derivative));
+				printf ("Output: %i\n", (int) output);
+				printf ("New Airoha Index: %i\n", newAI);
+				printf ("----------------------------\n");
+				#endif
+				
+				/* If corrections are performed, we delete stability flag */
+				auxStable = 0;
+				if (!flagsMessagues)
+				{
+					printf ("System compensating for desired RF: %i\n", desiredPower);
+					flagsMessagues = 1;
+				}
+			}
+			else if (auxStable > 15) // From 5.
+			{
+				
+				integral = 0.0;
+				if (flagsMessagues)
+				{
+					printf ("SYSTEM STABLE\nDesired ADC: %i, Measured ADC: %i, AI Index: %i\n", \
+						desiredADC, avgADC, newAI);
+					flagsMessagues = 0;
+				}
+				
+			}
+			else
+			{
+				auxStable++;
+			}
+
+			previous_error = error;
+				
+			reset_max_min_values();
+			waitUS(30000);
+			read_max_conversion ((unsigned char *) &measuredADC);
+			
+			if (auxModulation)
+			{
+				avgADC += measuredADC;
+				avgADC /= 2;
+			}
+			else
+				avgADC = measuredADC;
+		}
+				
+		readline("");
+		
+		/* Extract arguments */
+		if ((argc = parse_line (console_buffer, argv)) == 0)
+		{
+			continue;
+		}
+				
+		value = simple_strtol (argv[1], &p, 10);
+		
+		switch (argv[0][0])
+		{
+			case 'q':
+				goto EXIT_SUB_CONT_TX;
+			break;
+		
+			case 'p':
+				MacSetDirectTxPower((unsigned char) value);
+			break;
+			
+			case 'r':
+				errorMeasuredADC = value;
+			break;
+
+			case 'd':
+				desiredPower = value;
+				desiredADC = getADCfromPW(auxCalData, value, channel-1, rate);
+				integral = 0.0;
+				derivative = 0.0;
+			break;
+
+			default:
+			break;
+		}
+	}
+
+	EXIT_SUB_CONT_TX:
+	{
+		NOP;
+	}
+
+	return 0;
+}
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/calibration.h b/common/digi/cmd_testhw/wireless/calibration.h
new file mode 100644
index 0000000..fa9c993
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/calibration.h
@@ -0,0 +1,75 @@
+#define CALIBRATIONTEST 1
+
+#include <common.h>
+#include <nvram.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#ifndef __CALIBRATION_H__
+#define __CALIBRATION_H__
+
+#define WCD_NUM_MOD_BG		2
+
+/*#define char_t		char
+#define uint8_t		unsigned char
+#define uint16_t	unsigned int
+#define uint32_t	unsigned long*/
+
+
+/* imports from common/main.c */
+extern char console_buffer[CFG_CBSIZE];
+
+extern int getSLongConsoleNOREAD(char *auxConBuff, long *returned, char **p);
+
+int getConsoleNOREAD(char *auxConBuff, void *toReturn, char **p, unsigned char size, unsigned char isSigned);
+
+int retrieveCalHeaderConsole (nv_wcd_header_t *auxHeader, unsigned char decimalSeparator, \
+			      unsigned char valuesSeparator, unsigned char endProcessSeparator);
+
+int retrieveCalPointConsole (wcd_point_t *auxPoint, unsigned char decimalSeparator, \
+			     unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			     unsigned char channelNumber, unsigned char modulationType, unsigned char point);
+
+int retrieveCalCurveConsole (wcd_curve_t *auxCurve, unsigned char decimalSeparator, \
+			     unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			     unsigned char channelNumber, unsigned char modulationType);
+
+int retrieveCalData (wcd_data_t *auxData, unsigned char decimalSeparator, \
+		     unsigned char valuesSeparator, unsigned char endProcessSeparator);
+
+int printCalHeaderConsole (nv_wcd_header_t *auxHeader);
+
+int printCalPointConsole (wcd_point_t *auxPoint, \
+			     unsigned char channelNumber, unsigned char modulationType, unsigned char point);
+
+int printCalCurveConsole (wcd_curve_t *auxCurve, \
+			     unsigned char channelNumber, unsigned char modulationType);
+
+int printCalData (wcd_data_t *auxData);
+
+unsigned char getAIfromPW(wcd_data_t *auxCalData, int16_t powerOutputRF, unsigned int channel, unsigned int rate);
+unsigned char getADCfromPW(wcd_data_t *auxCalData, int16_t powerOutputRF, unsigned int channel, unsigned int rate);
+unsigned char getAIfromADC(wcd_data_t *auxCalData, int16_t ADC, unsigned int channel, unsigned int rate);
+unsigned char PIDController (wcd_data_t *auxCalData, unsigned int desiredPower, unsigned int channel, unsigned int rate);
+
+
+#define CCK	0
+#define OFDM	1
+static const unsigned char nTs_modulation_type[][6] =
+{
+	"CCK\0",
+	"OFDM\0"
+};
+
+// TRUE if channel number in 5 GHz band
+#define	CHAN_5G(chan)		( (chan) > 14)
+#define CHAN_4920_4980(chan)	(((chan) > 14) && ((chan) < 19))
+#define CHAN_5150_5350(chan)	(((chan) > 21) && ((chan) < 34))
+#define CHAN_5470_5725(chan)	(((chan) > 33) && ((chan) < 44))
+#define CHAN_5725_5825(chan)	(((chan) > 44) && ((chan) < 50))
+
+
+#endif /* CFG_HAS_WIRELESS */
+#endif /* __CALIBRATION_H__ */
diff --git a/common/digi/cmd_testhw/wireless/commandswifi.c b/common/digi/cmd_testhw/wireless/commandswifi.c
new file mode 100644
index 0000000..c14f84b
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/commandswifi.c
@@ -0,0 +1,504 @@
+#include <common.h>
+ 
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#include "commandswifi.h"
+#include "gui_tst_wifi.h"
+#include "calibration.h"
+#include "vBPiper.h"
+#include "adc081C021.h"
+#include "AIROHA_7230.h"
+
+
+
+int cmdSetContinousTx (long command, struct menuStatus *auxMenuStatus)
+{
+	cmdExitMode(command, auxMenuStatus);
+	
+	if (CMDSCTXGETPC(command))
+	{
+		auxMenuStatus->statusInformation = RADIO_TX_CONTINUOUS_WIRELESS_TEST;
+		auxMenuStatus->power_control = 1;
+		auxMenuStatus->channel = CMDSCTXGETCHANNEL(command);
+		auxMenuStatus->transmit_mode = CMDSCTXGETTYPE(command);
+		auxMenuStatus->txpower = 0;
+		auxMenuStatus->rftxpower = CMDSCTXGETPOWER(command);
+		auxMenuStatus->transmit_rate = CMDSCTXGETRATE(command);
+		
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		changePrompt(PRMPTTXCONTPC1, auxMenuStatus);
+	}
+	else
+	{
+		auxMenuStatus->statusInformation = RADIO_TX_CONTINUOUS_WIRELESS_TEST;
+		auxMenuStatus->power_control = 0;
+		auxMenuStatus->channel = CMDSCTXGETCHANNEL(command);
+		auxMenuStatus->transmit_mode = CMDSCTXGETTYPE(command);
+		auxMenuStatus->txpower = CMDSCTXGETPOWER(command);
+		auxMenuStatus->rftxpower = 0;
+		auxMenuStatus->transmit_rate = CMDSCTXGETRATE(command);
+
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		changePrompt(PRMPTTXCONTPC0, auxMenuStatus);
+	}
+	return 0;
+}
+
+/*****************************************************************************/
+int cmdSetPeriodicTx (long command, struct menuStatus *auxMenuStatus)
+{
+	cmdExitMode(command, auxMenuStatus);
+	
+	if (CMDSCTXGETPC(command))
+	{
+		auxMenuStatus->statusInformation = RADIO_TX_PERIODIC_FRAME_TRANSMIT;
+		auxMenuStatus->power_control = 1;
+		auxMenuStatus->channel = CMDSCTXGETCHANNEL(command);
+		auxMenuStatus->transmit_mode = 0;
+		auxMenuStatus->txpower = 0;
+		auxMenuStatus->rftxpower = CMDSCTXGETPOWER(command);
+		auxMenuStatus->frame_length = CMDSCTXGETLENGTH(command);
+		auxMenuStatus->frame_period = CMDSCTXGETPERIOD(command);
+		auxMenuStatus->transmit_rate = CMDSCTXGETRATE(command);
+
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		changePrompt(PRMPTTXPERIODPC1, auxMenuStatus);
+		
+	}
+	else
+	{
+		auxMenuStatus->statusInformation = RADIO_TX_PERIODIC_FRAME_TRANSMIT;
+		auxMenuStatus->power_control = 0;
+		auxMenuStatus->channel = CMDSCTXGETCHANNEL(command);
+		auxMenuStatus->transmit_mode = 0;
+		auxMenuStatus->txpower = CMDSCTXGETPOWER(command);
+		auxMenuStatus->rftxpower = 0;
+		auxMenuStatus->frame_length = CMDSCTXGETLENGTH(command);
+		auxMenuStatus->frame_period = CMDSCTXGETPERIOD(command);
+		auxMenuStatus->transmit_rate = CMDSCTXGETRATE(command);
+	
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		changePrompt(PRMPTTXPERIODPC0, auxMenuStatus);
+		
+	}
+	return (0);
+}
+
+/*****************************************************************************/
+
+/* ADD ANTENNA SELECTION OPTION */
+/* ADD EVENT FOR MIN NUMBER OF FRAMES RECEIVED */
+int cmdSetRx (long command, struct menuStatus *auxMenuStatus)
+{
+	cmdExitMode(command, auxMenuStatus);
+	auxMenuStatus->statusInformation = RADIO_RX_SILENT_WIRELESS_TEST;
+	auxMenuStatus->channel = CMDSRXGETCHANNEL(command);
+	applyWirelessSettingsNoMenu (auxMenuStatus);
+	changePrompt(PRMPTRX, auxMenuStatus);
+	return (0);
+}
+
+/*****************************************************************************/
+/*#define CMDCPGETPOWER(x)	(x & 0x0000000F)
+#define CMDCPGETINCRTYPE(x)	((x >> 8) & 0x00000001)
+#define CMDCPGETINCRDIR(x)	((x >> 9) & 0x00000001)*/
+
+int cmdChangePower (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST || \
+	    auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+		if (!CMDCPGETINCRTYPE(command))
+		{
+			auxMenuStatus->txpower = CMDCPGETPOWER(command);
+			MacSetDirectTxPower(auxMenuStatus->txpower);
+			////printMessage(COMMANDEXECUTED);
+			return (0);
+		}
+		else
+		{
+			if (CMDCPGETINCRDIR(command))
+			{
+				auxMenuStatus->txpower += CMDCPGETPOWER(command);
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+				//printMessage(COMMANDEXECUTED);
+				return (0);
+			}
+			else
+			{
+				auxMenuStatus->txpower -= CMDCPGETPOWER(command);
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+				//printMessage(COMMANDEXECUTED);
+				return (0);
+			}
+		}
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+int cmdChangeChannel (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST || \
+	    auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+		auxMenuStatus->channel = CMDCCCHANNEL(command);
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		//printMessage(COMMANDEXECUTED);
+		return (0);
+	}
+	else if (auxMenuStatus->statusInformation == RADIO_RX_SILENT_WIRELESS_TEST)
+	{
+		auxMenuStatus->channel = CMDCCCHANNEL(command);
+		cmdExitMode(command, auxMenuStatus);
+		SetChannel(auxMenuStatus->channel);
+		auxMenuStatus->statusInformation = RADIO_RX_SILENT_WIRELESS_TEST;
+		MacRadioRXTest(1);
+		rxBeforeLoop(&(auxMenuStatus->lastNumRxFrames));
+		changePrompt(PRMPTRX, auxMenuStatus);
+		return (0);
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+int cmdChangeRate (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST || \
+	    auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+		auxMenuStatus->transmit_rate = CMDCRRATE(command);
+		applyWirelessSettingsNoMenu(auxMenuStatus);
+		//printMessage(COMMANDEXECUTED);
+		return (0);
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+int cmdChangeFrameLength (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+		auxMenuStatus->frame_length = CMDCFLLENGTH(command);
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		//printMessage(COMMANDEXECUTED);
+		return (0);
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+int cmdChangeFramePeriod (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+		auxMenuStatus->frame_period = CMDCFPPERIOD(command);
+		applyWirelessSettingsNoMenu (auxMenuStatus);
+		//printMessage(COMMANDEXECUTED);
+		return (0);
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+int cmdReadADCValues (long command, struct menuStatus *auxMenuStatus)
+{
+	/* For measuring ADC value */
+	unsigned char adcValue;
+
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST || \
+	    auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT)
+	{
+
+		reset_max_min_values();
+		waitUS(auxMenuStatus->frame_period * 2 * 1000);
+		
+		switch (CMDRAVGETMEAS(command))
+		{
+			case MAXADC:
+				read_max_conversion (&adcValue);
+			break;
+		
+			case MINADC:
+				//read_max_min_avg_conversion (0, &adcValue);
+			break;
+
+			case AVGADC:
+				//read_max_min_avg_conversion ((command & 0xFF), &adcValue);
+			break;
+		}
+				
+			/* Check desired numerical format */
+		if (!CMDRAVGETFORMAT(command))
+			printf("ADC: %u\r\n",adcValue);
+		else
+			printf("ADC: 0x%02x\r\n",adcValue);
+		
+		return (0);
+	}
+	printError(NOMODESELECTED);
+	return (1);
+}
+
+/*****************************************************************************/
+
+int cmdReadResetRxFrames (long command, struct menuStatus *auxMenuStatus)
+{
+	if (RESETCOUNTER(command))
+		auxMenuStatus->lastNumRxFrames = 0;
+	
+	if (CMDRRFGETFORMAT(command))
+		printf("RXd: %u\r\n",auxMenuStatus->lastNumRxFrames);
+	else
+		printf("RXf: 0x%08x\r\n",auxMenuStatus->lastNumRxFrames);
+
+	
+	return (0);
+}	
+
+
+/*****************************************************************************/
+int cmdExitTestHWWireless (long command, struct menuStatus *auxMenuStatus)
+{
+	cmdExitMode(command, auxMenuStatus);
+	printMessage(PRMPTEXITING);
+	return (-1);
+}
+
+/*****************************************************************************/
+int cmdExitMode (long command, struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST)
+	{
+		PRINTDEBUG("DEBUG: TXCONTOFF\r\n");
+		MacContinuousTransmit(0, \
+			auxMenuStatus->transmit_mode, \
+			auxMenuStatus->transmit_rate);
+		waitUS(100000);
+	}
+	else if (auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT || \
+		 auxMenuStatus->statusInformation == RADIO_START_TX_PERIODIC_FRAME_TRANSMIT || \
+		 auxMenuStatus->statusInformation == RADIO_SWITCH_POWER_CONTROL_LOOP)
+	{
+		MacRadioTXPeriodic(0, \
+			auxMenuStatus->transmit_mode, 
+			auxMenuStatus->transmit_rate, \
+			1000, \
+			auxMenuStatus->frame_period, \
+			auxMenuStatus->frame_length);
+		waitUS(100000);
+	}
+	else if (auxMenuStatus->statusInformation == RADIO_RX_SILENT_WIRELESS_TEST)
+	{
+		rxAfterLoop();
+		MacRadioRXTest(0);
+	}
+
+	auxMenuStatus->statusInformation = RADIO_NOSELECTION;
+	auxMenuStatus->power_control = 0;
+	auxMenuStatus->channel = 1;
+	auxMenuStatus->transmit_mode = 0;
+	auxMenuStatus->txpower = 0;
+	auxMenuStatus->rftxpower = 0;
+	auxMenuStatus->transmit_rate = 0;
+	auxMenuStatus->frame_period = 0;
+	auxMenuStatus->frame_length = 0;
+	auxMenuStatus->lastNumRxFrames = 0;
+	
+	changePrompt(STANDBYNOMODE, auxMenuStatus);
+	return 0;
+}
+
+/*****************************************************************************/
+int cmdReadCalibration (long command, struct menuStatus *auxMenuStatus)
+{
+	return 0;
+}
+
+/*****************************************************************************/
+int cmdSetCalibration (long command, struct menuStatus *auxMenuStatus)
+{
+	printf("Use the following command to load calibration data\r\n");
+	printf("via tftp:\r\n\r\n");
+	printf("update wifical tftp <filename>\r\n");
+	return 0;
+}
+
+/*****************************************************************************/
+int cmdGetStatus (long command, struct menuStatus *auxMenuStatus)
+{
+	return 0;
+}
+
+/*****************************************************************************/
+int mainRoutineTestHWWirelessNoMenu(struct menuStatus *auxMenuStatus)
+{
+	int (*menuFunctions[]) (long , struct menuStatus*) = 
+	{
+		&cmdSetContinousTx,
+		&cmdSetPeriodicTx,
+		NULL, NULL,
+		&cmdSetRx,
+		NULL, NULL, NULL,
+		&cmdChangePower,
+		&cmdChangeChannel,
+		&cmdChangeRate,
+		&cmdChangeFrameLength,
+		&cmdChangeFramePeriod,
+		&cmdReadADCValues,
+		&cmdReadResetRxFrames,
+		&cmdExitMode,
+		&cmdReadCalibration,
+		&cmdSetCalibration,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL,
+		&cmdGetStatus,
+		&cmdExitTestHWWireless
+	};
+
+	unsigned long command;
+	int returned;
+	char *argv[CFG_MAXARGS + 1];
+	char argc;
+	
+	init_adc_pc();
+	
+	SetBSS (0, (unsigned char *) "TESTING123", 10, 0xFFFF, 10);
+	changePrompt(STANDBYNOMODE, auxMenuStatus);
+	refreshPrompt(auxMenuStatus);
+
+	while (1)
+	{
+		do
+		{
+
+			if (auxMenuStatus->statusInformation == RADIO_RX_SILENT_WIRELESS_TEST)
+			{
+				rxLoopExecution(&(auxMenuStatus->lastNumRxFrames));
+				//printf("Waiting: %u", &(auxMenuStatus->lastNumRxFrames));
+			}
+			else if (auxMenuStatus->power_control)
+			{
+				//control loop here
+			}
+
+		} while (!tstc());
+				
+		readline("");
+		
+		/* Extract arguments */
+		if ((argc = parse_line (console_buffer, argv)) == 0)
+		{
+			continue;
+		}
+		else
+		{		
+			command = (unsigned long) simple_strtol (argv[0], NULL, 10);
+			returned = menuFunctions[GETCOMMAND(command)] (command, auxMenuStatus);
+			
+			if (returned == -1)
+				goto EXIT;
+			else
+				refreshPrompt(auxMenuStatus);
+		}
+	}
+	
+	EXIT:
+	{
+		ShutdownHW();
+	}
+	
+	return (0);
+}
+
+
+/*****************************************************************************/
+int applyWirelessSettingsNoMenu (struct menuStatus *auxMenuStatus)
+{
+	
+
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST ||
+	    auxMenuStatus->statusInformation == RADIO_START_CONTINUOUS_TRANSMIT ||
+	    auxMenuStatus->statusInformation == RADIO_SWITCH_POWER_CONTROL_LOOP )
+	{
+		MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+		MacSetDirectTxPower(auxMenuStatus->txpower);
+		waitUS(100000);
+		SetChannel(auxMenuStatus->channel);
+		MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+		MacSetDirectTxPower(auxMenuStatus->txpower);	
+		return 0;
+
+	}
+	else if (auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT ||
+		 auxMenuStatus->statusInformation == RADIO_START_TX_PERIODIC_FRAME_TRANSMIT ||
+		 auxMenuStatus->statusInformation == RADIO_SWITCH_POWER_CONTROL_LOOP)
+	{
+		MacRadioTXPeriodic(0, \
+			auxMenuStatus->transmit_mode, 
+			auxMenuStatus->transmit_rate, \
+			1000, \
+			auxMenuStatus->frame_period, \
+			auxMenuStatus->frame_length);
+		MacSetDirectTxPower(auxMenuStatus->txpower);
+		waitUS(100000);
+		SetChannel(auxMenuStatus->channel);
+		MacRadioTXPeriodic(1, \
+				auxMenuStatus->transmit_mode, \
+				auxMenuStatus->transmit_rate, \
+				1000, \
+				auxMenuStatus->frame_period, \
+				auxMenuStatus->frame_length);
+		MacSetDirectTxPower(auxMenuStatus->txpower);
+		return 0;
+	}
+
+	else if (auxMenuStatus->statusInformation == RADIO_RX_SILENT_WIRELESS_TEST)
+	{
+		SetChannel(auxMenuStatus->channel);
+		MacRadioRXTest(1);
+		rxBeforeLoop(&(auxMenuStatus->lastNumRxFrames));
+	}
+
+	return 1;
+}
+
+/*****************************************************************************/
+int changePrompt(char *newPrompt, struct menuStatus *auxMenuStatus)
+{
+	int aux;
+
+	aux = (int) strcpy(auxMenuStatus->prompt, newPrompt);
+	/* printf("%s ", auxMenuStatus->prompt); */
+	
+	return aux;
+}
+
+/*****************************************************************************/
+void refreshPrompt(struct menuStatus *auxMenuStatus)
+{
+	printf("%s ", auxMenuStatus->prompt);
+}
+
+/*****************************************************************************/
+void printMessage (char *message)
+{
+	printf("%s", message);
+}
+
+/*****************************************************************************/
+void printError(char *errorToPrint)
+{
+	printf("%s", errorToPrint);
+}
+
+#endif
diff --git a/common/digi/cmd_testhw/wireless/commandswifi.h b/common/digi/cmd_testhw/wireless/commandswifi.h
new file mode 100644
index 0000000..e4ffaeb
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/commandswifi.h
@@ -0,0 +1,136 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#ifndef _COMMANDS_WIFI_H
+#define _COMMANDS_WIFI_H
+
+#include "gui_tst_wifi.h"
+#include "calibration.h"
+#include "vBPiper.h"
+#include "adc081C021.h"
+#include "AIROHA_7230.h"
+
+/* Indicated that is an option to be performed only if there is a mode selected previously*/
+#define REQUIRESMODESELEC(x)	((x >> 30) & 0x01)
+
+/* Answers defintion */
+#define COMMANDEXECUTED		"OK\0"
+
+
+/* Error definition */
+#define NOMODESELECTED		"E:0x01\0"
+#define UNKNOWNERROR		"E:0xFF\0"
+
+/* PROMPTS */
+#define STANDBYNOMODE		"?:\0"
+
+/*****************************************************************************/
+#define CMDSCTXGETCHANNEL(x)	((x >> 21) & 0x0000003F)
+#define CMDSCTXGETPC(x)		((x >> 13) & 0x00000001)
+#define CMDSCTXGETTYPE(x)	((x >> 11) & 0x00000003)
+#define CMDSCTXGETRATE(x)	((x >> 7)  & 0x0000000F)
+#define CMDSCTXGETPOWER(x)	( x        & 0x0000007F)
+
+#define PRMPTTXCONTPC0		"TXC0:\0"
+#define PRMPTTXCONTPC1		"TXC1:\0"
+
+int cmdSetContinousTx (long command, struct menuStatus *auxMenuStatus);
+
+/*****************************************************************************/
+#define CMDSCTXGETCHANNEL(x)	((x >> 21) & 0x0000003F)
+#define CMDSCTXGETPERIOD(x)	((x >> 14) & 0x0000007F)
+#define CMDSCTXGETPC(x)		((x >> 13) & 0x00000001)
+#define CMDSCTXGETLENGTH(x)	((x >> 11) & 0x00000003)
+#define CMDSCTXGETRATE(x)	((x >> 7)  & 0x0000000F)
+#define CMDSCTXGETPOWER(x)	( x        & 0x0000007F)
+
+#define PRMPTTXPERIODPC0		"TXP0:\0"
+#define PRMPTTXPERIODPC1		"TXP1:\0"
+
+int cmdSetPeriodicTx (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define PRMPTRX			"RX:\0"
+#define CMDSRXGETCHANNEL(x)	((x >> 21) & 0x0000003F)
+
+int cmdSetRx (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDCPGETPOWER(x)	( x       & 0x0000003F)
+#define CMDCPGETINCRTYPE(x)	((x >> 7) & 0x00000001)
+#define CMDCPGETINCRDIR(x)	((x >> 8) & 0x00000001)
+
+int cmdChangePower (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDCCCHANNEL(x)		((x >> 21) & 0x0000003F)
+
+int cmdChangeChannel (long command, struct menuStatus *auxMenuStatus);
+
+/*****************************************************************************/
+#define CMDCRRATE(x)		((x >> 7) & 0x0000000B)
+
+int cmdChangeRate (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDCFLLENGTH(x)		((x >> 11) & 0x00000003)
+
+int cmdChangeFrameLength (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDCFPPERIOD(x)		((x >> 14) & 0x0000007F)
+
+int cmdChangeFramePeriod (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDRAVGETMEAS(x)	((x >> 7) & 0x03)
+#define CMDRAVGETFORMAT(x)	((x >> 2 & 0x1))
+#define ADCOUTPUT(string)	"ADC: string\r\n"
+
+#define MAXADC		0x00
+#define MINADC		0x01
+#define AVGADC		0x02
+
+int cmdReadADCValues (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define CMDRRFGETFORMAT(x)	((x >> 2 & 0x1))
+#define RESETCOUNTER(x)		(x & 0x01)
+
+#define RXOUTPUT(string)	"RXf: string\r\n"
+
+int cmdReadResetRxFrames (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define PRMPTEXITING	"CLOSING...\r\n\0"
+int cmdExitTestHWWireless (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+int cmdExitMode (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+int cmdReadCalibration (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+int cmdSetCalibration (long command, struct menuStatus *auxMenuStatus);
+
+/*****************************************************************************/
+int cmdGetStatus (long command, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+#define GETCOMMAND(x)		((x >> 27) & 0x0000001F)
+
+int mainRoutineTestHWWirelessNoMenu(struct menuStatus *auxMenuStatus);
+
+/*****************************************************************************/
+int applyWirelessSettingsNoMenu (struct menuStatus *auxMenuStatus);
+
+/*****************************************************************************/
+int changePrompt(char *newPrompt, struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+void refreshPrompt(struct menuStatus *auxMenuStatus);
+/*****************************************************************************/
+void printMessage (char *message);
+/*****************************************************************************/
+void printError(char *error);
+
+//#define DEBUGGING 1
+#ifdef DEBUGGING
+	#define PRINTDEBUG(x)	printf(x);
+#else
+	#define PRINTDEBUG(x)
+#endif
+
+#endif /*COMMAND WIFI*/
+#endif
diff --git a/common/digi/cmd_testhw/wireless/fpArithmetic.h b/common/digi/cmd_testhw/wireless/fpArithmetic.h
new file mode 100644
index 0000000..ca1aced
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/fpArithmetic.h
@@ -0,0 +1,28 @@
+#if 0
+#include <common.h>
+
+#if CFG_HAS_WIRELESS
+
+#ifndef _FPARITHMETIC_H
+#define _FPARITHMETIC_H
+
+/* Approach: 100 codes per 5 dBm change maximum */
+/* Integer required: 7 bits + sign = 8 bits */
+/* Fraction required: 8 bits --> 0.0039 Granularity */
+
+typedef union FIXED816_8tag
+{
+	int full;
+	struct part16_8tag
+	{
+	        signed int integer;
+        	unsigned char fraction;
+    	} part;
+} FIXED16_8;
+
+
+#endif
+
+#endif /* CFG_HAS_WIRELESS */
+
+#endif /*if 0*/
diff --git a/common/digi/cmd_testhw/wireless/gui_tst_wifi.c b/common/digi/cmd_testhw/wireless/gui_tst_wifi.c
new file mode 100644
index 0000000..7651cc1
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/gui_tst_wifi.c
@@ -0,0 +1,1225 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#include "calibration.h"
+/*#include "fpArithmetic.h"*/
+#include "gui_tst_wifi.h"
+#include "vBPiper.h"
+#include "adc081C021.h"
+#include "AIROHA_7230.h"
+
+extern wcd_data_t calDataObtained;
+
+int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+	while (nargs < CFG_MAXARGS) {
+		/* skip any white space */
+		while ((*line == ' ') || (*line == '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+			return (nargs);
+		}
+
+		argv[nargs++] = line;	/* begin of argument string	*/
+
+		/* find end of string */
+		while (*line && (*line != ' ') && (*line != '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+			return (nargs);
+		}
+
+		*line++ = '\0';		/* terminate current arg	 */
+	}
+
+	printf ("** Too many args (max. %d) **\n", CFG_MAXARGS);
+
+	return (nargs);
+}
+
+void printMenu (const unsigned char message[][80], const unsigned char num_of_lines)
+{
+	unsigned char aux;
+	
+	for(aux = 0; aux < num_of_lines; aux++)
+	{
+		printf ("%s", message[aux]);	
+	}
+}
+
+int getSLongConsole(long *returned)
+{
+	int aux;
+		
+	aux = readline(RADIO_TST_PROMPT);
+	
+	if (aux > 0)
+       	{
+        	*returned = simple_strtol (console_buffer, NULL, 10);
+       	}
+       	return aux;
+}
+
+#if 0
+int getSFP16_8ConsoleNOREAD (char *auxConBuff, FIXED16_8 *returned, unsigned char decimalSeparator, char **p)
+{
+	/*int aux;*/
+	//char *p;
+
+	//aux = readline(RADIO_TST_PROMPT);
+	/*if (aux > 0)*/
+       	/*{*/
+		returned->part.integer = simple_strtol (auxConBuff, p, 10);
+		if (**p == decimalSeparator)// || *p == ',')
+			returned->part.fraction = simple_strtol ((*p+1), p, 10);
+		else
+			returned->part.fraction = 0;
+	/*}*/
+       	/*return aux;*/
+	return 0;
+}
+#endif
+int getSLongConsoleNOREAD(char *auxConBuff, long *returned, char **p)
+{
+	/*int aux;*/
+		
+	/*if (aux > 0)*/
+       	/*{*/
+        	*returned = simple_strtol (auxConBuff, p, 10);
+       	/*}*/
+       	/*return aux;*/
+	return 0;
+}
+
+#if 0
+int retrieveLineConsole (lineDefinition *auxLine, unsigned char decimalSeparator, \
+			    unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			    unsigned char lineNumber)
+{
+	int aux;
+	char *p = NULL;
+	
+	printf ("Input_line_%i>>", lineNumber);
+	aux = readline("");
+	if (aux > 0)
+       	{
+		getSFP16_8ConsoleNOREAD(console_buffer, &(auxLine->slope), decimalSeparator, &p);
+		p++;
+		getSFP16_8ConsoleNOREAD(p, &(auxLine->intercept), decimalSeparator, &p);
+		p++;
+		auxLine->maxIndex = 0;
+		getSLongConsoleNOREAD(p, &aux, &p);
+		auxLine->maxIndex = (unsigned long) (0x0000FFFF & aux); /* Max index */
+		p++;
+		getSLongConsoleNOREAD(p, &aux, &p);
+		auxLine->maxIndex |= (unsigned long) ((0x0000FFFF & aux) << 16); /* Min Index */
+		auxLine->crc = 0;
+		auxLine->crc = crc32 (0, (unsigned char*) auxLine, sizeof(auxLine));
+	}
+       	return -1;
+}
+#endif
+
+unsigned int validateValue(signed int *toValidate, enum validateInputs *inputType)
+{
+	/* The condition >= 0 is not necessary while toValidate is unsigned */
+	switch	(*inputType)
+	{
+		case TXPOWER:
+			if (*toValidate >= 0 && *toValidate <= 63)
+				return 0;
+			else
+				return 1;
+		break;
+		case RFTXPOWER:
+			if (*toValidate >= -10000 && *toValidate <= 16000)
+				return 0;
+			else
+				return 1;
+		break;
+		case TRANSMIT_MODE:
+			if (*toValidate >= 0 && *toValidate <= 4)
+				return 0;
+			else
+				return 1;
+		break;
+		case TRANSMIT_RATE:
+			if (*toValidate >= 0 && *toValidate <= 11)
+				return 0;
+			else
+				return 1;
+		break;
+		case CHANNEL:
+			if ( (*toValidate >= 1) && (*toValidate <= 49) )
+				return 0;
+			else
+				return 1;
+		break;
+		case FRAME_PERIOD:
+			if (*toValidate >= 0 && *toValidate <= 100)
+				return 0;
+			else
+				return 1;
+		break;
+		case FRAME_LENGTH:
+			if (*toValidate >= 0 && *toValidate <= 1)
+				return 0;
+			else
+				return 1;
+		break;
+		default:
+			return 1;
+		break;
+	}
+}
+
+unsigned char setControlledTxPower (struct menuStatus *auxMenuStatus)
+{
+	if (auxMenuStatus->power_control == TRUE)
+		/* Measure ADC value */
+		/* Transform ADC value */
+		/* Decivde if corrective measures are necessary */
+		/* Correct output power within the limits */
+		NOP;
+	else
+		MacSetDirectTxPower(auxMenuStatus->txpower);
+
+	return 0;
+}
+
+unsigned char setControlledChannel (struct menuStatus *auxMenuStatus)
+{
+	/* Assuming if rate 1Mbps nulled, complete channel is nulled as well */
+	//if (auxMenuStatus->calData.maxIndexBand_B_G[auxMenuStatus->channel-1][0] == 0)
+	if(0)	
+	{
+		//printf ("Value %d",auxMenuStatus->calData.maxIndexBand_B_G[auxMenuStatus->channel-1][0]);
+		printf ("Channel %d is blocked via software.\n", auxMenuStatus->channel);
+		return 1; /* Channel not allowed */
+	}
+	else
+	{
+		SetChannel(auxMenuStatus->channel);
+		return 0;
+	}
+}
+
+unsigned char applyWirelessSettings (struct menuStatus *auxMenuStatus)
+{
+	/*if (setControlledChannel(auxMenuStatus))
+		return 1;*/
+	SetChannel(auxMenuStatus->channel);
+	MacSetDirectTxPower(auxMenuStatus->txpower);
+
+	if (auxMenuStatus->statusInformation == RADIO_TX_CONTINUOUS_WIRELESS_TEST ||
+	    auxMenuStatus->statusInformation == RADIO_START_CONTINUOUS_TRANSMIT)
+	{
+		MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);	
+
+	}
+	else if (auxMenuStatus->statusInformation == RADIO_TX_PERIODIC_FRAME_TRANSMIT ||
+		 auxMenuStatus->statusInformation == RADIO_START_TX_PERIODIC_FRAME_TRANSMIT ||
+		 auxMenuStatus->statusInformation == RADIO_SWITCH_POWER_CONTROL_LOOP)
+	{
+		MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+				auxMenuStatus->transmit_rate, \
+				1000, \
+				auxMenuStatus->frame_period, \
+				auxMenuStatus->frame_length);		
+	}
+
+	/*if (setControlledTxPower(auxMenuStatus))
+		return 1;*/
+	
+	return 0;
+}
+
+int menuRadioTxContinuousWirelessTest(struct menuStatus *auxMenuStatus)
+{
+	/*struct menuStatus auxMenuStatus; */
+	
+	long auxEnteredValue;
+	/* WARNING */
+	/* unsigned int enteredValue; */
+	signed int enteredValue;
+	enum validateInputs enteredValueType;
+	
+	enteredValueType = TXPOWER;
+	do
+	{
+		printMenu (menu_Request_TX_Power, menu_Request_TX_Power_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+
+	auxMenuStatus->txpower = enteredValue;
+		
+	enteredValueType = TRANSMIT_MODE;
+	do
+	{	
+		printMenu (menu_Request_TX_Mode, menu_Request_TX_Mode_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	
+	auxMenuStatus->transmit_mode = enteredValue;
+	
+	enteredValueType = TRANSMIT_RATE;
+	do
+	{	
+		printMenu (menu_Request_TX_Rate, menu_Request_TX_Rate_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	
+	
+	auxMenuStatus->transmit_rate = enteredValue;
+		
+	enteredValueType = CHANNEL;
+	do
+	{
+		printMenu (menu_Request_TX_Channel, menu_Request_TX_Channel_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	
+	auxMenuStatus->channel = enteredValue;
+	
+	if (applyWirelessSettings (auxMenuStatus))
+	{
+		printf ("One or more errors occured. Settings not activated.\n");
+		return 1;
+	}
+		
+
+	/*printf("Channel: %d -- Tx Power: %d -- Tx Mode: %s -- Tx Rate: %s\n", \
+		auxMenuStatus->channel, \ 
+		auxMenuStatus->txpower, \
+		nTs_transmit_mode[auxMenuStatus->transmit_mode], \
+		nTs_transmit_rate[auxMenuStatus->transmit_rate]);*/
+
+	/*SetChannel(auxMenuStatus->channel);
+	MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+	MacSetDirectTxPower(auxMenuStatus->txpower);*/
+	
+	subMenuRadioTxContinuousWirelessTest(auxMenuStatus);
+	return 0;
+}
+
+
+void subMenuRadioTxContinuousWirelessTest(struct menuStatus *auxMenuStatus)
+{
+	signed int value;
+	unsigned char instantadc;
+	unsigned long avgadc, maxadc;
+	unsigned char loopadc;
+	enum validateInputs valueType;
+	
+	char *argv[CFG_MAXARGS + 1];
+	// Delete if not error: char finaltoken[CFG_CBSIZE];
+	char argc;
+	char *p = '\0';
+
+		
+	while (1)
+	{
+		printf("Channel: %d -- Tx Power: %d -- Tx Mode: %s -- Tx Rate: %s\n", \
+			freqTableAiroha_7230[auxMenuStatus->channel].channelFrequency, \
+			auxMenuStatus->txpower, \
+			nTs_transmit_mode[auxMenuStatus->transmit_mode], \
+			nTs_transmit_rate[auxMenuStatus->transmit_rate]);
+		
+		printMenu (submenu_Radio_Tx_Cont_Wir_Test, submenu_Radio_Tx_Cont_Wir_Test_size);
+		printf(RADIO_TST_PROMPT);
+	
+		do
+		{
+			NOP;
+		} while (!tstc());
+				
+		readline("");
+		
+		/* Extract arguments */
+		if ((argc = parse_line (console_buffer, argv)) == 0) {
+			continue;
+		}
+				
+		value = (signed int) simple_strtol (argv[1], &p, 10);
+		
+		switch (argv[0][0])
+		{
+			/* Change channel */
+			case 'c':
+				valueType = CHANNEL;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->channel = value;
+				// To prevent the carrier appear as a peak with OFDM modulation, we have first to cancel the continuous
+				// TX before changing the channel.
+				//MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				//SetChannel(auxMenuStatus->channel);
+				//MacSetDirectTxPower(auxMenuStatus->txpower);
+				//MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				waitUS(100000); // If change channel in same moment, then appeads peaks in CCK/PSK.
+				SetChannel(auxMenuStatus->channel);
+				//setControlledChannel(auxMenuStatus->channel);
+				MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change rate */
+			case 'm':
+				valueType = TRANSMIT_RATE;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else
+				{
+					MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+					auxMenuStatus->transmit_rate = value;
+				}
+				/* Check why I need a delay ?*/
+				/* TBD */
+				//waitUS(100000);
+				//SetChannel(auxMenuStatus->channel);
+				//MacSetDirectTxPower(auxMenuStatus->txpower);
+				//MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				//MacUpdateFccBufferX(auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				waitUS(100000); // If change channel in same moment, then appears peaks in CCK/PSK.
+				SetChannel(auxMenuStatus->channel);
+				MacContinuousTransmit(1, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				/*#if CONFIG_CCW9P9215
+					waitUS(100000); // If change channel in same moment, then appears peaks in CCK/PSK.
+				#endif*/
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Increase power */
+			case '+':
+				if (auxMenuStatus->txpower == 63)
+				{
+					printf ("Maximum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else	
+					auxMenuStatus->txpower++;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Decrease power */
+			case '-':
+				if (auxMenuStatus->txpower == 0)
+				{
+					printf ("Minimum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else
+					auxMenuStatus->txpower--;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change power */
+			case 'p':
+				valueType = TXPOWER;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->txpower = value;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Obtain instant value from ADC*/
+			case 'i':
+				read_conversion (&instantadc);
+				printf("%u\n",instantadc);
+				
+			break;
+			/* Obtain averaged value from ADC*/
+			case 'a':
+				avgadc = 0;
+				maxadc = 0;
+				reset_max_min_values();
+				for(loopadc=0; loopadc<100; loopadc++) 
+				{	
+					waitUS(1000);
+					read_conversion (&instantadc);
+					avgadc += instantadc;
+				}
+				avgadc /= 100;
+				read_max_conversion ((unsigned char *) &maxadc);
+				printf("%u, %u\n",avgadc, maxadc);
+				
+			break;
+			/* Exit subMenu */
+			case 'q':
+				//MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				goto EXIT_SUB_CONT_TX;
+			break;
+			default:
+				printf ("\nWrong value, try again:\n");
+				ERROR_SUB_CONT_TX:
+			break;
+		}
+	}
+	
+	EXIT_SUB_CONT_TX:
+	{
+		NOP;
+	}
+
+}
+
+int menuRadioTxPeriodicWirelessTest(struct menuStatus *auxMenuStatus)
+{
+	/* struct menuStatus auxMenuStatus; */
+	
+	long auxEnteredValue;
+	/* WARNING */
+	/* unsigned int enteredValue; */
+	signed int enteredValue;
+	enum validateInputs enteredValueType;
+
+	enteredValueType = TXPOWER;
+	do
+	{
+		printMenu (menu_Request_TX_Power, menu_Request_TX_Power_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->txpower = enteredValue;
+
+	enteredValueType = FRAME_PERIOD;
+	do
+	{	
+		printMenu (menu_Request_TX_Frame_Period, menu_Request_TX_Frame_Period_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->frame_period = enteredValue;
+
+	enteredValueType = FRAME_LENGTH;
+	do
+	{	
+		printMenu (menu_Request_TX_Frame_Length, menu_Request_TX_Frame_Length_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->frame_length = enteredValue;
+
+	
+	enteredValueType = TRANSMIT_RATE;
+	do
+	{	
+		printMenu (menu_Request_TX_Rate, menu_Request_TX_Rate_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->transmit_rate = enteredValue;
+		
+	enteredValueType = CHANNEL;
+	do
+	{
+		printMenu (menu_Request_TX_Channel, menu_Request_TX_Channel_size);	  
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->channel = enteredValue;
+	
+	if (applyWirelessSettings (auxMenuStatus))
+	{
+		printf ("One or more errors occured. Settings not activated.\n");
+		return 1;
+	}
+		
+	/*printf("Channel: %d -- Tx Power: %d -- Tx Rate: %s -- Frame Length: %s -- Frame Rate: %d ms. --\n",
+		auxMenuStatus->channel, \
+		auxMenuStatus->txpower, \
+		nTs_transmit_rate[auxMenuStatus->transmit_rate], \
+		nTs_frame_length[auxMenuStatus->frame_length], \
+		auxMenuStatus->frame_period);*/
+	
+	//applyWirelessSettings (auxMenuStatus);
+
+	/*SetChannel(auxMenuStatus->channel);
+	MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      auxMenuStatus->transmit_rate, \
+			      1000, \
+			      auxMenuStatus->frame_period, \
+			      auxMenuStatus->frame_length);
+	MacSetDirectTxPower(auxMenuStatus->txpower);*/
+	
+	subMenuRadioTxPeriodicWirelessTest(auxMenuStatus);
+	return 0;
+}
+
+void subMenuRadioTxPeriodicWirelessTest(struct menuStatus *auxMenuStatus)
+{
+	signed int value;
+	unsigned char maxadc;
+	enum validateInputs valueType;
+	
+	char *argv[CFG_MAXARGS + 1];
+	/*char finaltoken[CFG_CBSIZE];*/
+	char argc;
+	char *p = '\0';
+
+	int auxPAStatus;
+	int auxFTXStatus;
+
+	/*To delete*/
+	unsigned int readAux;
+
+
+	auxPAStatus = 0x000A3;
+	auxFTXStatus = 0x221BB;
+		
+	while (1)
+	{
+		printf("Channel: %d -- Tx Power: %d -- Tx Rate: %s -- Frame Length: %s -- Frame Rate: %d ms. --\n",
+			freqTableAiroha_7230[auxMenuStatus->channel].channelFrequency, \
+			auxMenuStatus->txpower, \
+			nTs_transmit_rate[auxMenuStatus->transmit_rate], \
+			nTs_frame_length[auxMenuStatus->frame_length], \
+			auxMenuStatus->frame_period);
+
+		printf("\nPA Value: %x\n", auxPAStatus);
+
+		printMenu (submenu_Radio_Tx_Cont_Wir_Test, submenu_Radio_Tx_Cont_Wir_Test_size);
+		printf(RADIO_TST_PROMPT);
+
+		do
+		{
+			NOP;
+		} while (!tstc());
+				
+		readline("");
+		
+		/* Extract arguments */
+		if ((argc = parse_line (console_buffer, argv)) == 0) {
+			continue;
+		}
+				
+		value = (signed int) simple_strtol (argv[1], &p, 10);
+		
+		switch (argv[0][0])
+		{
+			/* Change channel */
+			case 'c':
+				valueType = CHANNEL;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->channel = value;
+				//setControlledChannel(auxMenuStatus->channel);
+				//SetChannel(auxMenuStatus->channel);
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+				waitUS(100000); // If change channel in same moment, then appeads peaks in CCK/PSK.
+				SetChannel(auxMenuStatus->channel);
+				//setControlledChannel(auxMenuStatus->channel);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+				/*#if CONFIG_CCW9P9215
+					waitUS(100000); // If change channel in same moment, then appears peaks in CCK/PSK.
+				#endif*/
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change rate */
+			case 'm':
+				valueType = TRANSMIT_RATE;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else
+				{
+					MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+					auxMenuStatus->transmit_rate = value;
+				}
+				/* Check why I need a delay ?*/
+				/* TBD */
+				waitUS(100000);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);
+				//MacUpdateFccBufferX(auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				break;
+			/* Increase power */
+			case '+':
+				if (auxMenuStatus->txpower == 63)
+				{
+					printf ("Maximum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else	
+					auxMenuStatus->txpower++;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Decrease power */
+			case '-':
+				if (auxMenuStatus->txpower == 0)
+				{
+					printf ("Minimum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else
+					auxMenuStatus->txpower--;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change power */
+			case 'p':
+				valueType = TXPOWER;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->txpower = value;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Obtain averaged value from ADC*/
+			case 'a':
+				reset_max_min_values();
+				waitUS(200000);
+				read_max_conversion (&maxadc);
+				printf("%u\n",maxadc);
+				
+			break;
+
+			case '1':
+				/*valueType = TRANSMIT_RATE;
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+				auxPAStatus &= ((~0x7) << 6);
+				auxPAStatus |= ((value & 0x7) << 6);
+				WriteRF(12, auxPAStatus);
+				
+				//waitUS(100000);
+				/*MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+			break;
+
+			case '2':
+				/*valueType = TRANSMIT_RATE;
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+				auxPAStatus &= (~0x7 << 3);
+				auxPAStatus |= (value << 3);
+				WriteRF(12, auxPAStatus);
+				
+				/*waitUS(100000);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+			break;
+
+			case '3':
+				/*valueType = TRANSMIT_RATE;
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+				auxPAStatus &= (~0x7);
+				auxPAStatus |= (value);
+				WriteRF(12, auxPAStatus);
+				
+				/*waitUS(100000);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);*/
+				
+			break;
+
+			case 'b':
+				valueType = TRANSMIT_RATE;
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);
+				
+				auxFTXStatus &= (0xFFFFFF & (~0x3 << 18));
+				auxFTXStatus |= (value << 18);
+				WriteRF(9, auxFTXStatus);
+				
+				waitUS(100000);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);
+				
+			break;
+
+			/* Exit subMenu */
+			case 'q':
+				//MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate, 100);
+				goto EXIT_SUB_CONT_TX;
+			break;
+			case 'r':
+				readAux = 0;
+				__read32(HW_MAC_STATUS, &readAux);
+				printf("Status register HW_MAC_STATUS: 0x%x\n", readAux);
+			/* Show error, repeat subMenu */
+			break;
+			/* Show error, repeat subMenu */
+			default:
+				printf ("\nWrong value, try again:\n");
+				ERROR_SUB_CONT_TX:
+			break;
+		}
+	}
+	
+	EXIT_SUB_CONT_TX:
+	{
+	
+	}
+
+}
+
+int menuRadioTxPeriodicControlLoop(struct menuStatus *auxMenuStatus)
+{
+	/* struct menuStatus auxMenuStatus; */
+	
+	long auxEnteredValue;
+	/* WARNING */
+	/* unsigned int enteredValue; */
+	signed int enteredValue;
+	enum validateInputs enteredValueType;
+
+	enteredValueType = RFTXPOWER;
+	do
+	{
+		printMenu (menu_Request_RF_TX_Power, menu_Request_RF_TX_Power_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue ((signed int *) &auxEnteredValue, &enteredValueType));
+	auxMenuStatus->rftxpower = enteredValue;
+
+	auxMenuStatus->frame_period = 20;
+	auxMenuStatus->frame_length = 0;
+
+	enteredValueType = TRANSMIT_RATE;
+	do
+	{	
+		printMenu (menu_Request_TX_Rate, menu_Request_TX_Rate_size);
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->transmit_rate = enteredValue;
+		
+	enteredValueType = CHANNEL;
+	do
+	{
+		printMenu (menu_Request_TX_Channel, menu_Request_TX_Channel_size);	  
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	auxMenuStatus->channel = enteredValue;
+	
+	if (applyWirelessSettings (auxMenuStatus))
+	{
+		printf ("One or more errors occured. Settings not activated.\n");
+		return 1;
+	}
+		
+	return 0;
+}
+
+void menuRadioSilentRX(struct menuStatus *auxMenuStatus)
+{
+	long auxEnteredValue;
+	signed int enteredValue;
+	unsigned int tst;
+	unsigned int longt;
+	enum validateInputs enteredValueType;
+
+	enteredValueType = CHANNEL;
+	do
+	{
+		printMenu (menu_Request_TX_Channel, menu_Request_TX_Channel_size);	  
+		getSLongConsole(&auxEnteredValue);
+		enteredValue = (signed int) auxEnteredValue;
+	} while (validateValue (&enteredValue, &enteredValueType));
+	
+	auxMenuStatus->channel = enteredValue;	
+
+	setControlledChannel(auxMenuStatus);
+	MacRadioRXTest(1);
+	__read32(HW_VERSION,&longt);
+	printf("Counter Before: 0h%x\n", longt);
+	MacReadPacketFromBuffer(&tst);
+	/* 13/07/09 */
+	MacRadioRXTest(0); /* This shoudl be the correct way. Test and delete comment */
+	__read32(HW_VERSION,&longt);
+	printf("Counter After: 0h%x\n", longt);
+	printf("Received frames: %u\n", tst);
+}
+
+/**************************************************************
+ * tst_wifi()
+ **************************************************************/
+int tst_wifi (struct menuStatus *auxMenuStatus)
+{
+	/* int i; */
+	
+	/* For user input */
+        int error_code;
+        long read_value;
+	char *s;
+
+	/* Initializes ADC from wireless for power control */
+	init_adc_pc();
+
+	//displayPowerLimitValues(&(auxMenuStatus->calData));
+
+	/* Displays the main menu listing all the tests */
+	printMenu (menu_principal_header, menu_principal_header_size);
+	
+	/* Declared in vBPiper.h */
+	//#ifdef IBSSOFF
+		SetBSS (0, (unsigned char *) "TESTING123", 10, 0xFFFF, 10); /* "TESTING123" */
+    	//#endif
+
+    	/* Main loop for program interaction */
+    	while (1)
+    	{
+        	/* Displays the main menu listing all the tests */
+		printMenu (menu_principal_body, menu_principal_body_size);
+		
+              	/* get a line of input from the user */
+	        error_code = getSLongConsole(&read_value);
+                if (error_code < 0)
+              	{
+	 		printf ("\n Wrong value, try again:\n");
+	                return 0;
+        	}
+                else
+		{
+			auxMenuStatus->statusInformation = (unsigned char) read_value;
+
+			if ( (auxMenuStatus->statusInformation >= RADIO_TX_CONTINUOUS_WIRELESS_TEST) \
+			      && (auxMenuStatus->statusInformation <= RADIO_EXIT) )
+                	{
+				switch (auxMenuStatus->statusInformation)
+	        		{
+					case RADIO_TX_CONTINUOUS_WIRELESS_TEST:
+			        		menuRadioTxContinuousWirelessTest(auxMenuStatus);
+						MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+			        	break;
+
+			        	case RADIO_START_CONTINUOUS_TRANSMIT:
+						menuRadioTxContinuousWirelessTest(auxMenuStatus);
+			        	break;
+
+			        	case RADIO_STOP_CONTINUOUS_TRANSMIT:
+			        		MacContinuousTransmit(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+			        	break;
+
+			        	case RADIO_RX_SILENT_WIRELESS_TEST:
+			        		menuRadioSilentRX (auxMenuStatus);
+						//MacRadioRXTest(0);
+			        	break;
+
+			        	case RADIO_TX_PERIODIC_FRAME_TRANSMIT:
+						menuRadioTxPeriodicWirelessTest(auxMenuStatus);
+						MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, \
+			      					      auxMenuStatus->transmit_rate, \
+			      				              1000, \
+			      					      auxMenuStatus->frame_period,  \
+			      					      auxMenuStatus->frame_length);
+			        	break;
+
+			        	case RADIO_START_TX_PERIODIC_FRAME_TRANSMIT:
+			        		menuRadioTxPeriodicWirelessTest(auxMenuStatus);
+			        	break;
+						
+					case RADIO_STOP_TX_PERIODIC_FRAME_TRANSMIT:
+						MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, \
+								      auxMenuStatus->transmit_rate, \
+							              1000, \
+								      auxMenuStatus->frame_period,  \
+								      auxMenuStatus->frame_length);
+					break;
+			
+					case RADIO_WRITE_RF:
+						printf ("Write to RF is not yet available.\n");
+						for (error_code = 0; error_code < 255; error_code++)
+						{
+							printf ("Index: %i, ADC: %i\n", (unsigned int) getAIfromADC(&calDataObtained, error_code, 1, 0), error_code);
+						}
+					break;
+
+				        case RADIO_READ_MAC_ADDRESS:
+				        	if ((s = getenv("wlanaddr")) != NULL)
+						{
+							printf("%s\n", s);
+						}
+				        break;
+
+				        case RADIO_SET_CALIBRATION_COEF:
+						retrieveCalData(&calDataObtained ,'.',',',';');
+						printf ("Returned value SaveInFlash: %i\n", NvPrivWCDSaveInFlash(&calDataObtained));
+						//waitUS(1000000);
+						//printf ("Returned value GetFromFlashAndSaveInNvram: %i\n", NvPrivWCDGetFromFlashAndSetInNvram());
+						/* This will go to another function in order to do the following */
+						/* Check if module calibrated and test pass*/
+						/* If calibrated and tested, modification is not possible */
+						/* if test not passed, then calibration is possible */
+						/*for (i=0; i<7; i++)
+						{
+							retrieveLineConsole (&calData[i], '.',',',';', i);
+						}*/
+						/* Write calibration to flash */
+						auxMenuStatus->calibration_status = TRUE;
+				        break;
+
+					case RADIO_READ_CALIBRATION_COEF:
+						
+						printCalData(&calDataObtained);
+						/*if (auxMenuStatus->calibration_status == FALSE)
+							printf ("Module not calibrated.\n");
+						else
+						{
+							for (i=0; i<7; i++)
+							{
+								printf("Line %i = %i.%i, %i.%i, %i, %i, 0x%8x\n", i,  \
+									calData[i].slope.part.integer, calData[i].slope.part.fraction, \
+									calData[i].intercept.part.integer, calData[i].intercept.part.fraction, \
+									(calData[i].maxIndex & 0x0000FFFF), ((calData[i].maxIndex & 0xFFFF0000) >> 16), \
+									calData[i].crc);
+							}
+						}*/
+				        break;
+
+				        case RADIO_SWITCH_POWER_CONTROL_LOOP:
+					 	menuRadioTxPeriodicControlLoop(auxMenuStatus);
+						PIDController (&calDataObtained, auxMenuStatus->rftxpower,auxMenuStatus->channel, auxMenuStatus->transmit_rate);
+						MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, \
+			      					      auxMenuStatus->transmit_rate, \
+			      				              1000, \
+			      					      auxMenuStatus->frame_period,  \
+			      					      auxMenuStatus->frame_length);
+						
+						/*printf ("The new power control status is: ");
+						if (auxMenuStatus->power_control == 0)
+						{
+							auxMenuStatus->power_control = 1;
+							printf ("active.\n");
+						}
+						else
+						{
+							auxMenuStatus->power_control = 0;
+							printf ("inactive.\n");
+						}*/
+				        break;
+					
+					case RADIO_EXIT:
+						goto EXIT;
+					break;
+			
+					default:
+						printf ("\n Unknown test error\n");
+					break;
+
+				}
+
+				auxMenuStatus->statusInformation = RADIO_NOSELECTION;
+			}
+			else
+			{
+				printf("Values outside the range, please repeat.\n");
+				auxMenuStatus->statusInformation = RADIO_NOSELECTION;
+			}
+		}
+	}
+	
+	EXIT:
+	{
+		ShutdownHW();
+		return 0;
+	}
+}
+
+
+void tst_wifi_nomenu(struct menuStatus *auxMenuStatus)
+{
+	signed int value;
+	unsigned char maxadc;
+	enum validateInputs valueType;
+	
+	char *argv[CFG_MAXARGS + 1];
+	/*char finaltoken[CFG_CBSIZE];*/
+	char argc;
+	char *p = '\0';
+
+		
+	while (1)
+	{
+		printMenu (submenu_Radio_Tx_Cont_Wir_Test, submenu_Radio_Tx_Cont_Wir_Test_size);
+		printf(RADIO_TST_PROMPT);
+
+		do
+		{
+			NOP;
+		} while (!tstc());
+				
+		readline("");
+		
+		/* Extract arguments */
+		if ((argc = parse_line (console_buffer, argv)) == 0) {
+			continue;
+		}
+				
+		value = (signed int) simple_strtol (argv[1], &p, 10);
+		
+		switch (argv[0][0])
+		{
+			/* Change channel */
+			case 'c':
+				valueType = CHANNEL;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->channel = value;
+				//setControlledChannel(auxMenuStatus->channel);
+				//SetChannel(auxMenuStatus->channel);
+				MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+				waitUS(100000); // If change channel in same moment, then appeads peaks in CCK/PSK.
+				SetChannel(auxMenuStatus->channel);
+				//setControlledChannel(auxMenuStatus->channel);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+				/*#if CONFIG_CCW9P9215
+					waitUS(100000); // If change channel in same moment, then appears peaks in CCK/PSK.
+				#endif*/
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change rate */
+			case 'm':
+				valueType = TRANSMIT_RATE;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else
+				{
+					MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, 
+			      				      auxMenuStatus->transmit_rate, \
+			      				      1000, \
+			      				      auxMenuStatus->frame_period, \
+			      				      auxMenuStatus->frame_length);
+					auxMenuStatus->transmit_rate = value;
+				}
+				/* Check why I need a delay ?*/
+				/* TBD */
+				waitUS(100000);
+				MacRadioTXPeriodic(1, auxMenuStatus->transmit_mode, \
+			      			      auxMenuStatus->transmit_rate, \
+			      			      1000, \
+			      			      auxMenuStatus->frame_period, \
+			      			      auxMenuStatus->frame_length);
+				//MacUpdateFccBufferX(auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate);
+				break;
+			/* Increase power */
+			case '+':
+				if (auxMenuStatus->txpower == 63)
+				{
+					printf ("Maximum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else	
+					auxMenuStatus->txpower++;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Decrease power */
+			case '-':
+				if (auxMenuStatus->txpower == 0)
+				{
+					printf ("Minimum output power index reached.\n");
+					goto ERROR_SUB_CONT_TX;
+				}
+				else
+					auxMenuStatus->txpower--;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Change power */
+			case 'p':
+				valueType = TXPOWER;
+				if (validateValue (&value, &valueType))
+					goto ERROR_SUB_CONT_TX;
+				else	
+					auxMenuStatus->txpower = value;
+				MacSetDirectTxPower(auxMenuStatus->txpower);
+			break;
+			/* Obtain averaged value from ADC*/
+			case 'a':
+				reset_max_min_values();
+				waitUS(200000);
+				read_max_conversion (&maxadc);
+				printf("%u\n",maxadc);
+				
+			break;
+			/* Exit subMenu */
+			case 'q':
+				//MacRadioTXPeriodic(0, auxMenuStatus->transmit_mode, auxMenuStatus->transmit_rate, 100);
+				goto EXIT_SUB_CONT_TX;
+			break;
+			/* Show error, repeat subMenu */
+			default:
+				printf ("\nWrong value, try again:\n");
+				ERROR_SUB_CONT_TX:
+			break;
+		}
+	}
+	
+	EXIT_SUB_CONT_TX:
+	{
+	
+	}
+
+}
+
+
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/gui_tst_wifi.h b/common/digi/cmd_testhw/wireless/gui_tst_wifi.h
new file mode 100644
index 0000000..0f22bda
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/gui_tst_wifi.h
@@ -0,0 +1,246 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#ifndef _GUI_TST_WIFI_H
+#define _GUI_TST_WIFI_H
+
+/* imports from common/main.c */
+extern char console_buffer[CFG_CBSIZE];
+
+/* ARM specific */
+#define NOP asm("MOV r0, r0")
+
+/* enum used to list all tests that can be conducted using the application. */
+enum radio_test_t
+{
+	RADIO_NOSELECTION = 0,
+	RADIO_TX_CONTINUOUS_WIRELESS_TEST = 1,
+	RADIO_START_CONTINUOUS_TRANSMIT,
+	RADIO_STOP_CONTINUOUS_TRANSMIT,
+	RADIO_RX_SILENT_WIRELESS_TEST,
+	RADIO_TX_PERIODIC_FRAME_TRANSMIT,
+	RADIO_WRITE_RF,
+	RADIO_START_TX_PERIODIC_FRAME_TRANSMIT,
+	RADIO_STOP_TX_PERIODIC_FRAME_TRANSMIT,
+	RADIO_READ_MAC_ADDRESS,
+	RADIO_READ_VERSION_REVISION,
+	RADIO_SET_CALIBRATION_COEF,
+	RADIO_READ_CALIBRATION_COEF,
+	RADIO_SWITCH_POWER_CONTROL_LOOP,
+	RADIO_EXIT
+};
+
+/* enum used to list all calibration related actions */
+enum radio_calibrate_t
+{
+    RADIO_CALIBRATE_TRANSMITTER,
+    RADIO_CHARACTERIZE_TRANSMITTER,
+    RADIO_CORRELATE_ADC_READINGS_WITH_VOLTMETER_READINGS,
+    RADIO_CALIBRATE_RECEIVER
+};
+
+/* Used for user values input validation */
+enum validateInputs {TXPOWER, TRANSMIT_MODE, TRANSMIT_RATE, CHANNEL, FRAME_LENGTH, FRAME_PERIOD, RFTXPOWER};
+
+
+#define RANDOM		0
+#define ZEROS		1
+#define ONES		2
+#define UNMODULATED 	3
+#define FCC		4
+static const unsigned char nTs_transmit_mode[][12] =
+{
+	"RANDOM\0",
+	"ZEROS\0", 
+	"ONES\0", 
+	"UNMODULATED\0", 
+	"FCC\0"
+};
+
+
+#define IS_CCK_DSSS(r)	(r >= 0 && r < 4)
+#define IS_OFDM(r)	(r > 4 && r < 12)
+
+static const unsigned char nTs_transmit_rate[][8] =
+{
+	"1Mbps\0", "2Mbps\0", "5.5Mbps\0", "11Mbps\0", "6Mbps\0", "9Mbps\0",
+	"12Mbps\0", "18Mbps\0", "24Mbps\0", "36Mbps\0", "48Mbps\0", "54Mbps\0"
+};
+
+#define SIZE1024BYTES	0
+#define SIZE128BYTES	1
+static const unsigned char nTs_frame_length[][11] =
+{
+	"1024 bytes\0",
+	"128 bytes\0"
+};
+
+
+// DELETE IF NOT ERROR:  #define CTRL_C_CHAR 0x03
+// DELETE IF NOT ERROR:  #define RADIO_TST_PROMPT ">> "
+
+/* Used where we get input from user. */
+// DELETE IF NOT ERROR: #define FCC_INPUT_BUFFER_SIZE 64
+
+
+struct menuStatus 
+{
+	enum radio_test_t statusInformation;
+	unsigned char power_control;
+	unsigned char calibration_status;
+	unsigned char channel;
+	unsigned char transmit_mode;
+	unsigned char txpower;
+	unsigned int  rftxpower;
+	unsigned char transmit_rate;
+	unsigned char frame_period;
+	unsigned char frame_length;
+	unsigned int  lastNumRxFrames;
+	char 	      prompt[12];
+//	struct wlanCalibrationData calData;
+};
+
+
+/*typedef struct lineDefinition
+{
+	FIXED16_8 	slope;
+   	FIXED16_8 	intercept;
+   	unsigned long 	maxIndex;
+   	unsigned long	crc;
+} lineDefinition;
+static lineDefinition calData[7];*/
+
+
+#define RADIO_TST_PROMPT 	"TST_WIFI>>"
+
+
+static const unsigned char menu_principal_header [][80]
+					= { 
+						"\n\0",
+						"**********************************\n\0",
+						"* Test 802.11 radio transceiver: *\n\0",
+						"**********************************\n\0",
+						"\n\0"
+					  };
+					  
+static const unsigned char menu_principal_header_size = 4;
+
+static const unsigned char menu_principal_body [][80] 
+					= {
+	            				" 1) Wireless Continuous Transmit Test\n\0",
+            					" 2) Start Wireless Continuous Transmit Test\n\0",
+            					" 3) Stop Wireless Continuous Transmit Test\n\0",
+            					" 4) Wireless Silent Test\n\0",
+            					" 5) Wireless Transmit Periodic frame Test\n\0",
+            					" 6) Write to RF Transceiver\n\0",
+            					" 7) Start Wireless Periodic Transmit Test\n\0",
+            					" 8) Stop Wireless Periodic Transmit Test\n\0",
+            					" 9) Read Radio Mac Address\n\0",
+            					"10) Read Radio Version-Revision\n\0",
+            					"11) Set Calibration Coefficients\n\0",
+						"12) Read Calibration Coefficients\n\0",
+            					"13) Switch Control Loop Status\n\0",
+						"14) Quit\n\0"
+					   }; 
+					   
+static const unsigned char menu_principal_body_size = 14;
+
+static const unsigned char menu_Request_TX_Power [][80]
+					= {
+						"Enter wireless TX Power (from [Min = 0] up to [Max = 63])\n\0",
+					  };
+					
+static const unsigned char menu_Request_TX_Power_size = 1;
+
+static const unsigned char menu_Request_RF_TX_Power [][80]
+					= {
+						"Enter wireless TX Power (from Min = 0, (0 dBm) up to Max = 1600 (for 16 dBm))\n\0",
+					  };
+					
+static const unsigned char menu_Request_RF_TX_Power_size = 1;
+					
+static const unsigned char menu_Request_TX_Mode [][80]
+					= {
+						"Enter wireless transmit mode --> \n\0",
+						"     0=random, 1=zeros, 2=ones, 3=unmodulated, 4=fcc\n\0"
+					};
+					
+static const unsigned char menu_Request_TX_Mode_size = 2;
+					
+static const unsigned char menu_Request_TX_Rate [][80]
+					= {
+					            				
+            					"Enter wireless transmit rate -->\n\0",
+            					"      0 =  1Mbps,  1 =  2Mbps, 2 = 5.5Mbps, 3 = 11Mbps, 4 =  6Mbps\n\0",
+            					"      5 =  9Mbps,  6 = 12Mbps, 7 =  18Mbps, 8 = 24Mbps, 9 = 36Mbps\n\0",
+            					"     10 = 48Mbps, 11 = 54Mbps\n\0"
+					};
+					
+static const unsigned char menu_Request_TX_Rate_size = 4;
+					
+static const unsigned char menu_Request_TX_Channel [][80]
+					= {
+            					"Enter wireless channel to transmit/receive on (1 - 49)\n\0",
+					  };
+					  
+static const unsigned char menu_Request_TX_Channel_size = 1;
+
+static const unsigned char menu_Request_TX_Frame_Period [][80]
+					= {
+            					"Enter TX frame period (0 - 100 msecs)\n\0"
+					  };
+					  
+static const unsigned char menu_Request_TX_Frame_Period_size = 1;
+
+static const unsigned char menu_Request_TX_Frame_Length [][80]
+					= {
+            					"Enter TX frame length -->\n\0",
+						"     0 = 1024 bytes, 1 = 128 bytes\n\0"
+					  };
+					  
+static const unsigned char menu_Request_TX_Frame_Length_size = 2;
+					  
+static const unsigned char submenu_Radio_Tx_Cont_Wir_Test [][80]
+					= {
+						"Type 'c' to change channel, followed by the new channel value\n\0",
+						"Type 'm' to change transmit rate, followed by the new rate value\n\0", 
+            					"Type (+/-) to increase/decrease power\n\0",
+            					"Type 'p' to change power, followed by the new power value\n\0",
+            					"Type q to quit\n\0"
+					  };
+					  
+static const unsigned char submenu_Radio_Tx_Cont_Wir_Test_size = 5;
+
+void printMenu (const unsigned char message[][80], const unsigned char num_of_lines);
+
+int parse_line (char *line, char *argv[]);
+int getSLongConsole(long *returned);
+/*int getSFP8_8ConsoleNOREAD (char *auxConBuff, FIXED16_8 *returned, unsigned char decimalSeparator, char **p);*/
+int getSLongConsoleNOREAD(char *auxConBuff, long *returned, char **p);
+/*int retrieveLineConsole (lineDefinition *auxLine, unsigned char decimalSeparator, \
+			    unsigned char valuesSeparator, unsigned char endProcessSeparator, \
+			    unsigned char lineNumber);
+*/
+
+unsigned int validateValue(signed int *toValidate, enum validateInputs *inputType);
+unsigned char setControlledTxPower (struct menuStatus *auxMenuStatus);
+unsigned char setControlledChannel (struct menuStatus *auxMenuStatus);
+unsigned char applyWirelessSettings (struct menuStatus *auxMenuStatus);
+
+
+int menuRadioTxContinuousWirelessTest(struct menuStatus *auxMenuStatus);
+void subMenuRadioTxContinuousWirelessTest(struct menuStatus *auxMenuStatus);
+int menuRadioTxPeriodicWirelessTest(struct menuStatus *auxMenuStatus);
+void subMenuRadioTxPeriodicWirelessTest(struct menuStatus *auxMenuStatus);
+void menuRadioSilentRX(struct menuStatus *auxMenuStatus);
+int menuRadioTxPeriodicControlLoop(struct menuStatus *auxMenuStatus);
+
+int tst_wifi (struct menuStatus *auxMenuStatus);
+
+
+#endif
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/mac.h b/common/digi/cmd_testhw/wireless/mac.h
new file mode 100644
index 0000000..27b8c11
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/mac.h
@@ -0,0 +1,437 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+//
+// Embedded 802.11b wireless network interface
+// MAC layer internal defines
+// Copyright 2003 Digi International
+//
+
+#ifndef _MAC_H
+#define _MAC_H
+
+#define uint32_2 		unsigned long
+#define uint16 		unsigned short
+#define uint8  		unsigned char
+
+#define wln_rand    0
+
+
+#define WLN_MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+#define WLN_MAC2STR(a) (a)[5], (a)[4], (a)[3], (a)[2], (a)[1], (a)[0]
+
+//
+// Implementation constants
+//
+#define	BUF_SIZE			512*3+128	// Max IP size (1500) + LLC/SNAP size (8)
+
+// For the WiWave we need more MAC buffers, we need to constantly poll
+// the WiWave and need buffers available to do this, otherwise
+// the WiWave will lock up.
+#define	BEACON_MISS			6		// Missed beacons to start new scan
+#define	RSSI_SCALE			32		// RSSI samples to average
+
+// Preferred SSID if searching for any SSID
+#define	PREF_SSID			"Connect"
+#define	PREF_SSID_LEN		((sizeof PREF_SSID)-1)
+
+//
+// 802.11 MIB constants
+//
+#define	SHORT_RETRY_LIMIT	7			// Small frame transmit retry limit
+#define	LONG_RETRY_LIMIT	4			// Large frame transmit retry limit
+
+#define	CW_MIN				31			// Min contention window size
+#define	CW_MAX				1023		// Max contention window size
+
+#define TU					1024L/1000	// Time unit (in msecs)
+#define	MAX_TX_LIFETIME		(512*TU)	// Transmit lifetime limit (in msecs)
+#define	MAX_RX_LIFETIME		(512*TU)	// Receive lifetime limit (in msecs)
+
+/******************************************************************************/
+/* 802.11 MAC FRAME FORMATS ***************************************************/
+/******************************************************************************/
+
+#define	IV_SIZE		4		// Initialization vector size
+#define	EXTIV_SIZE	8		// IV and extended IV size
+#define	SNAP_SIZE	8		// LLC/SNAP header size
+#define	ICV_SIZE	4		// Integrity check value size
+#define	MIC_SIZE	8		// Message integrity check size
+#define	FCS_SIZE	4		// FCS (CRC-32) size
+
+#define	WEP_SIZE	(IV_SIZE+ICV_SIZE)	// Total WEP size
+#define	TKIP_SIZE	(EXTIV_SIZE+ICV_SIZE)	// Total TKIP size
+#define	CCMP_SIZE	(EXTIV_SIZE+MIC_SIZE)	// Total CCMP size
+
+#define TKIP_KEY_SIZE		32		// TKIP/MIC key size
+#define CCMP_KEY_SIZE		16		// CCMP key size
+
+#define	CHAL_SIZE		128		// Authentication challenge size
+
+#define	RTS_SIZE		20		// RTS frame size
+#define	CTS_SIZE		14		// CTS frame size
+#define	DATA_SIZE		28		// Data frame header+FCS size
+#define	ACK_SIZE		14		// ACK frame size
+
+// Max total MAC frame size
+#define	MAX_FRAME_SIZE		(DATA_SIZE+BUF_SIZE+TKIP_SIZE+MIC_SIZE)
+
+// Max number of fragments
+#define	MAX_FRAGS			16
+
+// Frame header modulation type field
+#define	MOD_PSKCCK		0x00	// PSK/CCK modulation
+#define	MOD_OFDM		0xEE	// OFDM modulation
+
+// PSK/CCK PLCP service field bits
+#define	SERVICE_LOCKED		0x04	// Locked clocks
+#define	SERVICE_MODSEL		0x08	// Modulation selection
+#define	SERVICE_LENEXT		0x80	// Length extension
+
+// MAC type field values
+#define	TYPE_ASSOC_REQ		0x00	// Association request
+#define	TYPE_ASSOC_RESP		0x10	// Association response
+#define	TYPE_REASSOC_REQ	0x20	// Reassociation request
+#define	TYPE_REASSOC_RESP	0x30	// Reassociation response
+#define	TYPE_PROBE_REQ		0x40	// Probe request
+#define	TYPE_PROBE_RESP		0x50	// Probe response
+
+#define	TYPE_BEACON		0x80	// Beacon
+#define	TYPE_ATIM		0x90	// Annoucement traffice indication
+#define	TYPE_DISASSOC		0xA0	// Disassociation
+#define	TYPE_AUTH		0xB0	// Authentication
+#define	TYPE_DEAUTH		0xC0	// Deauthentication
+
+#define TYPE_RTS		0xB4	// Request to send
+#define TYPE_CTS		0xC4	// Clear to send
+#define TYPE_ACK		0xD4	// Acknowledgement
+#define TYPE_PSPOLL		0xA4	// Power Save(PS)-Poll
+
+#define TYPE_DATA		0x08	// Data
+#define TYPE_NULL_DATA      	0x48    // Null Data
+
+// TRUE if buf is data or management frame
+#define	IS_DATA(buf)		(((buf)->macHdr.fc.type & 0xcf) == TYPE_DATA)
+#define	IS_MGMT(buf)		(((buf)->macHdr.fc.type & 0x0f) == 0)
+// Authentication algorithm number field values
+#define	AUTH_OPEN			0x00	// Open system
+#define	AUTH_SHAREDKEY		0x01	// Shared key
+#define	AUTH_LEAP			0x80	// LEAP
+
+// Capability information field bits
+#define	CAP_ESS				0x0001	// Extended service set (infrastructure)
+#define	CAP_IBSS			0x0002	// Independent BSS (ad hoc)
+#define	CAP_POLLABLE		0x0004	// Contention free pollable
+#define	CAP_POLLREQ			0x0008	// Contention free poll request
+#define	CAP_PRIVACY			0x0010	// Privacy (WEP) required
+#define	CAP_SHORTPRE		0x0020	// Short preambles allowed
+#define	CAP_PBCC			0x0040	// PBCC modulation allowed
+#define	CAP_AGILITY			0x0080	// Channel agility in use
+#define	CAP_SHORTSLOT		0x0400	// Short slot time in use
+#define	CAP_DSSSOFDM		0x2000	// DSSS-OFDM in use
+
+// Status code field values
+#define	STAT_SUCCESS		0
+
+// Reason code field values
+#define	REAS_NOLONGERVALID	2
+#define	REAS_DEAUTH_LEAVING	3
+#define	REAS_INACTIVITY		4
+#define REAS_INCORRECT_FRAME_UNAUTH 6
+#define REAS_INCORRECT_FRAME_UNASSO 7
+
+// Information element IDs
+#define	ELEM_SSID			0		// Service set ID
+#define	ELEM_SUPRATES		1		// Supported rates
+#define	ELEM_DSPARAM		3		// DS parameter set
+#define	ELEM_IBSSPARAM		6		// IBSS parameter set
+#define ELEM_COUNTRY        7       // Country information
+#define	ELEM_CHALLENGE		16		// Challenge text
+#define ELEM_ERPINFO		42		// Extended rate PHY info
+#define ELEM_RSN			48		// Robust security network (WPA2)
+#define	ELEM_EXTSUPRATES	50		// Extended supported rates
+#define ELEM_VENDOR			221		// Vendor extension (WPA)
+// Use short preamble if allowed in BSS and params and rate > 1 mbps.
+#define	USE_SHORTPRE(rate)	((rate) > 0 && \
+							 !(erpInfo & ERP_BARKER) && \
+							 (macParams.options & WLN_OPT_SHORTPRE))
+	
+// MAC address macros
+#define	MAC_GROUP			0x01	// Broadcast or multicast address
+#define	MAC_LOCAL			0x02	// Locally administered address
+
+#define	IS_GROUP_ADDR(addr)	(addr[0] & MAC_GROUP)
+#define	EQUAL_ADDR(a1, a2)	(memcmp (a1, a2, WLN_ADDR_SIZE) == 0)
+#define	SET_ADDR(a1, a2)	(memcpy (a1, a2, WLN_ADDR_SIZE))
+
+// Authentication algorithm number field values
+#define	AUTH_OPEN			0x00	// Open system
+#define	AUTH_SHAREDKEY		0x01	// Shared key
+#define	AUTH_LEAP			0x80	// LEAP
+
+// Capability information field bits
+#define	CAP_ESS				0x0001	// Extended service set (infrastructure)
+#define	CAP_IBSS			0x0002	// Independent BSS (ad hoc)
+#define	CAP_POLLABLE		0x0004	// Contention free pollable
+#define	CAP_POLLREQ			0x0008	// Contention free poll request
+#define	CAP_PRIVACY			0x0010	// Privacy (WEP) required
+#define	CAP_SHORTPRE		0x0020	// Short preambles allowed
+#define	CAP_PBCC			0x0040	// PBCC modulation allowed
+#define	CAP_AGILITY			0x0080	// Channel agility in use
+#define	CAP_SHORTSLOT		0x0400	// Short slot time in use
+#define	CAP_DSSSOFDM		0x2000	// DSSS-OFDM in use
+
+// Status code field values
+#define	STAT_SUCCESS		0
+
+// Reason code field values
+#define	REAS_NOLONGERVALID	2
+#define	REAS_DEAUTH_LEAVING	3
+#define	REAS_INACTIVITY		4
+#define REAS_INCORRECT_FRAME_UNAUTH 6
+#define REAS_INCORRECT_FRAME_UNASSO 7
+
+// Information element IDs
+#define	ELEM_SSID			0		// Service set ID
+#define	ELEM_SUPRATES		1		// Supported rates
+#define	ELEM_DSPARAM		3		// DS parameter set
+#define	ELEM_IBSSPARAM		6		// IBSS parameter set
+#define ELEM_COUNTRY        7       // Country information
+#define	ELEM_CHALLENGE		16		// Challenge text
+#define ELEM_ERPINFO		42		// Extended rate PHY info
+#define ELEM_RSN			48		// Robust security network (WPA2)
+#define	ELEM_EXTSUPRATES	50		// Extended supported rates
+#define ELEM_VENDOR			221		// Vendor extension (WPA)
+
+// 802.11d related defines
+// minimum length field value in country information elelment
+#define COUNTRY_INFO_MIN_LEN   6
+
+// Supported rates bits
+#define	RATE_BASIC			0x80	// Bit set if basic rate
+
+// TRUE if channel number in 5 GHz band
+//#define	CHAN_5G(chan)		((chan) > 14)
+
+// ERP info bits
+#define	ERP_NONERP			0x01	// Non-ERP present
+#define	ERP_USEPROTECT		0x02	// Use protection
+#define	ERP_BARKER			0x04	// Barker (long) preamble mode
+
+// WPA/RSN info length field
+#define	wpa_info_len		wpa_info[1]
+#define rsn_info_len        rsn_info[1]
+
+// Key ID byte in data frame body
+#define	EXT_IV				0x20	// Extended IV is present
+
+// Correct CRC-32 check value
+#define	GOOD_CRC32			0x2144df1c
+
+
+#define GET_UPPER_LONG(x)	(x >> 16)
+#define GET_LOWER_LONG(x)	(x & 0x0000FFFF)
+
+//
+// 802.11 MAC frame structures.
+// These structures lay out a complete PLCP/MAC frame in a single memory region.
+// They are compiler dependent.
+//
+
+/******************************************************************************/
+/* RECEIVE FRAME HEADER --> PIPER Programming Manual 1.3 - Page 46 ************/
+/******************************************************************************/
+typedef uint32_2 RxFrameHeader;
+
+#define GET_MODTYP_RX(x)	(x >> 24)
+#define GET_ANTENNA(x)		((x & 0x00800000) >> 22)	
+#define GET_RSSIVGA(x)		((x & 0x00600000) >> 20)
+#define GET_RSSILNA(x)		((x & 0x001F8000) >> 18)
+#define GET_FREQOFF(x)		( x & 0x00007FFF)
+
+/******************************************************************************/
+/* TRANSMIT FRAME HEADER --> PIPER Programming Manual 1.3 - Page 48 ***********/
+/******************************************************************************/
+typedef uint32_2 TxFrameHeader;
+
+#define GET_LSBLENGTH(x)	(x >> 24)
+#define GET_MSBLENGTH(x)	GET_LOWER_LONG(x)
+#define GET_MODTYP_TX(x)	(x & 0x000000FF)
+
+#define SET_TXFRAMEHEADER(length, mod) (((0x00000000 | (0x1F & length)) << 8) | (0xFF & mod))
+
+/* Union of frame header types ************************************************/
+typedef union {
+	RxFrameHeader rx;		// Receive frame header
+	TxFrameHeader tx;		// Transmit frame header
+} FrameHeader;
+
+/******************************************************************************/
+/* PSK/CCK PLCP HEADER (WORD 2) --> PIPER Programming Manual 1.3 - Page 45|48 */
+/* This frame is common for Tx and Rx buffers for PSK/CCK Frames.	      */
+/******************************************************************************/
+typedef uint32_2 PskCckHeader;
+
+/* #define GET_SIGNAL(x)		(x >> 24)
+#define GET_SERVICE(x)		((x & 0x00FF0000) >> 16) 
+#define GET_LENGTH(x)		(x & 0x0000FFFF)*/
+#define GET_PSKHEADER_LENGTH(x)		( (x) >> 16 )
+#define GET_PSKHEADER_SERVICE(x)	( (x & 0x0000FF00) >> 8 )
+#define GET_PSKHEADER_SIGNAL(x)		( x & 0x000000FF )
+
+#define SET_PSKCCKHEADER(length, service, signal) ( ( ( ( (0x00000000 | (0xFFFF & length)) << 8 ) | (0xFF & service) ) << 8 ) | (0xFF & signal) ) 
+
+/******************************************************************************/
+/* OFMD PLCP HEADER (WORD 2) --> PIPER Programming Manual 1.3 - Page 46       */
+/* This frame is common for Tx and Rx buffers for OFDM Frames.   	      */
+/******************************************************************************/
+typedef uint32_2 OfdmHeader;
+
+/******************************************************************************/
+/* __________________________________________________________________________ */
+/* | P | LENGTH | R | RATE | ________________________________________________ */
+/* |17 | 16 - 5 | 4 |3 - 0 | ________________________________________________ */
+/******************************************************************************/
+
+#define GET_OFDMHEADER_PARITY(x)	( (x & 0x00020000) >> 18 )
+#define GET_OFDMHEADER_LENGTH(x)	( (x & 0x0001FFE0) >> 5 )
+#define GET_OFDMHEADER_RATE(x)		( x & 0x0000000F )
+
+#define SET_PSKOFDMHEADER(parity, length, rate) ( ( ( ( (0x00000000 | (0x1 & parity)) << 12 ) | (0xFFF & length) ) <<  5) | (0xF & rate) )
+
+/* Union of PLCP header types *************************************************/
+typedef union {
+	PskCckHeader 	pskcck;	// PLCP header for PSK/CCK
+	OfdmHeader 	ofdm;	// PLCP header for OFDM
+} PlcpHeader;
+
+/******************************************************************************/
+/* FRAME CONTROL / DURATION FIELD -->  802.11 - Chapter 3 - Page 47 & 50      */
+/******************************************************************************/
+typedef uint32_2 FC_DUR;
+
+#define GET_FC_DUR_DURATION(x)		( ((x) & 0xFFFF0000) >> 16 )
+#define GET_FC_DUR_ORDER(x)		( ((x) & 0x00008000) >> 15 )
+#define GET_FC_DUR_PROTECTEDFRAME(x)	( ((x) & 0x00004000) >> 14 )
+#define GET_FC_DUR_MOREDATA(x)		( ((x) & 0x00002000) >> 13 )
+#define GET_FC_DUR_PWRMGMT(x)		( ((x) & 0x00001000) >> 12 )
+#define GET_FC_DUR_RETRY(x)		( ((x) & 0x00000800) >> 11 )
+#define GET_FC_DUR_MOREFRAG(x)		( ((x) & 0x00000400) >> 10 )
+#define GET_FC_DUR_FROMDS(x)		( ((x) & 0x00000200) >> 9 )
+#define GET_FC_DUR_TODS(x)		( ((x) & 0x00000100) >> 8 )
+#define GET_FC_DUR_SUBTYPE(x)		( ((x) & 0x000000F0) >> 4 )
+#define GET_FC_DUR_TYPE(x)		( ((x) & 0x0000000C) >> 2 )
+#define GET_FC_DUR_PROTOCOL(x)		( ((x) & 0x00000003) )
+
+#define SET_FC_DUR(duration, order, procframe, moredata, pwrmanag, retry, morefrag, fds, tds, subtype, type, protocol) \
+	((((((((((((( 0xFFFF & duration ) << 1 ) | ( 0x1 & order ) << 1 ) | ( 0x1 & procframe ) << 1 ) | ( 0x1 & moredata ) << 1 ) | \
+	( 0x1 & pwrmanag ) << 1 ) | ( 0x1 & retry ) << 1 ) | ( 0x1 & morefrag ) << 1 ) | ( 0x1 & fds ) << 1 ) | \
+	( 0x1 & tds ) << 4 ) | ( 0xF & subtype ) << 2 ) | ( 0x3 & type ) << 2 ) | ( 0x3 & protocol ) )
+
+/* MAC address */
+typedef unsigned char MacAddr[6];
+
+/******************************************************************************/
+/* SEQUENCE CONTROL FIELD -->  802.11 - Chapter 3 - Page 52                   */
+/******************************************************************************/
+typedef struct {
+	unsigned seq		:12;	// Sequence number
+	unsigned frag		:4;	// Fragment number
+} SeqControl;
+
+/* Union of sequence control types ********************************************/
+typedef union {
+	SeqControl 	sq;		// Sequence control fields
+	uint16 		sq16;		// Sequence control as 16-bit int
+} SeqControlU;
+
+//#pragma pack(1)
+
+
+/******************************************************************************/
+/* GENERIC MAC FRAME -->  802.11 - Chapter 3 - Page 52                        */
+/******************************************************************************/
+typedef struct {
+	FC_DUR 	fc_duration;		// Frame control
+					// Duration/ID
+	uint32_2 	addr1;			// Address 1
+	uint32_2 	addr1_2;		// Address 1_2
+	uint32_2 	addr2;			// Address 2
+	uint32_2 	addr3;			// Address 2_3
+	uint32_2 	addr3_squ;		// Address 3_Sequence control fields
+}  MacHeader;
+
+#define GET_PART_MAC1(x)	GET_UPPER_LONG(x)
+#define GET_PART_MAC2(x)	GET_LOWER_LONG(x)
+#define GET_PART_MAC3(x)	GET_UPPER_LONG(x)
+#define GET_SQU(x)		GET_LOWER_LONG(x)
+
+#define SET_MAC1_MAC2(mac1, mac2) ( ( ( 0xFFFF & mac1 ) << 16 ) | ( 0xFFFF & mac2 ) )
+#define SET_MAC2_MAC3(mac2, mac3) ( ( ( 0xFFFF & mac2 ) << 16 ) | ( 0xFFFF & mac3 ) )
+#define SET_MAC3_SQU(mac3, squ)  ( ( ( 0xFFFF & mac3 ) << 16 ) | ( 0xFFFF & squ ) )
+
+// MAC buffer, including complete MAC frame
+typedef struct MacFrameHeader 
+{
+	uint32_2  	frameHdr;	// Frame header
+	uint32_2		plcpHdr;	// PLCP header
+	
+	uint32_2 	fc_duration;		// Frame control
+					// Duration/ID
+	uint32_2 	addr1;			// Address 1
+	uint32_2 	addr1_2;		// Address 1_2
+	uint32_2 	addr2;			// Address 2
+	uint32_2 	addr3;			// Address 2_3
+	uint32_2 	addr3_squ;		// Address 3_Sequence control fields
+	//MacHeader	macHdr;		// MAC header*/
+	
+} MacFrameHeader;
+
+typedef struct BeaconStruct
+{
+	uint32_2		timestamp[2];
+	uint32_2 		interval_capinfo;
+	uint8		nameSSID[10];
+} BeaconStruct;
+
+typedef struct BeaconFrame
+{
+	//MacFrameHeader 	macHdr;
+	uint32_2  	frameHdr;	// Frame header
+	uint32_2		plcpHdr;	// PLCP header
+	
+	uint32_2 		fc_duration;		// Frame control
+					// Duration/ID
+	uint32_2 		addr1;			// Address 1
+	uint32_2 		addr1_2;		// Address 1_2
+	uint32_2 		addr2;			// Address 2
+	uint32_2 		addr3;			// Address 2_3
+	uint32_2 		addr3_squ;		// Address 3_Sequence control fields
+	uint32_2		timestamp[2];
+	uint32_2 		interval_capinfo;
+	uint8		nameSSID[10];
+	//BeaconStruct	beaconFrm;	
+} BeaconFrame;
+
+
+// Rate values
+#define	RATE_MASK_A		0x0ff0
+#define	RATE_MASK_B		0x000f
+#define	RATE_MASK_G		0x0fff
+
+#define	RATE_MASK_PSK		0x0003
+#define	RATE_MASK_CCK		0x000c
+#define	RATE_MASK_OFDM		0x0ff0
+
+#define	RATE_MASK_BASIC		0x0153	// Ad hoc basic rates
+
+#define	RATE_MIN_A		4
+#define	RATE_MIN_B		0
+
+#endif
+
+#endif /* CFG_HAS_WIRELESS */ 
+
diff --git a/common/digi/cmd_testhw/wireless/vBPiper.c b/common/digi/cmd_testhw/wireless/vBPiper.c
new file mode 100644
index 0000000..f80c18b
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/vBPiper.c
@@ -0,0 +1,1845 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+//
+// Embedded 802.11a/g wireless network interface
+// MAC layer hardware interface for ConnectCorewi9p9215 and Connectwiem9210
+// Copyright 2008 Digi International
+//
+
+//#include "wifi.h"
+#include "mac.h"
+#include "vBPiper.h"
+
+//#include "malloc.h"
+#include "AIROHA_7230.h"
+
+/* Includes Baseband firmware image *******************************************/
+#include "wifig_dsp_ucode.c"
+#include "wifig_macassist_ucode.c"
+
+int HW_TEST_MODE = 0;
+int HW_TX_BUFFER[2000];
+
+static unsigned char fcc_txbuffer[64];
+
+#if 0
+unsigned char fcc_txbuffer2[36]={0x00,0x09,0x00,0x00,0x0a,0x04,0x00,0x01, 
+	                         0x08,0x00,0x00,0x00,0x00,0x22,0x33,0x44,
+	                         0x55,0x66,0x10,0x20,0x30,0x40,0x50,0x60,
+	                         0x10,0x20,0x30,0x40,0x50,0x60,0x00,0x00,
+	                         0x05,0x55,0x55,0x00};
+#endif
+	
+/* static unsigned char radio_txbuffer[1024]; */
+
+#if CONFIG_CCW9M2443
+void piperReset (void)
+{
+	(*(volatile unsigned int *)(0x56000010)) = 0x00000050;
+	(*(volatile unsigned int *)(0x56000018)) = 0x002AAA2A;
+	(*(volatile unsigned int *)(0x56000014)) = 0x00000000;
+	waitUS(10);//10
+	(*(volatile unsigned int *)(0x56000014)) = 0x0000000C;
+	waitUS(500);//500
+}
+#elif CONFIG_CCW9P9215
+void piperReset (void)
+{
+	(*(volatile unsigned int *)(0xA090205C)) = 0x1818181D;//0x1818181B;
+	(*(volatile unsigned int *)(0xA0902074)) = 0x00240000;//0x10240000;
+	waitUS(10);
+	(*(volatile unsigned int *)(0xA0902074)) = 0x12240000;//0x10240000;
+	waitUS(500);
+}
+#endif
+
+inline void __write32 (volatile unsigned int *addr, unsigned int data, unsigned char operation)
+{
+	#if CONFIG_CCW9M2443
+		typedef union
+		{
+			unsigned int reg32;
+			struct
+			{
+				unsigned short LSB;
+				unsigned short MSB;
+			} reg16;
+		} c32to16;
+		
+		c32to16 aux;
+		
+		volatile unsigned short *addr_16 = (volatile unsigned short *) addr;
+	#elif CONFIG_CCW9P9215
+		volatile unsigned int *addr_32 = (volatile unsigned int *) addr;
+	#endif
+	
+	switch (operation)
+	{
+		case WRITE:
+			#if CONFIG_CCW9M2443
+				aux.reg32 = data;
+				
+				*(addr_16 + 1) = aux.reg16.MSB;
+				*(addr_16)     = aux.reg16.LSB;
+
+			/*printf("Pointer: %p, %p, %p\n", addr, addr_16, addr_16+1);
+			printf("Data: %x, %x, %x\n", aux.reg32, aux.reg16.MSB, aux.reg16.LSB);*/
+				
+			#elif CONFIG_CCW9P9215
+				*addr_32 = data;
+			#endif
+		break;
+		case AND:
+			#if CONFIG_CCW9M2443				
+				aux.reg16.LSB = *(addr_16);
+				aux.reg16.MSB = *(addr_16 + 1);
+				
+				aux.reg32 &= data;
+				
+				*(addr_16 + 1) = aux.reg16.MSB;
+				*(addr_16)     = aux.reg16.LSB;
+			#elif CONFIG_CCW9P9215
+				*addr_32 &= data;
+			#endif
+		break;
+		case OR:
+			#if CONFIG_CCW9M2443				
+				aux.reg16.LSB = *(addr_16);
+				aux.reg16.MSB = *(addr_16 + 1);
+				
+				aux.reg32 |= data;
+				
+				*(addr_16 + 1) = aux.reg16.MSB;
+				*(addr_16)     = aux.reg16.LSB;	
+			#elif  CONFIG_CCW9P9215
+				*addr_32 |= data;
+			#endif
+		break;
+		default:
+		break;
+			
+	}
+}
+
+void __read32 (volatile unsigned int *addr, unsigned int *data )
+{
+	#if CONFIG_CCW9M2443
+		typedef union
+		{
+			unsigned int reg32;
+			struct
+			{
+				unsigned short LSB;
+				unsigned short MSB;
+			} reg16;
+		} c32to16;
+		
+		c32to16 aux;
+		
+		unsigned short *addr_16;
+		addr_16 = (unsigned short *) addr;
+			
+		aux.reg16.LSB = *(addr_16);
+		aux.reg16.MSB = *(addr_16 + 1);
+		
+		*data = aux.reg32;
+	#elif CONFIG_CCW9P9215
+		*data = (unsigned int) *addr;
+	#endif		
+}
+
+#if 0
+static void HWMemcpy (volatile void *dst_, volatile void *src_, int len)
+
+{
+	volatile uint32 *dst = (uint32 *) dst_;
+	volatile uint32 *src = (uint32 *) src_;
+
+	for (; len >= 16; len -= 16)
+	{
+    		__write32 (dst++, *src++, WRITE);
+		__write32 (dst++, *src++, WRITE);
+		__write32 (dst++, *src++, WRITE);
+		__write32 (dst++, *src++, WRITE);
+	}
+    		
+	for (; len > 0; len -= 4)
+    		__write32 (dst++, *src++, WRITE);
+}
+
+//
+// Copy from receive FIFO
+//
+static void HWReadFifo (void *dst_, int len)
+{
+	uint32 *dst = (uint32 *) dst_;
+
+	for (; len >= 16; len -= 16) //ERRORROROROR: Increase dst for reading.
+	{
+		__read32 (HW_DATA_FIFO, dst);
+		//ByteSwap(dst);
+		//waitUS(50);
+		__read32 (HW_DATA_FIFO, dst);
+		//ByteSwap(dst);
+		//waitUS(50);
+		__read32 (HW_DATA_FIFO, dst);
+		//ByteSwap(dst);
+		//waitUS(50);
+		__read32 (HW_DATA_FIFO, dst);
+		//ByteSwap(dst);
+		//waitUS(50);
+	}
+	for (; len > 0; len -= 4)
+	{
+		__read32 (HW_DATA_FIFO, dst);
+		//ByteSwap(dst);
+		//waitUS(50);
+	}
+}
+
+#endif 
+
+static void HWWriteFifo (void *src_, int len)
+{
+	uint32 *src = (uint32 *) src_;
+  	
+	__write32 (HW_GEN_CONTROL, GEN_TXHOLD, OR);
+	//waitUS(5);
+
+	for (; len >= 16; len -= 16)
+	{
+		__write32 (HW_DATA_FIFO, *src++, WRITE);
+		__write32 (HW_DATA_FIFO, *src++, WRITE);
+		__write32 (HW_DATA_FIFO, *src++, WRITE);
+		__write32 (HW_DATA_FIFO, *src++, WRITE);
+	}
+
+	for (; len > 0; len -= 4)
+		__write32 (HW_DATA_FIFO, *src++, WRITE);
+
+	//waitUS(5);
+	__write32 (HW_GEN_CONTROL, ~GEN_TXHOLD, AND);
+	
+}
+
+#if CONFIG_CCW9M2443
+void initializeuPToKnowState (void)
+{
+	(*(volatile unsigned int *)(0x4f000080)) = 0x0000000F;
+	(*(volatile unsigned int *)(0x4f000084)) = 0x0000001F;
+	(*(volatile unsigned int *)(0x4f000088)) = 0x0000001F;
+	(*(volatile unsigned int *)(0x4f00008C)) = 0x0000000F;
+	(*(volatile unsigned int *)(0x4f000090)) = 0x0000000F;
+	(*(volatile unsigned int *)(0x4f000094)) = 0x0020A091;//0x00202011;
+}
+#elif CONFIG_CCW9P9215
+/* This funtions perform and initialization of the NS9215 CPU to a known state 
+   after the initialization with U-Boot */
+void initializeuPToKnowState (void)
+{
+	/* Configure the following register from NS9215 */
+	/* GPIO's involved */
+	/*	PIPER_RESET in port GPIO_92 */
+	(*(volatile unsigned int *)(0xA090205C)) = 0x1818181D;//0x1818181B;
+	(*(volatile unsigned int *)(0xA0902074)) = 0x12240000;//0x10240000;
+
+	/* Interruptions */
+	/*	PIPER_INT in port GPIO_A0 */
+	(*(volatile unsigned int *)(0xA0902068)) = 0x18181818;/* 0b00011000 */
+	
+	/* CS3 is used for wireless baseband registers. The registers start at address 0x00 - 
+        the base address is defined by the configuration of the chip select.  */
+	*((volatile unsigned int *)0xA0700260) = 0x00000082;
+	/* SOFT RESET */
+	(*(volatile unsigned int *)(0x70000004)) = 0x40000000;//0x10240000;	
+}
+#endif
+
+/*
+ * Write the Piper register to the documented reset values in the PM v1.3 
+ */
+
+void registersPiperToDefault (void)
+{
+	__write32 (HW_GEN_CONTROL, 0x377F4000, WRITE);
+	__write32 (HW_GEN_STATUS, 0x30000010, WRITE);
+	__write32 (HW_RSSI_AES, 0x0000007F, WRITE);
+	__write32 (HW_INTR_MASK, 0x00000000, WRITE);
+	__write32 (HW_INTR_STATUS, 0x00000000, WRITE);
+	__write32 (HW_SPI_CTRL, 0x00000018, WRITE);
+	__write32 (HW_DATA_FIFO, 0x00000000, WRITE);
+	
+	//HW_TRACK_CONTROL 	= 0x377F4000;
+	
+	__write32 (HW_CONF1, 0x8043002C, WRITE);
+	__write32 (HW_CONF2, 0x0882B314, WRITE);
+	__write32 (HW_AES_MODE, 0x00000000, WRITE);
+	__write32 (HW_OUT_CTRL, 0x00000001, WRITE);
+}
+
+/*
+// Delay for usec microseconds
+*/
+void waitUS (unsigned long usec)
+{
+	udelay(usec);
+}
+
+/*
+// Write data to an RF tranceiver register
+// @param addr Register address (4 bits)
+// @param data Data to write (20 bits, bit reversed)
+*/
+void WriteRF (uint8 addr, uint32 data)
+{
+	__write32(HW_SPI, (data << 4) | addr, WRITE);
+	waitUS (10);
+}
+
+void ByteSwap (unsigned int *x)
+{
+   *x = ((((*x) & 0xff) << 24) | (((*x) & 0xff00) << 8) | \
+	   (((*x) >> 8) & 0xff00) | (((*x) >> 24) & 0xff));
+}
+
+/*
+// Load the baseband controller firmware
+*/
+int LoadHW (void)
+{
+	static boolean loaded = FALSE;
+	#if CONFIG_CCW9P9215
+	volatile unsigned int *addr;
+	#endif
+	int i;
+
+	int timeout1 = 300, timeout2 = 300; //NEW
+	unsigned int auxReading = 0; //NEW
+
+	// Load only once after reset
+	if (loaded == TRUE) return 0;
+	
+	//__write32(HW_GEN_CONTROL, 0x377F40000, WRITE);
+	__write32(HW_GEN_CONTROL, 0x377F4000, WRITE);
+	
+	#if CONFIG_CCW9M2443
+	//printf("*************************************************\n");
+	// Zero out MAC assist SRAM (put into known state before enabling MAC assist)
+	for (i = 0; i <= 0x80; i += 0x04)//Tested 0x40 ok in w9m
+	{	
+		__write32(REG32(0x40 + i), 0, WRITE);
+	}
+	
+	/*for (addr=MAC_CTRL_BASE; addr<(MAC_CTRL_BASE+ 0x20); addr += 0x04)
+        {
+                __write32(addr, 0, WRITE);
+        }*/
+
+	//printf("*************************************************\n");
+	#elif CONFIG_CCW9P9215
+	for (addr=MAC_CTRL_BASE; addr<(MAC_CTRL_BASE+ 0x80); addr += 0x04) // Before 0x20
+        {
+                __write32(addr, 0, WRITE);
+        }
+	#endif
+
+    	// Enable download the MAC Assist program RAM
+	__write32(HW_GEN_CONTROL, MACASSIST_LOAD_ENABLE, OR);
+	
+	/* Load MAC Assist data */
+	/* no byte swap is necessary */
+	for (i = 0; i < macassist_data_len; i++)
+	{
+		__write32(HW_DATA_FIFO, wifi_macassist_ucode[i], WRITE);
+        }
+
+    	// disable MAC Assist download
+    	__write32(HW_GEN_CONTROL, ~MACASSIST_LOAD_ENABLE, AND);
+
+	// Enable download the DSP program RAM
+    	__write32(HW_GEN_CONTROL, DSP_LOAD_ENABLE, OR);
+
+	/* Load DSP data */
+	/* no byte swap is necessary */
+    	for (i = 0; i < dsp_data_len; i++)
+    	{
+	        __write32(HW_DATA_FIFO, wifi_dsp_ucode[i], WRITE);
+    	}
+    	// disable DSP download
+    	__write32(HW_GEN_CONTROL, ~DSP_LOAD_ENABLE, AND);
+	
+	// set bit-11 in the general control register to a 1 to start the processors
+    	__write32(HW_GEN_CONTROL, DSP_MACASSIST_ENABLE, OR);
+    	    	
+#if  1 /* mike_spike_code */
+      /* OK, I finally have this timing alignment code working.  The new "magic"
+      value is 0x63 at address 0xA62.  Bit-0 indicates the timing measurement
+      is complete.  Bit-1 indicates that a second timing measurment was
+      performed.  The upper nibble is the timing measurement value.
+
+      This code should eliminate the possibility of spikes at the beginning
+      of all PSK/CCK frames and eliminate the spikes at the end of all
+      PSK (1M, 2M) frames.
+      */
+                
+	// reset the timing value WrPortI(0xA62, NULL, 0x00); 
+	__write32(HW_MAC_STATUS, 0xffff00ff, AND);
+                    
+	__read32(HW_MAC_STATUS, &auxReading);
+	while ( (auxReading & 0x0000ff00) != 0x00006300) //while (RdPortI(0xA62) != 0x63)
+	{          
+		// reset the timing value 
+		__write32(HW_MAC_STATUS, 0xffff00ff, AND);
+		
+		// issue WiFi soft reset     
+		__write32(HW_GEN_STATUS, 0x40000000, WRITE);               
+
+		// Set TX_ON Low WrPortI(0xA3C, NULL, ((RdPortI(0xA3C) & ~0xC0) | 0x80));
+		__write32(HW_OUT_CTRL, 0xffffff3f, AND);
+		__write32(HW_OUT_CTRL, 0x00000080, OR);
+	
+		// Set PA_2G Low WrPortI(0xA3D, NULL, ((RdPortI(0xA3D) & ~0x0C) | 0x08)); 
+		__write32(HW_OUT_CTRL, 0xfffff0ff, AND);
+		__write32(HW_OUT_CTRL, 0x00000a00, OR);
+		
+		// Set RX_ON low  WrPortI(0xA3F, NULL, ((RdPortI(0xA3F) & ~0x30) | 0x20)); 
+		__write32(HW_OUT_CTRL, 0xcfffffff, AND);
+		__write32(HW_OUT_CTRL, 0x20000000, OR);
+		
+		// start the WiFi mac & dsp
+		#if SIMULATING_NETOS_2
+			#if CONFIG_CCW9P9215
+				__write32(HW_GEN_CONTROL, 0x377C0820, WRITE);
+			#elif CONFIG_CCW9M2443
+				__write32(HW_GEN_CONTROL, 0x377F0820, WRITE);
+			#endif
+		#else
+			__write32(HW_GEN_CONTROL, 0x37780820, WRITE);
+		#endif           
+
+		timeout1= 500;
+
+		// Wait for timing measurement to finish
+		__read32(HW_MAC_STATUS, &auxReading);
+		while ( (auxReading & 0x0000ff00) != 0x00000100)
+		{
+			waitUS(2);
+			timeout1--;
+			if (!timeout1)
+				break;
+			__read32(HW_MAC_STATUS, &auxReading);
+		}
+
+		timeout2--;
+		
+		if(!timeout2)
+			return 1;
+		
+		__read32(HW_MAC_STATUS, &auxReading);
+	}   
+
+	// Set TX_ON/RXHP_ON and RX to normal wifi, restore the reset value to HW_OUT_CTRL
+	__write32(HW_OUT_CTRL, 0x1, WRITE);
+
+#endif /* Mike's spike code */
+
+                
+       	// set the TX-hold bit
+	//__write32(HW_GEN_CONTROL, 0x37780080, WRITE);
+/*1/10/09*/
+	__write32(HW_GEN_CONTROL, 0x00000080, OR);
+
+	// clear the TX-FIFO memory
+	for (i=0; i<448; i++)
+		__write32(HW_DATA_FIFO, 0, WRITE);
+
+	// reset the TX-FIFO
+	//__write32(HW_GEN_CONTROL, 0x377800C0, WRITE);
+/*1/10/09*/
+	__write32(HW_GEN_CONTROL, 0x00000040, OR);
+	
+	// release the TX-hold and reset
+	//__write32(HW_GEN_CONTROL, 0x377800C0, WRITE);
+	//__write32(HW_GEN_CONTROL, 0x37780000, WRITE);
+/*1/10/09*/	
+	__write32(HW_GEN_CONTROL, 0x000000C0, OR);
+	__write32(HW_GEN_CONTROL, ~0x000000C0, AND);
+	
+	// AGC disable
+	__write32(HW_GEN_CONTROL, ~0x00800000, AND);
+		
+	loaded = TRUE;
+	return 0;
+}
+
+
+void PowerOnCalibrationRF (unsigned char band_selection, unsigned char one_time)
+{
+	const unsigned int cal_reg_RF [2][4] =	{
+							/* BAND B/G */
+							{0x9ABA8, 0x3ABA8, 0x1ABA8, 0x00000300},
+       							/* BAND A */
+							{0x9ABA8, 0x3ABA8, 0x12BAC, 0x00000300}//0x00000f00
+	
+						};
+						
+	unsigned int i;
+	
+	/* Power-on calibration procedure */
+	if (one_time)
+	{
+		__write32(HW_OUT_CTRL, cal_reg_RF[band_selection][3], OR);
+    		waitUS(150);
+	}
+	
+	/* Calibration procedure */
+	for (i=0;i<3;i++)
+	{
+		WriteRF(15,cal_reg_RF[band_selection][i]);
+		waitUS(50);
+	}
+	
+	//TESTING
+	//__write32(HW_OUT_CTRL, ~cal_reg_RF[band_selection][3], AND);
+	
+}
+
+void InitializeRF(unsigned char band_selection)
+{
+	
+	/*
+	For both bands use only the following configuretion:
+		AND 0xfffff0ff
+		OR  0x00000200
+		OR  0x00000300
+	
+	Ignote NETOS configuration
+	
+	*/
+	
+	const unsigned int ini_reg_Piper [2][2] = {
+							/* BAND B/G */
+						  	{0xfffff0ff, 0x00000200},//cff,200 
+	 						/* BAND A */
+						  	{0xfffff0ff, 0x00000200}//0ff,a00
+						  };
+	
+	/*#if SIMULATING_NETOS
+		const unsigned int ini_reg_RF [2][16] = {
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6CBC0, 0x221BB, 0xE0040, 0x08031, 0x0002B, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  	  	  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC } //0870
+							};*/
+	#if CONFIG_CCW9M2443
+		#if WITH_RSSI_OUTPUT
+		const unsigned int ini_reg_RF [2][16] = {
+								/* BAND B/G */
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6CBC0, 0x221BB, 0xE0040, 0x08031, 0x00070, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							/* BAND A */
+								{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  		  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC }
+							};
+		#else
+		const unsigned int ini_reg_RF [2][16] = {
+								/* BAND B/G */
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6CBC0, 0x221BB, 0xE0040, 0x08031, 0x00070, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							/* BAND A */
+								{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  		  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC }
+							};
+		#endif
+	/*	const unsigned int ini_reg_RF [2][16] = {
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6EBC0, 0x221BB, 0xE0040, 0x08031, 0x00070, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  		  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC }
+							};*/
+	#elif CONFIG_CCW9P9215
+		const unsigned int ini_reg_RF [2][16] = {
+								/* BAND B/G */
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6CBC0, 0x221BB, 0xE0040, 0x08031, 0x0002B, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							/* BAND A */
+								{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  	  	  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC } //0870
+							};
+	/*	const unsigned int ini_reg_RF [2][16] = {
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6EBC0, 0x221BB, 0xE0040, 0x08031, 0x0002B, 0xFFFFF, 0x00000, 0x1ABA8 },
+
+								{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  	  	  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC } //0870
+							};*/
+	#else
+		const unsigned int ini_reg_RF [2][16] = {
+								/* BAND B/G */
+								{ 0x0037C, 0x13333, 0x841FF, 0x3FDFA, 0x7FD78, 0x802BF, 0x56AF3, 0xCE000, 
+							  	  0x6EBC0, 0x221BB, 0xE0040, 0x08031, 0x000A3, 0xFFFFF, 0x00000, 0x1ABA8 },
+	   							/* BAND A */
+								{ 0x0FF52, 0x00000, 0x451FE, 0x5FDFA, 0x67f78, 0x853FF, 0x56AF3, 0xCE000,
+						  	  	  0x6EBC0, 0x221BB, 0xE0600, 0x08031, 0x00143, 0xFFFFF, 0x00000, 0x12BAC } //0870
+						};
+	#endif
+	unsigned char i;
+	
+	/* Initial setting for Piper to control RF transceiver */
+
+	/* Initial settings for 20 MHz reference frequency, 802.11b/g */
+	__write32(HW_OUT_CTRL, ini_reg_Piper[band_selection][0], AND);
+	__write32(HW_OUT_CTRL, ini_reg_Piper[band_selection][1], OR);
+	waitUS(150);	
+
+	
+    	/* Register initialization of the RF transceiver */
+    	for (i=0;i<=15;i++)
+	{
+		WriteRF(i,ini_reg_RF[band_selection][i]);
+		//waitUS(10);
+	}
+
+	//PowerOnCalibrationRF(band_selection);
+}
+
+//
+// Initialize the wireless hardware
+//
+int InitHW (void)
+{
+	//unsigned long aux32;
+
+	// Load the baseband controller firmware
+	if (LoadHW() != 0) return 1;
+
+	/* Initialize baseband general control register */
+	__write32(HW_GEN_CONTROL, GEN_INIT_AIROHA_24GHZ, WRITE); //0x31780005
+	
+	/* OPTIONAL? */
+	__write32(HW_CONF1, 0xff00ffff, AND);
+	__write32(HW_CONF1, TRACK_BG_BAND, WRITE);
+	
+	/* OPTIONAL? */
+	__write32(HW_GEN_STATUS, 1 << 26, OR); // Set the RXHP RST bi
+	          
+	/* OPTIONAL? */
+	__write32(HW_CONF2, 0xff00003f, AND);
+	__write32(HW_CONF2, (0x0C << 18), OR);
+	__write32(HW_CONF2, (0xA6B << 6), OR);  
+	
+	#if SIMULATING_NETOS
+		__write32(HW_CONF2, 0x09325AD4, WRITE);
+	#else
+		/* OPTIONAL? */
+		__write32(HW_CONF2, 0x08329AD4, WRITE);
+	#endif
+
+	/* Initialize the SPI word length */	   
+	__write32(HW_SPI_CONTROL, SPI_INIT_AIROHA, WRITE);
+		
+	// Clear the Interrupt Mask Register before enabling external interrupts.
+	// Also clear out any status bits in the Interrupt Status Register.
+	__write32(HW_INTR_MASK, 0, WRITE);
+	__write32(HW_INTR_STATUS, 0x00, WRITE);//0xff;
+	__write32(HW_INTR_MASK, INTR_RXFIFO|INTR_TXEND|INTR_TIMEOUT|INTR_RXOVERRUN, WRITE);
+	
+	/*
+	 * Make sure secondary MAC addresses are disabled and set to
+	 * zero by default.
+	 */
+	__write32(HW_MAC_CONTROL, ~CTRL_MAC_FLTR, AND);
+	
+	/* make sure addresses are zero to start with
+	 * to insure we don't start with extraneous bits */
+	__write32(HW_STA2ID0, 0, WRITE);
+	__write32(HW_STA2ID1, 0, WRITE);
+	__write32(HW_STA3ID0, 0, WRITE);
+	__write32(HW_STA3ID1, 0, WRITE);
+
+	
+	__write32(HW_STAID0, 0x00010203, WRITE);
+	__write32(HW_STAID1, 0x04050000, OR);
+	//__write32(HW_STAID0, 0x0004F301, WRITE);
+	//__write32(HW_STAID1, 0x8E720000, OR);
+	
+	// Antenna Mapping
+	__write32(HW_RSSI_AES, 0x00FFFFFF, AND);
+	
+	#if SIMULATING_NETOS
+		__write32(HW_RSSI_AES, 0x1E000000, OR);
+	#else
+		__write32(HW_RSSI_AES, 0x69000000, OR);
+	#endif
+	
+	// Select Primary Antenna 
+	__write32(HW_GEN_CONTROL, 0xfffffffb, AND);
+
+	// reset RX and TX FIFOs
+    	__write32(HW_GEN_CONTROL, (GEN_RXFIFORST | GEN_TXFIFORST), OR);
+	__write32(HW_GEN_CONTROL, ~(GEN_RXFIFORST | GEN_TXFIFORST), AND);
+	    	
+	// DAC Quadrature-Inphase enable
+	// Tracking cte 2412-2472 Mhz
+	__write32(HW_CONF1, 0xC043002C, WRITE);
+		
+	/* Initialize RF transceiver */
+	InitializeRF(RF_24GHZ);
+	PowerOnCalibrationRF(RF_24GHZ,1);
+
+
+	// Host int inverted.
+	__write32(HW_OUT_CTRL, 1 << 26, OR);
+	  
+	return 0;
+}
+void ShutdownHW (void)
+{
+	//printf ("HW shutdown\n");
+    
+	// Disable receiving
+	__write32(HW_GEN_CONTROL, ~GEN_RXEN, AND);
+	__write32(HW_MAC_CONTROL, 0, WRITE);
+	__write32(HW_INTR_MASK, 0, WRITE);
+}
+
+//
+// Select a channel
+// @param channel Channel number: 1-22
+//
+void SetChannel (unsigned char channel)
+{
+	/* Disable the rx processing path */
+    	__write32(HW_GEN_CONTROL, ~GEN_RXEN, AND);
+	
+	/* perform chip and frequency-band specific RF initialization */
+	
+	if ( CHAN_5G(channel) )
+	{
+		__write32(HW_GEN_CONTROL, ~GEN_PA_ON, AND);
+		
+		/* 12/03/2009 */
+// 		/* Added from initial 5 Ghz configuration */
+		//__write32(HW_GEN_CONTROL, 0x8, OR);
+		
+		/* 12/03/2009 */
+		/* Non fully tested */
+		__write32(HW_TRACK_CONTROL, 0xff00ffff, AND);
+		if (CHAN_4920_4980(channel))
+			__write32(HW_TRACK_CONTROL, TRACK_4920_4980_A_BAND, OR);
+		else if (CHAN_5150_5350(channel))
+			__write32(HW_TRACK_CONTROL, TRACK_5150_5350_A_BAND, OR);
+		else if (CHAN_5470_5725(channel))
+			__write32(HW_TRACK_CONTROL, TRACK_5470_5725_A_BAND, OR);
+		else if (CHAN_5725_5825(channel))
+			__write32(HW_TRACK_CONTROL, TRACK_5725_5825_A_BAND, OR);
+		else
+			__write32(HW_TRACK_CONTROL, TRACK_BG_BAND, OR);
+
+		InitializeRF(RF_50GHZ);
+		PowerOnCalibrationRF(RF_50GHZ, 1);
+	}
+	else
+	{
+		__write32(HW_GEN_CONTROL, GEN_PA_ON, OR);
+		
+		/* 12/03/2009 */
+		/* Added from initial 2.4 Ghz configuration */
+		//__write32(HW_GEN_CONTROL, ~0x8, AND);
+		
+		/* 12/03/2009 */
+		/* Non fully tested */
+		__write32(HW_TRACK_CONTROL, 0xff00ffff, AND);
+		__write32(HW_TRACK_CONTROL, TRACK_BG_BAND, OR);
+		
+		InitializeRF(RF_24GHZ);
+		PowerOnCalibrationRF(RF_24GHZ, 1);
+	    	
+		//__write32(HW_GEN_CONTROL, ~GEN_5GEN, AND);
+	}
+
+	/* Set the channel frequency */
+	WriteRF (0, freqTableAiroha_7230[channel].integer);
+	waitUS(1);
+	WriteRF (1, freqTableAiroha_7230[channel].fraction);
+	waitUS(11); //before waitUS(1);
+	    	
+	if ( CHAN_5G(channel) )
+	{
+		WriteRF (4, freqTableAiroha_7230[channel].addres4Airoha);
+		waitUS(10);
+		PowerOnCalibrationRF(RF_50GHZ, 1);
+		// No effect detected __write32(HW_GEN_CONTROL, GEN_5GEN, OR);
+		//__write32(HW_GEN_CONTROL, ~GEN_5GEN, AND);
+	}
+	else
+	{
+		WriteRF (4, freqTableAiroha_7230[channel].addres4Airoha);
+		waitUS(10);
+		PowerOnCalibrationRF(RF_24GHZ, 1);
+		
+		__write32(HW_GEN_CONTROL, ~GEN_5GEN, AND);
+	}
+	
+	/* configure the baseband processing engine */		    
+	//__write32(HW_GEN_CONTROL, ~GEN_5GEN, AND);
+	
+	/*Re-enable the rx processing path */
+	__write32(HW_GEN_CONTROL, GEN_RXEN, OR);
+}
+
+
+//
+// This function is used to fill the fcc_txbuffer with random data
+// for the transmit test.
+//
+void MacUpdateFccBuffer(unsigned int transmit_mode, unsigned int transmit_rate)
+{
+	int i;
+	unsigned long *aux;
+	/* WARNING MODIFICATION */
+	aux = (unsigned long *) fcc_txbuffer;/* (added unsigned long *) */
+	const unsigned char auxArray[12][3] = 
+				{
+					{0x00, 0x10, 0x0A}, /*1mpbs*/
+					{0x00, 0x10, 0x14}, /*2mbps*/
+					{0x00, 0x10, 0x37}, /*5.5mbps*/
+					{0x00, 0x10, 0x6E}, /*11mbps*/
+					  /*** OFMD ***/
+					{0xEE, 0x10, 0x0B}, /*6mbps*/
+					{0xEE, 0x10, 0x0F}, /*9mbps*/
+					{0xEE, 0x10, 0x0A}, /*12mbps*/
+					{0xEE, 0x10, 0x0E}, /*18mbps*/
+					{0xEE, 0x10, 0x09}, /*24mbps*/
+					{0xEE, 0x10, 0x0D}, /*36mbps*/
+					{0xEE, 0x10, 0x08}, /*48mbps*/
+					{0xEE, 0x10, 0x0C}, /*54mbps*/
+				};
+
+	if (transmit_rate >= 0 && transmit_rate <= 11)
+	{
+		*aux = (auxArray[transmit_rate][0]  << 24) | (auxArray[transmit_rate][1]  << 16) | 0x00000000; 
+		*(aux+1) = (auxArray[transmit_rate][2]  << 24) | 0x00000000;
+		
+		//printf ("%x\n", *aux);
+		//printf ("%x", *(aux+1));
+		//fcc_txbuffer[3] = (auxArray[transmit_rate][0]); 
+	    	//fcc_txbuffer[2] = (auxArray[transmit_rate][1]); 
+		//fcc_txbuffer[7] = (auxArray[transmit_rate][2]);
+		
+	}
+	else
+	{
+		fcc_txbuffer[0] = (0x00); 
+	    	fcc_txbuffer[1] = (0x10); 
+		fcc_txbuffer[4] = (0x0A);
+	}
+
+	if (transmit_mode == 4)
+	{
+		/* for fcc transmit 01 pattern */
+		for (i=8; i < 64; i++)
+		{
+		    fcc_txbuffer[i] = 0xaa;
+		}
+	}
+	else
+	{
+		for (i=8; i < 64; i++)
+		{
+		    fcc_txbuffer[i] = (unsigned char) 0xaa;//rand();
+		}
+	}
+	/* copy to transmit buffer */
+	//HWMemcpy (HW_TX_BUFFER, fcc_txbuffer, 64);
+	HWWriteFifo (&fcc_txbuffer, 16);
+	
+}
+
+
+
+void MacUpdateBuffer(unsigned int transmit_mode, unsigned int transmit_rate)
+{
+	int i;
+	/* WARNING */
+	unsigned int aux;/* unsigned long *aux */
+	
+	
+	const unsigned int auxArray[12][2] = 
+		{
+			{0x00001000, 0x0000000A}, /*1mpbs*/
+  			{0x00001000, 0x00000014}, /*2mbps*/
+    		 	{0x00001000, 0x00000037}, /*5.5mbps*/
+     			{0x00001000, 0x0000006E}, /*11mbps*/
+  			/*** OFMD ***/
+			{0x000010EE, 0x0000000B}, /*6mbps*/
+			{0x000010EE, 0x0000000F}, /*9mbps*/
+			{0x000010EE, 0x0000000A}, /*12mbps*/
+			{0x000010EE, 0x0000000E}, /*18mbps*/
+			{0x000010EE, 0x00000009}, /*24mbps*/
+			{0x000010EE, 0x0000000D}, /*36mbps*/
+  			{0x000010EE, 0x00000008}, /*48mbps*/
+     			{0x000010EE, 0x0000000C} /*54mbps*/
+		};
+	
+	__write32 (HW_GEN_CONTROL, GEN_TXHOLD, OR);
+	
+	aux = auxArray[transmit_rate][0];
+	ByteSwap(&aux);
+	__write32 (HW_DATA_FIFO, aux, WRITE);
+
+	aux = auxArray[transmit_rate][1];
+	ByteSwap(&aux);
+	__write32 (HW_DATA_FIFO, aux, WRITE);
+	
+
+	if (transmit_mode == 3) // Before 4
+	{
+		/* for fcc transmitmacStats 01 pattern */
+		for (i=0; i < 14; i++)
+		{
+			__write32 (HW_DATA_FIFO, 0xAAAAAAAA, WRITE);
+		}
+	}
+	else
+	{
+		for (i=0; i < 14; i++)
+		{
+			__write32 (HW_DATA_FIFO, 0xAAAAAAAA, WRITE); // This should be random
+		}
+	}
+	
+	__write32 (HW_GEN_CONTROL, ~GEN_TXHOLD, AND);
+}
+
+//
+// This function puts the driver into continuous transfer mode.  When doing
+// so it attempts to shutdown normal driver functionality so the driver
+// will not interfere with the continuous transfer.  However I do not think
+// the process of shutting down the driver while enabling continous transfer
+// mode is completely void of interference, but I think it will work well
+// enough for FCC testing.
+//
+void MacContinuousTransmit(int enable, unsigned int transmit_mode, unsigned int transmit_rate)
+{
+	//int level;
+		
+	const unsigned int tx_mode_on[4] = {
+					 	0x30100000 , /* Random */
+						0x30300000 , /* Zeros */
+					  	0x30500000 , /* Ones */
+					 	0x30700000   /* DC Baseband */
+					    };
+					 
+	const unsigned int tx_mode_off[4] = {
+					 	0x30000000 , /* Random */
+						0x30200000 , /* Zeros */
+					  	0x30400000 , /* Ones */
+					 	0x30000000   /* DC Baseband */
+					     }; 
+	
+	/* disable interrupts host */
+	if (enable)
+	{
+		MacUpdateBuffer(transmit_mode, transmit_rate);
+
+		/* disable mac interrupts */
+		__write32(HW_INTR_MASK, 0, WRITE);
+	     		
+		// Disable IBSS mode
+		__write32(HW_MAC_CONTROL, ~(CTRL_IBSS|CTRL_BEACONTX), AND);        
+
+		if(transmit_mode == 3)
+			//enable test mode of operation
+		  	//HW_GEN_CONTROL = 0x93780001;
+		 	// HW_GEN_CONTROL |= GEN_TESTMODE;
+		 	__write32(HW_CONF1, TX_CTL, OR); /* Piper */
+		
+		/* set to continuous transmit; test bit too */
+		if (transmit_mode >= 0 && transmit_mode <= 3) // before until 4
+			__write32(HW_GEN_STATUS, tx_mode_on[transmit_mode], WRITE);
+		else
+			__write32(HW_GEN_STATUS, tx_mode_on[0], WRITE);
+			  
+		/* start transmiting */
+		__write32(HW_MAC_CONTROL, CTRL_TXREQ, OR);
+	}
+	else
+	{
+		if (transmit_mode >= 0 && transmit_mode <= 4)
+			__write32(HW_GEN_STATUS, tx_mode_off[transmit_mode], WRITE);
+		else
+			__write32(HW_GEN_STATUS, tx_mode_off[0], WRITE);
+		
+		if(transmit_mode == 3)
+			/* Disable test mode of operation */
+		 	__write32(HW_CONF1, ~TX_CTL, AND);
+				
+		/* enable common mac interrupts */
+		__write32(HW_INTR_MASK, INTR_RXFIFO|INTR_TXEND|INTR_TIMEOUT|INTR_ABORT, OR);			
+		
+		__write32(HW_MAC_CONTROL, ~CTRL_TXREQ, AND);
+	}
+	/* enable interrupts host */
+}
+
+/* Set the power directly in the RF transceiver chip for RF testing purposes */
+void MacSetDirectTxPower(int value)
+{
+	if (value < 0x40)
+    		WriteRF(11, 0x08040 | value);
+	else
+    		WriteRF(11, 0x08040 | 0x3f);
+}
+
+void MacRadioRXTest(int enable)
+{
+    	/* disable interrupts */
+	if (enable)
+    	{
+        	/* disable the mac driver */
+        	SetPromiscuousMode(TRUE);   
+         	MacSetQuiet(1); 
+     	}
+    	else
+	{
+        	SetPromiscuousMode(FALSE);
+                MacSetQuiet(0);    
+    	}//HW_MAC_CONTROL &= ~CTRL_PROMISC;
+    	/* enable interrupts */
+}
+
+//
+// This function is used to put the mac driver in a quiet mode where
+// no transmitting is done, but the FPGA is still running.  It is my
+// hope that by disabling interrupts the FPGA will not do any automatic
+// acking of received data.
+//
+void MacSetQuiet(int enable_quiet)
+{
+    /* disable interrupts */
+
+    if (enable_quiet)
+    {
+        /* disable mac interrupts */
+        __write32(HW_INTR_MASK, 0, WRITE);
+    }
+    else
+    {
+        /* enable common mac interrupts */
+        __write32(HW_INTR_MASK, INTR_RXEND|INTR_TXEND|INTR_TIMEOUT|INTR_ABORT, OR);
+
+    }
+    /* enable interrupts */
+}
+
+void SetPromiscuousMode(boolean enable)
+{
+	if (enable == TRUE)    // Enable PROMISC mode
+    	{
+		__write32(HW_MAC_CONTROL, CTRL_PROMISC, OR); // It was cancelled before.
+	}
+	else    //disable
+    	{
+		__write32(HW_MAC_CONTROL, ~CTRL_PROMISC, AND);
+	}
+}
+
+void MacRadioPrepareTXBeacon(unsigned int tx_frame_period)
+{
+	/* set frame interval to tx_frame_period */ 
+	__write32(HW_CFP_ATIM, (tx_frame_period << 16), WRITE);
+    
+	/* enable beacon transmission */ 
+	__write32(HW_GEN_CONTROL, GEN_BEACEN, OR);
+}
+
+//
+// Set BSS mode and IDs
+// @param bssCaps BSS capabilities, OR of CAP_xxx
+// @param bssid ID of BSS to join or start
+// @param ssid Service set ID
+// @param ssid_len Service set ID length
+// @param basic Basic rates, OR of WLN_RATE_xxx
+// @param atim IBSS ATIM window size in TU
+//
+void SetBSS (int bssCaps, uint8 *ssid, int ssid_len, uint16 basic, int atim)
+{
+	//unsigned char todelete1[4] = {0x00,0x13,0x1A,0x9F,0xDE,0xE0,0x00,0x00};
+	//MacFrameHeader MacToSend;
+	BeaconFrame BeaconToSend;
+	
+	static unsigned long todelete = 0; 
+	//unsigned long aux;
+	unsigned int aux2;
+	
+	//unsigned char todelete1[4] = {0x00, 0x00, 0xE0, 0xDE, 0x9F, 0x1A, 0x13, 0x00};
+	// Set BSSID in hardware
+	//HWMemcpy (HW_BSSID0, todelete1, 6);
+	//__write32(HW_BSSID0, 0x00010203, WRITE); 
+	//__write32(HW_BSSID1, 0x04050000, WRITE);
+	
+	//aux2 = 0xFFFFFFFF;
+	//ByteSwap(&aux2);
+	__write32(HW_BSSID0, 0x00000000, WRITE);
+	//aux2 = 0xFFFF0000;
+	//ByteSwap(&aux2); 
+	__write32(HW_BSSID1, 0x00000000, WRITE);
+	
+	
+	// Set SSID and basic rates in hardware
+	//HWMemcpy (HW_SSID, 0x0a, 1);
+	__write32(HW_SSID, 0x0a, WRITE);
+	//aux2 = 0x00010203;
+	//ByteSwap(&aux2);
+	__write32(HW_STAID0, 0x00010203, WRITE);
+	//aux2 = 0x04050000;
+	//ByteSwap(&aux2); 
+	__write32(HW_STAID1, 0x04050000, WRITE);
+
+/*	HW_SSID_LEN = ssid_len |
+		((basic & RATE_MASK_OFDM) << 20) |
+		((basic & (RATE_MASK_PSK|RATE_MASK_CCK)) << 16);*/
+	//__write32(HW_SSID_LEN, ssid_len | ((basic & RATE_MASK_OFDM) << 20) | ((basic & (RATE_MASK_PSK|RATE_MASK_CCK)) << 16), WRITE);
+	__write32(HW_SSID_LEN, 0xFF0F000A, OR);
+	__write32(HW_SSID, 0x33333333, WRITE);
+	__write32(HW_SSID+1, 0x33343132, WRITE);
+	__write32(HW_SSID+2, 0x34360000, WRITE);
+	//__write32(HW_SSID+8, 0x00003333, WRITE);
+	
+	//_write32(HW_REMAIN_BO, 100, WRITE);
+	__write32(HW_BEACON_BO, 1000, WRITE);
+		
+	// IBSS mode
+	if (bssCaps)
+	{
+		// If starting IBSS, set beacon and ATIM intervals
+		//HW_CFP_ATIM = atim | (BEACON_INT << 16);
+		__write32(HW_CFP_ATIM, 1000 | (100 << 16), WRITE);
+//		MacRadioPrepareTXBeacon(atim);
+
+		// Write beacon frame to beacon buffer
+		if (1)//bcnframe
+		{
+			__write32(HW_GEN_CONTROL, GEN_BEACEN, OR);
+			__write32 (HW_GEN_CONTROL, GEN_TXHOLD, OR);
+			
+			aux2 = SET_TXFRAMEHEADER(1, 0xee);//0x00
+			ByteSwap(&aux2);
+			//aux2 = 0xee000000;
+			//BeaconToSend.frameHdr = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			//aux2 = SET_PSKCCKHEADER(0, 0x26, 0x6E);
+			aux2 = 0x0026006e; // works
+			aux2 = 0x01A0000A; // works
+			aux2 = 0x00540037; // works
+			aux2 = 0x00D00014; // works
+			
+			aux2 = SET_PSKOFDMHEADER(0, 0x400, 0xC);//13*4
+			
+			//printf("FC.Protocol: 0x%08x\n", aux2);
+			ByteSwap(&aux2);			
+			//aux2 = 0x8c600000;
+			//aux2 = 0x03;
+			//printf("FC.Protocol: 0x%08x\n", aux2);
+			//deserializer(&aux2);
+			//ByteSwap(&aux2);
+			//printf("FC.Protocol: 0x%08x\n", aux2);
+			BeaconToSend.plcpHdr = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			//aux2 = SET_FC_DUR(0, 0, 0, 0, 0, 0, 0, 0, 0, 0x8, 0, 0);
+			//printf("FC.Protocol: 0x%08x\n", aux2);
+			
+			aux2 = 0x00000080;
+			ByteSwap(&aux2);
+			BeaconToSend.fc_duration = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			aux2 = 0xFFFFFFFF;
+			//ByteSwap(&aux2 );
+			BeaconToSend.addr1 = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			aux2 = SET_MAC1_MAC2 (0xFFFF, 0x0001);
+			aux2 = 0xFFFF0001;
+			//ByteSwap(&aux2);
+			BeaconToSend.addr1_2 = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			aux2 = 0x02030405;
+			//ByteSwap(&aux2);
+			BeaconToSend.addr2   = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			aux2 = 0x00010203;
+			//ByteSwap(&aux2);
+			BeaconToSend.addr3 = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			aux2 = SET_MAC2_MAC3 (0x0405, 0x0000);
+			aux2 = 0x04050000;
+			//ByteSwap(&aux2);
+			BeaconToSend.addr3_squ = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			//BeaconToSend.macHdr = MacToSend;
+			BeaconToSend.timestamp[0] = todelete;
+			__write32 (HW_DATA_FIFO, todelete, WRITE);
+			BeaconToSend.timestamp[1] = 0;
+			__write32 (HW_DATA_FIFO, 0, WRITE);
+			aux2 = 0x00010200;
+			//ByteSwap(&aux2);
+			//BeaconToSend.interval_capinfo = aux2;
+			__write32 (HW_DATA_FIFO, aux2, WRITE);
+			
+			__write32 (HW_DATA_FIFO, 0x000A3333, WRITE);
+			//BeaconToSend.nameSSID[0] = 0x0A0B0C0D;
+			//__write32 (HW_DATA_FIFO, 0x04, WRITE);
+			//BeaconToSend.nameSSID[4] = 0x0E;
+			__write32 (HW_DATA_FIFO, 0x33333334, WRITE);
+			__write32 (HW_DATA_FIFO, 0x31323436, WRITE);
+			
+			//__write32 (HW_DATA_FIFO, 0x000A3333, WRITE);
+			//BeaconToSend.nameSSID[0] = 0x0A0B0C0D;
+			//__write32 (HW_DATA_FIFO, 0x04, WRITE);
+			
+			//HWWriteFifo (&(BeaconToSend), (sizeof(BeaconFrame)-4)/4);
+			//MacUpdateFccBuffer(0,11);
+			
+			__write32 (HW_GEN_CONTROL, ~GEN_TXHOLD, AND);
+			__write32(HW_GEN_CONTROL, ~GEN_BEACEN, AND);
+			
+			//MacUpdateFccBuffer(0,11);
+			//todelete++;
+		}
+
+		// Set interrupt mask to enable TBTT and ATIM interrupts
+		__write32(HW_INTR_STATUS, INTR_TBTT|INTR_ATIM, OR);//WRITE
+		
+		//intrMask |= INTR_TBTT|INTR_ATIM;      // enable
+		//HW_INTR_MASK = intrMask;
+		__write32(HW_INTR_MASK, INTR_TBTT|INTR_ATIM, OR);
+		
+		// Enable IBSS mode
+		__write32(HW_MAC_CONTROL, CTRL_IBSS|CTRL_BEACONTX, OR);
+		//__write32(HW_MAC_CONTROL, ~0x2, AND);
+	}
+
+	// ESS mode
+	else
+	{
+		// Set interrupt mask to disable TBTT and ATIM interrupts
+		//intrMask &= ~(INTR_TBTT|INTR_ATIM); // disable
+		//HW_INTR_MASK = intrMask;
+		__write32(HW_INTR_MASK, ~(INTR_TBTT|INTR_ATIM), AND);
+
+		// Disable IBSS mode
+		//HW_MAC_CONTROL &= ~(CTRL_IBSS|CTRL_BEACONTX);
+		__write32(HW_MAC_CONTROL, ~(CTRL_IBSS|CTRL_BEACONTX), AND);
+	}
+}
+
+void MacRadioTXPeriodic (unsigned char active, unsigned int transmit_mode, unsigned int transmit_rate, int atim, int beacon, unsigned char frame_length)
+{
+	unsigned int aux;
+	unsigned int loop;
+	
+	/*1024 bytes packet*/
+	const unsigned int aux1024ByPacket[12][2] = 
+				{
+					/* Received frame header, PLCP frame*/
+					{0x00010000, 0x2000040A}, /*1mpbs*/
+     					{0x00010000, 0x10000014}, /*2mbps*/
+					{0x00010000, 0x06610437}, /*5.5mbps*/
+					{0x00010000, 0x02E8046E}, /*11mbps*/
+					/*** OFMD ***/
+					{0x000100EE, 0x0000800B}, /*6mbps*/
+					{0x000100EE, 0x0000800F}, /*9mbps*/
+					{0x000100EE, 0x0000800A}, /*12mbps*/
+					{0x000100EE, 0x0000800E}, /*18mbps*/
+					{0x000100EE, 0x00008009}, /*24mbps*/
+					{0x000100EE, 0x0000800D}, /*36mbps*/
+					{0x000100EE, 0x00008008}, /*48mbps*/
+					{0x000100EE, 0x0000800C} /*54mbps*/
+				};
+
+	const unsigned int aux128ByPacket[12][2] = 
+				{
+					/* Received frame header, PLCP frame*/
+					{0x00002000, 0x03E8040A}, /*1mpbs*/
+					{0x00002000, 0x01F40414}, /*2mbps*/
+					{0x00002000, 0x00B5D437}, /*5.5mbps*/
+					{0x00002000, 0x005AE46E}, /*11mbps*/
+					/*** OFMD ***/
+					{0x000020EE, 0x0000100B}, /*6mbps*/
+					{0x000020EE, 0x0000100F}, /*9mbps*/
+					{0x000020EE, 0x0000100A}, /*12mbps*/
+					{0x000020EE, 0x0000100E}, /*18mbps*/
+					{0x000020EE, 0x00001009}, /*24mbps*/
+					{0x000020EE, 0x0000100D}, /*36mbps*/
+					{0x000020EE, 0x00001008}, /*48mbps*/
+     					{0x000020EE, 0x0000100C} /*54mbps*/
+				};
+				
+	// Set BSSID in hardware
+	// Does not filter any stations.
+	__write32(HW_BSSID0, 0xFFFFFFFF, WRITE);
+	__write32(HW_BSSID1, 0xFFFF0000, WRITE);
+	
+	// Set SSID and basic rates in hardware
+	// SSID Lenght 10 octects.
+	__write32(HW_SSID, 0x0a, WRITE);
+
+	// MAC Address => 01:02:03:04:05
+	__write32(HW_STAID0, 0x00010203, WRITE);
+	__write32(HW_STAID1, 0x04050000, WRITE);
+
+	// Basic rates are all PSK/CCK and all OFDM
+	__write32(HW_SSID_LEN, 0xFF0F000A, OR);
+	
+	// SSID name, just to fill it with something.
+	__write32(HW_SSID, 0x33333333, WRITE);
+	__write32(HW_SSID+1, 0x33343132, WRITE);
+	__write32(HW_SSID+2, 0x34360000, WRITE);
+		
+	//__write32(HW_BEACON_BO, 1000, WRITE);
+		
+	// IBSS mode
+	if (active == 1)
+	{
+		// If starting IBSS, set beacon and ATIM intervals
+		__write32(HW_CFP_ATIM, (beacon << 16), WRITE);//atim | (beacon << 16)
+
+		// Write beacon frame to beacon buffer
+		//__write32(HW_GEN_CONTROL, GEN_BEACEN, OR);
+		__write32 (HW_GEN_CONTROL, GEN_TXHOLD, OR);
+		
+		
+		/********************************************************/
+		/* It looks like the Beacon buffer is limted to 128 bytes.
+		   If you try to go over that limitation, the device will
+		   directly not transmit. If we transmit more than 128 bytes
+		   using the Beacon buffer, what we transfer after that
+		   limted amount of data is the data buffer itself, bit the
+		   the beacon buffer. So, in order to modifiy this buffer, first
+		   we should access the data buffer, modifiy the required data
+		   and then access the beacon buffer. */
+		
+		aux = aux1024ByPacket[transmit_rate][0];
+		ByteSwap(&aux);
+		__write32 (HW_DATA_FIFO, aux, WRITE);
+			
+		aux = aux1024ByPacket[transmit_rate][1];
+		ByteSwap(&aux);
+		__write32 (HW_DATA_FIFO, aux, WRITE);
+		
+		for (loop=256; loop != 0; loop--)//249
+		{
+			__write32 (HW_DATA_FIFO, 0, WRITE);
+		}
+		
+		/********************************************************/
+		__write32(HW_GEN_CONTROL, GEN_BEACEN, OR);
+		
+		if (frame_length == SIZE1024BYTES)
+		{
+			aux = aux1024ByPacket[transmit_rate][0];
+			ByteSwap(&aux);
+			__write32 (HW_DATA_FIFO, aux, WRITE);
+			
+			aux = aux1024ByPacket[transmit_rate][1];
+			ByteSwap(&aux);
+			__write32 (HW_DATA_FIFO, aux, WRITE);
+		}
+		else
+		{
+			aux = aux128ByPacket[transmit_rate][0];
+			ByteSwap(&aux);
+			__write32 (HW_DATA_FIFO, aux, WRITE);
+			
+			aux = aux128ByPacket[transmit_rate][1];
+			ByteSwap(&aux);
+			__write32 (HW_DATA_FIFO, aux, WRITE);
+		}
+
+		// Beacon frame: 0x80
+		
+		// Data frame.
+		aux = 0x00000008;
+		ByteSwap(&aux);
+		__write32 (HW_DATA_FIFO, aux, WRITE);
+			
+		// MAC1, MAC2, MAC3 from MAC FRAME
+		__write32 (HW_DATA_FIFO, 0xFFFFFFFF, WRITE);
+		__write32 (HW_DATA_FIFO, 0xFFFF0001, WRITE);
+		__write32 (HW_DATA_FIFO, 0x02030405, WRITE);
+		__write32 (HW_DATA_FIFO, 0x00010203, WRITE);
+		__write32 (HW_DATA_FIFO, 0x04050000, WRITE);
+			
+		// Timestamp
+		/*__write32 (HW_DATA_FIFO, 0, WRITE);
+		__write32 (HW_DATA_FIFO, 0, WRITE);*/
+		
+		// Cap_Info
+		/*__write32 (HW_DATA_FIFO, 0x00010200, WRITE);*/
+			
+		// SSID
+		/*__write32 (HW_DATA_FIFO, 0x000A3333, WRITE);
+		__write32 (HW_DATA_FIFO, 0x33333334, WRITE);
+		__write32 (HW_DATA_FIFO, 0x31323436, WRITE);*/
+			
+		// Filling up with something.
+		if (frame_length == SIZE1024BYTES)
+		{
+			for (loop=24; loop != 0; loop--)//249
+			{
+				__write32 (HW_DATA_FIFO, 0, WRITE);
+			}
+		}
+		else
+		{
+			for (loop=24; loop != 0; loop--)//33
+			{
+				__write32 (HW_DATA_FIFO, 0, WRITE);
+			}
+		}
+		
+		__write32 (HW_GEN_CONTROL, ~GEN_TXHOLD, AND);
+		__write32(HW_GEN_CONTROL, ~GEN_BEACEN, AND);
+	
+		/////// TESTING !!!!!!!
+		// Set interrupt mask to enable TBTT and ATIM interrupts
+		/*__write32(HW_INTR_STATUS, INTR_TBTT|INTR_ATIM, OR);//WRITE
+		__write32(HW_INTR_MASK, INTR_TBTT|INTR_ATIM, OR);*/
+		__write32(HW_INTR_MASK, 0, WRITE);
+		
+		// Enable IBSS mode
+		__write32(HW_MAC_CONTROL, CTRL_IBSS|CTRL_BEACONTX, OR);
+	}
+
+	// ESS mode
+	else
+	{
+		// Set interrupt mask to disable TBTT and ATIM interrupts
+		__write32(HW_INTR_MASK, ~(INTR_TBTT|INTR_ATIM), AND);
+
+		// Disable IBSS mode
+		__write32(HW_MAC_CONTROL, ~(CTRL_IBSS|CTRL_BEACONTX), AND);
+	}
+}
+
+
+void PrintMacHeader(MacFrameHeader *aux)
+{
+#if 0
+	//MacFrameHeader *aux = &(aux1->macHdr); 
+	/* FRAME Info */
+	printf("FH MacRXTestmodType: 0x%02x\n", GET_MODTYP(aux->frameHdr));
+	printf("FH ant: 0x%01x\n",GET_ANTENNA( aux->frameHdr));
+	printf("FH rssiLNA: 0x%01x\n", GET_RSSILNA(aux->frameHdr));
+	printf("FH rssiVGA: 0x%01x\n", GET_RSSIVGA(aux->frameHdr));
+	printf("FH freqOff: 0x%04x\n", GET_FREQOFF(aux->frameHdr));
+	
+	if (GET_MODTYP(aux->frameHdr) == 0xEE)
+	{
+		/* OFDM / PLCP Info */
+		printf("PLCP length: 0x%04x\n", GET_OFDMHEADER_LENGTH(aux->plcpHdr));
+		printf("PLCP rate: 0x%02x\n", GET_OFDMHEADER_RATE(aux->plcpHdr));
+		printf("PLCP parity: 0x%01x\n", GET_OFDMHEADER_PARITY(aux->plcpHdr));
+	}
+	else
+	{
+		/* PSK / PLCP Info */
+		printf("PLCP length: 0x%02x\n", GET_PSKHEADER_LENGTH(aux->plcpHdr));
+		printf("PLCP service: 0x%02x\n", GET_PSKHEADER_SERVICE(aux->plcpHdr));
+		printf("PLCP signal: 0x%04x\n", GET_PSKHEADER_SIGNAL(aux->plcpHdr));	
+	}
+		
+	/* MAC Info */
+	printf("FC.Protocol: 0x%08x\n", GET_FC_DUR_PROTOCOL(aux->macHdr.fc_duration));
+	printf("FC.type:     0x%08x\n", GET_FC_DUR_TYPE((aux->macHdr.fc_duration)));
+	printf("FC.subtype:  0x%08x\n", GET_FC_DUR_SUBTYPE(aux->macHdr.fc_duration));
+	printf("FC.order:    0x%08x\n", GET_FC_DUR_ORDER((aux->macHdr.fc_duration)));
+	printf("FC._prot:    0x%08x\n", GET_FC_DUR_PROTECTEDFRAME((aux->macHdr.fc_duration)));
+	printf("FC.moredata: 0x%08x\n", GET_FC_DUR_MOREDATA((aux->macHdr.fc_duration)));
+	printf("FC.pwrMgt:   0x%08x\n", GET_FC_DUR_PWRMGMT((aux->macHdr.fc_duration)));
+	printf("FC.retry:    0x%08x\n", GET_FC_DUR_RETRY((aux->macHdr.fc_duration)));
+	printf("FC.moreFrag: 0x%08x\n", GET_FC_DUR_MOREFRAG((aux->macHdr.fc_duration)));
+	printf("FC.fromDS:   0x%08x\n", GET_FC_DUR_FROMDS((aux->macHdr.fc_duration)));
+	printf("FC.toDS:     0x%08x\n", GET_FC_DUR_TODS((aux->macHdr.fc_duration)));
+	
+	printf("Duration:    0x%08x\n", GET_FC_DUR_DURATION(aux->macHdr.fc_duration));
+
+	deserializer(&(aux->macHdr.addr1));
+	deserializer(&(aux->macHdr.addr1_2));
+	deserializer(&(aux->macHdr.addr2));
+	deserializer(&(aux->macHdr.addr3));
+	deserializer(&(aux->macHdr.addr3_squ));
+
+	printf("MAC1: %08x%04x\n", aux->macHdr.addr1, GET_PART_MAC1(aux->macHdr.addr1_2));
+	printf("MAC2: %04x%08x\n", GET_PART_MAC2(aux->macHdr.addr1_2), aux->macHdr.addr2);
+	printf("MAC3: %08x%04x\n", aux->macHdr.addr3, GET_PART_MAC3(aux->macHdr.addr3_squ));
+	
+	//printf("SQU: %08x\n", aux->macHdr.squ.sq16);
+
+#endif
+}
+void deserializer(unsigned long *value)
+{
+	unsigned long aux = 0;
+	unsigned int i;
+	unsigned char * charAux1 = (unsigned char *) value;
+	unsigned char * charAux2 = (unsigned char *) &aux;
+	
+	for (i=0; i < 4; i++)
+	{
+		charAux2[i] = charAux1[3 - i];		
+	}
+	
+	*value = aux;
+}
+
+void MacRXTest (unsigned long *numRxFrames)
+{
+	unsigned int aux;
+	unsigned int aux2;
+	/* unsigned long aux2; */
+	
+	*numRxFrames = 0;
+	
+	// Diversity OFF
+	//__write32(HW_GEN_CONTROL, ~0x00000002, AND); /* NACHO 1/12/09 */	
+	__write32(HW_GEN_CONTROL, 0x00000002, OR); /* NACHO 1/12/09 */	
+	// Antenna SEC.
+	//__write32(HW_GEN_CONTROL, ~0x00000004, OR); /* NACHO 1/12/09 */
+
+	// Clean buffer.
+	__write32(HW_GEN_CONTROL, GEN_RXFIFORST, OR);
+	__write32(HW_GEN_CONTROL, ~GEN_RXFIFORST, AND);
+	
+	waitUS(10);
+	
+	__write32(HW_INTR_MASK, 0x1, OR);
+	
+	// Clear interrupts
+	__write32(HW_INTR_STATUS, 0, WRITE);
+
+	do
+	{
+		__read32 (HW_INTR_STATUS, &aux);	
+		if ( (aux & 0x01) == 0x01)
+		{	
+			//__read32 (HW_MAC_STATUS, &aux);
+			//if ((aux & 0x04) == 0x04)
+				(*numRxFrames)++;
+			//__write32 (HW_MAC_STATUS, ~0x00000004, AND);
+		}
+		// Clean buffer.
+		__write32(HW_GEN_CONTROL, GEN_RXFIFORST, OR);
+		__write32(HW_GEN_CONTROL, ~GEN_RXFIFORST, AND);
+	
+		// Clear interrupts
+		__write32(HW_INTR_STATUS, 0, OR);
+	} while (!tstc());
+	
+	getc();
+}
+
+inline void rxBeforeLoop(unsigned int *rxFrames)
+{
+	/* Frame counter */
+	*rxFrames = 0;
+	
+	/* Force max. RX sensitivity */
+	//__write32(HW_OUT_CTRL, 0x0000F000, OR);
+	
+	/* Force min. RX sensitivity */
+	//__write32(HW_OUT_CTRL, 0x0000A000, OR);
+	
+	/* Force antenna 1*/
+	//__write32(HW_GEN_CONTROL, 0x00000004, OR); /*NACHO 1/12/09*/
+	
+	//__write32(HW_RSSI_AES, 0x00FFFFFF, AND); /*NACHO 1/12/09*/
+	//__write32(HW_RSSI_AES, 0x96000000, OR); /*NACHO 1/12/09*/
+	
+	__write32(HW_GEN_STATUS, ~0x04000000, AND);
+	//__write32(HW_GEN_CONTROL, ~0x00000002, AND); /*NACHO 13/01/2010 NACHO 1/12/09*/	
+	//__write32(HW_GEN_CONTROL, 0x00000004, OR); /*NACHO 1/12/09*/
+	
+	waitUS(1);
+	
+	/* Reset FIFO */
+	__write32(HW_GEN_CONTROL, GEN_RXFIFORST, OR);
+	waitUS(1);
+	__write32(HW_GEN_CONTROL, ~GEN_RXFIFORST, AND);
+	waitUS(100);
+}
+
+inline void rxLoopExecution(unsigned int *rxFrames)
+{
+	unsigned long length, i;
+	unsigned int aux, intrStatus;
+
+	__read32 (HW_INTR_STATUS, &intrStatus);	
+		
+	if ( (intrStatus & 0x1) == 0x1)
+	{	
+		__read32 (HW_DATA_FIFO, &aux);
+		
+		if ((aux & 0xFF000000) == 0xEE000000)
+		{
+			__read32 (HW_DATA_FIFO, &aux);
+			ByteSwap(&aux);
+				
+			length = GET_OFDMHEADER_LENGTH(aux);
+					
+			for (i=length/4; i>0; i--)
+				__read32 (HW_DATA_FIFO, &aux);
+			
+			(*rxFrames)++;
+		}
+		else if ((aux & 0xFF000000) == 0x00000000)
+		{
+			__read32 (HW_DATA_FIFO, &aux);
+			ByteSwap(&aux);
+			length = (aux & 0xFFFF0000) >> 16;
+			switch (aux & 0x000000FF)
+			{	
+				case 0xA:
+					length /= 8;
+				break;
+				case 0x14:
+					length /= 4;
+				break;
+				case 0x37:
+					length = (11 * length)/16;
+				break;
+				case 0x6E:
+					length = (11 * length)/8;
+				break;
+			}
+			
+			for (i=length/4; i>0; i--)
+				__read32 (HW_DATA_FIFO, &aux);
+			
+			(*rxFrames)++;
+		}
+	}	
+		// Clear interrupts
+		__write32(HW_INTR_STATUS, 0xF, WRITE);
+}
+
+inline void rxAfterLoop(void)
+{
+	/* Force antenna 1*/
+	__write32(HW_GEN_CONTROL, ~0x00000004, AND);
+}
+
+inline void MacReadPacketFromBuffer(unsigned int *rxFrames)
+{
+	unsigned long length, i;
+	unsigned int aux, intrStatus, error_code, read_value, aux2;
+	
+	// Received a frame
+
+	*rxFrames = 0;
+	
+	/* Force max. RX sensitivity */
+	//__write32(HW_OUT_CTRL, 0x0000F000, OR);
+	
+	/* Force min. RX sensitivity */
+	//__write32(HW_OUT_CTRL, 0x0000A000, OR);
+	
+	/* Force antenna 1*/
+	//__write32(HW_GEN_CONTROL, 0x00000004, OR);
+
+	__write32(HW_GEN_STATUS, ~0x04000000, AND);
+	//__write32(HW_GEN_STATUS, 0x02000000, OR);
+	
+	waitUS(1);
+	
+	__write32(HW_GEN_CONTROL, GEN_RXFIFORST, OR);
+	waitUS(1);
+	__write32(HW_GEN_CONTROL, ~GEN_RXFIFORST, AND);
+	waitUS(100);
+
+	/*printf("Memory dump - Ready for RX test.\n");
+	printf("BEFORE.\n");
+	
+	for (aux2 = 0x00; aux2 < 0xd4; aux2+=0x4)
+	{
+		__read32(REG32(aux2), &aux);
+		printf("Address: 0h%08x  --  Value: 0h%08x\n", aux2, aux);
+	}*/
+
+	/* get a line of input from the user */
+	/*error_code = getSLongConsole(&read_value);
+        if (error_code < 0)
+        {
+		printf ("\n Wrong value, try again:\n");
+	        return 0;
+        }*/
+	/*__read32(REG32(0x08), &aux);
+	printf("Address: 0h%08x  --  Value: 0h%08x\n", 0x08, aux);*/
+	/*printf("Input Code: %i -- Transceiver Value: 0h%.5x\n", error_code, read_value);
+        WriteRF (8, read_value);	*/
+
+	do
+	{
+		__read32 (HW_INTR_STATUS, &intrStatus);	
+		
+		if ( (intrStatus & 0x1) == 0x1)
+		{	
+			__read32 (HW_DATA_FIFO, &aux);
+			
+			if ((aux & 0xFF000000) == 0xEE000000)
+			{
+				__read32 (HW_DATA_FIFO, &aux);
+				ByteSwap(&aux);
+						
+				length = GET_OFDMHEADER_LENGTH(aux);
+						
+				for (i=length/4; i>0; i--)
+					__read32 (HW_DATA_FIFO, &aux);
+				
+				(*rxFrames)++;
+			}
+			else if ((aux & 0xFF000000) == 0x00000000)
+			{
+				__read32 (HW_DATA_FIFO, &aux);
+				ByteSwap(&aux);
+				length = (aux & 0xFFFF0000) >> 16;
+				switch (aux & 0x000000FF)
+				{	
+					case 0xA:
+						length /= 8;
+					break;
+					case 0x14:
+						length /= 4;
+					break;
+					case 0x37:
+						length = (11 * length)/16;
+					break;
+					case 0x6E:
+						length = (11 * length)/8;
+					break;
+				}
+				
+				for (i=length/4; i>0; i--)
+					__read32 (HW_DATA_FIFO, &aux);
+				
+				(*rxFrames)++;
+			}
+
+		}
+		
+		// Clear interrupts
+		__write32(HW_INTR_STATUS, 0xF, WRITE);
+		
+	} while (!tstc());
+	
+	/* Force antenna 1*/
+	__write32(HW_GEN_CONTROL, ~0x00000004, AND);
+	
+	// Flush buffer from last character.
+	getc();
+
+	/*printf("AFTER.\n");
+	
+	for (aux2 = 0xc0; aux2 < 0xd4; aux2+=0x4)
+	{
+		__read32(REG32(aux2), &aux);
+		printf("Address: 0h%08x  --  Value: 0h%08x\n", aux2, aux);
+	}*/
+}
+
+void ConstRead(void)
+{
+	static int k=0;
+	/* static int  p=0; */
+	//static unsigned long superbuffer[100];
+	
+	// Get interrupt status
+	uint32 intrStatus, rxFrames;
+	//uint32 aux2, aux3, aux4;
+	//unsigned char i;
+	
+	//MacFrameHeader aux;
+	
+	rxFrames = 0;
+	
+	//intrStatus &= intrMask;
+	// Received a frame
+	while (1)
+	{
+		__read32 (HW_INTR_STATUS, &intrStatus);	
+		if ( (intrStatus & 0x01) == 0x01)
+		{	
+#if 0			
+			k=0;
+			__read32(HW_MAC_STATUS, &aux3);
+			__read32(HW_MAC_CONTROL, &aux4);
+			do {
+				__write32 (HW_INTR_STATUS, 1, OR);
+				__read32 (HW_DATA_FIFO, (superbuffer + k));
+				if (k>0)
+				{
+					ByteSwap(superbuffer + k);
+				}
+				k++;
+				if (k > 99) break;//> sizeof (MacFrameHeader)) break;
+				__read32 (HW_GEN_STATUS, &aux2);
+																
+			}while ((aux2 & 0x10) != 0x10);
+			// Process the frame
+			//HandleRxEnd (&rxFrame);
+#endif			
+			__write32(HW_GEN_CONTROL, GEN_RXFIFORST, OR);
+			__write32(HW_GEN_CONTROL, ~GEN_RXFIFORST, AND);
+			rxFrames++;
+	
+			// Clear interrupts
+			__write32(HW_INTR_STATUS, 0, WRITE);
+			//PrintMacHeader(&(aux));
+			
+		}
+		if (k>=0)
+		{
+#if 0
+			printf("\n **** INI FRAME **** \n");
+			//printf("k: %08x\n", k);
+			p=0;
+			//HWMemcpy(&aux, superbuffer, sizeof(aux));
+			//if (GET_FC_DUR_TYPE(aux.macHdr.fc_duration) == 0x02 )
+			PrintMacHeader((MacFrameHeader *) (superbuffer));
+			printf("MAC C: %08x\n", aux4);
+			printf("MAC S: %08x\n", aux3);
+			
+			/*if (aux3 == 0x8)
+				printf("DF\n");
+			if (aux3 == 0x4)
+				printf("BF\n");
+			if (aux3 == 0x2)
+				printf("GO\n");
+			if (aux3 == 0x1)
+				printf("NGO\n");*/
+			while (p <= k)
+			{
+				printf("%08x\n", (superbuffer[p]));
+				p++;
+			}
+			printf("\n **** END FRAME **** \n");
+#endif
+			printf("FRAMES : %u", rxFrames);
+			k = -1;
+		}
+	}
+}
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/vBPiper.h b/common/digi/cmd_testhw/wireless/vBPiper.h
new file mode 100644
index 0000000..a872574
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/vBPiper.h
@@ -0,0 +1,308 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#define SIMULATING_NETOS_2 1
+#define SIMULATING_NETOS 1
+//
+// Embedded 802.11a/g wireless network interface
+// MAC layer hardware interface for ConnectCorewi9p9215 and Connectwiem9210
+// Copyright 2008 Digi International
+//
+
+#ifndef _PIPER_H
+#define _PIPER_H
+
+#define IBSSOFF 1
+
+typedef enum {FALSE, TRUE} boolean;
+
+typedef unsigned int * __p32bits;
+typedef unsigned short * __p16bits;
+
+void __write32 (volatile unsigned int *addr, unsigned int  data, unsigned char operation);
+void __read32  (volatile unsigned int *addr, unsigned int *data);
+void waitUS (unsigned long usec);
+void piperReset(void);
+
+#define uint32 		unsigned int
+#define uint16 		unsigned short
+#define uint8  		unsigned char
+
+#define WRITE 0
+#define AND 1
+#define OR 2
+
+#define SIZE1024BYTES	0
+#define SIZE128BYTES	1
+
+#define	RATE_MASK_PSK		0x0003
+#define	RATE_MASK_CCK		0x000c
+#define	RATE_MASK_OFDM		0x0ff0
+
+#define	RATE_MASK_BASIC		0x0153	// Ad hoc basic rates
+
+/******************************************************************************/
+/* HARDWARE REGISTER DEFINES **************************************************/
+/******************************************************************************/
+#if CONFIG_CCW9M2443
+	#define MAC_BASE	0x20000000		// Register base address
+#elif CONFIG_CCW9P9215
+	#define MAC_BASE	0x70000000		// Register base address
+#endif
+
+#define MAC_CTRL_BASE   (  (volatile uint32 *) (MAC_BASE + (0x40)) )
+#define	REG32(offset)	(  (volatile uint32 *) (MAC_BASE + (offset)) )
+
+#define MAC_MASK		0xffffc001	// Size mask and enable bit
+
+/* BASEBAND CONTROL REGISTERS *************************************************/
+#define	HW_VERSION		REG32(0x00)	// Version
+#define	HW_GEN_CONTROL		REG32(0x04)	// General control
+#define	HW_GEN_STATUS		REG32(0x08)	// General status
+#define	HW_RSSI_AES		REG32(0x0c)	// RSSI and AES status
+#define	HW_INTR_MASK		REG32(0x10)	// Interrupt mask
+#define	HW_INTR_STATUS		REG32(0x14)	// Interrupt status
+#define	HW_SPI			REG32(0x18)	// RF SPI interface
+#define HW_SPI_CTRL     	REG32(0x1C)	// RF SPI control
+#define HW_SPI_CONTROL  	REG32(0x1C)     // SPI control baseband register
+#define	HW_DATA_FIFO		REG32(0x20)	// Data FIFO
+
+//CC CAT rev2
+#define	HW_TRACK_CONTROL 	REG32(0x28)	// frequency-band specific tracking constant
+//CC CAT rev2
+
+#define HW_CONF1        	REG32(0x28)	// Configuration 1
+#define HW_CONF2        	REG32(0x2C)	// Configuration 2
+#define	HW_AES_FIFO		REG32(0x30)	// AES FIFO
+#define	HW_AES_MODE		REG32(0x38)	// ARS mode
+#define HW_OUT_CTRL     	REG32(0x3C)     //Output control
+
+/* MAC CONTROL REGISTERS ******************************************************/
+#define	HW_STAID0		REG32(0x40)	// Station ID (6 bytes)
+#define	HW_STAID1		REG32(0x44)
+#define	HW_BSSID0		REG32(0x48)	// BSS ID (6 bytes)
+#define	HW_BSSID1		REG32(0x4c)
+#define	HW_SSID_LEN		REG32(0x50)	// Basic rates (high 16 bits), SSID length (low 8 bits)
+#define	HW_BACKOFF		REG32(0x54)	// Backoff period (16 bits)
+#define	HW_LISTEN		REG32(0x58)	// Listen interval (16 bits), CFP (8 bits), DTIM (8 bits)
+#define	HW_CFP_ATIM		REG32(0x5c)	// CFP max duration/ATIM period (16 bits), beacon interval (16 bits)
+#define	HW_MAC_STATUS		REG32(0x60)	// MAC status (8 bits)
+#define	HW_MAC_CONTROL		REG32(0x64)	// MAC control (8 bits)
+#define	HW_REMAIN_BO		REG32(0x68)	// Remaining backoff (16 bits)
+#define	HW_BEACON_BO		REG32(0x6c)	// Beacon backoff (16 bits), beacon mask (8 bits)
+#define	HW_SSID			REG32(0x80)	// Service set ID (32 bytes)
+#define	HW_STA2ID0		REG32(0xb0)	// Second Station ID (6 bytes)
+#define	HW_STA2ID1		REG32(0xb4)
+#define	HW_STA3ID0		REG32(0xb8)	// Third Station ID (6 bytes)
+#define	HW_STA3ID1		REG32(0xbc)
+
+/* FIFO SIZES IN BYTES ********************************************************/
+#define	HW_TX_FIFO_SIZE		1792
+#define	HW_RX_FIFO_SIZE		2048
+
+#if (MAX_FRAME_SIZE > HW_TX_FIFO_SIZE)
+	#error	MAX_FRAME_SIZE too big
+#endif
+
+// Min fragment size to allow interrupt latency between frames
+#define	MIN_FRAG_SIZE		400
+
+// Size of CTS frame in FIFO
+#define	CTS_OVERHEAD		20
+
+// Max overhead per fragment (CCMP is worst case)
+#define	FRAG_OVERHEAD		(8+DATA_SIZE+CCMP_SIZE-FCS_SIZE)
+
+// Max fragment size to fit CTS and 2 fragments in transmit FIFO
+#define	MAX_FRAG_SIZE		(DATA_SIZE + (HW_TX_FIFO_SIZE-CTS_OVERHEAD-2*FRAG_OVERHEAD)/2)
+
+#define DSP_LOAD_ENABLE         0x00000400          //1 << 10
+#define MACASSIST_LOAD_ENABLE   0x00000200          //1 << 9
+#define DSP_MACASSIST_ENABLE    0x00000800          //1 << 11
+
+/* GENERAL CONTROL REGISTER BITS **********************************************/
+#define	GEN_RXEN		0x00000001	// Receive enable
+#define	GEN_ANTDIV		0x00000002	// Antenna diversity
+#define	GEN_ANTSEL		0x00000004	// Antenna select
+#define	GEN_5GEN		0x00000008	// 5 GHz band enable
+#define	GEN_SHPRE		0x00000010	// Transmit short preamble
+#define	GEN_RXFIFORST		0x00000020	// Receive FIFO reset
+#define	GEN_TXFIFORST		0x00000040	// Transmit FIFO reset
+#define	GEN_TXHOLD		0x00000080	// Transmit FIFO hold
+#define	GEN_BEACEN		0x00000100	// Beacon enable
+#define	GEN_TXFIFOEMPTY		0x00004000	// Transmit FIFO empty
+#define	GEN_TXFIFOFULL		0x00008000	// Transmit FIFO full
+
+
+#define	GEN_TESTMODE		0x80000000	// Test mode of operation 
+#define	GEN_PA_ON		0x02000000	// 0 = 5.0Ghz PA; 1 = 2.4Ghz PA (Airoha AL7230)
+
+#define CONT_TX 		0x00100000	//Piper continuous transmit, in General status Register
+#define TX_CTL  		0x00006000	//Piper, tansmit control value, 11 DAC data is positive DC
+
+//CC CAT rev2
+#define TRACK_BG_BAND           0x00430000     // Tracking constant for 802.11 b/g frequency band
+#define TRACK_4920_4980_A_BAND  0x00210000     // Tracking constant for 802.11 a sub-frequency band
+#define TRACK_5150_5350_A_BAND  0x001F0000     // Tracking constant for 802.11 a sub-frequency band
+#define TRACK_5470_5725_A_BAND  0x001D0000     // Tracking constant for 802.11 a sub-frequency band
+#define TRACK_5725_5825_A_BAND  0x001C0000     // Tracking constant for 802.11 a sub-frequency band
+//CC CAT rev2
+
+/* GENERAL STATUS REGISTER BITS ***********************************************/
+#define	STAT_RXFE		0x00000010	// Receive FIFO empty
+#define STAT_DLLLOCK   		0x00000020      // DLL lock
+
+/* AES STATUS REGISTER BITS ***************************************************/
+#define	AES_EMPTY		0x00010000	// AES receive FIFO empty
+#define	AES_FULL		0x00020000	// AES transmit FIFO full
+#define	AES_BUSY		0x00040000	// AES engine busy
+#define	AES_MIC			0x00080000	// AES MIC correct
+
+/* INTERRUPT MASK AND STATUS REGISTER BITS ************************************/
+#define	INTR_RXFIFO		0x00000001	// Receive FIFO not empty
+#define	INTR_TXEND		0x00000002	// Transmit complete
+#define	INTR_TIMEOUT		0x00000004	// CTS/ACK receive timeout
+#define	INTR_ABORT		0x00000008	// CTS transmit abort
+#define	INTR_TBTT		0x00000010	// Beacon transmission time
+#define	INTR_ATIM		0x00000020	// ATIM interval end
+#define	INTR_RXOVERRUN		0x00000040	// Receive FIFO overrun
+
+/* MAC CONTROL REGISTER BITS **************************************************/
+#define	CTRL_TXREQ		0x00000001	// Transmit request
+#define	CTRL_AUTOTXDIS		0x00000002	// Auto-transmit disable
+#define	CTRL_BEACONTX		0x00000004	// Beacon transmit enable
+#define	CTRL_PROMISC		0x00000008	// Promiscuous mode
+#define	CTRL_IBSS		0x00000010	// IBBS mode
+#define	CTRL_MAC_FLTR		0x00000040	// Extra address filter mode
+
+/* POWERSAVE REGISTER INDEX ***************************************************/
+#define	INDX_GEN_CONTROL	0	// General control
+#define	INDX_GEN_STATUS		1	// General status
+#define	INDX_RSSI_AES		2	// RSSI and AES status
+#define	INDX_INTR_MASK	    	3	// Interrupt mask
+#define INDX_SPI_CTRL       	4	// RF SPI control
+#define INDX_CONF1          	5	// Configuration 1
+#define INDX_CONF2          	6	// Configuration 2
+#define	INDX_AES_MODE		7	// ARS mode
+#define INDX_OUT_CTRL       	8       // Output control
+#define INDX_MAC_CONTROL    	9       // MAC control
+#define INDX_TOTAL          	10
+
+/* SOFTWARE TIMING REGISTERS **************************************************/
+
+
+//#ifdef FCC_ENABLED
+	#define	INTR_RXEND	0x00000001	//  Receive FIFO not empty
+	#define HW_SSI_ADDR   	REG32(0x10)
+	#define SSI_ADDR_WR   	REG32(0x14)
+	#define HW_SSI_DATA0   	REG32(0x18)
+	#define HW_SSI_DATA1   	REG32(0x18)
+	#define HW_SSI_DATA2   	REG32(0x18)
+	#define	REG16(offset)	(* (volatile uint16 *) (MAC_BASE + (offset)))  
+	#define REG8(offset)	(* (volatile uint8  *) (MAC_BASE + (offset) + 1)) 
+
+//	int HW_TEST_MODE = 0;
+//	int HW_TX_BUFFER[2000];
+//#endif
+
+//#if BSP_RF_TESTING
+//	#define	REG16(offset)	(* (volatile uint16 *) (MAC_BASE + (offset)))  
+	
+//	static wln_bss bss_save = WLN_BSS_NONE;
+
+	// This buffer is used as t//#if BSP_RF_TESTING
+//	#define	REG16(offset)	(* (volatile uint16 *) (MAC_BASE + (offset)))  
+	
+//	static wln_bss bss_save = WLN_BSS_NONE;
+
+	// This buffer is used as the transmit buffer for testing the
+	// continuous transmit FCC test.
+//	static unsigned char fcc_txbuffer[64];
+/*	unsigned char fcc_txbuffer2[36]={0x00,0x09,0x00,0x00,0x0a,0x04,0x00,0x01, 
+		                         0x08,0x00,0x00,0x00,0x00,0x22,0x33,0x44,
+		                         0x55,0x66,0x10,0x20,0x30,0x40,0x50,0x60,
+		                         0x10,0x20,0x30,0x40,0x50,0x60,0x00,0x21) Set powersave time
+		                         00,
+		                         0x05,0x55,0x55,0x00};
+	
+	static unsigned char radio_txbuffer[1024];*/
+//#endifhe transmit buffer for testing the
+	// continuous transmit FCC test.
+//	static unsigned char fcc_txbuffer[64];
+/*	unsigned char fcc_txbuffer2[36]={0x00,0x09,0x00,0x00,0x0a,0x04,0x00,0x01, 
+		                         0x08,0x00,0x00,0x00,0x00,0x22,0x33,0x44,
+		                         0x55,0x66,0x10,0x20,0x30,0x40,0x50,0x60,
+		                         0x10,0x20,0x30,0x40,0x50,0x60,0x00,0x00,
+		                         0x05,0x55,0x55,0x00};
+	
+	static unsigned char radio_txbuffer[1024];*/
+//#endif
+
+//
+// PIO pins
+//
+#define PIN_LED			PIN_INIT     		// Link status LED
+#define INTR_ID			EXTERNAL0_INTERRUPT	//external interupt 0, active high
+#define STATUS_A0		(((*(unsigned long *)(0xA0902088)) & 0x100) >> 8)
+
+
+
+/******************************************************************************/
+/* FUNCTIONS PROTOTYPES *******************************************************/
+/******************************************************************************/
+
+/* This funtions perform and initialization of the NS9215 CPU to a known state 
+   after the initialization with U-Boot */
+void initializeuPToKnowState (void);
+
+
+/*
+ Write data to an RF tranceiver register
+ @param addr Register address (4 bits)
+ @param data Data to write (20 bits, bit reversed)
+*/
+void WriteRF (uint8 addr, uint32 data);
+
+//
+// Load the baseband controller firmware
+//
+int LoadHW (void);
+
+void InitializeRF(unsigned char band_selection);
+
+//
+// Initialize the wireless hardware
+//
+int InitHW (void);
+
+//
+// Shutdown the wireless hardware
+//
+void ShutdownHW (void);
+
+//
+// Select a channel
+// @param channel Channel number: 1-22
+//
+//void SetChannel (void);
+void SetChannel (unsigned char channel);
+void MacRadioTXPeriodic (unsigned char active, unsigned int transmit_mode, unsigned int transmit_rate, int atim, int beacon, unsigned char frame_length);
+
+void SetPromiscuousMode(boolean enable);
+void MacSetQuiet(int enable_quiet);
+
+void SetBSS (int bssCaps, uint8 *ssid, int ssid_len, uint16 basic, int atim);
+void MacSetDirectTxPower(int value);
+void MacRadioRXTest(int enable);
+
+inline void rxBeforeLoop(unsigned int *rxFrames);
+inline void rxLoopExecution(unsigned int *rxFrames);
+inline void rxAfterLoop(void);
+inline void MacReadPacketFromBuffer(unsigned int *rxFrames);
+void MacContinuousTransmit(int enable, unsigned int transmit_mode, unsigned int transmit_rate);
+
+#endif
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/wifig_dsp_ucode.c b/common/digi/cmd_testhw/wireless/wifig_dsp_ucode.c
new file mode 100644
index 0000000..075f11c
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/wifig_dsp_ucode.c
@@ -0,0 +1,294 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+/*
+   Copyright (c) 2007-2008 Digi International Inc., All Rights Reserved
+
+   This software contains proprietary and confidential information of Digi
+   International Inc.  By accepting transfer of this copy, Recipient agrees
+   to retain this software in confidence, to prevent disclosure to others,
+   and to make no use of this software other than that for which it was
+   delivered.  This is an unpublished copyrighted work of Digi International
+   Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
+   prohibited.
+
+   Restricted Rights Legend
+
+   Use, duplication, or disclosure by the Government is subject to
+   restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
+   Technical Data and Computer Software clause at DFARS 252.227-7031 or
+   subparagraphs (c)(1) and (2) of the Commercial Computer Software -
+   Restricted Rights at 48 CFR 52.227-19, as applicable.
+
+   Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
+
+   WiFi DSP Code for Piper
+*/
+
+#if 1
+/*const*/ unsigned long wifi_dsp_ucode[1024] = {
+  0x32000,  0x3200F,  0x320AB,  0x0403F,
+  0x0C000,  0x38000,  0x38060,  0x10004,
+  0x10008,  0x10009,  0x1000A,  0x1000B,
+  0x10001,  0x10010,  0x08000,  0x08000,
+  0x10001,  0x08000,  0x08000,  0x08000,
+  0x08000,  0x08000,  0x08000,  0x08000,
+  0x32030,  0x39010,  0x39010,  0x30802,
+  0x2B030,  0x10001,  0x10800,  0x38000,
+  0x10004,  0x10040,  0x11002,  0x320D1,
+  0x041AD,  0x0C000,  0x38000,  0x38160,
+  0x38400,  0x061AD,  0x38100,  0x39171,
+  0x39571,  0x32072,  0x11002,  0x320E1,
+  0x38100,  0x39171,  0x39571,  0x36002,
+  0x29039,  0x38000,  0x11002,  0x38000,
+  0x38060,  0x10001,  0x083D5,  0x10050,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x10104,  0x10013,  0x321D1,  0x0422D,
+  0x0E000,  0x38000,  0x38260,  0x38400,
+  0x0622D,  0x0C000,  0x38200,  0x39271,
+  0x39671,  0x32002,  0x10003,  0x321E1,
+  0x38200,  0x39271,  0x39671,  0x10013,
+  0x321E1,  0x38200,  0x39271,  0x39671,
+  0x36002,  0x29034,  0x38000,  0x10003,
+  0x10001,  0x38060,  0x083B1,  0x10050,
+  0x10104,  0x10040,  0x10213,  0x320D1,
+  0x0422D,  0x0E000,  0x38000,  0x38260,
+  0x38400,  0x0622D,  0x0C000,  0x38200,
+  0x39271,  0x39671,  0x10003,  0x321E1,
+  0x38200,  0x39271,  0x39671,  0x10013,
+  0x321E1,  0x38200,  0x39271,  0x39671,
+  0x10003,  0x10001,  0x38060,  0x10004,
+  0x10000,  0x08392,  0x10010,  0x08380,
+  0x30802,  0x29003,  0x37012,  0x082BF,
+  0x38000,  0x29002,  0x37012,  0x08078,
+  0x29002,  0x37012,  0x08105,  0x29002,
+  0x37012,  0x081C2,  0x29002,  0x37172,
+  0x0822F,  0x04236,  0x10801,  0x29002,
+  0x370F2,  0x0838A,  0x29002,  0x370F2,
+  0x083A7,  0x29002,  0x370F2,  0x083C4,
+  0x38000,  0x08002,  0x38000,  0x38000,
+  0x30822,  0x10104,  0x10040,  0x10213,
+  0x320D1,  0x0422D,  0x0E000,  0x38000,
+  0x38260,  0x38400,  0x0622D,  0x0C000,
+  0x38200,  0x39271,  0x39671,  0x10003,
+  0x321E1,  0x38200,  0x39271,  0x39671,
+  0x10013,  0x321E1,  0x38200,  0x39271,
+  0x39671,  0x10003,  0x38000,  0x38060,
+  0x36002,  0x2A005,  0x0422D,  0x38400,
+  0x0402D,  0x38060,  0x38400,  0x10004,
+  0x10000,  0x10001,  0x08349,  0x10010,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x3601F,  0x30033,  0x23103,  0x38000,
+  0x08030,  0x38000,  0x08031,  0x38000,
+  0x327F0,  0x300F1,  0x37091,  0x21034,
+  0x30803,  0x300F2,  0x23009,  0x32081,
+  0x10002,  0x04180,  0x0C100,  0x38000,
+  0x38040,  0x04400,  0x320A1,  0x38060,
+  0x04900,  0x0E630,  0x38000,  0x38000,
+  0x38060,  0x38000,  0x2103E,  0x38060,
+  0x04000,  0x0C000,  0x300F1,  0x22004,
+  0x37041,  0x23003,  0x04401,  0x38000,
+  0x38020,  0x3601F,  0x30033,  0x2310C,
+  0x38000,  0x082EA,  0x10010,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x38000,  0x10800,  0x38000,
+  0x300F2,  0x32081,  0x35021,  0x20017,
+  0x300F2,  0x37052,  0x28036,  0x0440A,
+  0x0C000,  0x38000,  0x38060,  0x30011,
+  0x20004,  0x0440A,  0x0E000,  0x2103F,
+  0x38060,  0x05410,  0x0E000,  0x38000,
+  0x38060,  0x08005,  0x38000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x04000,
+  0x10008,  0x05C02,  0x0C000,  0x38000,
+  0x38020,  0x04C12,  0x0E000,  0x10002,
+  0x38020,  0x0C209,  0x04914,  0x38000,
+  0x0C409,  0x38040,  0x38000,  0x38000,
+  0x38020,  0x32011,  0x36001,  0x0E000,
+  0x05E02,  0x38000,  0x38120,  0x0E201,
+  0x04914,  0x38000,  0x0E401,  0x38040,
+  0x38000,  0x38020,  0x21034,  0x38000,
+  0x10202,  0x04924,  0x38000,  0x38400,
+  0x10202,  0x041A4,  0x0C100,  0x38060,
+  0x04424,  0x38060,  0x04924,  0x0E630,
+  0x320A1,  0x38000,  0x38060,  0x38000,
+  0x2103E,  0x38060,  0x04403,  0x0C000,
+  0x300F0,  0x38020,  0x0E000,  0x37030,
+  0x39030,  0x39030,  0x0401B,  0x10401,
+  0x38040,  0x10001,  0x05C1C,  0x38000,
+  0x38040,  0x08282,  0x10010,  0x00000,
+  0x10023,  0x10104,  0x0422D,  0x0C080,
+  0x32180,  0x38260,  0x0E080,  0x38200,
+  0x39270,  0x39270,  0x05C2E,  0x0C000,
+  0x38060,  0x100D3,  0x0422D,  0x0C080,
+  0x32180,  0x38260,  0x0E080,  0x38200,
+  0x39270,  0x39270,  0x05C2E,  0x0E000,
+  0x38060,  0x10004,  0x10003,  0x10402,
+  0x0422D,  0x0C000,  0x323F0,  0x38200,
+  0x39270,  0x39770,  0x04401,  0x0C000,
+  0x1000B,  0x38020,  0x06409,  0x38020,
+  0x38020,  0x38020,  0x1000A,  0x08254,
+  0x10010,  0x38000,  0x38000,  0x38000,
+  0x10462,  0x10014,  0x041AD,  0x0C000,
+  0x32180,  0x38160,  0x0E000,  0x38100,
+  0x39170,  0x39170,  0x05C2E,  0x0C000,
+  0x38060,  0x10512,  0x041AD,  0x0C000,
+  0x32180,  0x38160,  0x0E000,  0x38100,
+  0x39170,  0x39170,  0x05C2E,  0x0E000,
+  0x38060,  0x10004,  0x05036,  0x0E008,
+  0x10212,  0x38060,  0x38400,  0x04427,
+  0x0C000,  0x38060,  0x0403F,  0x38000,
+  0x38020,  0x0493F,  0x0E630,  0x32051,
+  0x38000,  0x38060,  0x38000,  0x2103E,
+  0x38060,  0x300F1,  0x37061,  0x0443E,
+  0x0C000,  0x38020,  0x0643F,  0x0C000,
+  0x38020,  0x38020,  0x38020,  0x0563F,
+  0x0E000,  0x2000A,  0x38000,  0x21004,
+  0x38020,  0x04C37,  0x08014,  0x38020,
+  0x2000C,  0x38000,  0x21006,  0x38000,
+  0x04637,  0x38020,  0x05C37,  0x0800B,
+  0x38020,  0x38020,  0x21005,  0x04437,
+  0x38020,  0x05637,  0x08004,  0x38020,
+  0x05C37,  0x38020,  0x38000,  0x11102,
+  0x041B6,  0x0C000,  0x38000,  0x38020,
+  0x04E37,  0x0E000,  0x38020,  0x05C3F,
+  0x0C000,  0x38020,  0x04438,  0x0E000,
+  0x38020,  0x04000,  0x38000,  0x10008,
+  0x04401,  0x0C000,  0x38020,  0x06439,
+  0x0E000,  0x38020,  0x38020,  0x38020,
+  0x38020,  0x38020,  0x38020,  0x04439,
+  0x38000,  0x38020,  0x04409,  0x0C000,
+  0x1000B,  0x06409,  0x38020,  0x38020,
+  0x38020,  0x1000A,  0x10212,  0x04136,
+  0x0C800,  0x38000,  0x38060,  0x11112,
+  0x041B6,  0x0E000,  0x38000,  0x38060,
+  0x25004,  0x38000,  0x10800,  0x38000,
+  0x38000,  0x10400,  0x081CD,  0x38000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x10422,  0x10023,  0x10114,  0x04BAD,
+  0x0C080,  0x32190,  0x38300,  0x39370,
+  0x39F70,  0x104D2,  0x100D3,  0x32190,
+  0x38300,  0x39370,  0x39F70,  0x38000,
+  0x10433,  0x0422D,  0x0C000,  0x32030,
+  0x39270,  0x39A10,  0x10063,  0x10334,
+  0x32030,  0x39270,  0x39A10,  0x10512,
+  0x041AD,  0x32020,  0x39170,  0x39510,
+  0x10782,  0x10114,  0x32020,  0x39170,
+  0x39510,  0x104D3,  0x0422D,  0x0C070,
+  0x10334,  0x38260,  0x0E070,  0x32060,
+  0x39210,  0x39270,  0x107B2,  0x104D3,
+  0x10020,  0x05BAD,  0x0E060,  0x32190,
+  0x38300,  0x39370,  0x39B70,  0x13FC3,
+  0x0422D,  0x0C070,  0x10114,  0x38260,
+  0x0E070,  0x32060,  0x39210,  0x39270,
+  0x104E2,  0x13FC3,  0x05BAD,  0x0E060,
+  0x32190,  0x38300,  0x39370,  0x39B70,
+  0x10004,  0x08326,  0x10000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x10114,  0x10173,  0x10902,  0x0616D,
+  0x0C800,  0x321B0,  0x38260,  0x38260,
+  0x38260,  0x39270,  0x39770,  0x0416D,
+  0x321B0,  0x10173,  0x10912,  0x38260,
+  0x38260,  0x38260,  0x39270,  0x39770,
+  0x10003,  0x10C42,  0x0616D,  0x0C800,
+  0x321B0,  0x38260,  0x38260,  0x38260,
+  0x39270,  0x39770,  0x0416D,  0x321B0,
+  0x10003,  0x10C52,  0x38260,  0x38260,
+  0x38260,  0x39270,  0x39770,  0x32028,
+  0x0C070,  0x10973,  0x0423F,  0x38060,
+  0x10B33,  0x0E070,  0x108E3,  0x38060,
+  0x38060,  0x0E060,  0x10AA3,  0x38000,
+  0x38060,  0x0C000,  0x0503F,  0x10222,
+  0x38400,  0x080C6,  0x38000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x108D3,  0x10104,  0x10140,  0x040F6,
+  0x0C202,  0x32181,  0x38200,  0x38080,
+  0x382C0,  0x380A0,  0x216FF,  0x380A0,
+  0x10823,  0x0C202,  0x32181,  0x38200,
+  0x38080,  0x382C0,  0x380A0,  0x216FF,
+  0x380A0,  0x080FA,  0x10010,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x10902,  0x108D3,  0x10114,  0x10140,
+  0x047F6,  0x0D202,  0x32181,  0x100E1,
+  0x38280,  0x38040,  0x381A0,  0x216FE,
+  0x38440,  0x10C42,  0x10823,  0x047F6,
+  0x0D202,  0x32171,  0x38280,  0x38040,
+  0x381A0,  0x216FE,  0x38440,  0x381A0,
+  0x386E0,  0x321A1,  0x2103F,  0x10001,
+  0x38400,  0x080D2,  0x10010,  0x00000,
+  0x38000,  0x38000,  0x38000,  0x0423F,
+  0x10973,  0x0C000,  0x38060,  0x10B33,
+  0x0E000,  0x108E3,  0x38060,  0x38060,
+  0x0E030,  0x10AA3,  0x38000,  0x38060,
+  0x18083,  0x0C0C0,  0x0443F,  0x36018,
+  0x38060,  0x21002,  0x0C000,  0x32018,
+  0x0503F,  0x10222,  0x38400,  0x041A4,
+  0x0C100,  0x38060,  0x04424,  0x38060,
+  0x048A4,  0x0E630,  0x32061,  0x38000,
+  0x38060,  0x38000,  0x2103E,  0x38060,
+  0x10080,  0x04401,  0x0C000,  0x38020,
+  0x06639,  0x0E000,  0x38020,  0x04409,
+  0x0C000,  0x1000B,  0x06409,  0x38020,
+  0x38020,  0x38020,  0x1000A,  0x30811,
+  0x22007,  0x37021,  0x20003,  0x38000,
+  0x08383,  0x38000,  0x083A1,  0x38000,
+  0x10902,  0x108D3,  0x10104,  0x10140,
+  0x047F6,  0x0D202,  0x32181,  0x100E1,
+  0x38080,  0x38240,  0x381A0,  0x38460,
+  0x214FD,  0x38740,  0x10C42,  0x10823,
+  0x047F6,  0x0D202,  0x32171,  0x38080,
+  0x38240,  0x381A0,  0x38460,  0x214FD,
+  0x38740,  0x381A0,  0x38460,  0x384E0,
+  0x38000,  0x38000,  0x38000,  0x38000,
+  0x38000,  0x38000,  0x38000,  0x38000,
+  0x38000,  0x38400,  0x10001,  0x08068,
+  0x10010,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x041A4,  0x0C100,  0x38000,  0x38060,
+  0x04424,  0x32061,  0x38060,  0x04924,
+  0x0E630,  0x38000,  0x38000,  0x38060,
+  0x38000,  0x2103E,  0x38060,  0x10080,
+  0x108D3,  0x10104,  0x10040,  0x040F6,
+  0x0C202,  0x32181,  0x38200,  0x38200,
+  0x38200,  0x21240,  0x21640,  0x10823,
+  0x32181,  0x38200,  0x38200,  0x38200,
+  0x21240,  0x21640,  0x04401,  0x0C000,
+  0x38020,  0x06639,  0x0E000,  0x38020,
+  0x04409,  0x0C000,  0x1000B,  0x06409,
+  0x38020,  0x38020,  0x38020,  0x1000A,
+  0x0801F,  0x10010,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000
+};
+#endif
+ 
+/*const*/ int dsp_data_len = (sizeof wifi_dsp_ucode)/4; 
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/wifig_macassist_ucode.c b/common/digi/cmd_testhw/wireless/wifig_macassist_ucode.c
new file mode 100644
index 0000000..d85c759
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/wifig_macassist_ucode.c
@@ -0,0 +1,294 @@
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+/*
+   Copyright (c) 2007-2008 Digi International Inc., All Rights Reserved
+
+   This software contains proprietary and confidential information of Digi
+   International Inc.  By accepting transfer of this copy, Recipient agrees
+   to retain this software in confidence, to prevent disclosure to others,
+   and to make no use of this software other than that for which it was
+   delivered.  This is an unpublished copyrighted work of Digi International
+   Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
+   prohibited.
+
+   Restricted Rights Legend
+
+   Use, duplication, or disclosure by the Government is subject to
+   restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
+   Technical Data and Computer Software clause at DFARS 252.227-7031 or
+   subparagraphs (c)(1) and (2) of the Commercial Computer Software -
+   Restricted Rights at 48 CFR 52.227-19, as applicable.
+
+   Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
+
+   WiFi MAC assist Code for Piper
+*/
+
+
+
+const unsigned long wifi_macassist_ucode[] = {
+  0x00F00,  0x2CF22,  0x3033B,  0x00E20,  0x2CED0,  0x2CFD2,  0x2CFD8,  0x2CFD9,
+  0x2CF31,  0x2CFDB,  0x00E20,  0x2CEDA,  0x00E64,  0x2CE1D,  0x00EFF,  0x2CEEA,
+  0x2CEEB,  0x00E01,  0x2CE20,  0x00E0F,  0x2CE21,  0x04522,  0x00603,  0x2C6CE,
+  0x00001,  0x2C040,  0x00000,  0x2C041,  0x2C042,  0x2C043,  0x0016E,  0x2C144,
+  0x00000,  0x0010A,  0x00200,  0x0A5FF,  0x35027,  0x0010B,  0x00280,  0x2C245,
+  0x2C146,  0x2C047,  0x00180,  0x2C148,  0x2C049,  0x2C0CE,  0x00000,  0x00100,
+  0x00223,  0x040C0,  0x302E2,  0x3031A,  0x00030,  0x0011C,  0x00801,  0x042C0,
+  0x0A204,  0x35037,  0x042C0,  0x0A5FF,  0x35040,  0x00031,  0x00117,  0x00806,
+  0x30338,  0x1C001,  0x35C40,  0x1C101,  0x35C43,  0x00000,  0x042C0,  0x043C0,
+  0x044C0,  0x045C0,  0x046C0,  0x047C0,  0x00000,  0x1C801,  0x35C4D,  0x048C1,
+  0x049C1,  0x04AC1,  0x04BC1,  0x04CC1,  0x04DC1,  0x0D320,  0x0D430,  0x0D540,
+  0x0D650,  0x0D760,  0x19230,  0x19240,  0x19250,  0x19260,  0x19270,  0x0A880,
+  0x35062,  0x18208,  0x0A980,  0x35065,  0x18208,  0x0AA80,  0x35068,  0x18208,
+  0x0AB80,  0x3506B,  0x18208,  0x0AC80,  0x3506E,  0x18208,  0x0AD80,  0x35071,
+  0x18208,  0x20206,  0x04122,  0x0A1FF,  0x3547B,  0x2C222,  0x0E260,  0x35015,
+  0x0E260,  0x00151,  0x3407C,  0x00103,  0x19120,  0x2C122,  0x00E00,  0x2CECE,
+  0x3C001,  0x04EC3,  0x0AE20,  0x04FC2,  0x0AF80,  0x0DEF0,  0x04F30,  0x2CE30,
+  0x0FFE0,  0x35095,  0x0EE20,  0x35495,  0x3C000,  0x04EC1,  0x0AE80,  0x3548D,
+  0x04E17,  0x2CED4,  0x04E16,  0x2CED6,  0x3C001,  0x04E27,  0x0AE10,  0x04F33,
+  0x2CE33,  0x0EF10,  0x0BFE0,  0x350AC,  0x00E00,  0x00FE0,  0x2DEF0,  0x18F01,
+  0x0EFE8,  0x350A4,  0x0EFE8,  0x3409E,  0x04F1D,  0x00E00,  0x1DEF0,  0x2CEEA,
+  0x04F1C,  0x00E00,  0x1FEF0,  0x2CEEB,  0x04E27,  0x0AE80,  0x350C8,  0x3C000,
+  0x00E01,  0x2CECE,  0x04EC1,  0x0AE80,  0x354B2,  0x04EE0,  0x2CE27,  0x04EE1,
+  0x2CE26,  0x04EE2,  0x2CE25,  0x04EE3,  0x2CE24,  0x04EE4,  0x2CE23,  0x04EE5,
+  0x2CE22,  0x04EE6,  0x04FE7,  0x2CE21,  0x2CF20,  0x00E00,  0x2CECE,  0x3C001,
+  0x04E35,  0x04F36,  0x0DEF0,  0x3507E,  0x04E3A,  0x04FEB,  0x15EF0,  0x3547E,
+  0x04FEA,  0x04E37,  0x15EF0,  0x3547E,  0x3C000,  0x04EC1,  0x0AE80,  0x354D5,
+  0x04E36,  0x12EFF,  0x354E7,  0x04F35,  0x14F40,  0x35CE7,  0x00E00,  0x2CED8,
+  0x20F06,  0x20F06,  0x2CFD9,  0x3C001,  0x2CE36,  0x2CE35,  0x3407E,  0x04F35,
+  0x1CF01,  0x1EE00,  0x2CF35,  0x2CE36,  0x00E0F,  0x2CED8,  0x2CED9,  0x3C001,
+  0x04E37,  0x04F3A,  0x18E01,  0x1AF00,  0x2CE37,  0x2CF3A,  0x3407E,  0x2CF32,
+  0x04FC0,  0x20F0E,  0x3190B,  0x20F0E,  0x31BFC,  0x20F0E,  0x3195B,  0x20F0E,
+  0x31A72,  0x20F0E,  0x31ACA,  0x20F0E,  0x319DC,  0x20F0E,  0x319E3,  0x20F0E,
+  0x31A63,  0x04F32,  0x38001,  0x04031,  0x0C001,  0x2C031,  0x040C2,  0x0A008,
+  0x35120,  0x04031,  0x0A004,  0x35517,  0x04031,  0x0C080,  0x2C031,  0x302E2,
+  0x040C3,  0x0A010,  0x3511C,  0x00016,  0x18011,  0x00100,  0x00200,  0x3031A,
+  0x302FF,  0x0E3FF,  0x35127,  0x04031,  0x0A0BF,  0x2C031,  0x3412A,  0x04031,
+  0x0C040,  0x2C031,  0x04244,  0x040C3,  0x0A010,  0x35547,  0x302E8,  0x00400,
+  0x04510,  0x0A5FF,  0x35534,  0x0C515,  0x13350,  0x3513B,  0x01430,  0x1232F,
+  0x35544,  0x2030E,  0x34134,  0x1232F,  0x3553F,  0x2030E,  0x34134,  0x124FF,
+  0x35544,  0x2030E,  0x35D34,  0x00401,  0x302F4,  0x2C33B,  0x2A000,  0x04511,
+  0x1426E,  0x3514F,  0x14237,  0x35152,  0x14214,  0x35155,  0x34158,  0x0026E,
+  0x12508,  0x35559,  0x00237,  0x12504,  0x35559,  0x00214,  0x12502,  0x35559,
+  0x0020A,  0x2C23B,  0x2A000,  0x04127,  0x00001,  0x2C0CE,  0x040C2,  0x0A040,
+  0x35163,  0x00005,  0x2C0CE,  0x0A110,  0x35192,  0x04048,  0x0E080,  0x3516C,
+  0x04048,  0x0E050,  0x3516C,  0x34192,  0x00012,  0x04140,  0x0E1EE,  0x35175,
+  0x041C1,  0x0A120,  0x35574,  0x18020,  0x18007,  0x302FF,  0x00100,  0x19030,
+  0x1A100,  0x30338,  0x042E0,  0x043E1,  0x044E2,  0x045E3,  0x046E4,  0x047E5,
+  0x048E6,  0x049E7,  0x19200,  0x1B310,  0x1A400,  0x1A500,  0x1A600,  0x1A700,
+  0x1A800,  0x1A900,  0x2C260,  0x2C361,  0x2C462,  0x2C563,  0x2C664,  0x2C765,
+  0x2C866,  0x2C967,  0x0002C,  0x00100,  0x042C2,  0x044C1,  0x0A480,  0x35595,
+  0x2C0D0,  0x2C1D2,  0x043C2,  0x0A3E0,  0x2C3C2,  0x04140,  0x04348,  0x00000,
+  0x2C0CE,  0x04031,  0x0A0FB,  0x2C031,  0x0A204,  0x355B6,  0x0A30F,  0x0E304,
+  0x351B6,  0x04012,  0x0A001,  0x351B6,  0x0E1EE,  0x355AF,  0x0C004,  0x0C00A,
+  0x2C012,  0x00064,  0x1C001,  0x355B2,  0x00040,  0x2C0C4,  0x040C2,  0x0A040,
+  0x2B400,  0x0403E,  0x0A0FF,  0x2B400,  0x00001,  0x2C0CE,  0x04040,  0x0A0FF,
+  0x351C5,  0x0E001,  0x351C5,  0x0E0EF,  0x355D4,  0x04042,  0x0A0FF,  0x351CB,
+  0x0E001,  0x355D4,  0x341CE,  0x04041,  0x0A0FF,  0x351D4,  0x04043,  0x0A0FF,
+  0x355D4,  0x00000,  0x2C0CE,  0x2A000,  0x00080,  0x2C0C4,  0x0403F,  0x18001,
+  0x2C03F,  0x00000,  0x2C0CE,  0x2A000,  0x00008,  0x2C0C4,  0x00100,  0x2C13E,
+  0x00012,  0x00200,  0x3431A,  0x00101,  0x2C1CE,  0x0402B,  0x12001,  0x35203,
+  0x04128,  0x121FF,  0x351EE,  0x1C101,  0x2C128,  0x35603,  0x04129,  0x0422D,
+  0x0432C,  0x0442F,  0x0452E,  0x12002,  0x351F7,  0x2C128,  0x341F9,  0x0A0FE,
+  0x2C02B,  0x00000,  0x2C0CE,  0x0401D,  0x1D200,  0x0401C,  0x1F300,  0x2C237,
+  0x2C33A,  0x2C435,  0x2C536,  0x00000,  0x2C0CE,  0x04027,  0x0A010,  0x35236,
+  0x3033B,  0x040D5,  0x2C02B,  0x040D7,  0x2C02A,  0x00100,  0x0401F,  0x1D100,
+  0x2C1E8,  0x00100,  0x0401E,  0x1F100,  0x2C1E9,  0x040C2,  0x0A004,  0x3561D,
+  0x3033B,  0x00004,  0x2C0D0,  0x00000,  0x2C0D2,  0x04027,  0x0A004,  0x3522C,
+  0x30338,  0x30338,  0x040C2,  0x0C080,  0x2C0C2,  0x040C2,  0x0A040,  0x3522C,
+  0x0402F,  0x2C0D4,  0x0402E,  0x2C0D6,  0x00110,  0x040C1,  0x0A010,  0x35234,
+  0x04031,  0x0D010,  0x2C031,  0x34246,  0x2C1C4,  0x34246,  0x00010,  0x2C0C4,
+  0x04034,  0x0C000,  0x35246,  0x040ED,  0x0C000,  0x35646,  0x3033B,  0x0421F,
+  0x0431E,  0x2C2D8,  0x2C3D9,  0x04119,  0x1D010,  0x2C0ED,  0x0421D,  0x0431C,
+  0x00000,  0x00100,  0x1D020,  0x1F130,  0x3033B,  0x2C0EA,  0x2C1EB,  0x040EC,
+  0x0C000,  0x35655,  0x04118,  0x1D010,  0x2C0EC,  0x3033B,  0x040EE,  0x0C000,
+  0x2B400,  0x041EF,  0x0C100,  0x2B400,  0x0421B,  0x0431A,  0x1D020,  0x1F130,
+  0x2C0EE,  0x2C1EF,  0x2A000,  0x3033B,  0x040D5,  0x2C02B,  0x040D7,  0x2C02A,
+  0x040C1,  0x0A010,  0x3566E,  0x00020,  0x2C0C4,  0x2A000,  0x04031,  0x0C020,
+  0x2C031,  0x2A000,  0x04012,  0x0A0F7,  0x2C012,  0x00500,  0x00601,  0x00100,
+  0x00700,  0x04031,  0x0A0F7,  0x2C031,  0x2C53E,  0x040C3,  0x0A0C0,  0x35287,
+  0x00603,  0x0A080,  0x35684,  0x00605,  0x2C6CE,  0x04440,  0x342A4,  0x00702,
+  0x2C6CE,  0x04440,  0x0424C,  0x0A201,  0x356A4,  0x04248,  0x0E2B4,  0x35293,
+  0x04249,  0x0A204,  0x35298,  0x2C5CE,  0x04231,  0x0C208,  0x2C231,  0x2C6CE,
+  0x00203,  0x04048,  0x2C5CE,  0x0E0C4,  0x352B9,  0x00030,  0x0A4EE,  0x356A2,
+  0x00080,  0x1805E,  0x00209,  0x342B9,  0x2C5CE,  0x00000,  0x00100,  0x04231,
+  0x0A240,  0x356AD,  0x042C1,  0x0A201,  0x356B2,  0x0A4EE,  0x356B0,  0x000FE,
+  0x1803C,  0x1A100,  0x00200,  0x0A4EE,  0x356B7,  0x18016,  0x1A100,  0x18012,
+  0x1A100,  0x3031A,  0x12702,  0x352C2,  0x0A202,  0x356C2,  0x04131,  0x12108,
+  0x356C2,  0x0C780,  0x04131,  0x0A130,  0x0D710,  0x2C7C4,  0x04731,  0x0A7CF,
+  0x2C731,  0x2A000,  0x04531,  0x12504,  0x352D4,  0x3033B,  0x0A5FB,  0x2C531,
+  0x00500,  0x2C5D8,  0x2C5D9,  0x342DE,  0x04031,  0x0A080,  0x2B400,  0x04131,
+  0x0A1F7,  0x2C131,  0x00184,  0x2C1C4,  0x00101,  0x2C1CE,  0x04440,  0x302E2,
+  0x00500,  0x342A4,  0x040C1,  0x0A080,  0x356E2,  0x00020,  0x2C0DB,  0x2A000,
+  0x00310,  0x12202,  0x352EC,  0x00301,  0x12201,  0x356F0,  0x20306,  0x20306,
+  0x12204,  0x352F3,  0x20306,  0x2A000,  0x00308,  0x12455,  0x356F8,  0x0030C,
+  0x12433,  0x352FB,  0x0C301,  0x1240F,  0x352FE,  0x0C302,  0x2A000,  0x04240,
+  0x0E2EE,  0x35708,  0x04244,  0x003FF,  0x0A208,  0x2B000,  0x00300,  0x2A000,
+  0x003FF,  0x04244,  0x0E26E,  0x3570D,  0x00311,  0x04244,  0x0E237,  0x35711,
+  0x00323,  0x04244,  0x0E214,  0x35715,  0x00360,  0x04244,  0x0E20A,  0x2B400,
+  0x003C0,  0x2A000,  0x0C000,  0x35322,  0x04325,  0x01430,  0x20306,  0x19430,
+  0x19040,  0x1A100,  0x1C01A,  0x1E100,  0x04AC1,  0x0AA80,  0x35724,  0x043DB,
+  0x19030,  0x1A100,  0x12180,  0x3532F,  0x00001,  0x00100,  0x34331,  0x18001,
+  0x1A100,  0x2C0D0,  0x2C1D2,  0x043C2,  0x0A3E0,  0x0D230,  0x2C2C2,  0x2A000,
+  0x04AC1,  0x0AA80,  0x35338,  0x04AC1,  0x0AA80,  0x3573B,  0x2A000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00001,  0x2C0CF,  0x2A000,  0x340F7,
+  0x040C3,  0x0A002,  0x35008,  0x300EA,  0x04031,  0x0C002,  0x2C031,  0x343FC,
+  0x04031,  0x12002,  0x3540E,  0x12001,  0x353FC,  0x300EA,  0x04031,  0x0A0F8,
+  0x2C031,  0x30058,  0x04031,  0x0A0F7,  0x2C031,  0x04123,  0x01010,  0x0A00C,
+  0x0E004,  0x35020,  0x04031,  0x0A080,  0x35042,  0x00084,  0x2C0C4,  0x34042,
+  0x04023,  0x0C010,  0x2C023,  0x04027,  0x0A008,  0x35429,  0x01010,  0x0A003,
+  0x3501A,  0x04031,  0x0A080,  0x35036,  0x04048,  0x0A0EC,  0x0E0C4,  0x3503A,
+  0x00084,  0x2C0C4,  0x04031,  0x0A07F,  0x2C031,  0x3403A,  0x04048,  0x0A0EC,
+  0x0E0C4,  0x35042,  0x040C1,  0x0A002,  0x35040,  0x00040,  0x2C0C4,  0x3401A,
+  0x00001,  0x2C0C4,  0x04031,  0x0A07F,  0x2C031,  0x04023,  0x0A00C,  0x0E004,
+  0x357FC,  0x0404C,  0x0A001,  0x3504E,  0x300B0,  0x343FC,  0x04023,  0x0A001,
+  0x35453,  0x300BF,  0x343FC,  0x04048,  0x0E050,  0x357FC,  0x300DB,  0x343FC,
+  0x04031,  0x0A040,  0x3505F,  0x04023,  0x0C020,  0x2C023,  0x3406B,  0x040C1,
+  0x0A001,  0x3506B,  0x04023,  0x0C004,  0x2C023,  0x04048,  0x0A003,  0x35073,
+  0x04023,  0x0C008,  0x2C023,  0x040C3,  0x0A010,  0x3506F,  0x00054,  0x1804E,
+  0x00100,  0x00200,  0x34306,  0x040C2,  0x0A004,  0x2B400,  0x040C3,  0x0A010,
+  0x3507A,  0x00016,  0x18012,  0x00100,  0x00200,  0x30306,  0x0004C,  0x05100,
+  0x0A101,  0x2B000,  0x04008,  0x0A001,  0x35088,  0x04048,  0x0E080,  0x3509A,
+  0x04049,  0x0A002,  0x3548C,  0x00008,  0x18050,  0x05100,  0x0A101,  0x35494,
+  0x00208,  0x3032E,  0x0C400,  0x2B400,  0x04048,  0x0E040,  0x3549A,  0x04027,
+  0x0A010,  0x2B000,  0x0402D,  0x0A0FF,  0x350AC,  0x04048,  0x0E080,  0x354AC,
+  0x04063,  0x04139,  0x2C039,  0x0F010,  0x354AC,  0x04062,  0x04138,  0x0422D,
+  0x0B020,  0x2C038,  0x0F010,  0x2B000,  0x04023,  0x0C002,  0x2C023,  0x2A000,
+  0x04048,  0x0A0EC,  0x0E0E4,  0x354BC,  0x04036,  0x04135,  0x0D010,  0x2B400,
+  0x3033C,  0x2C0D8,  0x2C0D9,  0x2A000,  0x04048,  0x0E080,  0x310DB,  0x0414B,
+  0x0A180,  0x2B400,  0x0414A,  0x0424B,  0x1C10A,  0x1E200,  0x35CC9,  0x00100,
+  0x00200,  0x30340,  0x2BC00,  0x04048,  0x0E0B4,  0x2B400,  0x2A000,  0x04031,
+  0x0C004,  0x2C031,  0x00078,  0x00100,  0x042C3,  0x0A210,  0x350D9,  0x0006A,
+  0x00101,  0x00209,  0x34306,  0x0466D,  0x1866F,  0x05160,  0x19610,  0x0416A,
+  0x0A10C,  0x2C134,  0x350E9,  0x1860A,  0x05160,  0x18601,  0x05260,  0x30340,
+  0x1C60B,  0x34213,  0x00000,  0x2C023,  0x04031,  0x0A040,  0x2B400,  0x040C3,
+  0x0A010,  0x354FB,  0x04046,  0x0A001,  0x354FB,  0x04045,  0x14005,  0x35CFB,
+  0x040C3,  0x0A002,  0x354F8,  0x04048,  0x0A003,  0x2B400,  0x0004C,  0x05100,
+  0x0A101,  0x2B400,  0x0424C,  0x0434D,  0x0444E,  0x0454F,  0x04750,  0x04851,
+  0x04100,  0x0F120,  0x04001,  0x0F030,  0x0D100,  0x04002,  0x0F040,  0x0D100,
+  0x04003,  0x0F050,  0x0D100,  0x04004,  0x0F070,  0x0D100,  0x04005,  0x0F080,
+  0x0D100,  0x35146,  0x04027,  0x0A040,  0x35145,  0x00001,  0x2C0CE,  0x04130,
+  0x0F120,  0x04038,  0x0F200,  0x04031,  0x0F030,  0x0D100,  0x04039,  0x0F030,
+  0x0D200,  0x04032,  0x0F040,  0x0D100,  0x0403A,  0x0F040,  0x0D200,  0x04033,
+  0x0F050,  0x0D100,  0x0403B,  0x0F050,  0x0D200,  0x04034,  0x0F070,  0x0D100,
+  0x0403C,  0x0F070,  0x0D200,  0x04035,  0x0433D,  0x00400,  0x2C4CE,  0x0F080,
+  0x0D100,  0x35146,  0x0F380,  0x0D230,  0x35146,  0x2A000,  0x04023,  0x0C001,
+  0x2C023,  0x040C1,  0x0A002,  0x2B400,  0x04048,  0x0A00C,  0x0E004,  0x35564,
+  0x04048,  0x0A0E0,  0x0E0A0,  0x35164,  0x0E060,  0x2B400,  0x04131,  0x0A108,
+  0x2B000,  0x3020A,  0x040C3,  0x0A002,  0x3555A,  0x040C1,  0x0A002,  0x35577,
+  0x040C1,  0x0A001,  0x35177,  0x2A000,  0x3020A,  0x0413B,  0x040C3,  0x0A010,
+  0x355C5,  0x0C1C0,  0x002EE,  0x00300,  0x00701,  0x00603,  0x040C3,  0x0A002,
+  0x3556E,  0x040C1,  0x0A002,  0x35577,  0x040C1,  0x0A001,  0x3557C,  0x042C2,
+  0x0A2E0,  0x0C203,  0x2C2C2,  0x2A000,  0x2C6CE,  0x2C240,  0x2C341,  0x2C342,
+  0x2C343,  0x2C144,  0x2C745,  0x2C346,  0x2C347,  0x2C3CE,  0x04248,  0x0434A,
+  0x0444B,  0x01540,  0x0E580,  0x35193,  0x01520,  0x0E5B4,  0x35195,  0x04549,
+  0x0A504,  0x35595,  0x0A400,  0x0A300,  0x341AB,  0x00528,  0x01010,  0x0A007,
+  0x351A9,  0x0E004,  0x351A9,  0x0E001,  0x351A9,  0x18504,  0x0E004,  0x351A9,
+  0x0E007,  0x351A9,  0x18508,  0x0E004,  0x351A9,  0x18504,  0x0E005,  0x351A9,
+  0x1850C,  0x1D350,  0x1E400,  0x00000,  0x2C6CE,  0x0E2B4,  0x351B1,  0x005D4,
+  0x341B2,  0x005C4,  0x2C548,  0x2C049,  0x2C34A,  0x2C44B,  0x00306,  0x00152,
+  0x0024C,  0x2C0CE,  0x05810,  0x2C6CE,  0x2D820,  0x18101,  0x18201,  0x1C301,
+  0x355B9,  0x2C0CE,  0x00001,  0x2C03E,  0x2A000,  0x045C1,  0x0A540,  0x351CC,
+  0x01510,  0x0E50A,  0x355CC,  0x00114,  0x01510,  0x00784,  0x00800,  0x0E56E,
+  0x351D9,  0x00704,  0x0E559,  0x351D8,  0x0E523,  0x351D7,  0x18838,  0x18823,
+  0x1880A,  0x1880B,  0x00603,  0x00300,  0x040C3,  0x0A002,  0x355DC,  0x040C1,
+  0x0A002,  0x35577,  0x040C1,  0x0A001,  0x35177,  0x2C6CE,  0x2C340,  0x2C341,
+  0x2C342,  0x2C343,  0x2C144,  0x2C745,  0x2C846,  0x2C347,  0x2C3CE,  0x04248,
+  0x0434A,  0x0444B,  0x01540,  0x0E580,  0x351FC,  0x01520,  0x0E5B4,  0x351FE,
+  0x04549,  0x0A504,  0x355FE,  0x0A400,  0x0A300,  0x341AB,  0x01580,  0x1850A,
+  0x1D350,  0x1E400,  0x045C1,  0x0A540,  0x35606,  0x185A0,  0x18520,  0x1D350,
+  0x1E400,  0x341AB,  0x00000,  0x00100,  0x00217,  0x04348,  0x0E3B4,  0x35211,
+  0x00207,  0x30306,  0x2A000,  0x18603,  0x04027,  0x0A010,  0x0416A,  0x0A102,
+  0x20106,  0x20106,  0x20106,  0x0F010,  0x2B400,  0x0C100,  0x35237,  0x0426D,
+  0x04013,  0x0F020,  0x2B400,  0x0006E,  0x00100,  0x0A2FF,  0x2B000,  0x00500,
+  0x05300,  0x00701,  0x2C7CE,  0x05410,  0x00700,  0x2C7CE,  0x0F340,  0x0D530,
+  0x18001,  0x18101,  0x1C201,  0x35628,  0x0C500,  0x2B400,  0x34257,  0x00058,
+  0x00108,  0x00206,  0x00500,  0x05300,  0x05410,  0x0F340,  0x0D530,  0x18001,
+  0x18101,  0x1C201,  0x3563B,  0x0C500,  0x2B400,  0x04034,  0x0C000,  0x35257,
+  0x18603,  0x05060,  0x00100,  0x1D100,  0x2C1ED,  0x18601,  0x05060,  0x2C019,
+  0x18601,  0x05060,  0x2C01F,  0x18601,  0x05060,  0x2C01E,  0x18602,  0x04048,
+  0x0A0EC,  0x0E080,  0x35676,  0x04023,  0x0C002,  0x2C023,  0x040C2,  0x0A080,
+  0x35265,  0x040C2,  0x0A05F,  0x2C0C2,  0x2C0C2,  0x18603,  0x04027,  0x0A010,
+  0x3526F,  0x05060,  0x2C01F,  0x18601,  0x05060,  0x2C01E,  0x34276,  0x05060,
+  0x00100,  0x1D100,  0x2C1EC,  0x18601,  0x05060,  0x2C018,  0x040C3,  0x0A010,
+  0x35685,  0x04044,  0x04145,  0x04246,  0x00304,  0x2020E,  0x20108,  0x20008,
+  0x2010E,  0x20008,  0x1C301,  0x35680,  0x34294,  0x04046,  0x04147,  0x04244,
+  0x003C0,  0x0E26E,  0x3568C,  0x00311,  0x04244,  0x0E237,  0x35690,  0x00323,
+  0x04244,  0x0E214,  0x35694,  0x00360,  0x1D030,  0x1E100,  0x30339,  0x1801A,
+  0x1A100,  0x04260,  0x19200,  0x04361,  0x1B310,  0x04462,  0x1A400,  0x04563,
+  0x1A500,  0x04664,  0x1A600,  0x04765,  0x1A700,  0x04866,  0x1A800,  0x04967,
+  0x1A900,  0x0406A,  0x0A002,  0x352BF,  0x040E0,  0x1D020,  0x040E1,  0x1F030,
+  0x040E2,  0x1F040,  0x040E3,  0x1F050,  0x040E4,  0x1F060,  0x040E5,  0x1F070,
+  0x040E6,  0x1F080,  0x040E7,  0x1F090,  0x2BC00,  0x00000,  0x342C0,  0x30339,
+  0x2C2E0,  0x2C3E1,  0x2C4E2,  0x2C5E3,  0x2C6E4,  0x2C7E5,  0x2C8E6,  0x2C9E7,
+  0x01230,  0x0401D,  0x0411C,  0x00D27,  0x00C01,  0x20006,  0x20100,  0x35AD5,
+  0x18C01,  0x0EC10,  0x352F4,  0x0EC10,  0x342CD,  0x20108,  0x342D8,  0x2010E,
+  0x20008,  0x1CC01,  0x352EC,  0x01A80,  0x01B90,  0x1DA00,  0x1FB10,  0x35AD7,
+  0x018A0,  0x019B0,  0x342D7,  0x1CD01,  0x352F8,  0x20306,  0x20400,  0x20500,
+  0x20600,  0x20700,  0x20800,  0x20900,  0x01A80,  0x01B90,  0x1DA00,  0x1FB10,
+  0x35AE3,  0x018A0,  0x019B0,  0x342E3,  0x00100,  0x008FF,  0x009FF,  0x34301,
+  0x30339,  0x0401D,  0x0411C,  0x04AE1,  0x0FA20,  0x0AAFC,  0x35301,  0x18801,
+  0x1A900,  0x1D800,  0x1F910,  0x2C8EA,  0x2C9EB,  0x2A000,  0x0442C,  0x0C000,
+  0x3530D,  0x04325,  0x01430,  0x20306,  0x19430,  0x19040,  0x1A100,  0x043C3,
+  0x0A310,  0x35717,  0x04344,  0x0A302,  0x35317,  0x00318,  0x3431A,  0x0031C,
+  0x1D030,  0x1E100,  0x04AC1,  0x0AA80,  0x3571A,  0x04ADB,  0x190A0,  0x1A100,
+  0x12180,  0x35325,  0x00001,  0x00100,  0x34327,  0x18001,  0x1A100,  0x2C0D0,
+  0x2C1D2,  0x043C2,  0x0A3E0,  0x0D230,  0x2C2C2,  0x2A000,  0x00506,  0x00400,
+  0x05100,  0x05320,  0x0F130,  0x0D410,  0x18201,  0x18001,  0x1C501,  0x35730,
+  0x2A000,  0x04AC1,  0x0AA80,  0x35339,  0x04AC1,  0x0AA80,  0x3573C,  0x2A000,
+  0x30339,  0x043D8,  0x044D9,  0x18301,  0x1A400,  0x1D310,  0x1F420,  0x2BC00,
+  0x2C1D8,  0x2C2D9,  0x2A000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,
+  0x00000,  0x00000,  0x00000,  0x00000,  0x00000,  0x2C0CF,  0x34000,  0x00000
+};
+
+/*const*/ int macassist_data_len = (sizeof wifi_macassist_ucode)/4; 
+
+#endif /* CFG_HAS_WIRELESS */
diff --git a/common/digi/cmd_testhw/wireless/wireless.c b/common/digi/cmd_testhw/wireless/wireless.c
new file mode 100644
index 0000000..5472ebc
--- /dev/null
+++ b/common/digi/cmd_testhw/wireless/wireless.c
@@ -0,0 +1,129 @@
+/*
+ *  common/digi/cmd_testhw/common/wireless.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP && \
+     defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+     defined(CFG_HAS_WIRELESS))
+
+#include <cmd_testhw/testhw.h>
+#include "calibration.h"
+/*#include "fpArithmetic.h"*/
+#include "vBPiper.h"
+#include "gui_tst_wifi.h"
+#include "commandswifi.h"
+
+#define USAGE	"Performs wireless testing and calibration."
+
+extern char cancel_prompt_echo;
+
+wcd_data_t calDataObtained;
+
+static int do_testhw_wireless(int argc, char* argv[])
+{
+	
+	/* For loop control */
+	signed char i;
+	
+	/* Wireless Status */
+	static struct menuStatus auxMenuStatus;
+
+	if (argc > 1)
+	{
+		printf("Incorrect number of arguments");
+		return 0;
+	}
+	
+
+	printf("\nSTARTING TESTHW WIRELESS APPLICATION...\n");
+	printf("Resetting Piper...\n");
+	piperReset();
+		
+	printf("Initializing uP and Piper...\n");
+	initializeuPToKnowState();
+	
+	#if CONFIG_CCW9P9215
+	//registersPiperToDefault();
+	#endif
+	
+	waitUS(10);
+	
+	printf("Loading Firmware to Piper...\n");
+	InitHW();
+	
+	printf("Setting Channel 1...\n");
+	SetChannel(1);
+	
+	printf("Setting BSS...\n");
+	SetBSS (1, (unsigned char *) "TESTING123", 10, 0xFFFF, 10); /* "TESTING123" */
+
+	//SetBSS (0, "TESTING123", 10, 0xFFFF, 10);
+	//MacRadioTXPeriodic (0, 0, 0, 0, 0, 0);
+
+	//waitUS(1000);
+
+	printf("Activating DSP and MAC processor...\n");
+	//__write32 (HW_GEN_CONTROL, DSP_MACASSIST_ENABLE, OR);
+	
+	
+	printf("Setting output power level to min...\n");
+	MacSetDirectTxPower(0);
+	
+
+	/* Golden delay. Never delete. */
+	printf("Waiting for start-up:");
+	for (i = 1; i >= 0; i--) // From 2
+	{
+		printf (" %ds. ",i);
+		waitUS(1000000);	
+	}
+	printf("\n");
+
+		
+	//MacSetDirectTxPower(20);
+	
+	auxMenuStatus.statusInformation = RADIO_NOSELECTION;
+	auxMenuStatus.power_control = FALSE;
+	auxMenuStatus.calibration_status = FALSE;
+	auxMenuStatus.channel = 1;
+	auxMenuStatus.transmit_mode = 0;
+	auxMenuStatus.txpower = 0;
+	auxMenuStatus.transmit_rate = 0;
+	auxMenuStatus.frame_period = 0;
+	auxMenuStatus.frame_length = 0;
+	auxMenuStatus.lastNumRxFrames = 0;
+	//writeDummyPowerLimitValues(&(auxMenuStatus.calData));
+
+	printf("Wireless hardware running.\nStarting up test enviroment ");
+	
+	if (argc == 1)
+	{
+		cancel_prompt_echo = 1;
+		printf ("without human interface...\n");
+		mainRoutineTestHWWirelessNoMenu(&auxMenuStatus);
+		cancel_prompt_echo = 0;
+	}
+	else
+	{
+		printf ("with human interface...\n");
+		tst_wifi(&auxMenuStatus);
+	}
+
+	return 1;
+}
+
+/* ********** Test command implemented ********** */
+
+TESTHW_CMD(wireless, USAGE);
+
+#endif /* CFG_HAS_WIRELESS */
+
diff --git a/common/digi/fpga_checkbitstream.h b/common/digi/fpga_checkbitstream.h
new file mode 100644
index 0000000..08be2e6
--- /dev/null
+++ b/common/digi/fpga_checkbitstream.h
@@ -0,0 +1,26 @@
+/*
+ *  common/digi/fpga_checkbitstream.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines the functions to access the DIGI fpga
+ */
+
+#ifndef __DIGI_FPGA_CHECKBITSTREAM_H
+#define __DIGI_FPGA_CHECKBITSTREAM_H
+
+#define LOAD_FPGA_OK	0
+#define LOAD_FPGA_FAIL	1
+
+extern int fpga_checkbitstream( uchar* fpgadata, ulong size );
+extern ulong fpga_hw_version, fpga_fw_version, checksum_calc, checksum_read, fpgadatasize;
+
+#endif /* __DIGI_FPGA_CHECKBITSTREAM_H */
diff --git a/common/digi/vscanf.c b/common/digi/vscanf.c
new file mode 100644
index 0000000..c2db926
--- /dev/null
+++ b/common/digi/vscanf.c
@@ -0,0 +1,257 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+/* 
+ * Fri Jul 13 2001 Crutcher Dunnavant <crutcher+kernel@datastacks.com>
+ * - changed to provide snprintf and vsnprintf functions
+ * So Feb  1 16:51:32 CET 2004 Juergen Quade <quade@hsnr.de>
+ * - scnprintf and vscnprintf
+ */
+
+/* Taken from /usr/local/LxNETES-4.0/kernel/linux/lib/vsprintf.c and adapted to
+ * U-Boot by Markus Pietrek. Removed signed support */
+
+#include <common.h>             /* simple_stroul */
+#include <stdarg.h>             /* va_list */
+#include <linux/ctype.h>        /* is_digit */
+
+#include "vscanf.h"
+
+/* also from some linux include files */
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+#define INT_MAX		((int)(~0U>>1))
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (isdigit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:	input buffer
+ * @fmt:	format of buffer
+ * @args:	arguments
+ */
+int vsscanf(const char * buf, const char * fmt, va_list args)
+{
+	const char *str = buf;
+	char *next;
+	char digit;
+	int num = 0;
+	int qualifier;
+	int base;
+	int field_width;
+	int is_sign = 0;
+
+	while(*fmt && *str) {
+		/* skip any white space in format */
+		/* white space in format matchs any amount of
+		 * white space, including none, in the input.
+		 */
+		if (isspace(*fmt)) {
+			while (isspace(*fmt))
+				++fmt;
+			while (isspace(*str))
+				++str;
+		}
+
+		/* anything that is not a conversion must match exactly */
+		if (*fmt != '%' && *fmt) {
+			if (*fmt++ != *str++)
+				break;
+			continue;
+		}
+
+		if (!*fmt)
+			break;
+		++fmt;
+		
+		/* skip this conversion.
+		 * advance both strings to next white space
+		 */
+		if (*fmt == '*') {
+			while (!isspace(*fmt) && *fmt)
+				fmt++;
+			while (!isspace(*str) && *str)
+				str++;
+			continue;
+		}
+
+		/* get field width */
+		field_width = -1;
+		if (isdigit(*fmt))
+			field_width = skip_atoi(&fmt);
+
+		/* get conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+		    *fmt == 'Z' || *fmt == 'z') {
+			qualifier = *fmt++;
+			if (unlikely(qualifier == *fmt)) {
+				if (qualifier == 'h') {
+					qualifier = 'H';
+					fmt++;
+				} else if (qualifier == 'l') {
+					qualifier = 'L';
+					fmt++;
+				}
+			}
+		}
+		base = 10;
+		is_sign = 0;
+
+		if (!*fmt || !*str)
+			break;
+
+		switch(*fmt++) {
+		case 'c':
+		{
+			char *s = (char *) va_arg(args,char*);
+			if (field_width == -1)
+				field_width = 1;
+			do {
+				*s++ = *str++;
+			} while (--field_width > 0 && *str);
+			num++;
+		}
+		continue;
+		case 's':
+		{
+			char *s = (char *) va_arg(args, char *);
+			if(field_width == -1)
+				field_width = INT_MAX;
+			/* first, skip leading white space in buffer */
+			while (isspace(*str))
+				str++;
+
+			/* now copy until next white space */
+			while (*str && !isspace(*str) && field_width--) {
+				*s++ = *str++;
+			}
+			*s = '\0';
+			num++;
+		}
+		continue;
+		case 'n':
+			/* return number of characters read so far */
+		{
+			int *i = (int *)va_arg(args,int*);
+			*i = str - buf;
+		}
+		continue;
+		case 'o':
+			base = 8;
+			break;
+		case 'x':
+		case 'X':
+			base = 16;
+			break;
+		case 'i':
+                        base = 0;
+		case 'd':
+			is_sign = 1;
+		case 'u':
+			break;
+		case '%':
+			/* looking for '%' in str */
+			if (*str++ != '%') 
+				return num;
+			continue;
+		default:
+			/* invalid format; stop here */
+			return num;
+		}
+
+		/* have some sort of integer conversion.
+		 * first, skip white space in buffer.
+		 */
+		while (isspace(*str))
+			str++;
+
+		digit = *str;
+		if (is_sign && digit == '-')
+			digit = *(str + 1);
+
+		if (!digit
+                    || (base == 16 && !isxdigit(digit))
+                    || (base == 10 && !isdigit(digit))
+                    || (base == 8 && (!isdigit(digit) || digit > '7'))
+                    || (base == 0 && !isdigit(digit)))
+				break;
+
+		switch(qualifier) {
+		case 'H':	/* that's 'hh' in format */
+			{
+				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
+				*s = (unsigned char) simple_strtoul(str, &next, base);
+			}
+			break;
+		case 'h':
+			{
+				unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
+				*s = (unsigned short) simple_strtoul(str, &next, base);
+			}
+			break;
+		case 'l':
+			{
+				unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
+				*l = simple_strtoul(str,&next,base);
+			}
+			break;
+		case 'L':
+			{
+				unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
+				*l = simple_strtoull(str,&next,base);
+			}
+			break;
+		case 'Z':
+		case 'z':
+		{
+			size_t *s = (size_t*) va_arg(args,size_t*);
+			*s = (size_t) simple_strtoul(str,&next,base);
+		}
+		break;
+		default:
+			{
+				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
+				*i = (unsigned int) simple_strtoul(str,&next,base);
+			}
+			break;
+		}
+		num++;
+
+		if (!next)
+			break;
+		str = next;
+	}
+	return num;
+}
+
+/**
+ * sscanf - Unformat a buffer into a list of arguments
+ * @buf:	input buffer
+ * @fmt:	formatting of buffer
+ * @...:	resulting arguments
+ */
+int sscanf(const char * buf, const char * fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args,fmt);
+	i = vsscanf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
diff --git a/common/digi/vscanf.h b/common/digi/vscanf.h
new file mode 100644
index 0000000..e4daa26
--- /dev/null
+++ b/common/digi/vscanf.h
@@ -0,0 +1,10 @@
+#ifndef __DIGI_VSCANF_H
+#define __DIGI_VSCANF_H
+
+/* !!!!! vsscanf has been tuned down to not support signed operations.
+   Therefore, only simple_strtoul are used.
+*/
+extern int vsscanf(const char * buf, const char * fmt, va_list args);
+extern int sscanf(const char * buf, const char * fmt, ...);
+
+#endif  /* NVRAM_H */
diff --git a/common/env_common.c b/common/env_common.c
index 460309b..be7d555 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -29,9 +29,22 @@
 #include <environment.h>
 #include <linux/stddef.h>
 #include <malloc.h>
+#include "../common/digi/cmd_nvram/mtd.h"
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_AMIGAONEG3SE
+	extern void enable_nvram(void);
+	extern void disable_nvram(void);
+#endif
+
 #undef DEBUG_ENV
 #ifdef DEBUG_ENV
 #define DEBUGF(fmt,args...) printf(fmt ,##args)
@@ -41,10 +54,13 @@ DECLARE_GLOBAL_DATA_PTR;
 
 extern env_t *env_ptr;
 
+size_t nvram_part_size;
+
 extern void env_relocate_spec (void);
 extern uchar env_get_char_spec(int);
 
 static uchar env_get_char_init (int index);
+unsigned char (*env_get_char)(int) = env_get_char_init;
 
 /************************************************************************
  * Default settings to be used when no valid environment is found
@@ -86,20 +102,14 @@ uchar default_environment[] = {
 #ifdef	CONFIG_ETH3ADDR
 	"eth3addr="	MK_STR(CONFIG_ETH3ADDR)		"\0"
 #endif
-#ifdef	CONFIG_ETH4ADDR
-	"eth4addr="	MK_STR(CONFIG_ETH4ADDR)		"\0"
-#endif
-#ifdef	CONFIG_ETH5ADDR
-	"eth5addr="	MK_STR(CONFIG_ETH5ADDR)		"\0"
-#endif
 #ifdef	CONFIG_IPADDR
 	"ipaddr="	MK_STR(CONFIG_IPADDR)		"\0"
 #endif
 #ifdef	CONFIG_SERVERIP
 	"serverip="	MK_STR(CONFIG_SERVERIP)		"\0"
 #endif
-#ifdef	CONFIG_SYS_AUTOLOAD
-	"autoload="	CONFIG_SYS_AUTOLOAD			"\0"
+#ifdef	CFG_AUTOLOAD
+	"autoload="	CFG_AUTOLOAD			"\0"
 #endif
 #ifdef	CONFIG_PREBOOT
 	"preboot="	CONFIG_PREBOOT			"\0"
@@ -117,7 +127,7 @@ uchar default_environment[] = {
 	"hostname="	MK_STR(CONFIG_HOSTNAME)		"\0"
 #endif
 #ifdef	CONFIG_BOOTFILE
-	"bootfile="	MK_STR(CONFIG_BOOTFILE)		"\0"
+	"bootfile="	CONFIG_BOOTFILE			"\0"
 #endif
 #ifdef	CONFIG_LOADADDR
 	"loadaddr="	MK_STR(CONFIG_LOADADDR)		"\0"
@@ -134,6 +144,10 @@ uchar default_environment[] = {
 	"\0"
 };
 
+#if defined(CFG_ENV_IS_IN_NAND)		/* Environment is in Nand Flash */
+int default_environment_size = sizeof(default_environment);
+#endif
+
 void env_crc_update (void)
 {
 	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
@@ -154,27 +168,29 @@ static uchar env_get_char_init (int index)
 	return (c);
 }
 
+#ifdef CONFIG_AMIGAONEG3SE
 uchar env_get_char_memory (int index)
 {
+	uchar retval;
+	enable_nvram();
 	if (gd->env_valid) {
-		return ( *((uchar *)(gd->env_addr + index)) );
+		retval = ( *((uchar *)(gd->env_addr + index)) );
 	} else {
-		return ( default_environment[index] );
+		retval = ( default_environment[index] );
 	}
+	disable_nvram();
+	return retval;
 }
-
-uchar env_get_char (int index)
+#else
+uchar env_get_char_memory (int index)
 {
-	uchar c;
-
-	/* if relocated to RAM */
-	if (gd->flags & GD_FLG_RELOC)
-		c = env_get_char_memory(index);
-	else
-		c = env_get_char_init(index);
-
-	return (c);
+	if (gd->env_valid) {
+		return ( *((uchar *)(gd->env_addr + index)) );
+	} else {
+		return ( default_environment[index] );
+	}
 }
+#endif
 
 uchar *env_get_addr (int index)
 {
@@ -185,28 +201,27 @@ uchar *env_get_addr (int index)
 	}
 }
 
-void set_default_env(void)
-{
-	if (sizeof(default_environment) > ENV_SIZE) {
-		puts ("*** Error - default environment is too large\n\n");
-		return;
-	}
-
-	memset(env_ptr, 0, sizeof(env_t));
-	memcpy(env_ptr->data, default_environment,
-	       sizeof(default_environment));
-#ifdef CONFIG_SYS_REDUNDAND_ENVIRONMENT
-	env_ptr->flags = 0xFF;
-#endif
-	env_crc_update ();
-	gd->env_valid = 1;
-}
-
 void env_relocate (void)
 {
-#ifndef CONFIG_RELOC_FIXUP_WORKS
 	DEBUGF ("%s[%d] offset = 0x%lx\n", __FUNCTION__,__LINE__,
 		gd->reloc_off);
+
+	/* Dynamic calculation of NVRAM partition size. */
+	nvram_part_size = MtdGetEraseSize(0, PART_UBOOT_SIZE);
+	while (nvram_part_size < CFG_ENV_SIZE)
+		nvram_part_size += MtdGetEraseSize(0, PART_UBOOT_SIZE + nvram_part_size);
+	
+	/* space for NVRAM backup */
+	nvram_part_size += MtdGetEraseSize(0, PART_UBOOT_SIZE + nvram_part_size);
+	while (nvram_part_size < 2 * CFG_ENV_SIZE)
+		nvram_part_size += MtdGetEraseSize(0, PART_UBOOT_SIZE + nvram_part_size);
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) 
+	/* double NVRAM partition size to handle bad blcoks */
+	nvram_part_size += nvram_part_size;
+#endif
+#ifdef CONFIG_AMIGAONEG3SE
+	enable_nvram();
 #endif
 
 #ifdef ENV_IS_EMBEDDED
@@ -214,31 +229,53 @@ void env_relocate (void)
 	 * The environment buffer is embedded with the text segment,
 	 * just relocate the environment pointer
 	 */
-#ifndef CONFIG_RELOC_FIXUP_WORKS
 	env_ptr = (env_t *)((ulong)env_ptr + gd->reloc_off);
-#endif
 	DEBUGF ("%s[%d] embedded ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
 #else
 	/*
 	 * We must allocate a buffer for the environment
 	 */
-	env_ptr = (env_t *)malloc (CONFIG_ENV_SIZE);
+	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
 	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
 #endif
 
+	/*
+	 * After relocation to RAM, we can always use the "memory" functions
+	 */
+	env_get_char = env_get_char_memory;
+
 	if (gd->env_valid == 0) {
-#if defined(CONFIG_ENV_IS_NOWHERE)	/* Environment not changable */
+#if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
 #else
 		puts ("*** Warning - bad CRC, using default environment\n\n");
-		show_boot_progress (-60);
+		SHOW_BOOT_PROGRESS (-1);
 #endif
-		set_default_env();
+
+		if (sizeof(default_environment) > ENV_SIZE)
+		{
+			puts ("*** Error - default environment is too large\n\n");
+			return;
+		}
+
+		memset (env_ptr, 0, sizeof(env_t));
+		memcpy (env_ptr->data,
+			default_environment,
+			sizeof(default_environment));
+#ifdef CFG_REDUNDAND_ENVIRONMENT
+		env_ptr->flags = 0xFF;
+#endif
+		env_crc_update ();
+		gd->env_valid = 1;
 	}
 	else {
 		env_relocate_spec ();
 	}
 	gd->env_addr = (ulong)&(env_ptr->data);
+
+#ifdef CONFIG_AMIGAONEG3SE
+	disable_nvram();
+#endif
 }
 
 #ifdef CONFIG_AUTO_COMPLETE
diff --git a/common/flash.c b/common/flash.c
index 683978e..131c5d7 100644
--- a/common/flash.c
+++ b/common/flash.c
@@ -22,7 +22,7 @@
  */
 
 /* #define DEBUG */
-
+#include <configs/cc9p9215.h>
 #include <common.h>
 #include <flash.h>
 
diff --git a/common/helper.c b/common/helper.c
new file mode 100644
index 0000000..49e8080
--- /dev/null
+++ b/common/helper.c
@@ -0,0 +1,60 @@
+/*
+ *  common/helper.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Various helper stuff, like waiting for Yes Pressed etc.
+*/
+
+#include <common.h>
+#include "helper.h"
+
+/*! \brief waits until something is pressed on console */
+/*! \return 1 if yes is pressed otherwise 1
+ */
+int WaitForYesPressed( const char* szWhat, const char* szWhere )
+{
+        int iRes = 0;
+        
+        printf( "%s(y/n)", szWhat );
+                    
+        while( 1 ) {
+                if( tstc() ) { 
+                        char c = getc();
+                        putc( c );
+
+                        if( 'y' == c ) {
+                                iRes = 1;
+                                break;
+                        } else {
+                                eprintf( "\n%s aborted\n", szWhere );
+                                break;
+                        }
+                }
+        } /* while( true ) */
+
+        printf( "\n" );
+        
+        return iRes;
+}
+
+long get_input(const char *cp)
+{
+	ulong res = 0;
+	char * endp;
+	res = simple_strtoul(cp, &endp, 16);
+	if(strlen(cp) != (endp - cp)) {
+		printf("input not valid\n");
+		return -1;
+	}
+	return res;
+}
diff --git a/common/main.c b/common/main.c
index 8d548db..7d50926 100644
--- a/common/main.c
+++ b/common/main.c
@@ -26,7 +26,7 @@
  */
 
 /* #define	DEBUG	*/
-
+#include <configs/digi_common.h>
 #include <common.h>
 #include <watchdog.h>
 #include <command.h>
diff --git a/common/serial.c b/common/serial.c
index 1345c08..5bb8f40 100644
--- a/common/serial.c
+++ b/common/serial.c
@@ -29,12 +29,21 @@ DECLARE_GLOBAL_DATA_PTR;
 
 static struct serial_device *serial_devices = NULL;
 static struct serial_device *serial_current = NULL;
+#if defined(CONFIG_NS9215) || defined(CONFIG_NS9210)
+extern struct serial_device serial_ns921x_devices[4];
+#endif
 
 #if !defined(CONFIG_LWMON) && !defined(CONFIG_PXA27X)
 struct serial_device *__default_serial_console (void)
 {
 #if defined(CONFIG_8xx_CONS_SMC1) || defined(CONFIG_8xx_CONS_SMC2)
 	return &serial_smc_device;
+#elif defined(CONFIG_NS9215) || defined(CONFIG_NS9210)
+#ifdef CONFIG_NS921X_FIM_UART
+        return &fim_serial_device;
+#else
+        return &serial_ns921x_devices[ CONFIG_CONS_INDEX ];
+#endif
 #elif defined(CONFIG_8xx_CONS_SCC1) || defined(CONFIG_8xx_CONS_SCC2) \
    || defined(CONFIG_8xx_CONS_SCC3) || defined(CONFIG_8xx_CONS_SCC4)
 	return &serial_scc_device;
@@ -126,6 +135,15 @@ void serial_initialize (void)
  || defined(CONFIG_8xx_CONS_SCC3) || defined(CONFIG_8xx_CONS_SCC4)
 	serial_register (&serial_scc_device);
 #endif
+#if defined(CONFIG_NS9215) || defined(CONFIG_NS9210)
+#ifdef CONFIG_NS921X_FIM_UART
+        serial_register( &fim_serial_device);
+#else
+        int i;
+        for( i = 0; i < ARRAY_SIZE( serial_ns921x_devices ); i++ )
+                serial_register( &serial_ns921x_devices[ i ] );
+#endif
+#endif
 
 #if defined(CONFIG_405GP) || defined(CONFIG_405CR) || defined(CONFIG_440) \
  || defined(CONFIG_405EP) || defined(CONFIG_405EZ) || defined(CONFIG_405EX) \
@@ -300,3 +318,17 @@ void serial_puts (const char *s)
 
 	serial_current->puts (s);
 }
+/* flushes all characters in Tx Queue and returns when completed */
+void serial_tx_flush (void)
+{
+            struct serial_device* dev;
+
+                    dev = ( (!(gd->flags & GD_FLG_RELOC) || !serial_current) ?
+                                            default_serial_console() :
+                                                            serial_current );
+
+                            if( NULL != dev->tx_flush )
+                                                /* has been added only for Digi Drivers */
+                                                dev->tx_flush();
+}
+
diff --git a/cpu/arm926ejs/ns921x/Makefile b/cpu/arm926ejs/ns921x/Makefile
new file mode 100644
index 0000000..766458f
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2000-2005
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Copyright (C) 2007 by Digi International Inc.
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= lib$(SOC).a
+
+COBJS	:= timer.o serial_ns921x.o ns921x_edt.o ns921x_eth.o \
+	   fim_serial.o fim.o fim_sdio.o
+
+SOBJS	:= reset.o
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+
+DIGI_DIR := $(TOPDIR)/common/digi
+DIGI_BSP := -I $(DIGI_DIR) -I $(DIGI_DIR)/cmd_nvram/ -I $(DIGI_DIR)/cmd_nvram/lib/include -DUBOOT
+CFLAGS   += $(DIGI_BSP)
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm926ejs/ns921x/fim.c b/cpu/arm926ejs/ns921x/fim.c
new file mode 100644
index 0000000..8487a10
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim.c
@@ -0,0 +1,572 @@
+/* -*- linux-c -*-
+ * cpu/arm926ejs/ns921x/fims/fim.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision$
+ * !Author:     Luis Galdos
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ */
+
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm-arm/arch-ns9xxx/ns921x_fim.h>
+#include <asm-arm/arch-ns9xxx/fim_firmware.h>
+#include <asm-arm/arch-ns9xxx/io.h>
+#include <asm-arm/arch-ns9xxx/ns921x_hub.h>
+#include "fim_reg.h"
+
+#define	FIM0_SHIFT			6
+
+/* @XXX: Need a similar mechanism as under Linux for having customizable DMA-channels */
+#define FIM_TOTAL_NUMBER                (FIM_MAX_PIC_INDEX + 1)
+#define FIM_DMA_BUFFERS                 (21)
+#define FIM_TOTAL_BUFFERS               (FIM_TOTAL_NUMBER * FIM_DMA_BUFFERS)
+#define FIM_BUFFER_SIZE                 (1024)
+
+//#define FIM_CORE_DEBUG
+
+#define printk_info(fmt,args...)                   printf(fmt, ##args)
+#define printk_err(fmt,args...)                   printf(fmt, ##args)
+
+#if defined(FIM_CORE_DEBUG)
+# define printk_debug(fmt,args...)                   printf(fmt, ##args)
+#else
+# define printk_debug(fmt, args...)
+#endif
+
+/* Data for the RX-DMA buffers and DMA-FIFOs too */
+static volatile struct iohub_dma_desc_t fim_rxdma_buffers[FIM_TOTAL_BUFFERS];
+static volatile struct iohub_dma_fifo_t fim_rxdma_fifos[FIM_TOTAL_NUMBER];
+
+int fim_get_exp_reg(int pic_num, int nr)
+{
+	return readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_EXP_REG(nr));
+}
+
+/*
+ * This function provides the access to the control registers of the PICs
+ * reg : Number of the control register (from 0 to 15)
+ * val : Value to write into the control register
+ */
+void fim_set_ctrl_reg(int pic_num, int reg, unsigned int val)
+{
+	writel(val, FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL_REG(reg));
+}
+
+int fim_send_interrupt(int pic_num, unsigned int code)
+{
+	unsigned int stopcnt;
+	u32 status;
+
+	if ( !code || (code & ~0x7f))
+		return 1;
+
+	if (!pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	code = NS92XX_FIM_INT_MASK(code);
+	status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	writel(status | code, FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	/* This loop is perhaps problematic, exit with a timeout */
+	stopcnt = 0xFFFF;
+	do {
+		status = readl(FIM_REG_ADDR(pic_num)  + NS92XX_FIM_GEN_CTRL_REG);
+		stopcnt--;
+	} while (!(status & NS92XX_FIM_GEN_CTRL_INTACKRD) && stopcnt);
+
+	if (!stopcnt) {
+		return 1;
+	}
+
+	/* Reset the interrupt bits for the PIC acknowledge */
+	status &= ~NS92XX_FIM_GEN_CTRL_INTTOPIC;
+	writel(status, FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	stopcnt = 0xFFFF;
+	do {
+		status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+		stopcnt--;
+	} while ((status & NS92XX_FIM_GEN_CTRL_INTACKRD) && stopcnt);
+
+	if (!stopcnt) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* Provides the read access to the control registers of the PICs */
+int fim_get_iohub_reg(int pic_num, int reg)
+{
+	return readl(FIM_IOHUB_ADDR(pic_num) + reg);
+}
+
+void fim_set_iohub_reg(int pic_num, int reg, unsigned int val)
+{
+	writel(val, FIM_IOHUB_ADDR(pic_num) + reg);
+}
+
+/* Provides the read access to the control registers of the PICs */
+int fim_get_ctrl_reg(int pic_num, int reg)
+{
+	if (NS92XX_FIM_CTRL_REG_CHECK(reg))
+		return -1;
+
+	return readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL_REG(reg));
+}
+
+int pic_get_exp_reg(int pic_num, int nr, unsigned int *value)
+{
+	*value = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_EXP_REG(nr));
+
+	return 0;
+}
+
+int pic_is_running(int pic_num)
+{
+	unsigned int regval;
+
+	regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	if (regval & NS92XX_FIM_GEN_CTRL_PROGMEM)
+		return 1;
+	else
+		return 0;
+}
+
+/* Called when the PIC interrupts the ARM-processor */
+void isr_from_pic(int pic_num, int irqnr)
+{
+	unsigned int status;
+	unsigned int rx_fifo;
+	unsigned int timeout;
+
+	status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	rx_fifo = readl(FIM_IOHUB_ADDR(pic_num) + HUB_RX_FIFO_STAT);
+
+	/* @TEST */
+	writel(status, FIM_REG_ADDR(pic_num) + NS92XX_FIM_CTRL7_REG);
+
+	writel(status | NS92XX_FIM_GEN_CTRL_INTACKWR,
+	       FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+
+	timeout = 0xFFFF;
+	do {
+		timeout--;
+		status = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	} while (timeout && (status & NS92XX_FIM_GEN_CTRL_INTFROMPIC));
+
+	/* @XXX: Should we stop the PIC for avoiding more timeout errors? */
+	if (!timeout) {
+		return;
+	}
+
+	writel(status & ~NS92XX_FIM_GEN_CTRL_INTACKWR, FIM_REG_ADDR(pic_num) +
+	       NS92XX_FIM_GEN_CTRL_REG);
+}
+
+/* This is the main ISR for the PIC-interrupts */
+void pic_irq(int pic_num)
+{
+	unsigned int ifs;
+
+	ifs = readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+
+	if (ifs & HUB_INT_MODIP)
+		isr_from_pic(pic_num, 0x00);
+
+	writel(ifs, FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+}
+
+/* Set the HWA PIC clock (see PIC module specification, page 19) */
+static int pic_config_output_clock_divisor(int pic_num, struct fim_program_t *program)
+{
+	int div;
+	int clkd;
+	unsigned int val;
+
+	if (!program)
+		return 1;
+
+	div = program->clkdiv;
+	switch (div) {
+	case FIM_CLK_DIV_2:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_2;
+		break;
+
+	case FIM_CLK_DIV_4:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_4;
+		break;
+
+	case FIM_CLK_DIV_8:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_8;
+		break;
+
+	case FIM_CLK_DIV_16:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_16;
+		break;
+
+	case FIM_CLK_DIV_32:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_32;
+		break;
+
+	case FIM_CLK_DIV_64:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_64;
+		break;
+
+	case FIM_CLK_DIV_128:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_128;
+		break;
+
+	case FIM_CLK_DIV_256:
+		clkd = FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_256;
+		break;
+
+	default:
+		return 1;
+	}
+
+	val = readl(FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+	writel(val | clkd, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	return 0;
+}
+
+int pic_stop_and_reset(int pic_num)
+{
+	unsigned int regval = 0;
+
+	if (pic_is_running(pic_num)) {
+
+		regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+		writel(regval & NS92XX_FIM_GEN_CTRL_STOP_PIC,
+		       FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	}
+
+	if (pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	/* Reset the HWA generial register too */
+	writel(0x00, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	return 0;
+}
+
+int pic_start_at_zero(int pic_num)
+{
+	unsigned int regval;
+
+	regval = readl(FIM_REG_ADDR(pic_num) + NS92XX_FIM_GEN_CTRL_REG);
+	writel(regval | NS92XX_FIM_GEN_CTRL_START_PIC, FIM_REG_ADDR(pic_num) +
+	       NS92XX_FIM_GEN_CTRL_REG);
+
+	/* Check if the PIC is really running */
+	if (!pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int pic_download_firmware(int pic_num, const unsigned char *buffer)
+{
+	int mode;
+	unsigned int status;
+	struct fim_program_t *program = (struct fim_program_t *)buffer;
+	int offset;
+
+	if (!program )
+		return 1;
+
+	if (!(FORMAT_TYPE_VALID(program->format))) {
+		printf("Invalid format type\n");
+		return 1;
+	}
+
+	/* Check if the PIC is running, before starting the firmware update */
+	if (pic_is_running(pic_num)) {
+		return 1;
+	}
+
+	/* Check if the firmware has the correct header */
+	if (!(PROCESSOR_TYPE_VALID(program->processor))) {
+		printf("Invalid processor type. Aborting firmware download.\n");
+		return 1;
+	}
+
+	/* Enable the clock to IO processor and reset the module */
+	status = sys_readl(SYS_CLOCK);
+	sys_writel(status | (1 << (pic_num + FIM0_SHIFT)), SYS_CLOCK);
+	status = sys_readl(SYS_RESET);
+	sys_writel(status & ~(1 << (pic_num + FIM0_SHIFT)), SYS_RESET);
+	sys_writel(status | (1 << (pic_num + FIM0_SHIFT)), SYS_RESET);
+
+	/* Configure the output clock */
+	if(pic_config_output_clock_divisor(pic_num, program)) {
+		printf("Couldn't set the clock output divisor.\n");
+		return 1;
+	}
+
+	switch (program->hw_mode) {
+	case FIM_HW_ASSIST_MODE_NONE:
+		mode = 0x00;
+		break;
+	case FIM_HW_ASSIST_MODE_GENERIC:
+		mode = 0x01;
+		break;
+	case FIM_HW_ASSIST_MODE_CAN:
+		mode = 0x02;
+		break;
+	default:
+		printf("Invalid HWA mode %i\n", program->hw_mode);
+		return 1;
+	}
+
+	status = readl(FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+	writel(mode | status, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_GEN_CONF_REG);
+
+	/* Update the HW assist config registers */
+	for (offset = 0; offset < FIM_NUM_HWA_CONF_REGS; offset++) {
+		status = program->hwa_cfg[offset];
+		writel(status, FIM_HWA_ADDR(pic_num) + NS92XX_FIM_HWA_SIGNAL(offset));
+	}
+
+	/* Check for the maximal supported number of instructions */
+	if (program->length > FIM_NS9215_MAX_INSTRUCTIONS)
+		return 1;
+
+	/* Start programming the PIC (the program size is in 16bit-words) */
+	for (offset = 0; offset < program->length; offset++)
+		writel(program->data[offset] & NS92XX_FIM_INSTRUCTION_MASK,
+		       FIM_INSTR_ADDR(pic_num) + 4*offset);
+
+	return 0;
+}
+
+/* This is for a hard reset of the FIMs */
+void fim_force_hard_reset(int pic)
+{
+	unsigned int status;
+	ulong regval;
+	int cnt;
+
+	status = sys_readl(SYS_RESET);
+	for (cnt = 0; cnt < FIM_MAX_PIC_INDEX; cnt++) {
+
+		if (cnt != pic)
+			continue;
+		
+		sys_writel(status & ~(1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		sys_writel(status | (1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		regval = readl(FIM_IOHUB_ADDR(cnt) + HUB_INT);
+		writel(regval, FIM_IOHUB_ADDR(cnt) + HUB_INT);
+        }
+}
+
+/* Dont use any lock, otherwise it would be required to free the PIC by failures */
+int fim_core_init(int pic, const unsigned char *fwbuf)
+{
+	fim_force_hard_reset(pic);
+
+        /* Stop the PIC before any other action */
+	if(pic_stop_and_reset(pic))
+		goto exit_free_pic;
+
+	if(pic_download_firmware(pic, fwbuf))
+		goto exit_free_pic;
+
+	/* Start the PIC at zero */
+	if(pic_start_at_zero(pic))
+		goto exit_free_pic;
+
+	return 0;
+
+ exit_free_pic:
+	return 1;
+}
+
+
+
+/*
+ * Functions for using the DMA-channels of the FIMs. In some cases it is absolutely
+ * required to use DMA for exchanging data with the FIMs (like in the case of the MMC)
+ * for this reason we need the support.
+ */
+
+
+int fim_init_rxdma(int pic)
+{
+	/* DMA-buffer descriptors */
+	static uchar rxbuf[FIM_TOTAL_BUFFERS][FIM_BUFFER_SIZE];
+	volatile struct iohub_dma_desc_t *picbuf, *lstbuf;
+	volatile struct iohub_dma_fifo_t *picfifo;
+	int cnt;
+
+	/* Init the last buffer pointer too */
+	picbuf = &fim_rxdma_buffers[pic * FIM_DMA_BUFFERS];
+
+	picfifo = &fim_rxdma_fifos[pic];
+	picfifo->first = (struct iohub_dma_desc_t *)picbuf;
+	picfifo->dma_last = (struct iohub_dma_desc_t *)picbuf;
+	picfifo->last = (struct iohub_dma_desc_t *)(picbuf + FIM_DMA_BUFFERS - 1);
+
+	printk_debug("DMA buffers for the FIM %i [%p to %p]\n", pic,
+		     picfifo->first, picfifo->last);
+
+	for (cnt = 0; cnt < FIM_DMA_BUFFERS; cnt++, picbuf++) {
+		picbuf->src = (unsigned int)rxbuf[cnt];
+		picbuf->length = FIM_BUFFER_SIZE;
+		picbuf->control = IOHUB_DMA_DESC_CTRL_INT;
+		printk_debug("  %2i. %p : 0x%08x | %u Bytes\n", cnt+1, picbuf,
+			     picbuf->src, picbuf->length);
+
+		lstbuf = picbuf;
+	}
+
+	picbuf = &fim_rxdma_buffers[pic * FIM_DMA_BUFFERS];
+	lstbuf->control = IOHUB_DMA_DESC_CTRL_LAST | IOHUB_DMA_DESC_CTRL_INT |
+		IOHUB_DMA_DESC_CTRL_WRAP;
+
+	writel(0x0, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+
+	writel((unsigned long)picbuf, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_DESCR);
+
+	writel(HUB_RX_INT_NCIE | HUB_RX_INT_NRIE | HUB_RX_INT_ECIE,
+		FIM_IOHUB_ADDR(pic) + HUB_RX_INT);
+
+	writel(HUB_DMA_RX_CTRL_CE, FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+	return 0;
+}
+
+/* Send a buffer by using the DMA-channel */
+int fim_send_buffer(int pic, struct fim_buffer_t *buffer)
+{
+	static volatile struct iohub_dma_desc_t fims_txdma_bufdesc[2];
+	volatile struct iohub_dma_desc_t *picbuf;
+
+	/* @TODO: Sanity check for the passed PIC number! */
+	picbuf = &fims_txdma_bufdesc[pic];
+
+	/* Configure the buffer first */
+	picbuf->src = (unsigned int)buffer->data;
+	picbuf->length = buffer->length;
+	picbuf->control = IOHUB_DMA_DESC_CTRL_LAST | IOHUB_DMA_DESC_CTRL_FULL |
+		IOHUB_DMA_DESC_CTRL_INT | IOHUB_DMA_DESC_CTRL_WRAP;
+
+	/* Configure the TX DMA-channel */
+	writel(0x0, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_CTRL);
+
+	flush_cache_all();
+	writel((unsigned long)picbuf, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_DESCR);
+
+	writel(HUB_TX_INT_NCIE | HUB_TX_INT_NRIE | HUB_TX_INT_ECIE,
+		FIM_IOHUB_ADDR(pic) + HUB_TX_INT);
+
+	writel(HUB_DMA_TX_CTRL_CE, FIM_IOHUB_ADDR(pic) + HUB_DMA_TX_CTRL);
+
+	return 0;
+}
+
+/* Wait until the DMA-buffer was closed by the FIM */
+int fim_wait_txdma(int pic)
+{
+	unsigned long ifs;
+	unsigned long timeout = 0xfffff;
+
+	do {
+		timeout--;
+		ifs = readl(FIM_IOHUB_ADDR(pic) + HUB_INT);
+	} while (timeout && !(ifs & HUB_INT_TX_NCIP));
+
+	if (timeout)
+		writel(ifs | HUB_INT_TX_NCIP, FIM_IOHUB_ADDR(pic) + HUB_INT);
+
+	return (timeout) ? (0) : (-1);
+}
+
+/* The timeout is in microseconds */
+struct fim_buffer_t *fim_wait_rxdma(int pic, uint timeout)
+{
+	struct fim_buffer_t *retval;
+	struct iohub_dma_desc_t *picbuf;
+	unsigned long ifs;
+	volatile static struct fim_buffer_t rxdma[FIM_TOTAL_NUMBER];
+	volatile struct iohub_dma_fifo_t *picfifo;
+	int cnt;
+
+	/* First check if there is an already fulled DMA-buffer */
+	picfifo = &fim_rxdma_fifos[pic];
+
+	do {
+		picbuf = picfifo->dma_last;
+		for (cnt = 0; cnt < FIM_DMA_BUFFERS; cnt++, picbuf++) {
+
+			/* Check that the pointer is correct */
+			if (picbuf > picfifo->last)
+				picbuf = picfifo->first;
+
+			invalidate_cache_all();
+			if (picbuf->control & IOHUB_DMA_DESC_CTRL_FULL) {
+
+				rxdma[pic].data = (uchar *)picbuf->src;
+				rxdma[pic].length = picbuf->length;
+				retval = (struct fim_buffer_t *)&rxdma[pic];
+				picbuf->control &= ~(IOHUB_DMA_DESC_CTRL_FULL |
+						     IOHUB_DMA_DESC_CTRL_LAST);
+				picbuf->length = FIM_BUFFER_SIZE;
+
+				/*
+				 * Update the last pointer. If we overflow the DMA-buffer,
+				 * then the above sanity check will correct the pointer
+				 */
+				picfifo->dma_last = picbuf + 1;
+				if (picfifo->dma_last > picfifo->last)
+					picfifo->dma_last = picfifo->first;
+
+				ifs = readl(FIM_IOHUB_ADDR(pic) + HUB_DMA_RX_CTRL);
+				printk_debug("  ==> RX-DMA %p (%i) | Last is now %p\n",
+					     picbuf, ifs & 0x3ff, picfifo->dma_last);
+				
+				return retval;
+			}
+		}
+
+		udelay(1);
+		timeout--;
+	} while (timeout);
+
+	return NULL;
+}
+
+/*
+ * There seems to be a problem when we try to boot the Linux-kernel with
+ * a running FIM. The failure is reproducible by resetting the target console
+ * stopped and then started with a command).
+ * At this moment let us reset the FIMs for being able to boot the system, but
+ * in the future we will need a better workaround.
+ * Luis Galdos
+ */
+void shutdown_fims(void)
+{
+        unsigned int status;
+	ulong regval;
+        int cnt;
+
+        status = sys_readl(SYS_RESET);
+        for (cnt = 0; cnt < FIM_MAX_PIC_INDEX; cnt++) {
+                sys_writel(status & ~(1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+                sys_writel(status | (1 << (cnt + FIM0_SHIFT)), SYS_RESET);
+		regval = readl(FIM_IOHUB_ADDR(cnt) + HUB_INT);
+		writel(regval, FIM_IOHUB_ADDR(cnt) + HUB_INT);
+        }
+}
diff --git a/cpu/arm926ejs/ns921x/fim_reg.h b/cpu/arm926ejs/ns921x/fim_reg.h
new file mode 100644
index 0000000..b993d74
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_reg.h
@@ -0,0 +1,283 @@
+/*
+ * include/asm-arm/arch-ns9xxx/fim_reg.h
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ *  !Revision:   $Revision$
+ *  !Author:     Silvano Najera, Luis Galdos
+ *  !Descr:      
+ *  !References:
+ */
+
+
+#ifndef __FIM_REG_H
+#define __FIM_REG_H
+
+
+/* @FIXME: We must use the IOHUB base address*/
+#define NS92XX_FIM_IOHUB_BASE_PA		(0x90000000)
+#define NS92XX_FIM_IOHUB_SIZE			(0x1000)
+#define NS92XX_FIM_IOHUB_OFFSET			(0x8000)
+
+
+/* Base addresses of all memory regions */
+#define NS92XX_FIM_REG_BASE_PA			(0x90001000)
+#define NS92XX_FIM_REG_OFFSET			(0x8000)
+#define NS92XX_FIM_REG_SIZE                     (0x3000)
+
+#define NS92XX_FIM_INSTR_BASE_PA		(0x90004000)
+#define NS92XX_FIM_INSTR_OFFSET			(0x8000)
+#define NS92XX_FIM_INSTR_SIZE                   (0x5000)
+
+#define NS92XX_FIM_HWA_BASE_PA			(0x90068000)
+#define NS92XX_FIM_HWA_OFFSET			(0x8000)
+#define NS92XX_FIM_HWA_SIZE                     (0x8000)
+
+#define NS92XX_FIM_IO_SPACE_BASE_PA		(0x90078000)
+#define NS92XX_FIM_IO_SPACE_OFFSET		(0x8000)
+#define NS92XX_FIM_IO_SPACE_SIZE                (0x8000)
+
+
+/* FIM register offsets */
+#define NS92XX_FIM_GEN_CTRL_REG			(0x00)
+	
+#define NS92XX_FIM_CTRL0_REG			(0x10)
+#define NS92XX_FIM_CTRL1_REG			(0x14)
+#define NS92XX_FIM_CTRL2_REG			(0x18)
+#define NS92XX_FIM_CTRL3_REG			(0x1c)
+#define NS92XX_FIM_CTRL4_REG			(0x20)
+#define NS92XX_FIM_CTRL5_REG			(0x24)
+#define NS92XX_FIM_CTRL6_REG			(0x28)
+#define NS92XX_FIM_CTRL7_REG			(0x2c)
+#define NS92XX_FIM_CTRL8_REG			(0x30)
+#define NS92XX_FIM_CTRL9_REG			(0x34)
+#define NS92XX_FIM_CTRL10_REG			(0x38)
+#define NS92XX_FIM_CTRL11_REG			(0x3c)
+#define NS92XX_FIM_CTRL12_REG			(0x40)
+#define NS92XX_FIM_CTRL13_REG			(0x44)
+#define NS92XX_FIM_CTRL14_REG			(0x48)
+#define NS92XX_FIM_CTRL15_REG			(0x4c)
+#define NS92XX_FIM_CTRL_REG(i)			(NS92XX_FIM_CTRL0_REG + 4*i)
+#define NS92XX_FIM_CTRL_REG_CHECK(i)		((i<0 || i>15)?1:0)
+
+
+/*
+ * According to the HW-reference manual of the FIMs (page 16)
+ * The macros have as offset the address 0x90001000 (NS92XX_FIM_REG_BASE_PA)
+ */
+#define NS92XX_FIM_STAT0_REG			(0x50)
+#define NS92XX_FIM_STAT1_REG			(0x54)
+#define NS92XX_FIM_STAT2_REG			(0x58)
+#define NS92XX_FIM_STAT3_REG			(0x5c)
+#define NS92XX_FIM_STAT4_REG			(0x60)
+#define NS92XX_FIM_STAT5_REG			(0x64)
+#define NS92XX_FIM_STAT6_REG			(0x68)
+#define NS92XX_FIM_STAT7_REG			(0x6c)
+#define NS92XX_FIM_STAT8_REG			(0x70)
+#define NS92XX_FIM_STAT9_REG			(0x74)
+#define NS92XX_FIM_STAT10_REG			(0x78)
+#define NS92XX_FIM_STAT11_REG			(0x7c)
+#define NS92XX_FIM_STAT12_REG			(0x80)
+#define NS92XX_FIM_STAT13_REG			(0x84)
+#define NS92XX_FIM_STAT14_REG			(0x88)
+#define NS92XX_FIM_STAT_REG(i)			(NS92XX_FIM_STAT0_REG + 4*i)
+#define NS92XX_FIM_STAT_REG_CHECK(i)		((i<0 || i>14)?1:0)
+
+
+/*
+ * According to the HW-reference manual of the FIMs (page 16)
+ * The macros have as offset the address 0x90001000 (NS92XX_FIM_REG_BASE_PA)
+ */
+#define NS92XX_FIM_EXP0_REG			(0x50)
+#define NS92XX_FIM_EXP1_REG			(0x54)
+#define NS92XX_FIM_EXP2_REG			(0x58)
+#define NS92XX_FIM_EXP3_REG			(0x5c)
+#define NS92XX_FIM_EXP4_REG			(0x60)
+#define NS92XX_FIM_EXP5_REG			(0x64)
+#define NS92XX_FIM_EXP6_REG			(0x68)
+#define NS92XX_FIM_EXP7_REG			(0x6c)
+#define NS92XX_FIM_EXP8_REG			(0x70)
+#define NS92XX_FIM_EXP9_REG			(0x74)
+#define NS92XX_FIM_EXP10_REG			(0x78)
+#define NS92XX_FIM_EXP11_REG			(0x7c)
+#define NS92XX_FIM_EXP12_REG			(0x80)
+#define NS92XX_FIM_EXP13_REG			(0x84)
+#define NS92XX_FIM_EXP14_REG			(0x88)
+#define NS92XX_FIM_EXP15_REG			(0x8c)
+#define NS92XX_FIM_EXP_REG(i)			(NS92XX_FIM_EXP0_REG + 4*i)
+#define NS92XX_FIM_EXP_REG_CHECK(i)		((i<0 || i>15)?1:0)
+
+
+/* FIM intruction memory offset */
+#define NS92XX_FIM_INSTRUCTION_ADDR		(0x00)
+
+/* Hardware assist register offsets */
+#define NS92XX_FIM_HWA_GEN_CONF_REG		(0x00)
+
+#define NS92XX_FIM_HWA_SIGNAL0			(0x04)
+#define NS92XX_FIM_HWA_SIGNAL1			(0x08)
+#define NS92XX_FIM_HWA_SIGNAL2			(0x0c)
+#define NS92XX_FIM_HWA_SIGNAL3			(0x10)
+#define NS92XX_FIM_HWA_SIGNAL4			(0x14)
+#define NS92XX_FIM_HWA_SIGNAL5			(0x18)
+#define NS92XX_FIM_HWA_SIGNAL6			(0x1c)
+#define NS92XX_FIM_HWA_SIGNAL7			(0x20)
+#define NS92XX_FIM_HWA_CONTROL0			(0x24)
+#define NS92XX_FIM_HWA_CONTROL1			(0x28)
+#define NS92XX_FIM_HWA_CONTROL2			(0x2c)
+#define NS92XX_FIM_HWA_CONTROL3			(0x30)
+#define NS92XX_FIM_HWA_16_BIT_BUS		(0x34)
+#define NS92XX_FIM_HWA_32_BIT_BUS		(0x38)
+#define NS92XX_FIM_HWA_SIGNAL(index)		(NS92XX_FIM_HWA_GEN_CONF_REG + NS92XX_FIM_HWA_SIGNAL0 + 4*index)
+
+
+/* Fim register bit fields */
+#define NS92XX_FIM_GEN_CTRL_PROGMEM		(0x80000000)
+#define NS92XX_FIM_GEN_CTRL_RESERVED1		(0x7fff0000)
+#define NS92XX_FIM_GEN_CTRL_INTACKWR		(0x00008000)
+#define NS92XX_FIM_GEN_CTRL_INTTOPIC		(0x00007f00)
+#define NS92XX_FIM_GEN_CTRL_INTACKRD		(0x00000080)
+#define NS92XX_FIM_GEN_CTRL_INTFROMPIC		(0x0000007f)
+
+/* Mask used for the interrupt codes from the ARM to the PICs */
+#define NS92XX_FIM_INT_MASK(code)		(code<<8)
+
+
+/* FIM intructions bit fields*/
+#define NS92XX_FIM_INSTRUCTION_MASK		(0x00003fff)
+
+/* Hardware assist register bit fields */
+#define NS92XX_FIM_HWA_GEN_CONF_RESERVED1	(0xffffffe0)
+#define NS92XX_FIM_HWA_GEN_CONF_CLKSEL		(0x0000001c)
+#define NS92XX_FIM_HWA_GEN_CONF_ENABLE		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL0_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL0_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL0_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL0_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL0_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL0_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL1_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL1_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL1_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL1_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL1_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL1_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL2_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL2_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL2_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL2_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL2_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL2_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL3_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL3_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL3_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL3_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL3_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL3_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL4_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL4_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL4_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL4_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL4_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL4_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL5_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL5_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL5_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL5_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL5_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL5_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL6_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL6_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL6_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL6_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL6_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL6_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_SIGNAL7_RESERVED		(0xfffffc00)
+#define NS92XX_FIM_HWA_SIGNAL7_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_SIGNAL7_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_SIGNAL7_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_SIGNAL7_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_SIGNAL7_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL0_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL0_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL0_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL0_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL0_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL0_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL1_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL1_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL1_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL1_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL1_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL1_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL2_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL2_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL2_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL2_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL2_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL2_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_CONTROL3_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_CONTROL3_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_CONTROL3_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_CONTROL3_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_CONTROL3_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_CONTROL3_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_16_BIT_BUS_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_16_BIT_BUS_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_16_BIT_BUS_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_16_BIT_BUS_CLKS		(0x00000003)
+
+#define NS92XX_FIM_HWA_32_BIT_BUS_RESERVED	(0xfffffc00)
+#define NS92XX_FIM_HWA_32_BIT_BUS_OMODE		(0x00000300)
+#define NS92XX_FIM_HWA_32_BIT_BUS_IMODE		(0x000000e0)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CLKE		(0x00000010)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CNTRL		(0x0000000c)
+#define NS92XX_FIM_HWA_32_BIT_BUS_CLKS		(0x00000003)
+
+
+
+/* H/W Assist General Configuration Register Codes */
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_2	(0)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_4	(1<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_8	(2<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_16	(3<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_32	(4<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_64	(5<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_128	(6<<2)
+#define FIM_HWA_GEN_CFG_CLKSEL_DIVIDE_BY_256	(7<<2)
+
+#define FIM_REG_ADDR(x) (NS92XX_FIM_REG_BASE_PA + (x * NS92XX_FIM_REG_OFFSET)) 
+#define FIM_INSTR_ADDR(x) (NS92XX_FIM_INSTR_BASE_PA + (x * NS92XX_FIM_INSTR_OFFSET))
+#define FIM_HWA_ADDR(x) (NS92XX_FIM_HWA_BASE_PA + (x * NS92XX_FIM_HWA_OFFSET))
+#define FIM_IOHUB_ADDR(x) (NS92XX_FIM_IOHUB_BASE_PA + (x * NS92XX_FIM_IOHUB_OFFSET))
+
+
+#endif	/* __FIM_REG_H */
+
+
+
+
+
+
+
+
diff --git a/cpu/arm926ejs/ns921x/fim_sdio.c b/cpu/arm926ejs/ns921x/fim_sdio.c
new file mode 100644
index 0000000..18d5b18
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio.c
@@ -0,0 +1,1071 @@
+/* -*- linux-c -*-
+ *
+ * cpu/arm926ejs/ns921x/fims/fim_sdio.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision: 1.1.1.1 $
+ * !Author:     Luis Galdos
+ * !References: Based on the MMC-driver of Kyle Harris (kharris@nexus-tech.net)
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include <configs/userconfig.h>
+
+#if defined(CONFIG_NS921X_FIM_SDIO)
+
+/* @XXX: This is not the correct place for this macro, need to move to another place */
+#define CONFIG_SUPPORT_MMC_PLUS
+
+#include <asm/arch/ns921x_sys.h>
+#include <asm/arch/ns921x_hub.h>
+#include <asm/arch/ns921x_gpio.h>
+#include <asm/arch/io.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/ns921x_fim.h>
+#include <asm/arch/ns921x_dma.h>
+
+#include <mmc.h>
+#include <asm/errno.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/protocol.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <part.h>
+
+#include "fim_reg.h"
+#include "fim_sdio.h"
+
+#define AUTODETECTION	0
+#define SD_CARD		1
+#define MMC_CARD	2
+
+/* When reading data, print a dot for each 64K read */
+#define BYTES_PROGRESS_DOT	16384
+
+/* Include only the needed firmware header */
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  include "fim_sdio0.h"
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  include "fim_sdio1.h"
+# else
+#  error "FIM number is not valid!"
+# endif
+#elif defined(CONFIG_CME9210)
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  include "fim_sdio0_9210.h"
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  include "fim_sdio1_9210.h"
+# else
+#  error "FIM number is not valid!"
+# endif
+#endif
+
+//#define FIM_SDIO_DEBUG
+# define printk_info(fmt,args...)                   printf(fmt, ##args)
+# define printk_err(fmt,args...)                   printf("[ ERROR ] " fmt, ##args)
+
+#if defined(FIM_SDIO_DEBUG)
+# define printk_debug(fmt,args...)                   printf(fmt, ##args)
+#else
+# define printk_debug(fmt, args...)                  do { } while (0);
+#endif
+
+/* Values for the block read state machine */
+enum fim_blkrd_state {
+	BLKRD_STATE_IDLE		= 0,
+	BLKRD_STATE_WAIT_ACK		= 1, /* Waiting for the block read ACK */
+	BLKRD_STATE_WAIT_DATA		= 2, /* Waiting for the block read data */
+	BLKRD_STATE_WAIT_CRC		= 3, /* Waiting for the CRC */
+	BLKRD_STATE_HAVE_DATA		= 4, /* Have block read data with the CRC */
+	BLKRD_STATE_TIMEOUTED		= 5, /* Timeout response from the PIC */
+	BLKRD_STATE_CRC_ERR		= 6, /* Compared CRC (PIC and card) differs */
+};
+
+/* Values for the command state machine */
+enum fim_cmd_state {
+	CMD_STATE_IDLE			= 0,
+	CMD_STATE_WAIT_ACK		= 1, /* Waiting for the response ACK */
+	CMD_STATE_WAIT_DATA		= 2, /* Waiting for the response data */
+	CMD_STATE_HAVE_RSP		= 3, /* Have response data */
+	CMD_STATE_TIMEOUTED		= 4, /* Timeout response from the PIC */
+	CMD_STATE_CRC_ERR		= 5, /* Compared CRC (PIC and card) differs */
+};
+
+/*
+ * Response receive structure from the Card
+ * resp  : Card response, with a length of 5 or 17 as appropriate
+ * stat  : Opcode of the executed command
+ * crc   : CRC
+ */
+struct fim_sd_rx_resp_t {
+        unsigned char stat;
+        unsigned char resp[FIM_SD_MAX_RESP_LENGTH];
+        unsigned char crc;
+}__attribute__((__packed__));
+
+/*
+ * Transfer command structure for the card
+ * opctl : Control byte for the PIC
+ * blksz : Block size
+ * cmd   : Command to send to the card
+ */
+struct fim_sd_tx_cmd_t {
+	unsigned char opctl;
+	unsigned char blksz_msb;
+        unsigned char blksz_lsb;
+        unsigned char cmd[FIM_SD_TX_CMD_LEN];
+}__attribute__((__packed__));
+
+struct fim_sdio_t {
+	enum fim_cmd_state cmd_state;
+	enum fim_blkrd_state blkrd_state;
+	struct mmc_command *mmc_cmd;
+	int trans_blocks;
+	int trans_sg;
+	int reg;
+
+	int waiting_process_next;
+	int bus_width;
+	struct mmc_card mmc_card;
+
+	uint card_size;
+	uint blk_size;
+	uchar *blkrd_dst;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct fim_sdio_t fim_sdio;
+struct fim_sdio_t *port = &fim_sdio;
+
+/* FIM SD control registers */
+#define FIM_SD_REG_CLOCK_DIVISOR                0
+#define FIM_SD_REG_INTERRUPT                    1
+#define FIM_SDIO_MAIN_REG			5
+#define FIM_SDIO_MAIN_START			(1 << 0)
+
+#if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+static int pic_num = 0;
+extern const unsigned char fim_sdio_firmware0[];
+#define FIM_SDIO_FIRMWARE			(fim_sdio_firmware0)
+#elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+static int pic_num = 1;
+extern const unsigned char fim_sdio_firmware1[];
+#define FIM_SDIO_FIRMWARE			(fim_sdio_firmware1)
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_FAT)
+extern int fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+#endif
+static block_dev_desc_t mmc_dev;
+static uint  card;
+static unsigned char sdhc = 0;
+
+/*
+ * This function is called for obtaining the device to a corresponding device number
+ * (U-Boot) fatls mmc 1:1 /
+ */
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/* Internal function prototypes */
+static void *fim_sd_dma_to_sg(struct fim_sdio_t *port, struct mmc_data *data,
+			      unsigned char *dma_buf, int dma_len);
+
+inline static void fim_sd_parse_resp(struct mmc_command *cmd,
+				     struct fim_sd_rx_resp_t *resp)
+{
+	unsigned char *ptr;
+	ptr = (unsigned char *)cmd->resp;
+	if (cmd->flags & MMC_RSP_136) {
+		*ptr++ = resp->resp[3];
+		*ptr++ = resp->resp[2];
+		*ptr++ = resp->resp[1];
+		*ptr++ = resp->resp[0];
+		*ptr++ = resp->resp[7];
+		*ptr++ = resp->resp[6];
+		*ptr++ = resp->resp[5];
+		*ptr++ = resp->resp[4];
+		*ptr++ = resp->resp[11];
+		*ptr++ = resp->resp[10];
+		*ptr++ = resp->resp[9];
+		*ptr++ = resp->resp[8];
+		*ptr++ = resp->resp[15];
+		*ptr++ = resp->resp[14];
+		*ptr++ = resp->resp[13];
+		*ptr++ = resp->resp[12];
+	} else {
+		*ptr++ = resp->resp[3];
+		*ptr++ = resp->resp[2];
+		*ptr++ = resp->resp[1];
+		*ptr++ = resp->resp[0];
+		*ptr++ = resp->resp[4];
+		*ptr++ = resp->stat;
+	}
+}
+
+/*
+ * This function checks the CRC by block read transfer
+ * The information about the length and content of the CRC was obtained
+ * from the firmware-source code (sd.asm)
+ */
+inline static int fim_sd_check_blkrd_crc(struct fim_sdio_t *port, unsigned char *data,
+                                         int length)
+{
+        int crc_len;
+        unsigned char *pic_crc;
+
+        /*
+         * The CRC length depends on the bus width (see sd.asm)
+         * No CRC enabled : One byte (0x00)
+         * One bit bus    : Four bytes
+         * Four bit bus   : Eight bytes
+         */
+        if (!(port->mmc_cmd->flags & MMC_RSP_CRC)) {
+                crc_len = 1;
+                pic_crc = data;
+        } else if (port->bus_width == MMC_BUS_WIDTH_1) {
+                crc_len = 4;
+                pic_crc = data + 2;
+        } else {
+                crc_len = 16;
+                pic_crc = data + 8;
+        }
+
+        if (crc_len != length) {
+                printk_err("Unexpected CRC length %i (expected %i)\n",
+                       length, crc_len);
+                return -EINVAL;
+        }
+
+
+        /*
+         * Code for forcing a CRC-error and the behavior of the MMC-layer
+         * crc_error = 10 : Error reading the partition table
+         * crc_error = 40 : Error by a block read transfer
+         */
+#ifdef FIM_SD_FORCE_CRC
+        static int crc_error = 0;
+        if (crc_error == 40) {
+                crc_error++;
+                return 1;
+        } else
+                crc_error++;
+#endif
+
+        /* If the CRC is disabled, the PIC only appended a dummy Byte */
+        if (crc_len == 1)
+                return 0;
+
+        return memcmp(data, pic_crc, crc_len >> 1);
+}
+
+static void fim_sd_process_next(struct fim_sdio_t *port)
+{
+	struct mmc_command *cmd;
+
+	/* mmc0: req done (CMD41): 0: 00ff8000 00003fff 00000000 00000000 */
+	cmd = port->mmc_cmd;
+	printk_debug("mmc0: req done (CMD%u): %d: %08x %08x %08x %08x\n",
+		     cmd->opcode, cmd->error,
+		     cmd->resp[0], cmd->resp[1],
+		     cmd->resp[2], cmd->resp[3]);
+
+	port->waiting_process_next = 0;
+}
+
+/*
+ * Called when a receive DMA-buffer was closed.
+ * Unfortunately the data received from the PIC has different formats. Sometimes it
+ * contains a response, sometimes data of a block read request and sometimes the CRC
+ * of the read data. In the case of a read transfer it is really amazing, then
+ * the transfer consists in four DMA-buffers.
+ */
+static void fim_sd_rx_isr(/* struct fim_driver *driver, int irq, */
+			  struct fim_buffer_t *pdata)
+{
+	/* struct fim_sdio_t *port; */
+	struct mmc_command *mmc_cmd;
+	struct fim_sd_rx_resp_t *resp;
+	int len, crc_len;
+	unsigned char *crc_ptr;
+	int is_ack;
+
+	/* Get the correct port from the FIM-driver structure */
+	len = pdata->length;
+	/* port = (struct fim_sdio_t *)driver->driver_data; */
+	/* spin_lock(&port->mmc_lock); */
+
+	/*
+	 * The timeout function can set the command structure to NULL, for this reason
+	 * check here is we can handle the response correctly
+	 */
+	if ((mmc_cmd = port->mmc_cmd) == NULL) {
+		printk_err("Timeouted command response?\n");
+		/* goto exit_unlock; */
+	}
+
+	/*
+	 * Check the current state of the command and update it if required
+	 * IMPORTANT: The buffer can contain response data or the data from a block
+	 * read too, for this reason was implemented the state machine
+	 */
+	resp = (struct fim_sd_rx_resp_t *)pdata->data;
+	is_ack = (pdata->length == 1) ? 1 : 0;
+
+	printk_debug("CMD%i | PIC stat %x | CMD stat %i | BLKRD stat %i | Len %i\n",
+	       mmc_cmd->opcode, resp->stat, port->cmd_state,
+	       port->blkrd_state, pdata->length);
+
+	/*
+	 * By the ACKs the PIC will NOT send a timeout. Timeouts are only
+	 * set by the response and and block read data
+	 */
+	if (is_ack && resp->stat & FIM_SD_RX_TIMEOUT) {
+		mmc_cmd->error = -ETIMEDOUT;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+
+		/* Check the conditions for the BLOCK READ state machine */
+	} else if (port->blkrd_state == BLKRD_STATE_WAIT_ACK && is_ack &&
+		   resp->stat & FIM_SD_RX_BLKRD) {
+		port->blkrd_state = BLKRD_STATE_WAIT_DATA;
+
+		/* Check if the block read data has arrived */
+	} else if (port->blkrd_state == BLKRD_STATE_WAIT_DATA && !is_ack) {
+		crc_len = len - mmc_cmd->data->blksz;
+		crc_ptr = pdata->data + mmc_cmd->data->blksz;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+
+		if (fim_sd_check_blkrd_crc(port, crc_ptr, crc_len)) {
+			mmc_cmd->error = -EILSEQ;
+		} else {
+			/*
+			 * @UBOOT: Only pass the number of data bytes to the copy
+			 * function, otherwise the CRC will be copied too!
+			 */
+			fim_sd_dma_to_sg(port, mmc_cmd->data,
+					 pdata->data, pdata->length - crc_len);
+ 		}
+
+		/* Check if we have a multiple transfer read */
+		port->trans_blocks -= 1;
+		if (port->trans_blocks > 0)
+			port->blkrd_state = BLKRD_STATE_WAIT_DATA;
+
+		/* Check the conditions for the COMMAND state machine */
+	} else if (is_ack && port->cmd_state == CMD_STATE_WAIT_ACK &&
+		   resp->stat & FIM_SD_RX_RSP) {
+		port->cmd_state = CMD_STATE_WAIT_DATA;
+
+	} else if (!is_ack && port->cmd_state == CMD_STATE_WAIT_DATA) {
+		fim_sd_parse_resp(mmc_cmd, resp);
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+
+		/* Check for unexpected acks or opcodes */
+	} else {
+
+		/* @FIXME: Need a correct errror handling for this condition */
+		printk_err("Unexpected RX stat (CMD%i | PIC stat %x | Length %i)\n",
+		       mmc_cmd->opcode, resp->stat, pdata->length);
+	}
+
+	/*
+	 * By errors set the two states machines to the end position for sending
+	 * the error to the MMC-layer
+	 */
+	if (mmc_cmd->error) {
+		port->cmd_state = CMD_STATE_HAVE_RSP;
+		port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+	}
+
+	/*
+	 * Now evaluate if need to wait for another RX-interrupt or
+	 * can send the request done to the MMC-layer
+	 */
+	if (port->cmd_state == CMD_STATE_HAVE_RSP &&
+	    port->blkrd_state == BLKRD_STATE_HAVE_DATA)
+		fim_sd_process_next(port);
+
+/*  exit_unlock: */
+	/* spin_unlock(&port->mmc_lock); */
+}
+
+/*
+ * Function called when RD data has arrived
+ * Return value is the pointer of the last byte copied to the scatterlist, it can
+ * be used for appending more data (e.g. in multiple block read transfers)
+ */
+static void *fim_sd_dma_to_sg(struct fim_sdio_t *port, struct mmc_data *data,
+			      unsigned char *dma_buf, int dma_len)
+{
+/*         unsigned int len, cnt, process; */
+/*         struct scatterlist *sg; */
+/*         char *sg_buf; */
+
+/*         sg = data->sg; */
+/*         len = data->sg_len; */
+
+/*         /\* Need a correct error handling *\/ */
+/* #if !defined(FIM_SD_MULTI_BLOCK) */
+/*         if (len > 1) { */
+/*                 printk_err("The FIM-SD host driver only supports single block\n"); */
+/*                 len = 1; */
+/*         } */
+/* #endif */
+
+/*         /\* This loop was tested only with single block transfers *\/ */
+/*         sg_buf = NULL; */
+/*         for (cnt = port->trans_sg; cnt < len && dma_len > 0; cnt++) { */
+/*                 process = dma_len > sg[cnt].length ? sg[cnt].length : dma_len; */
+/*                 sg_buf = sg_virt(&sg[cnt]); */
+/*                 memcpy(sg_buf, dma_buf, process); */
+/*                 dma_buf += process; */
+/*                 dma_len -= process; */
+/*                 data->bytes_xfered += process; */
+/*                 sg_buf += process; */
+/*                 port->trans_sg += 1; */
+/*         } */
+
+/*         return sg_buf; */
+
+	memcpy(port->blkrd_dst, dma_buf, dma_len);
+
+	return NULL;
+}
+
+static struct fim_buffer_t *fim_sd_alloc_cmd(void)
+{
+	static struct fim_sd_tx_cmd_t fim_cmd;
+	static struct fim_buffer_t fim_buf = {
+		.length = sizeof(struct fim_sd_tx_cmd_t),
+		.data = (uchar *)&fim_cmd,
+		.sent = 0,
+		.private = NULL,
+	};
+
+	return &fim_buf;
+}
+
+/* Send a buffer over the FIM-API */
+static int fim_sd_send_buffer(struct fim_buffer_t *buf)
+{
+	int retval;
+
+	if (!buf)
+		return -EINVAL;
+
+	if ((retval = fim_send_buffer(pic_num, buf)))
+		printk_err("FIM send buffer request failed.\n");
+
+	return retval;
+}
+
+/* This function will send the command to the PIC using the TX-DMA buffers */
+static int fim_sd_send_command(struct mmc_command *cmd)
+{
+	struct mmc_data *data;
+	struct fim_buffer_t *buf;
+	struct fim_sd_tx_cmd_t *txcmd;
+	unsigned int block_length, blocks;
+	int retval, length;
+
+	/* @TODO: Send an error response to the MMC-core */
+	buf = fim_sd_alloc_cmd();
+
+	/* Use the buffer data for the TX-command */
+	txcmd = (struct fim_sd_tx_cmd_t *)buf->data;
+	txcmd->opctl = 0;
+
+	/*
+	 * Set the internal flags for the next response sequences
+	 * Assume that we will wait for a command response (not block read).
+	 * By block reads the flag will be modified inside the if-condition
+	 */
+	port->cmd_state = CMD_STATE_WAIT_ACK;
+	port->blkrd_state = BLKRD_STATE_HAVE_DATA;
+	if ((data = cmd->data) != NULL) {
+		block_length = data->blksz;
+		blocks = data->blocks;
+
+#if !defined(FIM_SD_MULTI_BLOCK)
+		if (blocks != 1) {
+			printf("Only supports single block transfer (%i)\n", blocks);
+			cmd->error = -EILSEQ;
+			fim_sd_process_next(port);
+			return -EILSEQ;
+		}
+#endif
+
+		printk_debug("Transfer of %i blocks (len %i)\n", blocks, block_length);
+
+/* 		/\* Reset the scatter list position *\/ */
+/* 		port->trans_sg = 0; */
+		port->trans_blocks = blocks;
+		fim_set_ctrl_reg(pic_num, 2, blocks);
+
+		/* Check if the transfer request is for reading or writing */
+		if (cmd->data->flags & MMC_DATA_READ) {
+			txcmd->opctl |= SDIO_FIFO_TX_BLKRD;
+			port->blkrd_state = BLKRD_STATE_WAIT_ACK;
+		} else
+			txcmd->opctl |= SDIO_FIFO_TX_BLKWR;
+	} else {
+		block_length = 0;
+		blocks = 0;
+	}
+
+	/* Set the correct expected response length */
+	if (cmd->flags & MMC_RSP_136)
+		txcmd->opctl |= SDIO_FIFO_TX_136RSP;
+	else
+		txcmd->opctl |= SDIO_FIFO_TX_48RSP;
+
+	/* Set the correct CRC configuration */
+	if (!(cmd->flags & MMC_RSP_CRC)) {
+		printk_debug("CRC is disabled\n");
+		txcmd->opctl |= SDIO_FIFO_TX_DISCRC;
+	}
+
+	/* Set the correct bus width for the FIM transfer */
+	if (port->bus_width == MMC_BUS_WIDTH_4) {
+		printk_debug("Bus width has four bits\n");
+		txcmd->opctl |= SDIO_FIFO_TX_BW4;
+	}
+
+	txcmd->blksz_msb = (block_length >> 8);
+	txcmd->blksz_lsb =  block_length;
+	txcmd->cmd[0] = SDIO_HOST_TX_HDR | (cmd->opcode & SDIO_HOST_CMD_MASK);
+	txcmd->cmd[1] = cmd->arg >> 24;
+	txcmd->cmd[2] = cmd->arg >> 16;
+	txcmd->cmd[3] = cmd->arg >> 8;
+	txcmd->cmd[4] = cmd->arg;
+
+	/*
+	 * Store the private data for the callback function
+	 * If an error ocurrs when sending the buffer, the timeout function will
+	 * send the error to the MMC-layer
+	 */
+/* 	port->buf = buf; */
+	port->mmc_cmd = cmd;
+/* 	buf->private = port; */
+/* 	mod_timer(&port->mmc_timer, jiffies + msecs_to_jiffies(FIM_SD_TIMEOUT_MS)); */
+	if ((retval = fim_sd_send_buffer(buf))) {
+		printk_err("MMC command %i (err %i)\n", cmd->opcode, retval);
+		goto exit_ok;
+	}
+
+	if (fim_wait_txdma(pic_num)) {
+		ulong ifs;
+
+		/* If we have a timeout then try to get some infos about it */
+		ifs = readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT);
+		printk_err("FIM%i: Timeout sending CMD%u [0x%08x]\n",
+			   pic_num, cmd->opcode, ifs);
+		retval = -EBUSY;
+	}
+
+
+	/*
+	 * If we have a write command then fill a next buffer and send it
+	 * @TODO: We need here an error handling, then otherwise we have started a
+	 * WR-transfer but have no transfer data (perhaps not too critical?)
+	 */
+	if (data && data->flags & MMC_DATA_WRITE) {
+		length = data->blksz * data->blocks;
+/* 		if (!(buf = fim_sd_alloc_buffer(port, length))) { */
+/* 			printk_err("Buffer alloc BLKWR failed, %i\n", length); */
+/* 			goto exit_ok; */
+/* 		} */
+
+/* 		buf->private = port; */
+/* 		fim_sd_sg_to_dma(port, data, buf); */
+/* 		if ((retval = fim_sd_send_buffer(port, buf))) { */
+/* 			printk_err("Send BLKWR-buffer failed, %i\n", retval); */
+/* 			fim_sd_free_buffer(port, buf); */
+/* 		} */
+	}
+
+ exit_ok:
+	return retval;
+}
+
+static int mmc_cmd(u32 opcode, u32 arg, unsigned int flags, struct mmc_data *data)
+{
+	static struct mmc_command mmc_cmd;
+	struct fim_buffer_t *rxbuf;
+
+	/* Send a reset command first */
+	mmc_cmd.opcode = opcode;
+	mmc_cmd.arg = arg;
+	mmc_cmd.data = data;
+	mmc_cmd.flags = flags;
+	mmc_cmd.error = 0;
+	memset(mmc_cmd.resp, 0, sizeof(mmc_cmd.resp));
+	if (fim_sd_send_command(&mmc_cmd))
+		return -ENODEV;
+
+	port->waiting_process_next = 1;
+	while (port->waiting_process_next) {
+
+		if (!(rxbuf = fim_wait_rxdma(pic_num, 1000))) {
+			printk_err("Timeout by RX-DMA %i (INT 0x%08lx)\n",
+				   pic_num, readl(FIM_IOHUB_ADDR(pic_num) + HUB_INT));
+			return -ENODEV;
+		}
+
+		/* A new DMA-buffer is full, so call the handler */
+		fim_sd_rx_isr(rxbuf);
+	}
+
+	return mmc_cmd.error;
+}
+
+static void set_bus_width(int width)
+{
+	u32 flags, arg;
+
+	if(card == MMC_CARD) {
+		flags = 0x0000049d;
+		arg = 0x03b70000 | (width << 7);
+		if (mmc_cmd(MMC_SWITCH, arg, flags, NULL)) {
+			printk_err("Setting the bus width!\n");
+			return;
+		}
+	} else  {
+		/* CMD55: Prepare for the next application command */
+		flags = 0x00000095;
+		if (mmc_cmd(MMC_APP_CMD, port->mmc_card.rca << 16, flags, NULL)) {
+			printk_err("Couldn't prepare the card for the APPCMD6\n");
+			return;
+		}
+
+		/* APCMD6: Set the bus width */
+		flags = 0x00000015;
+		if (mmc_cmd(SD_APP_SET_BUS_WIDTH, width, flags, NULL)) {
+			printk_err("Setting the bus width!\n");
+			return;
+		}
+	}
+}
+
+void get_sd_scr(void)
+{
+	uint scr1, sd_spec;
+	struct mmc_data data;
+
+	/* ACMD51: Get the SCR */
+	mmc_cmd(MMC_APP_CMD, port->mmc_card.rca << 16, 0x000000f5, NULL);
+	data.blocks = 1;
+	data.blksz = 8;
+	data.flags = MMC_DATA_READ;
+	mmc_cmd(SD_APP_SEND_SCR, 0x0, 0x000000b5, &data);
+
+	udelay(1000);
+	scr1 = port->mmc_cmd->resp[0];
+
+	if (scr1 & 0x1<<24)
+		sd_spec = 1;	/* Version 1.10, support CMD6 */
+	else
+		sd_spec = 0;	/* Version 1.0 ~ 1.01 */
+
+	printf("sd_spec = 1.%d(0x%08x)\n", sd_spec, scr1);
+}
+
+uint check_sd_ocr(void)
+{
+	uint i, ret = 0;
+
+	for(i = 0; i < 0x80; i++) {
+		/* CMD55: Prepare for a next Application command (ACMD41) */
+		mmc_cmd(MMC_APP_CMD, 0, 0x000000f5, NULL);
+		/* CMD41: Get the OCR from the card */
+		mmc_cmd(SD_APP_OP_COND, 0x40300000, 0x000000e1, NULL);
+		/*
+		 * If the busy bit is set, then the card informs us that the power up
+		 * procedure is done.
+		 */
+		if (!port->mmc_cmd->error && (port->mmc_cmd->resp[0] & MMC_CARD_BUSY)) {
+			if (port->mmc_cmd->resp[0] & MMC_HIGH_CAPACITY)
+				sdhc = 1;
+			ret = SD_CARD;
+			break;
+		}
+		else
+			udelay(10000);
+	}
+
+	return ret;
+}
+
+uint check_mmc_ocr(void)
+{
+	uint i, ret = 0;
+
+	for(i = 0; i < 5; i++) {
+		/* CMD1: Get the OCR from the card */
+		mmc_cmd(MMC_SEND_OP_COND, 0x40300000, 0x000000e1, NULL);
+		/*
+		 * If the busy bit is set, then the card informs us that the power up
+		 * procedure is done.
+		 */
+		if (!port->mmc_cmd->error && (port->mmc_cmd->resp[0] & MMC_CARD_BUSY)) {
+			if (port->mmc_cmd->resp[0] & MMC_HIGH_CAPACITY)
+				sdhc = 1;
+			ret = MMC_CARD;
+			break;
+		}
+		else
+			udelay(100000);
+	}
+
+	return ret;
+}
+
+/*
+ * Function for reading data from the card
+ * dst : Memory address to transfer the read data to
+ * src : Address inside the card to read from
+ * len : Block size to read (must be configured first)
+ */
+int mmc_block_read(uchar *dst, ulong src, ulong len)
+{
+	struct mmc_data data;
+	int retval;
+	u32 flags;
+
+	port->blkrd_dst = dst;
+
+	/* CMD17: Read a single block from the card */
+	data.blocks = 1;
+	data.blksz = port->blk_size;
+	data.flags = MMC_DATA_READ;
+	flags = 0xb5 | MMC_RSP_CRC;
+
+	if (sdhc) {
+		/* Convert src to Block addressing */
+		src /= port->blk_size;
+	}
+	retval = mmc_cmd(MMC_READ_SINGLE_BLOCK, src, flags, &data);
+
+	return retval;
+}
+
+int mmc_read(ulong src, uchar *dst, int size)
+{
+	ulong blksz, blocks;
+	ulong cnt;
+	u8 *ptr;
+	u32 progress = 0;
+
+	/* @XXX: Sanity check probably not required */
+	if (size == 0) {
+		printk_err("Zero data to read?\n");
+		return 0;
+	}
+
+	blksz = port->blk_size;
+	blocks = (size) / blksz;
+
+	printk_debug("Read: src %lx to dest %lx (Blocks %i x %luB)\n",
+		    src, (ulong)dst, blocks, blksz);
+
+	/* Main loop for reading the different blocks */
+	for (ptr = dst, cnt = 0; cnt < blocks; cnt++) {
+		if ((mmc_block_read((uchar *)ptr, src, blksz)) < 0) {
+			printk_err("Block read error. Aborting\n");
+			return -1;
+		}
+		if (++progress == BYTES_PROGRESS_DOT / blksz) {
+			printf(".");
+			progress = 0;
+		}
+
+		src += blksz;
+		ptr += blksz;
+	}
+
+	return 0;
+}
+
+int mmc_write(uchar *src, ulong dst, int size)
+{
+	return 0;
+}
+
+ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+{
+	ulong src = (blknr * port->blk_size)/*  + CFG_MMC_BASE */;
+
+	printk_debug("%s: Read %i block(s) from %i | Dest %p\n",
+		     __func__, blkcnt, blknr, dst);
+
+	/* In some cases the caller pass ZERO as number of blocks to read */
+	blkcnt = (!blkcnt) ? (1) : blkcnt;
+
+        mmc_read(src, (uchar *)dst, blkcnt * port->blk_size);
+        return blkcnt;
+}
+
+/* Below function is coming from the S3C24XX machine code */
+static int fim_sdio_fill_csd(u32 *resp)
+{
+        uint c_size, c_size_multi, read_bl_len;
+	uint csd_struct;
+	uint mb;
+
+	if (card == SD_CARD) {
+		/* CSD struct is at bits [127:126] i.e. R0[31:30]
+		* At this point Response is: R0-R1-R2-R3 where
+		* R0.31 is the MSB and R3.0 the LSB (unshifted) */
+		csd_struct = resp[0] >> 30;
+		switch (csd_struct) {
+			case 0:
+				sdhc = 0;
+				break;
+			case 1:
+				/* SDHC card > 2Gb.
+				* This should have already been discovered
+				* in the OCR data (bit 30), but just in case */
+				sdhc = 1;
+				break;
+			default:
+				printf("ERROR: incorrect CSD Structure version. Card not supported\n");
+				return -1;
+		}
+	}
+
+	/* Common fields for SD/SDHC/MMC */
+        read_bl_len = (resp[1] >> 16) & 0xf;
+        port->blk_size = (1 << read_bl_len);
+        printf("Block Size: %d Bytes\n", port->blk_size);
+
+	if (sdhc) {
+		/* Special size calculation procedure for
+		 * SDHC cards: In theory, they are 22 bits,
+		 * but the specification says that only 16 bits
+		 * are valid. c_size is given in blocks */
+		c_size = resp[2] >> 16;
+		port->card_size = (c_size + 1) << 10;	/* in blocks */
+	} else {
+		/* Standard size calculation procedure for
+		 * SD and MMC cards */
+		c_size = ((resp[1] & 0x3ff) << 2 ) | ((resp[2] >> 30) & 0x3);
+		c_size_multi = ((resp[2] >> 15) & 0x7);
+		port->card_size = (c_size + 1) *
+			    (1 << (c_size_multi + 2)); /* in blocks */
+	}
+	/* Card size in MB + security area */
+	mb = (port->card_size * port->blk_size) / 1048576 + 1;
+	if (mb / 1024 > 0)
+		printf("Card Size: %d.%d GBytes\n",
+			mb / 1024,
+			(mb % 1024)*100/1024);
+	else
+		printf("Card Size: %d MBytes\n", mb);
+
+	return 0;
+}
+
+/*
+ * This function is called over the command "mmcinit"
+ */
+int mmc_init(uint card_type, uint width, uint highspeed)
+{
+ 	int rc = -ENODEV;
+	unsigned int flags;
+	unsigned long clkdiv;
+	int fwver, rca;
+
+	//printk_info("Firmware address 0x%08x\n", FIM_SDIO_FIRMWARE);
+
+	/* Reset sdhc flag */
+	sdhc = 0;
+
+	/* Check if the instruction cache is enabled, otherwise return at this point */
+	if (!icache_status()) {
+		printk_err("Instruction cache required for this operation (icache on)\n");
+		return -EAGAIN;
+	}
+
+	/* Install the FIM-firmware for the SDIO-port */
+        if(fim_core_init(pic_num, FIM_SDIO_FIRMWARE)) {
+		printf("Couldn't install the FIM-firmware\n");
+                return -ENODEV;
+	}
+
+	fwver = fim_get_exp_reg(pic_num, FIM_SDIO_VERSION_SREG);
+	printk_debug("FIM%u: Firmware revision rev%02x\n", pic_num, fwver);
+
+	/* Configure the GPIOs */
+	printk_debug("Configuring GPIOs: %d,%d,%d,%d,%d,%d,%d\n",
+		FIM_SDIO_D0,
+		FIM_SDIO_D1,
+		FIM_SDIO_D2,
+		FIM_SDIO_D3,
+		FIM_SDIO_CD,
+		FIM_SDIO_CLK,
+		FIM_SDIO_CMD);
+	gpio_cfg_set(FIM_SDIO_D0, GPIO_CFG_FUNC_FIM_SDIO_D0);
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+	gpio_cfg_set(FIM_SDIO_D1, GPIO_CFG_FUNC_FIM_SDIO_D1);
+	gpio_cfg_set(FIM_SDIO_D2, GPIO_CFG_FUNC_FIM_SDIO_D2);
+	gpio_cfg_set(FIM_SDIO_D3, GPIO_CFG_FUNC_FIM_SDIO_D3);
+#endif
+	gpio_cfg_set(FIM_SDIO_CD, GPIO_CFG_FUNC_FIM_SDIO_CD);
+	gpio_cfg_set(FIM_SDIO_CLK, GPIO_CFG_FUNC_FIM_SDIO_CLK);
+	gpio_cfg_set(FIM_SDIO_CMD, GPIO_CFG_FUNC_FIM_SDIO_CMD);
+
+	/* Configure the write protect GPIO as input IO */
+	gpio_cfg_set(FIM_SDIO_WP,
+		     GPIO_CFG_INPUT | GPIO_CFG_PULLUP_DISABLE | GPIO_CFG_FUNC_GPIO);
+
+	/* turn on the power */
+	udelay(1000);
+
+	fim_init_rxdma(pic_num);
+
+	/* Configure the clock with 320kHz */
+	clkdiv = 0x70;
+	fim_set_ctrl_reg(pic_num, FIM_SD_REG_CLOCK_DIVISOR, clkdiv);
+
+	/* Start the code execution on the FIM */
+	fim_set_ctrl_reg(pic_num, FIM_SDIO_MAIN_REG, FIM_SDIO_MAIN_START);
+
+	port->bus_width = MMC_BUS_WIDTH_1;
+
+	/* A timeout will happen by this reset-command (but isn't a failure) */
+	mmc_cmd(MMC_GO_IDLE_STATE, 0, 0x000000c0, NULL);
+
+	/* CMD8: Get the Card Specific Data from the card */
+	if ((rc = mmc_cmd(MMC_SEND_EXT_CSD, 0x000001aa, 0x000002f5, NULL))) {
+		/* printk_err("FIM%u: Couldn't get the CSD\n", pic_num); */
+		/* return rc; */
+	}
+
+	switch(card_type) {
+		case AUTODETECTION:
+		case MMC_CARD:
+			if(check_mmc_ocr()) {
+				card = MMC_CARD;
+				printf("MMC card is detected\n");
+				break;
+			}
+		case SD_CARD:
+			if(check_sd_ocr()) {
+				card = SD_CARD;
+				printf("SD%s card is detected\n",
+					sdhc ? "HC" : "" );
+				break;
+			}
+		default:
+			return 1;
+	}
+
+	/* CMD2: Send the CID to the MMC-host */
+	flags = MMC_RSP_R2 | MMC_CMD_BCR;
+	if ((rc = mmc_cmd(MMC_ALL_SEND_CID, 0x0, flags, NULL))) {
+		printk_err("Reading the CID\n");
+		return rc;
+	}
+
+	/* CMD3: Get the relative card address (RCA) */
+	rca = (card & MMC_CARD) ? 0x1 : 0x0;
+	if ((rc = mmc_cmd(MMC_SET_RELATIVE_ADDR, rca << 16, 0x00000075, NULL))) {
+		printk_err("Setting the relative address\n");
+		return rc;
+	}
+	/* Read RCA only on SD cards */
+	if (!rca)
+		rca = port->mmc_cmd->resp[0] >> 16;
+	port->mmc_card.rca = rca;
+
+	/* CMD9: Get the card specific data (CSD) */
+	if ((rc = mmc_cmd(MMC_SEND_CSD, port->mmc_card.rca << 16, 0x00000087, NULL))) {
+		printk_err("Error on CMD9\n");
+		return rc;
+	}
+	fim_sdio_fill_csd(port->mmc_cmd->resp);
+
+	/* CMD7: Select the card for the next operations */
+	if ((rc = mmc_cmd(MMC_SELECT_CARD, port->mmc_card.rca << 16, 0x00000015, NULL))) {
+		printk_err("Error on CMD7\n");
+		return rc;
+	}
+
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+	/* Set bus width to 4 bits in cc(w)9p9215 */
+	port->bus_width = MMC_BUS_WIDTH_4;
+#endif
+	set_bus_width(port->bus_width);
+
+	/* Now, the card can be driven at full speed */
+	fim_set_ctrl_reg(pic_num, FIM_SD_REG_CLOCK_DIVISOR, 0x4);
+
+	/* FAT and ext2 require a block size of 512.
+	 * it needs to be forced despite of the value in CSD */
+	if (MMC_BLOCK_SIZE != port->blk_size)
+		port->blk_size = MMC_BLOCK_SIZE;
+
+	/* CMD16: Set the correct block length to read */
+	flags = 0x00000095; //MMC_RSP_CRC | MMC_CMDAT_R1;
+	while(mmc_cmd(MMC_CMD_SET_BLOCKLEN, port->blk_size, flags, NULL));
+
+	/* Setup the mmc device in order to register a FAT device */
+        mmc_dev.if_type = IF_TYPE_MMC;
+        mmc_dev.part_type = PART_TYPE_DOS;
+        mmc_dev.dev = 0;
+        mmc_dev.lun = 0;
+        mmc_dev.type = 0;
+        mmc_dev.blksz = port->blk_size;
+        mmc_dev.lba = port->card_size;
+        sprintf((char*) mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+                        0x00, 0x1, 0x2, 0x1, 0x2, 0x3);
+        sprintf((char*) mmc_dev.product,"%s","SD/MMC");
+        sprintf((char*) mmc_dev.revision,"%x %x",0x1, 0x1);
+        mmc_dev.removable = 0;
+        mmc_dev.block_read = mmc_bread;
+#if (CONFIG_COMMANDS & CFG_CMD_FAT)
+	fat_register_device(&mmc_dev, MMC_MAX_DEVICE);
+#endif
+	return 0;
+}
+
+int hs_mmc_get_dev(uint card, uint buswidth, uint highspeed)
+{
+
+	return -1;
+}
+
+int hs_mmc_init(uint card, uint buswidth, uint highspeed)
+{
+
+	return -1;
+}
+
+int mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+/* 	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) { */
+/* 		return 1; */
+/* 	} */
+	return 0;
+}
+
+#endif /* CONFIG_NS921X_FIM_SDIO && CONFIG_MMC */
diff --git a/cpu/arm926ejs/ns921x/fim_sdio.h b/cpu/arm926ejs/ns921x/fim_sdio.h
new file mode 100644
index 0000000..d291bea
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio.h
@@ -0,0 +1,57 @@
+/* FIM SD registers, flags, and macros */
+
+/* Registers with status information */
+#define FIM_SD_GPIOS_REG			0x02
+#define FIM_SD_GPIOS_REG_CD			0x01
+#define FIM_SD_GPIOS_REG_WP			0x02
+#define FIM_SD_CARD_STATREG			0x00
+
+/* Interrupts from the FIM to the driver */
+#define FIM_SD_INTARM_CARD_DAT1			0x01
+#define FIM_SD_INTARM_CARD_DETECTED		0x02
+
+
+/* Macros for the SDIO-interface to the FIM-firmware */
+#define SDIO_HOST_TX_HDR			0x40
+#define SDIO_HOST_CMD_MASK			0x3f
+#define SDIO_FIFO_TX_48RSP			0x01
+#define	SDIO_FIFO_TX_136RSP			0x02
+#define SDIO_FIFO_TX_BW4			0x04
+#define SDIO_FIFO_TX_BLKWR			0x08
+#define SDIO_FIFO_TX_BLKRD			0x10
+#define SDIO_FIFO_TX_DISCRC			0x20
+
+
+/* User specified macros */
+#define FIM_SD_TIMEOUT_MS			2000
+#define FIM_SD_TX_CMD_LEN			5
+#define FIM_SD_MAX_RESP_LENGTH			17
+
+
+/* Status bits from the PIC-firmware */
+#define FIM_SD_RX_RSP				0x01
+#define FIM_SD_RX_BLKRD				0x02
+#define FIM_SD_RX_TIMEOUT			0x04
+
+
+/* FIM SD control registers */
+#define FIM_SD_REG_CLOCK_DIVISOR		0
+#define FIM_SD_REG_INTERRUPT			1
+
+
+/* Internal flags for the request function */
+#define FIM_SD_REQUEST_NEW			0x00
+#define FIM_SD_REQUEST_CMD			0x01
+#define FIM_SD_REQUEST_STOP			0x02
+#define FIM_SD_SET_BUS_WIDTH			0x04
+
+
+/* Macros for the DMA-configuraton */
+#define FIM_SD_DMA_BUFFER_SIZE			PAGE_SIZE
+#define FIM_SD_DMA_RX_BUFFERS			21
+#define FIM_SD_DMA_TX_BUFFERS			10
+
+/*
+ * Expansion/Status register with the revision number
+ */
+#define FIM_SDIO_VERSION_SREG			(0)
diff --git a/cpu/arm926ejs/ns921x/fim_sdio0.h b/cpu/arm926ejs/ns921x/fim_sdio0.h
new file mode 100644
index 0000000..12c99a0
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio0.h
@@ -0,0 +1,225 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio.h
+ * Structure     : fim_sdio_firmware0
+ */
+
+static const unsigned char fim_sdio_firmware0[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x2f, 0x03, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x1d, 0x23, 0x83, 0x12,  0x9f, 0x01, 0x9f, 0x14,  
+	0x83, 0x16, 0xff, 0x30,  0x99, 0x00, 0x83, 0x12,  
+	0x83, 0x12, 0x15, 0x1c,  0x16, 0x28, 0x00, 0x30,  
+	0xa6, 0x00, 0x1c, 0x28,  0xa4, 0x01, 0xbb, 0x01,  
+	0xbc, 0x01, 0xbd, 0x01,  0xbe, 0x01, 0xbf, 0x01,  
+	0xc0, 0x01, 0xc1, 0x01,  0xc2, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0xb9, 0x01, 0x3d, 0x20,  
+	0x8c, 0x1d, 0x54, 0x28,  0x2e, 0x20, 0x1c, 0x28,  
+	0x83, 0x16, 0x1a, 0x14,  0x83, 0x12, 0x10, 0x08,  
+	0xac, 0x00, 0xac, 0x0b,  0x33, 0x28, 0x83, 0x16,  
+	0x1a, 0x10, 0x83, 0x12,  0x10, 0x08, 0xac, 0x00,  
+	0xac, 0x0b, 0x3a, 0x28,  0x08, 0x00, 0x22, 0x1c,  
+	0x48, 0x28, 0x83, 0x16,  0x89, 0x1f, 0x46, 0x28,  
+	0x83, 0x12, 0x89, 0x01,  0x22, 0x10, 0x08, 0x00,  
+	0x83, 0x12, 0x08, 0x00,  0x11, 0x1c, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1c,  0x4f, 0x28, 0x83, 0x12,  
+	0x08, 0x00, 0x83, 0x12,  0x22, 0x14, 0x01, 0x30,  
+	0x89, 0x00, 0x08, 0x00,  0x9f, 0x10, 0xa7, 0x01,  
+	0x0f, 0x23, 0xa3, 0x00,  0x0f, 0x23, 0xb5, 0x00,  
+	0x0f, 0x23, 0xb4, 0x00,  0xff, 0x39, 0x03, 0x19,  
+	0x62, 0x28, 0x35, 0x08,  0x01, 0x3e, 0xb5, 0x00,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x8e, 0x20, 0x27, 0x08,  
+	0x75, 0x20, 0x9f, 0x14,  0x23, 0x18, 0x9b, 0x28,  
+	0xa3, 0x18, 0x9b, 0x28,  0x46, 0x29, 0xaa, 0x00,  
+	0x08, 0x30, 0xad, 0x00,  0xaa, 0x0d, 0x83, 0x16,  
+	0x03, 0x18, 0x7e, 0x28,  0x9a, 0x10, 0x7f, 0x28,  
+	0x9a, 0x14, 0x83, 0x12,  0x85, 0x20, 0x2e, 0x20,  
+	0xad, 0x0b, 0x78, 0x28,  0x08, 0x00, 0xa7, 0x13,  
+	0x03, 0x18, 0xa7, 0x17,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x08, 0x00, 0x09, 0x30,  0xa7, 0x06, 0x08, 0x00,  
+	0x07, 0x30, 0xa9, 0x00,  0x03, 0x10, 0xa7, 0x0d,  
+	0xa7, 0x1f, 0x96, 0x28,  0x09, 0x30, 0xa7, 0x06,  
+	0xa9, 0x0b, 0x90, 0x28,  0x03, 0x14, 0xa7, 0x0d,  
+	0x08, 0x00, 0x64, 0x30,  0xab, 0x00, 0xb0, 0x01,  
+	0xa7, 0x01, 0xab, 0x0b,  0xa2, 0x28, 0x1c, 0x29,  
+	0x1f, 0x21, 0x03, 0x18,  0x9f, 0x28, 0x23, 0x1a,  
+	0xe0, 0x28, 0x01, 0x30,  0x18, 0x23, 0x03, 0x10,  
+	0x2d, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0xa3, 0x18, 0xc2, 0x28,  
+	0x8e, 0x20, 0x27, 0x08,  0xa8, 0x00, 0x2c, 0x21,  
+	0x13, 0x23, 0x28, 0x08,  0xa3, 0x19, 0xc0, 0x28,  
+	0x18, 0x23, 0x46, 0x29,  0x13, 0x23, 0x46, 0x29,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x13, 0x23, 0x28, 0x08,  
+	0x18, 0x23, 0x46, 0x29,  0x50, 0x30, 0x84, 0x00,  
+	0x2d, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0xa3, 0x1c,  
+	0x14, 0x29, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x80, 0x00, 0x24, 0x18,  
+	0xfc, 0x29, 0x0b, 0x2a,  0x04, 0x30, 0x18, 0x23,  
+	0x1c, 0x28, 0x23, 0x1a,  0x21, 0x22, 0x83, 0x16,  
+	0x92, 0x18, 0x28, 0x29,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x10, 0x08, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x14, 0x08, 0x00,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x30, 0x08, 0x08, 0x00,  
+	0x23, 0x1a, 0xfc, 0x29,  0xa3, 0x19, 0x4f, 0x29,  
+	0x2e, 0x20, 0x2e, 0x20,  0x2e, 0x20, 0x3d, 0x20,  
+	0x1c, 0x28, 0x2e, 0x20,  0x2e, 0x20, 0xff, 0x30,  
+	0x23, 0x1d, 0x11, 0x30,  0x83, 0x16, 0x98, 0x00,  
+	0xff, 0x3a, 0x99, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x83, 0x16, 0x98, 0x01,  0x83, 0x12, 0x2e, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x0f, 0x23, 0xb8, 0x00,  0x23, 0x19, 0x79, 0x29,  
+	0x08, 0x30, 0xba, 0x00,  0xb8, 0x1b, 0x6f, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x00, 0x30,  
+	0x73, 0x29, 0x83, 0x16,  0x18, 0x14, 0x83, 0x12,  
+	0x01, 0x30, 0xe7, 0x22,  0x2e, 0x20, 0xb8, 0x0d,  
+	0xba, 0x0b, 0x68, 0x29,  0x9e, 0x29, 0x26, 0x18,  
+	0x8c, 0x29, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0x9e, 0x29,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xb8, 0x0e, 0x38, 0x08,  
+	0xa3, 0x1e, 0xe7, 0x22,  0x2e, 0x20, 0x38, 0x08,  
+	0x83, 0x16, 0x98, 0x00,  0x83, 0x12, 0xb8, 0x0e,  
+	0x38, 0x08, 0xa3, 0x1e,  0xe7, 0x22, 0x2e, 0x20,  
+	0xb6, 0x0b, 0x62, 0x29,  0xb7, 0x0b, 0x62, 0x29,  
+	0xa3, 0x1a, 0xaa, 0x29,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0xe7, 0x22,  0xc4, 0x0b, 0xa6, 0x29,  
+	0x10, 0x30, 0xc4, 0x00,  0xc5, 0x01, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x18,  0x45, 0x14, 0xbd, 0x0d,  
+	0xbe, 0x0d, 0x03, 0x18,  0xc5, 0x14, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x18,  0x45, 0x15, 0xc1, 0x0d,  
+	0xc2, 0x0d, 0x03, 0x18,  0xc5, 0x15, 0x26, 0x18,  
+	0xc5, 0x0e, 0x45, 0x08,  0x83, 0x16, 0x98, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0xc4, 0x0b, 0xac, 0x29,  
+	0x83, 0x16, 0xff, 0x30,  0x98, 0x00, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0xff, 0x30, 0x99, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0x2e, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0xd7, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x2e, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0xde, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xe5, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0x10, 0x1c, 0xec, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0x18, 0x23, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xf2, 0x29, 0x83, 0x12,  0x2e, 0x20, 0x2e, 0x20,  
+	0x2e, 0x20, 0x1c, 0x28,  0x24, 0x18, 0x01, 0x2a,  
+	0x21, 0x22, 0x2e, 0x20,  0xfc, 0x29, 0x21, 0x22,  
+	0x2e, 0x20, 0x24, 0x18,  0x01, 0x2a, 0x24, 0x1d,  
+	0x0b, 0x2a, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x1c, 0x28, 0x24, 0x15,  0x01, 0x30, 0x18, 0x23,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xcf, 0x0b,  0x14, 0x2a, 0x28, 0x08,  
+	0x18, 0x23, 0x23, 0x1a,  0xfc, 0x29, 0x2e, 0x20,  
+	0x2e, 0x20, 0x2e, 0x20,  0x1c, 0x28, 0x24, 0x18,  
+	0x32, 0x2a, 0x83, 0x16,  0x10, 0x18, 0x30, 0x2a,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0x18, 0x23, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x23, 0x19, 0x4d, 0x2a,  0x83, 0x16, 0x03, 0x10,  
+	0x10, 0x18, 0x03, 0x14,  0xa1, 0x0d, 0x03, 0x01,  
+	0x10, 0x18, 0x01, 0x30,  0x83, 0x12, 0xa3, 0x1a,  
+	0x41, 0x2a, 0xa4, 0x18,  0xe7, 0x22, 0xb9, 0x0a,  
+	0xb9, 0x1d, 0x08, 0x00,  0x83, 0x16, 0x21, 0x08,  
+	0x83, 0x12, 0x13, 0x23,  0xb9, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0x73, 0x2a, 0x39, 0x19,  
+	0x62, 0x2a, 0x83, 0x16,  0xa1, 0x01, 0x90, 0x19,  
+	0xa1, 0x15, 0x10, 0x19,  0x21, 0x15, 0x90, 0x18,  
+	0xa1, 0x14, 0x10, 0x18,  0x21, 0x14, 0x21, 0x08,  
+	0xa1, 0x0e, 0x83, 0x12,  0x39, 0x15, 0xa3, 0x1a,  
+	0x08, 0x00, 0xa4, 0x18,  0xe7, 0x22, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x19,  0xa1, 0x15, 0x10, 0x19,  
+	0x21, 0x15, 0x90, 0x18,  0xa1, 0x14, 0x10, 0x18,  
+	0x21, 0x14, 0x21, 0x08,  0x83, 0x12, 0x13, 0x23,  
+	0xa3, 0x1a, 0x73, 0x2a,  0xa4, 0x18, 0xe7, 0x22,  
+	0xb9, 0x01, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x81, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x23, 0x1d,  0x02, 0x30, 0xb6, 0x00,  
+	0x01, 0x30, 0xb7, 0x00,  0x08, 0x00, 0x24, 0x10,  
+	0x23, 0x12, 0xa3, 0x1a,  0xe4, 0x2a, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0xe7, 0x22, 0xc4, 0x0b,  
+	0x87, 0x2a, 0x23, 0x19,  0x92, 0x2a, 0x3c, 0x08,  
+	0x13, 0x23, 0x3b, 0x08,  0x18, 0x23, 0x08, 0x00,  
+	0x04, 0x08, 0xe7, 0x00,  0x47, 0x30, 0x84, 0x00,  
+	0x08, 0x30, 0xc4, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x98, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x04, 0x30, 0xc4, 0x00,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x17, 0xc2, 0x0d,  0x03, 0x18, 0x80, 0x15,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x17, 0xc0, 0x0d,  
+	0x03, 0x18, 0x00, 0x15,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x16, 0xbe, 0x0d,  0x03, 0x18, 0x80, 0x14,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x16, 0xbc, 0x0d,  
+	0x03, 0x18, 0x00, 0x14,  0x84, 0x0a, 0xc4, 0x0b,  
+	0xa0, 0x2a, 0x04, 0x30,  0xc4, 0x00, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc1, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xbf, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbd, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbb, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0xbd, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x07, 0x30, 0xc4, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xc4, 0x0b,  0xdc, 0x2a, 0x00, 0x08,  
+	0x18, 0x23, 0x08, 0x00,  0x03, 0x01, 0x18, 0x23,  
+	0x08, 0x00, 0xc3, 0x00,  0xc3, 0x0c, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x1c,  0xf1, 0x2a, 0x21, 0x30,  
+	0xbb, 0x06, 0x10, 0x30,  0xbc, 0x06, 0x23, 0x1d,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0xfc, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x05, 0x2b, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x0f, 0x2b, 0x0f, 0x08,  
+	0x08, 0x00, 0x8c, 0x1b,  0x13, 0x2b, 0x8e, 0x01,  
+	0x8d, 0x00, 0x08, 0x00,  0x8c, 0x1b, 0x18, 0x2b,  
+	0x8e, 0x0a, 0x8d, 0x00,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0x20, 0x2b,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0x28, 0x2b,  
+	0x08, 0x00
+};
+
diff --git a/cpu/arm926ejs/ns921x/fim_sdio0_9210.h b/cpu/arm926ejs/ns921x/fim_sdio0_9210.h
new file mode 100644
index 0000000..540583e
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio0_9210.h
@@ -0,0 +1,197 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio_9210.h
+ * Structure     : fim_sdio_firmware0
+ */
+
+static const unsigned char fim_sdio_firmware0[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0xbf, 0x02, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x01, 0x30, 0x98, 0x00,  0xad, 0x22, 0x83, 0x16,  
+	0x99, 0x01, 0x19, 0x15,  0x19, 0x14, 0x83, 0x12,  
+	0x17, 0x28, 0xa4, 0x01,  0xbb, 0x01, 0xbc, 0x01,  
+	0xbd, 0x01, 0xbe, 0x01,  0xbf, 0x01, 0xc0, 0x01,  
+	0xc1, 0x01, 0xc2, 0x01,  0x83, 0x16, 0xa1, 0x01,  
+	0x83, 0x12, 0xb9, 0x01,  0x8c, 0x1d, 0x37, 0x28,  
+	0x28, 0x20, 0x17, 0x28,  0x83, 0x16, 0x98, 0x14,  
+	0x83, 0x12, 0x10, 0x08,  0xac, 0x00, 0xac, 0x0b,  
+	0x2d, 0x28, 0x83, 0x16,  0x98, 0x10, 0x83, 0x12,  
+	0x10, 0x08, 0xac, 0x00,  0xac, 0x0b, 0x34, 0x28,  
+	0x08, 0x00, 0x83, 0x16,  0x19, 0x11, 0x83, 0x12,  
+	0xa7, 0x01, 0x93, 0x22,  0xa3, 0x00, 0x93, 0x22,  
+	0xb5, 0x00, 0x93, 0x22,  0xb4, 0x00, 0xff, 0x39,  
+	0x03, 0x19, 0x47, 0x28,  0x35, 0x08, 0x01, 0x3e,  
+	0xb5, 0x00, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x75, 0x20,  
+	0x27, 0x08, 0x5c, 0x20,  0x83, 0x16, 0x19, 0x15,  
+	0x83, 0x12, 0x23, 0x18,  0x82, 0x28, 0xa3, 0x18,  
+	0x82, 0x28, 0x2d, 0x29,  0xaa, 0x00, 0x08, 0x30,  
+	0xad, 0x00, 0xaa, 0x0d,  0x83, 0x16, 0x03, 0x18,  
+	0x65, 0x28, 0x18, 0x11,  0x66, 0x28, 0x18, 0x15,  
+	0x83, 0x12, 0x6c, 0x20,  0x28, 0x20, 0xad, 0x0b,  
+	0x5f, 0x28, 0x08, 0x00,  0xa7, 0x13, 0x03, 0x18,  
+	0xa7, 0x17, 0xa7, 0x0d,  0xa7, 0x1f, 0x08, 0x00,  
+	0x09, 0x30, 0xa7, 0x06,  0x08, 0x00, 0x07, 0x30,  
+	0xa9, 0x00, 0x03, 0x10,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x7d, 0x28, 0x09, 0x30,  0xa7, 0x06, 0xa9, 0x0b,  
+	0x77, 0x28, 0x03, 0x14,  0xa7, 0x0d, 0x08, 0x00,  
+	0x64, 0x30, 0xab, 0x00,  0xb0, 0x01, 0xa7, 0x01,  
+	0xab, 0x0b, 0x89, 0x28,  0x03, 0x29, 0x06, 0x21,  
+	0x03, 0x18, 0x86, 0x28,  0x23, 0x1a, 0xc7, 0x28,  
+	0x01, 0x30, 0xa4, 0x22,  0x03, 0x10, 0x14, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0xa3, 0x18,  0xa9, 0x28, 0x75, 0x20,  
+	0x27, 0x08, 0xa8, 0x00,  0x13, 0x21, 0x9b, 0x22,  
+	0x28, 0x08, 0xa3, 0x19,  0xa7, 0x28, 0xa4, 0x22,  
+	0x2d, 0x29, 0x9b, 0x22,  0x2d, 0x29, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x9b, 0x22,  0x28, 0x08, 0xa4, 0x22,  
+	0x2d, 0x29, 0x50, 0x30,  0x84, 0x00, 0x14, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0xa3, 0x1c, 0xfb, 0x28,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x80, 0x00,  0x24, 0x18, 0xac, 0x29,  
+	0xbb, 0x29, 0x04, 0x30,  0xa4, 0x22, 0x17, 0x28,  
+	0x23, 0x1a, 0xd1, 0x21,  0x83, 0x16, 0x10, 0x19,  
+	0x0f, 0x29, 0x83, 0x12,  0x28, 0x20, 0x03, 0x10,  
+	0x08, 0x00, 0x83, 0x12,  0x28, 0x20, 0x03, 0x14,  
+	0x08, 0x00, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x30, 0x08,  0x08, 0x00, 0x23, 0x1a,  
+	0xac, 0x29, 0xa3, 0x19,  0x35, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x28, 0x20,  
+	0x28, 0x20, 0xff, 0x30,  0x01, 0x30, 0x83, 0x16,  
+	0x18, 0x14, 0x19, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x93, 0x22, 0xb8, 0x00,  0x08, 0x30, 0xba, 0x00,  
+	0xb8, 0x1b, 0x51, 0x29,  0x83, 0x16, 0x18, 0x10,  
+	0x83, 0x12, 0x00, 0x30,  0x55, 0x29, 0x83, 0x16,  
+	0x18, 0x14, 0x83, 0x12,  0x01, 0x30, 0x6c, 0x22,  
+	0x28, 0x20, 0xb8, 0x0d,  0xba, 0x0b, 0x4a, 0x29,  
+	0x5b, 0x29, 0xb6, 0x0b,  0x46, 0x29, 0xb7, 0x0b,  
+	0x46, 0x29, 0xa3, 0x1a,  0x67, 0x29, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0x6c, 0x22, 0xc4, 0x0b,  
+	0x63, 0x29, 0x10, 0x30,  0xc4, 0x00, 0xc5, 0x01,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x18, 0x72, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x75, 0x29,  
+	0x83, 0x16, 0x18, 0x14,  0x83, 0x12, 0x28, 0x20,  
+	0xc4, 0x0b, 0x69, 0x29,  0x83, 0x16, 0x18, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x19, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x28, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0x87, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x28, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0x8e, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0x95, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x28, 0x20, 0x83, 0x16,  0x10, 0x1c, 0x9c, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0xa4, 0x22, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xa2, 0x29, 0x83, 0x12,  0x28, 0x20, 0x28, 0x20,  
+	0x28, 0x20, 0x17, 0x28,  0x24, 0x18, 0xb1, 0x29,  
+	0xd1, 0x21, 0x28, 0x20,  0xac, 0x29, 0xd1, 0x21,  
+	0x28, 0x20, 0x24, 0x18,  0xb1, 0x29, 0x24, 0x1d,  
+	0xbb, 0x29, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x17, 0x28, 0x24, 0x15,  0x01, 0x30, 0xa4, 0x22,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x9b, 0x22,  
+	0x84, 0x0a, 0xcf, 0x0b,  0xc4, 0x29, 0x28, 0x08,  
+	0xa4, 0x22, 0x23, 0x1a,  0xac, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x24, 0x18,  
+	0xe2, 0x29, 0x83, 0x16,  0x10, 0x18, 0xe0, 0x29,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0xa4, 0x22, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x83, 0x16, 0x03, 0x10,  0x10, 0x18, 0x03, 0x14,  
+	0xa1, 0x0d, 0x03, 0x01,  0x10, 0x18, 0x01, 0x30,  
+	0x83, 0x12, 0xa3, 0x1a,  0xef, 0x29, 0xa4, 0x18,  
+	0x6c, 0x22, 0xb9, 0x0a,  0xb9, 0x1d, 0x08, 0x00,  
+	0x83, 0x16, 0x21, 0x08,  0x83, 0x12, 0x9b, 0x22,  
+	0xb9, 0x01, 0x83, 0x16,  0xa1, 0x01, 0x83, 0x12,  
+	0xfb, 0x29, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x08, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x02, 0x30,  0xb6, 0x00, 0x01, 0x30,  
+	0xb7, 0x00, 0x08, 0x00,  0x24, 0x10, 0x23, 0x12,  
+	0xa3, 0x1a, 0x69, 0x2a,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0x6c, 0x22,  0xc4, 0x0b, 0x0e, 0x2a,  
+	0x3c, 0x08, 0x9b, 0x22,  0x3b, 0x08, 0xa4, 0x22,  
+	0x08, 0x00, 0x04, 0x08,  0xe7, 0x00, 0x47, 0x30,  
+	0x84, 0x00, 0x08, 0x30,  0xc4, 0x00, 0x80, 0x01,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x1d, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x04, 0x30,  0xc4, 0x00, 0xc2, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xc0, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbe, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbc, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x25, 0x2a,  0x04, 0x30, 0xc4, 0x00,  
+	0xc1, 0x0d, 0x03, 0x18,  0x80, 0x17, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x15,  0xbf, 0x0d, 0x03, 0x18,  
+	0x00, 0x17, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x15,  
+	0xbd, 0x0d, 0x03, 0x18,  0x80, 0x16, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x14,  0xbb, 0x0d, 0x03, 0x18,  
+	0x00, 0x16, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x14,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x42, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x07, 0x30,  0xc4, 0x00, 0x00, 0x08,  
+	0x9b, 0x22, 0x84, 0x0a,  0xc4, 0x0b, 0x61, 0x2a,  
+	0x00, 0x08, 0xa4, 0x22,  0x08, 0x00, 0x03, 0x01,  
+	0xa4, 0x22, 0x08, 0x00,  0xc3, 0x00, 0xc3, 0x0c,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x1c, 0x76, 0x2a,  
+	0x21, 0x30, 0xbb, 0x06,  0x10, 0x30, 0xbc, 0x06,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0x80, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x89, 0x2a, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x93, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x0f, 0x08,  0x00, 0x00, 0x8b, 0x17,  
+	0x08, 0x00, 0x8c, 0x1b,  0x9b, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x8e, 0x01,  0x8d, 0x00, 0x00, 0x00,  
+	0x8b, 0x17, 0x08, 0x00,  0x8c, 0x1b, 0xa4, 0x2a,  
+	0x8b, 0x13, 0x00, 0x00,  0x8e, 0x0a, 0x8d, 0x00,  
+	0x00, 0x00, 0x8b, 0x17,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0xb0, 0x2a,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0xb8, 0x2a,  
+	0x08, 0x00
+};
+
diff --git a/cpu/arm926ejs/ns921x/fim_sdio1.h b/cpu/arm926ejs/ns921x/fim_sdio1.h
new file mode 100644
index 0000000..7f73a0c
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio1.h
@@ -0,0 +1,225 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio.h
+ * Structure     : fim_sdio_firmware1
+ */
+
+static const unsigned char fim_sdio_firmware1[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x2f, 0x03, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x1d, 0x23, 0x83, 0x12,  0x9f, 0x01, 0x9f, 0x15,  
+	0x83, 0x16, 0xff, 0x30,  0x99, 0x00, 0x83, 0x12,  
+	0x83, 0x12, 0x15, 0x1c,  0x16, 0x28, 0x01, 0x30,  
+	0xa6, 0x00, 0x1c, 0x28,  0xa4, 0x01, 0xbb, 0x01,  
+	0xbc, 0x01, 0xbd, 0x01,  0xbe, 0x01, 0xbf, 0x01,  
+	0xc0, 0x01, 0xc1, 0x01,  0xc2, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0xb9, 0x01, 0x3d, 0x20,  
+	0x8c, 0x1d, 0x54, 0x28,  0x2e, 0x20, 0x1c, 0x28,  
+	0x83, 0x16, 0x1a, 0x15,  0x83, 0x12, 0x10, 0x08,  
+	0xac, 0x00, 0xac, 0x0b,  0x33, 0x28, 0x83, 0x16,  
+	0x1a, 0x11, 0x83, 0x12,  0x10, 0x08, 0xac, 0x00,  
+	0xac, 0x0b, 0x3a, 0x28,  0x08, 0x00, 0x22, 0x1c,  
+	0x48, 0x28, 0x83, 0x16,  0x89, 0x1f, 0x46, 0x28,  
+	0x83, 0x12, 0x89, 0x01,  0x22, 0x10, 0x08, 0x00,  
+	0x83, 0x12, 0x08, 0x00,  0x11, 0x1c, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1e,  0x4f, 0x28, 0x83, 0x12,  
+	0x08, 0x00, 0x83, 0x12,  0x22, 0x14, 0x01, 0x30,  
+	0x89, 0x00, 0x08, 0x00,  0x9f, 0x11, 0xa7, 0x01,  
+	0x0f, 0x23, 0xa3, 0x00,  0x0f, 0x23, 0xb5, 0x00,  
+	0x0f, 0x23, 0xb4, 0x00,  0xff, 0x39, 0x03, 0x19,  
+	0x62, 0x28, 0x35, 0x08,  0x01, 0x3e, 0xb5, 0x00,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x0f, 0x23, 0x75, 0x20,  
+	0x0f, 0x23, 0x75, 0x20,  0x8e, 0x20, 0x27, 0x08,  
+	0x75, 0x20, 0x9f, 0x15,  0x23, 0x18, 0x9b, 0x28,  
+	0xa3, 0x18, 0x9b, 0x28,  0x46, 0x29, 0xaa, 0x00,  
+	0x08, 0x30, 0xad, 0x00,  0xaa, 0x0d, 0x83, 0x16,  
+	0x03, 0x18, 0x7e, 0x28,  0x9a, 0x11, 0x7f, 0x28,  
+	0x9a, 0x15, 0x83, 0x12,  0x85, 0x20, 0x2e, 0x20,  
+	0xad, 0x0b, 0x78, 0x28,  0x08, 0x00, 0xa7, 0x13,  
+	0x03, 0x18, 0xa7, 0x17,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x08, 0x00, 0x09, 0x30,  0xa7, 0x06, 0x08, 0x00,  
+	0x07, 0x30, 0xa9, 0x00,  0x03, 0x10, 0xa7, 0x0d,  
+	0xa7, 0x1f, 0x96, 0x28,  0x09, 0x30, 0xa7, 0x06,  
+	0xa9, 0x0b, 0x90, 0x28,  0x03, 0x14, 0xa7, 0x0d,  
+	0x08, 0x00, 0x64, 0x30,  0xab, 0x00, 0xb0, 0x01,  
+	0xa7, 0x01, 0xab, 0x0b,  0xa2, 0x28, 0x1c, 0x29,  
+	0x1f, 0x21, 0x03, 0x18,  0x9f, 0x28, 0x23, 0x1a,  
+	0xe0, 0x28, 0x01, 0x30,  0x18, 0x23, 0x03, 0x10,  
+	0x2d, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0xa3, 0x18, 0xc2, 0x28,  
+	0x8e, 0x20, 0x27, 0x08,  0xa8, 0x00, 0x2c, 0x21,  
+	0x13, 0x23, 0x28, 0x08,  0xa3, 0x19, 0xc0, 0x28,  
+	0x18, 0x23, 0x46, 0x29,  0x13, 0x23, 0x46, 0x29,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x2c, 0x21, 0x13, 0x23,  
+	0x2c, 0x21, 0x13, 0x23,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x13, 0x23, 0x28, 0x08,  
+	0x18, 0x23, 0x46, 0x29,  0x50, 0x30, 0x84, 0x00,  
+	0x2d, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0xa3, 0x1c,  
+	0x14, 0x29, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x2c, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x2c, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x2c, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x2c, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x8e, 0x20, 0x27, 0x08,  
+	0xa8, 0x00, 0x2c, 0x21,  0x80, 0x00, 0x24, 0x18,  
+	0xfc, 0x29, 0x0b, 0x2a,  0x04, 0x30, 0x18, 0x23,  
+	0x1c, 0x28, 0x23, 0x1a,  0x21, 0x22, 0x83, 0x16,  
+	0x92, 0x19, 0x28, 0x29,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x10, 0x08, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x03, 0x14, 0x08, 0x00,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x1f, 0x21, 0x85, 0x20,  
+	0xb0, 0x0d, 0x1f, 0x21,  0x85, 0x20, 0xb0, 0x0d,  
+	0x1f, 0x21, 0x85, 0x20,  0xb0, 0x0d, 0x1f, 0x21,  
+	0x85, 0x20, 0xb0, 0x0d,  0x30, 0x08, 0x08, 0x00,  
+	0x23, 0x1a, 0xfc, 0x29,  0xa3, 0x19, 0x4f, 0x29,  
+	0x2e, 0x20, 0x2e, 0x20,  0x2e, 0x20, 0x3d, 0x20,  
+	0x1c, 0x28, 0x2e, 0x20,  0x2e, 0x20, 0xff, 0x30,  
+	0x23, 0x1d, 0x11, 0x30,  0x83, 0x16, 0x98, 0x00,  
+	0xff, 0x3a, 0x99, 0x00,  0x83, 0x12, 0x2e, 0x20,  
+	0x83, 0x16, 0x98, 0x01,  0x83, 0x12, 0x2e, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x0f, 0x23, 0xb8, 0x00,  0x23, 0x19, 0x79, 0x29,  
+	0x08, 0x30, 0xba, 0x00,  0xb8, 0x1b, 0x6f, 0x29,  
+	0x83, 0x16, 0x18, 0x12,  0x83, 0x12, 0x00, 0x30,  
+	0x73, 0x29, 0x83, 0x16,  0x18, 0x16, 0x83, 0x12,  
+	0x01, 0x30, 0xe7, 0x22,  0x2e, 0x20, 0xb8, 0x0d,  
+	0xba, 0x0b, 0x68, 0x29,  0x9e, 0x29, 0x26, 0x18,  
+	0x8c, 0x29, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0xb8, 0x0e,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xa3, 0x1e, 0xe7, 0x22,  
+	0x2e, 0x20, 0x9e, 0x29,  0x38, 0x08, 0x83, 0x16,  
+	0x98, 0x00, 0x83, 0x12,  0xb8, 0x0e, 0x38, 0x08,  
+	0xa3, 0x1e, 0xe7, 0x22,  0x2e, 0x20, 0x38, 0x08,  
+	0x83, 0x16, 0x98, 0x00,  0x83, 0x12, 0xb8, 0x0e,  
+	0x38, 0x08, 0xa3, 0x1e,  0xe7, 0x22, 0x2e, 0x20,  
+	0xb6, 0x0b, 0x62, 0x29,  0xb7, 0x0b, 0x62, 0x29,  
+	0xa3, 0x1a, 0xaa, 0x29,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0xe7, 0x22,  0xc4, 0x0b, 0xa6, 0x29,  
+	0x10, 0x30, 0xc4, 0x00,  0xc5, 0x01, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x18,  0x45, 0x14, 0xbd, 0x0d,  
+	0xbe, 0x0d, 0x03, 0x18,  0xc5, 0x14, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x18,  0x45, 0x15, 0xc1, 0x0d,  
+	0xc2, 0x0d, 0x03, 0x18,  0xc5, 0x15, 0x26, 0x18,  
+	0xc5, 0x0e, 0x45, 0x08,  0x83, 0x16, 0x98, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0xc4, 0x0b, 0xac, 0x29,  
+	0x83, 0x16, 0xff, 0x30,  0x98, 0x00, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0xff, 0x30, 0x99, 0x00,  
+	0x83, 0x12, 0x2e, 0x20,  0x2e, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1e,  0xd7, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x2e, 0x20, 0x83, 0x16,  
+	0x10, 0x1e, 0xde, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1e,  
+	0xe5, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x2e, 0x20, 0x83, 0x16,  0x10, 0x1e, 0xec, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0x18, 0x23, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x83, 0x12, 0x2e, 0x20,  0x83, 0x16, 0x10, 0x1e,  
+	0xf2, 0x29, 0x83, 0x12,  0x2e, 0x20, 0x2e, 0x20,  
+	0x2e, 0x20, 0x1c, 0x28,  0x24, 0x18, 0x01, 0x2a,  
+	0x21, 0x22, 0x2e, 0x20,  0xfc, 0x29, 0x21, 0x22,  
+	0x2e, 0x20, 0x24, 0x18,  0x01, 0x2a, 0x24, 0x1d,  
+	0x0b, 0x2a, 0x2e, 0x20,  0x2e, 0x20, 0x2e, 0x20,  
+	0x1c, 0x28, 0x24, 0x15,  0x01, 0x30, 0x18, 0x23,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xcf, 0x0b,  0x14, 0x2a, 0x28, 0x08,  
+	0x18, 0x23, 0x23, 0x1a,  0xfc, 0x29, 0x2e, 0x20,  
+	0x2e, 0x20, 0x2e, 0x20,  0x1c, 0x28, 0x24, 0x18,  
+	0x32, 0x2a, 0x83, 0x16,  0x10, 0x1a, 0x30, 0x2a,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0x18, 0x23, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x23, 0x19, 0x4d, 0x2a,  0x83, 0x16, 0x03, 0x10,  
+	0x10, 0x1a, 0x03, 0x14,  0xa1, 0x0d, 0x03, 0x01,  
+	0x10, 0x1a, 0x01, 0x30,  0x83, 0x12, 0xa3, 0x1a,  
+	0x41, 0x2a, 0xa4, 0x18,  0xe7, 0x22, 0xb9, 0x0a,  
+	0xb9, 0x1d, 0x08, 0x00,  0x83, 0x16, 0x21, 0x08,  
+	0x83, 0x12, 0x13, 0x23,  0xb9, 0x01, 0x83, 0x16,  
+	0xa1, 0x01, 0x83, 0x12,  0x73, 0x2a, 0x39, 0x19,  
+	0x62, 0x2a, 0x83, 0x16,  0xa1, 0x01, 0x90, 0x1b,  
+	0xa1, 0x15, 0x10, 0x1b,  0x21, 0x15, 0x90, 0x1a,  
+	0xa1, 0x14, 0x10, 0x1a,  0x21, 0x14, 0x21, 0x08,  
+	0xa1, 0x0e, 0x83, 0x12,  0x39, 0x15, 0xa3, 0x1a,  
+	0x08, 0x00, 0xa4, 0x18,  0xe7, 0x22, 0x08, 0x00,  
+	0x83, 0x16, 0x90, 0x1b,  0xa1, 0x15, 0x10, 0x1b,  
+	0x21, 0x15, 0x90, 0x1a,  0xa1, 0x14, 0x10, 0x1a,  
+	0x21, 0x14, 0x21, 0x08,  0x83, 0x12, 0x13, 0x23,  
+	0xa3, 0x1a, 0x73, 0x2a,  0xa4, 0x18, 0xe7, 0x22,  
+	0xb9, 0x01, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x81, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x23, 0x1d,  0x02, 0x30, 0xb6, 0x00,  
+	0x01, 0x30, 0xb7, 0x00,  0x08, 0x00, 0x24, 0x10,  
+	0x23, 0x12, 0xa3, 0x1a,  0xe4, 0x2a, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0xe7, 0x22, 0xc4, 0x0b,  
+	0x87, 0x2a, 0x23, 0x19,  0x92, 0x2a, 0x3c, 0x08,  
+	0x13, 0x23, 0x3b, 0x08,  0x18, 0x23, 0x08, 0x00,  
+	0x04, 0x08, 0xe7, 0x00,  0x47, 0x30, 0x84, 0x00,  
+	0x08, 0x30, 0xc4, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x98, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x04, 0x30, 0xc4, 0x00,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x17, 0xc2, 0x0d,  0x03, 0x18, 0x80, 0x15,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x17, 0xc0, 0x0d,  
+	0x03, 0x18, 0x00, 0x15,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x16, 0xbe, 0x0d,  0x03, 0x18, 0x80, 0x14,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x16, 0xbc, 0x0d,  
+	0x03, 0x18, 0x00, 0x14,  0x84, 0x0a, 0xc4, 0x0b,  
+	0xa0, 0x2a, 0x04, 0x30,  0xc4, 0x00, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc1, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xbf, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbd, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbb, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0xbd, 0x2a,  0x47, 0x30, 0x84, 0x00,  
+	0x07, 0x30, 0xc4, 0x00,  0x00, 0x08, 0x13, 0x23,  
+	0x84, 0x0a, 0xc4, 0x0b,  0xdc, 0x2a, 0x00, 0x08,  
+	0x18, 0x23, 0x08, 0x00,  0x03, 0x01, 0x18, 0x23,  
+	0x08, 0x00, 0xc3, 0x00,  0xc3, 0x0c, 0xbb, 0x0d,  
+	0xbc, 0x0d, 0x03, 0x1c,  0xf1, 0x2a, 0x21, 0x30,  
+	0xbb, 0x06, 0x10, 0x30,  0xbc, 0x06, 0x23, 0x1d,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0xfc, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x05, 0x2b, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x0f, 0x2b, 0x0f, 0x08,  
+	0x08, 0x00, 0x8c, 0x1b,  0x13, 0x2b, 0x8e, 0x01,  
+	0x8d, 0x00, 0x08, 0x00,  0x8c, 0x1b, 0x18, 0x2b,  
+	0x8e, 0x0a, 0x8d, 0x00,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0x20, 0x2b,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0x28, 0x2b,  
+	0x08, 0x00
+};
+
diff --git a/cpu/arm926ejs/ns921x/fim_sdio1_9210.h b/cpu/arm926ejs/ns921x/fim_sdio1_9210.h
new file mode 100644
index 0000000..cfb9206
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_sdio1_9210.h
@@ -0,0 +1,197 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_sdio_9210.h
+ * Structure     : fim_sdio_firmware1
+ */
+
+static const unsigned char fim_sdio_firmware1[] = { 
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  
+	0xbf, 0x02, 0x00, 0x00,  0x0e, 0x28, 0x00, 0x00,  
+	0x01, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,  
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x21, 0x08,  
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,  
+	0x01, 0x30, 0x98, 0x00,  0xad, 0x22, 0x83, 0x16,  
+	0x99, 0x01, 0x19, 0x15,  0x19, 0x14, 0x83, 0x12,  
+	0x17, 0x28, 0xa4, 0x01,  0xbb, 0x01, 0xbc, 0x01,  
+	0xbd, 0x01, 0xbe, 0x01,  0xbf, 0x01, 0xc0, 0x01,  
+	0xc1, 0x01, 0xc2, 0x01,  0x83, 0x16, 0xa1, 0x01,  
+	0x83, 0x12, 0xb9, 0x01,  0x8c, 0x1d, 0x37, 0x28,  
+	0x28, 0x20, 0x17, 0x28,  0x83, 0x16, 0x98, 0x14,  
+	0x83, 0x12, 0x10, 0x08,  0xac, 0x00, 0xac, 0x0b,  
+	0x2d, 0x28, 0x83, 0x16,  0x98, 0x10, 0x83, 0x12,  
+	0x10, 0x08, 0xac, 0x00,  0xac, 0x0b, 0x34, 0x28,  
+	0x08, 0x00, 0x83, 0x16,  0x19, 0x11, 0x83, 0x12,  
+	0xa7, 0x01, 0x93, 0x22,  0xa3, 0x00, 0x93, 0x22,  
+	0xb5, 0x00, 0x93, 0x22,  0xb4, 0x00, 0xff, 0x39,  
+	0x03, 0x19, 0x47, 0x28,  0x35, 0x08, 0x01, 0x3e,  
+	0xb5, 0x00, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x93, 0x22,  
+	0x5c, 0x20, 0x93, 0x22,  0x5c, 0x20, 0x75, 0x20,  
+	0x27, 0x08, 0x5c, 0x20,  0x83, 0x16, 0x19, 0x15,  
+	0x83, 0x12, 0x23, 0x18,  0x82, 0x28, 0xa3, 0x18,  
+	0x82, 0x28, 0x2d, 0x29,  0xaa, 0x00, 0x08, 0x30,  
+	0xad, 0x00, 0xaa, 0x0d,  0x83, 0x16, 0x03, 0x18,  
+	0x65, 0x28, 0x18, 0x11,  0x66, 0x28, 0x18, 0x15,  
+	0x83, 0x12, 0x6c, 0x20,  0x28, 0x20, 0xad, 0x0b,  
+	0x5f, 0x28, 0x08, 0x00,  0xa7, 0x13, 0x03, 0x18,  
+	0xa7, 0x17, 0xa7, 0x0d,  0xa7, 0x1f, 0x08, 0x00,  
+	0x09, 0x30, 0xa7, 0x06,  0x08, 0x00, 0x07, 0x30,  
+	0xa9, 0x00, 0x03, 0x10,  0xa7, 0x0d, 0xa7, 0x1f,  
+	0x7d, 0x28, 0x09, 0x30,  0xa7, 0x06, 0xa9, 0x0b,  
+	0x77, 0x28, 0x03, 0x14,  0xa7, 0x0d, 0x08, 0x00,  
+	0x64, 0x30, 0xab, 0x00,  0xb0, 0x01, 0xa7, 0x01,  
+	0xab, 0x0b, 0x89, 0x28,  0x03, 0x29, 0x06, 0x21,  
+	0x03, 0x18, 0x86, 0x28,  0x23, 0x1a, 0xc7, 0x28,  
+	0x01, 0x30, 0xa4, 0x22,  0x03, 0x10, 0x14, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0xa3, 0x18,  0xa9, 0x28, 0x75, 0x20,  
+	0x27, 0x08, 0xa8, 0x00,  0x13, 0x21, 0x9b, 0x22,  
+	0x28, 0x08, 0xa3, 0x19,  0xa7, 0x28, 0xa4, 0x22,  
+	0x2d, 0x29, 0x9b, 0x22,  0x2d, 0x29, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x13, 0x21,  0x9b, 0x22, 0x13, 0x21,  
+	0x9b, 0x22, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x9b, 0x22,  0x28, 0x08, 0xa4, 0x22,  
+	0x2d, 0x29, 0x50, 0x30,  0x84, 0x00, 0x14, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0xa3, 0x1c, 0xfb, 0x28,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x13, 0x21,  0x80, 0x00, 0x84, 0x0a,  
+	0x13, 0x21, 0x80, 0x00,  0x84, 0x0a, 0x13, 0x21,  
+	0x80, 0x00, 0x84, 0x0a,  0x13, 0x21, 0x80, 0x00,  
+	0x84, 0x0a, 0x75, 0x20,  0x27, 0x08, 0xa8, 0x00,  
+	0x13, 0x21, 0x80, 0x00,  0x24, 0x18, 0xac, 0x29,  
+	0xbb, 0x29, 0x04, 0x30,  0xa4, 0x22, 0x17, 0x28,  
+	0x23, 0x1a, 0xd1, 0x21,  0x83, 0x16, 0x10, 0x19,  
+	0x0f, 0x29, 0x83, 0x12,  0x28, 0x20, 0x03, 0x10,  
+	0x08, 0x00, 0x83, 0x12,  0x28, 0x20, 0x03, 0x14,  
+	0x08, 0x00, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x06, 0x21,  0x6c, 0x20, 0xb0, 0x0d,  
+	0x06, 0x21, 0x6c, 0x20,  0xb0, 0x0d, 0x06, 0x21,  
+	0x6c, 0x20, 0xb0, 0x0d,  0x06, 0x21, 0x6c, 0x20,  
+	0xb0, 0x0d, 0x30, 0x08,  0x08, 0x00, 0x23, 0x1a,  
+	0xac, 0x29, 0xa3, 0x19,  0x35, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x28, 0x20,  
+	0x28, 0x20, 0xff, 0x30,  0x01, 0x30, 0x83, 0x16,  
+	0x18, 0x14, 0x19, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x28, 0x20,  
+	0x34, 0x08, 0xb6, 0x00,  0x35, 0x08, 0xb7, 0x00,  
+	0x93, 0x22, 0xb8, 0x00,  0x08, 0x30, 0xba, 0x00,  
+	0xb8, 0x1b, 0x51, 0x29,  0x83, 0x16, 0x18, 0x10,  
+	0x83, 0x12, 0x00, 0x30,  0x55, 0x29, 0x83, 0x16,  
+	0x18, 0x14, 0x83, 0x12,  0x01, 0x30, 0x6c, 0x22,  
+	0x28, 0x20, 0xb8, 0x0d,  0xba, 0x0b, 0x4a, 0x29,  
+	0x5b, 0x29, 0xb6, 0x0b,  0x46, 0x29, 0xb7, 0x0b,  
+	0x46, 0x29, 0xa3, 0x1a,  0x67, 0x29, 0x10, 0x30,  
+	0xc4, 0x00, 0x03, 0x01,  0x6c, 0x22, 0xc4, 0x0b,  
+	0x63, 0x29, 0x10, 0x30,  0xc4, 0x00, 0xc5, 0x01,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x18, 0x72, 0x29,  
+	0x83, 0x16, 0x18, 0x10,  0x83, 0x12, 0x75, 0x29,  
+	0x83, 0x16, 0x18, 0x14,  0x83, 0x12, 0x28, 0x20,  
+	0xc4, 0x0b, 0x69, 0x29,  0x83, 0x16, 0x18, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x19, 0x14,  
+	0x83, 0x12, 0x28, 0x20,  0x28, 0x20, 0xc6, 0x01,  
+	0x83, 0x16, 0x10, 0x1c,  0x87, 0x29, 0x83, 0x12,  
+	0xc6, 0x15, 0x83, 0x12,  0x28, 0x20, 0x83, 0x16,  
+	0x10, 0x1c, 0x8e, 0x29,  0x83, 0x12, 0x46, 0x15,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0x95, 0x29, 0x83, 0x12,  0xc6, 0x14, 0x83, 0x12,  
+	0x28, 0x20, 0x83, 0x16,  0x10, 0x1c, 0x9c, 0x29,  
+	0x83, 0x12, 0x46, 0x14,  0x83, 0x12, 0x46, 0x08,  
+	0xa4, 0x22, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x83, 0x12, 0x28, 0x20,  0x83, 0x16, 0x10, 0x1c,  
+	0xa2, 0x29, 0x83, 0x12,  0x28, 0x20, 0x28, 0x20,  
+	0x28, 0x20, 0x17, 0x28,  0x24, 0x18, 0xb1, 0x29,  
+	0xd1, 0x21, 0x28, 0x20,  0xac, 0x29, 0xd1, 0x21,  
+	0x28, 0x20, 0x24, 0x18,  0xb1, 0x29, 0x24, 0x1d,  
+	0xbb, 0x29, 0x28, 0x20,  0x28, 0x20, 0x28, 0x20,  
+	0x17, 0x28, 0x24, 0x15,  0x01, 0x30, 0xa4, 0x22,  
+	0x50, 0x30, 0x84, 0x00,  0x06, 0x30, 0xa3, 0x18,  
+	0x11, 0x30, 0xcf, 0x00,  0x00, 0x08, 0x9b, 0x22,  
+	0x84, 0x0a, 0xcf, 0x0b,  0xc4, 0x29, 0x28, 0x08,  
+	0xa4, 0x22, 0x23, 0x1a,  0xac, 0x29, 0x28, 0x20,  
+	0x28, 0x20, 0x28, 0x20,  0x17, 0x28, 0x24, 0x18,  
+	0xe2, 0x29, 0x83, 0x16,  0x10, 0x18, 0xe0, 0x29,  
+	0x83, 0x12, 0x24, 0x14,  0xa4, 0x14, 0x02, 0x30,  
+	0xa4, 0x22, 0x34, 0x08,  0xb6, 0x00, 0x35, 0x08,  
+	0xb7, 0x00, 0x08, 0x00,  0x83, 0x12, 0x08, 0x00,  
+	0x83, 0x16, 0x03, 0x10,  0x10, 0x18, 0x03, 0x14,  
+	0xa1, 0x0d, 0x03, 0x01,  0x10, 0x18, 0x01, 0x30,  
+	0x83, 0x12, 0xa3, 0x1a,  0xef, 0x29, 0xa4, 0x18,  
+	0x6c, 0x22, 0xb9, 0x0a,  0xb9, 0x1d, 0x08, 0x00,  
+	0x83, 0x16, 0x21, 0x08,  0x83, 0x12, 0x9b, 0x22,  
+	0xb9, 0x01, 0x83, 0x16,  0xa1, 0x01, 0x83, 0x12,  
+	0xfb, 0x29, 0xb6, 0x0b,  0x08, 0x00, 0xb7, 0x0b,  
+	0x08, 0x00, 0xa4, 0x1c,  0x08, 0x2a, 0xa4, 0x10,  
+	0x08, 0x30, 0x02, 0x30,  0xb6, 0x00, 0x01, 0x30,  
+	0xb7, 0x00, 0x08, 0x00,  0x24, 0x10, 0x23, 0x12,  
+	0xa3, 0x1a, 0x69, 0x2a,  0x10, 0x30, 0xc4, 0x00,  
+	0x03, 0x01, 0x6c, 0x22,  0xc4, 0x0b, 0x0e, 0x2a,  
+	0x3c, 0x08, 0x9b, 0x22,  0x3b, 0x08, 0xa4, 0x22,  
+	0x08, 0x00, 0x04, 0x08,  0xe7, 0x00, 0x47, 0x30,  
+	0x84, 0x00, 0x08, 0x30,  0xc4, 0x00, 0x80, 0x01,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x1d, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x04, 0x30,  0xc4, 0x00, 0xc2, 0x0d,  
+	0x03, 0x18, 0x80, 0x17,  0xc2, 0x0d, 0x03, 0x18,  
+	0x80, 0x15, 0xc0, 0x0d,  0x03, 0x18, 0x00, 0x17,  
+	0xc0, 0x0d, 0x03, 0x18,  0x00, 0x15, 0xbe, 0x0d,  
+	0x03, 0x18, 0x80, 0x16,  0xbe, 0x0d, 0x03, 0x18,  
+	0x80, 0x14, 0xbc, 0x0d,  0x03, 0x18, 0x00, 0x16,  
+	0xbc, 0x0d, 0x03, 0x18,  0x00, 0x14, 0x84, 0x0a,  
+	0xc4, 0x0b, 0x25, 0x2a,  0x04, 0x30, 0xc4, 0x00,  
+	0xc1, 0x0d, 0x03, 0x18,  0x80, 0x17, 0xc1, 0x0d,  
+	0x03, 0x18, 0x80, 0x15,  0xbf, 0x0d, 0x03, 0x18,  
+	0x00, 0x17, 0xbf, 0x0d,  0x03, 0x18, 0x00, 0x15,  
+	0xbd, 0x0d, 0x03, 0x18,  0x80, 0x16, 0xbd, 0x0d,  
+	0x03, 0x18, 0x80, 0x14,  0xbb, 0x0d, 0x03, 0x18,  
+	0x00, 0x16, 0xbb, 0x0d,  0x03, 0x18, 0x00, 0x14,  
+	0x84, 0x0a, 0xc4, 0x0b,  0x42, 0x2a, 0x47, 0x30,  
+	0x84, 0x00, 0x07, 0x30,  0xc4, 0x00, 0x00, 0x08,  
+	0x9b, 0x22, 0x84, 0x0a,  0xc4, 0x0b, 0x61, 0x2a,  
+	0x00, 0x08, 0xa4, 0x22,  0x08, 0x00, 0x03, 0x01,  
+	0xa4, 0x22, 0x08, 0x00,  0xc3, 0x00, 0xc3, 0x0c,  
+	0xbb, 0x0d, 0xbc, 0x0d,  0x03, 0x1c, 0x76, 0x2a,  
+	0x21, 0x30, 0xbb, 0x06,  0x10, 0x30, 0xbc, 0x06,  
+	0x08, 0x00, 0xc3, 0x0c,  0xbd, 0x0d, 0xbe, 0x0d,  
+	0x03, 0x1c, 0x80, 0x2a,  0x21, 0x30, 0xbd, 0x06,  
+	0x10, 0x30, 0xbe, 0x06,  0xc3, 0x0c, 0xbf, 0x0d,  
+	0xc0, 0x0d, 0x03, 0x1c,  0x89, 0x2a, 0x21, 0x30,  
+	0xbf, 0x06, 0x10, 0x30,  0xc0, 0x06, 0xc3, 0x0c,  
+	0xc1, 0x0d, 0xc2, 0x0d,  0x03, 0x1c, 0x08, 0x00,  
+	0x21, 0x30, 0xc1, 0x06,  0x10, 0x30, 0xc2, 0x06,  
+	0x08, 0x00, 0x8c, 0x19,  0x93, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x0f, 0x08,  0x00, 0x00, 0x8b, 0x17,  
+	0x08, 0x00, 0x8c, 0x1b,  0x9b, 0x2a, 0x8b, 0x13,  
+	0x00, 0x00, 0x8e, 0x01,  0x8d, 0x00, 0x00, 0x00,  
+	0x8b, 0x17, 0x08, 0x00,  0x8c, 0x1b, 0xa4, 0x2a,  
+	0x8b, 0x13, 0x00, 0x00,  0x8e, 0x0a, 0x8d, 0x00,  
+	0x00, 0x00, 0x8b, 0x17,  0x08, 0x00, 0x83, 0x12,  
+	0x20, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0x80, 0x3c,  0x03, 0x1d, 0xb0, 0x2a,  
+	0xa0, 0x30, 0x84, 0x00,  0x80, 0x01, 0x84, 0x0a,  
+	0x04, 0x08, 0xff, 0x3c,  0x03, 0x1d, 0xb8, 0x2a,  
+	0x08, 0x00
+};
+
diff --git a/cpu/arm926ejs/ns921x/fim_serial.c b/cpu/arm926ejs/ns921x/fim_serial.c
new file mode 100644
index 0000000..590e40e
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_serial.c
@@ -0,0 +1,279 @@
+/*
+ * cpu/arm926ejs/ns921x/fims/fim_serial.c
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version2  as published by
+ * the Free Software Foundation.
+ *
+ * !Revision:   $Revision$
+ * !Author:     Luis Galdos
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ */
+
+#include <common.h>
+#include <configs/userconfig.h>
+
+#ifdef CONFIG_NS921X_FIM_UART
+
+#include <serial.h>             /* serial_device */
+
+#include <asm/arch/ns921x_sys.h>
+#include <asm/arch/ns921x_hub.h>
+#include <asm/arch/ns921x_gpio.h>
+#include <asm/arch/io.h>  /* gpio_readl */
+#include <asm/arch/ns921x_fim.h>
+
+#include "fim_serial.h"
+
+/* Depending on the processor we have different offset */
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+# define FIM_GPIO_OFFSET	68
+#elif defined(CONFIG_CME9210)
+# define FIM_GPIO_OFFSET	0
+#else
+# error "Invalid platform. Couldn't define FIM_GPIO_OFFSET"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* It must be a constant */
+const static int pic_num = CONFIG_UBOOT_FIM_UART_PIC_NUM;
+static unsigned int secByte = 0;
+
+extern const unsigned char fim_serial_firmware[];
+
+void fim_serial_setbrg( void)
+{
+	unsigned int div, prescale = 1;
+	unsigned long clock;
+	int cnt;
+	unsigned int bit_time;
+
+	clock = ahb_clock_freq();
+	clock = (clock * 4) / gd->baudrate;
+	div = (clock / 256) + 1;
+
+	/* Must round up to next power of 2 (see NET+OS driver) */
+	for (cnt = 1; cnt <= 8; cnt++) {
+		if (div < (unsigned int)(1 << cnt)) {
+			div = 1 << cnt;
+			prescale = cnt - 1;
+			break;
+		}
+	}
+
+	/* The Net+OS driver has another calculation of the bit time */
+	bit_time = (clock / div) - 1;
+
+	/* Set the bit time */
+	fim_set_ctrl_reg(pic_num, 0, bit_time);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_BIT_TIME);
+
+	/* Set the prescale value */
+	fim_set_ctrl_reg(pic_num, 0, prescale);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_PRESCALE);
+}
+
+static int fim_sw_flowctrl(void)
+{
+	unsigned short start_match, stop_match;
+
+	start_match = 1;
+	stop_match = 1;
+
+	fim_set_ctrl_reg(pic_num, 0, 0xff);
+	fim_set_ctrl_reg(pic_num, 1, 0xff);
+	fim_set_ctrl_reg(pic_num, 2, 0xff);
+	fim_set_ctrl_reg(pic_num, 3, 0xff);
+	fim_set_ctrl_reg(pic_num, 4, 0x00);
+	fim_set_ctrl_reg(pic_num, 5, 0x00);
+
+	/* Now send the interrupt for the SW flow control */
+	if(fim_send_interrupt(pic_num, FIM_SERIAL_INT_MATCH_CHAR))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Check if there is new input data to get from the RX-FIFO
+ */
+int fim_serial_tstc(void)
+{
+	unsigned int regval;
+
+	regval = fim_get_iohub_reg(pic_num, HUB_INT);
+
+	return (regval & HUB_INT_RX_FIFO_EMPTY) ? 0 : 1;
+}
+
+int fim_serial_isr(int pic_num)
+{
+	unsigned int regval;
+	int bytes;
+
+	/* Was a second character read before from FIFO */
+	if(secByte) {
+		regval = secByte;
+		secByte = 0;
+
+		return regval;
+	}
+
+	/* If the RX-FIFO is empty then returns */
+	do {
+	  regval = fim_get_iohub_reg(pic_num, HUB_INT);
+	} while (regval & HUB_INT_RX_FIFO_EMPTY);
+
+	regval = fim_get_iohub_reg(pic_num, HUB_RX_FIFO_STAT);
+	bytes = HUB_RX_FIFO_BYTE(regval);
+
+	regval = fim_get_iohub_reg(pic_num, HUB_RX_FIFO);
+	/* The FIM firmware always sends two bytes per data byte:
+	 * - The first byte is the data itself
+	 * - The second byte contains information about the serial
+	 * communication (data bits, parity, stop bits).
+	 * The direct IO HUB FIFO is 32 bits long, this means it
+	 * can buffer 4 bytes. Considering the 1-byte overhead
+	 * described above for each data byte, this means:
+	 * if the 'bytes' field of FIFO stat register contains a
+	 * value of 2, we have 1 data byte. If it contains a
+	 * value of 4, we have 2 data bytes. */
+
+	/* Get the second data byte and skip the FIM overhead byte */
+	if (bytes == 4)
+		secByte = (regval & 0xff0000) >> 16;
+
+	/* Return the first data byte */
+	return regval & 0xFF;
+}
+
+int fim_serial_getc(void)
+{
+	return fim_serial_isr(pic_num);
+}
+
+/*
+ * Send a char over an interrupt
+ */
+void fim_serial_putc( const char ch)
+{
+	unsigned int status;
+	unsigned short data = 1;
+
+	if( '\n' == ch ) {
+		fim_serial_putc('\r');
+	}
+
+	/* Check if the PIC is tasked with another send-char request */
+	do {
+		status = fim_get_exp_reg(pic_num, 0);
+	} while (status & FIM_SERIAL_INT_INSERT_CHAR);
+
+	data = (data << FIM_SERIAL_DATA_BITS) | (ch & ((1 << FIM_SERIAL_DATA_BITS) - 1));
+
+	/* And send the char using the interrupt function */
+	fim_set_ctrl_reg(pic_num, 0, data & 0xFF);
+	fim_set_ctrl_reg(pic_num, 1, (data >> 8) & 0xFF);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_INSERT_CHAR);
+
+}
+
+int fim_serial_init(void)
+{
+	unsigned int regval;
+	printf("Loading serial firmware\n");
+	if(fim_core_init(pic_num, fim_serial_firmware))
+		return 1;
+
+	/* Init the register of the PIC */
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG, 0x00);
+
+	/* Set the GPIOs offset */
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_TXIO_REG,
+			 1 << (FIM_UART_TX - FIM_GPIO_OFFSET));
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_RXIO_REG,
+			 1 << (FIM_UART_RX - FIM_GPIO_OFFSET));
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_BIT_POS);
+
+	fim_set_ctrl_reg(pic_num, 0, 0xFF);
+	fim_set_ctrl_reg(pic_num, 1, 0xFF);
+	fim_set_ctrl_reg(pic_num, 2, 0xFF);
+	fim_set_ctrl_reg(pic_num, 3, 0xFF);
+	fim_set_ctrl_reg(pic_num, 4, 0x00);
+	fim_set_ctrl_reg(pic_num, 5, 0x00);
+	fim_send_interrupt(pic_num, FIM_SERIAL_INT_MATCH_CHAR);
+
+	/* Configure the GPIOs */
+	gpio_cfg_set(FIM_UART_RX, GPIO_CFG_FUNC_FIM_UART);
+	gpio_cfg_set(FIM_UART_TX, GPIO_CFG_FUNC_FIM_UART);
+
+	fim_set_ctrl_reg(pic_num, 0, FIM_SERIAL_TOTAL_BITS);
+	if(fim_send_interrupt(pic_num, FIM_SERIAL_INT_BITS_CHAR))
+		return 1;
+
+	/* Configure the software flow control */
+	if(fim_sw_flowctrl())
+		return 1;
+
+	/* Now set the control status register to the correct value */
+	regval = fim_get_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG);
+	if(regval < 0)
+		return 1;
+	regval &= ~FIM_SERIAL_STAT_HW_FLOW;
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG, regval);
+
+
+	/* After each reconfiguration we need to re-init the FIM-firmware */
+	regval = fim_get_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG);
+	if(regval < 0)
+		return 1;
+	fim_set_ctrl_reg(pic_num, FIM_SERIAL_CTRL_REG,
+			 regval | FIM_SERIAL_STAT_TX_ENABLE | FIM_SERIAL_STAT_COMPLETE);
+
+	/* baudrate configure before get lost */
+	fim_serial_setbrg();
+
+	/*
+	 * IMPORTANT: Configure the FIM in direct mode, otherwise the other FIM
+	 * probably doesn't work when it tries to use the DMA-engine!
+	 */
+	fim_set_iohub_reg(pic_num, HUB_DMA_RX_CTRL, HUB_DMA_RX_CTRL_DIRECT);
+	fim_set_iohub_reg(pic_num, HUB_DMA_TX_CTRL, HUB_DMA_TX_CTRL_DIRECT);
+	/* fim_set_iohub_reg(pic_num, HUB_RX_INT, 0x20000000); */
+	/* regval = fim_get_iohub_reg(pic_num, HUB_DMA_RX_CTRL); */
+	/* fim_set_iohub_reg(pic_num, HUB_DMA_RX_CTRL, regval | 0x10000000); */
+
+	return 0;
+}
+
+static void fim_serial_tx_flush( void )
+{
+	/* Dummy */
+}
+
+/**
+ * fim_serial_puts - outputs a zero terminated string
+ */
+static void fim_serial_puts( const char* szMsg )
+{
+	while( *szMsg )
+		fim_serial_putc( *szMsg++ );
+}
+
+struct serial_device fim_serial_device = {
+
+	.name     = "fim_serial",
+	.init     = fim_serial_init ,
+	.setbrg   = fim_serial_setbrg,
+	.getc     = fim_serial_getc,
+	.tstc     = fim_serial_tstc,
+	.putc     = fim_serial_putc,
+	.puts     = fim_serial_puts,
+	.tx_flush = fim_serial_tx_flush
+};
+
+#endif  /* CONFIG_NS921X_FIM_UART */
diff --git a/cpu/arm926ejs/ns921x/fim_serial.h b/cpu/arm926ejs/ns921x/fim_serial.h
new file mode 100644
index 0000000..6cf4806
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/fim_serial.h
@@ -0,0 +1,189 @@
+
+/*
+ * Automatic generated header file with the firmware code for the FIM
+ * Input binary  : fim_firmware.bin
+ * Output header : fim_uart.h
+ * Structure     : fim_serial_firmware
+ */
+
+static const unsigned char fim_serial_firmware[] = {
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
+	0x16, 0x02, 0x00, 0x00,  0x62, 0x28, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,  0xa0, 0x00, 0x03, 0x08,
+	0x83, 0x12, 0xa1, 0x00,  0x8b, 0x10, 0x83, 0x16,
+	0x09, 0x18, 0x19, 0x28,  0x89, 0x18, 0x21, 0x28,
+	0x09, 0x19, 0x2f, 0x28,  0x89, 0x19, 0x33, 0x28,
+	0x09, 0x1a, 0x39, 0x28,  0x89, 0x1a, 0x4f, 0x28,
+	0x09, 0x1b, 0x57, 0x28,  0x18, 0x28, 0x83, 0x12,
+	0x18, 0x14, 0x10, 0x08,  0xc0, 0x00, 0x11, 0x08,
+	0xc1, 0x00, 0x25, 0x14,  0x5b, 0x28, 0x83, 0x12,
+	0x10, 0x08, 0xc2, 0x00,  0x11, 0x08, 0xc3, 0x00,
+	0x12, 0x08, 0xc4, 0x00,  0x13, 0x08, 0xc5, 0x00,
+	0x14, 0x08, 0xc6, 0x00,  0x15, 0x08, 0xc7, 0x00,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xc8, 0x00,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xb5, 0x00,
+	0x11, 0x08, 0xb6, 0x00,  0x5b, 0x28, 0x83, 0x12,
+	0x10, 0x08, 0xbc, 0x00,  0x11, 0x08, 0xbd, 0x00,
+	0x12, 0x08, 0xbe, 0x00,  0x13, 0x08, 0xbf, 0x00,
+	0x3c, 0x08, 0x83, 0x16,  0x98, 0x00, 0x83, 0x12,
+	0xa9, 0x00, 0x3e, 0x08,  0xa9, 0x04, 0x29, 0x08,
+	0xff, 0x3a, 0x83, 0x16,  0x99, 0x00, 0x83, 0x12,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0x07, 0x39,
+	0x83, 0x16, 0x81, 0x00,  0x01, 0x17, 0x83, 0x12,
+	0x5b, 0x28, 0x83, 0x12,  0x10, 0x08, 0xc9, 0x00,
+	0x5b, 0x28, 0x89, 0x17,  0xa4, 0x14, 0x21, 0x08,
+	0x83, 0x00, 0xa0, 0x0e,  0x20, 0x0e, 0x09, 0x00,
+	0x8b, 0x17, 0x0b, 0x16,  0x83, 0x16, 0x01, 0x17,
+	0x83, 0x12, 0x04, 0x22,  0x98, 0x01, 0xb0, 0x30,
+	0xb8, 0x00, 0xb9, 0x00,  0xa4, 0x18, 0xf1, 0x21,
+	0x16, 0x1c, 0x6c, 0x28,  0x71, 0x28, 0x7e, 0x20,
+	0x86, 0x28, 0x4e, 0x21,  0x7e, 0x20, 0x4e, 0x21,
+	0x7e, 0x20, 0x4e, 0x21,  0x24, 0x18, 0xe8, 0x21,
+	0xa4, 0x18, 0xf1, 0x21,  0x7e, 0x20, 0x08, 0x00,
+	0x22, 0x1c, 0x82, 0x28,  0xa2, 0x20, 0x08, 0x00,
+	0xa2, 0x19, 0x21, 0x21,  0xfd, 0x20, 0x08, 0x00,
+	0x23, 0x1c, 0x8a, 0x28,  0x79, 0x21, 0x71, 0x28,
+	0x73, 0x20, 0x16, 0x1d,  0x93, 0x28, 0x3f, 0x08,
+	0x83, 0x16, 0x10, 0x05,  0x83, 0x12, 0x03, 0x1d,
+	0x71, 0x28, 0x25, 0x1c,  0x9d, 0x28, 0x40, 0x08,
+	0xaa, 0x00, 0x41, 0x08,  0xb7, 0x00, 0x25, 0x10,
+	0x18, 0x10, 0xc7, 0x21,  0x71, 0x28, 0x96, 0x1c,
+	0x71, 0x28, 0x8c, 0x1d,  0xbf, 0x21, 0x71, 0x28,
+	0x01, 0x08, 0xa8, 0x00,  0x22, 0x1d, 0xab, 0x28,
+	0xa8, 0x1b, 0xab, 0x28,  0xa2, 0x1c, 0xb5, 0x28,
+	0xa2, 0x10, 0x22, 0x11,  0xa8, 0x1b, 0x22, 0x15,
+	0xa2, 0x18, 0x08, 0x00,  0x31, 0x08, 0x28, 0x02,
+	0x03, 0x18, 0xb5, 0x28,  0x08, 0x00, 0x22, 0x11,
+	0xb1, 0x1b, 0x22, 0x15,  0x49, 0x08, 0xb1, 0x07,
+	0x03, 0x1c, 0xbd, 0x28,  0xa2, 0x14, 0x22, 0x1e,
+	0xc1, 0x28, 0x22, 0x12,  0x08, 0x00, 0x03, 0x10,
+	0x3d, 0x08, 0x83, 0x16,  0x10, 0x05, 0x83, 0x12,
+	0x03, 0x19, 0xc9, 0x28,  0x03, 0x14, 0xab, 0x0c,
+	0xad, 0x0b, 0xe1, 0x28,  0x23, 0x18, 0x79, 0x21,
+	0x2b, 0x08, 0xae, 0x00,  0x96, 0x1d, 0xd7, 0x28,
+	0x2b, 0x08, 0x46, 0x05,  0x42, 0x02, 0x03, 0x19,
+	0x26, 0x14, 0x16, 0x1e,  0xde, 0x28, 0x2b, 0x08,
+	0x46, 0x05, 0x44, 0x02,  0x03, 0x19, 0xa6, 0x14,
+	0xab, 0x01, 0x08, 0x30,  0xad, 0x00, 0xac, 0x0b,
+	0x08, 0x00, 0x23, 0x18,  0x79, 0x21, 0xa2, 0x15,
+	0x35, 0x08, 0xb3, 0x00,  0x36, 0x08, 0xb4, 0x00,
+	0x22, 0x10, 0x26, 0x1c,  0xf4, 0x28, 0x26, 0x10,
+	0x2b, 0x08, 0x47, 0x05,  0x43, 0x02, 0x03, 0x19,
+	0xe2, 0x21, 0x08, 0x00,  0xa6, 0x1c, 0x08, 0x00,
+	0xa6, 0x10, 0x2b, 0x08,  0x47, 0x05, 0x45, 0x02,
+	0x03, 0x19, 0xe5, 0x21,  0x08, 0x00, 0x3d, 0x08,
+	0x83, 0x16, 0x10, 0x05,  0x83, 0x12, 0x03, 0x1d,
+	0x20, 0x29, 0x01, 0x08,  0xa8, 0x00, 0x23, 0x18,
+	0x79, 0x21, 0xa2, 0x1d,  0x0a, 0x29, 0x29, 0x21,
+	0xa2, 0x01, 0x22, 0x14,  0x22, 0x16, 0xa8, 0x1b,
+	0x22, 0x15, 0x48, 0x08,  0xac, 0x00, 0xac, 0x19,
+	0x08, 0x30, 0xad, 0x00,  0xab, 0x01, 0x03, 0x10,
+	0x49, 0x0c, 0xa9, 0x00,  0x0a, 0x30, 0x29, 0x02,
+	0x28, 0x07, 0xb1, 0x00,  0x03, 0x1c, 0x1f, 0x29,
+	0xa2, 0x14, 0x08, 0x00,  0x08, 0x00, 0xb3, 0x0b,
+	0x08, 0x00, 0xb4, 0x0b,  0x08, 0x00, 0xa2, 0x11,
+	0x2b, 0x14, 0x29, 0x21,  0x08, 0x00, 0x38, 0x08,
+	0xba, 0x00, 0xba, 0x0a,  0x03, 0x1d, 0x30, 0x29,
+	0xb0, 0x30, 0xba, 0x00,  0x3a, 0x08, 0x39, 0x02,
+	0x03, 0x1d, 0x36, 0x29,  0xdd, 0x21, 0x08, 0x00,
+	0x3a, 0x08, 0xbb, 0x00,  0xbb, 0x0a, 0x03, 0x1d,
+	0x3d, 0x29, 0xb0, 0x30,  0xbb, 0x00, 0x3b, 0x08,
+	0x39, 0x02, 0x03, 0x1d,  0x43, 0x29, 0xdd, 0x21,
+	0x08, 0x00, 0x38, 0x08,  0x84, 0x00, 0x2e, 0x08,
+	0x80, 0x00, 0x3a, 0x08,  0x84, 0x00, 0x2b, 0x08,
+	0x80, 0x00, 0x3b, 0x08,  0xb8, 0x00, 0x08, 0x00,
+	0x8c, 0x1b, 0x74, 0x29,  0x3e, 0x08, 0xff, 0x3a,
+	0x83, 0x16, 0x98, 0x05,  0x83, 0x12, 0x39, 0x08,
+	0x38, 0x02, 0x03, 0x19,  0x08, 0x00, 0x39, 0x08,
+	0x84, 0x00, 0x00, 0x08,  0x39, 0x1c, 0x67, 0x29,
+	0x00, 0x1c, 0x67, 0x29,  0x8b, 0x13, 0x00, 0x00,
+	0x8e, 0x0a, 0x8d, 0x00,  0x00, 0x00, 0x8b, 0x17,
+	0x6e, 0x29, 0x8b, 0x13,  0x00, 0x00, 0x8e, 0x01,
+	0x8d, 0x00, 0x00, 0x00,  0x8b, 0x17, 0x6e, 0x29,
+	0xb9, 0x0a, 0x03, 0x1d,  0x08, 0x00, 0xb0, 0x30,
+	0xb9, 0x00, 0x08, 0x00,  0x3e, 0x08, 0x83, 0x16,
+	0x98, 0x04, 0x83, 0x12,  0x08, 0x00, 0x01, 0x08,
+	0xa7, 0x00, 0x23, 0x1d,  0x82, 0x29, 0xa7, 0x1b,
+	0x82, 0x29, 0xa3, 0x1c,  0x8c, 0x29, 0xa3, 0x10,
+	0x23, 0x11, 0xa7, 0x1b,  0x23, 0x15, 0xa3, 0x18,
+	0x08, 0x00, 0x27, 0x08,  0x32, 0x02, 0x03, 0x1c,
+	0x8c, 0x29, 0x08, 0x00,  0xa3, 0x1d, 0xa0, 0x29,
+	0x3c, 0x08, 0x83, 0x16,  0x98, 0x04, 0x83, 0x12,
+	0x23, 0x1a, 0x9e, 0x29,  0x23, 0x16, 0x23, 0x11,
+	0xb2, 0x1b, 0x23, 0x15,  0x49, 0x08, 0xb2, 0x07,
+	0x03, 0x1c, 0x9d, 0x29,  0xa3, 0x14, 0x08, 0x00,
+	0x23, 0x10, 0x08, 0x00,  0x3c, 0x08, 0x2a, 0x1c,
+	0xa7, 0x29, 0x83, 0x16,  0x98, 0x04, 0x83, 0x12,
+	0xab, 0x29, 0xff, 0x3a,  0x83, 0x16, 0x98, 0x05,
+	0x83, 0x12, 0xaa, 0x0c,  0x23, 0x11, 0xb2, 0x1b,
+	0x23, 0x15, 0x49, 0x08,  0xb2, 0x07, 0x03, 0x1c,
+	0xb4, 0x29, 0xa3, 0x14,  0xaf, 0x0b, 0xb8, 0x29,
+	0xa3, 0x15, 0x08, 0x00,  0xb0, 0x0b, 0x08, 0x00,
+	0x37, 0x08, 0xaa, 0x00,  0x08, 0x30, 0xb0, 0x00,
+	0x08, 0x00, 0xfc, 0x21,  0xaa, 0x00, 0x09, 0x30,
+	0x48, 0x02, 0x03, 0x1c,  0xc7, 0x29, 0xfc, 0x21,
+	0xb7, 0x00, 0x48, 0x08,  0xaf, 0x00, 0x08, 0x30,
+	0xb0, 0x00, 0xa3, 0x01,  0x23, 0x14, 0x01, 0x08,
+	0xb2, 0x00, 0x23, 0x11,  0xb2, 0x1b, 0x23, 0x15,
+	0x49, 0x08, 0xb2, 0x07,  0x03, 0x1c, 0xd7, 0x29,
+	0xa3, 0x14, 0x3c, 0x08,  0xff, 0x3a, 0x83, 0x16,
+	0x98, 0x05, 0x83, 0x12,  0x08, 0x00, 0x24, 0x18,
+	0x08, 0x00, 0x09, 0x15,  0x24, 0x14, 0x08, 0x00,
+	0x09, 0x14, 0x24, 0x14,  0x08, 0x00, 0x89, 0x14,
+	0x24, 0x14, 0x08, 0x00,  0x83, 0x16, 0x89, 0x1f,
+	0xfa, 0x29, 0x83, 0x12,  0x17, 0x08, 0xff, 0x3a,
+	0x89, 0x05, 0x24, 0x10,  0x08, 0x00, 0x83, 0x16,
+	0x09, 0x08, 0x7f, 0x39,  0x03, 0x1d, 0xfa, 0x29,
+	0x83, 0x12, 0x89, 0x13,  0xa4, 0x10, 0x08, 0x00,
+	0x83, 0x12, 0x08, 0x00,  0x8c, 0x19, 0xfc, 0x29,
+	0x8b, 0x13, 0x00, 0x00,  0x0f, 0x08, 0x00, 0x00,
+	0x8b, 0x17, 0x08, 0x00,  0x83, 0x12, 0x20, 0x30,
+	0x84, 0x00, 0x80, 0x01,  0x84, 0x0a, 0x04, 0x08,
+	0x80, 0x3c, 0x03, 0x1d,  0x07, 0x2a, 0xa0, 0x30,
+	0x84, 0x00, 0x80, 0x01,  0x84, 0x0a, 0x04, 0x08,
+	0xff, 0x3c, 0x03, 0x1d,  0x0f, 0x2a, 0x08, 0x00
+
+};
+
+/* Firmware-dependent interrupts from the ARM to the FIM */
+#define FIM_SERIAL_INT_INSERT_CHAR		0x01
+#define FIM_SERIAL_INT_MATCH_CHAR		0x02
+#define FIM_SERIAL_INT_BITS_CHAR		0x04
+#define FIM_SERIAL_INT_CHAR_GAP 		0x08
+#define FIM_SERIAL_INT_BIT_POS			0x10
+#define FIM_SERIAL_INT_PRESCALE			0x20
+#define FIM_SERIAL_INT_BIT_TIME 		0x40
+
+/* Interrupts from the FIM to the driver */
+#define FIM_INT_FROM_MATCH_CHAR1		0x01
+#define FIM_INT_FROM_MATCH_CHAR2		0x02
+#define FIM_INT_FROM_RX_OVERFLOW		0x04
+
+/* FIM status */
+#define FIM_SERIAL_STAT_COMPLETE		0x01
+#define FIM_SERIAL_STAT_TX_ENABLE		0x02
+#define FIM_SERIAL_STAT_HW_FLOW 		0x04
+#define FIM_SERIAL_STAT_MATCH_CHAR1		0x08
+#define FIM_SERIAL_STAT_MATCH_CHAR2		0x10
+
+/* Special control registers */
+#define FIM_SERIAL_TXIO_REG                     0
+#define FIM_SERIAL_RXIO_REG                     1
+#define FIM_SERIAL_CTRL_REG			6
+
+/* Default port configuration */
+#define FIM_SERIAL_DATA_BITS			8
+#define FIM_SERIAL_STOP_BITS			1
+#define FIM_SERIAL_PARITY_BITS			0
+#define FIM_SERIAL_TOTAL_BITS			(FIM_SERIAL_DATA_BITS + \
+						 FIM_SERIAL_STOP_BITS + \
+						 FIM_SERIAL_PARITY_BITS)
+
diff --git a/cpu/arm926ejs/ns921x/ns921x_edt.c b/cpu/arm926ejs/ns921x/ns921x_edt.c
new file mode 100644
index 0000000..ef4443d
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/ns921x_edt.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2009 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <lcd.h>
+#include <asm-arm/io.h>
+#include <asm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm/arch-ns9xxx/io.h>
+#include <asm/arch-ns9xxx/ns921x_sys.h>
+#include <asm/arch-ns9xxx/ns9xxx_mem.h>
+#include <partition.h>
+#include <nvram.h>
+#include <linux/mtd/compat.h>
+#if  (CONFIG_COMMANDS & CFG_CMD_BSP && defined(CONFIG_DIGI_CMD))
+# include "../../../common/digi/cmd_bsp.h"
+#endif
+
+#define EDTQVGA_DISPLAY              \
+{                                    \
+       .name           = "EDTQVGA",  \
+       .vl_col         = 320,        \
+       .vl_row         = 240,        \
+       .vl_bpix        = LCD_BPP     \
+}
+
+#ifdef CONFIG_LCD
+
+#define LCD_CS_OFFSET	0x40000000
+#define	LCD_POINTER	LCD_CS_OFFSET
+#define LCD_DATA	(LCD_CS_OFFSET + 2)
+#define GPIO_RESET_LCD	86
+#define GPIO_ENABLE_LCD	87
+
+struct vidinfo panel_info = EDTQVGA_DISPLAY;
+
+/* Externally used variables */
+void *lcd_base;				/* Start of framebuffer memory	*/
+void *lcd_console_address;		/* Start of console buffer	*/
+short console_col;
+short console_row;
+int lcd_line_length;
+int lcd_color_fg;
+int lcd_color_bg;
+int display_initialized = 0;
+
+int lcd_display_init(void);
+void lcd_ctrl_init( void *lcdbase );
+void lcd_enable( void );
+static int edtdisplay_init_mem( void *lcdbase );
+static int edtdisplay_init( void *lcdbase );
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static void write_lcd_reg(uint addr, uint data)
+{
+	writew(addr, LCD_POINTER);
+	writew(data, LCD_DATA);
+}
+
+static void mdelay(int count)
+{
+	for(;count != 0;count--)
+		udelay(1000);
+}
+
+int lcd_display_init(void)
+{
+	display_initialized = 1;
+	return 0;
+}
+
+void config_cs(void)
+{
+	int cs = 0;
+	unsigned int reg;
+
+	/* CS configuration */
+	writel(0x3,   MEM_BASE_PA + MEM_STAT_EXT_WAIT);
+	writel(0x181, MEM_BASE_PA + MEM_STAT_CFG(cs));
+	writel(0x4,   MEM_BASE_PA + MEM_STAT_WAIT_WEN(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_WAIT_OEN(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_RD(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_PAGE(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_WR(cs));
+	writel(0x0,   MEM_BASE_PA + MEM_STAT_TURN(cs));
+	/* Enable CS */
+	reg = readl(SYS_BASE_PA + SYS_CS_STATIC_BASE(cs));
+	writel(reg | 0x1, SYS_BASE_PA + SYS_CS_STATIC_BASE(cs));
+}
+
+void lcd_reset(void)
+{
+	gpio_cfg_set(GPIO_RESET_LCD,
+		     GPIO_CFG_FUNC_GPIO | GPIO_CFG_OUTPUT);
+	gpio_ctrl_set(GPIO_RESET_LCD, 0);
+	mdelay(100);
+	gpio_ctrl_set(GPIO_RESET_LCD, 1);
+}
+
+/* Configuration for the EDT QVGA display, most of the settings have
+ * been taken from a Himax application note */
+unsigned char edt_qvga_lcd_init[][3] = {
+	/* Index, value, delay to write next register in ms*/
+	{0x46, 0x94, 0},
+	{0x47, 0x41, 0},
+	{0x48, 0x00, 0},
+	{0x49, 0x33, 0},
+	{0x4a, 0x23, 0},
+	{0x4b, 0x45, 0},
+	{0x4c, 0x44, 0},
+	{0x4d, 0x77, 0},
+	{0x4e, 0x12, 0},
+	{0x4f, 0xcc, 0},
+	{0x50, 0x46, 0},
+	{0x51, 0x82, 0},
+	{0x02, 0x00, 0},	/* Column address start 2 */
+	{0x03, 0x00, 0},	/* Column address start 1 */
+	{0x04, 0x01, 0},	/* Column address end 2 */
+	{0x05, 0x3f, 0},	/* Column address end 1 */
+	{0x06, 0x00, 0},	/* Row address start 2 */
+	{0x07, 0x00, 0},	/* Row address start 1 */
+	{0x08, 0x00, 0},	/* Row address end 2 */
+	{0x09, 0xef, 0},	/* Row address end 1 */
+	{0x01, 0x06, 0},
+	{0x16, 0x68, 0},
+	{0x23, 0x95, 0},
+	{0x24, 0x95, 0},
+	{0x25, 0xff, 0},
+	{0x27, 0x02, 0},
+	{0x28, 0x02, 0},
+	{0x29, 0x02, 0},
+	{0x2a, 0x02, 0},
+	{0x2c, 0x02, 0},
+	{0x2d, 0x02, 0},
+	{0x3a, 0x01, 0},
+	{0x3b, 0x01, 0},
+	{0x3c, 0xf0, 0},
+	{0x3d, 0x00, 20},
+	{0x35, 0x38, 0},
+	{0x36, 0x78, 0},
+	{0x3e, 0x38, 0},
+	{0x40, 0x0f, 0},
+	{0x41, 0xf0, 0},
+	{0x19, 0x49, 0},
+	{0x93, 0x0f, 10},
+	{0x20, 0x40, 0},
+	{0x1d, 0x07, 0},
+	{0x1e, 0x00, 0},
+	{0x1f, 0x04, 0},
+	{0x44, 0x40, 0},
+	{0x45, 0x12, 10},
+	{0x1c, 0x04, 20},
+	{0x43, 0x80, 5},
+	{0x1b, 0x08, 40},
+	{0x1b, 0x10, 40},
+	{0x90, 0x7f, 0},
+	{0x26, 0x04, 40},
+	{0x26, 0x24, 0},
+	{0x26, 0x2c, 40},
+	{0x26, 0x3c, 0},
+	{0x57, 0x02, 0},
+	{0x55, 0x00, 0},
+	{0x57, 0x00, 0}
+};
+
+void edt_init(void)
+{
+	int i;
+
+	for (i=0; i < (sizeof(edt_qvga_lcd_init)/3); i++) {
+
+		write_lcd_reg(edt_qvga_lcd_init[i][0],
+			      edt_qvga_lcd_init[i][1]);
+		mdelay(edt_qvga_lcd_init[i][2]);
+	}
+	/* Prepare to print data */
+	writew(0x22, LCD_POINTER);
+}
+
+void lcd_disable(void)
+{
+	gpio_ctrl_set(GPIO_ENABLE_LCD, 0);
+}
+
+void lcd_enable(void)
+{
+	gpio_cfg_set(GPIO_ENABLE_LCD,
+		     GPIO_CFG_FUNC_GPIO | GPIO_CFG_OUTPUT);
+	gpio_ctrl_set(GPIO_ENABLE_LCD, 1);
+}
+
+void lcd_ctrl_init (void *lcdbase)
+{
+        const nv_param_part_t *part_entry;
+
+	if (NvParamPartFind(&part_entry, NVPT_SPLASH_SCREEN, NVFS_NONE, 0, 0)) {
+		edtdisplay_init_mem(lcdbase);
+		edtdisplay_init(lcdbase);
+		lcd_disable();
+		return;
+	}
+	gd->bd->fb_base = 0xffffffff;
+}
+
+ulong calc_fbsize (void)
+{
+	ulong size;
+	int line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
+
+	size = line_length * panel_info.vl_row;
+	size += PAGE_SIZE;
+
+	return size;
+}
+
+static int edtdisplay_init_mem (void *lcdbase)
+{
+	u_long palette_mem_size;
+	int fb_size = panel_info.vl_row * (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
+
+	panel_info.screen = (u_long)lcdbase;
+
+	panel_info.palette_size = NBITS(panel_info.vl_bpix) == 8 ? 256 : 16;
+	palette_mem_size = panel_info.palette_size * sizeof(u16);
+
+	debug("palette_mem_size = 0x%08lx\n", (u_long) palette_mem_size);
+	/* locate palette and descs at end of page following fb */
+	panel_info.palette = (u_long)lcdbase + fb_size + PAGE_SIZE - palette_mem_size;
+
+	return 0;
+}
+
+static int edtdisplay_init(void *lcdbase)
+{
+	lcd_enable();
+	lcd_reset();
+	config_cs();
+
+	mdelay(50);
+	writeb(0x67, LCD_POINTER);
+	if (readb(LCD_DATA) != 0x47) {
+		printf("error: HX8347 controller not detected\n");
+	}
+
+	edt_init();
+	/* Disable to avoid displaying anything on the
+	 * screen until we have the splash image */
+	lcd_disable();
+
+	return 0;
+}
+
+void lcd_write_pixel(unsigned short val)
+{
+	writew(val, LCD_DATA);
+}
+
+#endif /* CONFIG_LCD */
diff --git a/cpu/arm926ejs/ns921x/ns921x_eth.c b/cpu/arm926ejs/ns921x/ns921x_eth.c
new file mode 100644
index 0000000..a7acfd8
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/ns921x_eth.c
@@ -0,0 +1,986 @@
+/*
+ *  cpu/arm926ejs/ns921x/ns921x_eth.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.2 $
+ *  !Author:     Markus Pietrek
+ *  !References: [1] derived from ns9750_eth.c, 1.29
+*/
+
+#include <common.h>
+#include <net.h>		/* NetSendPacket */
+#include <miiphy.h>		/* miiphy_register */
+
+#include "ns9750_eth.h"		/* for Ethernet and PHY */
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>
+
+#if defined(CONFIG_DRIVER_NS921X_ETHERNET) && \
+	(CONFIG_COMMANDS & CFG_CMD_NET)
+
+/* some definition to make transistion to linux easier */
+
+#define NS921X_DRIVER_NAME	"eth"
+#define KERN_WARNING 		"Warning:"
+#define KERN_ERR 		"Error:"
+#define KERN_INFO 		"Info:"
+
+#if 0
+# define DEBUG
+#endif
+
+#ifdef	DEBUG
+# define printk			printf
+
+# define DEBUG_INIT		0x0001
+# define DEBUG_MINOR		0x0002
+# define DEBUG_RX		0x0004
+# define DEBUG_TX		0x0008
+# define DEBUG_INT		0x0010
+# define DEBUG_POLL		0x0020
+# define DEBUG_LINK		0x0040
+# define DEBUG_MII		0x0100
+# define DEBUG_MII_LOW		0x0200
+# define DEBUG_MEM		0x0400
+# define DEBUG_ERROR		0x4000
+# define DEBUG_ERROR_CRIT	0x8000
+
+static int nDebugLvl = DEBUG_ERROR_CRIT;
+
+# define DEBUG_ARGS0( FLG, a0 ) if( ( nDebugLvl & (FLG) ) == (FLG) ) \
+		printf("%s: " a0, __FUNCTION__, 0, 0, 0, 0, 0, 0 )
+# define DEBUG_ARGS1( FLG, a0, a1 ) if( ( nDebugLvl & (FLG) ) == (FLG)) \
+		printf("%s: " a0, __FUNCTION__, (int)(a1), 0, 0, 0, 0, 0 )
+# define DEBUG_ARGS2( FLG, a0, a1, a2 ) if( (nDebugLvl & (FLG)) ==(FLG))\
+		printf("%s: " a0, __FUNCTION__, (int)(a1), (int)(a2), 0, 0,0,0 )
+# define DEBUG_ARGS3( FLG, a0, a1, a2, a3 ) if((nDebugLvl &(FLG))==(FLG))\
+		printf("%s: "a0,__FUNCTION__,(int)(a1),(int)(a2),(int)(a3),0,0,0)
+# define DEBUG_FN( FLG ) if( (nDebugLvl & (FLG)) == (FLG) ) \
+		printf("\r%s:line %d\n", (int)__FUNCTION__, __LINE__, 0,0,0,0);
+# define ASSERT( expr, func ) if( !( expr ) ) { \
+        	printf( "Assertion failed! %s:line %d %s\n", \
+        	(int)__FUNCTION__,__LINE__,(int)(#expr),0,0,0); \
+        	func }
+#else /* DEBUG */
+# define printk(...)
+# define DEBUG_ARGS0( FLG, a0 )
+# define DEBUG_ARGS1( FLG, a0, a1 )
+# define DEBUG_ARGS2( FLG, a0, a1, a2 )
+# define DEBUG_ARGS3( FLG, a0, a1, a2, a3 )
+# define DEBUG_FN( n )
+# define ASSERT(expr, func)
+#endif /* DEBUG */
+
+#define NS921X_MII_CHECK_FOR_NEG      	(3*CFG_HZ) /* in s */
+#define NS921X_MII_NEG_DELAY      	(5*CFG_HZ) /* in s */
+#define TX_TIMEOUT			(5*CFG_HZ) /* in s */
+#define SPREAD_SPECTRUM_PERCENTAGE	(4)	   /* 4% */
+
+/* @TODO move it to eeprom.h */
+#define FS_EEPROM_AUTONEG_MASK		0x7
+#define FS_EEPROM_AUTONEG_SPEED_MASK	0x1
+#define FS_EEPROM_AUTONEG_SPEED_10	0x0
+#define FS_EEPROM_AUTONEG_SPEED_100	0x1
+#define FS_EEPROM_AUTONEG_DUPLEX_MASK	0x2
+#define FS_EEPROM_AUTONEG_DUPLEX_HALF	0x0
+#define FS_EEPROM_AUTONEG_DUPLEX_FULL	0x2
+#define FS_EEPROM_AUTONEG_ENABLE_MASK	0x4
+#define FS_EEPROM_AUTONEG_DISABLE	0x0
+#define FS_EEPROM_AUTONEG_ENABLE	0x4
+
+/* buffer descriptors taken from [1] p.306 */
+typedef struct
+{
+	unsigned int* punSrc;
+	unsigned int unLen;	/* 11 bits */
+	unsigned int* punDest;	/* unused */
+	union {
+		unsigned int unReg;
+		struct {
+			unsigned uStatus : 16;
+			unsigned uRes : 12;
+			unsigned uFull : 1;
+			unsigned uEnable : 1;
+			unsigned uInt : 1;
+			unsigned uWrap : 1;
+		} bits;
+	} s;
+} rx_buffer_desc_t;
+
+typedef struct
+{
+	unsigned int* punSrc;
+	unsigned int unLen;	/* 10 bits */
+	unsigned int* punDest;	/* unused */
+	union {
+		unsigned int unReg; /* only 32bit accesses may done to NS921X
+				     * eth engine */
+		struct {
+			unsigned uStatus : 16;
+			unsigned uRes : 12;
+			unsigned uFull : 1;
+			unsigned uLast : 1;
+			unsigned uInt : 1;
+			unsigned uWrap : 1;
+		} bits;
+	} s;
+} tx_buffer_desc_t;
+
+static int eth_lowlevel_init( void );
+static int ns921x_eth_init_mac( void );
+static void ns921x_eth_reset_mac( void );
+
+static void ns921x_link_force( void );
+static void ns921x_link_auto_negotiate( void );
+static void ns921x_link_update_egcr( void );
+static void ns921x_link_print_changed( void );
+
+/* the PHY stuff */
+
+static char ns921x_mii_identify_phy( void );
+static unsigned short ns921x_mii_read( unsigned short uiRegister );
+static void ns921x_mii_write( unsigned short uiRegister, unsigned short uiData );
+static unsigned int ns921x_mii_get_clock_divisor( unsigned int unMaxMDIOClk );
+static unsigned int ns921x_mii_poll_busy( void );
+
+static unsigned int nPhyMaxMdioClock = PHY_MDIO_ASS_CLK;
+static unsigned char ucLinkMode =      FS_EEPROM_AUTONEG_ENABLE;
+static unsigned int uiLastLinkStatus;
+static PhyType phyDetected = PHY_NONE;
+
+/* we use only one tx buffer descriptor */
+static tx_buffer_desc_t* pTxBufferDesc =
+	(tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD );
+
+/* we use only one rx buffer descriptor of the 4 */
+static rx_buffer_desc_t rxBufferDesc[PKTBUFSRX];
+static uchar rxBuffer[PKTBUFSRX][(1522 + (0x1f)) & ~0x1f];
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_read based on ns921x_mii_read
+ * @Return: the data read from PHY register reg
+ * @Descr: the data read may be invalid if timed out. If so, a message
+ *         is printed but the invalid data is returned.
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static int ns921x_miiphy_read( char* devname, unsigned char addr, unsigned char reg, unsigned short *value )
+{
+        /* so MII functions can be used independently whether we did
+         * something with ethernet */
+        if( !eth_lowlevel_init() )
+                return -1;
+        
+	/* write MII register to be read */
+	*get_eth_reg_addr(NS9750_ETH_MADR) = addr<<8|reg;
+
+	*get_eth_reg_addr( NS9750_ETH_MCMD ) = NS9750_ETH_MCMD_READ;
+
+	if( !ns921x_mii_poll_busy() )
+	    printk( KERN_WARNING NS921X_DRIVER_NAME
+		    ": MII still busy in read\n" );
+	/* continue to read */
+
+	*get_eth_reg_addr( NS9750_ETH_MCMD ) = 0;
+
+	*value = (unsigned short) (*get_eth_reg_addr( NS9750_ETH_MRDD ) );
+
+	return 0;
+}
+
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_write based on ns921x_mii_write
+ * @Return: != 0 on error
+ * @Descr: writes the data to the PHY register. In case of a timeout,
+ *         no special handling is performed but a message printed
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static int ns921x_miiphy_write (char* devname, unsigned char addr, unsigned char reg, unsigned short value)
+{
+        if( !eth_lowlevel_init() )
+                return -1;
+
+	/* write MII register to be written */
+	*get_eth_reg_addr( NS9750_ETH_MADR)=addr<<8|reg;
+
+	*get_eth_reg_addr( NS9750_ETH_MWTD ) = value;
+
+	if( !ns921x_mii_poll_busy() )
+		printk( KERN_WARNING NS921X_DRIVER_NAME
+			": MII still busy in write\n");
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: ns921x_miiphy_initialize
+ * @Return: always 0
+ ***********************************************************************/
+int ns921x_miiphy_initialize( bd_t *bis )
+{
+        miiphy_register( "ns921x", ns921x_miiphy_read, ns921x_miiphy_write );
+        return 0;
+}
+
+
+/***********************************************************************
+ * @Function: ns921x_mii_read
+ * @Return: the data read from PHY register uiRegister
+ * @Descr: the data read may be invalid if timed out. If so, a message
+ *         is printed but the invalid data is returned.
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static unsigned short ns921x_mii_read( unsigned short uiRegister )
+{
+        unsigned short val;
+        
+        ns921x_miiphy_read( NULL, NS921X_ETH_PHY_ADDRESS, uiRegister, &val );
+        return val;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_write
+ * @Return: nothing
+ * @Descr: writes the data to the PHY register. In case of a timeout,
+ *         no special handling is performed but a message printed
+ *         The fixed device address is being used.
+ ***********************************************************************/
+
+static void ns921x_mii_write( unsigned short uiRegister, unsigned short uiData )
+{
+        ns921x_miiphy_write( NULL, NS921X_ETH_PHY_ADDRESS, uiRegister, uiData );
+}
+
+/***********************************************************************
+ * @Function: eth_lowlevel_init
+ * @Return: 0 on failure otherwise 1
+ * @Descr: Initializes the GPIO and low level register not for individual
+ *         frames
+ ***********************************************************************/
+
+static int eth_lowlevel_init( void )
+{
+        static int bAlreadyInitialized = 0;
+	int i;
+
+	DEBUG_FN( DEBUG_INIT );
+
+        if( bAlreadyInitialized )
+                return 1;
+        
+        bAlreadyInitialized = 1;
+
+        /* enable clock and hold it out-of-reset */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_ETH );
+        /* we don't need ETH Phy Int */
+	for( i = 32; i <= 49; i++ )
+                gpio_cfg_set( i, GPIO_CFG_FUNC_0 );
+
+#ifdef GPIO_ETH_PHY_RESET
+        /* take PHY out of reset. Needs to be done after GPIO 42
+           (TX_EN), otherwise the PHY lights yellow activity and blinks
+           green link LED.
+           xmit of frames will start after 35...500ms, [4] 9.5.16.
+           If already done by platform.S due to S4-8, it has no effect */
+        gpio_ctrl_set( GPIO_ETH_PHY_RESET, 1 );
+        gpio_cfg_set( GPIO_ETH_PHY_RESET,
+                      GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO );
+#endif
+        
+	/* no need to check for hardware */
+
+	if( !ns921x_eth_init_mac() )
+		return 0;
+
+	*get_eth_reg_addr( NS9750_ETH_MAC2 ) = NS9750_ETH_MAC2_CRCEN |
+		NS9750_ETH_MAC2_PADEN |
+		NS9750_ETH_MAC2_FULLD;
+
+        return 1;
+}
+
+/***********************************************************************
+ * @Function: eth_init
+ * @Return: -1 on failure otherwise 0
+ * @Descr: Initializes the ethernet engine and uses either FS Forth's default
+ *         MAC addr or the one in environment
+ ***********************************************************************/
+
+int eth_init( bd_t* pbis )
+{
+	int i;
+
+	/* enable hardware */
+        if( !eth_lowlevel_init() )
+                return -1;
+
+	/* prepare DMA descriptors */
+	/* NetRxPackets[ 0 ] is initialized before eth_init is called and never
+	   changes. NetRxPackets is 32bit aligned */
+
+	for (i = 0; i < PKTBUFSRX; ++i) {
+		rxBufferDesc[i].punSrc = (unsigned int*) (rxBuffer[i]);
+		rxBufferDesc[i].unLen = 1522;
+		rxBufferDesc[i].s.bits.uWrap = !(i < PKTBUFSRX - 1);
+		rxBufferDesc[i].s.bits.uInt = 1;
+		rxBufferDesc[i].s.bits.uEnable = 1;
+		rxBufferDesc[i].s.bits.uFull = 0;
+	}
+
+        flush_cache_all();
+        
+	*get_eth_reg_addr( NS9750_ETH_RXAPTR ) = (unsigned int)rxBufferDesc;
+	*get_eth_reg_addr( NS9750_ETH_RXBPTR ) = 0;
+	*get_eth_reg_addr( NS9750_ETH_RXCPTR ) = 0;
+	*get_eth_reg_addr( NS9750_ETH_RXDPTR ) = 0;
+
+	udelay(1); /* This seems to be only needed when compiled under cygwin?? */
+
+	/* pTxBufferDesc is the first possible buffer descriptor */
+	*get_eth_reg_addr( NS9750_ETH_TXPTR ) = 0x0;
+	
+	/* set first descriptor to wrap and disable to avoid unwanted
+	   transmissions */
+	((tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD ))->s.unReg=0x80000000;
+        
+	/* set the next buffer descriptor empty so the tx engine stops on that descriptor */
+	((tx_buffer_desc_t*) get_eth_reg_addr( NS9750_ETH_TXBD1 ))->s.unReg=0x0;
+
+	/* enable receive and transmit FIFO, use 10/100 Mbps MII */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) =
+		NS9750_ETH_EGCR1_ERX |
+		NS9750_ETH_EGCR1_ETX |
+		NS9750_ETH_EGCR1_ERXINIT;
+
+	/* [1] Tab. 221 states less than 5us */
+	udelay( 5 );
+	while( !(*get_eth_reg_addr(NS9750_ETH_EGSR) & NS9750_ETH_EGSR_RXINIT))
+		/* wait for finish */
+		udelay( 1 );
+
+        *get_eth_reg_addr(NS9750_ETH_EGSR) = NS9750_ETH_EGSR_RXINIT;
+
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) &= ~NS9750_ETH_EGCR1_ERXINIT;
+	*get_eth_reg_addr( NS9750_ETH_EGCR2 ) = NS9750_ETH_EGCR2_STEN;
+
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) = NS9750_ETH_MAC1_RXEN;
+	*get_eth_reg_addr( NS9750_ETH_SUPP ) &= ~NS9750_ETH_SUPP_RPERMII;
+
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) =
+		NS9750_ETH_EGCR1_ERX |
+		NS9750_ETH_EGCR1_ETX |
+		NS9750_ETH_EGCR1_ERXDMA |
+		NS9750_ETH_EGCR1_ETXDMA |
+		NS9750_ETH_EGCR1_ERXSHT;
+
+	*get_eth_reg_addr(NS9750_ETH_EINTR) |= *get_eth_reg_addr(NS9750_ETH_EINTR);
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_send
+ * @Return: -1 on timeout otherwise 1
+ * @Descr: sends one frame by DMA
+ ***********************************************************************/
+
+int eth_send( volatile void* pPacket, int nLen )
+{
+        unsigned int uiTries = 3;
+        
+	DEBUG_FN( DEBUG_TX );
+
+        /* in case a Tx Error happened, retry transmission a few times */
+        do {
+                ulong ulTimeout;
+                
+                uiTries--;
+                
+                /* clear old status values */
+                *get_eth_reg_addr(NS9750_ETH_EINTR) &= NS9750_ETH_EINTR_TX_MA;
+
+                /* prepare Tx Descriptors */
+                
+                pTxBufferDesc->punSrc = (unsigned int*) pPacket; /* pPacket is 32bit
+                                                                  * aligned */
+                pTxBufferDesc->unLen = nLen;
+                /* only 32bit accesses allowed. wrap, full, interrupt and enabled to 1 */
+                pTxBufferDesc->s.unReg = 0xf0000000;
+                
+                flush_cache_all();
+                
+                /* pTxBufferDesc is the first possible buffer descriptor */
+                *get_eth_reg_addr( NS9750_ETH_TXPTR ) = 0x0;
+
+                /* enable processor for next frame */
+
+                *get_eth_reg_addr( NS9750_ETH_EGCR2 ) &= ~(NS9750_ETH_EGCR2_TCLER | NS9750_ETH_EGCR2_TKICK );
+                *get_eth_reg_addr( NS9750_ETH_EGCR2 ) |= ( NS9750_ETH_EGCR2_TCLER | NS9750_ETH_EGCR2_TKICK );
+
+                DEBUG_ARGS0(DEBUG_TX|DEBUG_MINOR,"Waiting for transmission to finish\n");
+	
+                ulTimeout = get_timer( 0 );
+
+                while( 1 ) {
+                        u32 uiIntr = *get_eth_reg_addr( NS9750_ETH_EINTR );
+
+                        if( get_timer( ulTimeout ) >= TX_TIMEOUT ) {
+                                printf( "Tx Timeout %x %x\n",
+                                        uiIntr, pTxBufferDesc->s.unReg );
+                                break;
+                        }
+
+                        if( uiIntr & NS9750_ETH_EINTR_TXERR ) {
+                                printf( "Tx Error: %08x\n",
+                                        pTxBufferDesc->s.unReg );
+                                break;
+                        } else if( uiIntr & NS9750_ETH_EINTR_TXDONE ) {
+                                uiTries = 0;
+                                break;
+                        }
+                }
+
+                *get_eth_reg_addr( NS9750_ETH_EINTR ) &= NS9750_ETH_EINTR_TX_MA;
+        } while( uiTries );
+        
+        DEBUG_ARGS0( DEBUG_TX|DEBUG_MINOR, "transmitted...\n");
+
+        return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_rx
+ * @Return: size of last frame in bytes or 0 if no frame available
+ * @Descr: gives one frame to U-Boot which has been copied by DMA engine already
+ *         to NetRxPackets[ 0 ].
+ ***********************************************************************/
+
+int eth_rx( void )
+{
+	unsigned int unStatus;
+	int i;
+
+	unStatus = *get_eth_reg_addr(NS9750_ETH_EINTR) & NS9750_ETH_EINTR_RX_MA;
+
+	if( !unStatus )
+		/* no packet available, return immediately */
+		return 0;
+
+	DEBUG_FN( DEBUG_RX );
+
+	/* acknowledge status register */
+	*get_eth_reg_addr(NS9750_ETH_EINTR) = unStatus;
+
+	if (unStatus & NS9750_ETH_EINTR_RXDONEA)  {
+		for (i = 0; i < PKTBUFSRX; ++i) {
+                        invalidate_cache_all();
+
+			if (rxBufferDesc[i].s.bits.uFull) {
+				int len = rxBufferDesc[i].unLen - 4;
+				NetReceive(rxBuffer[i], len);
+
+				rxBufferDesc[i].unLen = 1522;
+				rxBufferDesc[i].s.bits.uFull = 0;
+				*get_eth_reg_addr(NS9750_ETH_RXFREE) |= 0x1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: eth_halt
+ * @Return: n/a
+ * @Descr: we don't do anything here to avoid unnecessary initialization
+ *         again on next command
+ ***********************************************************************/
+
+void eth_halt( void )
+{
+	DEBUG_FN( DEBUG_INIT );
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) &= ~NS9750_ETH_MAC1_RXEN;
+}
+
+/***********************************************************************
+ * @Function: ns921x_eth_init_mac
+ * @Return: 0 on failure otherwise 1
+ * @Descr: initializes the PHY layer,
+ *         performs auto negotiation or fixed modes
+ ***********************************************************************/
+
+static int ns921x_eth_init_mac( void )
+{
+	DEBUG_FN( DEBUG_MINOR );
+
+	/* initialize PHY */
+	*get_eth_reg_addr( NS9750_ETH_SUPP ) = NS9750_ETH_SUPP_RPERMII;
+
+	*get_eth_reg_addr( NS9750_ETH_MAC1 ) = 0;  /* take it out of SoftReset */
+	/* we don't support hot plugging of PHY, therefore we don't reset
+	   phyDetected and nPhyMaxMdioClock here. The risk is if the setting is
+	   incorrect the first open
+	   may detect the PHY correctly but succeding will fail
+	   For reseting the PHY and identifying we have to use the standard
+	   MDIO CLOCK value 2.5 MHz.2.5 MHz are assured by the hardware
+	   reference ns9215 and ns9210. Higher speed can be working. We
+	   will not use higher speed. */
+
+	*get_eth_reg_addr( NS9750_ETH_MCFG ) =
+	    ns921x_mii_get_clock_divisor( nPhyMaxMdioClock );
+
+	/* MII clock has been setup to default, ns9750_mii_identify_phy should
+	   work for all */
+
+	if( !ns921x_mii_identify_phy() ) {
+	    printf( "Unsupported PHY, aborting\n");
+	    return 0;
+	}
+
+	/* PHY has been detected, so there can be no abort reason and we can
+	   finish initializing ethernet */
+
+	uiLastLinkStatus = 0xff; /* undefined */
+
+	if((ucLinkMode&FS_EEPROM_AUTONEG_ENABLE_MASK)==FS_EEPROM_AUTONEG_DISABLE)
+		/* use parameters defined */
+		ns921x_link_force();
+	else
+		ns921x_link_auto_negotiate();
+
+	return 1;
+}
+
+/***********************************************************************
+ * @Function: ns921x_eth_reset_mac
+ * @Return: 0 on failure otherwise 1
+ * @Descr: resets the MAC 
+ ***********************************************************************/
+
+static void ns921x_eth_reset_mac( void )
+{
+	DEBUG_FN( DEBUG_MINOR );
+
+	/* Reset MAC */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) |= (NS9750_ETH_EGCR1_MAC_HRST |
+							NS9750_ETH_EGCR1_ERX |
+							NS9750_ETH_EGCR1_ETX);
+	udelay( 5 ); 		/* according to [1], p.322 */
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) &= ~NS9750_ETH_EGCR1_MAC_HRST;
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_force
+ * @Return: void
+ * @Descr: configures eth and MII to use the link mode defined in
+ *         ucLinkMode
+ ***********************************************************************/
+
+static void ns921x_link_force( void )
+{
+	unsigned short uiControl;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	uiControl = ns921x_mii_read( PHY_COMMON_CTRL );
+	uiControl &= ~( PHY_COMMON_CTRL_SPD_MA |
+			PHY_COMMON_CTRL_AUTO_NEG |
+			PHY_COMMON_CTRL_DUPLEX );
+
+	uiLastLinkStatus = 0;
+
+	if( ( ucLinkMode & FS_EEPROM_AUTONEG_SPEED_MASK ) ==
+	    FS_EEPROM_AUTONEG_SPEED_100 ) {
+	    uiControl |= PHY_COMMON_CTRL_SPD_100;
+#ifdef CONFIG_PHY_ICS1893
+	    uiLastLinkStatus |= PHY_ICS1893_QPSTAT_100BTX;
+#endif
+	} else
+	    uiControl |= PHY_COMMON_CTRL_SPD_10;
+
+	if( ( ucLinkMode & FS_EEPROM_AUTONEG_DUPLEX_MASK ) ==
+	    FS_EEPROM_AUTONEG_DUPLEX_FULL ) {
+	    uiControl |= PHY_COMMON_CTRL_DUPLEX;
+#ifdef CONFIG_PHY_ICS1893
+	    uiLastLinkStatus |= PHY_ICS1893_QPSTAT_DUPLEX;
+#endif
+	}
+
+	ns921x_mii_write( PHY_COMMON_CTRL, uiControl );
+
+	ns921x_link_print_changed();
+	ns921x_link_update_egcr();
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_auto_negotiate
+ * @Return: void
+ * @Descr: performs auto-negotation of link.
+ ***********************************************************************/
+
+static void ns921x_link_auto_negotiate( void )
+{
+	unsigned long ulStartJiffies;
+	unsigned short uiStatus;
+        unsigned long uiCheckStart;
+        
+	DEBUG_FN( DEBUG_LINK );
+
+        uiCheckStart = get_timer( 0 );
+        
+        /* determination whether an auto-negotiation is in progress */
+        do {
+                uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+                if( ( uiStatus &
+                      PHY_COMMON_STAT_LNK_STAT) == PHY_COMMON_STAT_LNK_STAT) {
+                        /* we have a link, so no need to trigger auto-negotiation */
+                        ns921x_link_print_changed();
+                        ns921x_link_update_egcr();
+                        return;
+                }
+        } while( get_timer( uiCheckStart ) < NS921X_MII_CHECK_FOR_NEG );
+
+        /* no auto-negotiation seemed to be in progress, and there is no link.
+           run auto-negotation */
+	/* define what we are capable of */
+	ns921x_mii_write( PHY_COMMON_AUTO_ADV,
+			  PHY_COMMON_AUTO_ADV_100BTXFD |
+			  PHY_COMMON_AUTO_ADV_100BTX |
+			  PHY_COMMON_AUTO_ADV_10BTFD |
+			  PHY_COMMON_AUTO_ADV_10BT |
+			  PHY_COMMON_AUTO_ADV_802_3 );
+	/* start auto-negotiation */
+	ns921x_mii_write( PHY_COMMON_CTRL,
+			  PHY_COMMON_CTRL_AUTO_NEG |
+			  PHY_COMMON_CTRL_RES_AUTO );
+
+	/* wait for completion */
+
+	ulStartJiffies = get_ticks();
+	while( get_ticks() < ulStartJiffies + NS921X_MII_NEG_DELAY ) {
+		uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+		if( ( uiStatus &
+		      (PHY_COMMON_STAT_AN_COMP | PHY_COMMON_STAT_LNK_STAT)) ==
+		    (PHY_COMMON_STAT_AN_COMP | PHY_COMMON_STAT_LNK_STAT) ) {
+			/* lucky we are, auto-negotiation succeeded */
+			ns921x_link_print_changed();
+			ns921x_link_update_egcr();
+
+			return;
+		}
+	}
+
+	printf( KERN_WARNING NS921X_DRIVER_NAME
+		":auto-negotiation timed out, forcing 10Mbps/Half\n" );
+
+	/* force mode */
+	ucLinkMode = FS_EEPROM_AUTONEG_SPEED_10 | FS_EEPROM_AUTONEG_DUPLEX_HALF;
+	ns921x_link_force();
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_update_egcr
+ * @Return: void
+ * @Descr: updates the EGCR and MAC2 link status after mode change or
+ *         auto-negotation
+ ***********************************************************************/
+
+static void ns921x_link_update_egcr( void )
+{
+	unsigned int unEGCR;
+	unsigned int unMAC2;
+	unsigned int unIPGT;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	unEGCR = *get_eth_reg_addr( NS9750_ETH_EGCR1 );
+	unMAC2 = *get_eth_reg_addr( NS9750_ETH_MAC2 );
+	unIPGT = *get_eth_reg_addr( NS9750_ETH_IPGT ) & ~NS9750_ETH_IPGT_MA;
+
+	unMAC2 &= ~NS9750_ETH_MAC2_FULLD;
+
+#ifdef CONFIG_PHY_ICS1893
+	if( (uiLastLinkStatus & PHY_ICS1893_QPSTAT_DUPLEX)
+	    == PHY_ICS1893_QPSTAT_DUPLEX ) {
+		unMAC2 |= NS9750_ETH_MAC2_FULLD;
+		unIPGT |= 0x15;	/* see [1] p. 339 */
+	}
+	else
+#endif
+		unIPGT |= 0x12;	/* see [1] p. 339 */
+
+	*get_eth_reg_addr( NS9750_ETH_MAC2 ) = unMAC2;
+	*get_eth_reg_addr( NS9750_ETH_EGCR1 ) = unEGCR;
+	*get_eth_reg_addr( NS9750_ETH_IPGT ) = unIPGT;
+}
+
+/***********************************************************************
+ * @Function: ns921x_link_print_changed
+ * @Return: void
+ * @Descr: checks whether the link status has changed and if so prints
+ *         the new mode
+ ***********************************************************************/
+
+static void ns921x_link_print_changed( void )
+{
+	unsigned short uiStatus;
+	unsigned short uiControl;
+
+	DEBUG_FN( DEBUG_LINK );
+
+	uiControl = ns921x_mii_read( PHY_COMMON_CTRL );
+
+	if( (uiControl & PHY_COMMON_CTRL_AUTO_NEG) == PHY_COMMON_CTRL_AUTO_NEG) {
+		/* PHY_COMMON_STAT_LNK_STAT is only set on autonegotiation */
+		uiStatus = ns921x_mii_read( PHY_COMMON_STAT );
+
+		if( !( uiStatus & PHY_COMMON_STAT_LNK_STAT) ) {
+			printk( KERN_WARNING NS921X_DRIVER_NAME ": link down\n");
+			/* @TODO Linux: carrier_off */
+		} else {
+			/* @TODO Linux: carrier_on */
+#ifdef CONFIG_PHY_ICS1893
+	unsigned short uiStatus_bak;
+			if( phyDetected == PHY_ICS1893BK ) {
+				uiStatus = ns921x_mii_read( PHY_COMMON_AUTO_ADV );
+				uiStatus &= (PHY_ICS1893_QPSTAT_100BTX);
+				uiStatus_bak = uiStatus;
+				uiStatus = ns921x_mii_read( PHY_COMMON_CTRL );
+				uiStatus &= (PHY_ICS1893_QPSTAT_DUPLEX );
+				uiStatus |= uiStatus_bak;
+
+				/* mask out all uninteresting parts */
+			}
+#endif
+			/* other PHYs must store there link information in
+			   uiStatus as PHY_LXT971 */
+		}
+	} else {
+		/* mode has been forced, so uiStatus should be the same as the
+		   last link status, enforce printing */
+		uiStatus = uiLastLinkStatus;
+		uiLastLinkStatus = 0xff;
+	}
+
+	if( uiStatus != uiLastLinkStatus ) {
+		/* save current link status */
+		uiLastLinkStatus = uiStatus;
+	}
+}
+
+/***********************************************************************
+ * the MII low level stuff
+ ***********************************************************************/
+
+/***********************************************************************
+ * @Function: ns921x_mii_identify_phy
+ * @Return: 1 if supported PHY has been detected otherwise 0
+ * @Descr: checks for supported PHY and prints the IDs.
+ ***********************************************************************/
+
+static char ns921x_mii_identify_phy( void )
+{
+	unsigned short uiID1;
+	unsigned short uiID2;
+	char* szName;
+	char cRes = 0;
+        
+	DEBUG_FN( DEBUG_MII );
+
+	uiID1 = ns921x_mii_read( PHY_COMMON_ID1 );
+	phyDetected = (PhyType)uiID1;
+
+	switch( phyDetected ) {
+#ifdef CONFIG_PHY_ICS1893
+	    case PHY_ICS1893BK:
+		szName = "ICS1893BK";
+		uiID2 = ns921x_mii_read( PHY_COMMON_ID2 );
+		cRes = 1;
+		break;
+#endif
+#ifdef CONFIG_PHY_HIRSCHMANN
+	    case PHY_HIRSCHMANN:
+		szName = "Hirschmann";
+		nPhyMaxMdioClock = 0x25000000;
+		cRes = 1;
+		break;
+#endif
+	    case PHY_NONE:
+	    default:
+		/* in case uiID1 == 0 && uiID2 == 0 we may have the wrong
+		   address or reset sets the wrong NS921X_ETH_MCFG_CLKS */
+
+		uiID2 = 0;
+		szName = "unknown";
+		phyDetected = PHY_NONE;
+
+                printf( "Unknown PHY @ %i (0x%x, 0x%x) detected\n",
+                        NS921X_ETH_PHY_ADDRESS,
+                        uiID1,
+                        uiID2 );
+
+	}
+
+	return cRes;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_get_clock_divisor
+ * @Return: the clock divisor that should be used in NS9750_ETH_MCFG_CLKS
+ * @Descr: if no clock divisor can be calculated for the
+ *         current SYSCLK and the maximum MDIO Clock, a warning is printed
+ *         and the greatest divisor is taken
+ ***********************************************************************/
+
+static unsigned int ns921x_mii_get_clock_divisor( unsigned int unMaxMDIOClk )
+{
+	struct
+	{
+		unsigned int unSysClkDivisor;
+		unsigned int unClks; /* field for NS9750_ETH_MCFG_CLKS */
+	} PHYClockDivisors[] = {
+		{  4, NS9750_ETH_MCFG_CLKS_4 },
+		{  6, NS9750_ETH_MCFG_CLKS_6 },
+		{  8, NS9750_ETH_MCFG_CLKS_8 },
+		{ 10, NS9750_ETH_MCFG_CLKS_10 },
+		{ 20, NS9750_ETH_MCFG_CLKS_20 },
+		{ 30, NS9750_ETH_MCFG_CLKS_30 },
+		{ 40, NS9750_ETH_MCFG_CLKS_40 }
+	};
+
+	int nIndexSysClkDiv;
+	int nArraySize = sizeof(PHYClockDivisors) / sizeof(PHYClockDivisors[0]);
+	unsigned int unClks = NS9750_ETH_MCFG_CLKS_40; /* defaults to
+							  greatest div */
+
+	DEBUG_FN( DEBUG_INIT );
+
+	for( nIndexSysClkDiv=0; nIndexSysClkDiv < nArraySize;nIndexSysClkDiv++) {
+		/* find first sysclock divisor that isn't higher than 2.5 MHz
+		   clock */
+		if( AHB_CLK_FREQ /
+		    PHYClockDivisors[ nIndexSysClkDiv ].unSysClkDivisor <=
+		    unMaxMDIOClk ) {
+			unClks = PHYClockDivisors[ nIndexSysClkDiv ].unClks;
+			break;
+		}
+	}
+
+	DEBUG_ARGS2( DEBUG_INIT,
+		     "Taking MDIO Clock bit mask 0x%0x for max clock %i\n",
+		     unClks,
+		     unMaxMDIOClk );
+
+	/* return greatest divisor */
+	return unClks;
+}
+
+/***********************************************************************
+ * @Function: ns921x_mii_poll_busy
+ * @Return: 0 if timed out otherwise the remaing timeout
+ * @Descr: waits until the MII has completed a command or it times out
+ *         code may be interrupted by hard interrupts.
+ *         It is not checked what happens on multiple actions when
+ *         the first is still being busy and we timeout.
+ ***********************************************************************/
+
+static unsigned int ns921x_mii_poll_busy( void )
+{
+	unsigned int unTimeout = 10000;
+
+	DEBUG_FN( DEBUG_MII_LOW );
+
+	while( (( *get_eth_reg_addr( NS9750_ETH_MIND ) & NS9750_ETH_MIND_BUSY)
+		== NS9750_ETH_MIND_BUSY ) &&
+	       unTimeout )
+		unTimeout--;
+
+	return unTimeout;
+}
+
+/***********************************************************************
+ * @Function: eth_use_mac_from_env
+ * @Return: 0 if ok, < 0 on failure
+ * @Descr: Stores MAC address in chip. Might be called for a not fully
+ * initialized network stack when booting Linux from Flash.
+ ***********************************************************************/
+
+int eth_use_mac_from_env( bd_t* pbis )
+{
+	unsigned char aucMACAddr[ 6 ] = { 0x00,0x04,0xf3,0x00,0x06,0x35 };
+
+	char* pcTmp = getenv( "ethaddr" );
+	char* pcEnd;
+        int   i;
+
+        /* clock is not on when used directly from board_late_init() */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_ETH );
+
+        ns921x_eth_reset_mac();
+
+	if( pcTmp != NULL ) {
+                /* copy MAC address */
+                for( i = 0; i < 6; i++ ) {
+                        aucMACAddr[ i ] = pcTmp ? simple_strtoul( pcTmp, &pcEnd, 16 ) : 0;
+                        /* next char or terminating zero */
+                        pcTmp = (*pcTmp) ? ( pcEnd + 1 ) : pcEnd;
+                }
+        } else
+                eprintf( "Couldn't read MAC address from environment, using default\n" );
+
+
+        /* now set it, so linux can use it */
+	*get_eth_reg_addr( NS9750_ETH_SA1 ) = aucMACAddr[ 5 ]<<8 | aucMACAddr[ 4 ];
+	*get_eth_reg_addr( NS9750_ETH_SA2 ) = aucMACAddr[ 3 ]<<8 | aucMACAddr[ 2 ];
+	*get_eth_reg_addr( NS9750_ETH_SA3 ) = aucMACAddr[ 1 ]<<8 | aucMACAddr[ 0 ];
+
+        sys_rmw32( SYS_CLOCK, & ( ~SYS_CLOCK_ETH ) );
+
+	return 0;
+}
+
+/***********************************************************************
+* @Function: set_mac_from_env
+* @Descr: Stores MAC address in chip. Call careful,because no check is
+* done.
+***********************************************************************/
+
+void set_mac_from_env( void )
+{
+	unsigned char aucMACAddr[ 6 ];
+
+	char* pcTmp = getenv( "ethaddr" );
+	char* pcEnd;
+        int   i;
+
+	if( pcTmp != NULL ) {
+                /* copy MAC address */
+                for( i = 0; i < 6; i++ ) {
+                        aucMACAddr[ i ] = pcTmp ? simple_strtoul( pcTmp, &pcEnd, 16 ) : 0;
+                        /* next char or terminating zero */
+                        pcTmp = (*pcTmp) ? ( pcEnd + 1 ) : pcEnd;
+                }
+        } else
+                eprintf( "Couldn't read MAC address from environment, using default\n" );
+
+
+        /* now set it, so linux can use it */
+	*get_eth_reg_addr( NS9750_ETH_SA1 ) = aucMACAddr[ 5 ]<<8 | aucMACAddr[ 4 ];
+	*get_eth_reg_addr( NS9750_ETH_SA2 ) = aucMACAddr[ 3 ]<<8 | aucMACAddr[ 2 ];
+	*get_eth_reg_addr( NS9750_ETH_SA3 ) = aucMACAddr[ 1 ]<<8 | aucMACAddr[ 0 ];
+}
+
+#endif /* CONFIG_DRIVER_NS921X_ETHERNET */
diff --git a/cpu/arm926ejs/ns921x/reset.S b/cpu/arm926ejs/ns921x/reset.S
new file mode 100644
index 0000000..a98f329
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/reset.S
@@ -0,0 +1,29 @@
+/*
+ *  cpu/arm926ejs/ns921x/reset.S
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Reference:  [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <config.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+
+	.align	4
+.globl reset_cpu
+reset_cpu:
+          ldr   r1, =(SYS_BASE_PA + SYS_PLL)
+          ldr   r2, [r1]
+          str   r2, [r1]
+
+_loop_forever:
+	b	_loop_forever
+        
diff --git a/cpu/arm926ejs/ns921x/serial_ns921x.c b/cpu/arm926ejs/ns921x/serial_ns921x.c
new file mode 100644
index 0000000..dbfc2b0
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/serial_ns921x.c
@@ -0,0 +1,344 @@
+/*
+ *  cpu/arm926ejs/ns921x/serial_ns921x.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#include <common.h>
+
+#ifdef CFG_NS921X_UART
+
+#ifdef CONFIG_NS9210
+# define SERIAL_PORT_B_TX	23
+# define SERIAL_PORT_B_RX	19
+# define SERIAL_PORT_D_TX	31
+# define SERIAL_PORT_D_RX	27
+# define GPIO_CFG_FUNC_UART	GPIO_CFG_FUNC_1
+#else
+# define SERIAL_PORT_B_TX	58
+# define SERIAL_PORT_B_RX	54
+# define SERIAL_PORT_D_TX	66
+# define SERIAL_PORT_D_RX	62
+# define GPIO_CFG_FUNC_UART	GPIO_CFG_FUNC_0
+#endif
+
+#include <serial.h>             /* serial_ns921x_devices */
+
+#include <asm/errno.h>              /* EINVAL */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/ns921x_hub.h>
+#include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+
+#include <../common/digi/vscanf.h>  /* sscanf */
+
+#define GPIO_TX		0
+#define GPIO_RX		1
+#define GPIO_LAST	1
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Order of GPIOs is GPIO_TX to GPIO_LAST and function
+ * Use always function as last element of the array
+ */
+static const char l_aiGPIO[][3] = {
+	{  7,  3,  GPIO_CFG_FUNC_0 }, /* Port A */
+	{ SERIAL_PORT_B_TX, SERIAL_PORT_B_RX, GPIO_CFG_FUNC_UART }, /* Port B */
+	{ 15, 11, GPIO_CFG_FUNC_0 }, /* Port C */
+	{ SERIAL_PORT_D_TX, SERIAL_PORT_D_RX, GPIO_CFG_FUNC_UART }  /* Port D */
+};
+
+/* the port we are using */
+static int l_iPort = -1;        /* not initialized yet */
+
+/* for caching characters and l_xFIFO */
+static struct {
+        u32 uChars;
+        int iCount;
+} l_xFIFO = { 0, 0 };
+
+/* some functions that map the HUB port  */
+static inline u32 hub_readl( u32 uOffs )
+{
+        return hub_port_readl( l_iPort, uOffs );
+}
+
+static inline u8 hub_readb( u32 uOffs )
+{
+        return hub_port_readb( l_iPort, uOffs );
+}
+
+static inline void hub_writel( u32 uVal, u32 uOffs )
+{
+        hub_port_writel( l_iPort, uVal, uOffs );
+}
+
+static inline void hub_writeb( u8 ucVal, u32 uOffs )
+{
+        hub_port_writeb( l_iPort, ucVal, uOffs );
+}
+
+/**
+ * ns_serial_setbrg - set baudrate register
+ */
+void ns_serial_setbrg( void )
+{
+        u32 uPeriod = NS_CPU_REF_CLOCK / gd->baudrate;
+        u32 uDiv    = uPeriod / 16; /* 16 bit oversampling */
+        /* [1], p. 359 by default we use 8N1. 8 character bit, one start, one
+         * stopbit */
+        static const u32 uCharLen = 10;
+
+        hub_writel( UART_CGAP_CTRL_EN |
+                       UART_CGAP_CTRL_VAL( uCharLen * uPeriod - 1 ), UART_CGAP_CTRL );
+        /* [1], p. 360, 64 characters, 640 bit periods */
+        hub_writel( UART_BGAP_CTRL_EN |
+                       UART_BGAP_CTRL_VAL( 64 * uCharLen * uPeriod - 1 ), UART_BGAP_CTRL );
+
+        /* baudrate divisor */
+        hub_rmw32( UART_LINE_CTRL, | UART_LINE_CTRL_DLAB );
+        hub_writel( UART_BRDL_VAL( uDiv ),      UART_BRDL );
+        hub_writel( UART_BRDM_VAL( uDiv >> 8 ), UART_BRDM );
+        hub_rmw32( UART_LINE_CTRL, & ~UART_LINE_CTRL_DLAB );
+}
+
+/**
+ * ns_serial_init - initialises UART Module
+ */
+static int ns_serial_init( void )
+{
+        int i;
+
+        /* configure GPIOs for special function */
+         for( i = 0; i < ( ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ); i++ )
+                gpio_cfg_set( l_aiGPIO[ l_iPort ][ i ],
+                              l_aiGPIO[ l_iPort ][ ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ] );
+
+        /* enable clock and hold it out-of-reset */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_UART( l_iPort ) );
+        sys_rmw32( SYS_RESET, | SYS_RESET_UART( l_iPort ) );
+
+        /* toggle RX/TX FLUSH for resetting FIFO */
+        hub_writel( UART_WRAPPER_CFG_RX_FLUSH |
+                       UART_WRAPPER_CFG_TX_FLUSH,
+                       UART_WRAPPER_CFG );
+        hub_writel( 0, UART_WRAPPER_CFG );
+
+        /* no DMA, we poke into FIFO */
+        hub_writel( HUB_DMA_RX_CTRL_DIRECT, HUB_DMA_RX_CTRL );
+        hub_writel( HUB_DMA_TX_CTRL_DIRECT, HUB_DMA_TX_CTRL );
+
+        ns_serial_setbrg();
+
+        /* set line control to 8 Data Bits, No Parity, 1 Stop Bit */
+        hub_writel( UART_LINE_CTRL_PAR_NO |
+                       UART_LINE_CTRL_STOP_1  |
+                       UART_LINE_CTRL_WLS_8, UART_LINE_CTRL );
+
+        /* enable UARTs internal Rx/Tx FIFO */
+        hub_writel( UART_FIFO_CTRL_EN, UART_FIFO_CTRL );
+
+        /* This interrupt is needed from HW (Hub) as transmitter holding
+         * register. SW doesn't use it */
+        hub_writel( UART_BAUD_INT_ETBEI, UART_BAUD_INT );
+
+        /* enable wrapper */
+        hub_writel( UART_WRAPPER_CFG_RX_EN      |
+                       UART_WRAPPER_CFG_TX_EN      |
+                       UART_WRAPPER_CFG_TX_FLOW_SW |
+                       UART_WRAPPER_CFG_MODE_UART, UART_WRAPPER_CFG );
+
+        return 0;
+}
+
+/**
+ * ns_serial_deinit - deinitialises UART Module
+ */
+static int ns_serial_deinit( void )
+{
+        int i;
+
+        /* configure GPIOs as INPUT */
+        for( i = 0; i < ( ARRAY_SIZE( l_aiGPIO[ l_iPort ] ) - 1 ); i++ )
+                gpio_cfg_set( l_aiGPIO[ l_iPort ] [ i ], GPIO_CFG_INPUT );
+
+        /* disable wrapper */
+        hub_writel( 0, UART_WRAPPER_CFG );
+
+        /* disable clock and put in reset */
+        sys_rmw32( SYS_CLOCK, & ~SYS_CLOCK_UART( l_iPort ) );
+        sys_rmw32( SYS_RESET, & ~SYS_RESET_UART( l_iPort ) );
+
+        return 0;
+}
+
+/**
+ * serial_disable - disables UART Module
+ */
+int serial_disable( void )
+{
+#ifdef CONFIG_ALLOW_SERIAL_DISABLE
+	int i;
+
+	for(i=0; i < SERIAL_PORTS_NR; i++) {
+		l_iPort = i;
+		/* disable UARTs internal Rx/Tx FIFO */
+		hub_writel( 0, UART_WRAPPER_CFG );
+	}
+#endif
+	return 0;
+}
+
+/**
+ * ns_serial_start - starts the console.
+ */
+static int ns_serial_start( int iPort )
+{
+        int iRes = -EINVAL;
+
+        if( ( iPort >= 0 ) && ( iPort < 4 ) ) {
+                /* switch to new console */
+                if( -1 != l_iPort )
+                                /* not initialized yet */
+                        ns_serial_deinit();
+
+                l_iPort = iPort;
+                ns_serial_init();
+
+                iRes = 0;
+        } else {
+                /* eprintf may not be available yet */
+                printf( "*** ERROR: Unsupported port\n" );
+                iRes = -EINVAL;
+        }
+
+        return iRes;
+}
+
+/**
+ * ns_serial_putc - outputs one character
+ */
+
+static void ns_serial_putc( const char c )
+{
+        /* generate CR/LF */
+        if( '\n' == c )
+                ns_serial_putc( '\r' );
+
+        /* wait for space available */
+        while( ( hub_readl( HUB_INT ) & HUB_INT_TX_FIFO_FULL ) ) {
+                /* do nothing, wait for character to be sent */
+        }
+
+        hub_writeb( c, HUB_TX_FIFO );
+}
+
+/**
+ * ns_serial_puts - outputs a zero terminated string
+ */
+static void ns_serial_puts( const char* szMsg )
+{
+	while( *szMsg )
+		ns_serial_putc( *szMsg++ );
+}
+
+/**
+ * ns_serial_tstc - checks for input available
+ * @return: 0 if no input available, otherwise != 0
+ */
+int ns_serial_tstc( void )
+{
+        if( !l_xFIFO.iCount ) {
+                /* don't use HUB_RX_FIFO_STAT for checking of empty, it doesn't
+                 * handle buffer closed well. */
+                if( !( hub_readl( HUB_INT ) & HUB_INT_RX_FIFO_EMPTY ) ) {
+                        /* both reads (status and data) must be together */
+                        l_xFIFO.iCount = HUB_RX_FIFO_BYTE( hub_readl( HUB_RX_FIFO_STAT ) );
+
+	                l_xFIFO.uChars = hub_readl( HUB_RX_FIFO );
+                }
+
+                /* uChars may still be undefined if iCount == 0 */
+        }
+
+        return ( l_xFIFO.iCount != 0 );
+}
+
+
+/**
+ * ns_serial_getc - returns one character
+ */
+static int ns_serial_getc( void )
+{
+        u8 ucChar;
+
+        while( !ns_serial_tstc() ) {
+                /* do nothing, wait for incoming character */
+        }
+
+        l_xFIFO.iCount--;
+        ucChar = l_xFIFO.uChars & 0xff;
+        l_xFIFO.uChars >>= 8;
+        return ucChar;
+}
+
+/**
+ * ns_serial_tx_flush - returns when all characters have been flushed out
+ */
+static void ns_serial_tx_flush( void )
+{
+        while( !( hub_readl( HUB_INT ) & HUB_INT_TX_FIFO_EMPTY ) ) {
+                /* do nothing, wait for all characters to be sent */
+        }
+
+        /* wait for character to be really out */
+        while( !( hub_readl( UART_LINE_STAT ) & UART_LINE_STAT_TEMT ) ) {
+                /* do nothing, wait for character to be sent */
+        }
+}
+
+/* some stuff to provide serial0...serial3 */
+#define MK( port ) \
+static int ns_serial_start_##port( void ) \
+{ \
+        ns_serial_start( port ); \
+        return 0; \
+}
+MK( 0 )
+MK( 1 )
+MK( 2 )
+MK( 3 )
+#undef MK
+
+#define MK( port ) \
+        { .name     = "serial"#port,            \
+          .init     = ns_serial_start_##port,   \
+          .setbrg   = ns_serial_setbrg, \
+          .getc     = ns_serial_getc,   \
+          .tstc     = ns_serial_tstc,   \
+          .putc     = ns_serial_putc,   \
+          .puts     = ns_serial_puts,     \
+          .tx_flush = ns_serial_tx_flush    \
+        }
+
+struct serial_device serial_ns921x_devices[ 4 ] = {
+        MK( 0 ),
+        MK( 1 ),
+        MK( 2 ),
+        MK( 3 )
+};
+#undef MK
+
+#endif  /* CFG_NS921X_UART */
diff --git a/cpu/arm926ejs/ns921x/timer.c b/cpu/arm926ejs/ns921x/timer.c
new file mode 100644
index 0000000..1e97801
--- /dev/null
+++ b/cpu/arm926ejs/ns921x/timer.c
@@ -0,0 +1,241 @@
+/*
+ *  cpu/arm926ejs/ns921x/timer.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ *               [2] cc9x/timer.c
+ *  !Descr:      U-Boot uses 4 timers.
+ *               Timer 0 provides a 1ms timer. This is for long
+ *               lasting test using get_timer().
+ *               Timer 1 is concated to Timer 0 and counts the ms since reset.
+ *               This gives a wraparound every 4 Mio. seconds or every 46 days
+ *               Therefore there is no SW encounting of wraparounds
+ *
+ *               Timer 2 and Timer 3 are also concatenated and used for udelay.
+ *               Timer 2 provides a pulse with about 1us resolution.
+ *               Timer 3 is then loaded with usec value of udelay and
+ *               polled for zero.
+ *               This gives quite exact udelays.
+ *               With 149.91360 MHz, udelay(1us) may be range from 1us to 1.7us
+ *
+ *               If only one timer is being used, divisions and multiplications
+ *               are needed. This makes it impossible to achieve
+ *               udelays < 25us because of the calculation overhead.
+ *
+ *               Calibrating an udelay loop is too unprecise, too. Depending on
+ *               the environment it may differ (DMA transfer, framebuffer
+ *               active, cache enabled/disabled ) etc.
+ *
+ *               A precise udelay brings advantage as U-Boot is also being used
+ *               for HW tests.
+*/
+
+#include <common.h>
+
+/* we are only compiled if CONFIG_NS9215 is present  */
+
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+
+#define MS_TIMER		0       /* for ms */
+#define SYSTEM_TIMER		1       /* for get_timer */
+#define US_TIMER		2       /* timer in about 1us resolution */
+#define UDELAY_TIMER		3       /* loaded with usec delay */
+#define SYSTEM_TIMER_RELOAD    	0
+
+#define US_DISABLE \
+        ( SYS_TIMER_CTRL_TCS_M2   | \
+          SYS_TIMER_CTRL_TM_INT   | \
+          SYS_TIMER_CTRL_DOWN     | \
+          SYS_TIMER_CTRL_32       | \
+          SYS_TIMER_CTRL_RELOAD )
+
+#define UDELAY_DISABLE \
+        ( SYS_TIMER_CTRL_TCS_M2   | \
+          SYS_TIMER_CTRL_TM_CONC  | \
+          SYS_TIMER_CTRL_DOWN     | \
+          SYS_TIMER_CTRL_32 )
+
+#define US_ENABLE      ( US_DISABLE     | SYS_TIMER_CTRL_TE )
+#define UDELAY_ENABLE  ( UDELAY_DISABLE | SYS_TIMER_CTRL_TE )
+
+/**
+ * sys_clock_freq - determines system clock frequency based on PLL settings
+ * @return: clock in Hz
+ *
+ * System clock is only calculated on the first call
+ */
+int sys_clock_freq( void )
+{
+        static u32 uiSysClkFreq = 0;
+
+        if( !uiSysClkFreq ) {
+                /* calculate it only once */
+                static const u32 uiRefClk = NS_CPU_REF_CLOCK;
+                u32 uiPLL    = sys_readl( SYS_PLL );
+                u32 uiPLLVC0 = ( uiRefClk / ( SYS_PLL_NR( uiPLL ) + 1 ) ) *
+                        ( SYS_PLL_NF( uiPLL ) + 1 );
+
+                uiSysClkFreq  = uiPLLVC0 / ( SYS_PLL_OD( uiPLL ) + 1 );
+        }
+
+        return uiSysClkFreq;
+}
+
+/**
+ * ahb_clock_freq - determines ahb clock frequency based on clock config settings
+ * @return: clock in Hz
+ */
+int ahb_clock_freq( void )
+{
+        u32 uiClkScale = SYS_CLOCK_CSC( sys_readl( SYS_CLOCK ) );
+        u32 uiAHBClockFreq;
+
+        uiAHBClockFreq = ( sys_clock_freq() / 4 ) >> uiClkScale;
+
+        return uiAHBClockFreq;
+}
+
+/**
+ * cpu_clock_freq - determines cpu clock frequency based on clock config settings
+ * @return: clock in Hz
+ */
+int cpu_clock_freq( void )
+{
+        u32 uiClkFac = ( sys_readl( SYS_CLOCK ) & SYS_CLOCK_CCSEL ) ? 2 : 1;
+        u32 uiCPUClockFreq;
+
+        uiCPUClockFreq = ahb_clock_freq() * uiClkFac;
+
+        return uiCPUClockFreq;
+}
+
+/**
+ * read_timer - returns timer value
+ */
+static inline u32 read_timer( void )
+{
+        return sys_readl( SYS_TIMER_READ( SYSTEM_TIMER ) );
+}
+
+/**
+ * set_timer - sets the timestamp counter
+ */
+void set_timer( ulong t )
+{
+        sys_writel( t, SYS_TIMER_RELOAD( SYSTEM_TIMER ) );
+}
+
+void reset_timer( void )
+{
+        set_timer( 0 );
+}
+
+/**
+ * timer_init -
+ * @return: always 0 on ok
+ *
+ * initializes Timer 0 as ms timer and Timer 1 concatenated as system timer (for msdelay).
+ * initializes Timer 2 as us timer and Timer 3 concatenated for udelay
+ */
+int timer_init( void )
+{
+        u32 uiTicksPerMS = 0;
+
+        sys_writel( 0, SYS_TIMER_CTRL( SYSTEM_TIMER ) );  /* disable all */
+
+        /* configure ms timer */
+        uiTicksPerMS = ( ahb_clock_freq() * 2 ) / 1000;
+        sys_writel( uiTicksPerMS, SYS_TIMER_RELOAD( MS_TIMER ) );
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                    SYS_TIMER_CTRL_TCS_M2   |
+                    SYS_TIMER_CTRL_TM_INT   |
+                    SYS_TIMER_CTRL_DOWN     |
+                    SYS_TIMER_CTRL_32       |
+                    SYS_TIMER_CTRL_RELOAD,
+                    SYS_TIMER_CTRL( MS_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( MS_TIMER ) );
+
+        /* configure system timer, concated to ms timer */
+        reset_timer();
+        sys_writel( SYS_TIMER_CTRL_TE       |
+                    SYS_TIMER_CTRL_TCS_M2   |  /* don't divide input clock*/
+                    SYS_TIMER_CTRL_TM_CONC  |
+                    SYS_TIMER_CTRL_TM_INT   |
+                    SYS_TIMER_CTRL_UP       |
+                    SYS_TIMER_CTRL_32       |
+                    SYS_TIMER_CTRL_RELOAD,
+                    SYS_TIMER_CTRL( SYSTEM_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( SYSTEM_TIMER ) );
+
+        /* configure us timer */
+        sys_writel( uiTicksPerMS / 1000, SYS_TIMER_RELOAD( US_TIMER ) );
+        sys_writel( US_DISABLE,
+                    SYS_TIMER_CTRL( US_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( US_TIMER ) );
+
+        /* configure udelay timer, concated to us timer */
+        sys_writel( UDELAY_DISABLE,
+                    SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        sys_rmw32( SYS_TIMER_MASTER_CTRL,
+                   | SYS_TIMER_MASTER_CTRL_EN( UDELAY_TIMER ) );
+
+        return 0;
+}
+
+ulong get_timer( ulong base )
+{
+	return read_timer() - base;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay( unsigned long usec )
+{
+        if( !usec )
+                return;
+
+        /* disable us and udelay timer. us should be kicked from a known state */
+        sys_writel( US_DISABLE, SYS_TIMER_CTRL( US_TIMER ) );
+        sys_writel( UDELAY_DISABLE, SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        /* load timer 3 with the intended udelay to wait */
+        sys_writel( usec, SYS_TIMER_RELOAD( UDELAY_TIMER ) );
+
+        /* kick them */
+
+        sys_writel( UDELAY_ENABLE, SYS_TIMER_CTRL( UDELAY_TIMER ) );
+        sys_writel( US_ENABLE, SYS_TIMER_CTRL( US_TIMER ) );
+
+        while( sys_readl( SYS_TIMER_READ( UDELAY_TIMER ) ) ) {
+                /* wait for timer to expire, do nothing */
+        }
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks( void )
+{
+	return get_timer( 0 );
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk( void )
+{
+        return CFG_HZ;
+}
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 8921ff9..55f833e 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -40,6 +40,7 @@ COBJS-$(CONFIG_S3C44B0_I2C) += s3c44b0_i2c.o
 COBJS-$(CONFIG_SOFT_I2C) += soft_i2c.o
 COBJS-$(CONFIG_SPEAR_I2C) += spr_i2c.o
 COBJS-$(CONFIG_TSI108_I2C) += tsi108_i2c.o
+COBJS-$(CONFIG_NS9215) += ns9xxx_i2c.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/i2c/ns9xxx_i2c.c b/drivers/i2c/ns9xxx_i2c.c
new file mode 100644
index 0000000..00005fe
--- /dev/null
+++ b/drivers/i2c/ns9xxx_i2c.c
@@ -0,0 +1,603 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2004 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ *
+ * @Author: Markus Pietrek
+ * @Descr: I2C Driver for the NS9750. No multi-master support
+ * @TODO: iprobe fails, i2c is unusable then
+ * @References: [1] linux/drivers/i2c/busses/i2c_ns.c
+ *              [2] drivers/s3c24x0_i2c.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *  
+ ***********************************************************************/
+
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_NS9750_I2C
+
+#include <asm/errno.h>		/* -ETIMEDOUT */
+#include <asm/byteorder.h>	/* cpu_to_le32 */
+
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215) || \
+    defined(CONFIG_CME9210) || defined(CONFIG_CC9P9210)
+# include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+# include <asm-arm/arch-ns9xxx/io.h>
+#else
+# include <ns9750_bbus.h>	/* NS9750_BBUS_MASTER_RESET */
+# include <ns9750_sys.h>
+#endif
+
+#include <ns9750_i2c.h>		/* get_i2c_reg_addr */
+
+#define I2C_TIMEOUT	1000 /* us */
+
+#define DRIVER_NAME	"i2c_ns"
+
+#define PRINTD(x)
+
+#ifndef writel
+/* linux porting helping functions */
+# define writel(v,a)	do { PRINTD((" -> writel(0x%08x, 0x%08x)\n", v, a)); \
+		*((a)) = (v); } while(0);
+
+# define readl(a)	({ unsigned int __v; __v = *((a)); \
+		PRINTD(("readl(0x%08x) -> 0x%08x\n", a, __v)); \
+		__v; })
+#endif
+
+#define rmwl(a,op)	do { PRINTD((" -> rmwl(0x%08x, " #op ")\n", a)); \
+		*(a) = ( *(a) op ); } while(0);
+
+#define addr_i2c(a)	(get_i2c_reg_addr(a))
+#define addr_bbus_utility(a)	(get_bbus_reg_addr(a))
+
+#define I2C_M_NOSTART	1
+#define I2C_M_RD	2
+
+typedef enum
+{
+	I2C_NS_INT_AWAITING,
+	I2C_NS_INT_OK,
+	I2C_NS_INT_RETRY,
+	I2C_NS_INT_ERROR,
+	I2C_NS_INT_ABORT
+} i2c_ns_int_status_t;
+
+/* derived from linux/include/linux/i2c.h */
+struct i2c_msg {
+	__u16 addr;	/* slave address			*/
+ 	__u16 flags;		
+ 	__u16 len;		/* msg length				*/
+ 	__u8 *buf;		/* pointer to msg data			*/
+};
+
+static uchar* i2c_ns_buf = NULL;	/* where to store the incoming character */
+static i2c_ns_int_status_t i2c_ns_int_status;
+
+static int i2c_ns_master_xfer( struct i2c_msg msgs[], int num );
+static int i2c_ns_read( int count );
+static int i2c_ns_write( const uchar* buf, int count );
+static int i2c_ns_send_cmd( unsigned int cmd );
+static int i2c_ns_wait_cmd( void );
+
+static int l_iSelectedSpeed = 0;
+
+static void i2c_lowlevel_init( void )
+{
+        static char bAlreadyInitialized = 0;
+
+        if( bAlreadyInitialized )
+                return;
+
+        bAlreadyInitialized = 1;
+        
+#ifdef CONFIG_NS921X
+        /* enable clock and hold it out-of-reset */
+        sys_rmw32( SYS_CLOCK, | SYS_CLOCK_I2C );
+#endif
+#ifdef REMOVE
+#if defined (CONFIG_CC9P9360) || defined (CONFIG_CC9C) || (CONFIG_CCW9C)
+	rmwl( addr_bbus_utility( NS9750_BBUS_MASTER_RESET ), & 0xFFFFFF7F );
+        set_gpio_cfg_reg_val(I2C_SCL_GPIO, I2C_SCL_GPIO_FUNC);
+        set_gpio_cfg_reg_val(I2C_SDA_GPIO, I2C_SDA_GPIO_FUNC);
+	udelay(10);
+#else
+        gpio_cfg_set(I2C_SCL_GPIO, I2C_SCL_GPIO_FUNC);
+        gpio_cfg_set(I2C_SDA_GPIO, I2C_SDA_GPIO_FUNC);
+#endif /* (CONFIG_CC9P9360) || (CONFIG_CC9C) || (CONFIG_CCW9C) */
+#endif /* REMOVE */
+        gpio_cfg_set(I2C_SCL_GPIO, I2C_SCL_GPIO_FUNC);
+        gpio_cfg_set(I2C_SDA_GPIO, I2C_SDA_GPIO_FUNC);
+}
+
+
+/**
+ * i2c_update_speed - writes l_iSelectedSpeed to I2C
+ *
+ * If the speed is invalid, don't write it
+ */
+static void i2c_update_speed( void )
+{
+        char bIgnore = 0;
+        
+        u32 uiClkRef = CPU_CLK_FREQ / ( 4 * l_iSelectedSpeed );
+
+        if( uiClkRef > NS_I2C_CFG_CLREF_MA )
+                bIgnore = 1;
+
+        uiClkRef &= NS_I2C_CFG_CLREF_MA;
+        
+        if( uiClkRef && !bIgnore ) {
+                u32 uiCfg = uiClkRef | ((0xf << NS_I2C_CFG_SFW_SH) & NS_I2C_CFG_SFW_MA );
+                writel( uiCfg, addr_i2c( NS_I2C_CFG ) );
+        } else
+                eprintf( "Wrong I2C Divisor %i, not changing register\n",
+                         uiClkRef );
+}
+
+/**
+ * i2c_init - initializes I2C
+ * @speed: != 0 means new value, otherwise stick with old or default
+ */
+void i2c_init( int speed /* ignored */, int slaveadd /*ignored*/ )
+{
+	PRINTD(("%s\n", __func__));
+        if( !speed && l_iSelectedSpeed )
+		/* no speed change and already configured */
+                return;
+
+        i2c_lowlevel_init();
+
+        l_iSelectedSpeed = ( speed ? speed : CFG_I2C_SPEED );
+
+        i2c_update_speed();
+}
+
+/**
+ * i2c_speed - determine real I2C speed
+ */
+int i2c_speed( void )
+{
+        u32 uiClkRef;
+        
+        i2c_init( 0, 0 );  /* in case it has not already been configured */
+
+        uiClkRef = readl( addr_i2c( NS_I2C_CFG ) ) & NS_I2C_CFG_CLREF_MA;
+
+        /* there seems to be a rounding issue on cc9p9215. It reports 100
+           kHz, the scope says 96 kHz */
+        return CPU_CLK_FREQ / ( 4 * uiClkRef );
+}
+
+int i2c_write( uchar chip, uint addr, int alen, uchar * buffer, int count )
+{
+	uchar xaddr[4];
+	struct i2c_msg msg[ 2 ] = {
+		{
+			.addr = chip,
+			.len = alen,
+			.buf = &xaddr[4 - alen]
+		}, {
+			.addr = chip,
+			.len = count,
+			.buf = buffer
+		}
+        };
+
+	PRINTD(("%s\n", __func__));
+
+	if( alen > 4 ) {
+		printf( "I2C read: addr len %d not supported\n", alen );
+		return 1;
+	}
+
+	if( alen > 0 ) {
+		xaddr[ 0 ] = (addr >> 24) & 0xFF;
+		xaddr[ 1 ] = (addr >> 16) & 0xFF;
+		xaddr[ 2 ] = (addr >> 8) & 0xFF;
+		xaddr[ 3 ] = addr & 0xFF;
+
+		msg[1].flags |= I2C_M_NOSTART;
+	}
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	if( alen > 0 )
+		chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+
+	{
+		int i;
+		for( i = 0; i < 2; i++ )
+			msgs[ i++ ].addr = chip;
+	}
+#endif
+
+	/* if alen == 0, don't send the first message */
+	if (i2c_ns_master_xfer(msg + !alen, 2 - !alen) != (2 - !alen))
+		return -EIO;
+
+	return 0;
+}
+
+int i2c_read( uchar chip, uint addr, int alen, uchar * buffer, int count )
+{
+	uchar xaddr[ 4 ];
+	struct i2c_msg msg[ 2 ] = {
+                {addr:chip,flags:0,       len: alen, buf:&xaddr[ 4-alen ] },
+                {addr:chip,flags:I2C_M_RD,len:count, buf:buffer}
+        };
+
+	PRINTD(("%s\n", __func__));
+
+	if( alen > 4 ) {
+		printf( "I2C read: addr len %d not supported\n", alen );
+		return 1;
+	}
+
+	if( alen > 0 ) {
+		xaddr[ 0 ] = (addr >> 24) & 0xFF;
+		xaddr[ 1 ] = (addr >> 16) & 0xFF;
+		xaddr[ 2 ] = (addr >> 8) & 0xFF;
+		xaddr[ 3 ] = addr & 0xFF;
+	}
+
+#ifdef CFG_I2C_EEPROM_ADDR_OVERFLOW
+	/*
+	 * EEPROM chips that implement "address overflow" are ones
+	 * like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	 * address and the extra bits end up in the "chip address"
+	 * bit slots. This makes a 24WC08 (1Kbyte) chip look like
+	 * four 256 byte chips.
+	 *
+	 * Note that we consider the length of the address field to
+	 * still be one byte because the extra address bits are
+	 * hidden in the chip address.
+	 */
+	if( alen > 0 )
+		chip |= ((addr >> (alen * 8)) & CFG_I2C_EEPROM_ADDR_OVERFLOW);
+
+	{
+		int i;
+		for( i = 0; i < 2; i++ )
+			msgs[ i++ ].addr = chip;
+	}
+#endif
+
+	/* if alen == 0, don't send the first message */
+	if (i2c_ns_master_xfer(msg + !alen, 2 - !alen) != 2 - !alen)
+		return -EIO;
+
+	return 0;
+}
+
+int i2c_probe( uchar chip )
+{
+	uchar buf[ 1 ];
+	struct i2c_msg msg[1] = {
+                {addr:chip, flags:0, len: 0, buf:buf },
+        };
+	int len = sizeof( msg ) / sizeof( struct i2c_msg );
+
+	PRINTD(("%s\n", __func__));
+
+	buf[ 0 ] = 0;
+
+	/*
+	 * What is needed is to send the chip address and verify that the
+	 * address was <ACK>ed (i.e. there was a chip at that address which
+	 * drove the data line low).
+	 */
+        if( i2c_ns_master_xfer( msg, len ) != len )
+                return -EIO;
+
+	return 0;
+}
+
+uchar i2c_reg_read( uchar chip, uchar reg )
+{
+        uchar buf;
+
+	PRINTD(("%s\n", __func__));
+
+        i2c_read( chip, reg, 1, &buf, 1 );
+
+        return (buf);
+}
+
+void i2c_reg_write( uchar chip, uchar reg, uchar val )
+{
+	PRINTD(("%s\n", __func__));
+
+        i2c_write( chip, reg, 1, &val, 1 );
+}
+
+/***********************************************************************
+ * @Function: i2c_ns_master_xfer
+ * @Return: 0 on failure otherwise number messages sends (== num)
+ * @Descr: performs action described in i2c_msg
+ *         accepts I2C_M_NOSTART for continous transfer, I2C_M_RD and
+ *         !I2C_M_RD (write). No buffer validity check is performed.
+ ***********************************************************************/
+
+static int i2c_ns_master_xfer( struct i2c_msg msgs[], int num )
+{
+	int i = 0;
+	int ret = 0;
+	int len;
+	uchar* buf;
+	int retry = 1;		/* allow only some retries */
+
+	PRINTD(("%s\n", __func__));
+
+        i2c_init(0, 0);
+        
+	i2c_ns_int_status = I2C_NS_INT_OK;
+	while( i < num ) {
+		if( i2c_ns_int_status == I2C_NS_INT_RETRY ) {
+			/* resend complete message, stop previous access first */
+			/* i is already set to 0 due to while condition */
+			ret = i2c_ns_send_cmd( NS_I2C_DATA_TX_CMD_M_STOP );
+			if( !(retry--) || ret ) {
+				/* @TODO */
+
+				break;
+			}
+		}
+		
+		len = msgs[ i ].len;
+		buf = msgs[ i ].buf;
+
+		i2c_ns_buf = buf;
+
+		if( !(msgs[ i ].flags & I2C_M_NOSTART ) ) {
+			unsigned int cmd;
+
+			/* set device address */
+			writel( (msgs[i].addr << NS_I2C_MASTER_MDA_SH) &
+				NS_I2C_MASTER_MDA_MA, addr_i2c( NS_I2C_MASTER ));
+
+			if( msgs[ i ].flags & I2C_M_RD )
+				cmd = NS_I2C_DATA_TX_CMD_M_READ;
+			else {
+				/* we need to send first byte with the command */
+				cmd = NS_I2C_DATA_TX_CMD_M_WRITE |
+					NS_I2C_DATA_TX_VAL |
+					*buf;
+				len--;
+				buf++;
+			}
+
+			/* send start, device address and read/write command */
+			ret = i2c_ns_send_cmd( cmd );
+			if( ret ) {
+				if( i2c_ns_int_status == I2C_NS_INT_RETRY ) {
+					/* try the message again */
+					i = 0;
+					continue;
+				} else if( i2c_ns_int_status == I2C_NS_INT_ABORT )
+                                        break;
+				
+				printf( DRIVER_NAME 
+					":Setting address failed for 0x%x "
+					"with errno %i\n",
+					msgs[ i ].addr, ret  );
+				break;
+			}
+		}
+		
+		if( len > 0 ) {
+			/* either read mode or send more than one byte */
+			if( msgs[ i ].flags & I2C_M_RD )
+				ret = i2c_ns_read( len );
+			else
+				ret = i2c_ns_write( buf, len );
+			
+			if( ret ) {
+				if( i2c_ns_int_status == I2C_NS_INT_RETRY ) {
+					/* try the message again */
+					i = 0;
+					continue;
+				}
+
+				printf( DRIVER_NAME,
+					":Operation 0x%x failed for 0x%x "
+					"with errno %i\n",
+					msgs[ i ].flags,msgs[ i ].addr,ret);
+				break;
+			}
+		}
+
+		i++;
+	}
+
+	/* message block transmitted, send stop */
+	if( i2c_ns_send_cmd( NS_I2C_DATA_TX_CMD_M_STOP ) ) {
+		/* something locked up, maybe devices thinks lost clock. */
+		if( i2c_ns_send_cmd( NS_I2C_DATA_TX_CMD_M_NOP ) ||
+		    i2c_ns_send_cmd( NS_I2C_DATA_TX_CMD_M_STOP ) ) {
+#ifndef CONFIG_NS921X			
+			/* maybe netsilicon's I2C state machine got stuck,
+			   reset it. */
+			rmwl( addr_bbus_utility( NS9750_BBUS_MASTER_RESET ),
+			      | NS9750_BBUS_MASTER_RESET_I2C );
+			rmwl( addr_bbus_utility( NS9750_BBUS_MASTER_RESET ),
+			      & ~NS9750_BBUS_MASTER_RESET_I2C );
+#endif
+
+                        i2c_update_speed();
+		}
+	}
+
+	return ret ? 0 : i;
+}
+
+/***********************************************************************
+ * @Function: i2c_ns_read
+ * @Return: <0 in case of failure otherwise 0
+ * @Descr: Must be called after an M_READ has been executed and the 
+ *         interrupt has happened. Byte has already been stored by i2c_ns_int in
+ *         i2c_ns_buf but not incremented. Don't do read command in i2c_ns_int
+ *         so that we still use I2C_TIMEOUT
+ ***********************************************************************/
+
+static int i2c_ns_read( int count )
+{
+	int ret = 0;
+
+	PRINTD(("%s\n", __func__));
+
+	/* first character has already been stored in buffer by interrupt
+	 * handler */
+	while( count-- > 1 ) {
+		i2c_ns_buf++;
+
+		ret = i2c_ns_send_cmd( NS_I2C_DATA_TX_CMD_M_NOP );
+		if( ret )
+			return ret;
+	}
+
+	return 0;
+}
+
+/***********************************************************************
+ * @Function: i2c_ns_write
+ * @Return: <0 in case of failure otherwise 0
+ * @Descr: Must be called after an M_WRITE has been executed and the 
+ *         first character has been sent already with M_WRITE.
+ ***********************************************************************/
+
+static int i2c_ns_write( const uchar* buf, int count )
+{
+	int ret = 0;
+
+	PRINTD(("%s\n", __func__));
+
+	while( count-- ) {
+		ret = i2c_ns_send_cmd( (*buf & NS_I2C_DATA_TX_DATA_MA ) |
+				       NS_I2C_DATA_TX_CMD_M_NOP |
+				       NS_I2C_DATA_TX_VAL );
+		if( ret )
+			return ret;
+
+		buf++;
+	}
+	
+	return ret;
+}
+
+/***********************************************************************
+ * @Function: i2c_ns_send_cmd
+ * @Return: -ETIMEDOUT if no interrupt happened in I2C_TIMEOUT or -EIO on
+ *          an I2C failure
+ * @Descr: sends command and waits signal safe for I2C interrupt acknowleding
+ *         command or timeout.
+ ***********************************************************************/
+
+static int i2c_ns_send_cmd( unsigned int cmd )
+{
+	int ret = 0;
+
+	PRINTD(("%s\n", __func__));
+
+	i2c_ns_int_status = I2C_NS_INT_AWAITING;
+	do {
+		writel( cmd, addr_i2c( NS_I2C_DATA_TX ) );
+		ret = i2c_ns_wait_cmd();
+	} while( !ret && (i2c_ns_int_status == I2C_NS_INT_AWAITING) );
+	
+	if( i2c_ns_int_status != I2C_NS_INT_OK )
+		ret = -EIO;
+	
+	return ret;
+}
+
+/***********************************************************************
+ * @Function: i2c_ns_wait_cmd
+ * @Return: 0 or -ETIMEDOUT
+ * @Descr: waits for status flag of transmission
+ ***********************************************************************/
+
+static int i2c_ns_wait_cmd( void )
+{
+	int ret = 0;
+	unsigned int status;
+	int timeout = I2C_TIMEOUT;
+
+	PRINTD(("%s\n", __func__));
+
+	while( (i2c_ns_int_status == I2C_NS_INT_AWAITING) && --timeout ) {
+		udelay( 1 );
+		
+		/* read and acknowledge (by read) */
+		status = readl( addr_i2c( NS_I2C_DATA_RX ) );
+		switch( status & NS_I2C_DATA_RX_IRQCD_MA ) {
+		    case NS_I2C_DATA_RX_IRQCD_NO_IRQ:
+                        /* no status available. continue to wait */
+                        break;
+                        
+		    case NS_I2C_DATA_RX_IRQCD_M_RX_DATA:
+			*i2c_ns_buf = status & NS_I2C_DATA_RX_DATA_MA;
+			i2c_ns_int_status = I2C_NS_INT_OK;
+                        break;
+                        
+		    case NS_I2C_DATA_RX_IRQCD_M_CMD_ACK:
+			i2c_ns_int_status = I2C_NS_INT_OK;
+			break;
+			
+		    case NS_I2C_DATA_RX_IRQCD_M_TX_DATA:
+			i2c_ns_int_status = I2C_NS_INT_OK;
+			break;
+			
+		    case NS_I2C_DATA_RX_IRQCD_M_NO_ACK:
+                        /* send stop */
+                        writel( NS_I2C_DATA_TX_CMD_M_STOP, addr_i2c( NS_I2C_DATA_TX ) );
+                        /* no ACK is not necessary an error, e.g. in probe */
+			i2c_ns_int_status = I2C_NS_INT_ABORT;
+                        break;
+                        
+                    case NS_I2C_DATA_RX_IRQCD_M_ARBIT:
+			/* maybe device didn't listen closely,try again*/
+			i2c_ns_int_status = I2C_NS_INT_RETRY;
+			break;
+			
+		    default:
+			printf(DRIVER_NAME ": wait failed with 0x%x\n", status);
+			i2c_ns_int_status = I2C_NS_INT_ERROR;
+		}
+	}
+	if( !timeout ) {
+		printf( DRIVER_NAME ": timed out\n" );
+		
+		/* not interrupted */
+		ret = -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+#endif /* CONFIG_DRIVER_NS9750_I2C */
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 44ebb9d..6e3a706 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -712,7 +712,7 @@ static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
  * Loop through the sector table starting from the previously found sector.
  * Searches forwards or backwards, dependent on the passed address.
  */
-static flash_sect_t find_sector (flash_info_t * info, ulong addr)
+flash_sect_t find_sector (flash_info_t * info, ulong addr)
 {
 	static flash_sect_t saved_sector = 0; /* previously found sector */
 	flash_sect_t sector = saved_sector;
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 98734db..014bc67 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -63,6 +63,7 @@ COBJS-$(CONFIG_RTC_RX8025) += rx8025.o
 COBJS-$(CONFIG_RTC_S3C24X0) += s3c24x0_rtc.o
 COBJS-$(CONFIG_RTC_S3C44B0) += s3c44b0_rtc.o
 COBJS-$(CONFIG_RTC_X1205) += x1205.o
+COBJS-$(CONFIG_NS9215) += ns921x_rtc.o
 
 COBJS	:= $(sort $(COBJS-y))
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/rtc/ns921x_rtc.c b/drivers/rtc/ns921x_rtc.c
new file mode 100644
index 0000000..595fb53
--- /dev/null
+++ b/drivers/rtc/ns921x_rtc.c
@@ -0,0 +1,188 @@
+/*
+ *  rtc/ns921x_rtc.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.9 $
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Some system registers (SYS_CLOCK and SYS_RTC) have been
+ *               changed. Therefore, cc9c_rtc.c is not merged into it.
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ *               [2] netos:rtc_drv.c 1.4
+*/
+
+#include <common.h>
+
+#if defined(CONFIG_RTC_NS921X) && (CONFIG_COMMANDS & CFG_CMD_DATE)
+#include <rtc.h>                /* rtc_time */
+#include <bcd.h>                /* bcd2bin */
+
+#include <asm-arm/arch-ns9xxx/ns921x_rtc.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* rtc_readl */
+
+#define CLEAR( x ) memset( &x, 0, sizeof( x ) )
+
+#define TIMEOUT		1000000 /* us */
+
+static void rtc_cold_boot( void )
+{
+        unsigned int uiTimeout = TIMEOUT;
+
+        /* configure RTC for CPU access */
+        sys_rmw32( SYS_RTC, |  SYS_RTC_INT_READY_CLEAR );
+        sys_rmw32( SYS_RTC, & ~SYS_RTC_INT_READY_CLEAR );
+
+        /* [2] */
+        sys_rmw32( SYS_RTC, | SYS_RTC_NORMAL );
+        while( ! (sys_readl( SYS_RTC ) & SYS_RTC_INT_READY ) ) {
+                /* wait for RTC to become ready */
+                if( !uiTimeout ) {
+                        eprintf( "RTC Timed Out\n" );
+                        break;
+                }
+                uiTimeout--;
+                udelay( 1 );
+        }
+
+        while( ! (sys_readl( SYS_RTC ) & SYS_RTC_NORMAL_STAT ) ) {
+                /* wait for RTC to become accessable */
+                if( !uiTimeout ) {
+                        eprintf( "RTC Timed Out\n" );
+                        break;
+                }
+                uiTimeout--;
+                udelay( 1 );
+        }
+}
+
+/**
+ * rtc_lowlevel_init - setups the hardware
+ */
+void rtc_lowlevel_init( void )
+{
+        static char bAlreadyInitialized = 0;
+
+        if( !bAlreadyInitialized ) {
+                sys_rmw32( SYS_CLOCK, | SYS_CLOCK_RTC );
+
+                if( ! (sys_readl( SYS_RTC ) & SYS_RTC_NORMAL_STAT ) )
+                        /* RTC has not been started yet, e.g. reset */
+                        rtc_cold_boot();
+
+                sys_rmw32( SYS_RTC,  | SYS_RTC_INT_READY_CLEAR );
+                sys_rmw32( SYS_RTC, &~ SYS_RTC_INT_READY_CLEAR );
+
+                rtc_writel( RTC_24H_24, RTC_24H );
+
+                /* clear events */
+                rtc_readl( RTC_EVENT );
+
+                /* kick it if not running */
+                rtc_rmw32( RTC_CTRL, & ~( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+
+                bAlreadyInitialized = 1;
+        }
+}
+
+/**
+ * rtc_reset - bring rtc into known state (same as battery of)
+ */
+void rtc_reset( void )
+{
+        rtc_lowlevel_init();
+}
+
+/**
+ * rtc_get - returns current time/date
+ */
+int rtc_get( struct rtc_time* pTime )
+{
+        u32 uiDate;
+        u32 uiDateDetectWrap;
+        u32 uiTime;
+        u32 uiStatus;
+
+        rtc_lowlevel_init();
+
+        uiDate = rtc_readl( RTC_DATE );
+        uiTime = rtc_readl( RTC_TIME );
+
+        /* date could have wrapped around just after a read, so time is
+         * 00:00:00 but date is from yesterday. Detect this and read again  */
+        uiDateDetectWrap = rtc_readl( RTC_DATE );
+        if( uiDate != uiDateDetectWrap ) {
+                /* wrapped, use new date and get new time */
+                uiDate = uiDateDetectWrap;
+                uiTime = rtc_readl( RTC_TIME );
+        }
+
+        uiStatus = rtc_readl( RTC_GEN_STAT );
+        if( ( uiStatus & RTC_GEN_STAT_ALL_VALID ) != RTC_GEN_STAT_ALL_VALID )
+                eprintf( "RTC reports invalid configuration: 0x%08x\n",
+                         uiStatus );
+
+        /* convert to U-Boot */
+        CLEAR( *pTime );
+
+        pTime->tm_sec  = bcd2bin( RTC_TIME_S_GET( uiTime ) );
+        pTime->tm_min  = bcd2bin( RTC_TIME_M_GET( uiTime ) );
+        pTime->tm_hour = bcd2bin( RTC_TIME_HR_GET( uiTime ) );
+        pTime->tm_mday = bcd2bin( RTC_DATE_D_GET( uiDate ) );
+        pTime->tm_mon  = bcd2bin( RTC_DATE_M_GET( uiDate ) );
+        pTime->tm_year = bcd2bin( RTC_DATE_C_GET( uiDate ) ) * 100 +
+                bcd2bin( RTC_DATE_Y_GET( uiDate ) );
+        pTime->tm_wday = bcd2bin( RTC_DATE_DAY_GET( uiDate ) - 1 );
+        /* yday and isdst not set */
+        return 0;
+}
+
+/**
+ * rtc_set - updates battery powered RTC
+ */
+int rtc_set( struct rtc_time* pTime )
+{
+        u32 uiDate;
+        u32 uiTime;
+        u32 uiStatus;
+
+        rtc_lowlevel_init();
+
+        uiTime =
+                RTC_TIME_S_SET( bin2bcd( pTime->tm_sec ) ) |
+                RTC_TIME_M_SET( bin2bcd( pTime->tm_min ) ) |
+                RTC_TIME_HR_SET( bin2bcd( pTime->tm_hour ) );
+        uiDate =
+                RTC_DATE_D_SET( bin2bcd( pTime->tm_mday ) ) |
+                RTC_DATE_M_SET( bin2bcd( pTime->tm_mon  ) )  |
+                RTC_DATE_Y_SET( bin2bcd( pTime->tm_year % 100 ) ) |
+                RTC_DATE_C_SET( bin2bcd( pTime->tm_year / 100 ) ) |
+		/* NET+OS saves Sunday as 1, so let's do that, too */
+                RTC_DATE_DAY_SET( bin2bcd( pTime->tm_wday ) + 1 );
+
+        /* disable RTC operation while we update */
+        rtc_rmw32( RTC_CTRL, | ( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+
+        rtc_writel( uiTime, RTC_TIME );
+        /* msecs are 0. This gives us a whole second to write date */
+        rtc_writel( uiDate, RTC_DATE );
+
+        /* check for valid settings. do_date() performs a get() after a set(),
+         * but* someone else might not */
+        uiStatus = rtc_readl( RTC_GEN_STAT );
+        if( ( uiStatus & RTC_GEN_STAT_ALL_VALID ) != RTC_GEN_STAT_ALL_VALID )
+                eprintf( "RTC reports invalid configuration: 0x%08x\n",
+                         uiStatus );
+
+        /* let it continue */
+        rtc_rmw32( RTC_CTRL, & ~( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+        return 0;
+}
+
+#endif  /* defined(CONFIG_RTC_NS921X) && (CONFIG_COMMANDS & CFG_CMD_DATE) */
diff --git a/drivers/spi/soft_spi.c b/drivers/spi/soft_spi.c
index 13df8cb..d933d01 100644
--- a/drivers/spi/soft_spi.c
+++ b/drivers/spi/soft_spi.c
@@ -27,7 +27,7 @@
 #include <common.h>
 #include <spi.h>
 
-#include <malloc.h>
+#if defined(CONFIG_SOFT_SPI)
 
 /*-----------------------------------------------------------------------
  * Definitions
@@ -39,15 +39,13 @@
 #define PRINTD(fmt,args...)
 #endif
 
-struct soft_spi_slave {
-	struct spi_slave slave;
-	unsigned int mode;
-};
-
-static inline struct soft_spi_slave *to_soft_spi(struct spi_slave *slave)
-{
-	return container_of(slave, struct soft_spi_slave, slave);
-}
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+# include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+# include <asm-arm/arch-ns9xxx/io.h>
+#define UBOOT
+# include <nvram_types.h> /* atoi */
+int spi_delay = -1;
+#endif
 
 /*=====================================================================*/
 /*                         Public Functions                            */
@@ -59,63 +57,13 @@ static inline struct soft_spi_slave *to_soft_spi(struct spi_slave *slave)
 void spi_init (void)
 {
 #ifdef	SPI_INIT
-	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
-
+# ifdef CONFIG_SYS_IMMR
+	volatile immap_t *immr = (immap_t *)CFG_IMMR;
+# endif
 	SPI_INIT;
 #endif
 }
 
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int mode)
-{
-	struct soft_spi_slave *ss;
-
-	if (!spi_cs_is_valid(bus, cs))
-		return NULL;
-
-	ss = malloc(sizeof(struct soft_spi_slave));
-	if (!ss)
-		return NULL;
-
-	ss->slave.bus = bus;
-	ss->slave.cs = cs;
-	ss->mode = mode;
-
-	/* TODO: Use max_hz to limit the SCK rate */
-
-	return &ss->slave;
-}
-
-void spi_free_slave(struct spi_slave *slave)
-{
-	struct soft_spi_slave *ss = to_soft_spi(slave);
-
-	free(ss);
-}
-
-int spi_claim_bus(struct spi_slave *slave)
-{
-#ifdef CONFIG_SYS_IMMR
-	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
-#endif
-	struct soft_spi_slave *ss = to_soft_spi(slave);
-
-	/*
-	 * Make sure the SPI clock is in idle state as defined for
-	 * this slave.
-	 */
-	if (ss->mode & SPI_CPOL)
-		SPI_SCL(1);
-	else
-		SPI_SCL(0);
-
-	return 0;
-}
-
-void spi_release_bus(struct spi_slave *slave)
-{
-	/* Nothing to do */
-}
 
 /*-----------------------------------------------------------------------
  * SPI transfer
@@ -128,54 +76,61 @@ void spi_release_bus(struct spi_slave *slave)
  * and "din" can point to the same memory location, in which case the
  * input data overwrites the output data (since both are buffered by
  * temporary variables, this is OK).
+ *
+ * If the chipsel() function is not NULL, it is called with a parameter
+ * of '1' (chip select active) at the start of the transfer and again with
+ * a parameter of '0' at the end of the transfer.
+ *
+ * If the chipsel() function _is_ NULL, it the responsibility of the
+ * caller to make the appropriate chip select active before calling
+ * spi_xfer() and making it inactive after spi_xfer() returns.
  */
-int  spi_xfer(struct spi_slave *slave, unsigned int bitlen,
-		const void *dout, void *din, unsigned long flags)
+int  spi_xfer(spi_chipsel_type chipsel, int bitlen, uchar *dout, uchar *din)
 {
 #ifdef CONFIG_SYS_IMMR
-	volatile immap_t *immr = (immap_t *)CONFIG_SYS_IMMR;
+	volatile immap_t *immr = (immap_t *)CFG_IMMR;
 #endif
-	struct soft_spi_slave *ss = to_soft_spi(slave);
-	uchar		tmpdin  = 0;
-	uchar		tmpdout = 0;
-	const u8	*txd = dout;
-	u8		*rxd = din;
-	int		cpol = ss->mode & SPI_CPOL;
-	int		cpha = ss->mode & SPI_CPHA;
-	unsigned int	j;
+	uchar tmpdin  = 0;
+	uchar tmpdout = 0;
+	int   j;
+
+	PRINTD("spi_xfer: chipsel %d dout %08X din %08X bitlen %d\n",
+		(int)chipsel, *(uint *)dout, *(uint *)din, bitlen);
 
-	PRINTD("spi_xfer: slave %u:%u dout %08X din %08X bitlen %u\n",
-		slave->bus, slave->cs, *(uint *)txd, *(uint *)rxd, bitlen);
+#if defined(CONFIG_CC9P9215) || defined(CONFIG_CCW9P9215)
+	if (spi_delay < 0 ) {
+		char *s;
 
-	if (flags & SPI_XFER_BEGIN)
-		spi_cs_activate(slave);
+		spi_delay = 10;
+		s = getenv("spidelay");
+		if (s != NULL)
+			spi_delay = atoi(s);
+	}
+#endif
+
+	if(chipsel != NULL) {
+		(*chipsel)(1);	/* select the target chip */
+	}
 
 	for(j = 0; j < bitlen; j++) {
 		/*
 		 * Check if it is time to work on a new byte.
 		 */
 		if((j % 8) == 0) {
-			tmpdout = *txd++;
+			tmpdout = *dout++;
 			if(j != 0) {
-				*rxd++ = tmpdin;
+				*din++ = tmpdin;
 			}
 			tmpdin  = 0;
 		}
-
-		if (!cpha)
-			SPI_SCL(!cpol);
+		SPI_SCL(0);
 		SPI_SDA(tmpdout & 0x80);
 		SPI_DELAY;
-		if (cpha)
-			SPI_SCL(!cpol);
-		else
-			SPI_SCL(cpol);
-		tmpdin	<<= 1;
-		tmpdin	|= SPI_READ;
-		tmpdout	<<= 1;
+		SPI_SCL(1);
 		SPI_DELAY;
-		if (cpha)
-			SPI_SCL(cpol);
+		tmpdin  <<= 1;
+		tmpdin   |= SPI_READ;
+		tmpdout <<= 1;
 	}
 	/*
 	 * If the number of bits isn't a multiple of 8, shift the last
@@ -184,10 +139,38 @@ int  spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 	 */
 	if((bitlen % 8) != 0)
 		tmpdin <<= 8 - (bitlen % 8);
-	*rxd++ = tmpdin;
+	*din++ = tmpdin;
+
+	SPI_SCL(0);		/* SPI wants the clock left low for idle */
 
-	if (flags & SPI_XFER_END)
-		spi_cs_deactivate(slave);
+	if(chipsel != NULL) {
+		(*chipsel)(0);	/* deselect the target chip */
+
+	}
 
 	return(0);
 }
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+                                  unsigned int max_hz, unsigned int mode)
+{
+    return NULL;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+        free(slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+        return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+        return;
+}
+
+
+#endif	/* CONFIG_SOFT_SPI */
diff --git a/include/_exports.h b/include/_exports.h
index f3df568..3fd754c 100644
--- a/include/_exports.h
+++ b/include/_exports.h
@@ -24,9 +24,11 @@ EXPORT_FUNC(simple_strtol)
 EXPORT_FUNC(strcmp)
 EXPORT_FUNC(i2c_write)
 EXPORT_FUNC(i2c_read)
+    /*
 EXPORT_FUNC(spi_init)
 EXPORT_FUNC(spi_setup_slave)
 EXPORT_FUNC(spi_free_slave)
 EXPORT_FUNC(spi_claim_bus)
 EXPORT_FUNC(spi_release_bus)
 EXPORT_FUNC(spi_xfer)
+*/
diff --git a/include/asm-arm/arch-ns9xxx/fim_firmware.h b/include/asm-arm/arch-ns9xxx/fim_firmware.h
new file mode 100644
index 0000000..70a5369
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/fim_firmware.h
@@ -0,0 +1,99 @@
+/*
+ * include/asm-arm/arch-ns9xxx/fim-firmware.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ *  !Revision:   $Revision$
+ *  !Author:     Luis Galdos
+ *  !Desc:
+ *  !References:
+ */
+
+
+#ifndef _FIM_FIRMWARE_H
+#define _FIM_FIRMWARE_H
+
+
+
+#define FIM_NUM_HWA_CONF_REGS                           (14)
+#define FIM_NS9215_MAX_INSTRUCTIONS                     (1024)
+
+
+typedef enum {
+	FIM_NS9215 = 0,
+} fim_processors_t;
+
+#define PROCESSOR_TYPE_VALID(t) 	(t == FIM_NS9215) /* || (t == ADD_NEW_ONE_HERE) */
+
+
+typedef enum {
+	FIM_FORMAT_0 = 0,
+} fim_formats_t;
+
+#define FORMAT_TYPE_VALID(t) 	(t == FIM_FORMAT_0) /* || (t == ADD_NEW_ONE_HERE) */
+
+typedef enum {
+	FIM_PROCESSOR_PIC0,
+	FIM_PROCESSOR_PIC1
+} fim_processor_index_t;
+
+typedef enum {
+	FIM_HW_ASSIST_MODE_NONE,
+	FIM_HW_ASSIST_MODE_GENERIC,
+	FIM_HW_ASSIST_MODE_CAN,
+} fim_hw_assit_t;
+
+typedef enum {
+	FIM_CLK_DIV_2,
+	FIM_CLK_DIV_4,
+	FIM_CLK_DIV_8,
+	FIM_CLK_DIV_16,
+	FIM_CLK_DIV_32,
+	FIM_CLK_DIV_64,
+	FIM_CLK_DIV_128,
+	FIM_CLK_DIV_256
+} fim_output_clk_div_t;
+
+typedef enum {
+	FIM_SIGBUS_SIGNAL_0,
+	FIM_SIGBUS_SIGNAL_1,
+	FIM_SIGBUS_SIGNAL_2,
+	FIM_SIGBUS_SIGNAL_3,
+	FIM_SIGBUS_SIGNAL_4,
+	FIM_SIGBUS_SIGNAL_5,
+	FIM_SIGBUS_SIGNAL_6,
+	FIM_SIGBUS_SIGNAL_7,
+	FIM_SIGBUS_CONTROL_0,
+	FIM_SIGBUS_CONTROL_1,
+	FIM_SIGBUS_CONTROL_2,
+	FIM_SIGBUS_CONTROL_3,
+	FIM_SIGBUS_16_BIT_BUS,
+	FIM_SIGBUS_24_BIT_BUS
+} fim_signal_bus_t;
+
+
+
+/*
+ * The macro FIM_FIRMWARE_BUILDER is set by the build-system of the FIM-firmware
+ * See the Makefile under ../firmware/Makefile for more infos.
+ */
+struct fim_program_t {
+	fim_processors_t processor;
+	fim_formats_t format;
+	fim_hw_assit_t hw_mode;
+	fim_output_clk_div_t clkdiv;
+	unsigned int hwa_cfg[FIM_NUM_HWA_CONF_REGS];
+	unsigned int length;
+	unsigned short data[FIM_NS9215_MAX_INSTRUCTIONS];
+} __attribute__((packed, aligned(4)));
+
+
+#endif /* _FIM_FIRMWARE_H */
+
+
+
diff --git a/include/asm-arm/arch-ns9xxx/io.h b/include/asm-arm/arch-ns9xxx/io.h
new file mode 100644
index 0000000..aad2433
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/io.h
@@ -0,0 +1,223 @@
+/*
+ * include/asm/arch-ns9xxx/io.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+/***********************************************************************
+ *
+ * !Revision: $Revision$
+ * !Descr:    Provides XXX_readl and XXX_writel. These are OS specific
+ *            Include the header file first
+ * !Author:   Markus Pietrek
+ *
+ ***********************************************************************/
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "asm-arm/arch-ns9xxx/ns921x_hub.h"
+
+#include <asm/io.h>
+/* 
+ * u-boot is compiled with -Os -g by default. These functions are so small,
+ * and sometimes should run as fast as possible (e.g. in udelay), they should
+ * be always inlined. */
+
+
+#ifdef MEM_BASE_PA
+static inline u32  mem_readl( u32 uOffs ) __attribute__ ((always_inline));
+static inline void mem_writel( u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+
+# define mem_rmw32( offs, op ) mem_writel( mem_readl( offs ) op, (offs))
+static inline u32 mem_readl( u32 uOffs )
+{
+        u32 val = readl( MEM_BASE_PA + uOffs );
+
+        return val;
+}
+static inline void mem_writel( u32 uVal, u32 uOffs )
+{
+        writel( uVal, MEM_BASE_PA + uOffs );
+}
+#endif  /* MEM_BASE_PA */
+
+#ifdef SYS_BASE_PA
+static inline u32  sys_readl( u32 uOffs ) __attribute__ ((always_inline));
+static inline void sys_writel( u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+
+# define sys_rmw32( offs, op ) sys_writel( sys_readl( offs ) op, (offs))
+
+static inline u32 sys_readl( u32 uOffs )
+{
+        u32 uVal = readl( SYS_BASE_PA + uOffs );
+
+        return uVal;
+}
+static inline void sys_writel( u32 uVal, u32 uOffs )
+{
+        writel( uVal, SYS_BASE_PA + uOffs );
+}
+#endif  /* SYS_BASE_PA */
+
+#ifdef HUB_BASE_PA
+static inline u32  hub_port_readl( u32 uPort, u32 uOffs ) __attribute__ ((always_inline));
+static inline u8   hub_port_readb( u32 uPort, u32 uOffs ) __attribute__ ((always_inline));
+static inline void hub_port_writel( u32 uPort, u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+static inline void hub_port_writeb( u32 uPort, u8 ucVal, u32 uOffs ) __attribute__ ((always_inline));
+# define hub_rmw32( offs, op ) hub_writel( hub_readl( offs ) op, (offs))
+static inline u32 hub_port_readl( u32 uPort, u32 uOffs )
+{
+        u32 uVal = readl( HUB_BASE_PA + ( HUB_MODULE_OFFSET * uPort ) + uOffs );
+
+        return uVal;
+}
+static inline u8 hub_port_readb( u32 uPort, u32 uOffs )
+{
+        u8 ucVal = readb( HUB_BASE_PA + ( HUB_MODULE_OFFSET * uPort ) + uOffs );
+
+        return ucVal;
+}
+static inline void hub_port_writel( u32 uPort, u32 uVal, u32 uOffs )
+{
+        writel( uVal, HUB_BASE_PA + ( HUB_MODULE_OFFSET * uPort ) + uOffs );
+}
+static inline void hub_port_writeb( u32 uPort, u8 ucVal, u32 uOffs )
+{
+        writeb( ucVal, HUB_BASE_PA + ( HUB_MODULE_OFFSET * uPort ) + uOffs );
+}
+#endif  /* HUB_BASE_PA */
+
+#ifdef GPIO_BASE_PA
+static inline u32  gpio_readl( u32 uOffs ) __attribute__ ((always_inline));
+static inline void gpio_writel( u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+static inline uint gpio_cfg_bit_pos( uint uPin ) __attribute__ ((always_inline));
+static inline uint gpio_cfg_reg_offs( uint uPin ) __attribute__ ((always_inline));
+static inline void gpio_cfg_set( uint uPin, uint uFunction ) __attribute__ ((always_inline));
+static inline int  gpio_cfg_get( uint uPin ) __attribute__ ((always_inline));
+static inline uint gpio_ctrl_reg_offs ( uint uPin ) __attribute__ ((always_inline));
+static inline uint gpio_ctrl_bit_pos ( uint uPin ) __attribute__ ((always_inline));
+static inline void gpio_ctrl_set( uint uPin, uchar uVal ) __attribute__ ((always_inline));
+static inline uchar gpio_ctrl_get( uint uPin ) __attribute__ ((always_inline));
+static inline uchar gpio_stat_get( uint uPin ) __attribute__ ((always_inline));
+
+static inline u32 gpio_readl( u32 uOffs )
+{
+        u32 uVal = readl( GPIO_BASE_PA + uOffs );
+
+        return uVal;
+}
+static inline void gpio_writel( u32 uVal, u32 uOffs )
+{
+        writel( uVal, GPIO_BASE_PA + uOffs );
+}
+
+static inline uint gpio_cfg_bit_pos( uint uPin )
+{
+        return ( uPin & 0x3 ) * 8;
+}
+
+static inline uint gpio_cfg_reg_offs( uint uPin )
+{
+        return ( uPin / 4 ) * 4;
+}
+
+static inline void gpio_cfg_set( uint uPin, uint uFunction )
+{
+        u32  uOffs   = GPIO_CFG_BASE + gpio_cfg_reg_offs( uPin );
+        u32  uBitpos = gpio_cfg_bit_pos( uPin );
+        u32  uVal    = ( ( gpio_readl( uOffs ) & ~( 0xff << uBitpos ) ) |
+                        ( uFunction << uBitpos ) );
+
+        gpio_writel( uVal, uOffs );
+}
+
+static inline int gpio_cfg_get( uint uPin )
+{
+        u32 uOffs   = GPIO_CFG_BASE + gpio_cfg_reg_offs( uPin );
+        u32 uBitpos = gpio_cfg_bit_pos( uPin );
+        u32 uVal    = ( gpio_readl( uOffs ) >> uBitpos ) & 0xff;
+
+        return uVal;
+}
+
+static inline uint gpio_ctrl_reg_offs ( uint uPin )
+{
+        return ( uPin / 32 ) * 4;
+}
+
+static inline uint gpio_ctrl_bit_pos ( uint uPin )
+{
+        return uPin & 0x1f;
+}
+
+static inline void gpio_ctrl_set( uint uPin, uchar uVal )
+{
+        u32 uOffs   = GPIO_CTRL_BASE + gpio_ctrl_reg_offs( uPin );
+        u32 uBitpos = gpio_ctrl_bit_pos( uPin );
+        
+        gpio_writel( ( (gpio_readl( uOffs ) & ~( 1 << uBitpos ) ) |
+                          ( ( ( uVal & 0x1 ) << uBitpos ) ) ),
+                        uOffs );
+}
+
+static inline uchar gpio_ctrl_get( uint uPin )
+{
+        u32 uOffs   = GPIO_CTRL_BASE + gpio_ctrl_reg_offs( uPin );
+        u32 uBitpos = gpio_ctrl_bit_pos( uPin );
+        u32 uVal    = gpio_readl( uOffs );
+
+        return ( uVal >> uBitpos ) & 0x1;
+}
+
+static inline uchar gpio_stat_get( uint uPin )
+{
+        u32 uOffs   = GPIO_STAT_BASE + gpio_ctrl_reg_offs( uPin );
+        u32 uBitpos = gpio_ctrl_bit_pos( uPin );
+        uchar ucVal = ( gpio_readl( uOffs ) >> uBitpos ) & 0x1;
+
+        return ucVal;
+}
+#endif  /* GPIO_BASE_PA */
+
+#ifdef RTC_BASE_PA
+static inline u32  rtc_readl( u32 uOffs ) __attribute__ ((always_inline));
+static inline void rtc_writel( u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+
+# define rtc_rmw32( offs, op ) rtc_writel( rtc_readl( offs ) op, (offs))
+
+static inline u32 rtc_readl( u32 uOffs )
+{
+        u32 uVal = readl( RTC_BASE_PA + uOffs );
+
+        return uVal;
+}
+static inline void rtc_writel( u32 uVal, u32 uOffs )
+{
+        writel( uVal, RTC_BASE_PA + uOffs );
+}
+#endif  /* RTC_BASE_PA */
+
+#ifdef ADC_BASE_PA
+static inline u32  adc_readl( u32 uOffs ) __attribute__ ((always_inline));
+static inline void adc_writel( u32 uVal, u32 uOffs ) __attribute__ ((always_inline));
+
+# define adc_rmw32( offs, op ) adc_writel( adc_readl( offs ) op, (offs))
+
+static inline u32 adc_readl( u32 uOffs )
+{
+        u32 uVal = readl( ADC_BASE_PA + uOffs );
+
+        return uVal;
+}
+static inline void adc_writel( u32 uVal, u32 uOffs )
+{
+        writel( uVal, ADC_BASE_PA + uOffs );
+}
+#endif  /* ADC_BASE_PA */
+
+#endif /* __ASM_ARCH_IO_H */
diff --git a/include/asm-arm/arch-ns9xxx/ns9215_adc.h b/include/asm-arm/arch-ns9xxx/ns9215_adc.h
new file mode 100644
index 0000000..cb78d0b
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns9215_adc.h
@@ -0,0 +1,46 @@
+/*
+ *  include/asm-arm/arch-ns9xxx/ns9215_adc.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#ifndef __ASM_ARCH_NS9215_ADC_H
+#define __ASM_ARCH_NS9215_ADC_H
+
+#define ADC_BASE_PA		0x90039000
+
+#define ADC_CFG			0x0000
+#define ADC_CLOCK_CFG		0x0004
+#define ADC_OUTPUT_BASE		0x0008
+
+/* the vectored register addresses */
+
+#define ADC_OUTPUT( ch )	( ADC_OUTPUT_BASE + ( ( ch ) & 0x7 ) * 4 )
+
+/* register bit fields */
+
+#define ADC_CFG_EN		0x80000000
+#define ADC_CFG_INTSTAT( reg )	( ( ( reg ) >> 16 ) & 0x7 )
+#define ADC_CFG_INTCLR		0x00000010
+#define ADC_CFG_DMAEN		0x00000008
+#define ADC_CFG_SEL_SET( ch )	( ( ch ) & 0x7 )
+#define ADC_CFG_SEL_GET( reg )	( ( reg ) & 0x7 )
+
+#define ADC_CLOCK_CFG_WAIT_MA       0xffff0000
+#define ADC_CLOCK_CFG_WAIT_SET(val) ( ( (val) << 16 ) & ADC_CLOCK_CFG_WAIT_MA )
+#define ADC_CLOCK_CFG_WAIT_GET(reg) ( ( (reg) & ADC_CLOCK_CFG_WAIT_MA ) >> 16 )
+#define ADC_CLOCK_CFG_N_MA          0x000001ff
+#define ADC_CLOCK_CFG_N_SET(val)    ( ( val ) & ADC_CLOCK_CFG_N_MA )
+#define ADC_CLOCK_CFG_N_GET(reg)    ( ( reg ) & ADC_CLOCK_CFG_N_MA )
+
+#endif /*__ASM_ARCH_NS9215_ADC_H*/
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_dma.h b/include/asm-arm/arch-ns9xxx/ns921x_dma.h
new file mode 100644
index 0000000..eb10391
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_dma.h
@@ -0,0 +1,65 @@
+/*
+ * include/asm-arm/arch-ns9xxx/dma-ns921x.h
+ *
+ * Copyright (C) 2006 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ *  !Revision:   $Revision$
+ *  !Author:     Luis Galdos
+ *  !Desc:
+ *  !References:
+ */
+
+
+#ifndef __ASM_ARCH_NS921X_DMA_H
+#define __ASM_ARCH_NS921X_DMA_H
+
+
+/* 
+ * The maximal number of DMA-buffer descriptors comes from the NET+OS 
+ * distribution (iop_private.h) 
+ */
+#define IOHUB_MAX_DMA_BUFFERS                   (64)
+#define IOHUB_MAX_DMA_LENGTH                    (65535)
+
+
+#define IOHUB_DMA_DESC_CTRL_WRAP                0x8000
+#define IOHUB_DMA_DESC_CTRL_INT                 0x4000
+#define IOHUB_DMA_DESC_CTRL_LAST                0x2000
+#define IOHUB_DMA_DESC_CTRL_FULL                0x1000
+#define IOHUB_DMA_DESC_CTRL_ALL                 (IOHUB_DMA_DESC_CTRL_FULL | \
+                                                IOHUB_DMA_DESC_CTRL_INT | \
+                                                IOHUB_DMA_DESC_CTRL_LAST | \
+                                                IOHUB_DMA_DESC_CTRL_WRAP)
+
+struct iohub_dma_desc_t {
+    unsigned int src;
+    unsigned int length;
+    unsigned int reserved;
+    unsigned short status;
+    unsigned short control;
+}__attribute__((__packed__, aligned(4)));
+
+
+#define IOHUB_DMA_DESC_LENGTH                   sizeof(struct iohub_dma_desc_t)
+
+
+/* This is the FIFO used for the DMA-transfers of the IOHUB (e.g. FIMs) */
+struct iohub_dma_fifo_t {
+    int length;
+    struct iohub_dma_desc_t **descs;
+    dma_addr_t phys_descs;
+    struct iohub_dma_desc_t *first;
+    struct iohub_dma_desc_t *last;
+    struct iohub_dma_desc_t *dma_first;
+    struct iohub_dma_desc_t *dma_last;
+    struct iohub_dma_desc_t *dma_next;
+    struct iohub_dma_desc_t *next_free;
+};
+
+
+#endif /* ifndef __ASM_ARCH_NS912X_DMA_H */
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_fim.h b/include/asm-arm/arch-ns9xxx/ns921x_fim.h
new file mode 100644
index 0000000..96352bf
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_fim.h
@@ -0,0 +1,184 @@
+/* -*- linux-c -*-
+ * include/asm-arm/arch-ns9xxx/fim-ns921x.h
+ *
+ * Copyright (C) 2008 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ *  !Revision:   $Revision$
+ *  !Author:     Silvano Najera, Luis Galdos
+ *  !Descr:      
+ *  !References:
+ */
+
+
+#ifndef _NS921X_FIM_API_H
+#define _NS921X_FIM_API_H
+
+
+#include <asm-arm/arch-ns9xxx/ns921x_dma.h>
+
+
+#define FIM_MAX_FIRMWARE_NAME			32
+
+
+/* For DMA handling... */
+#define	FIM_DMA_NCIP				(0x1)
+#define FIM_DMA_NRIP				(0x2)
+#define FIM_DMA_ECIP				(0x4)
+#define FIM_DMA_CAIP				(0x8)
+#define FIM_DMA_CANCELLED			FIM_DMA_CAIP
+#define FIM_DMA_FLUSHED				(0x10)
+#define FIM_DMA_SUCCESS		         	(FIM_DMA_NCIP | FIM_DMA_NRIP)
+
+
+#define FIM_MAX_PIC_INDEX			(1)
+#define FIM_MIN_PIC_INDEX			(0)
+#define FIM_NR_PICS				(FIM_MAX_PIC_INDEX-FIM_MIN_PIC_INDEX+1)
+
+
+/* @XXX: Place this macros in another place? */
+#define NS92XX_FIM_GEN_CTRL_STOP_PIC		~NS92XX_FIM_GEN_CTRL_PROGMEM
+#define NS92XX_FIM_GEN_CTRL_START_PIC		NS92XX_FIM_GEN_CTRL_PROGMEM
+
+
+
+/* Please note that the maximal DMA-buffer size is 64kB */
+/* @FIXME: Check that the maximal size of the descriptors is littler than one page */
+#define PIC_DMA_RX_BUFFERS			(10)
+#define PIC_DMA_TX_BUFFERS			(10)
+#define PIC_DMA_BUFFER_SIZE			(1 * PAGE_SIZE)
+
+/*
+ * Internal structure for handling with the DMA-buffer descriptors
+ * p_desc : Physical descriptors address
+ * v_desc : Virtual access address for the descriptors
+ * v_buf  : Virtual address of the memory buffers
+ * length : Configured length of this buffer
+ * tasked : Used for locking the descriptor
+ */
+struct pic_dma_desc_t {
+	dma_addr_t src;
+	size_t length;
+//	atomic_t tasked;
+	void *private;
+	int total_length;
+};
+
+
+/*
+ * Structure used by the FIM-API to configure the DMA-buffer and buffer-descriptors.
+ * rxnr : Number of RX-DMA-buffers
+ * rxsz : Size of each DMA-buffer (in Bytes)
+ * txnr : Number of TX-DMA-buffers
+ * txsz : Size for each TX-buffer (in Bytes)
+ */
+struct fim_dma_cfg_t {
+	int rxnr;
+	int rxsz;
+	int txnr;
+	int txsz;
+};
+
+
+/*
+ * This structure should be used for transferring data with the API
+ * length  : Date length to transfer
+ * data    : Data buffer
+ * private : The API will not touch this pointer
+ * sent    : The external driver can use it for waking up sleeping processes
+ */
+struct fim_buffer_t {
+	int length;
+	unsigned char *data;
+	void *private;
+	int sent;
+};
+
+
+/* @TODO: We need perhaps another PIC-structure for the U-Boot */
+struct pic_t {
+	int irq;
+	struct device *dev;
+	u32 reg_addr;
+	u32 instr_addr;
+	u32 hwa_addr;
+	u32 iohub_addr;
+//	spinlock_t lock;
+	int index;
+//	atomic_t irq_enabled;
+	int requested;
+	
+	/* RX-DMA structures */
+	struct iohub_dma_fifo_t rx_fifo;
+//	spinlock_t rx_lock;
+	struct fim_dma_cfg_t dma_cfg;
+	
+	/* Variables for the DMA-memory buffers */
+	dma_addr_t dma_phys;
+//	void __iomem *dma_virt;
+	size_t dma_size;
+	
+	/* Data for the handling of the TX-DMA buffers */
+//	spinlock_t tx_lock;
+	struct pic_dma_desc_t *tx_desc;
+	struct iohub_dma_fifo_t tx_fifo;
+//	atomic_t tx_tasked;
+//	atomic_t tx_aborted;
+	
+	/* Info data for the sysfs */
+	char fw_name[FIM_MAX_FIRMWARE_NAME];
+	int fw_length;
+
+	/* Functions for a low level access to the PICs */
+	int (* is_running)(struct pic_t *);
+	int (* start_at_zero)(struct pic_t *);
+	int (* stop_and_reset)(struct pic_t *);
+	int (* download_firmware)(struct pic_t *, const unsigned char *);
+	int (* get_ctrl_reg)(struct pic_t *, int , unsigned int *);
+	void (* set_ctrl_reg)(struct pic_t *, int , unsigned int );
+	int (* get_exp_reg)(struct pic_t *, int , unsigned int *);
+	int (* send_interrupt)(struct pic_t *, u32 );
+};
+
+
+/*
+ * Structure with the GPIOs to use for the driver to be initialized
+ * nr     : GPIO number
+ * name   : Name to use for the GPIO
+ * picval : Value to pass to the PIC-firmware
+ * All GPIOs will be configured with NS921X_GPIO_CFG_FUNC_0 for the FIM-support
+ */
+struct fim_gpio_t {
+	int nr;
+	char *name;
+	unsigned char picval;  /* Value to pass to firmware */
+};
+
+#define FIM_LAST_GPIO			-1
+
+
+/* These are the functions of the FIM-API */
+int fim_core_init(int pic_num, const unsigned char *fwbuf);
+int pic_is_running(int pic_num);
+int fim_send_interrupt(int pic_num, unsigned int code);
+
+int fim_get_iohub_reg(int pic_num, int reg);
+int fim_get_ctrl_reg(int pic_num, int reg);
+int fim_get_exp_reg(int pic_num, int nr);
+void fim_set_iohub_reg(int pic_num, int reg, unsigned int val);
+void fim_set_ctrl_reg(int pic_num, int reg, unsigned int val);
+
+
+struct fim_buffer_t *fim_wait_rxdma(int pic, uint timeout);
+int fim_wait_txdma(int pic);
+int fim_send_buffer(int pic, struct fim_buffer_t *buffer);
+int fim_init_rxdma(int pic);
+
+#endif /* ifndef _NS921X_FIM_API_H */
+
+
+
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_gpio.h b/include/asm-arm/arch-ns9xxx/ns921x_gpio.h
new file mode 100644
index 0000000..0d3db84
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_gpio.h
@@ -0,0 +1,48 @@
+/*
+ * include/asm/arch-ns9xxx/ns921x_gpio.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+/***********************************************************************
+ *
+ * !Revision: $Revision$
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ * !Author:   Markus Pietrek
+ *
+ ***********************************************************************/
+
+#ifndef __ASM_ARCH_NS921X_GPIO_H
+#define __ASM_ARCH_NS921X_GPIO_H
+
+#define GPIO_BASE_PA		0xA0902000
+
+#define GPIO_GPIO_NR	        108
+#define GPIO_CFG_BASE	   	0x0000
+#define GPIO_CTRL_BASE		0x006C
+#define GPIO_STAT_BASE		0x007C
+#define GPIO_MEM		0x008C
+
+/* register bit fields */
+
+#define GPIO_CFG_MA		0xFF
+#define GPIO_CFG_INPUT	   	0x00
+#define GPIO_CFG_OUTPUT	   	0x04
+#define GPIO_CFG_FUNC_4	   	0x20
+#define GPIO_CFG_FUNC_GPIO	0x18
+#define GPIO_CFG_FUNC_2	   	0x10
+#define GPIO_CFG_FUNC_1	   	0x08
+#define GPIO_CFG_FUNC_0	   	0x00
+#define GPIO_CFG_PULLUP_DISABLE 0x01
+
+#define GPIO_MEM_APUEN		0x02000000
+#define GPIO_MEM_DHPUEN		0x01000000
+#define GPIO_MEM_CS( cs, val )	( ( ( val ) & 0x7 ) << ( 3 * cs ) )
+#define GPIO_MEM_DYN( cs )   	( cs )
+#define GPIO_MEM_STAT( cs )  	( 4 + ( cs ) )
+
+#endif /*__ASM_ARCH_NS921X_GPIO_H */
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_hub.h b/include/asm-arm/arch-ns9xxx/ns921x_hub.h
new file mode 100644
index 0000000..d09ba57
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_hub.h
@@ -0,0 +1,269 @@
+/*
+ * include/asm/arch-ns9xxx/ns921x_hub.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+/***********************************************************************
+ *
+ * !Revision: $Revision: 1.3 $
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ * !Descr:    To get a register address,
+ *            HUB_BASE_PA + ( UART_A * HUB_MODULE_OFFSET ) + UART_INT_ENABLE
+ * !Author:   Markus Pietrek
+ *
+ ***********************************************************************/
+
+#ifndef __ASM_ARCH_NS921X_HUB_H
+#define __ASM_ARCH_NS921X_HUB_H
+
+/* from Hub Module */
+#define HUB_BASE_PA		0x90010000
+
+#define HUB_INT			0x0000
+#define HUB_DMA_RX_CTRL		0x0004
+#define HUB_DMA_RX_DESCR	0x0008
+#define HUB_RX_INT		0x000C
+#define HUB_RX_FIFO_STAT        0x0010
+#define HUB_RX_FIFO		0x0014
+#define HUB_DMA_TX_CTRL		0x0018
+#define HUB_DMA_TX_DESCR	0x001C
+#define HUB_TX_INT		0x0020
+#define HUB_TX_FIFO		0x0028
+#define HUB_TX_FIFO_LAST	0x002C
+
+#define HUB_MODULE_OFFSET	0x8000  /* offset between different UARTs*/
+
+#define UART_PORT_A		0
+#define UART_PORT_B		1
+#define UART_PORT_C		2
+#define UART_PORT_D		3
+
+/* UART Register Mask */
+#define UART_WRAPPER_CFG	0x1000
+#define UART_INT_EN		0x1004
+#define UART_INT_STAT		0x1008
+#define UART_CGAP_CTRL		0x100C
+#define UART_BGAP_CTRL		0x1010
+#define UART_CMATCH_CTRL( c ) ( 0x1014 + (c) * 4 )
+#define UART_CFLOW_CTRL		0x1028
+#define UART_FORCE_TX_CHAR_CTRL	0x102C
+#define UART_ARM_WAKEUP_CTRL	0x1030
+#define UART_TX_BYTE_COUNT	0x1034
+
+/* these are 16750 UART Register. NS in their forethought foregot to mention
+   that they are using 16750 internally. */
+
+#define UART_RX_BUFFER		0x1100  /* only read,  dlab = 0 */
+#define UART_TX_BUFFER		0x1100  /* only write, dlab = 0 */
+#define UART_BAUD_INT		0x1104  /* dlab = 0 */
+#define UART_BRDL		0x1100  /* dlab = 1 */
+#define UART_BRDM		0x1104  /* dlab = 1 */
+#define UART_ID			0x1108  /* read */
+#define UART_FIFO_CTRL		0x1108  /* only write */
+#define UART_LINE_CTRL		0x110C
+#define UART_MODEM_CTRL		0x1110
+#define UART_LINE_STAT		0x1114
+#define UART_MODEM_STAT		0x1118
+#define UART_SCRATCH		0x111C
+
+/* HUB register bit fields */
+
+#define HUB_INT_RX_NCIP		0x80000000
+#define HUB_INT_RX_EICP		0x40000000
+#define HUB_INT_RX_NRIP		0x20000000
+#define HUB_INT_RX_CAIP		0x10000000
+#define HUB_INT_RX_PCIP		0x08000000
+#define HUB_INT_RX_FOFIP	0x04000000
+#define HUB_INT_RX_FSRIP	0x02000000
+#define HUB_INT_TX_NCIP		0x01000000
+#define HUB_INT_TX_ECIP		0x00800000
+#define HUB_INT_TX_NRIP		0x00400000
+#define HUB_INT_TX_CAIPP	0x00200000
+#define HUB_INT_TX_FUFIP	0x00100000
+#define HUB_INT_TX_FSRIP	0x00080000
+#define HUB_INT_MODIP  		0x00040000
+#define HUB_INT_RX_PBUSY	0x00008000
+#define HUB_INT_RX_FIFO_FULL	0x00004000
+#define HUB_INT_RX_FIFO_EMPTY	0x00002000
+#define HUB_INT_TX_PBUSY	0x00001000
+#define HUB_INT_TX_FIFO_FULL	0x00000800
+#define HUB_INT_TX_FIFO_EMPTY	0x00000400
+
+#define HUB_DMA_RX_CTRL_CE	0x80000000
+#define HUB_DMA_RX_CTRL_CA	0x40000000
+#define HUB_DMA_RX_CTRL_CPU	0x00000000
+#define HUB_DMA_RX_CTRL_FLEX	0x20000000
+#define HUB_DMA_RX_CTRL_DIRECT	0x10000000
+#define HUB_DMA_RX_CTRL_STATE_MA 0x0000FC00
+#define HUB_DMA_RX_CTRL_INDEX    0x000003FF
+
+#define HUB_RX_INT_THRS(c)  	(( (c) & 0x7) << 29 )
+#define HUB_RX_INT_FOFIE    	0x04000000
+#define HUB_RX_INT_FSRIE    	0x02000000
+#define HUB_RX_INT_NCIE		0x01000000
+#define HUB_RX_INT_ECIE		0x00800000
+#define HUB_RX_INT_NRIE		0x00400000
+#define HUB_RX_INT_CAIE		0x00200000
+#define HUB_RX_INT_PCIE		0x00100000
+#define HUB_RX_INT_WSTAT	0x00080000
+#define HUB_RX_INT_ISTAT	0x00040000
+#define HUB_RX_INT_LSTAT	0x00020000
+#define HUB_RX_INT_FSTAT	0x00010000
+#define HUB_RX_INT_BLENSTAT	0x0000FFFF
+
+#define HUB_RX_FIFO_STAT_EMPTY	0x00002000
+#define HUB_RX_FIFO_STAT_FULL	0x00001000
+#define HUB_RX_FIFO_BYTE(val)	(((val) >> 9 ) & 0x7)
+#define HUB_RX_FIFO_FFLAG	0x00000080
+#define HUB_RX_FIFO_PSTAT_MA	0x0000007F
+
+#define HUB_DMA_TX_CTRL_CE	0x80000000
+#define HUB_DMA_TX_CTRL_CA	0x40000000
+#define HUB_DMA_TX_CTRL_CPU	0x00000000
+#define HUB_DMA_TX_CTRL_FLEX	0x20000000
+#define HUB_DMA_TX_CTRL_DIRECT	0x10000000
+#define HUB_DMA_TX_CTRL_STATE_MA 0x0000FC00
+#define HUB_DMA_TX_CTRL_INDEX    0x000003FF
+
+#define HUB_TX_INT_THRS(c)  	(( (c) & 0x7) << 29 )
+#define HUB_TX_INT_FUFIE	0x04000000
+#define HUB_TX_INT_FSRIE	0x02000000
+#define HUB_TX_INT_NCIE		0x01000000
+#define HUB_TX_INT_ECIE		0x00800000
+#define HUB_TX_INT_NRIE		0x00400000
+#define HUB_TX_INT_CAIE		0x00200000
+#define HUB_TX_INT_WSTAT 	0x00080000
+#define HUB_TX_INT_ISTAT	0x00040000
+#define HUB_TX_INT_LSTAT	0x00020000
+#define HUB_TX_INT_FSTAT	0x00010000
+#define HUB_TX_INT_BLENSTAT	0x0000FFFF
+
+/* UART register bit fields */
+
+#define UART_WRAPPER_CFG_RX_EN	     0x40000000
+#define UART_WRAPPER_CFG_TX_EN	     0x20000000
+#define UART_WRAPPER_CFG_MODE_UART   0x00000000
+#define UART_WRAPPER_CFG_MODE_HDLC   0x10000000
+#define UART_WRAPPER_CFG_RTS_EN	     0x00080000
+#define UART_WRAPPER_CFG_DTR_EN	     0x00040000
+#define UART_WRAPPER_CFG_RX_FLUSH    0x00020000
+#define UART_WRAPPER_CFG_TX_FLUSH    0x00010000
+#define UART_WRAPPER_CFG_RX_BYTES(c) (( (c) >> 14 ) & 0x3 )
+#define UART_WRAPPER_CFG_RX_CLOSE    0x00002000
+#define UART_WRAPPER_CFG_TX_FLOW_MA  0x00000FC0
+#define UART_WRAPPER_CFG_TX_FLOW_CTS 0x00000040
+#define UART_WRAPPER_CFG_TX_FLOW_DCD 0x00000080
+#define UART_WRAPPER_CFG_TX_FLOW_DSR 0x00000100
+#define UART_WRAPPER_CFG_TX_FLOW_RI  0x00000200
+#define UART_WRAPPER_CFG_TX_FLOW_SW  0x00000400
+#define UART_WRAPPER_CFG_TX_FLOW_RX  0x00000800
+#define UART_WRAPPER_CFG_RL	     0x00000020
+#define UART_WRAPPER_CFG_RTS	     0x00000010
+#define UART_WRAPPER_CFG_RS485OFF_0   0x00000000
+#define UART_WRAPPER_CFG_RS485OFF_1   0x00000004
+#define UART_WRAPPER_CFG_RS485OFF_1_5 0x00000008
+#define UART_WRAPPER_CFG_RS485OFF_2   0x0000000C
+#define UART_WRAPPER_CFG_RS485ON_0    0x00000000
+#define UART_WRAPPER_CFG_RS485ON_1    0x00000001
+#define UART_WRAPPER_CFG_RS485ON_1_5  0x00000002
+#define UART_WRAPPER_CFG_RS485ON_2    0x00000003
+
+#define UART_INT_UINT		0x00200000
+#define UART_INT_FORCE		0x00100000
+#define UART_INT_OFLOW		0x00080000
+#define UART_INT_PARITY		0x00040000
+#define UART_INT_FRAME		0x00020000
+#define UART_INT_BREAK		0x00010000
+#define UART_INT_BGAP		0x00008000
+#define UART_INT_RX_CLS		0x00004000
+#define UART_INT_CGAP		0x00002000
+#define UART_INT_MATCH(c)	( 1 << ( ( c ) + 8 ) )
+#define UART_INT_DSR		0x00000080
+#define UART_INT_DCD		0x00000040
+#define UART_INT_CTS		0x00000020
+#define UART_INT_RI		0x00000010
+#define UART_INT_TBC		0x00000008
+#define UART_INT_RBC		0x00000004
+#define UART_INT_TX_IDLE	0x00000002
+#define UART_INT_RX_IDLE	0x00000001
+
+/* INT Status is the same */
+
+#define UART_CGAP_CTRL_EN	0x80000000
+#define UART_CGAP_CTRL_VAL(c) 	( ( c ) & 0x00ffffff )
+
+#define UART_BGAP_CTRL_EN	0x80000000
+#define UART_BGAP_CTRL_VAL(c) 	( ( c ) & 0x00ffffff )
+
+#define UART_CMATCH_CTRL_EN	0x80000000
+#define UART_CMATCH_CTRL_MASK(c) ( ( ( c ) & 0xff ) << 16 )
+#define UART_CMATCH_CTRL_DATA(c) ( ( c ) & 0xff )
+#define UART_CFLOW_CTRL_STATE 	0x00000400
+#define UART_CFLOW_CTRL_DIS(c) 	0
+#define UART_CFLOW_CTRL_XON(c)  ( 2 << ( ( c ) * 2 ) )
+#define UART_CFLOW_CTRL_XOFF(c) ( 3 << ( ( c ) * 2  ) )
+
+#define UART_FORCE_TX_CHAR_CTRL_EN     0x80000000
+#define UART_FORCE_TX_CHAR_CTRL_BUSY   0x40000000
+#define UART_FORCE_TX_CHAR_CTRL_VAL(c) ( ( c ) & 0xff )
+ 
+#define UART_ARM_WAKEUP_CTRL_EN	0x00000001
+
+#define UART_TX_BYTE_COUNT_EN	  0x80000000
+#define UART_TX_BYTE_COUNT_VAL(c) ( ( c ) & 0x00ffffff )
+#define UART_RX_BUFFER_VAL(c)   ( ( c ) & 0xff )
+#define UART_TX_BUFFER_VAL(c)   ( ( c ) & 0xff )
+
+#define UART_BAUD_INT_ETBEI	0x00000002
+#define UART_BAUD_INT_ERBFI	0x00000001
+
+#define UART_BRDL_VAL(c)        ( ( c ) & 0xff )
+#define UART_BRDM_VAL(c)        ( ( c ) & 0xff )
+
+#define UART_FIFO_CTRL_TX_CLEAR 0x00000004
+#define UART_FIFO_CTRL_RX_CLEAR 0x00000002
+#define UART_FIFO_CTRL_EN	0x00000001
+
+#define UART_LINE_CTRL_DLAB	0x00000080
+#define UART_LINE_CTRL_SB	0x00000040
+#define UART_LINE_CTRL_SP	0x00000020
+#define UART_LINE_CTRL_EPS	0x00000010
+#define UART_LINE_CTRL_PAR_NO	0x00000000
+#define UART_LINE_CTRL_PAR_EN	0x00000008
+#define UART_LINE_CTRL_STOP_1	0x00000000
+#define UART_LINE_CTRL_STOP_2	0x00000004
+#define UART_LINE_CTRL_WLS_MA	0x00000003
+#define UART_LINE_CTRL_WLS_5	0x00000000
+#define UART_LINE_CTRL_WLS_6	0x00000001
+#define UART_LINE_CTRL_WLS_7	0x00000002
+#define UART_LINE_CTRL_WLS_8	0x00000003
+
+#define UART_MODEM_CTRL_AFE	0x00000020
+#define UART_MODEM_CTRL_LLB	0x00000010
+#define UART_MODEM_CTRL_RTS	0x00000002
+#define UART_MODEM_CTRL_DTR	0x00000001
+
+#define UART_LINE_STAT_FIER	0x00000080
+#define UART_LINE_STAT_TEMT	0x00000040
+#define UART_LINE_STAT_THRE	0x00000020
+#define UART_LINE_STAT_BI	0x00000010
+#define UART_LINE_STAT_FE	0x00000008
+#define UART_LINE_STAT_PE	0x00000004
+#define UART_LINE_STAT_OE	0x00000002
+#define UART_LINE_STAT_DR	0x00000001
+
+#define UART_MODEM_STAT_DCD	0x00000080
+#define UART_MODEM_STAT_RI	0x00000040
+#define UART_MODEM_STAT_DSR	0x00000020
+#define UART_MODEM_STAT_CTS	0x00000010
+#define UART_MODEM_STAT_DCDC	0x00000008
+#define UART_MODEM_STAT_TERI	0x00000004
+#define UART_MODEM_STAT_DDSR	0x00000002
+#define UART_MODEM_STAT_DCTS	0x00000001
+
+#endif /*__ASM_ARCH_NS921X_HUB_H */
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_rtc.h b/include/asm-arm/arch-ns9xxx/ns921x_rtc.h
new file mode 100644
index 0000000..38a95a9
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_rtc.h
@@ -0,0 +1,83 @@
+/*
+ *  include/asm-arm/arch-ns9xxx/ns921x_rtc.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+*/
+
+#ifndef __ASM_ARCH_NS921X_RTC_H
+#define __ASM_ARCH_NS921X_RTC_H
+
+#define RTC_BASE_PA		0x90060000
+
+#define RTC_CTRL		0x0000
+#define RTC_24H			0x0004
+#define RTC_TIME		0x0008
+#define RTC_DATE		0x000C
+#define RTC_ALARM_TIME		0x0010
+#define RTC_ALARM_CALENDAR	0x0014
+#define RTC_ALARM_EN		0x0018
+#define RTC_EVENT		0x001C
+#define RTC_INT_EN		0x0020
+#define RTC_INT_DIS		0x0024
+#define RTC_INT_STAT		0x0028
+#define RTC_GEN_STAT		0x002C
+
+/* register bit fields */
+
+#define RTC_CTRL_CAL		0x00000002
+#define RTC_CTRL_TIME		0x00000001
+
+#define RTC_24H_12		0x00000001
+#define RTC_24H_24		0x00000000
+
+#define RTC_TIME_PM		0x40000000
+
+/* GET returns BCD code, SET expects BCD */
+#define RTC_TIME_HR_GET( reg )	( ( ( reg ) >> 24  ) & 0x3f )
+#define RTC_TIME_HR_SET( val )	( ( ( val ) & 0x3f ) << 24  )
+#define RTC_TIME_M_GET( reg  )	( ( ( reg ) >> 16  ) & 0x7f )
+#define RTC_TIME_M_SET( val  )	( ( ( val ) & 0x7f ) << 16  )
+#define RTC_TIME_S_GET( reg  )	( ( ( reg ) >> 8   ) & 0x7f )
+#define RTC_TIME_S_SET( val  )	( ( ( val ) & 0x7f ) << 8   )
+#define RTC_TIME_H_GET( reg  )	( ( ( reg ) & 0xff ) )
+#define RTC_TIME_H_SET( val  )	( ( ( val ) & 0xff ) )
+
+#define RTC_DATE_C_GET( reg )	( ( ( reg ) >> 24  ) & 0x3f )
+#define RTC_DATE_C_SET( val )	( ( ( val ) & 0x3f ) << 24  )
+#define RTC_DATE_Y_GET( reg )	( ( ( reg ) >> 16  ) & 0xff )
+#define RTC_DATE_Y_SET( val )	( ( ( val ) & 0xff ) << 16  )
+#define RTC_DATE_D_GET( reg )	( ( ( reg ) >> 8   ) & 0x3f )
+#define RTC_DATE_D_SET( val )	( ( ( val ) & 0x3f ) << 8   )
+#define RTC_DATE_M_GET( reg )	( ( ( reg ) >> 3   ) & 0x1f )
+#define RTC_DATE_M_SET( val )	( ( ( val ) & 0x1f ) << 3   )
+#define RTC_DATE_DAY_GET( reg )	( ( ( reg ) & 0x7  ) )
+#define RTC_DATE_DAY_SET( val )	( ( ( val ) & 0x7  ) )
+
+#define RTC_GEN_STAT_VCAC	0x00000008
+#define RTC_GEN_STAT_VTAC	0x00000004
+#define RTC_GEN_STAT_VCC	0x00000002
+#define RTC_GEN_STAT_VTC	0x00000001
+#define RTC_GEN_STAT_ALL_VALID	( RTC_GEN_STAT_VCAC | \
+                                  RTC_GEN_STAT_VTAC | \
+                                  RTC_GEN_STAT_VCC  | \
+                                  RTC_GEN_STAT_VTC )
+
+#define RTC_EVENT_ALARM		0x00000040
+#define RTC_EVENT_MONTH		0x00000020
+#define RTC_EVENT_DATE		0x00000010
+#define RTC_EVENT_HOUR		0x00000008
+#define RTC_EVENT_MINUTE	0x00000004
+#define RTC_EVENT_SEC		0x00000002
+#define RTC_EVENT_HSEC		0x00000001
+
+#endif  /* __ASM_ARCH_NS921X_RTC_H */
diff --git a/include/asm-arm/arch-ns9xxx/ns921x_sys.h b/include/asm-arm/arch-ns9xxx/ns921x_sys.h
new file mode 100644
index 0000000..6d7efbd
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns921x_sys.h
@@ -0,0 +1,255 @@
+/*
+ * include/asm/arch-ns9xxx/ns921x_sys.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+/***********************************************************************
+ *
+ * !Revision: $Revision$
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ * !Author:   Markus Pietrek
+ *
+ ***********************************************************************/
+
+#ifndef __ASM_ARCH_NS9XXX_SYS_H
+#define __ASM_ARCH_NS9XXX_SYS_H
+/* we use NS9XXX instead of NS921X_SYS.h to avoid accidently including both of
+ * them in ns9xxx*.c. Some values are named identical, but values are different */
+
+#define SYS_BASE_PA		0xA0900000
+
+#define SYS_AHB_GEN		0x0000
+#define SYS_BRC_BASE		0x0004
+#define SYS_AHB_ERROR1		0x0018
+#define SYS_AHB_ERROR2		0x001C
+#define SYS_AHB_MON		0x0020
+#define SYS_TIMER_MASTER_CTRL	0x0024
+#define SYS_TIMER_RELOAD_BASE	0x0028
+#define SYS_TIMER_READ_BASE	0x0050
+#define SYS_TIMER_HIGH_BASE	0x0078
+#define SYS_TIMER_STEP_BASE	0x0098
+#define SYS_TIMER_RELOAD_STEP_BASE 0x00A8
+#define SYS_INT_VEC_ADR_BASE	0x00C4
+#define SYS_INT_CFG_BASE	0x0144
+#define SYS_ISADDR		0x0164
+#define SYS_INT_STAT_ACTIVE	0x0168
+#define SYS_INT_STAT_RAW	0x016C
+#define SYS_SW_WDOG_CFG		0x0174
+#define SYS_SW_WDOG_TIMER	0x0178
+#define SYS_CLOCK		0x017C
+#define SYS_RESET		0x0180
+#define SYS_MISC		0x0184
+#define SYS_PLL			0x0188
+#define SYS_ACT_INT_STAT	0x018C
+#define SYS_TIMER_CTRL_BASE	0x0190
+#define SYS_CS_DYN_BASE_BASE	0x01D0
+#define SYS_CS_DYN_MASK_BASE	0x01D4
+#define SYS_CS_STATIC_BASE_BASE	0x01F0
+#define SYS_CS_STATIC_MASK_BASE	0x01F4
+#define SYS_GEN_ID		0x0210
+#define SYS_EXT_INT_CTRL_BASE	0x0214
+#define SYS_RTC			0x0224
+#define SYS_POWER		0x0228
+#define SYS_AHB_BUS_ACTIVITY	0x022C
+
+/* the vectored register addresses */
+
+#define SYS_TIMER_RELOAD( c )	( SYS_TIMER_RELOAD_BASE   + ( c ) * 4 )
+#define SYS_TIMER_READ( c )	( SYS_TIMER_READ_BASE     + ( c ) * 4 )
+#define SYS_INT_VEC_ADR( c )	( SYS_INT_VEC_ADR_BASE    + ( c ) * 4 )
+#define SYS_TIMER_CTRL( c )	( SYS_TIMER_CTRL_BASE     + ( c ) * 4 )
+/* CS_DYN index 0..3 */
+#define SYS_CS_DYN_BASE( c )	( SYS_CS_DYN_BASE_BASE    + ( c ) * 8 )
+#define SYS_CS_DYN_MASK( c )	( SYS_CS_DYN_MASK_BASE    + ( c ) * 8 )
+/* CS_STATIC start with 0 */
+#define SYS_CS_STATIC_BASE( c ) ( SYS_CS_STATIC_BASE_BASE + ( c ) * 8 )
+#define SYS_CS_STATIC_MASK( c ) ( SYS_CS_STATIC_MASK_BASE + ( c ) * 8 )
+#define SYS_EXT_INT_CTRL( c )   ( SYS_EXT_INT_CTRL_BASE	+ ( c ) * 4 )
+
+/* register bit fields */
+
+#define SYS_AHB_GEN_EXMAM	0x00000001 /* use main arbiter */
+
+/* need to be n*8bit to BRC channel */
+#define SYS_BRC_CEB		0x00000080
+#define SYS_BRC_BRF_MA		0x00000030
+#define SYS_BRC_BRF_100		0x00000000
+#define SYS_BRC_BRF_75		0x00000010
+#define SYS_BRC_BRF_50		0x00000020
+#define SYS_BRC_BRF_25		0x00000030
+
+#define SYS_AHB_ERROR2_IE	0x00080000
+#define SYS_AHB_ERROR2_DE	0x00040000
+#define SYS_AHB_ERROR2_ER	0x00020000
+#define SYS_AHB_ERROR2_HWR	0x00004000
+#define SYS_AHB_ERROR2_HMSTR(reg) ( ( ( reg ) >> 10 ) & 0xf )
+#define SYS_AHB_ERROR2_HPRE_MA 	0x000003C0
+#define SYS_AHB_ERROR2_HSZ(reg) ( ( ( reg ) >> 3 ) & 0x7 )
+#define SYS_AHB_ERROR2_HBRST_MA 0x00000007
+
+#define SYS_AHB_MON_EIC	 	0x00800000
+#define SYS_AHB_MON_SERDC	0x00000010
+
+#define SYS_TIMER_MASTER_CTRL_EN( timer ) 	( 1 << ( timer ) )
+#define SYS_TIMER_MASTER_CTRL_HSTEP_EN( timer ) ( 1 << ( 3 * ( ( timer ) - 6 ) ) + 10 )
+#define SYS_TIMER_MASTER_CTRL_LSTEP_EN( timer ) ( 1 << ( 3 * ( ( timer ) - 6 ) ) + 11 )
+#define SYS_TIMER_MASTER_CTRL_RSTEP_EN( timer ) ( 1 << ( 3 * ( ( timer ) - 6 ) ) + 12 )
+
+/* need to be n*8bit to Int Level */
+
+#define SYS_INT_CFG_IE		0x00000080
+#define SYS_INT_CFG_INV		0x00000040
+#define SYS_INT_CFG_IRQ		0x00000000
+#define SYS_INT_CFG_FIQ		0x00000020
+#define SYS_INT_CFG_ISD(irq)	( ( irq ) & 0x1f )
+
+/* interrupt source ids */
+#define SYS_ISD_WDOG		0x00
+#define SYS_ISD_AHB		0x01
+#define SYS_ISD_EXT_DMA		0x02
+#define SYS_ISD_WAKEUP		0x03
+#define SYS_ISD_ETH_RX		0x04
+#define SYS_ISD_ETH_TX		0x05
+#define SYS_ISD_ETH_PHY		0x06
+#define SYS_ISD_UART( port )	( 0x07 + ( ( port ) & 0x3 ) )
+#define SYS_ISD_SPI		0x0B
+#define SYS_ISD_ADC		0x0E
+#define SYS_ISD_EARLY_POWER	0x0F
+#define SYS_ISD_I2C		0x10
+#define SYS_ISD_RTC		0x11
+#define SYS_ISD_TIMER( timer )	( 0x12 + ( timer ) )
+#define SYS_ISD_EXT( int )	( 0x1C + ( ( int ) & 0x3 ) )
+
+#define SYS_SW_WDOG_CFG_DEBUG 	0x00000100
+#define SYS_SW_WDOG_CFG_SWWE 	0x00000080
+#define SYS_SW_WDOG_CFG_SWWI 	0x00000020
+#define SYS_SW_WDOG_CFG_SWWIC	0x00000010
+#define SYS_SW_WDOG_CFG_SWTCS_MA 0x00000007
+#define SYS_SW_WDOG_CFG_SWTCS_2	 0x00000000
+#define SYS_SW_WDOG_CFG_SWTCS_4	 0x00000001
+#define SYS_SW_WDOG_CFG_SWTCS_8	 0x00000002
+#define SYS_SW_WDOG_CFG_SWTCS_16 0x00000003
+#define SYS_SW_WDOG_CFG_SWTCS_32 0x00000004
+#define SYS_SW_WDOG_CFG_SWTCS_64 0x00000005
+
+#define SYS_CLOCK_CSC( reg )	( ( reg >> 29 ) & 0x7 )
+#define SYS_CLOCK_CSC_1		0x00000000
+#define SYS_CLOCK_CSC_2		0x20000000
+#define SYS_CLOCK_CSC_4		0x40000000
+#define SYS_CLOCK_CSC_8		0x60000000
+#define SYS_CLOCK_CSC_16	0x80000000
+#define SYS_CLOCK_MAX_CSC_1	0x00000000
+#define SYS_CLOCK_MAX_CSC_2	0x04000000
+#define SYS_CLOCK_MAX_CSC_4	0x08000000
+#define SYS_CLOCK_MAX_CSC_8	0x0C000000
+#define SYS_CLOCK_MAX_CSC_16	0x10000000
+#define SYS_CLOCK_CCSEL		0x02000000
+#define SYS_CLOCK_MA		0x00ffffff
+#define SYS_CLOCK_MCCOUT( cs )	( 1 << ( ( ( cs & 3 ) ) + 16 ) )
+#define SYS_CLOCK_EXT_DMA	0x00004000
+#define SYS_CLOCK_IO		0x00002000
+#define SYS_CLOCK_RTC		0x00001000
+#define SYS_CLOCK_I2C		0x00000800
+#define SYS_CLOCK_AES		0x00000200
+#define SYS_CLOCK_ADC		0x00000100
+#define SYS_CLOCK_SPI		0x00000020
+#define SYS_CLOCK_UART( port )	( 1 << ( ( ( port ) & 3 ) + 1 ) )
+#define SYS_CLOCK_ETH		0x00000001
+
+#define SYS_RESET_STAT_MA	0xE0000000
+#define SYS_RESET_STAT_RESN	0x20000000
+#define SYS_RESET_STAT_SRESN	0x40000000
+#define SYS_RESET_STAT_PLL	0x60000000
+#define SYS_RESET_STAT_SW_WDOG	0x80000000
+#define SYS_RESET_STAT_AHB	0x90000000
+#define SYS_RESET_EXT_DMA	0x00004000
+#define SYS_RESET_IO		0x00002000
+#define SYS_RESET_I2C		0x00000800
+#define SYS_RESET_AES		0x00000200
+#define SYS_RESET_ADC		0x00000100
+#define SYS_RESET_SPI		0x00000020
+#define SYS_RESET_UART( port )	( 1 << ( ( ( port ) & 3 ) + 1 ) )
+#define SYS_RESET_ETH		0x00000001
+
+#define SYS_MISC_REV( reg )	( ( ( reg ) >> 24 ) & 0xFF )
+#define SYS_MISC_ID_MA		0x00FF0000
+#define SYS_MISC_ID_NS9215_SP	0x00020000
+#define SYS_MISC_ID_NS9215_LP	0x00030000
+#define SYS_MISC_RTC		0x00000040
+#define SYS_MISC_BOOT_MODE	0x00000020
+#define SYS_MISC_BOOT_WIDTH_MA	0x00000018
+#define SYS_MISC_ENDM		0x00000004
+#define SYS_MISC_MIS		0x00000002
+#define SYS_MISC_INT		0x00000001
+
+#define SYS_PLL_NF( reg )	( ( ( reg ) >> 8 ) & 0x1ff )
+#define SYS_PLL_BP		0x00000080
+#define SYS_PLL_OD( reg )	( ( ( reg ) >> 5 ) & 0x3 )
+#define SYS_PLL_NR( reg )	( ( reg ) & 0x1f )
+
+#define SYS_ACT_INT_STAT_MA	0x0000FFFF
+
+#define SYS_CS_BASE_VAL( base )	( ( base ) << 11 )
+#define SYS_CS_MASK_VAL( mask )	( ( mask ) << 11 )
+#define SYS_CS_MASK_EN		0x00000001
+
+/* only for timer 0-4 */
+#define SYS_TIMER_CTRL_TE	0x00008000
+#define SYS_TIMER_CTRL_CAP_CMP_MA 0x00007000
+#define SYS_TIMER_CTRL_DBG_HALT 0x00000800
+#define SYS_TIMER_CTRL_INTC	0x00000400
+#define SYS_TIMER_CTRL_TCS_MA	0x000003C0
+#define SYS_TIMER_CTRL_TCS_M2	0x00000000
+#define SYS_TIMER_CTRL_TCS_1	0x00000040
+#define SYS_TIMER_CTRL_TCS_2	0x00000080
+#define SYS_TIMER_CTRL_TCS_4	0x000000C0
+#define SYS_TIMER_CTRL_TCS_8	0x00000100
+#define SYS_TIMER_CTRL_TCS_16	0x00000140
+#define SYS_TIMER_CTRL_TCS_32	0x00000180
+#define SYS_TIMER_CTRL_TCS_64	0x000001C0
+#define SYS_TIMER_CTRL_TCS_128	0x00000200
+#define SYS_TIMER_CTRL_TCS_EXT	0x000003C0
+#define SYS_TIMER_CTRL_TM_MA	0x00000030
+#define SYS_TIMER_CTRL_TM_INT	0x00000000
+#define SYS_TIMER_CTRL_TM_EXT_L 0x00000010
+#define SYS_TIMER_CTRL_TM_EXT_H	0x00000020
+#define SYS_TIMER_CTRL_TM_CONC	0x00000030
+#define SYS_TIMER_CTRL_INT	0x00000008
+#define SYS_TIMER_CTRL_DOWN	0x00000004
+#define SYS_TIMER_CTRL_UP	0x00000000
+#define SYS_TIMER_CTRL_32	0x00000002
+#define SYS_TIMER_CTRL_RELOAD	0x00000001
+
+#define SYS_CS_DYN_MASK_EN	0x00000001
+
+#define SYS_EXT_INT_CTRL_STS 	0x00000008
+#define SYS_EXT_INT_CTRL_CLR 	0x00000004
+#define SYS_EXT_INT_CTRL_PLTY_H	0x00000000
+#define SYS_EXT_INT_CTRL_PLTY_L	0x00000002
+#define SYS_EXT_INT_CTRL_EDGE	0x00000001
+#define SYS_EXT_INT_CTRL_LEVEL	0x00000000
+
+#define SYS_RTC_NORMAL_STAT	0x00000010
+#define SYS_RTC_INT_READY	0x00000008
+#define SYS_RTC_INT	 	0x00000004
+#define SYS_RTC_NORMAL		0x00000002
+#define SYS_RTC_STANDBY		0x00000000
+#define SYS_RTC_INT_READY_CLEAR	0x00000001
+
+#define SYS_POWER_SLEEP		0x80000000
+#define SYS_POWER_HW_CLOCK	0x40000000
+#define SYS_POWER_SELF_REFRESH	0x00200000
+#define SYS_POWER_WAKE_INT_CLR	0x00100000
+#define SYS_POWER_WAKE_INT_EXT( irq)	( 1 << ( ( irq ) + 16 ) )
+#define SYS_POWER_WAKE_RTC	0x00001000
+#define SYS_POWER_WAKE_I2C	0x00000800
+#define SYS_POWER_WAKE_SPI	0x00000020
+#define SYS_POWER_WAKE_UART( port )	( 1 << ( ( port ) + 1 ) )
+#define SYS_POWER_WAKE_ETH	0x00000001
+
+#endif /*__ASM_ARCH_NS9XXX_SYS_H*/
diff --git a/include/asm-arm/arch-ns9xxx/ns9xxx_mem.h b/include/asm-arm/arch-ns9xxx/ns9xxx_mem.h
new file mode 100644
index 0000000..8fdfa82
--- /dev/null
+++ b/include/asm-arm/arch-ns9xxx/ns9xxx_mem.h
@@ -0,0 +1,140 @@
+/*
+ * include/asm/arch-ns9xxx/ns9xxx_mem.h
+ *
+ * Copyright (C) 2007 by Digi International Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+/***********************************************************************
+ *
+ * !Revision: $Revision$
+ * !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ * !Author:   Markus Pietrek
+ *
+ ***********************************************************************/
+
+#ifndef __ASM_ARCH_NS9XXX_MEM_H
+#define __ASM_ARCH_NS9XXX_MEM_H
+
+#define MEM_BASE_PA		0xA0700000
+
+#define MEM_CTRL     		0x0000 
+#define MEM_STATUS     		0x0004
+#define MEM_CFG     		0x0008
+#define MEM_DYN_CTRL 		0x0020
+#define MEM_DYN_REFRESH 	0x0024
+#define MEM_DYN_READ_CFG	0x0028
+#define MEM_DYN_TRP     	0x0030
+#define MEM_DYN_TRAS    	0x0034
+#define MEM_DYN_TSREX   	0x0038
+#define MEM_DYN_TAPR   		0x003C
+#define MEM_DYN_TDAL    	0x0040
+#define MEM_DYN_TWR     	0x0044
+#define MEM_DYN_TRC     	0x0048
+#define MEM_DYN_TRFC    	0x004C
+#define MEM_DYN_TXSR    	0x0050
+#define MEM_DYN_TRRD    	0x0054
+#define MEM_DYN_TMRD    	0x0058
+#define MEM_STAT_EXT_WAIT	0x0080
+#define MEM_DYN_CFG_BASE	0x0100
+#define MEM_DYN_RAS_CAS_BASE	0x0104
+#define MEM_STAT_CFG_BASE	0x0200
+#define MEM_STAT_WAIT_WEN_BASE	0x0204
+#define MEM_STAT_WAIT_OEN_BASE	0x0208
+#define MEM_STAT_WAIT_RD_BASE	0x020C
+#define MEM_STAT_WAIT_PAGE_BASE	0x0210
+#define MEM_STAT_WAIT_WR_BASE	0x0214
+#define MEM_STAT_WAIT_TURN_BASE	0x0218
+
+/* the vectored register addresses */
+
+#define MEM_DYN_CFG(c)		( MEM_DYN_CFG_BASE        + (c) * 0x20 )
+#define MEM_DYN_RAS_CAS(c)	( MEM_DYN_RAS_CAS_BASE    + (c) * 0x20 )
+#define MEM_STAT_CFG(c)		( MEM_STAT_CFG_BASE       + (c) * 0x20 )
+#define MEM_STAT_WAIT_WEN(c)	( MEM_STAT_WAIT_WEN_BASE  + (c) * 0x20 )
+#define MEM_STAT_WAIT_OEN(c)	( MEM_STAT_WAIT_OEN_BASE  + (c) * 0x20 )
+#define MEM_STAT_RD(c)		( MEM_STAT_WAIT_RD_BASE   + (c) * 0x20 )
+#define MEM_STAT_PAGE(c)	( MEM_STAT_WAIT_PAGE_BASE + (c) * 0x20 )
+#define MEM_STAT_WR(c)		( MEM_STAT_WAIT_WR_BASE   + (c) * 0x20 )
+#define MEM_STAT_TURN(c)	( MEM_STAT_WAIT_TURN_BASE + (c) * 0x20 )
+
+/* register bit fields */
+
+#define MEM_CTRL_L		0x00000004
+#define MEM_CTRL_M		0x00000002
+#define MEM_CTRL_E		0x00000001
+
+#define MEM_STAT_SA		0x00000004
+#define MEM_STAT_S		0x00000002
+#define MEM_STAT_B		0x00000001
+
+#define MEM_CFG_CLK		0x00000010
+#define MEM_CFG_N		0x00000001
+
+#define MEM_DYN_CTRL_NRP	0x00004000
+#define MEM_DYN_CTRL_DP		0x00002000
+#define MEM_DYN_CTRL_I_MA	0x00000180
+#define MEM_DYN_CTRL_I_NORMAL 	0x00000000
+#define MEM_DYN_CTRL_I_MODE	0x00000080
+#define MEM_DYN_CTRL_I_PALL	0x00000100
+#define MEM_DYN_CTRL_I_NOP	0x00000180
+#define MEM_DYN_CTRL_BIT5	0x00000020
+#define MEM_DYN_CTRL_SR		0x00000004
+#define MEM_DYN_CTRL_BIT1	0x00000002
+#define MEM_DYN_CTRL_CE		0x00000001
+
+
+#define MEM_DYN_REFRESH_VAL( val ) ( ( val ) & 0x000007FF )
+
+#define MEM_DYN_READ_CFG_MA	0x00000003
+#define MEM_DYN_READ_CFG_DELAY0 0x00000001
+#define MEM_DYN_READ_CFG_DELAY1 0x00000002
+#define MEM_DYN_READ_CFG_DELAY2 0x00000003
+
+#define MEM_DYN_TRP_VAL( val )   ( ( val ) & 0x0000000F )
+#define MEM_DYN_TRAS_VAL( val )  ( ( val ) & 0x0000000F )
+#define MEM_DYN_TSREX_VAL( val ) ( ( val ) & 0x0000000F )
+#define MEM_DYN_TAPR_VAL( val )  ( ( val ) & 0x0000000F )
+#define MEM_DYN_TDAL_VAL( val )	 ( ( val ) & 0x0000000F )
+#define MEM_DYN_TWR_VAL( val )   ( ( val ) & 0x0000000F )
+#define MEM_DYN_TRC_VAL( val )	 ( ( val ) & 0x0000001F )
+#define MEM_DYN_TRFC_VAL( val )  ( ( val ) & 0x0000001F )
+#define MEM_DYN_TXSR_VAL( val )  ( ( val ) & 0x0000001F )
+#define MEM_DYN_TRRD_VAL( val )  ( ( val ) & 0x0000000F )
+#define MEM_DYN_TMRD_VAL( val )	 ( ( val ) & 0x0000000F )
+
+#define MEM_STAT_EXTW_WAIT_VAL( val ) ( ( val ) & 0x0000003F )
+
+#define MEM_DYN_CFG_P	   	0x00100000
+#define MEM_DYN_CFG_BDMC	0x00080000
+#define MEM_DYN_CFG_AM	   	0x00004000
+#define MEM_DYN_CFG_AM1( val )  ( (val) & 0x00001F80 )
+#define MEM_DYN_CFG_AM1_SIZE( reg )  ( ( ( reg ) >> 9 ) & 0x7 )
+#define MEM_DYN_CFG_MD	   	0x00000018
+
+#define MEM_DYN_RAS_CAS_CAS( val ) ( ( ( val ) & 0x3 ) << 8 )
+#define MEM_DYN_RAS_CAS_RAS( val ) ( ( ( val ) & 0x3 ) )
+
+#define MEM_STAT_CFG_PSMC	0x00100000
+#define MEM_STAT_CFG_BSMC	0x00080000
+#define MEM_STAT_CFG_EW	   	0x00000100
+#define MEM_STAT_CFG_PB	   	0x00000080
+#define MEM_STAT_CFG_PC	   	0x00000040
+#define MEM_STAT_CFG_PM	   	0x00000008
+#define MEM_STAT_CFG_BMODE	0x00000004
+#define MEM_STAT_CFG_MW_MA	0x00000003
+#define MEM_STAT_CFG_MW_8	0x00000000
+#define MEM_STAT_CFG_MW_16      0x00000001
+#define MEM_STAT_CFG_MW_32	0x00000002
+
+#define MEM_STAT_WAIT_WEN_VAL( val ) ( ( val ) & 0x0000000F )
+#define MEM_STAT_WAIT_OEN_VAL( val ) ( ( val ) & 0x0000000F )
+#define MEM_STAT_RD_VAL( val )       ( ( val ) & 0x0000001F )
+#define MEM_STAT_PAGE_VAL( val )     ( ( val ) & 0x0000001F )
+#define MEM_STAT_WR_VAL( val )       ( ( val ) & 0x0000001F )
+#define MEM_STAT_TURN_VAL( val )     ( ( val ) & 0x0000000F )
+
+#endif /*__ASM_ARCH_NS9XXX_MEM_H*/
diff --git a/include/asm-arm/status_led.h b/include/asm-arm/status_led.h
new file mode 100644
index 0000000..8f119b0
--- /dev/null
+++ b/include/asm-arm/status_led.h
@@ -0,0 +1,216 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2004 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ *
+ * $Id: status_led.h,v 1.1 2008-05-14 13:42:56 jkleintj Exp $
+ * @Author: Joachim Jaeger jjaeger@fsforth.de
+ * @Descr: SMDK2410 based status led support functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef __ASM_STATUS_LED_H__
+#define __ASM_STATUS_LED_H__
+
+/* no comment about placing a c-file in include/asm */
+#ifndef __ASSEMBLY__
+
+/* if not overriden */
+#ifndef CONFIG_BOARD_SPECIFIC_LED
+#ifdef CONFIG_SMDK2410_LED
+#include <s3c2410.h>
+
+#elif CONFIG_NS9360 || CONFIG_NS9750
+# include <ns9750_bbus.h>
+#elif CONFIG_NS921X
+# include <asm-arm/arch-ns9xxx/ns921x_gpio.h>
+# include <asm-arm/arch-ns9xxx/io.h>  /* gpio_readl */
+#elif  CONFIG_UNC90
+
+#include <asm/arch/AT91RM9200.h>
+#include <configs/unc90.h>
+#define	PIO_REG(port,reg)	AT91C_PIO ## port ## reg
+
+#if defined( CONFIG_UNC90_USE_A6_LED )
+  #define	PIO_MASK	AT91C_PIO_PD25
+  #define	PIO_CODR	PIO_REG(D,_CODR)
+  #define	PIO_SODR	PIO_REG(D,_SODR)	
+  #define	PIO_ODSR	PIO_REG(D,_ODSR)
+  #define	PIO_PER		PIO_REG(D,_PER)
+  #define	PIO_OER		PIO_REG(D,_OER)
+#elif defined ( CONFIG_UNC90_USE_A4_LED )
+  #define	PIO_MASK	AT91C_PIO_PB1
+  #define	PIO_CODR	PIO_REG(B,_CODR)
+  #define	PIO_SODR	PIO_REG(B,_SODR)	
+  #define	PIO_ODSR	PIO_REG(B,_ODSR)
+  #define	PIO_PER		PIO_REG(B,_PER)
+  #define	PIO_OER		PIO_REG(B,_OER)
+#else
+ #error Led support is configured for UNC90 and no Led was selected
+#endif
+
+#else
+#error CPU specific Status LED header file missing.
+#endif
+
+extern void status_led_set (int led, int state);
+
+/* led_id_t is unsigned int mask */
+typedef unsigned int led_id_t;
+
+#ifdef CONFIG_SMDK2410_LED
+
+static inline void __led_init (led_id_t mask, int state)
+{
+//	S3C24X0_GetBase_GPIO()->GPFCON = (0x0001<<mask);
+//	S3C24X0_GetBase_GPIO()->GPFDAT = 0x0FF;	//switch off all LEDs
+
+#if (STATUS_LED_ACTIVE == 0)
+	if (state == STATUS_LED_ON)
+		S3C24X0_GetBase_GPIO()->GPFDAT &= ~(mask & 0xFF);
+	else
+		S3C24X0_GetBase_GPIO()->GPFDAT |= (mask & 0xFF);
+#else
+	if (state == STATUS_LED_ON)
+		S3C24X0_GetBase_GPIO()->GPFDAT |= (mask & 0xFF);
+	else
+		S3C24X0_GetBase_GPIO()->GPFDAT &= ~(mask & 0xFF);
+#endif
+}
+
+static inline void __led_toggle (led_id_t mask)
+{
+	S3C24X0_GetBase_GPIO()->GPFDAT ^= (mask & 0xFF);
+}
+
+static inline void __led_set (led_id_t mask, int state)
+{
+#if (STATUS_LED_ACTIVE == 0)
+	if (state == STATUS_LED_ON)
+		S3C24X0_GetBase_GPIO()->GPFDAT &= ~(mask & 0xFF);
+	else
+		S3C24X0_GetBase_GPIO()->GPFDAT |= (mask & 0xFF);
+#else
+	if (state == STATUS_LED_ON)
+		S3C24X0_GetBase_GPIO()->GPFDAT |= (mask & 0xFF);
+	else
+		S3C24X0_GetBase_GPIO()->GPFDAT &= ~(mask & 0xFF);
+#endif
+}
+
+#elif CONFIG_NS9360 || CONFIG_NS9750
+
+static inline void __led_init (led_id_t mask, int state)
+{
+/* mask is GPIO-number */
+	set_gpio_cfg_reg_val(mask,NS9750_GPIO_CFG_FUNC_GPIO | NS9750_GPIO_CFG_OUTPUT);
+#if (STATUS_LED_ACTIVE == 0)
+	if (state == STATUS_LED_ON)
+		set_gpio_ctrl_reg_val(mask,0);
+	else
+		set_gpio_ctrl_reg_val(mask,1);
+#else
+	if (state == STATUS_LED_ON)
+		set_gpio_ctrl_reg_val(mask,1);
+	else
+		set_gpio_ctrl_reg_val(mask,0);
+#endif
+}
+
+static inline void __led_toggle (led_id_t mask)
+{
+/* mask is GPIO-number */
+	set_gpio_ctrl_reg_val(mask,!(get_gpio_stat(mask)));
+}
+
+static inline void __led_set (led_id_t mask, int state)
+{
+/* mask is GPIO-number */
+#if (STATUS_LED_ACTIVE == 0)
+	if (state == STATUS_LED_ON)
+		set_gpio_ctrl_reg_val(mask,0);
+	else
+		set_gpio_ctrl_reg_val(mask,1);
+#else
+	if (state == STATUS_LED_ON)
+		set_gpio_ctrl_reg_val(mask,1);
+	else
+		set_gpio_ctrl_reg_val(mask,0);
+#endif
+}
+
+#elif CONFIG_NS921X
+static inline void __led_toggle( led_id_t mask )
+{
+        gpio_ctrl_set( mask, ~gpio_ctrl_get( mask ) );
+}
+
+static inline void __led_set( led_id_t mask, int state )
+{
+        gpio_ctrl_set( mask, ( STATUS_LED_ON == state ) ? 0 : 1 );
+}
+
+static inline void __led_init( led_id_t mask, int state )
+{
+        __led_set( mask, state );
+        gpio_cfg_set( mask, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO );
+}
+#elif CONFIG_UNC90
+
+static inline void __led_init( led_id_t mask, int state )
+{
+	/* Enable PIO to access the LEDs */
+	*PIO_PER = PIO_MASK;
+	*PIO_OER = PIO_MASK;
+	
+	if( state == STATUS_LED_ON )
+		*PIO_CODR = PIO_MASK;
+	else
+		*PIO_SODR = PIO_MASK;
+}
+
+static inline void __led_toggle( led_id_t mask )
+{
+	unsigned long curr = *PIO_ODSR;
+	
+	// @TODO
+	// mask is used for...
+	
+	if( curr & PIO_MASK )
+		*PIO_CODR = PIO_MASK;
+	else
+		*PIO_SODR = PIO_MASK;
+}
+
+static inline void __led_set( led_id_t mask, int state )
+{
+	// @TODO
+	// mask is used for...
+	
+	if( state == STATUS_LED_ON )
+		*PIO_CODR = PIO_MASK;
+	else
+		*PIO_SODR = PIO_MASK;
+}
+
+#endif	// CONFIG_UNC90
+
+#endif
+
+#endif  /* __ASSEMBLY__ */
+#endif	/* __ASM_STATUS_LED_H__ */
diff --git a/include/cmd_confdefs.h b/include/cmd_confdefs.h
new file mode 100644
index 0000000..17a9bc0
--- /dev/null
+++ b/include/cmd_confdefs.h
@@ -0,0 +1,185 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Definitions for Configuring the monitor commands
+ */
+#ifndef _CMD_CONFIG_H
+#define _CMD_CONFIG_H
+
+/*
+ * Configurable monitor commands
+ */
+#define CFG_CMD_BDI		0x00000001ULL	/* bdinfo			*/
+#define CFG_CMD_LOADS		0x00000002ULL	/* loads			*/
+#define CFG_CMD_LOADB		0x00000004ULL	/* loadb			*/
+#define CFG_CMD_IMI		0x00000008ULL	/* iminfo			*/
+#define CFG_CMD_CACHE		0x00000010ULL	/* icache, dcache		*/
+#define CFG_CMD_FLASH		0x00000020ULL	/* flinfo, erase, protect	*/
+#define CFG_CMD_MEMORY		0x00000040ULL	/* md, mm, nm, mw, cp, cmp,	*/
+						/* crc, base, loop, mtest	*/
+#define CFG_CMD_NET		0x00000080ULL	/* bootp, tftpboot, rarpboot	*/
+#define CFG_CMD_ENV		0x00000100ULL	/* saveenv			*/
+#define CFG_CMD_KGDB		0x0000000000000200ULL	/* kgdb				*/
+#define CFG_CMD_PCMCIA		0x00000400ULL	/* PCMCIA support		*/
+#define CFG_CMD_IDE		0x00000800ULL	/* IDE harddisk support		*/
+#define CFG_CMD_PCI		0x00001000ULL	/* pciinfo			*/
+#define CFG_CMD_IRQ		0x00002000ULL	/* irqinfo			*/
+#define CFG_CMD_BOOTD		0x00004000ULL	/* bootd			*/
+#define CFG_CMD_CONSOLE		0x00008000ULL	/* coninfo			*/
+#define CFG_CMD_EEPROM		0x00010000ULL	/* EEPROM read/write support	*/
+#define CFG_CMD_ASKENV		0x00020000ULL	/* ask for env variable		*/
+#define CFG_CMD_RUN		0x00040000ULL	/* run command in env variable	*/
+#define CFG_CMD_ECHO		0x00080000ULL	/* echo arguments		*/
+#define CFG_CMD_I2C		0x00100000ULL	/* I2C serial bus support	*/
+#define CFG_CMD_REGINFO		0x00200000ULL	/* Register dump		*/
+#define CFG_CMD_IMMAP		0x00400000ULL	/* IMMR dump support		*/
+#define CFG_CMD_DATE		0x00800000ULL	/* support for RTC, date/time...*/
+#define CFG_CMD_DHCP		0x01000000ULL	/* DHCP Support			*/
+#define CFG_CMD_BEDBUG		0x02000000ULL	/* Include BedBug Debugger	*/
+#define CFG_CMD_FDC		0x04000000ULL	/* Floppy Disk Support		*/
+#define CFG_CMD_SCSI		0x08000000ULL	/* SCSI Support			*/
+#define CFG_CMD_AUTOSCRIPT	0x10000000ULL	/* Autoscript Support		*/
+#define CFG_CMD_MII		0x20000000ULL	/* MII support			*/
+#define CFG_CMD_SETGETDCR	0x40000000ULL	/* DCR support on 4xx		*/
+#define CFG_CMD_BSP		0x80000000ULL	/* Board Specific functions	*/
+
+#define CFG_CMD_ELF	0x0000000100000000ULL	/* ELF (VxWorks) load/boot cmd	*/
+#define CFG_CMD_MISC	0x0000000200000000ULL	/* Misc functions like sleep etc*/
+#define CFG_CMD_USB	0x0000000400000000ULL	/* USB Support			*/
+#define CFG_CMD_DOC	0x0000000800000000ULL	/* Disk-On-Chip Support		*/
+#define CFG_CMD_JFFS2	0x0000001000000000ULL	/* JFFS2 Support		*/
+#define CFG_CMD_DTT	0x0000002000000000ULL	/* Digital Therm and Thermostat */
+#define CFG_CMD_SDRAM	0x0000004000000000ULL	/* SDRAM DIMM SPD info printout */
+#define CFG_CMD_DIAG	0x0000008000000000ULL	/* Diagnostics			*/
+#define CFG_CMD_FPGA	0x0000010000000000ULL	/* FPGA configuration Support	*/
+#define CFG_CMD_HWFLOW	0x0000020000000000ULL	/* RTS/CTS hw flow control	*/
+#define CFG_CMD_SAVES	0x0000040000000000ULL	/* save S record dump		*/
+#define CFG_CMD_SPI	0x0000100000000000ULL	/* SPI utility			*/
+#define CFG_CMD_FDOS	0x0000200000000000ULL	/* Floppy DOS support		*/
+#define CFG_CMD_VFD	0x0000400000000000ULL	/* VFD support (TRAB)		*/
+#define CFG_CMD_NAND	0x0000800000000000ULL	/* NAND support			*/
+#define CFG_CMD_BMP	0x0001000000000000ULL	/* BMP support			*/
+#define CFG_CMD_PORTIO	0x0002000000000000ULL	/* Port I/O			*/
+#define CFG_CMD_PING	0x0004000000000000ULL	/* ping support			*/
+#define CFG_CMD_MMC	0x0008000000000000ULL	/* MMC support			*/
+#define CFG_CMD_FAT	0x0010000000000000ULL	/* FAT support			*/
+#define CFG_CMD_IMLS	0x0020000000000000ULL	/* List all found images	*/
+#define CFG_CMD_ITEST	0x0040000000000000ULL	/* Integer (and string) test	*/
+#define CFG_CMD_NFS	0x0080000000000000ULL	/* NFS support			*/
+#define CFG_CMD_REISER	0x0100000000000000ULL	/* Reiserfs support		*/
+#define CFG_CMD_CDP	0x0200000000000000ULL	/* Cisco Discovery Protocol 	*/
+#define CFG_CMD_XIMG	0x0400000000000000ULL	/* Load part of Multi Image	*/
+#define CFG_CMD_UNIVERSE 0x0800000000000000ULL	/* Tundra Universe Support      */
+#define CFG_CMD_EXT2	0x1000000000000000ULL	/* EXT2 Support			*/
+#define CFG_CMD_SNTP	0x2000000000000000ULL	/* SNTP support			*/
+#define CFG_CMD_DISPLAY	0x4000000000000000ULL	/* Display support		*/
+
+#define CFG_CMD_ALL	0xFFFFFFFFFFFFFFFFULL	/* ALL commands			*/
+
+/* Commands that are considered "non-standard" for some reason
+ * (memory hogs, requires special hardware, not fully tested, etc.)
+ */
+#define CFG_CMD_NONSTD (CFG_CMD_ASKENV	| \
+			CFG_CMD_BEDBUG	| \
+			CFG_CMD_BMP	| \
+			CFG_CMD_BSP	| \
+			CFG_CMD_CACHE	| \
+			CFG_CMD_CDP	| \
+			CFG_CMD_DATE	| \
+			CFG_CMD_DHCP	| \
+			CFG_CMD_DIAG	| \
+			CFG_CMD_DISPLAY	| \
+			CFG_CMD_DOC	| \
+			CFG_CMD_DTT	| \
+			CFG_CMD_EEPROM	| \
+			CFG_CMD_ELF	| \
+			CFG_CMD_EXT2	| \
+			CFG_CMD_FDC	| \
+			CFG_CMD_FAT	| \
+			CFG_CMD_FDOS	| \
+			CFG_CMD_HWFLOW	| \
+			CFG_CMD_I2C	| \
+			CFG_CMD_IDE	| \
+			CFG_CMD_IMMAP	| \
+			CFG_CMD_IRQ	| \
+			CFG_CMD_JFFS2	| \
+			CFG_CMD_KGDB	| \
+			CFG_CMD_MII	| \
+			CFG_CMD_MMC	| \
+			CFG_CMD_NAND	| \
+			CFG_CMD_PCI	| \
+			CFG_CMD_PCMCIA	| \
+			CFG_CMD_PING	| \
+			CFG_CMD_PORTIO	| \
+			CFG_CMD_REGINFO | \
+			CFG_CMD_REISER	| \
+			CFG_CMD_SAVES	| \
+			CFG_CMD_SCSI	| \
+			CFG_CMD_SDRAM	| \
+			CFG_CMD_SNTP	| \
+			CFG_CMD_SPI	| \
+			CFG_CMD_UNIVERSE | \
+			CFG_CMD_USB	| \
+			CFG_CMD_VFD	)
+
+/* Default configuration
+ */
+#define CONFIG_CMD_DFL	(CFG_CMD_ALL & ~CFG_CMD_NONSTD)
+
+#ifndef CONFIG_COMMANDS
+#define CONFIG_COMMANDS CONFIG_CMD_DFL
+#endif
+
+
+/*
+ * optional BOOTP fields
+ */
+
+#define CONFIG_BOOTP_SUBNETMASK		0x00000001
+#define CONFIG_BOOTP_GATEWAY		0x00000002
+#define CONFIG_BOOTP_HOSTNAME		0x00000004
+#define CONFIG_BOOTP_NISDOMAIN		0x00000008
+#define CONFIG_BOOTP_BOOTPATH		0x00000010
+#define CONFIG_BOOTP_BOOTFILESIZE	0x00000020
+#define CONFIG_BOOTP_DNS		0x00000040
+#define CONFIG_BOOTP_DNS2		0x00000080
+#define CONFIG_BOOTP_SEND_HOSTNAME	0x00000100
+#define CONFIG_BOOTP_NTPSERVER		0x00000200
+#define CONFIG_BOOTP_TIMEOFFSET		0x00000400
+#ifndef CONFIG_NS9215
+#define CONFIG_BOOTP_VENDOREX		0x80000000
+#endif
+#define CONFIG_BOOTP_ALL		(~CONFIG_BOOTP_VENDOREX)
+
+
+#define CONFIG_BOOTP_DEFAULT		(CONFIG_BOOTP_SUBNETMASK | \
+					CONFIG_BOOTP_GATEWAY	 | \
+					CONFIG_BOOTP_HOSTNAME	 | \
+					CONFIG_BOOTP_BOOTPATH)
+
+#ifndef CONFIG_BOOTP_MASK
+#define CONFIG_BOOTP_MASK		CONFIG_BOOTP_DEFAULT
+#endif
+
+#endif	/* _CMD_CONFIG_H */
diff --git a/include/configs/cc9c.h b/include/configs/cc9c.h
new file mode 100644
index 0000000..a3d74f1
--- /dev/null
+++ b/include/configs/cc9c.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2005 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ * Jonas Dietsche <jdietsche@fsforth.de>
+ *
+ * Configuation settings for the FS Forth-Systeme GmbH's A9M9750 Module
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm-arm/sizes.h>
+#include <ns9750_sys.h>
+#include <configs/digi_common.h>
+
+/************************************************************
+ * Definition of default options when not configured by user
+ ************************************************************/
+#ifndef CONFIG_DIGIEL_USERCONFIG
+# define CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_UBOOT_SPLASH
+# define CONFIG_UBOOT_CRT_VGA
+# define CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD
+# define CONFIG_UBOOT_LQ064V3DG01_TFT_LCD
+# define CONFIG_AUTOLOAD_BOOTSCRIPT
+#endif /* ifndef(CONFIG_DIGIEL_USERCONFIG) */
+
+#define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor " MODULE_STRING " on " CONFIG_UBOOT_BOARDNAME_STR
+
+#define CONFIG_GCC41		1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_NS9360		1	/* in an NetSilicon NS9360 SoC     */
+#define CONFIG_CC9C		1
+#define CONFIG_IS_NETSILICON    1
+#define CPU			"NS9360"
+#define CONFIG_MACH_CC9C		/* Select board mach-type */
+#define BOARD_LATE_INIT		1	/* Enables initializations before jumping to main loop */
+#define CRYSTAL 		294912
+#define PLLFS			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x17 ) & 0x3)
+#define PLLND			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x10 ) & 0x1f)
+
+#define CONFIG_HAVE_BOOTMUX     1
+
+/* CONFIG_CC9C_NAND will be defined in include/configs.h */
+#ifdef CONFIG_CC9C_NAND
+# define CONFIG_BOOT_NAND	1
+# define CFG_NO_FLASH		1	/* No NOR-Flash available */
+# define PLATFORM		"nand"
+# define EBOOTFLADDR		"280000"
+# define WCEFLADDR		"380000"
+# define NAND_WAIT_READY( nand ) udelay(25) /* 2KiB flash have 25 us */
+# ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+#  define CONFIG_HAVE_SPI_LOADER  1       /* that initializes SDRAM and */
+# endif  /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+#else
+# define CFG_FLASH_CFI		/* The flash is CFI compatible	*/
+# define CFG_FLASH_CFI_DRIVER	/* Use common CFI driver	*/
+# define PLATFORM		"nor"
+# define EBOOTFLADDR		"501C0000"
+# define WCEFLADDR		"502C0000"
+#endif /*CONFIG_CC9C_NAND*/
+#define CONFIG_MODULE_NAME	"cc9cjs"PLATFORM
+#define CONFIG_MODULE_NAME_WCE  "CCX9C"
+#define CONFIG_MODULE_NAME_NETOS "connectcore9c_a"
+#define NS9750_ETH_PHY_ADDRESS	(0x0001)
+
+#define CONFIG_SYS_CLK_FREQ 	(100*CRYSTAL * (PLLND +1) / (1<<PLLFS))
+
+#define CPU_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/2)
+#define AHB_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/4)
+#define BBUS_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/8)
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/************************************************************
+ * Base board specific configurations
+ ************************************************************/
+#if !defined(CONFIG_CONS_INDEX)
+# define CONFIG_CONS_INDEX	1	/*0= Port B; 1= Port A; 2= Port C; 3=Port D */
+#endif
+
+#ifndef CFG_CONSOLE
+# define CFG_CONSOLE            "ttyS"
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+# define USER_KEY1_GPIO		72
+# define USER_KEY2_GPIO		69
+# define USER_LED1_GPIO		48
+# define USER_LED2_GPIO		49
+
+/* MMC */
+#define MMC_MAX_DEVICE		0
+
+/************************************************************
+ * Activate LEDs while booting
+ ************************************************************/
+#define CONFIG_STATUS_LED	1
+#define	CONFIG_SHOW_BOOT_PROGRESS 1	/* Show boot progress on LEDs	*/
+
+#define CFG_NS9750_UART		1	/* use on-chip UART */
+#define CONFIG_DRIVER_NS9750_ETHERNET 1	/* use on-chip ethernet */
+
+#ifdef CONFIG_CMD_USB
+/* USB related stuff */
+# define LITTLEENDIAN		1	/* necessary for USB */
+# define CONFIG_USB_OHCI 	1
+# define CONFIG_USB_STORAGE 	1
+# define CONFIG_DOS_PARTITION 	1
+#endif
+
+#define CONFIG_SILENT_RESCUE	1
+
+/* Video settings */
+#ifdef CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_LCD			1
+# if defined(CONFIG_UBOOT_CRT_VGA) || defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD) || defined(CONFIG_UBOOT_LQ064V3DG01_TFT_LCD)
+#  define LCD_BPP       LCD_COLOR16
+# else
+#  error "Please, define LCD_BPP accordingly to your display needs"
+# endif
+#endif
+
+#ifdef CONFIG_UBOOT_SPLASH
+# define CONFIG_SPLASH_SCREEN		1
+# define CONFIG_SPLASH_WITH_CONSOLE	1
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#ifndef CONFIG_COMMANDS
+#ifdef CONFIG_CC9C_NAND
+# define CONFIG_COMMANDS \
+	( CONFIG_COMMANDS_DIGI	| \
+	CFG_CMD_DATE		| \
+	CFG_CMD_I2C		| \
+	CFG_CMD_FAT		| \
+	CFG_CMD_MII		| \
+	CFG_CMD_NAND    	| \
+	CFG_CMD_SNTP		|   /* simple network time protocol */ \
+	CFG_CMD_USB     	| \
+	0 )
+#else
+# define CONFIG_COMMANDS \
+	( CONFIG_COMMANDS_DIGI	| \
+	CFG_CMD_DATE		| \
+	CFG_CMD_I2C		| \
+	CFG_CMD_FAT		| \
+	CFG_CMD_FLASH    	| \
+	CFG_CMD_MII		| \
+	CFG_CMD_SNTP		|   /* simple network time protocol */ \
+	CFG_CMD_USB     	| \
+	0 )
+#endif	/* CONFIG_CC9C_NAND */
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#if !defined(CONFIG_UBOOT_PROMPT)
+# define CFG_PROMPT 		"CC9C # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT		CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#ifndef CONFIG_UBOOT_BOARDNAME
+# define CONFIG_UBOOT_BOARDNAME_STR	"Development Board"
+#endif
+
+#define MODULE_STRING		"ConnectCore 9C"
+
+#define CFG_MEMTEST_START	0x00200000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x00f80000	/* 13,5 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x00200000	/* default load address	*/
+#define CFG_WCE_LOAD_ADDR	0x002C0000
+#define CFG_INITRD_LOAD_ADDR    0x00600000      /* default initrd  load address */
+#define CFG_NETOS_LOAD_ADDR	0x00300000
+
+#define	CFG_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1    		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	 /* SDRAM Bank #1 */
+/* size will be defined in include/configs when you make the config */
+
+#ifdef CONFIG_CC9C_NAND
+# define PHYS_NAND_FLASH	0x50000000 /* NAND Flash Bank #1 */
+# define CFG_NAND_BASE		PHYS_NAND_FLASH
+# define CFG_NAND_BASE_LIST	{ CFG_NAND_BASE }
+# define CFG_NAND_UNALIGNED	1
+# define NAND_ECC_INFO		CFG_LOAD_ADDR	/* address in SDRAM is used */
+# define NAND_NO_RB
+#endif /*CONFIG_CC9C_NAND*/
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define PHYS_FLASH_1		0x50000000 /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT	(71)	/* max number of sectors on one chip */
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+/* use internal RTC */
+#define	CONFIG_RTC_NS9360	1
+
+/* i2c bus */
+#define CONFIG_HARD_I2C		1	/* I2C with hardware support */
+#define CONFIG_DRIVER_NS9750_I2C 1	/* I2C driver */
+#define CFG_I2C_SPEED 		100000	/* Hz */
+#define CFG_I2C_SLAVE 		0x7F	/* I2C slave addr */
+#define I2C_SCL_GPIO		70
+#define I2C_SDA_GPIO		71
+#define I2C_SCL_GPIO_FUNC	NS9750_GPIO_CFG_FUNC_2
+#define I2C_SDA_GPIO_FUNC	NS9750_GPIO_CFG_FUNC_2
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM address */
+#define CFG_I2C_EEPROM_ADDR_LEN	2	/* 2 address bytes */
+
+#undef CFG_I2C_EEPROM_ADDR_OVERFLOW
+#define CFG_EEPROM_PAGE_WRITE_BITS    5	/* 32 bytes page write mode on M24LC64 */
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+#define CFG_EEPROM_PAGE_WRITE_ENABLE   1
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <ns9750_nand.h>
+
+/* they are calculated for 128kB sectors. So Kernel/FPGA starts at 1MB */
+# define PART_UBOOT_SIZE	0x000c0000
+# define PART_NVRAM_SIZE        0x00080000
+# define PART_KERNEL_SIZE       0x00300000
+# define PART_ROOTFS_SIZE       0x01000000
+# define PART_WINCE_REG_SIZE	0x00100000
+# define PART_SPLASH_SIZE    	0x00100000
+# define PART_WINCE_SIZE        0x01800000
+# define PART_WINCE_FS_SIZE     0x0
+# define PART_WINCE_FLASHFX_SIZE 0x00300000 /* Even when the FFX demo only
+					       supports 2MB, some additional space is
+					       required by FFX */
+
+# define PART_NETOS_KERNEL_SIZE 0x002C0000
+# define CONFIG_JFFS2_DEV	 "nand0"
+# define CONFIG_JFFS2_NAND
+#endif /* if (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#include <configs/digi_common_post.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cc9m2443.h b/include/configs/cc9m2443.h
new file mode 100644
index 0000000..8b62f21
--- /dev/null
+++ b/include/configs/cc9m2443.h
@@ -0,0 +1,326 @@
+/*
+ * (C) Copyright 2005-2006
+ * Seung-Chull, Suh <sc.suh@samsung.com>
+ *
+ * Configuation settings for the Digi CC9M2443 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include "digi_common.h"
+#include <s3c2443_gpio.h>
+
+/************************************************************
+ * Definition of default options when not configured by user
+ ************************************************************/
+#if (!defined(CONFIG_DIGIEL_USERCONFIG))
+# define CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_UBOOT_SPLASH
+# define CONFIG_UBOOT_CRT_VGA
+# define CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD
+# define CONFIG_UBOOT_LQ064V3DG01_TFT_LCD
+# define CONFIG_AUTOLOAD_BOOTSCRIPT
+#endif /* if !defined(CONFIG_DIGIEL_USERCONFIG) */
+
+/* example recover from silent mode by gpio
+#define CONFIG_SILENT_CONSOLE
+#define ENABLE_CONSOLE_GPIO		S3C_GPF0
+#define CONSOLE_ENABLE_GPIO_STATE 	0
+*/
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define	CONFIG_S3C2443		1		/* in a SAMSUNG S3C2443 SoC     */
+#define	CONFIG_S3C24XX		1		/* in a SAMSUNG S3C24XX Family  */
+#define CONFIG_CC9M2443		1		/* on a SAMSUNG SMDK2443 Board  */
+#define CONFIG_ARM920T				/* This is an ARM920T Core */
+
+#define PLATFORM "js"
+#define CONFIG_MODULE_NAME "cc9m2443"PLATFORM
+#define BOARD_LATE_INIT
+
+#define CONFIG_BOOT_NAND        1
+#define CFG_NO_FLASH		1
+#undef	CONFIG_USE_NOR_BOOT
+
+#define CONFIG_MODULE_NAME_WCE	"CCX9M2443"
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000	/* the SMDK2443 has 12MHz input clock */
+
+#define	CFG_LOAD_ADDR		0x30200000	/* default load address	*/
+#define CFG_WCE_LOAD_ADDR 	0x30200000
+#define CFG_INITRD_LOAD_ADDR    0x30600000
+#define CFG_NETOS_LOAD_ADDR     0x30500000
+#define EBOOTFLADDR             "280000"
+#define virt_to_phys(x)	(x)
+
+#undef CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+
+#define CONFIG_ZIMAGE_BOOT
+#define CONFIG_IMAGE_BOOT
+
+/* Power Management is enabled */
+#define CONFIG_PM
+/* Generic U-Boot value 1000 */
+#define	CFG_HZ		1000
+
+/*
+ * select serial console configuration
+ */
+
+#define CONFIG_SILENT_RESCUE	1
+
+#define CONFIG_CMDLINE_EDITING
+
+/* I2C */
+#define CONFIG_S3C24XX_I2C
+#define CONFIG_HARD_I2C		1
+#define	CFG_I2C_SPEED		100000
+#define	CFG_I2C_SLAVE		0xFE
+
+/* USB and USB device related stuff */
+#if defined(CONFIG_CMD_USB)
+ #define LITTLEENDIAN
+ #define CONFIG_USB_OHCI
+ #define CONFIG_USB_STORAGE
+#endif
+
+/* not supported at the moment
+#define CONFIG_S3C_USBD
+#define USBD_DOWN_ADDR		0x30000000
+*/
+
+#if defined(CONFIG_CMD_USB) || defined(CONFIG_CMD_MMC)
+ #define CONFIG_DOS_PARTITION
+ #define CONFIG_SUPPORT_VFAT
+#endif
+
+/* Video settings */
+#ifdef CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_LCD			1
+# if defined(CONFIG_UBOOT_CRT_VGA) || defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD) || \
+	defined(CONFIG_UBOOT_LQ064V3DG01_TFT_LCD)
+#  define LCD_BPP       LCD_COLOR16
+# else
+#  error "Please, define LCD_BPP accordingly to your display needs"
+# endif
+#endif
+
+#ifdef CONFIG_UBOOT_SPLASH
+# define CONFIG_SPLASH_SCREEN		1
+# define CONFIG_SPLASH_WITH_CONSOLE	1
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+
+/************************************************************
+ * Base board specific configurations
+ ************************************************************/
+#if !defined(CONFIG_CONS_INDEX)
+# define CONFIG_CONS_INDEX	0 	/* 0 Port A; 2 Port B on 2410 dev 1 Port B on 2443JS */
+#endif
+
+#ifndef CFG_CONSOLE
+# define CFG_CONSOLE            "ttySAC"
+#endif
+
+#define USER_KEY1_GPIO		S3C_GPF0
+#define USER_KEY2_GPIO		S3C_GPF6
+#define USER_LED1_GPIO		S3C_GPL10
+#define USER_LED2_GPIO		S3C_GPL11
+
+/************************************************************
+ * RTC
+ ************************************************************/
+//#define CONFIG_RTC_S3C24XX	1 	/* internal RTC */
+#define CONFIG_RTC_DS1337	1 	/* RTC on jupstartboard */
+#define CFG_I2C_RTC_ADDR    	0x68
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#ifndef CONFIG_COMMANDS
+#define CONFIG_COMMANDS \
+	( CONFIG_COMMANDS_DIGI | \
+	CFG_CMD_DATE	| \
+	CFG_CMD_I2C	| \
+	CFG_CMD_FAT	| \
+	CFG_CMD_MMC	| \
+	CFG_CMD_NAND	| \
+	CFG_CMD_USB     | \
+	CFG_CMD_SNTP	|  /* simple network time protocol */ \
+	0 )
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+/************************************************************
+ * Default environment settings
+ ************************************************************/
+#define CONFIG_EXTRA_ENV_SETTINGS			\
+	"silent="CFG_SET_SILENT"\0"
+
+/* ethernet */
+#define CONFIG_DRIVER_SMSC9118
+#define CONFIG_SMSC9118_BASE (0x29000000)
+
+#define CONFIG_ETHADDR		00:40:5c:26:0a:5b
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		192.168.42.30
+#define CONFIG_SERVERIP		192.168.42.1
+#define CONFIG_GATEWAYIP	192.168.0.1
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+/* MMC */
+#if defined(CONFIG_CMD_MMC)
+# define CONFIG_MMC		1
+# define CONFIG_SUPPORT_MMC_PLUS
+#endif
+#define CFG_MMC_BASE		0xf0000000
+#define MMC_MAX_DEVICE		1
+#define HSMMC_MAX_DEVICE	1
+
+/*
+ * CC9M2443 default environment settings
+ */
+
+/*
+ * Miscellaneous configurable options
+ */
+#if !defined(CONFIG_UBOOT_PROMPT)
+#define	CFG_PROMPT		"CC9M2443 # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT             CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#define CFG_MEMTEST_START	0x30200000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x30400000	/* 60 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CFG_BANK_CFG_VAL_128            0x0006D25D
+#define	CFG_BANK_CFG_VAL_64		0x0004925D
+#define	CFG_BANK_CFG_VAL_32             0x0004895D
+
+#define	CFG_BANK_CON1_VAL		0x44000040
+
+#define	CFG_BANK_CON2_VAL_100		0x007b003f
+#define	CFG_BANK_CON2_VAL_133		0x009e003f
+
+#define	CFG_BANK_CON3_VAL		0x80000030
+
+#define	CFG_BANK_REFRESH_VAL_100_128	0x00000186
+#define	CFG_BANK_REFRESH_VAL_100_64	0x00000186
+#define	CFG_BANK_REFRESH_VAL_100_32	0x00000186
+#define	CFG_BANK_REFRESH_VAL_133_128	0x00000200
+#define	CFG_BANK_REFRESH_VAL_133_64	0x00000200
+#define	CFG_BANK_REFRESH_VAL_133_32	0x00000200
+
+#define	CFG_BANK_TIMEOUT_VAL_133_128	CFG_BANK_REFRESH_VAL_133_128
+#define	CFG_BANK_TIMEOUT_VAL_133_64	CFG_BANK_REFRESH_VAL_133_64
+#define	CFG_BANK_TIMEOUT_VAL_133_32	CFG_BANK_REFRESH_VAL_133_32
+
+#define CONFIG_NR_DRAM_BANKS		2	   /* we have 2 bank of DRAM */
+#define PHYS_SDRAM_1			0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_2			0x38000000 /* SDRAM Bank #2 */
+#define CFG_FLASH_BASE			0x08000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CFG_MAX_FLASH_SECT	1024
+#define CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x100000
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+
+#define CFG_ENV_ADDR		0
+
+/*
+ * CC9M2443 board specific data
+ */
+#ifndef CONFIG_UBOOT_BOARDNAME
+#define CONFIG_UBOOT_BOARDNAME_STR	"Development Board"
+#endif
+#define MODULE_STRING           	"ConnectCore 9M 2443"
+#define CONFIG_IDENT_STRING		" " VERSION_TAG "\nfor " MODULE_STRING " on " \
+       					CONFIG_UBOOT_BOARDNAME_STR
+
+#define CFG_UBOOT_SIZE  	(768*1024)
+/* base address for u-boot */
+#define CFG_UBOOT_BASE		0x30100000
+#define CFG_PHY_UBOOT_BASE	0x30100000
+
+/* NAND configuration */
+#define S3C_NAND_CFG_HWECC
+#define CFG_MAX_NAND_DEVICE	1
+#define CFG_NAND_BASE		(0x4e000010)
+#define NAND_MAX_CHIPS		1
+
+#define NAND_DISABLE_CE(nand)		(NFCONT_REG |= (1 << 1))
+#define NAND_ENABLE_CE(nand)		(NFCONT_REG &= ~(1 << 1))
+#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
+
+#define CFG_NAND_SKIP_BAD_DOT_I		1  /* ".i" read skips bad blocks   */
+#define	CFG_NAND_WP			1
+#define CFG_NAND_YAFFS_WRITE		1  /* support yaffs write */
+#define CFG_ENV_OFFSET 0x000C0000
+
+#define CONFIG_JFFS2_NAND	1	/* jffs2 on nand support */
+#define NAND_CACHE_PAGES	16	/* size of nand cache in 512 bytes pages */
+/*
+ * JFFS2 partitions
+ */
+#undef CONFIG_JFFS2_CMDLINE
+#define CONFIG_JFFS2_DEV		"nand0"
+#define CONFIG_JFFS2_PART_SIZE		0xFFFFFFFF
+#define CONFIG_JFFS2_PART_OFFSET	0x00200000
+
+#define PART_UBOOT_SIZE	       	0x000c0000
+#define PART_NVRAM_SIZE        	0x00040000	/* nvram 256 kb because 2k pagesize nands */
+#define PART_KERNEL_SIZE       	0x00300000
+#define PART_ROOTFS_SIZE       	0x01000000
+#define PART_WINCE_REG_SIZE	0x00100000
+#define PART_SPLASH_SIZE       	0x00100000
+#define PART_WINCE_SIZE        	0x01800000
+#define PART_WINCE_FS_SIZE    	0x0
+#define PART_NETOS_KERNEL_SIZE 	0x002C0000
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cc9p9210.h b/include/configs/cc9p9210.h
new file mode 100644
index 0000000..20d3bca
--- /dev/null
+++ b/include/configs/cc9p9210.h
@@ -0,0 +1,293 @@
+/*
+ *  include/configs/cc9p9210.h
+ *
+ *  Copyright (C) 2009 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm-arm/sizes.h>
+#include <ns921x.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+
+#include <configs/digi_common.h>
+
+#if !defined(CONFIG_DOWNLOAD_BY_DEBUGGER) && !defined(CONFIG_DIGIEL_USERCONFIG)
+# define CONFIG_UBOOT_CHECK_CRC32_ON_BOOT
+# define CONFIG_UBOOT_VERIFY_IN_SDRAM
+#endif
+
+/************************************************************
+ * Definition of default options when not configured by user
+ ************************************************************/
+#if (!defined(CONFIG_DIGIEL_USERCONFIG))
+# define CONFIG_UBOOT_SPLASH
+# define CONFIG_UBOOT_EDTQVGA_TFT_LCD
+# define CONFIG_AUTOLOAD_BOOTSCRIPT
+#endif /* if !defined(CONFIG_DIGIEL_USERCONFIG) */
+
+#define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor " MODULE_STRING " on " CONFIG_UBOOT_BOARDNAME_STR
+
+#define CONFIG_GCC41		1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_NS921X		1	/* in an NetSilicon NS921x SoC */
+#define CONFIG_NS9210		1	/* in an NetSilicon NS9215 SoC */
+#define CONFIG_CC9P9210		1       /* on a ConnectCore 9P 9360 module */
+#if defined(CONFIG_JSCC9P9215)
+#define CONFIG_MACH_CC9P9215JS	1	/* Select board mach-type */
+#else
+#define CONFIG_MACH_CC9P9210	1	/* Select generic mach-type */
+#endif
+#define CONFIG_IS_NETSILICON    1
+#define CPU     		"NS9210"
+
+#if defined(CONFIG_JSCC9P9215)
+# define PLATFORM		"js"
+#endif
+
+#define BOARD_LATE_INIT		1	/* Enables initializations before jumping to main loop */
+
+#define CONFIG_MODULE_NAME	"cc9p9210"PLATFORM
+#define CONFIG_MODULE_NAME_NETOS CONFIG_MODULE_NAME
+
+#define CONFIG_SYS_CLK_FREQ 	sys_clock_freq()
+#define CPU_CLK_FREQ		cpu_clock_freq()  /* for compat */
+#define AHB_CLK_FREQ		ahb_clock_freq()  /* for compat */
+
+/************************************************************
+ * Base board specific configurations
+ ************************************************************/
+#ifndef CONFIG_UBOOT_FIM_UART_PIC_NUM
+# define CFG_NS921X_UART	1
+# define CFG_CONSOLE            "ttyNS"
+# if !defined(CONFIG_CONS_INDEX)
+#  define CONFIG_CONS_INDEX	3	/*0= Port A; 1= Port B; 2= Port C; 3=Port D */
+# endif
+#else
+# define CFG_CONSOLE            "ttyFIM"
+# if defined(CONFIG_UBOOT_FIM_ZERO_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 0)
+#  define CONFIG_CONS_INDEX	0
+# elif defined(CONFIG_UBOOT_FIM_ONE_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 1)
+#  define CONFIG_CONS_INDEX	1
+# else
+#  error "Bad configuration of FIM Console index"
+# endif
+#endif
+
+#ifdef CONFIG_NS921X_FIM_UART
+# if defined(CONFIG_UBOOT_FIM_ZERO_SERIAL)
+# define FIM_UART_TX			68
+# define FIM_UART_RX			69
+# define GPIO_CFG_FUNC_FIM_UART		GPIO_CFG_FUNC_0
+# elif defined(CONFIG_UBOOT_FIM_ONE_SERIAL)
+# define FIM_UART_TX			72
+# define FIM_UART_RX			73
+# define GPIO_CFG_FUNC_FIM_UART		GPIO_CFG_FUNC_1
+#endif
+#endif
+
+/* Configuration for the SDIO */
+#if defined(CONFIG_CMD_MMC)
+#define CONFIG_DOS_PARTITION 	1
+#endif
+
+#ifdef CONFIG_NS921X_FIM_SDIO
+# define CONFIG_MMC		1
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  define FIM_SDIO_D0			68
+#  define FIM_SDIO_D1			69
+#  define FIM_SDIO_D2			70
+#  define FIM_SDIO_D3			71
+#  define FIM_SDIO_CLK			76
+#  define FIM_SDIO_CMD			77
+#  define FIM_SDIO_WP			100
+#  define FIM_SDIO_CD			101
+#  define GPIO_CFG_FUNC_FIM_SDIO_D0	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D1	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D2	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D3	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CLK	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CMD	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_WP	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CD	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  define FIM_SDIO_D0			72
+#  define FIM_SDIO_D1			73
+#  define FIM_SDIO_D2			74
+#  define FIM_SDIO_D3			75
+#  define FIM_SDIO_CLK			78
+#  define FIM_SDIO_CMD			79
+#  define FIM_SDIO_WP			100
+#  define FIM_SDIO_CD			101
+#  define GPIO_CFG_FUNC_FIM_SDIO_D0	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D1	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D2	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D3	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CLK	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CMD	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_WP	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CD	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+# else
+#  error "No FIM SDIO number defined! Aborting."
+# endif
+#endif
+
+/* MMC */
+#ifdef CONFIG_CMD_MMC
+# define CONFIG_MMC		1
+#endif
+#define CFG_MMC_BASE		0xf0000000
+#define MMC_MAX_DEVICE		1
+#define HSMMC_MAX_DEVICE	0
+
+#define CONFIG_CMDLINE_EDITING
+
+#define CONFIG_SERIAL_MULTI
+#if defined(CONFIG_JSCC9P9215)
+# define USER_KEY1_GPIO			81
+# define USER_KEY2_GPIO			84
+#endif
+
+#define	CONFIG_RTC_NS921X		1
+
+#define GPIO_ETH_PHY_RESET		43  /* GPIO that holds PHY in reset  */
+
+/* some strapping values. Only used if defined here */
+#define CFG_STRAP_PUT_ETH_OUT_OF_RESET	0x80
+
+/************************************************************
+ * Activate LEDs while booting
+ ************************************************************/
+
+#define CONFIG_STATUS_LED
+#define CONFIG_SHOW_BOOT_PROGRESS
+
+#define CONFIG_DRIVER_NS921X_ETHERNET 1	/* use on-chip ethernet */
+#define NS921X_ETH_PHY_ADDRESS	 	(0x0007)
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+#define CONFIG_SILENT_RESCUE	1
+
+/* Video settings */
+#ifdef CONFIG_UBOOT_SPLASH
+# define CONFIG_LCD                     1
+# define CONFIG_SPLASH_SCREEN           1
+# define CONFIG_SPLASH_WITH_CONSOLE     1
+#if defined(CONFIG_UBOOT_EDTQVGA_TFT_LCD)
+# define LCD_BPP       LCD_COLOR16
+#else
+# error "Please, define LCD_BPP accordingly to your display needs"
+#endif
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#ifndef CONFIG_COMMANDS
+#define CONFIG_COMMANDS \
+	( CONFIG_COMMANDS_DIGI	| \
+	CFG_CMD_FLASH		| \
+	CFG_CMD_MII		| \
+	0 )
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#if !defined(CONFIG_UBOOT_PROMPT)
+# define CFG_PROMPT 		"CC9P9210 # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT		CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#ifndef CONFIG_UBOOT_BOARDNAME
+# define CONFIG_UBOOT_BOARDNAME_STR "Development Board"
+#endif
+
+#define MODULE_STRING		"ConnectCore 9P 9210"
+
+/* TODO */
+#define CFG_MEMTEST_START	0x00000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x00f80000	/* 15,5 MB in DRAM	*/
+
+#define	CFG_LOAD_ADDR		0x00200000	/* default load address	*/
+#define	CFG_INITRD_LOAD_ADDR	0x00600000	/* default initrd  load address	*/
+#define CFG_NETOS_LOAD_ADDR	0x00300000
+#define CFG_LINUX_LOAD_ADDR	0x200000	/* default linux load address */
+
+#define	CFG_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1    		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	 /* SDRAM Bank #1 */
+/* size will be defined in include/configs when you make the config */
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_FLASH_CFI		1
+#define	CFG_FLASH_CFI_DRIVER	1
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CFG_FLASH_PROTECTION    1
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define PHYS_FLASH_1		0x50000000 /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT	(256)	/* max number of sectors on one chip */
+
+
+/* i2c bus */
+#define CONFIG_DRIVER_NS9750_I2C 1	/* I2C driver */
+#define CFG_I2C_SPEED 		100000	/* Hz */
+#define CFG_I2C_SLAVE 		0x7F	/* I2C slave addr */
+#define I2C_SCL_GPIO		104
+#define I2C_SDA_GPIO		105
+#define I2C_SCL_GPIO_FUNC	GPIO_CFG_FUNC_1
+#define I2C_SDA_GPIO_FUNC	GPIO_CFG_FUNC_1
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM address */
+#define CFG_I2C_EEPROM_ADDR_LEN	2	/* 2 address bytes */
+
+#undef CFG_I2C_EEPROM_ADDR_OVERFLOW
+#define CFG_EEPROM_PAGE_WRITE_BITS    5	/* 32 bytes page write mode on M24LC64 */
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+#define CFG_EEPROM_PAGE_WRITE_ENABLE   1
+
+#define PART_UBOOT_SIZE	        0x00040000
+#define PART_NVRAM_SIZE         0x00020000
+#define PART_KERNEL_SIZE        0x00180000
+#define PART_ROOTFS_SIZE        0x00000000  /* the rest */
+
+#ifdef CONFIG_NETOS_BRINGUP
+/* NET+OS runs in big-endian, 9600 */
+# undef CONFIG_BAUDRATE
+# define CONFIG_BAUDRATE	38400  /* they take it patient */
+# define CONFIG_PARTITION_SWAP
+# define CFG_NETOS_SWAP_ENDIAN
+# define PART_NETOS_LOADER_SIZE	0x00010000
+# define PART_NETOS_KERNEL_SIZE 0x00000000
+# define PART_NETOS_NVRAM_SIZE  0x00010000
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP ) && defined(CONFIG_UBOOT_CMD_BSP_TESTHW)
+# define CONFIG_USE_IRQ         /* for testhw powersave */
+#endif
+
+#include <configs/digi_common_post.h>
+
+#endif	/* __CONFIG_H */
+
diff --git a/include/configs/cc9p9215.h b/include/configs/cc9p9215.h
new file mode 100644
index 0000000..09ae41c
--- /dev/null
+++ b/include/configs/cc9p9215.h
@@ -0,0 +1,381 @@
+/*
+ *  include/configs/cccp9215.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <../arch/arm/include/asm/sizes.h>
+#include <ns921x.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+
+#include <configs/digi_common.h>
+
+#if !defined(CONFIG_DOWNLOAD_BY_DEBUGGER) && !defined(CONFIG_DIGIEL_USERCONFIG)
+# define CONFIG_UBOOT_CHECK_CRC32_ON_BOOT
+# define CONFIG_UBOOT_VERIFY_IN_SDRAM
+#endif
+
+/************************************************************
+ * Definition of default options when not configured by user
+ ************************************************************/
+#if (!defined(CONFIG_DIGIEL_USERCONFIG))
+# define CONFIG_AUTOLOAD_BOOTSCRIPT
+#endif /* if !defined(CONFIG_DIGIEL_USERCONFIG) */
+
+#define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor " MODULE_STRING " on " CONFIG_UBOOT_BOARDNAME_STR
+
+#define CONFIG_GCC41		1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_NS921X		1	/* in an NetSilicon NS921x SoC */
+/* RLS #define CONFIG_NS9215		1*/ 	/* is an NetSilicon NS9215 SoC */ 
+#define CONFIG_CC9P9215		1       /* on a ConnectCore 9P 9360 module */
+#define CONFIG_FLASH_CFI_DRIVER 1
+#define CONFIG_SYS_FLASH_CFI    1
+#if defined(CONFIG_JSCC9P9215)
+#define CONFIG_MACH_CC9P9215JS	1	/* Select board mach-type */
+#else
+#define CONFIG_MACH_CC9P9215	1	/* Select generic mach-type */
+#endif
+#define CONFIG_IS_NETSILICON    1
+#define CPU     		"NS9215"
+
+#if defined(CONFIG_JSCC9P9215)
+# define PLATFORM		"js"
+#else
+#define PLATFORM "nor"
+#endif
+
+#define BOARD_LATE_INIT		1	/* Enables initializations before jumping to main loop */
+
+#define CONFIG_MODULE_NAME	"cc9p9215"PLATFORM
+#define CONFIG_MODULE_NAME_NETOS CONFIG_MODULE_NAME
+
+#define CONFIG_SYS_CLK_FREQ 	sys_clock_freq()
+#define CPU_CLK_FREQ		cpu_clock_freq()  /* for compat */
+#define AHB_CLK_FREQ		ahb_clock_freq()  /* for compat */
+
+
+/* @TODO */
+/*#define	CFG_ENV_IS_IN_FLASH	1*/
+#ifdef MISSING_MALLOC_SIZE_INFO_RLS
+
+ * Defined in include/configs/digi_common.h 
+ *
+ * #define CFG_ENV_IS_NOWHERE
+#define CFG_ENV_SIZE		0x10000	/* Total Size of Environment Sector */
+#define CONFIG_ENV_SIZE     CFG_ENV_SIZE
+
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE       128     /* size in bytes reserved for initial
+					 * data */
+#endif 
+
+/************************************************************
+ * Base board specific configurations
+ ************************************************************/
+#ifndef CONFIG_UBOOT_FIM_UART_PIC_NUM
+# define CFG_NS921X_UART	1
+# define CFG_CONSOLE            "ttyNS"
+# if !defined(CONFIG_CONS_INDEX)
+#  define CONFIG_CONS_INDEX	3	/*0= Port A; 1= Port B; 2= Port C; 3=Port D */
+# endif
+#else
+# define CFG_CONSOLE            "ttyFIM"
+# if defined(CONFIG_UBOOT_FIM_ZERO_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 0)
+#  define CONFIG_CONS_INDEX	0
+# elif defined(CONFIG_UBOOT_FIM_ONE_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 1)
+#  define CONFIG_CONS_INDEX	1
+# else
+#  error "Bad configuration of FIM Console index"
+# endif
+#endif
+
+#ifdef CONFIG_NS921X_FIM_UART
+# if defined(CONFIG_UBOOT_FIM_ZERO_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 0)
+#  define FIM_UART_TX			68
+#  define FIM_UART_RX			69
+#  define GPIO_CFG_FUNC_FIM_UART		GPIO_CFG_FUNC_0
+# elif defined(CONFIG_UBOOT_FIM_ONE_SERIAL) && (CONFIG_UBOOT_FIM_UART_PIC_NUM == 1)
+#  define FIM_UART_TX			72
+#  define FIM_UART_RX			73
+#  define GPIO_CFG_FUNC_FIM_UART		GPIO_CFG_FUNC_1
+# endif
+#endif
+
+/* Configuration for the SDIO */
+#if defined(CONFIG_CMD_MMC)
+#define CONFIG_DOS_PARTITION 	1
+#endif
+
+#ifdef CONFIG_NS921X_FIM_SDIO
+# define CONFIG_MMC		1
+# if defined(CONFIG_UBOOT_FIM_ZERO_SD)
+#  define FIM_SDIO_D0			68
+#  define FIM_SDIO_D1			69
+#  define FIM_SDIO_D2			70
+#  define FIM_SDIO_D3			71
+#  define FIM_SDIO_CLK			76
+#  define FIM_SDIO_CMD			77
+#  define FIM_SDIO_WP			100
+#  define FIM_SDIO_CD			101
+#  define GPIO_CFG_FUNC_FIM_SDIO_D0	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D1	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D2	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D3	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CLK	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CMD	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_WP	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CD	(GPIO_CFG_FUNC_0 | GPIO_CFG_PULLUP_DISABLE)
+# elif defined(CONFIG_UBOOT_FIM_ONE_SD)
+#  define FIM_SDIO_D0			72
+#  define FIM_SDIO_D1			73
+#  define FIM_SDIO_D2			74
+#  define FIM_SDIO_D3			75
+#  define FIM_SDIO_CLK			78
+#  define FIM_SDIO_CMD			79
+#  define FIM_SDIO_WP			100
+#  define FIM_SDIO_CD			101
+#  define GPIO_CFG_FUNC_FIM_SDIO_D0	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D1	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D2	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_D3	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CLK	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CMD	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_WP	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+#  define GPIO_CFG_FUNC_FIM_SDIO_CD	(GPIO_CFG_FUNC_1 | GPIO_CFG_PULLUP_DISABLE)
+# else
+#  error "No FIM SDIO number defined! Aborting."
+# endif
+#endif
+
+/* MMC */
+#ifdef CONFIG_CMD_MMC
+# define CONFIG_MMC		1
+#endif
+#define CFG_MMC_BASE		0xf0000000
+#define MMC_MAX_DEVICE		1
+#define HSMMC_MAX_DEVICE	0
+
+#define CONFIG_CMDLINE_EDITING
+
+#define CONFIG_SERIAL_MULTI
+#if defined(CONFIG_JSCC9P9215)
+# define USER_KEY1_GPIO			81
+# define USER_KEY2_GPIO			84
+# define USER_LED1_GPIO			82
+# define USER_LED2_GPIO			85
+#endif
+
+#define	CONFIG_RTC_NS921X		1
+
+#define GPIO_ETH_PHY_RESET		90  /* GPIO that holds PHY in reset  */
+
+/* some strapping values. Only used if defined here */
+#define CFG_STRAP_PUT_ETH_OUT_OF_RESET	0x80
+
+/************************************************************
+ * Activate LEDs while booting
+ ************************************************************/
+
+#define CONFIG_STATUS_LED
+#define CONFIG_SHOW_BOOT_PROGRESS
+
+#define CONFIG_DRIVER_NS921X_ETHERNET 1	/* use on-chip ethernet */
+#define NS921X_ETH_PHY_ADDRESS	 	(0x0007)
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+#define CONFIG_SILENT_RESCUE	1
+
+/* Video settings */
+#ifdef CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_LCD			1
+# if defined(CONFIG_UBOOT_EDTQVGA_TFT_LCD)
+#  define LCD_BPP       LCD_COLOR16
+# else
+#  error "Please, define LCD_BPP accordingly to your display needs"
+# endif
+#endif
+
+#ifdef CONFIG_UBOOT_SPLASH
+# define CONFIG_SPLASH_SCREEN           1
+# define CONFIG_SPLASH_WITH_CONSOLE     1
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+#define CFG_CMD_SPI 1
+#define CONFIG_SOFT_SPI	1	/* Enable SPI driver */
+/* Software (bit-bang) SPI driver configuration */
+# define SPI_TX_GPIO		7
+# define SPI_RX_GPIO		3
+# define SPI_CLK_GPIO		5
+# define SPI_EN_GPIO		0
+
+# define SPI_INIT								\
+{										\
+	gpio_cfg_set(SPI_TX_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_EN_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_CLK_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_RX_GPIO, GPIO_CFG_INPUT | GPIO_CFG_FUNC_GPIO);		\
+	gpio_ctrl_set(SPI_EN_GPIO, 1);						\
+	gpio_ctrl_set(SPI_CLK_GPIO, 1);						\
+}
+
+# define SPI_READ	(gpio_stat_get(SPI_RX_GPIO))
+# define SPI_SDA(bit)	if(bit)  gpio_ctrl_set(SPI_TX_GPIO, 1);		\
+			else     gpio_ctrl_set(SPI_TX_GPIO, 0)
+# define SPI_SCL(bit)	if(bit)  gpio_ctrl_set(SPI_CLK_GPIO, 1);	\
+			else     gpio_ctrl_set(SPI_CLK_GPIO, 0)
+# define SPI_DELAY	udelay(spi_delay)
+
+
+#ifdef CONFIG_UBOOT_CMD_BSP_TESTHW
+# define TEST_HW_EXTRA_CMDS		CFG_CMD_SPI
+#endif
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#ifndef CONFIG_COMMANDS
+#define CONFIG_COMMANDS \
+	( CONFIG_COMMANDS_DIGI	| \
+	TEST_HW_EXTRA_CMDS	| \
+	CFG_CMD_DATE		| \
+	CFG_CMD_NET		| \
+	CFG_CMD_I2C		| \
+	CFG_CMD_FLASH		| \
+	CFG_CMD_MII		| \
+	CFG_CMD_SNTP		|  /* simple network time protocol */ \
+	0 )
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#if !defined(CONFIG_UBOOT_PROMPT)
+# define CFG_PROMPT 		"CC9P9215 # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT		CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#ifndef CONFIG_UBOOT_BOARDNAME
+# define CONFIG_UBOOT_BOARDNAME_STR "Development Board"
+#endif
+
+#define MODULE_STRING		"ConnectCore 9P 9215"
+
+/* TODO */
+#define CFG_MEMTEST_START	0x00200000	/* memtest works from    */
+#define CFG_MEMTEST_END		0x00780000	/* 2Mb to 7,5 MB in DRAM */
+
+#define	CFG_LOAD_ADDR		0x00200000	/* default load address	*/
+#define	CFG_INITRD_LOAD_ADDR	0x00600000	/* default initrd  load address	*/
+#define CFG_NETOS_LOAD_ADDR	0x00300000
+
+#define	CFG_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1    		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	 /* SDRAM Bank #1 */
+/* size will be defined in include/configs when you make the config */
+
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CFG_FLASH_CFI		1
+#define	CFG_FLASH_CFI_DRIVER	1
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CFG_FLASH_PROTECTION    1
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define PHYS_FLASH_1		0x50000000 /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT	(256)	/* max number of sectors on one chip */
+
+/* i2c bus */
+#define CONFIG_DRIVER_NS9750_I2C 1	/* I2C driver */
+#define CFG_I2C_SPEED 		100000	/* Hz */
+#define CFG_I2C_SLAVE 		0x7F	/* I2C slave addr */
+#define I2C_SCL_GPIO		102
+#define I2C_SDA_GPIO		103
+#define I2C_SCL_GPIO_FUNC	GPIO_CFG_FUNC_2
+#define I2C_SDA_GPIO_FUNC	GPIO_CFG_FUNC_2
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM address */
+#define CFG_I2C_EEPROM_ADDR_LEN	2	/* 2 address bytes */
+
+#undef CFG_I2C_EEPROM_ADDR_OVERFLOW
+#define CFG_EEPROM_PAGE_WRITE_BITS    5	/* 32 bytes page write mode on M24LC64 */
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+#define CFG_EEPROM_PAGE_WRITE_ENABLE   1
+
+#define PART_UBOOT_SIZE	        0x00040000
+#define PART_NVRAM_SIZE         0x00020000
+#define PART_KERNEL_SIZE        0x00180000
+#define PART_ROOTFS_SIZE        0x00000000  /* the rest */
+#define PART_SPLASH_SIZE    	0x00100000
+
+#ifdef CONFIG_NETOS_BRINGUP
+/* NET+OS runs in big-endian, 9600 */
+# undef CONFIG_BAUDRATE
+# define CONFIG_BAUDRATE	9600  /* they take it patient */
+
+# define CONFIG_PARTITION_SWAP
+# define CFG_NETOS_SWAP_ENDIAN
+# define PART_NETOS_LOADER_SIZE_VARIANT1	0x00010000
+# define PART_NETOS_LOADER_SIZE_VARIANT2	0x00020000
+# define PART_NETOS_LOADER_SIZE		PART_NETOS_LOADER_SIZE_VARIANT1
+# define PART_NETOS_KERNEL_SIZE 0x002C0000
+# define PART_NETOS_NVRAM_SIZE  0x00010000
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP ) && defined(CONFIG_UBOOT_CMD_BSP_TESTHW)
+# define CONFIG_USE_IRQ         /* for testhw powersave */
+
+/* Select SPI support for hardware test purposes */
+# define CONFIG_SOFT_SPI		/* Enable SPI driver */
+
+/* Software (bit-bang) SPI driver configuration */
+# define SPI_TX_GPIO		7
+# define SPI_RX_GPIO		3
+# define SPI_CLK_GPIO		5
+# define SPI_EN_GPIO		0
+
+# define SPI_INIT								\
+{										\
+	gpio_cfg_set(SPI_TX_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_EN_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_CLK_GPIO, GPIO_CFG_OUTPUT | GPIO_CFG_FUNC_GPIO);	\
+	gpio_cfg_set(SPI_RX_GPIO, GPIO_CFG_INPUT | GPIO_CFG_FUNC_GPIO);		\
+	gpio_ctrl_set(SPI_EN_GPIO, 1);						\
+	gpio_ctrl_set(SPI_CLK_GPIO, 1);						\
+}
+
+# define SPI_READ	(gpio_stat_get(SPI_RX_GPIO))
+# define SPI_SDA(bit)	if(bit)  gpio_ctrl_set(SPI_TX_GPIO, 1);		\
+			else     gpio_ctrl_set(SPI_TX_GPIO, 0)
+# define SPI_SCL(bit)	if(bit)  gpio_ctrl_set(SPI_CLK_GPIO, 1);	\
+			else     gpio_ctrl_set(SPI_CLK_GPIO, 0)
+# define SPI_DELAY	udelay(spi_delay)
+#endif /* CONFIG_UBOOT_CMD_BSP_TESTHW */
+
+#include <configs/digi_common_post.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cc9p9360.h b/include/configs/cc9p9360.h
new file mode 100644
index 0000000..757934d
--- /dev/null
+++ b/include/configs/cc9p9360.h
@@ -0,0 +1,292 @@
+/*
+ *  include/configs/cc9p9360.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* needed for digi_common.h */
+#if defined(CONFIG_A9M9750DEV)
+# define CFG_CONS_INDEX_SUB_1
+#endif
+
+#include <asm-arm/sizes.h>
+#include <ns9750_sys.h>
+#include <configs/digi_common.h>
+
+/************************************************************
+ * Definition of default options when not configured by user
+ ************************************************************/
+#ifndef CONFIG_DIGIEL_USERCONFIG
+# define CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_UBOOT_SPLASH
+# define CONFIG_UBOOT_CRT_VGA
+# define CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD
+# define CONFIG_UBOOT_LQ064V3DG01_TFT_LCD
+# define CONFIG_AUTOLOAD_BOOTSCRIPT
+# define CONFIG_UBOOT_CMD_BSP_COMPAT
+#endif /* ifndef(CONFIG_DIGIEL_USERCONFIG) */
+
+#define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor " MODULE_STRING " on " CONFIG_UBOOT_BOARDNAME_STR
+
+#define CONFIG_GCC41		1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_NS9360		1	/* in an NetSilicon NS9360 SoC     */
+#define CONFIG_CC9P9360		1       /* on a ConnectCore 9P 9360 module */
+#define CONFIG_A9M9360		1       /* old module reference name (added for compatibility) */
+#define CONFIG_IS_NETSILICON    1
+#define CPU     		"NS9360"
+#if defined(CONFIG_JSCC9P9360)
+# define CONFIG_MACH_CC9P9360JS		/* Select board mach-type */
+# define PLATFORM		"js"
+#elif defined(CONFIG_A9M9750DEV)
+# define CONFIG_MACH_CC9P9360DEV
+# define PLATFORM		"dev"
+#else
+# define CONFIG_MACH_CC9P9360VAL	/* Select board mach-type */
+# define PLATFORM		"val"
+#endif
+#define BOARD_LATE_INIT		1	/* Enables initializations before jumping to main loop */
+#define CRYSTAL 		294912
+#define PLLFS			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x17 ) & 0x3)
+#define PLLND			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x10 ) & 0x1f)
+
+#define CONFIG_BOOT_NAND	1
+#define CFG_NO_FLASH		1	/* No NOR-Flash available */
+#define EBOOTFLADDR		"280000"
+#define WCEFLADDR		"380000"
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+# define CONFIG_HAVE_SPI_LOADER  1       /* that initializes SDRAM and */
+#endif  /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+
+#define CONFIG_MODULE_NAME	"cc9p9360"PLATFORM
+#define CONFIG_MODULE_NAME_WCE  "CC9P9360"
+#define CONFIG_MODULE_NAME_NETOS "connectcore9p9360_a"
+#define NS9750_ETH_PHY_ADDRESS	(0x0001)
+
+#define CONFIG_SYS_CLK_FREQ 	(100*CRYSTAL * (PLLND +1) / (1<<PLLFS))
+
+#define CPU_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/2)
+#define AHB_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/4)
+#define BBUS_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/8)
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/************************************************************
+ * Base board specific configurations
+ ************************************************************/
+#if !defined(CONFIG_CONS_INDEX)
+# define CONFIG_CONS_INDEX	1	/*0= Port B; 1= Port A; 2= Port C; 3=Port D */
+#endif
+
+#ifndef CFG_CONSOLE
+#define CFG_CONSOLE            "ttyS"
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+#if defined(CONFIG_JSCC9P9360)
+# define CFG_NS9750_UART		1	/* use on-chip UART */
+# define USER_KEY1_GPIO			67
+# define USER_KEY2_GPIO			68
+# define USER_LED1_GPIO			46
+# define USER_LED2_GPIO			66
+#elif defined(CONFIG_A9M9750DEV)
+# define USER_KEY1_GPIO			45
+# define USER_KEY2_GPIO			46
+
+/* serial stuff */
+# define CFG_NS16550
+# define CFG_NS16550_SERIAL
+# define CFG_NS16550_REG_SIZE    1
+# define CFG_NS16550_CLK         18432000
+# define CFG_NS16550_COM1        0x40000000
+# define CFG_NS16550_COM2        0x40000008
+# define CFG_NS16550_COM3        0x40000010
+# define CFG_NS16550_COM4        0x40000018
+#endif
+
+/* MMC */
+#define MMC_MAX_DEVICE		0
+
+/************************************************************
+ * Activate LEDs while booting
+ ************************************************************/
+#define CONFIG_STATUS_LED
+#define	CONFIG_SHOW_BOOT_PROGRESS 1	/* Show boot progress on LEDs	*/
+
+#define CONFIG_DRIVER_NS9750_ETHERNET 1	/* use on-chip ethernet */
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+#ifdef CONFIG_CMD_USB
+/* USB related stuff */
+# define LITTLEENDIAN		1	/* necessary for USB */
+# define CONFIG_USB_OHCI 	1
+# define CONFIG_USB_STORAGE 	1
+# define CONFIG_DOS_PARTITION 	1
+#endif
+
+#define CONFIG_SILENT_RESCUE	1
+
+#ifdef CONFIG_UBOOT_CMD_BSP_COMPAT
+/* U-Boot 1.1.3 standard settings so we now where to look */
+# define CMD_BSP_COMPAT_ENV_IS_IN_EEPROM 1
+# define CMD_BSP_COMPAT_ENV_OFFSET       0x500
+# define CMD_BSP_COMPAT_ENV_SIZE         0x800
+# define CFG_CMD_BSP_COMPAT		 CFG_CMD_EEPROM
+#endif  /* CONFIG_UBOOT_CMD_BSP_COMPAT */
+
+#ifndef CFG_CMD_BSP_COMPAT
+# define CFG_CMD_BSP_COMPAT 0
+#endif  /* CFG_CMD_BSP_COMPAT */
+
+/* Video settings */
+#ifdef CONFIG_DISPLAYS_SUPPORT
+# define CONFIG_LCD			1
+# if defined(CONFIG_UBOOT_CRT_VGA) || defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD) || defined(CONFIG_UBOOT_LQ064V3DG01_TFT_LCD)
+#  define LCD_BPP       LCD_COLOR16
+# else
+#  error "Please, define LCD_BPP according to your display needs"
+# endif
+#endif
+
+#ifdef CONFIG_UBOOT_SPLASH
+# define CONFIG_SPLASH_SCREEN		1
+# define CONFIG_SPLASH_WITH_CONSOLE	1
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#ifndef CONFIG_COMMANDS
+#define CONFIG_COMMANDS 	\
+	( CONFIG_COMMANDS_DIGI	| \
+	CFG_CMD_BSP_COMPAT	|  \
+	CFG_CMD_DATE		| \
+	CFG_CMD_I2C		| \
+	CFG_CMD_FAT		| \
+	CFG_CMD_MII		| \
+	CFG_CMD_NAND    	| \
+	CFG_CMD_SNTP		|   /* simple network time protocol */ \
+	CFG_CMD_USB     	| \
+	0 )
+#endif
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#if !defined(CONFIG_UBOOT_PROMPT)
+# define CFG_PROMPT 		"CC9P9360 # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT		CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#ifndef CONFIG_UBOOT_BOARDNAME
+# define CONFIG_UBOOT_BOARDNAME_STR	"Development Board"
+#endif
+
+#define MODULE_STRING		"ConnectCore 9P 9360"
+
+#define CFG_MEMTEST_START	0x00200000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x00f80000	/* 13,5 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x00200000	/* default load address	*/
+#define CFG_WCE_LOAD_ADDR	0x002C0000
+#define CFG_INITRD_LOAD_ADDR    0x00600000      /* default initrd  load address */
+#define CFG_NETOS_LOAD_ADDR	0x00500000
+
+#define	CFG_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1    		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	 /* SDRAM Bank #1 */
+/* size will be defined in include/configs when you make the config */
+
+#define PHYS_NAND_FLASH		0x50000000 /* NAND Flash Bank #1 */
+#define CFG_NAND_BASE		PHYS_NAND_FLASH
+
+#define CFG_NAND_BASE_LIST	{ CFG_NAND_BASE }
+
+#define CFG_NAND_UNALIGNED	1
+#define NAND_ECC_INFO		CFG_LOAD_ADDR	/* address in SDRAM is used */
+
+#define NAND_BUSY_GPIO		49
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define PHYS_FLASH_1		0x50000000 /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT	(71)	/* max number of sectors on one chip */
+
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+/* use external RTC */
+#define	CONFIG_RTC_DS1337	1
+#define CFG_I2C_RTC_ADDR	0x68	/* Dallas DS1337 RTC address */
+
+/* i2c bus */
+#define CONFIG_HARD_I2C		1	/* I2C with hardware support */
+#define CONFIG_DRIVER_NS9750_I2C 1	/* I2C driver */
+#define CFG_I2C_SPEED 		100000	/* Hz */
+#define CFG_I2C_SLAVE 		0x7F	/* I2C slave addr */
+#define I2C_SCL_GPIO		70
+#define I2C_SDA_GPIO		71
+#define I2C_SCL_GPIO_FUNC	NS9750_GPIO_CFG_FUNC_2
+#define I2C_SDA_GPIO_FUNC	NS9750_GPIO_CFG_FUNC_2
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM address */
+#define CFG_I2C_EEPROM_ADDR_LEN	2	/* 2 address bytes */
+
+#undef CFG_I2C_EEPROM_ADDR_OVERFLOW
+#define CFG_EEPROM_PAGE_WRITE_BITS    5	/* 32 bytes page write mode on M24LC64 */
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+#define CFG_EEPROM_PAGE_WRITE_ENABLE   1
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <ns9750_nand.h>
+
+/* they are calculated for 128kB sectors. So Kernel/FPGA starts at 1MB */
+# define PART_UBOOT_SIZE	0x000c0000
+# define PART_NVRAM_SIZE        0x00080000
+# define PART_KERNEL_SIZE       0x00300000
+# define PART_ROOTFS_SIZE       0x01000000
+# define PART_WINCE_REG_SIZE	0x00100000
+# define PART_SPLASH_SIZE    	0x00100000
+# define PART_WINCE_SIZE        0x01800000
+# define PART_WINCE_FS_SIZE	0x0
+# define PART_WINCE_FLASHFX_SIZE 0x00200000
+# define PART_NETOS_KERNEL_SIZE 0x004C0000
+
+# define CONFIG_JFFS2_DEV	 "nand0"
+# define CONFIG_JFFS2_NAND
+#endif /* if (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#ifdef CONFIG_IEEE1588
+# define CFG_FPGA_SIZE		344771
+#endif
+
+#include <configs/digi_common_post.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cc9p9750.h b/include/configs/cc9p9750.h
new file mode 100644
index 0000000..64f2511
--- /dev/null
+++ b/include/configs/cc9p9750.h
@@ -0,0 +1,205 @@
+/*
+ *  include/configs/cc9p9750.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !References: For CC9P9750 Vali and Development Board
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm-arm/sizes.h>
+#include <ns9750_sys.h>
+#include <configs/digi_common.h>
+
+#ifdef CONFIG_A9M9750DEV
+# define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor Digi " MODULE_STRING " on Development Board"
+# define CONFIG_MACH_CC9P9750DEV
+# define PLATFORM		"dev"
+# define CFG_NS16550
+# define CFG_NS16550_SERIAL
+# define CFG_NS16550_REG_SIZE	 1
+# define CFG_NS16550_CLK		 18432000
+# define CFG_NS16550_COM1	 0x40000000
+#else
+# define CONFIG_IDENT_STRING	" " VERSION_TAG "\nfor Digi " MODULE_STRING " on Vali Board"
+# define CONFIG_MACH_CC9P9750VAL
+# define PLATFORM		"val"
+# define CFG_NS9750_UART		1	/* use on-chip UART */
+#endif  /* CONFIG_A9M9750DEV */
+
+#define CONFIG_GCC41		1
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_NS9750		1	/* in an NetSilicon NS9360 SoC     */
+#define CONFIG_A9M9750		1
+#define CONFIG_IS_NETSILICON    1
+#define CPU			"NS9750"
+#define BOARD_LATE_INIT		1	/* Enables initializations before jumping to main loop */
+#define CRYSTAL 		294912
+#define PLLFS			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x17 ) & 0x3)
+#define PLLND			((*get_sys_reg_addr( NS9750_SYS_PLL ) >>0x10 ) & 0x1f)
+
+/* CONFIG_CC9C_NAND will be defined in include/configs.h */
+
+#define CONFIG_BOOT_NAND	1
+#define CFG_NO_FLASH		1	/* No NOR-Flash available */
+#define EBOOTFLADDR		"280000"
+#define WCEFLADDR		"380000"
+#ifndef CONFIG_DOWNLOAD_BY_DEBUGGER
+# define CONFIG_HAVE_SPI_LOADER  1       /* that initializes SDRAM and */
+#endif  /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+
+#define CONFIG_MODULE_NAME	"cc9p9750"PLATFORM
+#define CONFIG_MODULE_NAME_WCE  "CC9P9750"
+#define CONFIG_MODULE_NAME_NETOS "connectcore9p9750_a"
+#define NS9750_ETH_PHY_ADDRESS	(0x0001)
+
+#define CONFIG_SYS_CLK_FREQ 	(100*CRYSTAL * (PLLND +1) / (1<<PLLFS))
+
+#define CPU_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/2)
+#define AHB_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/4)
+#define BBUS_CLK_FREQ		(CONFIG_SYS_CLK_FREQ/8)
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+#ifndef CFG_CONSOLE
+#define CFG_CONSOLE            "ttyS"
+#endif
+/************************************************************
+ * Activate LEDs while booting
+ ************************************************************/
+#define	CONFIG_SHOW_BOOT_PROGRESS 1	/* Show boot progress on LEDs	*/
+
+#define CONFIG_DRIVER_NS9750_ETHERNET 1	/* use on-chip ethernet */
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+/* USB related stuff */
+#define LITTLEENDIAN		1	/* necessary for USB */
+#define CONFIG_USB_OHCI 	1
+#define CONFIG_DOS_PARTITION 	1
+#define CONFIG_USB_STORAGE 	1
+
+#define CONFIG_SILENT_RESCUE	1
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS ( \
+         CONFIG_COMMANDS_DIGI | \
+         CFG_CMD_USB     | \
+	 CFG_CMD_NAND    | \
+         0 )
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+
+/************************************************************
+ * CCW9C default environment settings
+ ************************************************************/
+#define CONFIG_EXTRA_ENV_SETTINGS			\
+	"silent="CFG_SET_SILENT"\0"
+
+#if !defined(CONFIG_UBOOT_PROMPT)
+# define CFG_PROMPT 		"CC9P9750 # "	/* Monitor Command Prompt	*/
+#else
+# define CFG_PROMPT		CONFIG_UBOOT_PROMPT_STR
+#endif
+
+#define MODULE_STRING		"CC9P9750"
+
+#define CFG_MEMTEST_START	0x00000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x00f80000	/* 15,5 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x00200000	/* default load address	*/
+#define CFG_WCE_LOAD_ADDR	0x002C0000
+#define CFG_INITRD_LOAD_ADDR    0x00600000      /* default initrd  load address */
+#define CFG_NETOS_LOAD_ADDR     0x00500000
+
+#define	CFG_HZ			(CPU_CLK_FREQ/64)
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1    		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x00000000	 /* SDRAM Bank #1 */
+/* size will be defined in include/configs when you make the config */
+
+#define PHYS_NAND_FLASH		0x50000000 /* NAND Flash Bank #1 */
+#define CFG_NAND_BASE		PHYS_NAND_FLASH
+
+#define CFG_NAND_BASE_LIST	{ CFG_NAND_BASE }
+
+#define CFG_NAND_UNALIGNED	1
+#define NAND_ECC_INFO		CFG_LOAD_ADDR	/* address in SDRAM is used */
+
+#define NAND_BUSY_GPIO		49
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define PHYS_FLASH_1		0x50000000 /* Flash Bank #1 */
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT	(71)	/* max number of sectors on one chip */
+
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+/* use external RTC */
+#define	CONFIG_RTC_DS1337	1
+#define CFG_I2C_RTC_ADDR	0x68	/* Dallas DS1337 RTC address */
+
+#define CONFIG_HARD_I2C			1	/* I2C with hardware support */
+#define CONFIG_HARD_I2C		1	/* I2C with hardware support */
+#define CONFIG_DRIVER_NS9750_I2C 1	/* I2C driver */
+#define CFG_I2C_SPEED 		100000	/* Hz */
+#define CFG_I2C_SLAVE 		0x7F	/* I2C slave addr */
+
+#define CFG_I2C_EEPROM_ADDR	0x50	/* EEPROM address */
+#define CFG_I2C_EEPROM_ADDR_LEN	2	/* 2 address bytes */
+
+#undef CFG_I2C_EEPROM_ADDR_OVERFLOW
+#define CFG_EEPROM_PAGE_WRITE_BITS    5	/* 32 bytes page write mode on M24LC64 */
+#define CFG_EEPROM_PAGE_WRITE_DELAY_MS 10
+#define CFG_EEPROM_PAGE_WRITE_ENABLE   1
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+# include <ns9750_nand.h>
+
+/* they are calculated for 128kB sectors. So Kernel/FPGA starts at 1MB */
+# define PART_UBOOT_SIZE	0x000c0000
+# define PART_NVRAM_SIZE        0x00080000
+# define PART_KERNEL_SIZE       0x00300000
+# define PART_ROOTFS_SIZE       0x01000000
+# define PART_EBOOT_SIZE        0x00100000
+# define PART_WINCE_REG_SIZE    0x00100000
+# define PART_WINCE_SIZE        0x01400000
+# define PART_WINCE_FLASHFX_SIZE 0x00200000
+
+# define CONFIG_JFFS2_DEV	 "nand0"
+# define CONFIG_JFFS2_NAND
+#endif /* if (CONFIG_COMMANDS & CFG_CMD_NAND) */
+
+#include <configs/digi_common_post.h>
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/digi_common.h b/include/configs/digi_common.h
new file mode 100644
index 0000000..8516875
--- /dev/null
+++ b/include/configs/digi_common.h
@@ -0,0 +1,164 @@
+/*
+ *  include/configs/digi_common.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.4 $:
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines all definitions that are common to all DIGI platforms
+*/
+
+#ifndef __DIGI_COMMON_H
+#define __DIGI_COMMON_H
+
+/* global helper stuff */
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+/* may undefine settings */
+
+#include <digi_version.h>
+#include <configs/parse_user_definitions.h>
+
+/* stuff that may be undefined in userconfig.h */
+
+/* ********** user key configuration ********** */
+
+#ifndef CONFIG_UBOOT_DISABLE_USER_KEYS
+# define CONFIG_USER_KEY
+#endif
+
+/* ********** console configuration ********** */
+
+#ifdef CONFIG_SILENT_CONSOLE
+# define CFG_SET_SILENT		"yes"
+#else
+# define CFG_SET_SILENT		"no"
+#endif
+
+/* ********** System Initialization ********** */
+#ifdef CONFIG_DOWNLOAD_BY_DEBUGGER
+# define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_DOWNLOAD_BY_DEBUGGER */
+
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+/* define for developing */
+#undef	CONFIG_SKIP_LOWLEVEL_INIT
+
+/* ********** Booting ********** */
+
+#ifndef CONFIG_BOOTDELAY
+# define CONFIG_BOOTDELAY		4
+#endif  /* CONFIG_BOOTDELAY */
+
+/* ********** Rootfs *********** */
+/* Delay before trying to mount the rootfs from a media */
+#define ROOTFS_DELAY		10
+
+#ifndef CONFIG_ZERO_BOOTDELAY_CHECK
+# define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+#endif  /* CONFIG_ZERO_BOOTDELAY_CHECK */
+
+/* ********** Commands supported ********** */
+
+#define CONFIG_COMMANDS_DIGI (  \
+	( CONFIG_CMD_DFL & ~CFG_CMD_FLASH) | \
+	CFG_CMD_BSP       |  /* DIGI commands like dboot and update */ \
+	CFG_CMD_CACHE     |  /* icache, dcache */ \
+	CFG_CMD_DHCP      | \
+	CFG_CMD_PING      | \
+	CFG_CMD_REGINFO   | \
+	CFG_CMD_AUTOSCRIPT | \
+	0 )
+
+#define	CONFIG_DIGI_CMD	1		/* enables DIGI board specific commands */
+
+/* ********** serial configuration ********** */
+#define CONFIG_BAUDRATE		38400
+
+/* ********** network ********** */
+#ifndef CONFIG_TFTP_RETRIES_ON_ERROR
+# define CONFIG_TFTP_RETRIES_ON_ERROR	5
+#endif
+
+#define CONFIG_CMDLINE_TAG	1 /* passing of ATAGs */
+#define CONFIG_INITRD_TAG	1
+#define CONFIG_SETUP_MEMORY_TAGS 1
+
+/* ********** usb/mmc ********** */
+#define DEFAULT_KERNEL_FS		"fat"
+#define DEFAULT_KERNEL_DEVPART		"0:1"
+#define DEFAULT_ROOTFS_MMC_PART		"/dev/mmcblk0p2"
+#define DEFAULT_ROOTFS_USB_PART		"/dev/sda2"
+
+/* ********** memory sizes ********** */
+#define SPI_LOADER_SIZE		8192
+
+/* NVRAM */
+
+#define CFG_ENV_IS_IN_DIGI_NVRAM
+#define CFG_ENV_SIZE		0x00002000 /* some space for U-Boot */
+
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(768*1024)  /*  we need 2 erase blocks with at
+                                             *  max 128kB for NVRAM compares */
+#define CFG_GBL_DATA_SIZE       256     /* size in bytes reserved for initial data */
+#define CONFIG_SYS_MALLOC_LEN    CFG_MALLOC_LEN
+#define CONFIG_SYS_GBL_DATA_SIZE CFG_GBL_DATA_SIZE
+
+/* ********** misc stuff ********** */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERRIDE
+#define CONFIG_ENV_OVERWRITE
+
+#define	CFG_LONGHELP            /* undef to save memory */
+
+#define	CFG_CBSIZE		2048		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE 		(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define	CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* In: serial, Out: serial etc. */
+#define CFG_CONSOLE_INFO_QUIET
+
+/* stuff for DVTs and special information */
+
+#define CONFIG_DVT_PROVIDED
+#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 1
+
+/* compilation */
+
+#define CFG_64BIT_VSPRINTF      /* we need if for NVRAM */
+#define CFG_64BIT_STRTOUL       /* we need if for NVRAM */
+
+/************************************************************
+ * Default environment settings
+ ************************************************************/
+#define CONFIG_EXTRA_ENV_SETTINGS			\
+	"silent="CFG_SET_SILENT"\0"
+
+#endif /* __DIGI_COMMON_H */
diff --git a/include/configs/digi_common_post.h b/include/configs/digi_common_post.h
new file mode 100644
index 0000000..8e56e79
--- /dev/null
+++ b/include/configs/digi_common_post.h
@@ -0,0 +1,61 @@
+/*
+ *  include/configs/digi_common_post.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.1 $:
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines all definitions that are common to all DIGI platforms
+ *               and needs to be processed after <platform.h>
+*/
+
+#ifndef __DIGI_COMMON_POST_H
+#define __DIGI_COMMON_POST_H
+
+/* for creating the output file and default value of uimg */
+#ifndef CONFIG_UBOOT_IMAGE_NAME
+# define CONFIG_UBOOT_IMAGE_NAME "u-boot-"CONFIG_MODULE_NAME".bin"
+#endif
+
+#ifndef CONFIG_LINUX_IMAGE_NAME
+# define CONFIG_LINUX_IMAGE_NAME	"uImage-"CONFIG_MODULE_NAME
+#endif
+
+#ifndef CONFIG_IMAGE_JFFS2_BASENAME
+# define CONFIG_IMAGE_JFFS2_BASENAME	NULL    /* autogenerated */
+#endif
+
+/* ********** stack sizes ********** */
+#ifdef CONFIG_USE_IRQ
+# define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+# define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+
+/* Video settings, define video variable */
+#ifdef CONFIG_LCD
+/* VGA defaults if supported */
+#if defined(CONFIG_UBOOT_CRT_VGA)
+#define VIDEO_DISPLAY	"displayfb:VGA"
+/* LQ057Q3DC12I defaults if VGA not supported */
+#elif !defined(CONFIG_UBOOT_CRT_VGA) && defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD)
+#define VIDEO_DISPLAY	"displayfb:LQ057Q3DC12I"
+/* LQ064V3DG01 defaults if neither VGA nor LQ057 supported */
+#elif !defined(CONFIG_UBOOT_CRT_VGA) && !defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD) && \
+    defined(CONFIG_UBOOT_LQ064V3DG01_TFT_LCD)
+#define VIDEO_DISPLAY	"displayfb:LQ064V3DG01"
+#elif !defined(CONFIG_UBOOT_CRT_VGA) && !defined(CONFIG_UBOOT_LQ057Q3DC12I_TFT_LCD) && \
+    !defined(CONFIG_UBOOT_LQ064V3DG01_TFT_LCD) && defined(CONFIG_UBOOT_CUSTOM_DISPLAY)
+#error "Custom display name should be defined here"
+#else
+#undef VIDEO_DISPLAY
+#endif
+#endif  /* CONFIG_UBOOT_SPLASH */
+
+#endif  /* __DIGI_COMMON_POST_H */
diff --git a/include/configs/parse_user_definitions.h b/include/configs/parse_user_definitions.h
new file mode 100644
index 0000000..fecac93
--- /dev/null
+++ b/include/configs/parse_user_definitions.h
@@ -0,0 +1,397 @@
+#ifndef __PARSE_USER_DEFINITIONS_H
+#define __PARSE_USER_DEFINITIONS_H
+
+#include <configs/userconfig.h>
+
+#if defined(CONFIG_ENABLE_CONSOLE_GPIO) && defined(CONFIG_CONSOLE_ENABLE_GPIO_STATE)
+#define ENABLE_CONSOLE_GPIO 		CONFIG_ENABLE_CONSOLE_GPIO
+#define CONSOLE_ENABLE_GPIO_STATE 	CONFIG_CONSOLE_ENABLE_GPIO_STATE
+#endif
+
+#ifdef CONFIG_PARTITION
+
+#ifdef CONFIG_PARTITION_FIXED_2
+#define PARTITION_FIXED_2       1
+#else
+#define PARTITION_FIXED_2       0
+#endif
+
+#ifdef CONFIG_PARTITION_READONLY_2
+#define PARTITION_READONLY_2    1
+#else
+#define PARTITION_READONLY_2    0
+#endif
+
+#ifdef CONFIG_PARTITION_ROOTFS_2
+#define PARTITION_ROOTFS_2      1
+#else
+#define PARTITION_ROOTFS_2      0
+#endif
+
+#if ((CONFIG_PARTITION_SIZE_2 != 0 && defined(CONFIG_PARTITION_NAME_2) && \
+	defined(CONFIG_PARTITION_2)) || defined(CONFIG_HAVE_FPGA))
+#define CONFIG_HAVE_PARTITION_2
+#endif
+/* ------------------- */
+
+#ifdef CONFIG_PARTITION_FIXED_3
+#define PARTITION_FIXED_3       1
+#else
+#define PARTITION_FIXED_3       0
+#endif
+
+#ifdef CONFIG_PARTITION_READONLY_3
+#define PARTITION_READONLY_3    1
+#else
+#define PARTITION_READONLY_3    0
+#endif
+
+#ifdef CONFIG_PARTITION_ROOTFS_3
+#define PARTITION_ROOTFS_3      1
+#else
+#define PARTITION_ROOTFS_3      0
+#endif
+
+#if CONFIG_PARTITION_SIZE_3 != 0 && defined(CONFIG_PARTITION_NAME_3 ) && \
+	defined(CONFIG_PARTITION_3) && defined(CONFIG_HAVE_PARTITION_2)
+#define CONFIG_HAVE_PARTITION_3
+#endif
+/* ------------------- */
+
+#ifdef CONFIG_PARTITION_FIXED_4
+#define PARTITION_FIXED_4       1
+#else
+#define PARTITION_FIXED_4       0
+#endif
+
+#ifdef CONFIG_PARTITION_READONLY_4
+#define PARTITION_READONLY_4    1
+#else
+#define PARTITION_READONLY_4    0
+#endif
+
+#ifdef CONFIG_PARTITION_ROOTFS_4
+#define PARTITION_ROOTFS_4      1
+#else
+#define PARTITION_ROOTFS_4      0
+#endif
+
+#if CONFIG_PARTITION_SIZE_4 != 0 && defined(CONFIG_PARTITION_NAME_4) && \
+	defined(CONFIG_PARTITION_4) && defined(CONFIG_HAVE_PARTITION_3)
+#define CONFIG_HAVE_PARTITION_4
+#endif
+/* ------------------- */
+
+#ifdef CONFIG_PARTITION_FIXED_5
+#define PARTITION_FIXED_5       1
+#else
+#define PARTITION_FIXED_5       0
+#endif
+
+#ifdef CONFIG_PARTITION_READONLY_5
+#define PARTITION_READONLY_5    1
+#else
+#define PARTITION_READONLY_5    0
+#endif
+
+#ifdef CONFIG_PARTITION_ROOTFS_5
+#define PARTITION_ROOTFS_5      1
+#else
+#define PARTITION_ROOTFS_5      0
+#endif
+
+#if CONFIG_PARTITION_SIZE_5 != 0 && defined(CONFIG_PARTITION_NAME_5) && \
+	defined(CONFIG_PARTITION_5) && defined(CONFIG_HAVE_PARTITION_4)
+#define CONFIG_HAVE_PARTITION_5
+#endif
+/* ------------------- */
+
+#ifdef CONFIG_PARTITION_FIXED_6
+#define PARTITION_FIXED_6       1
+#else
+#define PARTITION_FIXED_6       0
+#endif
+
+#ifdef CONFIG_PARTITION_READONLY_6
+#define PARTITION_READONLY_6    1
+#else
+#define PARTITION_READONLY_6    0
+#endif
+
+#ifdef CONFIG_PARTITION_ROOTFS_6
+#define PARTITION_ROOTFS_6      1
+#else
+#define PARTITION_ROOTFS_6      0
+#endif
+
+#if CONFIG_PARTITION_SIZE_6 != 0 && defined(CONFIG_PARTITION_NAME_6) && \
+	defined(CONFIG_PARTITION_6) && defined(CONFIG_HAVE_PARTITION_5)
+#define CONFIG_HAVE_PARTITION_6
+#endif
+
+#endif /*PARTITION*/
+
+/* ---------------------------------- */
+/* COMMANDS			      */
+#ifndef CONFIG_CMD_BDI
+#define CONFIG_CMD_BDI		0
+#endif
+#ifndef CONFIG_CMD_LOADS
+#define CONFIG_CMD_LOADS	0
+#endif
+#ifndef CONFIG_CMD_LOADB
+#define CONFIG_CMD_LOADB	0
+#endif
+#ifndef CONFIG_CMD_IMI             
+#define CONFIG_CMD_IMI		0
+#endif
+#ifndef CONFIG_CMD_CACHE
+#define CONFIG_CMD_CACHE	0
+#endif
+#ifndef CONFIG_CMD_FLASH
+#define CONFIG_CMD_FLASH	0
+#endif
+#ifndef CONFIG_CMD_MEMORY
+#define CONFIG_CMD_MEMORY	0
+#endif
+#ifndef CONFIG_CMD_NET
+#define CONFIG_CMD_NET		0
+#endif
+#ifndef CONFIG_CMD_ENV
+#define CONFIG_CMD_ENV		0
+#endif
+#ifndef CONFIG_CMD_KGDB
+#define CONFIG_CMD_KGDB		0
+#endif
+#ifndef CONFIG_CMD_PCMCIA
+#define CONFIG_CMD_PCMCIA	0
+#endif
+#ifndef CONFIG_CMD_IDE
+#define CONFIG_CMD_IDE		0
+#endif
+#ifndef CONFIG_CMD_PCI
+#define CONFIG_CMD_PCI		0
+#endif
+#ifndef CONFIG_CMD_IRQ      
+#define CONFIG_CMD_IRQ		0
+#endif
+#ifndef CONFIG_CMD_BOOTD
+#define CONFIG_CMD_BOOTD	0
+#endif
+#ifndef CONFIG_CMD_CONSOLE
+#define CONFIG_CMD_CONSOLE	0
+#endif
+#ifndef CONFIG_CMD_EEPROM
+#define CONFIG_CMD_EEPROM	0
+#endif
+#ifndef CONFIG_CMD_ASKENV
+#define CONFIG_CMD_ASKENV	0
+#endif
+#ifndef CONFIG_CMD_RUN
+#define CONFIG_CMD_RUN		0
+#endif
+#ifndef CONFIG_CMD_ECHO
+#define CONFIG_CMD_ECHO		0
+#endif
+#ifndef CONFIG_CMD_I2C
+#define CONFIG_CMD_I2C		0
+#endif
+#ifndef CONFIG_CMD_REGINFO
+#define CONFIG_CMD_REGINFO	0
+#endif
+#ifndef CONFIG_CMD_IMMAP
+#define CONFIG_CMD_IMMAP	0
+#endif
+#ifndef CONFIG_CMD_DATE
+#define CONFIG_CMD_DATE		0
+#endif
+#ifndef CONFIG_CMD_DHCP
+#define CONFIG_CMD_DHCP		0
+#endif
+#ifndef CONFIG_CMD_BEDBUG
+#define CONFIG_CMD_BEDBUG	0
+#endif
+#ifndef CONFIG_CMD_FDC
+#define CONFIG_CMD_FDC		0
+#endif
+#ifndef CONFIG_CMD_SCSI
+#define	CONFIG_CMD_SCSI		0
+#endif
+#ifndef CONFIG_CMD_AUTOSCRIPT
+#define CONFIG_CMD_AUTOSCRIPT	0
+#endif
+#ifndef CONFIG_CMD_MII
+#define CONFIG_CMD_MII		0
+#endif
+#ifndef CONFIG_CMD_SETGETDCR
+#define CONFIG_CMD_SETGETDCR	0
+#endif
+#ifndef CONFIG_CMD_BSP
+#define CONFIG_CMD_BSP		0
+#endif
+
+#ifndef CONFIG_CMD_ELF
+#define CONFIG_CMD_ELF		0
+#endif
+#ifndef CONFIG_CMD_MISC
+#define CONFIG_CMD_MISC		0
+#endif
+#ifndef CONFIG_CMD_USB
+#define CONFIG_CMD_USB		0
+#endif
+#ifndef CONFIG_CMD_DOC
+#define CONFIG_CMD_DOC		0
+#endif
+#ifndef CONFIG_CMD_JFFS2
+#define CONFIG_CMD_JFFS2	0
+#endif
+#ifndef CONFIG_CMD_DTT
+#define CONFIG_CMD_DTT		0
+#endif
+#ifndef CONFIG_CMD_SDRAM
+#define CONFIG_CMD_SDRAM	0
+#endif
+#ifndef CONFIG_CMD_DIAG
+#define CONFIG_CMD_DIAG		0
+#endif
+#ifndef CONFIG_CMD_FPGA
+#define CONFIG_CMD_FPGA		0
+#endif
+#ifndef CONFIG_CMD_HWFLOW
+#define CONFIG_CMD_HWFLOW	0
+#endif
+#ifndef CONFIG_CMD_SAVES
+#define CONFIG_CMD_SAVES	0
+#endif
+#ifndef	CONFIG_CMD_CHGMAC
+#define CONFIG_CMD_CHGMAC	0
+#endif
+#ifndef CONFIG_CMD_SPI
+#define CONFIG_CMD_SPI		0
+#endif
+#ifndef CONFIG_CMD_FDOS
+#define CONFIG_CMD_FDOS		0
+#endif
+#ifndef CONFIG_CMD_VFD
+#define CONFIG_CMD_VFD		0
+#endif
+#ifndef CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND		0
+#endif
+#ifndef CONFIG_CMD_BMP
+#define CONFIG_CMD_BMP		0
+#endif
+#ifndef CONFIG_CMD_PORTIO
+#define CONFIG_CMD_PORTIO	0
+#endif
+#ifndef CONFIG_CMD_PING
+#define CONFIG_CMD_PING		0
+#endif
+#ifndef CONFIG_CMD_MMC
+#define CONFIG_CMD_MMC		0
+#endif
+#ifndef CONFIG_CMD_FAT
+#define CONFIG_CMD_FAT		0
+#endif
+#ifndef CONFIG_CMD_IMLS
+#define CONFIG_CMD_IMLS		0
+#endif
+#ifndef CONFIG_CMD_ITEST
+#define CONFIG_CMD_ITEST	0
+#endif
+#ifndef CONFIG_CMD_NFS
+#define CONFIG_CMD_NFS		0
+#endif
+#ifndef CONFIG_CMD_REISER
+#define CONFIG_CMD_REISER	0
+#endif
+#ifndef CONFIG_CMD_CDP
+#define CONFIG_CMD_CDP		0
+#endif
+#ifndef CONFIG_CMD_XIMG
+#define CONFIG_CMD_XIMG		0
+#endif
+#ifndef CONFIG_CMD_UNIVERSE
+#define CONFIG_CMD_UNIVERSE	0
+#endif
+#ifndef CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT2		0
+#endif
+#ifndef CONFIG_CMD_SNTP
+#define CONFIG_CMD_SNTP		0
+#endif
+#ifndef CONFIG_CMD_DISPLAY
+#define CONFIG_CMD_DISPLAY	0
+#endif
+
+#define	USER_DEFINED_COMMANDS ( 0					| \
+				CONFIG_CMD_BDI 			 	| \
+				CONFIG_CMD_LOADS << 1 			| \
+				CONFIG_CMD_LOADB << 2			| \
+				CONFIG_CMD_IMI << 3			| \
+				CONFIG_CMD_CACHE << 4			| \
+				CONFIG_CMD_FLASH << 5			| \
+				CONFIG_CMD_MEMORY << 6			| \
+				CONFIG_CMD_NET << 7			| \
+				CONFIG_CMD_ENV << 8			| \
+				CONFIG_CMD_KGDB << 9			| \
+				CONFIG_CMD_PCMCIA << 10			| \
+				CONFIG_CMD_IDE << 11			| \
+				CONFIG_CMD_PCI << 12			| \
+				CONFIG_CMD_IRQ << 13			| \
+				CONFIG_CMD_BOOTD << 14			| \
+				CONFIG_CMD_CONSOLE << 15		| \
+				CONFIG_CMD_EEPROM << 16			| \
+				CONFIG_CMD_ASKENV << 17			| \
+				CONFIG_CMD_RUN << 18			| \
+				CONFIG_CMD_ECHO << 19			| \
+				CONFIG_CMD_I2C << 20			| \
+				CONFIG_CMD_REGINFO << 21		| \
+				CONFIG_CMD_IMMAP << 22			| \
+				CONFIG_CMD_DATE << 23			| \
+				CONFIG_CMD_DHCP << 24			| \
+				CONFIG_CMD_BEDBUG << 25			| \
+				CONFIG_CMD_FDC << 26			| \
+				CONFIG_CMD_SCSI << 27			| \
+				CONFIG_CMD_AUTOSCRIPT << 28         	| \
+				CONFIG_CMD_MII << 29 			| \
+				CONFIG_CMD_SETGETDCR << 30		| \
+				CONFIG_CMD_BSP << 31			| \
+				CONFIG_CMD_ELF << 32			| \
+				CONFIG_CMD_MISC << 33			| \
+				CONFIG_CMD_USB << 34			| \
+				CONFIG_CMD_DOC << 35			| \
+				CONFIG_CMD_JFFS2 << 36			| \
+				CONFIG_CMD_DTT << 37			| \
+				CONFIG_CMD_SDRAM << 38			| \
+				CONFIG_CMD_DIAG << 39			| \
+				CONFIG_CMD_FPGA << 40			| \
+				CONFIG_CMD_HWFLOW << 41			| \
+				CONFIG_CMD_SAVES << 42			| \
+				CONFIG_CMD_CHGMAC << 43			| \
+				CONFIG_CMD_SPI << 44			| \
+				CONFIG_CMD_FDOS << 45			| \
+				CONFIG_CMD_VFD << 46			| \
+				CONFIG_CMD_NAND << 47			| \
+				CONFIG_CMD_BMP << 48			| \
+				CONFIG_CMD_PORTIO << 49			| \
+				CONFIG_CMD_PING << 50			| \
+				CONFIG_CMD_MMC << 51			| \
+				CONFIG_CMD_FAT << 52			| \
+				CONFIG_CMD_IMLS << 53			| \
+				CONFIG_CMD_ITEST << 54			| \
+				CONFIG_CMD_NFS << 55			| \
+				CONFIG_CMD_REISER << 56			| \
+				CONFIG_CMD_CDP << 57			| \
+				CONFIG_CMD_XIMG << 58			| \
+				CONFIG_CMD_UNIVERSE << 59		| \
+				CONFIG_CMD_EXT2 << 60			| \
+				CONFIG_CMD_SNTP << 61			| \
+				CONFIG_CMD_DISPLAY << 62		| \
+				0 )
+
+#if USER_DEFINED_COMMANDS != 0
+#define CONFIG_COMMANDS USER_DEFINED_COMMANDS
+#endif
+
+#endif /*__PARSE_USER_DEFINITIONS_H*/
diff --git a/include/configs/userconfig.h b/include/configs/userconfig.h
new file mode 100644
index 0000000..312ef74
--- /dev/null
+++ b/include/configs/userconfig.h
@@ -0,0 +1,133 @@
+/*
+ * U-Boot Configuration
+ */
+#define CONFIG_SHOW_HELP 1
+#define CONFIG_UBOOT_SETTINGS 1
+#define CONFIG_DIGIEL_USERCONFIG 1
+#define CONFIG_HAVE_MII 1
+#undef CONFIG_HAVE_MMC
+#undef CONFIG_HAVE_FPGA
+#define CONFIG_HAVE_INTERN_CLK 1
+#undef CONFIG_HAVE_EXTERN_CLK
+#undef CONFIG_HAVE_NAND
+#define CONFIG_HAVE_NOR 1
+#undef CONFIG_HAVE_MAC_IN_EEPROM
+#define CONFIG_HAVE_LCD 1
+#define CONFIG_HAVE_ETHERNET 1
+#undef CONFIG_HAVE_EEPROM
+#undef CONFIG_HAVE_USB
+#define CONFIG_HAVE_I2C 1
+#undef CONFIG_HAVE_SPI
+#define CONFIG_UBOOT_NVRAM_UNCHANGEABLE 1
+
+/*
+ * Commands
+ */
+
+/*
+ * Network
+ */
+#define CONFIG_CMD_MII 1
+#define CONFIG_CMD_NET 1
+#define CONFIG_CMD_DHCP 1
+#define CONFIG_CMD_PING 1
+#define CONFIG_CMD_SNTP 1
+#define CONFIG_CMD_NFS 1
+
+/*
+ * Serial, console and environment
+ */
+#define CONFIG_CMD_LOADS 1
+#define CONFIG_CMD_LOADB 1
+#define CONFIG_CMD_CONSOLE 1
+#define CONFIG_CMD_RUN 1
+#define CONFIG_CMD_ECHO 1
+#define CONFIG_CMD_ENV 1
+
+/*
+ * Memory
+ */
+#define CONFIG_CMD_CACHE 1
+#define CONFIG_CMD_MEMORY 1
+
+/*
+ * Storage
+ */
+#define CONFIG_CMD_FLASH 1
+
+/*
+ * Removable storage devices
+ */
+
+/*
+ * Data bus
+ */
+#define CONFIG_CMD_I2C 1
+
+/*
+ * Filesystem
+ */
+#undef CONFIG_CMD_FAT
+#undef CONFIG_CMD_EXT2
+
+/*
+ * Debug and information
+ */
+#define CONFIG_CMD_BDI 1
+
+/*
+ * Image tools
+ */
+#define CONFIG_CMD_IMI 1
+#define CONFIG_CMD_IMLS 1
+
+/*
+ * Board specific commands
+ */
+#define CONFIG_CMD_DATE 1
+#define CONFIG_CMD_BSP 1
+
+/*
+ * Boot commands
+ */
+#define CONFIG_CMD_BOOTD 1
+#define CONFIG_CMD_AUTOSCRIPT 1
+#define CONFIG_AUTOLOAD_BOOTSCRIPT 1
+#undef CONFIG_CMD_ELF
+#undef CONFIG_UBOOT_FIMS_SUPPORT
+#undef CONFIG_DISPLAY_SELECTED
+
+/*
+ * Misc commands
+ */
+#undef CONFIG_UBOOT_CMD_BSP_TESTHW
+#define CONFIG_CMD_MISC 1
+#define CONFIG_CMD_ITEST 1
+#undef CONFIG_PARTITION
+#undef CONFIG_UBOOT_PROMPT
+#undef CONFIG_UBOOT_BOARDNAME
+#undef CONFIG_NS9360_CONSOLE_PORT_A
+#undef CONFIG_NS9360_CONSOLE_PORT_B
+#undef CONFIG_NS9360_CONSOLE_PORT_C
+#undef CONFIG_NS9360_CONSOLE_PORT_D
+#undef CONFIG_NS9215_CONSOLE_PORT_A
+#define CONFIG_NS9215_CONSOLE_PORT_B 1
+#undef CONFIG_NS9215_CONSOLE_PORT_C
+#undef CONFIG_NS9215_CONSOLE_PORT_D
+#undef CONFIG_NS9210_CONSOLE_PORT_A
+#undef CONFIG_NS9210_CONSOLE_PORT_C
+#undef CONFIG_S3C2443_CONSOLE_PORT_A
+#undef CONFIG_S3C2443_CONSOLE_PORT_B
+#undef CONFIG_S3C2443_CONSOLE_PORT_C
+#undef CONFIG_S3C2443_CONSOLE_PORT_D
+#undef CONFIG_UBOOT_JTAG_CONSOLE
+#undef CONFIG_SILENT_CONSOLE
+#define CONFIG_BOOTDELAY 4
+#undef CONFIG_UBOOT_BOOTFILE
+#define CONFIG_UBOOT_IMAGE_NAME "u-boot-cc9p9215js.bin"
+#undef CONFIG_UBOOT_DISABLE_USER_KEYS
+#define CONFIG_UBOOT_CHECK_CRC32_ON_BOOT 1
+#define CONFIG_UBOOT_VERIFY_IN_SDRAM 1
+#define CONFIG_CONS_INDEX 1
+#define CONFIG_IMAGE_JFFS2_BASENAME "rootfs-cc9p9215js"
+#define CONFIG_LINUX_IMAGE_NAME "uImage-cc9p9215js"
diff --git a/include/digi_version.h b/include/digi_version.h
new file mode 100644
index 0000000..01b64ac
--- /dev/null
+++ b/include/digi_version.h
@@ -0,0 +1,19 @@
+/*
+ *  include/version_digi.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+#ifndef __DIGI_VERSION_H
+#define __DIGI_VERSION_H
+
+#if !defined(VERSION_TAG)
+# define VERSION_TAG		"dub-revf4"	/* default TAG is empty */
+#endif
+
+#endif /* __DIGI_VERSION_H */
diff --git a/include/dvt.h b/include/dvt.h
new file mode 100644
index 0000000..8d73c8d
--- /dev/null
+++ b/include/dvt.h
@@ -0,0 +1,207 @@
+/*
+ *  /targets/U-Boot-cc9p9360js.cvs/include/dvt.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Stuff for Device Verification Tests
+ *               When doing DVTs, we sometimes want a different behaviour than
+ *               in production. E.g. when writing to the NAND flash, we don't
+ *               want the MTD layer to abort on the first verify failed
+ *               error. We might want to check all bytes of the page and print
+ *               all errors.
+ *
+ *               This header files provides functions that enable specific
+ *               behaviour. 
+ *
+ *               If DVT  is off, then DVTWarning and DVTError always return 0
+ *             
+*/
+
+#ifndef _DVT_H
+#define _DVT_H
+
+#include <common.h>
+#include <stdarg.h>
+
+#define DVT_PREFIX     "\n*** DVT: "
+#define ERROR_PREFIX   DVT_PREFIX "ERROR:   "
+#define WARNING_PREFIX DVT_PREFIX "WARNING: "
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP) &&         \
+    defined(CONFIG_UBOOT_CMD_BSP_TESTHW) && \
+    defined(CONFIG_DVT_PROVIDED) && !defined(CONFIG_NS9215)
+
+#define DVTPrintOnlyOnce( ... )       \
+        {                                       \
+                static char bAlreadyPrinted = 0;    \
+                \
+                if( DVTIsEnabled() && !bAlreadyPrinted ) { \
+                        bAlreadyPrinted = 1;               \
+                        eprintf( DVT_PREFIX __VA_ARGS__ );   \
+                }                                          \
+        }
+
+extern char g_bDVTIsEnabled;
+extern char g_bDVTStatusChanged;
+extern char g_bDVTHadError;
+extern char g_bDVTHadWarning;
+
+/**
+ * DVTIsEnabled - 
+ *
+ * @return: returns 1 if DVT test is on otherwise 0
+ */
+static inline char DVTIsEnabled( void ) 
+{
+        return g_bDVTIsEnabled;
+}
+
+/**
+ * DVTError - 
+ *
+ * @return: returns 1 if DVT test had an error. It also prints warnings
+ */
+static inline char DVTError( void ) 
+{
+        if( g_bDVTHadError )
+                eprintf( ERROR_PREFIX "occured\n" );
+
+        if( g_bDVTHadWarning )
+                eprintf( WARNING_PREFIX "occured\n" );
+        return g_bDVTHadError;
+}
+
+/**
+ * DVTStatusChanged -
+ * @bAck - when 1, the status changed is acknowledged, so a next call doesn't
+ *         return 1.
+ *         when two DVTStatusChanged( 0 ) following each other, only the first
+ *         will return 1.
+ *         A DVTStatusChanged( 1 ) will also return 1 and reset it.
+ *         This way, DVTStatusChanged( 0 ) can be used on the same level
+ *         without interferring each other,
+ *         but an upper level will also detect it.
+ * @return: if an error or warning is new
+ */
+static inline char DVTStatusChanged( char bFullAck ) 
+{
+        char bRes = 0;
+
+        if( bFullAck ) {
+                bRes = ( g_bDVTStatusChanged > 0 );
+                g_bDVTStatusChanged = 0;
+        } else if( g_bDVTStatusChanged > 1 ) {
+                bRes = 1;
+                g_bDVTStatusChanged = 1;
+        }
+        
+        return bRes;
+}
+
+static inline void DVTReset( void )
+{
+        g_bDVTStatusChanged = 0;
+        g_bDVTHadError      = 0;
+        g_bDVTHadWarning    = 0;
+}
+
+/*
+ * DVTCountError - remembers an error
+ */
+static inline void DVTCountError( void )
+{
+	if( DVTIsEnabled() ) {
+		g_bDVTStatusChanged = 2;
+		g_bDVTHadError      = 1;
+	}
+}
+
+/**
+ * DVTSetError - remembers an error and returns with 1 if DVTIsEnabled
+ *
+ * Use it like:
+ * if( DVTSetError( "" ) ) { DVT Handling } else { normal handling }
+ */
+static inline char DVTSetError( const char* szFormat, ... ) 
+{
+        if( !DVTIsEnabled() )
+                return 0;
+
+        if( NULL != szFormat ) {
+                va_list ap;
+                
+                /* it's not stderr, put there is no vfprintf( stderr )*/
+                va_start( ap, szFormat );
+                eprintf( ERROR_PREFIX );
+                vprintf( szFormat, ap );
+                eprintf( "\n" );
+                va_end( ap );
+        }
+        
+        g_bDVTStatusChanged = 2;
+        g_bDVTHadError      = 1;
+        
+        return 1;
+}
+
+/*
+ * DVTCountWarning - remembers a warning
+ */
+static inline void  DVTCountWarning( void )
+{
+	if( DVTIsEnabled() ) {
+		g_bDVTStatusChanged = 2;
+		g_bDVTHadWarning    = 1;
+	}
+}
+
+/**
+ * DVTSetWarning - remembers a warning and returns with 1 if DVTIsEnabled
+ *
+ * Use it like:
+ * if( DVTSetWarning() ) { DVT Handling } else { normal handling }
+ */
+static inline char DVTSetWarning( const char* szFormat, ... ) 
+{
+        if( !DVTIsEnabled() )
+                return 0;
+        
+        if( NULL != szFormat ) {
+                va_list ap;
+                
+                /* it's not stderr, put there is no vfprintf( stderr )*/
+                va_start( ap, szFormat );
+                eprintf( WARNING_PREFIX );
+                vprintf( szFormat, ap );
+                eprintf( "\n" );
+                va_end( ap );
+        }
+        
+        g_bDVTStatusChanged = 2;
+        g_bDVTHadWarning    = 1;
+
+        return 1;
+}
+
+#else
+/* don't have negative impact on performance */
+# define DVTPrintOnlyOnce( ... )      do {} while( 0 )
+# define DVTIsEnabled()               ( 0 )
+# define DVTEnable( bEnabled )        ( 0 )
+# define DVTError()                   ( 0 )
+# define DVTStatusChanged(bAck)       ( 0 )
+# define DVTReset()                   do {} while( 0 )
+# define DVTCountError()    	      do {} while( 0 )
+# define DVTSetError(szFormat,...)    ( 0 )
+# define DVTCountWarning()            do {} while( 0 )
+# define DVTSetWarning(szFormat,...)  ( 0 )
+#endif  /* CONFIG_DVT_PROVIDED */
+#endif  /* _DVT_H */
diff --git a/include/environment.h b/include/environment.h
index fbccf6a..92940d7 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -149,9 +149,10 @@ typedef	struct environment_s {
 	unsigned char	data[ENV_SIZE]; /* Environment data		*/
 } env_t;
 
+#ifdef REMOVE
 /* Function that returns a character from the environment */
-unsigned char env_get_char (int);
-
+unsigned char (*env_get_char) (int);
+#endif
 /* Function that returns a pointer to a value from the environment */
 unsigned char *env_get_addr(int);
 unsigned char env_get_char_memory (int index);
diff --git a/include/flash.h b/include/flash.h
index 8feca1b..6f050c9 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -33,8 +33,8 @@ typedef struct {
 	ulong	size;			/* total bank size in bytes		*/
 	ushort	sector_count;		/* number of erase units		*/
 	ulong	flash_id;		/* combined device & manufacturer code	*/
-	ulong	start[CONFIG_SYS_MAX_FLASH_SECT];   /* virtual sector start address */
-	uchar	protect[CONFIG_SYS_MAX_FLASH_SECT]; /* sector protection status	*/
+	ulong	start[CFG_MAX_FLASH_SECT];   /* virtual sector start address */
+	uchar	protect[CFG_MAX_FLASH_SECT]; /* sector protection status	*/
 #ifdef CONFIG_SYS_FLASH_CFI
 	uchar	portwidth;		/* the width of the port		*/
 	uchar	chipwidth;		/* the width of the chip		*/
diff --git a/include/helper.h b/include/helper.h
new file mode 100644
index 0000000..396f67e
--- /dev/null
+++ b/include/helper.h
@@ -0,0 +1,22 @@
+/*
+ *  common/helper.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+*/
+
+#ifndef __DIGI_HELPER_H
+#define __DIGI_HELPER_H
+
+extern int WaitForYesPressed( const char* szWhat, const char* szWhere );
+
+#endif  /* __DIGI_HELPER_H */
diff --git a/include/ics1893bk.h b/include/ics1893bk.h
new file mode 100644
index 0000000..5cf0219
--- /dev/null
+++ b/include/ics1893bk.h
@@ -0,0 +1,185 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2005 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ *
+ * $Id$
+ * @Author: Jonas Dietsche
+ * @References: 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ ***********************************************************************/
+
+#ifndef __ICS1893BK_H__
+#define __ICS1893BK_H__
+
+/* PHY definitions ICS1893BK */
+#define PHY_COMMON_CTRL			(0x00)
+#define PHY_COMMON_STAT			(0x01)
+#define PHY_COMMON_ID1			(0x02)
+#define PHY_COMMON_ID2			(0x03)
+#define PHY_COMMON_AUTO_ADV	(0x04)
+#define PHY_COMMON_AUTO_LNKB	(0x05)
+#define PHY_COMMON_AUTO_EXP	(0x06)
+#define PHY_COMMON_AUTO_NEXT	(0x07)
+#define PHY_COMMON_AUTO_LNKN	(0x08)
+#define PHY_ICS1893_EXT_CTRL		(0x10)
+#define PHY_ICS1893_QPSTAT		(0x11)
+#define PHY_ICS1893_10B_OPSTAT	(0x12)
+#define PHY_ICS1893_EXT_CTRL_2	(0x13)
+
+/* CTRL PHY Control Register Bit Fields */
+#define PHY_COMMON_CTRL_RESET		(0x8000)
+#define PHY_COMMON_CTRL_LOOPBACK	(0x4000)
+#define PHY_COMMON_CTRL_SPD_MA   	(0x2000)
+#define PHY_COMMON_CTRL_SPD_10		(0x0000)
+#define PHY_COMMON_CTRL_SPD_100		(0x2000)
+#define PHY_COMMON_CTRL_AUTO_NEG	(0x1000)
+#define PHY_COMMON_CTRL_POWER_DN	(0x0800)
+#define PHY_COMMON_CTRL_ISOLATE	 	(0x0400)
+#define PHY_COMMON_CTRL_RES_AUTO	(0x0200)
+#define PHY_COMMON_CTRL_DUPLEX	 	(0x0100)
+#define PHY_COMMON_CTRL_COL_TEST	(0x0080)
+#define PHY_COMMON_CTRL_RES1		(0x003F)
+
+/* STAT Status Register Bit Fields */
+#define PHY_COMMON_STAT_100BT4	 	(0x8000)
+#define PHY_COMMON_STAT_100BXFD	 	(0x4000)
+#define PHY_COMMON_STAT_100BXHD	(0x2000)
+#define PHY_COMMON_STAT_10BTFD		(0x1000)
+#define PHY_COMMON_STAT_10BTHD		(0x0800)
+#define PHY_COMMON_STAT_MF_PSUP		(0x0040)
+#define PHY_COMMON_STAT_AN_COMP	(0x0020)
+#define PHY_COMMON_STAT_RMT_FLT		(0x0010)
+#define PHY_COMMON_STAT_AN_CAP		(0x0008)
+#define PHY_COMMON_STAT_LNK_STAT	(0x0004)
+#define PHY_COMMON_STAT_JAB_DTCT	(0x0002)
+#define PHY_COMMON_STAT_EXT_CAP		(0x0001)
+
+/* AUTO_ADV Auto-neg Advert Register Bit Fields */
+#define PHY_COMMON_AUTO_ADV_NP			(0x8000)
+#define PHY_COMMON_AUTO_ADV_RES1		(0x4000)
+#define PHY_COMMON_AUTO_ADV_RMT_FLT	(0x2000)
+#define PHY_COMMON_AUTO_ADV_RES2		(0x1000)
+#define PHY_COMMON_AUTO_ADV_RES3		(0x0800)
+#define PHY_COMMON_AUTO_ADV_RES4		(0x0400)
+#define PHY_COMMON_AUTO_ADV_100BT4		(0x0200)
+#define PHY_COMMON_AUTO_ADV_100BTXFD	(0x0100)
+#define PHY_COMMON_AUTO_ADV_100BTX		(0x0080)
+#define PHY_COMMON_AUTO_ADV_10BTFD		(0x0040)
+#define PHY_COMMON_AUTO_ADV_10BT		(0x0020)
+#define PHY_COMMON_AUTO_ADV_SEL_FLD_MA	(0x001F)
+#define PHY_COMMON_AUTO_ADV_802_3		(0x0001)
+
+/* AUTO_LNKB Auto-neg Link Ability Register Bit Fields */
+#define PHY_COMMON_AUTO_LNKB_NP		(0x8000)
+#define PHY_COMMON_AUTO_LNKB_ACK		(0x4000)
+#define PHY_COMMON_AUTO_LNKB_RMT_FLT	(0x2000)
+#define PHY_COMMON_AUTO_LNKB_RES2		(0x1000)
+#define PHY_COMMON_AUTO_LNKB_RES3		(0x0800)
+#define PHY_COMMON_AUTO_LNKB_RES4		(0x0400)
+#define PHY_COMMON_AUTO_LNKB_100BT4	(0x0200)
+#define PHY_COMMON_AUTO_LNKB_100BTXFD	(0x0100)
+#define PHY_COMMON_AUTO_LNKB_100BTX	(0x0080)
+#define PHY_COMMON_AUTO_LNKB_10BTFD	(0x0040)
+#define PHY_COMMON_AUTO_LNKB_10BT		(0x0020)
+#define PHY_COMMON_AUTO_LNKB_SEL_FLD_MA	(0x001F)
+#define PHY_COMMON_AUTO_LNKB_802_3		(0x0001)
+
+/* AUTO_EXP Auto-neg Expansion Register Bit Fields */
+#define PHY_COMMON_AUTO_EXP_RES1		(0xFFC0)
+#define PHY_COMMON_AUTO_EXP_BASE_PAGE	(0x0020)
+#define PHY_COMMON_AUTO_EXP_PAR_DT_FLT	(0x0010)
+#define PHY_COMMON_AUTO_EXP_LNK_NP_CAP	(0x0008)
+#define PHY_COMMON_AUTO_EXP_NP_CAP		(0x0004)
+#define PHY_COMMON_AUTO_EXP_PAGE_REC	(0x0002)
+#define PHY_COMMON_AUTO_EXP_LNK_AN_CAP	(0x0001)
+
+/* AUTO_NEXT Aut-neg Next Page Tx Register Bit Fields */
+#define PHY_COMMON_AUTO_NEXT_NP		(0x8000)
+#define PHY_COMMON_AUTO_NEXT_RES1		(0x4000)
+#define PHY_COMMON_AUTO_NEXT_MSG_PAGE	(0x2000)
+#define PHY_COMMON_AUTO_NEXT_ACK_2		(0x1000)
+#define PHY_COMMON_AUTO_NEXT_TOGGLE	(0x0800)
+#define PHY_COMMON_AUTO_NEXT_MSG		(0x07FF)
+
+/* AUTO_LNKN Auto-neg Link Partner Rx Reg Bit Fields */
+#define PHY_COMMON_AUTO_LNKN_NP         (0x8000)
+#define PHY_COMMON_AUTO_LNKN_RES1        (0x4000)
+#define PHY_COMMON_AUTO_LNKN_MSG_PAGE   (0x2000)
+#define PHY_COMMON_AUTO_LNKN_ACK_2      (0x1000)
+#define PHY_COMMON_AUTO_LNKN_TOGGLE     (0x0800)
+#define PHY_COMMON_AUTO_LNKN_MSG        (0x07FF)
+
+/* Extended Control Register */
+#define PHY_ICS1893_EXT_CTRL_CMD_OWR		(0x8000)
+#define PHY_ICS1893_EXT_CTRL_MONDL_4		(0x0400)
+#define PHY_ICS1893_EXT_CTRL_MONDL_3		(0x0200)
+#define PHY_ICS1893_EXT_CTRL_MONDL_2		(0x0100)
+#define PHY_ICS1893_EXT_CTRL_MONDL_1		(0x0080)
+#define PHY_ICS1893_EXT_CTRL_MONDL_0		(0x0040)
+#define PHY_ICS1893_EXT_CTRL_MONDL		(0x07C0)
+#define PHY_ICS1893_EXT_CTRL_SCIPHER_TEST	(0x0020)
+#define PHY_ICS1893_EXT_CTRL_ICS_RES2		(0x0010)
+#define PHY_ICS1893_EXT_CTRL_NRZ_NRZI		(0x0008)
+#define PHY_ICS1893_EXT_CTRL_TX_INV		(0x0004)
+#define PHY_ICS1893_EXT_CTRL_ICS_RES1		(0x0002)
+#define PHY_ICS1893_EXT_CTRL_SCIPHER		(0x0001)
+
+/* QuickPoll Detailed Status Register */
+#define PHY_ICS1893_QPSTAT_DATA_RATE			(0x8000)
+#define PHY_ICS1893_QPSTAT_DUPLEX			(0x4000)
+#define PHY_ICS1893_QPSTAT_AUTO_NEG_PROG_2	(0x2000)
+#define PHY_ICS1893_QPSTAT_AUTO_NEG_PROG_1	(0x1000)
+#define PHY_ICS1893_QPSTAT_AUTO_NEG_PROG_0	(0x0800)
+#define PHY_ICS1893_QPSTAT_AUTO_NEG_PROG		(0x3800)
+#define PHY_ICS1893_QPSTAT_100TX_LOST			(0x0400)
+#define PHY_ICS1893_QPSTAT_100PLL_LOCK 		(0x0200)
+#define PHY_ICS1893_QPSTAT_FALSE_CAR_DETECT   	(0x0100)
+#define PHY_ICS1893_QPSTAT_INV_DETECT			(0x0080)
+#define PHY_ICS1893_QPSTAT_HALT_DETECT		(0x0040)
+#define PHY_ICS1893_QPSTAT_PRE_END_DETECT 	(0x0020)
+#define PHY_ICS1893_QPSTAT_AUTO_NEG_COMP   	(0x0010)
+#define PHY_ICS1893_QPSTAT_100BTX			(0x0008)
+#define PHY_ICS1893_QPSTAT_JDETECT  			(0x0004)
+#define PHY_ICS1893_QPSTAT_REMFAULT  			(0x0002)
+#define PHY_ICS1893_QPSTAT_LINKSTAT   			(0x0001)
+
+/* I10Base-T Operations Register */
+#define PHY_ICS1893_10B_OPSTAT_REM_JAB_DTCT		(0x8000)
+#define PHY_ICS1893_10B_OPSTAT_POL_RES			(0x4000)
+#define PHY_ICS1893_10B_OPSTAT_JAB_INHIB			(0x0020)
+#define PHY_ICS1893_10B_OPSTAT_AUTOPOL_INHIB		(0x0008)
+#define PHY_ICS1893_10B_OPSTAT_SQE_INHIB			(0x0004)
+#define PHY_ICS1893_10B_OPSTAT_LLOSS_INHIB		(0x0002)
+#define PHY_ICS1893_10B_OPSTAT_SQUELCH_INHIB		(0x0001)
+
+/* Extended Control Register 2 */
+#define PHY_ICS1893_EXT_CTRL_2_RES1      (0xFF00)
+#define PHY_ICS1893_EXT_CTRL_2_NODE_MODE			(0x8000)
+#define PHY_ICS1893_EXT_CTRL_2_HW_SW_MODE		(0x4000)
+#define PHY_ICS1893_EXT_CTRL_2_REM_FAULT			(0x2000)
+#define PHY_ICS1893_EXT_CTRL_2_AMDIX_EN			(0x0200)
+#define PHY_ICS1893_EXT_CTRL_2_MDI_MODE			(0x0100)
+#define PHY_ICS1893_EXT_CTRL_2_TP_TRISTATE			(0x0080)
+#define PHY_ICS1893_EXT_CTRL_2_AUTO_100BTX_DWN	(0x0001)
+
+#define PHY_ICS1893_MDIO_MAX_CLK		(25000000)
+#define PHY_MDIO_MAX_CLK				(25000000)
+
+
+#endif /* __ICS1893BK_H__ */
diff --git a/include/ns921x.h b/include/ns921x.h
new file mode 100644
index 0000000..99866c6
--- /dev/null
+++ b/include/ns921x.h
@@ -0,0 +1,28 @@
+/*
+ *  include/ns921x.h
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      ns921x helper functions
+*/
+
+#ifndef _NS921X_H
+#define _NS921X_H
+
+#define NS_CPU_REF_CLOCK 29491200
+
+#ifndef __ASSEMBLY__
+extern int sys_clock_freq( void );
+extern int cpu_clock_freq( void );
+extern int ahb_clock_freq( void );
+#endif
+
+#endif  /* _NS921X_H */
diff --git a/include/ns9750_eth.h b/include/ns9750_eth.h
index 80c721b..1b35cc5 100644
--- a/include/ns9750_eth.h
+++ b/include/ns9750_eth.h
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_eth.h,v 1.2 2004/02/24 13:25:39 mpietrek Exp $
+ * $Id: ns9750_eth.h,v 1.3 2005/01/12 13:05:26 jjaeger Exp $
  * @Author: Markus Pietrek
  * @References: [1] NS9750 Hardware Reference, December 2003
  *              [2] Intel LXT971 Datasheet #249414 Rev. 02
@@ -23,30 +23,50 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
- *
+ *  
  ***********************************************************************/
 
 #ifndef FS_NS9750_ETH_H
 #define FS_NS9750_ETH_H
 
-#ifdef CONFIG_DRIVER_NS9750_ETHERNET
-
-#include <miiphy.h>
-#include "lxt971a.h"
-
-#define	NS9750_ETH_MODULE_BASE		(0xA0600000)
+#ifdef CONFIG_NS9750ACCORD
+# include "rtl8201.h"
+#elif defined (CONFIG_CC9C) || defined(CONFIG_CCW9C) || defined(CONFIG_CC9P9215) \
+	|| defined(CONFIG_CCW9P9215) || defined(CONFIG_CME9210) \
+	|| defined(CONFIG_CC9P9210)
+# define CONFIG_PHY_ICS1893	1
+# include "ics1893bk.h"
+#elif defined (CONFIG_INC20OTTER)
+# define CONFIG_PHY_HIRSCHMANN	1
+# include "phyhirschmann.h"
+#else
+# include "lxt971a.h"
+#endif
+
+typedef enum
+{
+	PHY_NONE    = 0xFFFF, /* no PHY detected yet */
+	PHY_ICS1893BK = 0x0015,
+	PHY_LXT971A = 0x0013,
+	PHY_RTL8201 = 0x0000,
+	PHY_HIRSCHMANN = 0x0007,
+} PhyType;
+
+#define PHY_MDIO_ASS_CLK (2500000) /* assured clock speed */
+
+#define	NS9750_ETH_MODULE_BASE	 	(0xA0600000)
 
 #define get_eth_reg_addr(c) \
      ((volatile unsigned int*) ( NS9750_ETH_MODULE_BASE+(unsigned int) (c)))
 
-#define NS9750_ETH_EGCR1		(0x0000)
-#define NS9750_ETH_EGCR2		(0x0004)
-#define NS9750_ETH_EGSR			(0x0008)
-#define NS9750_ETH_FIFORX		(0x000C)
-#define NS9750_ETH_FIFOTX		(0x0010)
-#define NS9750_ETH_FIFOTXS		(0x0014)
-#define NS9750_ETH_ETSR			(0x0018)
-#define NS9750_ETH_ERSR			(0x001C)
+#define NS9750_ETH_EGCR1	 	(0x0000)
+#define NS9750_ETH_EGCR2	 	(0x0004)
+#define NS9750_ETH_EGSR		 	(0x0008)
+#define NS9750_ETH_FIFORX	 	(0x000C)
+#define NS9750_ETH_FIFOTX	 	(0x0010)
+#define NS9750_ETH_FIFOTXS	 	(0x0014)
+#define NS9750_ETH_ETSR		 	(0x0018)
+#define NS9750_ETH_ERSR		 	(0x001C)
 #define NS9750_ETH_MAC1			(0x0400)
 #define NS9750_ETH_MAC2			(0x0404)
 #define NS9750_ETH_IPGT			(0x0408)
@@ -65,9 +85,9 @@
 #define NS9750_ETH_SA2			(0x0444)
 #define NS9750_ETH_SA3			(0x0448)
 #define NS9750_ETH_SAFR			(0x0500)
-#define NS9750_ETH_HT1			(0x0504)
-#define NS9750_ETH_HT2			(0x0508)
-#define NS9750_ETH_STAT_BASE		(0x0680)
+#define NS9750_ETH_HT1		 	(0x0504)
+#define NS9750_ETH_HT2		 	(0x0508)
+#define NS9750_ETH_STAT_BASE	 	(0x0680)
 #define NS9750_ETH_RXAPTR		(0x0A00)
 #define NS9750_ETH_RXBPTR		(0x0A04)
 #define NS9750_ETH_RXCPTR		(0x0A08)
@@ -85,42 +105,50 @@
 #define NS9750_ETH_TXOFF		(0x0A38)
 #define NS9750_ETH_RXFREE		(0x0A3C)
 #define NS9750_ETH_TXBD			(0x1000)
+#define NS9750_ETH_TXBD1		(0x1010)
+#define NS9750_ETH_TXBD2		(0x1020)
 
 /* register bit fields */
 
-#define NS9750_ETH_EGCR1_ERX		(0x80000000)
-#define NS9750_ETH_EGCR1_ERXDMA		(0x40000000)
-#define NS9750_ETH_EGCR1_ERXSHT		(0x10000000)
-#define NS9750_ETH_EGCR1_ERXSIZ		(0x08000000)
-#define NS9750_ETH_EGCR1_ETXSIZ		(0x04000000)
+#define NS9750_ETH_EGCR1_ERX	 	(0x80000000)
+#define NS9750_ETH_EGCR1_ERXDMA	 	(0x40000000)
+#define NS9750_ETH_EGCR1_ERXSHT	 	(0x10000000)
+#define NS9750_ETH_EGCR1_ERXSIZ	 	(0x08000000)
+#define NS9750_ETH_EGCR1_ETXSIZ	 	(0x04000000)
 #define NS9750_ETH_EGCR1_ETXDIAG	(0x02000000)
-#define NS9750_ETH_EGCR1_ERXBAD		(0x01000000)
-#define NS9750_ETH_EGCR1_ETX		(0x00800000)
-#define NS9750_ETH_EGCR1_ETXDMA		(0x00400000)
-#define NS9750_ETH_EGCR1_ETXWM		(0x00200000)
-#define NS9750_ETH_EGCR1_ERXADV		(0x00100000)
+#define NS9750_ETH_EGCR1_ERXBAD	 	(0x01000000)
+#define NS9750_ETH_EGCR1_ETX	 	(0x00800000)
+#define NS9750_ETH_EGCR1_ETXDMA	 	(0x00400000)
+#define NS9750_ETH_EGCR1_ETXWM	  	(0x00200000)
+#define NS9750_ETH_EGCR1_ERXADV	 	(0x00100000)
 #define NS9750_ETH_EGCR1_ERXINIT	(0x00080000)
-#define NS9750_ETH_EGCR1_PHY_MODE_MA	(0x0000C000)
-#define NS9750_ETH_EGCR1_PHY_MODE_MII	(0x00008000)
-#define NS9750_ETH_EGCR1_PHY_MODE_RMII	(0x00004000)
-#define NS9750_ETH_EGCR1_RXCINV		(0x00001000)
-#define NS9750_ETH_EGCR1_TXCINV		(0x00000800)
+#define NS9750_ETH_EGCR1_PHY_MODE_MA  	(0x0000C000)
+#define NS9750_ETH_EGCR1_PHY_MODE_MII 	(0x00000000)
+#define NS9750_ETH_EGCR1_PHY_MODE_RMII 	(0x00004000)
+#define NS9750_ETH_EGCR1_RXCINV	 	(0x00001000)
+#define NS9750_ETH_EGCR1_TXCINV	 	(0x00000800)
 #define NS9750_ETH_EGCR1_RXALIGN	(0x00000400)
-#define NS9750_ETH_EGCR1_MAC_HRST	(0x00000200)
-#define NS9750_ETH_EGCR1_ITXA		(0x00000100)
+#define NS9750_ETH_EGCR1_MAC_HRST 	(0x00000200)
+#define NS9750_ETH_EGCR1_ITXA	 	(0x00000100)
 
 #define NS9750_ETH_EGCR2_TPTV_MA	(0xFFFF0000)
 #define NS9750_ETH_EGCR2_TPCF		(0x00000040)
 #define NS9750_ETH_EGCR2_THPDF		(0x00000020)
-#define NS9750_ETH_EGCR2_TCLER		(0x00000008)
+#ifndef CONFIG_NS921X
+# define NS9750_ETH_EGCR2_TCLER		(0x00000008)
+# define NS9750_ETH_EGCR2_TKICK		(0x00000000)
+#else
+# define NS9750_ETH_EGCR2_TCLER		(0x00000080)
+# define NS9750_ETH_EGCR2_TKICK		(0x00000008)
+#endif
 #define NS9750_ETH_EGCR2_AUTOZ		(0x00000004)
 #define NS9750_ETH_EGCR2_CLRCNT		(0x00000002)
 #define NS9750_ETH_EGCR2_STEN		(0x00000001)
 
-#define NS9750_ETH_EGSR_RXINIT		(0x00100000)
-#define NS9750_ETH_EGSR_TXFIFONF	(0x00080000)
-#define NS9750_ETH_EGSR_TXFIFOH		(0x00040000)
-#define NS9750_ETH_EGSR_TXFIFOE		(0x00010000)
+#define NS9750_ETH_EGSR_RXINIT	 	(0x00100000)
+#define NS9750_ETH_EGSR_TXFIFONF 	(0x00080000)
+#define NS9750_ETH_EGSR_TXFIFOH	 	(0x00040000)
+#define NS9750_ETH_EGSR_TXFIFOE	 	(0x00010000)
 
 #define NS9750_ETH_FIFOTXS_ALL		(0x00000055)
 #define NS9750_ETH_FIFOTXS_3		(0x000000d5)
@@ -128,116 +156,123 @@
 #define NS9750_ETH_FIFOTXS_1		(0x0000000D)
 #define NS9750_ETH_FIFOTXS_0		(0x00000003)
 
-#define NS9750_ETH_ETSR_TXOK		(0x00008000)
-#define NS9750_ETH_ETSR_TXBR		(0x00004000)
-#define NS9750_ETH_ETSR_TXMC		(0x00002000)
-#define NS9750_ETH_ETSR_TXAL		(0x00001000)
-#define NS9750_ETH_ETSR_TXAED		(0x00000800)
-#define NS9750_ETH_ETSR_TXAEC		(0x00000400)
-#define NS9750_ETH_ETSR_TXAUR		(0x00000200)
-#define NS9750_ETH_ETSR_TXAJ		(0x00000100)
-#define NS9750_ETH_ETSR_TXDEF		(0x00000040)
-#define NS9750_ETH_ETSR_TXCRC		(0x00000020)
-#define NS9750_ETH_ETSR_TXCOLC		(0x0000000F)
+#define NS9750_ETH_ETSR_TXOK	 	(0x00008000)
+#define NS9750_ETH_ETSR_TXBR	 	(0x00004000)
+#define NS9750_ETH_ETSR_TXMC	 	(0x00002000)
+#define NS9750_ETH_ETSR_TXAL	 	(0x00001000)
+#define NS9750_ETH_ETSR_TXAED	 	(0x00000800)
+#define NS9750_ETH_ETSR_TXAEC	 	(0x00000400)
+#define NS9750_ETH_ETSR_TXAUR	 	(0x00000200)
+#define NS9750_ETH_ETSR_TXAJ	 	(0x00000100)
+#define NS9750_ETH_ETSR_TXDEF	 	(0x00000040)
+#define NS9750_ETH_ETSR_TXCRC	 	(0x00000020)
+#define NS9750_ETH_ETSR_TXCOLC   	(0x0000000F)
+#define NS9750_ETH_ETSR_ERROR_MA	( NS9750_ETH_ETSR_TXAL  | \
+                                          NS9750_ETH_ETSR_TXAED | \
+                                          NS9750_ETH_ETSR_TXAEC | \
+                                          NS9750_ETH_ETSR_TXAUR | \
+                                          NS9750_ETH_ETSR_TXAJ  | \
+                                          NS9750_ETH_ETSR_TXDEF | \
+                                          NS9750_ETH_ETSR_TXCRC )
 
 #define NS9750_ETH_ERSR_RXSIZE_MA	(0x0FFF0000)
-#define NS9750_ETH_ERSR_RXCE		(0x00008000)
-#define NS9750_ETH_ERSR_RXDV		(0x00004000)
-#define NS9750_ETH_ERSR_RXOK		(0x00002000)
-#define NS9750_ETH_ERSR_RXBR		(0x00001000)
-#define NS9750_ETH_ERSR_RXMC		(0x00000800)
-#define NS9750_ETH_ERSR_RXCRC		(0x00000400)
-#define NS9750_ETH_ERSR_RXDR		(0x00000200)
-#define NS9750_ETH_ERSR_RXCV		(0x00000100)
-#define NS9750_ETH_ERSR_RXSHT		(0x00000040)
-
-#define NS9750_ETH_MAC1_SRST		(0x00008000)
-#define NS9750_ETH_MAC1_SIMMRST		(0x00004000)
-#define NS9750_ETH_MAC1_RPEMCSR		(0x00000800)
-#define NS9750_ETH_MAC1_RPERFUN		(0x00000400)
-#define NS9750_ETH_MAC1_RPEMCST		(0x00000200)
-#define NS9750_ETH_MAC1_RPETFUN		(0x00000100)
-#define NS9750_ETH_MAC1_LOOPBK		(0x00000010)
-#define NS9750_ETH_MAC1_TXFLOW		(0x00000008)
-#define NS9750_ETH_MAC1_RXFLOW		(0x00000004)
-#define NS9750_ETH_MAC1_PALLRX		(0x00000002)
-#define NS9750_ETH_MAC1_RXEN		(0x00000001)
-
-#define NS9750_ETH_MAC2_EDEFER		(0x00004000)
-#define NS9750_ETH_MAC2_BACKP		(0x00002000)
-#define NS9750_ETH_MAC2_NOBO		(0x00001000)
-#define NS9750_ETH_MAC2_LONGP		(0x00000200)
-#define NS9750_ETH_MAC2_PUREP		(0x00000100)
-#define NS9750_ETH_MAC2_AUTOP		(0x00000080)
-#define NS9750_ETH_MAC2_VLANP		(0x00000040)
-#define NS9750_ETH_MAC2_PADEN		(0x00000020)
-#define NS9750_ETH_MAC2_CRCEN		(0x00000010)
-#define NS9750_ETH_MAC2_DELCRC		(0x00000008)
-#define NS9750_ETH_MAC2_HUGE		(0x00000004)
-#define NS9750_ETH_MAC2_FLENC		(0x00000002)
-#define NS9750_ETH_MAC2_FULLD		(0x00000001)
-
-#define NS9750_ETH_IPGT_MA		(0x0000007F)
-
-#define NS9750_ETH_IPGR_IPGR1		(0x00007F00)
-#define NS9750_ETH_IPGR_IPGR2		(0x0000007F)
-
-#define NS9750_ETH_CLRT_CWIN		(0x00003F00)
-#define	NS9750_ETH_CLRT_RETX		(0x0000000F)
-
-#define NS9750_ETH_MAXF_MAXF		(0x0000FFFF)
-
-#define NS9750_ETH_SUPP_RPERMII		(0x00008000)
-#define NS9750_ETH_SUPP_SPEED		(0x00000080)
-
-#define NS9750_ETH_TEST_TBACK		(0x00000004)
-#define NS9750_ETH_TEST_TPAUSE		(0x00000002)
-#define NS9750_ETH_TEST_SPQ		(0x00000001)
-
-#define NS9750_ETH_MCFG_RMIIM		(0x00008000)
-#define NS9750_ETH_MCFG_CLKS_MA		(0x0000001C)
-#define NS9750_ETH_MCFG_CLKS_4		(0x00000004)
-#define NS9750_ETH_MCFG_CLKS_6		(0x00000008)
-#define NS9750_ETH_MCFG_CLKS_8		(0x0000000C)
-#define NS9750_ETH_MCFG_CLKS_10		(0x00000010)
-#define NS9750_ETH_MCFG_CLKS_20		(0x00000014)
-#define NS9750_ETH_MCFG_CLKS_30		(0x00000018)
-#define NS9750_ETH_MCFG_CLKS_40		(0x0000001C)
-#define NS9750_ETH_MCFG_SPRE		(0x00000002)
-#define NS9750_ETH_MCFG_SCANI		(0x00000001)
-
-#define NS9750_ETH_MCMD_SCAN		(0x00000002)
-#define NS9750_ETH_MCMD_READ		(0x00000001)
-
-#define NS9750_ETH_MADR_DADR_MA		(0x00001F00)
-#define NS9750_ETH_MADR_RADR_MA		(0x0000001F)
-
-#define NS9750_ETH_MWTD_MA		(0x0000FFFF)
-
-#define NS9750_ETH_MRRD_MA		(0x0000FFFF)
+#define NS9750_ETH_ERSR_RXCE	 	(0x00008000)
+#define NS9750_ETH_ERSR_RXDV	 	(0x00004000)
+#define NS9750_ETH_ERSR_RXOK	 	(0x00002000)
+#define NS9750_ETH_ERSR_RXBR	 	(0x00001000)
+#define NS9750_ETH_ERSR_RXMC	 	(0x00000800)
+#define NS9750_ETH_ERSR_RXCRC	 	(0x00000400)
+#define NS9750_ETH_ERSR_RXDR	 	(0x00000200)
+#define NS9750_ETH_ERSR_RXCV	 	(0x00000100)
+#define NS9750_ETH_ERSR_RXSHT	 	(0x00000040)
+
+#define NS9750_ETH_MAC1_SRST	 	(0x00008000)
+#define NS9750_ETH_MAC1_SIMMRST	 	(0x00004000)
+#define NS9750_ETH_MAC1_RPEMCSR	 	(0x00000800)
+#define NS9750_ETH_MAC1_RPERFUN	 	(0x00000400)
+#define NS9750_ETH_MAC1_RPEMCST	 	(0x00000200)
+#define NS9750_ETH_MAC1_RPETFUN	 	(0x00000100)
+#define NS9750_ETH_MAC1_LOOPBK	 	(0x00000010)
+#define NS9750_ETH_MAC1_TXFLOW	 	(0x00000008)
+#define NS9750_ETH_MAC1_RXFLOW	 	(0x00000004)
+#define NS9750_ETH_MAC1_PALLRX	 	(0x00000002)
+#define NS9750_ETH_MAC1_RXEN	 	(0x00000001)
+
+#define NS9750_ETH_MAC2_EDEFER	 	(0x00004000)
+#define NS9750_ETH_MAC2_BACKP	 	(0x00002000)
+#define NS9750_ETH_MAC2_NOBO	 	(0x00001000)
+#define NS9750_ETH_MAC2_LONGP	 	(0x00000200)
+#define NS9750_ETH_MAC2_PUREP	 	(0x00000100)
+#define NS9750_ETH_MAC2_AUTOP	 	(0x00000080)
+#define NS9750_ETH_MAC2_VLANP	 	(0x00000040)
+#define NS9750_ETH_MAC2_PADEN  	 	(0x00000020)
+#define NS9750_ETH_MAC2_CRCEN	 	(0x00000010)
+#define NS9750_ETH_MAC2_DELCRC	 	(0x00000008)
+#define NS9750_ETH_MAC2_HUGE	 	(0x00000004)
+#define NS9750_ETH_MAC2_FLENC	 	(0x00000002)
+#define NS9750_ETH_MAC2_FULLD	 	(0x00000001)
+
+#define NS9750_ETH_IPGT_MA	 	(0x0000007F)
+
+#define NS9750_ETH_IPGR_IPGR1	 	(0x00007F00)
+#define NS9750_ETH_IPGR_IPGR2	 	(0x0000007F)
+
+#define NS9750_ETH_CLRT_CWIN	 	(0x00003F00)
+#define	NS9750_ETH_CLRT_RETX	 	(0x0000000F)
+
+#define NS9750_ETH_MAXF_MAXF	 	(0x0000FFFF)
+
+#define NS9750_ETH_SUPP_RPERMII	 	(0x00008000)
+#define NS9750_ETH_SUPP_SPEED  	 	(0x00000080)
+
+#define NS9750_ETH_TEST_TBACK	 	(0x00000004)
+#define NS9750_ETH_TEST_TPAUSE	 	(0x00000002)
+#define NS9750_ETH_TEST_SPQ	 	(0x00000001)
+
+#define NS9750_ETH_MCFG_RMIIM	 	(0x00008000)
+#define NS9750_ETH_MCFG_CLKS_MA	 	(0x0000001C)
+#define NS9750_ETH_MCFG_CLKS_4	 	(0x00000004)
+#define NS9750_ETH_MCFG_CLKS_6	 	(0x00000008)
+#define NS9750_ETH_MCFG_CLKS_8	 	(0x0000000C)
+#define NS9750_ETH_MCFG_CLKS_10	 	(0x00000010)
+#define NS9750_ETH_MCFG_CLKS_20	 	(0x00000014)
+#define NS9750_ETH_MCFG_CLKS_30	 	(0x00000018)
+#define NS9750_ETH_MCFG_CLKS_40	 	(0x0000001C)
+#define NS9750_ETH_MCFG_SPRE	 	(0x00000002)
+#define NS9750_ETH_MCFG_SCANI	 	(0x00000001)
+
+#define NS9750_ETH_MCMD_SCAN	 	(0x00000002)
+#define NS9750_ETH_MCMD_READ	 	(0x00000001)
+
+#define NS9750_ETH_MADR_DADR_MA	 	(0x00001F00)
+#define NS9750_ETH_MADR_RADR_MA	 	(0x0000001F)
+
+#define NS9750_ETH_MWTD_MA	 	(0x0000FFFF)
+
+#define NS9750_ETH_MRRD_MA	 	(0x0000FFFF)
 
 #define NS9750_ETH_MIND_MIILF		(0x00000008)
 #define NS9750_ETH_MIND_NVALID		(0x00000004)
-#define NS9750_ETH_MIND_SCAN		(0x00000002)
-#define NS9750_ETH_MIND_BUSY		(0x00000001)
+#define NS9750_ETH_MIND_SCAN	 	(0x00000002)
+#define NS9750_ETH_MIND_BUSY	 	(0x00000001)
 
-#define NS9750_ETH_SA1_OCTET1_MA	(0x0000FF00)
-#define NS9750_ETH_SA1_OCTET2_MA	(0x000000FF)
+#define NS9750_ETH_SA1_OCTET1_MA 	(0x0000FF00)
+#define NS9750_ETH_SA1_OCTET2_MA 	(0x000000FF)
 
-#define NS9750_ETH_SA2_OCTET3_MA	(0x0000FF00)
-#define NS9750_ETH_SA2_OCTET4_MA	(0x000000FF)
+#define NS9750_ETH_SA2_OCTET3_MA 	(0x0000FF00)
+#define NS9750_ETH_SA2_OCTET4_MA 	(0x000000FF)
 
-#define NS9750_ETH_SA3_OCTET5_MA	(0x0000FF00)
-#define NS9750_ETH_SA3_OCTET6_MA	(0x000000FF)
+#define NS9750_ETH_SA3_OCTET5_MA 	(0x0000FF00)
+#define NS9750_ETH_SA3_OCTET6_MA 	(0x000000FF)
 
-#define NS9750_ETH_SAFR_PRO		(0x00000008)
-#define NS9750_ETH_SAFR_PRM		(0x00000004)
-#define NS9750_ETH_SAFR_PRA		(0x00000002)
-#define NS9750_ETH_SAFR_BROAD		(0x00000001)
+#define NS9750_ETH_SAFR_PRO	 	(0x00000008)
+#define NS9750_ETH_SAFR_PRM	 	(0x00000004)
+#define NS9750_ETH_SAFR_PRA	 	(0x00000002)
+#define NS9750_ETH_SAFR_BROAD	 	(0x00000001)
 
-#define NS9750_ETH_HT1_MA		(0x0000FFFF)
+#define NS9750_ETH_HT1_MA	 	(0x0000FFFF)
 
-#define NS9750_ETH_HT2_MA		(0x0000FFFF)
+#define NS9750_ETH_HT2_MA	 	(0x0000FFFF)
 
 /* also valid for EINTREN */
 #define NS9750_ETH_EINTR_RXOVL_DATA	(0x02000000)
@@ -255,7 +290,7 @@
 #define NS9750_ETH_EINTR_TXBUFC		(0x00000010)
 #define NS9750_ETH_EINTR_TXBUFNR	(0x00000008)
 #define NS9750_ETH_EINTR_TXDONE		(0x00000004)
-#define NS9750_ETH_EINTR_TXERR		(0x00000002)
+#define NS9750_ETH_EINTR_TXERR 		(0x00000002)
 #define NS9750_ETH_EINTR_TXIDLE		(0x00000001)
 #define NS9750_ETH_EINTR_RX_MA	\
 	(NS9750_ETH_EINTR_RXOVL_DATA | \
@@ -290,9 +325,7 @@
 #define NS9750_ETH_RXFREE_A		(0x00000001)
 
 #ifndef NS9750_ETH_PHY_ADDRESS
-# define NS9750_ETH_PHY_ADDRESS		(0x0001) /* suitable for UNC20 */
+# define NS9750_ETH_PHY_ADDRESS	 	(0x0001) /* suitable for UNC20 */
 #endif /* NETARM_ETH_PHY_ADDRESS */
 
-#endif /* CONFIG_DRIVER_NS9750_ETHERNET */
-
 #endif /* FS_NS9750_ETH_H */
diff --git a/include/ns9750_eth_orig.h b/include/ns9750_eth_orig.h
new file mode 100644
index 0000000..1b35cc5
--- /dev/null
+++ b/include/ns9750_eth_orig.h
@@ -0,0 +1,331 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2004 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ *
+ * $Id: ns9750_eth.h,v 1.3 2005/01/12 13:05:26 jjaeger Exp $
+ * @Author: Markus Pietrek
+ * @References: [1] NS9750 Hardware Reference, December 2003
+ *              [2] Intel LXT971 Datasheet #249414 Rev. 02
+ *              [3] NS7520 Linux Ethernet Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *  
+ ***********************************************************************/
+
+#ifndef FS_NS9750_ETH_H
+#define FS_NS9750_ETH_H
+
+#ifdef CONFIG_NS9750ACCORD
+# include "rtl8201.h"
+#elif defined (CONFIG_CC9C) || defined(CONFIG_CCW9C) || defined(CONFIG_CC9P9215) \
+	|| defined(CONFIG_CCW9P9215) || defined(CONFIG_CME9210) \
+	|| defined(CONFIG_CC9P9210)
+# define CONFIG_PHY_ICS1893	1
+# include "ics1893bk.h"
+#elif defined (CONFIG_INC20OTTER)
+# define CONFIG_PHY_HIRSCHMANN	1
+# include "phyhirschmann.h"
+#else
+# include "lxt971a.h"
+#endif
+
+typedef enum
+{
+	PHY_NONE    = 0xFFFF, /* no PHY detected yet */
+	PHY_ICS1893BK = 0x0015,
+	PHY_LXT971A = 0x0013,
+	PHY_RTL8201 = 0x0000,
+	PHY_HIRSCHMANN = 0x0007,
+} PhyType;
+
+#define PHY_MDIO_ASS_CLK (2500000) /* assured clock speed */
+
+#define	NS9750_ETH_MODULE_BASE	 	(0xA0600000)
+
+#define get_eth_reg_addr(c) \
+     ((volatile unsigned int*) ( NS9750_ETH_MODULE_BASE+(unsigned int) (c)))
+
+#define NS9750_ETH_EGCR1	 	(0x0000)
+#define NS9750_ETH_EGCR2	 	(0x0004)
+#define NS9750_ETH_EGSR		 	(0x0008)
+#define NS9750_ETH_FIFORX	 	(0x000C)
+#define NS9750_ETH_FIFOTX	 	(0x0010)
+#define NS9750_ETH_FIFOTXS	 	(0x0014)
+#define NS9750_ETH_ETSR		 	(0x0018)
+#define NS9750_ETH_ERSR		 	(0x001C)
+#define NS9750_ETH_MAC1			(0x0400)
+#define NS9750_ETH_MAC2			(0x0404)
+#define NS9750_ETH_IPGT			(0x0408)
+#define NS9750_ETH_IPGR			(0x040C)
+#define NS9750_ETH_CLRT			(0x0410)
+#define NS9750_ETH_MAXF			(0x0414)
+#define NS9750_ETH_SUPP			(0x0418)
+#define NS9750_ETH_TEST			(0x041C)
+#define NS9750_ETH_MCFG			(0x0420)
+#define NS9750_ETH_MCMD			(0x0424)
+#define NS9750_ETH_MADR			(0x0428)
+#define NS9750_ETH_MWTD			(0x042C)
+#define NS9750_ETH_MRDD			(0x0430)
+#define NS9750_ETH_MIND			(0x0434)
+#define NS9750_ETH_SA1			(0x0440)
+#define NS9750_ETH_SA2			(0x0444)
+#define NS9750_ETH_SA3			(0x0448)
+#define NS9750_ETH_SAFR			(0x0500)
+#define NS9750_ETH_HT1		 	(0x0504)
+#define NS9750_ETH_HT2		 	(0x0508)
+#define NS9750_ETH_STAT_BASE	 	(0x0680)
+#define NS9750_ETH_RXAPTR		(0x0A00)
+#define NS9750_ETH_RXBPTR		(0x0A04)
+#define NS9750_ETH_RXCPTR		(0x0A08)
+#define NS9750_ETH_RXDPTR		(0x0A0C)
+#define NS9750_ETH_EINTR		(0x0A10)
+#define NS9750_ETH_EINTREN		(0x0A14)
+#define NS9750_ETH_TXPTR		(0x0A18)
+#define NS9750_ETH_TXRPTR		(0x0A1C)
+#define NS9750_ETH_TXERBD		(0x0A20)
+#define NS9750_ETH_TXSPTR		(0x0A24)
+#define NS9750_ETH_RXAOFF		(0x0A28)
+#define NS9750_ETH_RXBOFF		(0x0A2C)
+#define NS9750_ETH_RXCOFF		(0x0A30)
+#define NS9750_ETH_RXDOFF		(0x0A34)
+#define NS9750_ETH_TXOFF		(0x0A38)
+#define NS9750_ETH_RXFREE		(0x0A3C)
+#define NS9750_ETH_TXBD			(0x1000)
+#define NS9750_ETH_TXBD1		(0x1010)
+#define NS9750_ETH_TXBD2		(0x1020)
+
+/* register bit fields */
+
+#define NS9750_ETH_EGCR1_ERX	 	(0x80000000)
+#define NS9750_ETH_EGCR1_ERXDMA	 	(0x40000000)
+#define NS9750_ETH_EGCR1_ERXSHT	 	(0x10000000)
+#define NS9750_ETH_EGCR1_ERXSIZ	 	(0x08000000)
+#define NS9750_ETH_EGCR1_ETXSIZ	 	(0x04000000)
+#define NS9750_ETH_EGCR1_ETXDIAG	(0x02000000)
+#define NS9750_ETH_EGCR1_ERXBAD	 	(0x01000000)
+#define NS9750_ETH_EGCR1_ETX	 	(0x00800000)
+#define NS9750_ETH_EGCR1_ETXDMA	 	(0x00400000)
+#define NS9750_ETH_EGCR1_ETXWM	  	(0x00200000)
+#define NS9750_ETH_EGCR1_ERXADV	 	(0x00100000)
+#define NS9750_ETH_EGCR1_ERXINIT	(0x00080000)
+#define NS9750_ETH_EGCR1_PHY_MODE_MA  	(0x0000C000)
+#define NS9750_ETH_EGCR1_PHY_MODE_MII 	(0x00000000)
+#define NS9750_ETH_EGCR1_PHY_MODE_RMII 	(0x00004000)
+#define NS9750_ETH_EGCR1_RXCINV	 	(0x00001000)
+#define NS9750_ETH_EGCR1_TXCINV	 	(0x00000800)
+#define NS9750_ETH_EGCR1_RXALIGN	(0x00000400)
+#define NS9750_ETH_EGCR1_MAC_HRST 	(0x00000200)
+#define NS9750_ETH_EGCR1_ITXA	 	(0x00000100)
+
+#define NS9750_ETH_EGCR2_TPTV_MA	(0xFFFF0000)
+#define NS9750_ETH_EGCR2_TPCF		(0x00000040)
+#define NS9750_ETH_EGCR2_THPDF		(0x00000020)
+#ifndef CONFIG_NS921X
+# define NS9750_ETH_EGCR2_TCLER		(0x00000008)
+# define NS9750_ETH_EGCR2_TKICK		(0x00000000)
+#else
+# define NS9750_ETH_EGCR2_TCLER		(0x00000080)
+# define NS9750_ETH_EGCR2_TKICK		(0x00000008)
+#endif
+#define NS9750_ETH_EGCR2_AUTOZ		(0x00000004)
+#define NS9750_ETH_EGCR2_CLRCNT		(0x00000002)
+#define NS9750_ETH_EGCR2_STEN		(0x00000001)
+
+#define NS9750_ETH_EGSR_RXINIT	 	(0x00100000)
+#define NS9750_ETH_EGSR_TXFIFONF 	(0x00080000)
+#define NS9750_ETH_EGSR_TXFIFOH	 	(0x00040000)
+#define NS9750_ETH_EGSR_TXFIFOE	 	(0x00010000)
+
+#define NS9750_ETH_FIFOTXS_ALL		(0x00000055)
+#define NS9750_ETH_FIFOTXS_3		(0x000000d5)
+#define NS9750_ETH_FIFOTXS_2		(0x00000035)
+#define NS9750_ETH_FIFOTXS_1		(0x0000000D)
+#define NS9750_ETH_FIFOTXS_0		(0x00000003)
+
+#define NS9750_ETH_ETSR_TXOK	 	(0x00008000)
+#define NS9750_ETH_ETSR_TXBR	 	(0x00004000)
+#define NS9750_ETH_ETSR_TXMC	 	(0x00002000)
+#define NS9750_ETH_ETSR_TXAL	 	(0x00001000)
+#define NS9750_ETH_ETSR_TXAED	 	(0x00000800)
+#define NS9750_ETH_ETSR_TXAEC	 	(0x00000400)
+#define NS9750_ETH_ETSR_TXAUR	 	(0x00000200)
+#define NS9750_ETH_ETSR_TXAJ	 	(0x00000100)
+#define NS9750_ETH_ETSR_TXDEF	 	(0x00000040)
+#define NS9750_ETH_ETSR_TXCRC	 	(0x00000020)
+#define NS9750_ETH_ETSR_TXCOLC   	(0x0000000F)
+#define NS9750_ETH_ETSR_ERROR_MA	( NS9750_ETH_ETSR_TXAL  | \
+                                          NS9750_ETH_ETSR_TXAED | \
+                                          NS9750_ETH_ETSR_TXAEC | \
+                                          NS9750_ETH_ETSR_TXAUR | \
+                                          NS9750_ETH_ETSR_TXAJ  | \
+                                          NS9750_ETH_ETSR_TXDEF | \
+                                          NS9750_ETH_ETSR_TXCRC )
+
+#define NS9750_ETH_ERSR_RXSIZE_MA	(0x0FFF0000)
+#define NS9750_ETH_ERSR_RXCE	 	(0x00008000)
+#define NS9750_ETH_ERSR_RXDV	 	(0x00004000)
+#define NS9750_ETH_ERSR_RXOK	 	(0x00002000)
+#define NS9750_ETH_ERSR_RXBR	 	(0x00001000)
+#define NS9750_ETH_ERSR_RXMC	 	(0x00000800)
+#define NS9750_ETH_ERSR_RXCRC	 	(0x00000400)
+#define NS9750_ETH_ERSR_RXDR	 	(0x00000200)
+#define NS9750_ETH_ERSR_RXCV	 	(0x00000100)
+#define NS9750_ETH_ERSR_RXSHT	 	(0x00000040)
+
+#define NS9750_ETH_MAC1_SRST	 	(0x00008000)
+#define NS9750_ETH_MAC1_SIMMRST	 	(0x00004000)
+#define NS9750_ETH_MAC1_RPEMCSR	 	(0x00000800)
+#define NS9750_ETH_MAC1_RPERFUN	 	(0x00000400)
+#define NS9750_ETH_MAC1_RPEMCST	 	(0x00000200)
+#define NS9750_ETH_MAC1_RPETFUN	 	(0x00000100)
+#define NS9750_ETH_MAC1_LOOPBK	 	(0x00000010)
+#define NS9750_ETH_MAC1_TXFLOW	 	(0x00000008)
+#define NS9750_ETH_MAC1_RXFLOW	 	(0x00000004)
+#define NS9750_ETH_MAC1_PALLRX	 	(0x00000002)
+#define NS9750_ETH_MAC1_RXEN	 	(0x00000001)
+
+#define NS9750_ETH_MAC2_EDEFER	 	(0x00004000)
+#define NS9750_ETH_MAC2_BACKP	 	(0x00002000)
+#define NS9750_ETH_MAC2_NOBO	 	(0x00001000)
+#define NS9750_ETH_MAC2_LONGP	 	(0x00000200)
+#define NS9750_ETH_MAC2_PUREP	 	(0x00000100)
+#define NS9750_ETH_MAC2_AUTOP	 	(0x00000080)
+#define NS9750_ETH_MAC2_VLANP	 	(0x00000040)
+#define NS9750_ETH_MAC2_PADEN  	 	(0x00000020)
+#define NS9750_ETH_MAC2_CRCEN	 	(0x00000010)
+#define NS9750_ETH_MAC2_DELCRC	 	(0x00000008)
+#define NS9750_ETH_MAC2_HUGE	 	(0x00000004)
+#define NS9750_ETH_MAC2_FLENC	 	(0x00000002)
+#define NS9750_ETH_MAC2_FULLD	 	(0x00000001)
+
+#define NS9750_ETH_IPGT_MA	 	(0x0000007F)
+
+#define NS9750_ETH_IPGR_IPGR1	 	(0x00007F00)
+#define NS9750_ETH_IPGR_IPGR2	 	(0x0000007F)
+
+#define NS9750_ETH_CLRT_CWIN	 	(0x00003F00)
+#define	NS9750_ETH_CLRT_RETX	 	(0x0000000F)
+
+#define NS9750_ETH_MAXF_MAXF	 	(0x0000FFFF)
+
+#define NS9750_ETH_SUPP_RPERMII	 	(0x00008000)
+#define NS9750_ETH_SUPP_SPEED  	 	(0x00000080)
+
+#define NS9750_ETH_TEST_TBACK	 	(0x00000004)
+#define NS9750_ETH_TEST_TPAUSE	 	(0x00000002)
+#define NS9750_ETH_TEST_SPQ	 	(0x00000001)
+
+#define NS9750_ETH_MCFG_RMIIM	 	(0x00008000)
+#define NS9750_ETH_MCFG_CLKS_MA	 	(0x0000001C)
+#define NS9750_ETH_MCFG_CLKS_4	 	(0x00000004)
+#define NS9750_ETH_MCFG_CLKS_6	 	(0x00000008)
+#define NS9750_ETH_MCFG_CLKS_8	 	(0x0000000C)
+#define NS9750_ETH_MCFG_CLKS_10	 	(0x00000010)
+#define NS9750_ETH_MCFG_CLKS_20	 	(0x00000014)
+#define NS9750_ETH_MCFG_CLKS_30	 	(0x00000018)
+#define NS9750_ETH_MCFG_CLKS_40	 	(0x0000001C)
+#define NS9750_ETH_MCFG_SPRE	 	(0x00000002)
+#define NS9750_ETH_MCFG_SCANI	 	(0x00000001)
+
+#define NS9750_ETH_MCMD_SCAN	 	(0x00000002)
+#define NS9750_ETH_MCMD_READ	 	(0x00000001)
+
+#define NS9750_ETH_MADR_DADR_MA	 	(0x00001F00)
+#define NS9750_ETH_MADR_RADR_MA	 	(0x0000001F)
+
+#define NS9750_ETH_MWTD_MA	 	(0x0000FFFF)
+
+#define NS9750_ETH_MRRD_MA	 	(0x0000FFFF)
+
+#define NS9750_ETH_MIND_MIILF		(0x00000008)
+#define NS9750_ETH_MIND_NVALID		(0x00000004)
+#define NS9750_ETH_MIND_SCAN	 	(0x00000002)
+#define NS9750_ETH_MIND_BUSY	 	(0x00000001)
+
+#define NS9750_ETH_SA1_OCTET1_MA 	(0x0000FF00)
+#define NS9750_ETH_SA1_OCTET2_MA 	(0x000000FF)
+
+#define NS9750_ETH_SA2_OCTET3_MA 	(0x0000FF00)
+#define NS9750_ETH_SA2_OCTET4_MA 	(0x000000FF)
+
+#define NS9750_ETH_SA3_OCTET5_MA 	(0x0000FF00)
+#define NS9750_ETH_SA3_OCTET6_MA 	(0x000000FF)
+
+#define NS9750_ETH_SAFR_PRO	 	(0x00000008)
+#define NS9750_ETH_SAFR_PRM	 	(0x00000004)
+#define NS9750_ETH_SAFR_PRA	 	(0x00000002)
+#define NS9750_ETH_SAFR_BROAD	 	(0x00000001)
+
+#define NS9750_ETH_HT1_MA	 	(0x0000FFFF)
+
+#define NS9750_ETH_HT2_MA	 	(0x0000FFFF)
+
+/* also valid for EINTREN */
+#define NS9750_ETH_EINTR_RXOVL_DATA	(0x02000000)
+#define NS9750_ETH_EINTR_RXOVL_STAT	(0x01000000)
+#define NS9750_ETH_EINTR_RXBUFC		(0x00800000)
+#define NS9750_ETH_EINTR_RXDONEA	(0x00400000)
+#define NS9750_ETH_EINTR_RXDONEB	(0x00200000)
+#define NS9750_ETH_EINTR_RXDONEC	(0x00100000)
+#define NS9750_ETH_EINTR_RXDONED	(0x00080000)
+#define NS9750_ETH_EINTR_RXNOBUF	(0x00040000)
+#define NS9750_ETH_EINTR_RXBUFFUL	(0x00020000)
+#define NS9750_ETH_EINTR_RXBR		(0x00010000)
+#define NS9750_ETH_EINTR_STOVFL		(0x00000040)
+#define NS9750_ETH_EINTR_TXPAUSE	(0x00000020)
+#define NS9750_ETH_EINTR_TXBUFC		(0x00000010)
+#define NS9750_ETH_EINTR_TXBUFNR	(0x00000008)
+#define NS9750_ETH_EINTR_TXDONE		(0x00000004)
+#define NS9750_ETH_EINTR_TXERR 		(0x00000002)
+#define NS9750_ETH_EINTR_TXIDLE		(0x00000001)
+#define NS9750_ETH_EINTR_RX_MA	\
+	(NS9750_ETH_EINTR_RXOVL_DATA | \
+	 NS9750_ETH_EINTR_RXOVL_STAT | \
+	 NS9750_ETH_EINTR_RXBUFC | \
+	 NS9750_ETH_EINTR_RXDONEA | \
+	 NS9750_ETH_EINTR_RXDONEB | \
+	 NS9750_ETH_EINTR_RXDONEC | \
+	 NS9750_ETH_EINTR_RXDONED | \
+	 NS9750_ETH_EINTR_RXNOBUF | \
+	 NS9750_ETH_EINTR_RXBUFFUL | \
+	 NS9750_ETH_EINTR_RXBR )
+#define NS9750_ETH_EINTR_TX_MA	\
+	(NS9750_ETH_EINTR_TXPAUSE | \
+	 NS9750_ETH_EINTR_TXBUFC | \
+	 NS9750_ETH_EINTR_TXBUFNR | \
+	 NS9750_ETH_EINTR_TXDONE | \
+	 NS9750_ETH_EINTR_TXERR | \
+	 NS9750_ETH_EINTR_TXIDLE)
+
+/* for TXPTR, TXRPTR, TXERBD and TXSPTR */
+#define NS9750_ETH_TXPTR_MA		(0x000000FF)
+
+/* for RXAOFF, RXBOFF, RXCOFF and RXDOFF */
+#define NS9750_ETH_RXOFF_MA		(0x000007FF)
+
+#define NS9750_ETH_TXOFF_MA		(0x000003FF)
+
+#define NS9750_ETH_RXFREE_D		(0x00000008)
+#define NS9750_ETH_RXFREE_C		(0x00000004)
+#define NS9750_ETH_RXFREE_B		(0x00000002)
+#define NS9750_ETH_RXFREE_A		(0x00000001)
+
+#ifndef NS9750_ETH_PHY_ADDRESS
+# define NS9750_ETH_PHY_ADDRESS	 	(0x0001) /* suitable for UNC20 */
+#endif /* NETARM_ETH_PHY_ADDRESS */
+
+#endif /* FS_NS9750_ETH_H */
diff --git a/include/ns9750_i2c.h b/include/ns9750_i2c.h
new file mode 100644
index 0000000..4de93dc
--- /dev/null
+++ b/include/ns9750_i2c.h
@@ -0,0 +1,98 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2004 by FS Forth-Systeme GmbH.
+ * All rights reserved.
+ *
+ * $Id: ns9750_i2c.h,v 1.2 2007-07-05 14:18:01 mpietrek Exp $
+ * @Author: Markus Pietrek
+ * @References: [1] NS9750 Hardware Reference, March 2004, Chap. 11
+ * 		[2] Derives from linux/include/arch/arm/ns9750_i2c.h
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *  
+ ***********************************************************************/
+
+#ifndef FS_NS9750_I2C_H
+#define FS_NS9750_I2C_H
+
+#ifdef CONFIG_NS921X
+# define	NS_I2C_MODULE_BASE 	(0x90050000) /* physical address */
+#else
+# define	NS_I2C_MODULE_BASE 	(0x90500000) /* physical address */
+#endif
+
+#define get_i2c_reg_addr(c) \
+     ((volatile unsigned int*) ( NS_I2C_MODULE_BASE+(unsigned int) (c)))
+
+#define NS_I2C_DATA_TX			(0x00)
+#define NS_I2C_DATA_RX			(0x00)
+#define NS_I2C_MASTER			(0x04)
+#define NS_I2C_SLAVE			(0x08)
+#define NS_I2C_CFG			(0x0C)
+
+/* register bit fields */
+
+#define NS_I2C_DATA_TX_PIPE		(0x8000)
+#define NS_I2C_DATA_TX_DLEN		(0x4000)
+#define NS_I2C_DATA_TX_VAL		(0x2000)
+#define NS_I2C_DATA_TX_CMD_MA		(0x1F00)
+#define NS_I2C_DATA_TX_CMD_M_NOP	(0x0000)
+#define NS_I2C_DATA_TX_CMD_M_READ	(0x0400)
+#define NS_I2C_DATA_TX_CMD_M_WRITE	(0x0500)
+#define NS_I2C_DATA_TX_CMD_M_STOP	(0x0600)
+#define NS_I2C_DATA_TX_CMD_S_NOP	(0x1000)
+#define NS_I2C_DATA_TX_CMD_S_STOP	(0x1600)
+#define NS_I2C_DATA_TX_DATA_MA		(0x00FF)
+#define NS_I2C_DATA_TX_CMD_SH		(0x08) /* shift value for CMD_MA */
+
+#define NS_I2C_DATA_RX_BSTS		(0x8000)
+#define NS_I2C_DATA_RX_RDE		(0x4000)
+#define NS_I2C_DATA_RX_SCMDL		(0x2000)
+#define NS_I2C_DATA_RX_MCMDL		(0x1000)
+#define NS_I2C_DATA_RX_IRQCD_MA		(0x0F00)
+#define NS_I2C_DATA_RX_IRQCD_NO_IRQ   	(0x0000) /* no single bit fields */
+#define NS_I2C_DATA_RX_IRQCD_M_ARBIT	(0x0100)
+#define NS_I2C_DATA_RX_IRQCD_M_NO_ACK	(0x0200)
+#define NS_I2C_DATA_RX_IRQCD_M_TX_DATA	(0x0300)
+#define NS_I2C_DATA_RX_IRQCD_M_RX_DATA	(0x0400)
+#define NS_I2C_DATA_RX_IRQCD_M_CMD_ACK	(0x0500)
+#define NS_I2C_DATA_RX_IRQCD_S_RX_ABORT	(0x0800)
+#define NS_I2C_DATA_RX_IRQCD_S_CMD_REQ	(0x0900)
+#define NS_I2C_DATA_RX_IRQCD_S_NO_ACK	(0x0A00)
+#define NS_I2C_DATA_RX_IRQCD_S_TX_DATA1	(0x0B00)
+#define NS_I2C_DATA_RX_IRQCD_S_RX_DATA1	(0x0C00)
+#define NS_I2C_DATA_RX_IRQCD_S_TX_DATA	(0x0D00)
+#define NS_I2C_DATA_RX_IRQCD_S_RX_DATA	(0x0E00)
+#define NS_I2C_DATA_RX_IRQCD_S_CGA  	(0x0F00)
+#define NS_I2C_DATA_RX_DATA_MA		(0x00FF)
+
+#define NS_I2C_MASTER_MDA_MA		(0x07FE)
+#define NS_I2C_MASTER_MAM		(0x0001)
+#define NS_I2C_MASTER_MDA_SH		(0x01)
+
+#define NS_I2C_SLAVE_GCA		(0x0800)
+#define NS_I2C_SLAVE_SDA_MA		(0x07FE)
+#define NS_I2C_SLAVE_SAM		(0x0001)
+#define NS_I2C_SLAVE_SDA_SH		(0x01)
+
+#define NS_I2C_CFG_IRQD			(0x8000)
+#define NS_I2C_CFG_TMDE			(0x4000)
+#define NS_I2C_CFG_VSCD			(0x2000)
+#define NS_I2C_CFG_SFW_MA		(0x1E00)
+#define NS_I2C_CFG_CLREF_MA		(0x01FF)
+#define NS_I2C_CFG_SFW_SH		(0x09)
+
+#endif /* FS_NS950_I2C_H */
diff --git a/include/nvram_types.h b/include/nvram_types.h
new file mode 100644
index 0000000..38600de
--- /dev/null
+++ b/include/nvram_types.h
@@ -0,0 +1,116 @@
+/*
+ *  nvram/lib/include/nvram_types.h
+ *
+ *  Copyright (C) 2006 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+ */
+/*
+ *  !Revision:   $Revision$
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Defines standard types
+ */
+
+#ifndef NVRAM_TYPES_H
+#define NVRAM_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(LINUX)
+# include <string.h>            /* memset */
+# include <stdio.h>             /* snprintf */
+# include <stdint.h>            /* uint8 */
+# include <unistd.h>            /* size_t */
+# include <assert.h>            /* assert */
+# include <sys/types.h>         /* loff_t */
+# include <mtd/mtd-abi.h>       /* MTD_NORFLASH */
+/* digilib_ */
+# include <crc32.h>             /* crc32 */
+
+# define ARRAY_SIZE( x ) (sizeof(x)/sizeof(*(x)))
+# define ASSERT( expr ) assert( expr )
+# define PRINTF_QUAD "ll"
+# define CMD_NAME "nvram"
+# ifdef S_SPLINT_S
+/* splint checks for posixlibs, so we need to add some linux stuff */
+typedef uint64_t loff_t;
+extern /*@null@*/ /*@only@*/ char *strdup (char *s) /*@*/ ;
+# endif  /* S_SPLINT_S */
+
+# define strnicmp(a,b,c)	strncasecmp(a,b,c)
+# define memcpy32(a,b,c)	memcpy(a,b,c)
+
+#elif defined(UBOOT)
+# include <common.h>            /* panic */
+# include <linux/types.h>       /* loff_t */
+# include <linux/mtd/mtd-abi.h> /* MTD_NORFLASH */
+# include <malloc.h>            /* malloc */
+
+# include "../common/digi/vscanf.h"            /* vscanf/scanf */
+# include "../common/digi/atoi.h"              /* atoi */
+# define PRINTF_QUAD "q"
+# define CMD_NAME "intnvram"
+# define ASSERT( expr ) \
+        do { \
+                if( !(expr) )                                           \
+                        printf( "**** ASSERT %s@%s:%s", __FILE__, __LINE__, #expr ); \
+        } while( 0 )
+
+/* eprintf may fail in early steps before EEPROM is initialized, therefor printf*/
+
+typedef ulong crc32_t;
+#elif defined(WINCE)
+# include <windows.h> /**/
+# include <oal.h>	 /* OAL macros */
+#ifdef MX51
+# include <mx51_iomux.h> /* GPIO settings */
+# include <mx51_ddk.h> /* clock settings */
+#endif
+# include <args.h>	 /* BSP_ARGS */
+# include <crc32.h>  /* crc32 */
+/* defines */
+# define ARRAY_SIZE( x ) (sizeof(x)/sizeof(*(x)))
+# define PRINTF_QUAD "ll"
+# define CMD_NAME "nvram"
+# define memcpy32(a,b,c)	memcpy(a,b,c)
+/* MTD Flash device information */
+#define MTD_NORFLASH            3
+#define MTD_NANDFLASH           4
+/* typedefs */
+typedef unsigned long crc32_t;
+typedef UINT64 uint64_t;
+typedef INT64  int64_t;
+typedef UINT32 uint32_t;
+typedef INT32  int32_t;
+typedef UINT16 uint16_t;
+typedef INT16  int16_t;
+typedef UINT8  uint8_t;
+typedef INT8   int8_t;
+typedef uint64_t loff_t;
+#else
+# error "operating system not defined"
+#endif  /* LINUX */
+
+/* we want it identical for all os */
+#define CLEAR( x ) 		memset( &x, 0, sizeof( x ) )
+
+typedef unsigned char uchar_t;
+typedef char          char_t;
+
+#ifdef __GNUC__
+# define IDX(x) [x] =
+#else
+        /* e.g. Windows */
+# define IDX(x)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* NVRAM_TYPES_H */
diff --git a/include/serial.h b/include/serial.h
index 15ab73c..8d239ed 100644
--- a/include/serial.h
+++ b/include/serial.h
@@ -15,6 +15,7 @@ struct serial_device {
 	int (*tstc) (void);
 	void (*putc) (const char c);
 	void (*puts) (const char *s);
+        void (*tx_flush) (void);
 
 	struct serial_device *next;
 };
diff --git a/include/spi.h b/include/spi.h
index 320e50e..03dc5bc 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -24,103 +24,17 @@
 #ifndef _SPI_H_
 #define _SPI_H_
 
-/* Controller-specific definitions: */
-
-/* CONFIG_HARD_SPI triggers SPI bus initialization in PowerPC */
-#ifdef CONFIG_MPC8XXX_SPI
-# ifndef CONFIG_HARD_SPI
-#  define CONFIG_HARD_SPI
-# endif
-#endif
-
-/* SPI mode flags */
-#define	SPI_CPHA	0x01			/* clock phase */
-#define	SPI_CPOL	0x02			/* clock polarity */
-#define	SPI_MODE_0	(0|0)			/* (original MicroWire) */
-#define	SPI_MODE_1	(0|SPI_CPHA)
-#define	SPI_MODE_2	(SPI_CPOL|0)
-#define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
-#define	SPI_CS_HIGH	0x04			/* CS active high */
-#define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
-#define	SPI_3WIRE	0x10			/* SI/SO signals shared */
-#define	SPI_LOOP	0x20			/* loopback mode */
-
-/* SPI transfer flags */
-#define SPI_XFER_BEGIN	0x01			/* Assert CS before transfer */
-#define SPI_XFER_END	0x02			/* Deassert CS after transfer */
-
-/*-----------------------------------------------------------------------
- * Representation of a SPI slave, i.e. what we're communicating with.
- *
- * Drivers are expected to extend this with controller-specific data.
- *
- *   bus:	ID of the bus that the slave is attached to.
- *   cs:	ID of the chip select connected to the slave.
+/*
+ * The function call pointer type used to drive the chip select.
  */
-struct spi_slave {
-	unsigned int	bus;
-	unsigned int	cs;
-};
+typedef void (*spi_chipsel_type)(int cs);
+
 
 /*-----------------------------------------------------------------------
  * Initialization, must be called once on start up.
- *
- * TODO: I don't think we really need this.
  */
 void spi_init(void);
 
-/*-----------------------------------------------------------------------
- * Set up communications parameters for a SPI slave.
- *
- * This must be called once for each slave. Note that this function
- * usually doesn't touch any actual hardware, it only initializes the
- * contents of spi_slave so that the hardware can be easily
- * initialized later.
- *
- *   bus:     Bus ID of the slave chip.
- *   cs:      Chip select ID of the slave chip on the specified bus.
- *   max_hz:  Maximum SCK rate in Hz.
- *   mode:    Clock polarity, clock phase and other parameters.
- *
- * Returns: A spi_slave reference that can be used in subsequent SPI
- * calls, or NULL if one or more of the parameters are not supported.
- */
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int mode);
-
-/*-----------------------------------------------------------------------
- * Free any memory associated with a SPI slave.
- *
- *   slave:	The SPI slave
- */
-void spi_free_slave(struct spi_slave *slave);
-
-/*-----------------------------------------------------------------------
- * Claim the bus and prepare it for communication with a given slave.
- *
- * This must be called before doing any transfers with a SPI slave. It
- * will enable and initialize any SPI hardware as necessary, and make
- * sure that the SCK line is in the correct idle state. It is not
- * allowed to claim the same bus for several slaves without releasing
- * the bus in between.
- *
- *   slave:	The SPI slave
- *
- * Returns: 0 if the bus was claimed successfully, or a negative value
- * if it wasn't.
- */
-int spi_claim_bus(struct spi_slave *slave);
-
-/*-----------------------------------------------------------------------
- * Release the SPI bus
- *
- * This must be called once for every call to spi_claim_bus() after
- * all transfers have finished. It may disable any SPI hardware as
- * appropriate.
- *
- *   slave:	The SPI slave
- */
-void spi_release_bus(struct spi_slave *slave);
 
 /*-----------------------------------------------------------------------
  * SPI transfer
@@ -134,67 +48,26 @@ void spi_release_bus(struct spi_slave *slave);
  * input data overwrites the output data (since both are buffered by
  * temporary variables, this is OK).
  *
- * spi_xfer() interface:
- *   slave:	The SPI slave which will be sending/receiving the data.
- *   bitlen:	How many bits to write and read.
- *   dout:	Pointer to a string of bits to send out.  The bits are
- *		held in a byte array and are sent MSB first.
- *   din:	Pointer to a string of bits that will be filled in.
- *   flags:	A bitwise combination of SPI_XFER_* flags.
- *
- *   Returns: 0 on success, not 0 on failure
- */
-int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
-		void *din, unsigned long flags);
-
-/*-----------------------------------------------------------------------
- * Determine if a SPI chipselect is valid.
- * This function is provided by the board if the low-level SPI driver
- * needs it to determine if a given chipselect is actually valid.
+ * If the chipsel() function is not NULL, it is called with a parameter
+ * of '1' (chip select active) at the start of the transfer and again with
+ * a parameter of '0' at the end of the transfer.
  *
- * Returns: 1 if bus:cs identifies a valid chip on this board, 0
- * otherwise.
- */
-int  spi_cs_is_valid(unsigned int bus, unsigned int cs);
-
-/*-----------------------------------------------------------------------
- * Activate a SPI chipselect.
- * This function is provided by the board code when using a driver
- * that can't control its chipselects automatically (e.g.
- * common/soft_spi.c). When called, it should activate the chip select
- * to the device identified by "slave".
- */
-void spi_cs_activate(struct spi_slave *slave);
-
-/*-----------------------------------------------------------------------
- * Deactivate a SPI chipselect.
- * This function is provided by the board code when using a driver
- * that can't control its chipselects automatically (e.g.
- * common/soft_spi.c). When called, it should deactivate the chip
- * select to the device identified by "slave".
- */
-void spi_cs_deactivate(struct spi_slave *slave);
-
-/*-----------------------------------------------------------------------
- * Write 8 bits, then read 8 bits.
- *   slave:	The SPI slave we're communicating with
- *   byte:	Byte to be written
+ * If the chipsel() function _is_ NULL, it the responsibility of the
+ * caller to make the appropriate chip select active before calling
+ * spi_xfer() and making it inactive after spi_xfer() returns.
  *
- * Returns: The value that was read, or a negative value on error.
+ * spi_xfer() interface:
+ *   chipsel: Routine to call to set/clear the chip select:
+ *              if chipsel is NULL, it is not used.
+ *              if(cs),  make the chip select active (typically '0').
+ *              if(!cs), make the chip select inactive (typically '1').
+ *   dout:    Pointer to a string of bits to send out.  The bits are
+ *              held in a byte array and are sent MSB first.
+ *   din:     Pointer to a string of bits that will be filled in.
+ *   bitlen:  How many bits to write and read.
  *
- * TODO: This function probably shouldn't be inlined.
+ *   Returns: 0 on success, not 0 on failure
  */
-static inline int spi_w8r8(struct spi_slave *slave, unsigned char byte)
-{
-	unsigned char dout[2];
-	unsigned char din[2];
-	int ret;
-
-	dout[0] = byte;
-	dout[1] = 0;
-
-	ret = spi_xfer(slave, 16, dout, din, SPI_XFER_BEGIN | SPI_XFER_END);
-	return ret < 0 ? ret : din[1];
-}
+int  spi_xfer(spi_chipsel_type chipsel, int bitlen, uchar *dout, uchar *din);
 
 #endif	/* _SPI_H_ */
diff --git a/include/status_led.h b/include/status_led.h
index f213595..3593fdc 100644
--- a/include/status_led.h
+++ b/include/status_led.h
@@ -39,8 +39,61 @@
 #define STATUS_LED_BLINKING	1
 #define STATUS_LED_ON		2
 
+#ifndef __ASSEMBLY__
 void status_led_tick (unsigned long timestamp);
 void status_led_set  (int led, int state);
+#endif
+/*****  CC9C *************************************************************/
+#ifdef CONFIG_CC9C
+
+# define STATUS_LED_BIT         67              /* (CR1) LED at GPIO67  used */
+# define STATUS_LED_PERIOD      1559812
+# define STATUS_LED_STATE       STATUS_LED_ON
+
+# define STATUS_LED_BIT1        66              /* (CR2) LED at GPIO66 used */
+# define STATUS_LED_PERIOD1     1559812
+# define STATUS_LED_STATE1      STATUS_LED_OFF
+
+# ifdef CONFIG_JSCCW9C
+#  define STATUS_LED_BIT2       48              /* CR6(GPIO48) on JumpStart */
+#  define STATUS_LED_PERIOD2    1559812
+#  define STATUS_LED_STATE2     STATUS_LED_OFF
+
+#  define STATUS_LED_BIT3       49              /* CR7(GPIO49) on JumpStart */
+#  define STATUS_LED_PERIOD3    1559812
+#  define STATUS_LED_STATE3    STATUS_LED_OFF
+# endif  /* CONFIG_JSCCW9C */
+
+# define STATUS_LED_ACTIVE      0               /* LED on for bit == 0  */
+# define STATUS_LED_BOOT        0               /* LED DEBUG used for boot status */
+
+/*****  CC9P *************************************************************/
+#elif CONFIG_JSCC9P9360
+#  define STATUS_LED_BIT        47              /* (LE8) Debug LED on JumpStart */
+#  define STATUS_LED_PERIOD     1559812
+#  define STATUS_LED_STATE      STATUS_LED_OFF
+
+#  define STATUS_LED_BIT1       46              /* (LE5) LED at GPIO46 on JumpStart */
+#  define STATUS_LED_PERIOD1    1559812
+#  define STATUS_LED_STATE1     STATUS_LED_OFF
+
+#  define STATUS_LED_BIT2       66              /* (LE6) LED at GPIO66 on JumpStart */
+#  define STATUS_LED_PERIOD2    1559812
+#  define STATUS_LED_STATE2     STATUS_LED_OFF
+
+#  define STATUS_LED_ACTIVE     0               /* LED on for bit == 0  */
+#  define STATUS_LED_BOOT       0               /* LED DEBUG used for boot status */
+
+/*****  CC9P9360 Dev
+ * *************************************************************/
+#elif defined(CONFIG_MACH_CC9P9360DEV)
+#  define STATUS_LED_BIT        47              /* (LE8) Debug LED on DevKit */
+#  define STATUS_LED_PERIOD     1559812
+#  define STATUS_LED_STATE      STATUS_LED_OFF
+
+#  define STATUS_LED_ACTIVE     0               /* LED on for bit == 0  */
+#  define STATUS_LED_BOOT       0               /* LED DEBUG used for boot status */
+#endif
 
 /*****  TQM8xxL  ********************************************************/
 #if defined(CONFIG_TQM8xxL) && !defined(CONFIG_HMI10)
@@ -345,6 +398,8 @@ void status_led_set  (int led, int state);
 /************************************************************************/
 #elif defined(CONFIG_NIOS2)
 /* XXX empty just to avoid the error */
+#elif defined(CONFIG_NS921X)
+/* XXX empty just to avoid the error */
 /************************************************************************/
 #elif defined(CONFIG_V38B)
 
@@ -380,7 +435,7 @@ extern void __led_set (led_id_t mask, int state);
 /************************************************************************/
 
 #ifndef CONFIG_BOARD_SPECIFIC_LED
-# include <asm/status_led.h>
+# include <asm-arm/status_led.h>
 #endif
 
 /*
diff --git a/include/zlib.h b/include/zlib.h
new file mode 100644
index 0000000..e441494
--- /dev/null
+++ b/include/zlib.h
@@ -0,0 +1,434 @@
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-0.95
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+/*
+ *  ==FILEVERSION 960122==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 0.95, Aug 16th, 1995.
+
+  Copyright (C) 1995 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
+ */
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+/* #include "zconf.h" */	/* included directly here */
+
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* From: zconf.h,v 1.12 1995/05/03 17:27:12 jloup Exp */
+
+/*
+     The library does not install any signal handler. It is recommended to
+  add at least a handler for SIGSEGV when decompressing; the library checks
+  the consistency of the input data whenever possible but may go nuts
+  for some forms of corrupted input.
+ */
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ * Compile with -DUNALIGNED_OK if it is OK to access shorts or ints
+ * at addresses which are not a multiple of their size.
+ * Under DOS, -DFAR=far or -DFAR=__far may be needed.
+ */
+
+#ifndef STDC
+#  if defined(MSDOS) || defined(__STDC__) || defined(__cplusplus)
+#    define STDC
+#  endif
+#endif
+
+#ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
+#  include <unix.h>
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+	    1 << (windowBits+2)   +  1 << (memLevel+9)
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+			/* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+typedef unsigned char  Byte;  /* 8 bits */
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+typedef Byte FAR Bytef;
+typedef char FAR charf;
+typedef int FAR intf;
+typedef uInt FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+/* end of original zconf.h */
+
+#define ZLIB_VERSION "0.95P"
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms may be added later and will have the same
+  stream interface.
+
+     For compression the application must provide the output buffer and
+  may optionally provide the input buffer for optimization. For decompression,
+  the application must provide the input buffer and may optionally provide
+  the output buffer for optimization.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt nbytes));
+
+typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidp      opaque;  /* private data object passed to zalloc and zfree */
+
+    Byte     data_type; /* best guess about the data type: ascii or binary */
+
+    cb_func  outcb;	/* called regularly just before blocks of output */
+
+} z_stream;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+			/* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1
+#define Z_FULL_FLUSH    2
+#define Z_SYNC_FLUSH    3 /* experimental: partial_flush + byte align */
+#define Z_FINISH        4
+#define Z_PACKET_FLUSH	5
+/* See deflate() below for the usage of these constants */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+/* error codes for the compression/decompression functions */
+
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Used to set the data_type field */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+extern char *zlib_version;
+/* The application can compare zlib_version and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+ */
+
+			/* basic functions */
+
+extern int inflateInit OF((z_stream *strm));
+/*
+     Initializes the internal stream state for decompression. The fields
+   zalloc and zfree must be initialized before by the caller.  If zalloc and
+   zfree are set to Z_NULL, inflateInit updates them to use default allocation
+   functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory.  msg is set to null if there is no error message.
+   inflateInit does not perform any decompression: this will be done by
+   inflate().
+*/
+
+
+extern int inflate OF((z_stream *strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() always provides as much output as possible
+    (until there is no more input data or no more space in the output buffer).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate().
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
+  inflate flushes as much output as possible to the output buffer. The
+  flushing behavior of inflate is not specified for values of the flush
+  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
+  current implementation actually flushes as much output as possible
+  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
+  has been consumed, it is expecting to see the length field of a stored
+  block; if not, it returns Z_DATA_ERROR.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+    inflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if the end of the
+  compressed data has been reached and all uncompressed output has been
+  produced, Z_DATA_ERROR if the input data was corrupted, Z_STREAM_ERROR if
+  the stream structure was inconsistent (for example if next_in or next_out
+  was NULL), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR if no
+  progress is possible or if there was not enough room in the output buffer
+  when Z_FINISH is used. In the Z_DATA_ERROR case, the application may then
+  call inflateSync to look for a good compression block.  */
+
+
+extern int inflateEnd OF((z_stream *strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+			/* advanced functions */
+
+extern int inflateInit2 OF((z_stream *strm,
+			    int  windowBits));
+/*
+     This is another version of inflateInit with more compression options. The
+   fields next_out, zalloc and zfree must be initialized before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library (the value 16 will be allowed soon). The
+   default value is 15 if inflateInit is used instead. If a compressed stream
+   with a larger window size is given as input, inflate() will return with
+   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     If next_out is not null, the library will use this buffer for the history
+   buffer; the buffer must either be large enough to hold the entire output
+   data, or have at least 1<<windowBits bytes.  If next_out is null, the
+   library will allocate its own buffer (and leave next_out null). next_in
+   need not be provided here but must be provided by the application for the
+   next call of inflate().
+
+     If the history buffer is provided by the application, next_out must
+   never be changed by the application since the decompressor maintains
+   history information inside this buffer from call to call; the application
+   can only reset next_out to the beginning of the history buffer when
+   avail_out is zero and all output has been consumed.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   windowBits < 8). msg is set to null if there is no error message.
+   inflateInit2 does not perform any decompression: this will be done by
+   inflate().
+*/
+
+extern int inflateSync OF((z_stream *strm));
+/*
+    Skips invalid compressed data until the special marker (see deflate()
+  above) can be found, or until all available input is skipped. No output
+  is provided.
+
+    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no marker has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+extern int inflateReset OF((z_stream *strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int inflateIncomp OF((z_stream *strm));
+/*
+     This function adds the data at next_in (avail_in bytes) to the output
+   history without performing any output.  There must be no pending output,
+   and the decompressor must be expecting to see the start of a block.
+   Calling this function is equivalent to decompressing a stored block
+   containing the data at next_in (except that the data is not output).
+*/
+
+			/* checksum functions */
+
+/*
+     This function is not related to compression but is exported
+   anyway because it might be useful in applications using the
+   compression library.
+*/
+
+extern uLong adler32 OF((uLong adler, Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+#ifndef _Z_UTIL_H
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+#endif /* _ZLIB_H */
diff --git a/lib/crc32.c b/lib/crc32.c
index 27335a3..9562b13 100644
--- a/lib/crc32.c
+++ b/lib/crc32.c
@@ -18,6 +18,7 @@
 #include <watchdog.h>
 #endif
 #include "u-boot/zlib.h"
+#include "asm-arm/arch-ns9xxx/ns921x_hub.h"
 
 #define local static
 #define ZEXPORT	/* empty */
diff --git a/lib/string.c b/lib/string.c
index b375b81..fd3fb9f 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -21,7 +21,6 @@
 #include <malloc.h>
 
 
-#if 0 /* not used - was: #ifndef __HAVE_ARCH_STRNICMP */
 /**
  * strnicmp - Case insensitive, length-limited string comparison
  * @s1: One string
@@ -52,7 +51,6 @@ int strnicmp(const char *s1, const char *s2, size_t len)
 	}
 	return (int)c1 - (int)c2;
 }
-#endif
 
 char * ___strtok;
 
diff --git a/lib/time.c b/lib/time.c
index a309c26..2d68c53 100644
--- a/lib/time.c
+++ b/lib/time.c
@@ -28,6 +28,7 @@
 # define CONFIG_WD_PERIOD	(10 * 1000 * 1000)	/* 10 seconds default*/
 #endif
 
+#ifndef CONFIG_NS9215
 /* ------------------------------------------------------------------------- */
 
 void udelay(unsigned long usec)
@@ -41,3 +42,4 @@ void udelay(unsigned long usec)
 		usec -= kv;
 	} while(usec);
 }
+#endif
diff --git a/lib_arm/Makefile b/lib_arm/Makefile
new file mode 100644
index 0000000..3236948
--- /dev/null
+++ b/lib_arm/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2002-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(ARCH).a
+
+SOBJS	= _ashldi3.o _ashrdi3.o _divsi3.o _modsi3.o _udivsi3.o _umodsi3.o
+
+COBJS	= armlinux.o board.o \
+	  cache.o div0.o arm9.o
+
+SRCS 	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/lib_arm/_ashldi3.S b/lib_arm/_ashldi3.S
new file mode 100644
index 0000000..de4403d
--- /dev/null
+++ b/lib_arm/_ashldi3.S
@@ -0,0 +1,46 @@
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+
+#ifdef __ARMEB__
+#define al r1
+#define ah r0
+#else
+#define al r0
+#define ah r1
+#endif
+
+.globl __ashldi3
+__ashldi3:
+
+	subs	r3, r2, #32
+	rsb	ip, r2, #32
+	movmi	ah, ah, lsl r2
+	movpl	ah, al, lsl r3
+	orrmi	ah, ah, al, lsr ip
+	mov	al, al, lsl r2
+	mov	pc, lr
diff --git a/lib_arm/_ashrdi3.S b/lib_arm/_ashrdi3.S
new file mode 100644
index 0000000..5edbcb3
--- /dev/null
+++ b/lib_arm/_ashrdi3.S
@@ -0,0 +1,46 @@
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+
+#ifdef __ARMEB__
+#define al r1
+#define ah r0
+#else
+#define al r0
+#define ah r1
+#endif
+
+.globl __ashrdi3
+__ashrdi3:
+
+	subs	r3, r2, #32
+	rsb	ip, r2, #32
+	movmi	al, al, lsr r2
+	movpl	al, ah, asr r3
+	orrmi	al, al, ah, lsl ip
+	mov	ah, ah, asr r2
+	mov	pc, lr
diff --git a/lib_arm/_divsi3.S b/lib_arm/_divsi3.S
new file mode 100644
index 0000000..9dc15f6
--- /dev/null
+++ b/lib_arm/_divsi3.S
@@ -0,0 +1,140 @@
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+
+#else
+
+	@ Initially shift the divisor left 3 bits if possible,
+	@ set curbit accordingly.  This allows for curbit to be located
+	@ at the left end of each 4 bit nibbles in the division loop
+	@ to save one loop in most cases.
+	tst	\divisor, #0xe0000000
+	moveq	\divisor, \divisor, lsl #3
+	moveq	\curbit, #8
+	movne	\curbit, #1
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	movlo	\curbit, \curbit, lsl #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	movlo	\curbit, \curbit, lsl #1
+	blo	1b
+
+	mov	\result, #0
+
+#endif
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+.macro ARM_DIV2_ORDER divisor, order
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+
+#else
+
+	cmp	\divisor, #(1 << 16)
+	movhs	\divisor, \divisor, lsr #16
+	movhs	\order, #16
+	movlo	\order, #0
+
+	cmp	\divisor, #(1 << 8)
+	movhs	\divisor, \divisor, lsr #8
+	addhs	\order, \order, #8
+
+	cmp	\divisor, #(1 << 4)
+	movhs	\divisor, \divisor, lsr #4
+	addhs	\order, \order, #4
+
+	cmp	\divisor, #(1 << 2)
+	addhi	\order, \order, #3
+	addls	\order, \order, \divisor, lsr #1
+
+#endif
+
+.endm
+
+	.align	5
+.globl __divsi3
+__divsi3:
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+Ldiv0:
+
+	str	lr, [sp, #-4]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #4
diff --git a/lib_arm/_modsi3.S b/lib_arm/_modsi3.S
new file mode 100644
index 0000000..539c584
--- /dev/null
+++ b/lib_arm/_modsi3.S
@@ -0,0 +1,99 @@
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+#else
+
+	mov	\order, #0
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	addlo	\order, \order, #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	addlo	\order, \order, #1
+	blo	1b
+
+#endif
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+	.align	5
+.globl __modsi3
+__modsi3:
+	cmp	r1, #0
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	movs	ip, r0				@ preserve sign of dividend
+	rsbmi	r0, r0, #0			@ if negative make positive
+	subs	r2, r1, #1			@ compare divisor with 1
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq	r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	bls	10f
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+10:	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+
+Ldiv0:
+
+	str	lr, [sp, #-4]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #4
diff --git a/lib_arm/_udivsi3.S b/lib_arm/_udivsi3.S
new file mode 100644
index 0000000..2cdcd48
--- /dev/null
+++ b/lib_arm/_udivsi3.S
@@ -0,0 +1,77 @@
+/* # 1 "libgcc1.S" */
+@ libgcc1 routines for ARM cpu.
+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)
+dividend	.req	r0
+divisor		.req	r1
+result		.req	r2
+curbit		.req	r3
+/* ip		.req	r12	*/
+/* sp		.req	r13	*/
+/* lr		.req	r14	*/
+/* pc		.req	r15	*/
+	.text
+	.globl	 __udivsi3
+	.type  __udivsi3       ,function
+	.align	0
+ __udivsi3      :
+	cmp	divisor, #0
+	beq	Ldiv0
+	mov	curbit, #1
+	mov	result, #0
+	cmp	dividend, divisor
+	bcc	Lgot_result
+Loop1:
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+	cmp	divisor, #0x10000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #4
+	movcc	curbit, curbit, lsl #4
+	bcc	Loop1
+Lbignum:
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+	cmp	divisor, #0x80000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #1
+	movcc	curbit, curbit, lsl #1
+	bcc	Lbignum
+Loop3:
+	@ Test for possible subtractions, and note which bits
+	@ are done in the result.  On the final pass, this may subtract
+	@ too much from the dividend, but the result will be ok, since the
+	@ "bit" will have been shifted out at the bottom.
+	cmp	dividend, divisor
+	subcs	dividend, dividend, divisor
+	orrcs	result, result, curbit
+	cmp	dividend, divisor, lsr #1
+	subcs	dividend, dividend, divisor, lsr #1
+	orrcs	result, result, curbit, lsr #1
+	cmp	dividend, divisor, lsr #2
+	subcs	dividend, dividend, divisor, lsr #2
+	orrcs	result, result, curbit, lsr #2
+	cmp	dividend, divisor, lsr #3
+	subcs	dividend, dividend, divisor, lsr #3
+	orrcs	result, result, curbit, lsr #3
+	cmp	dividend, #0			@ Early termination?
+	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
+	movne	divisor, divisor, lsr #4
+	bne	Loop3
+Lgot_result:
+	mov	r0, result
+	mov 	pc, lr
+Ldiv0:
+	str	lr, [sp, #-4]!
+	bl	 __div0       (PLT)
+	mov	r0, #0			@ about as wrong as it could be
+	ldmia	sp!, {pc}
+	.size  __udivsi3       , . -  __udivsi3
+/* # 235 "libgcc1.S" */
+/* # 320 "libgcc1.S" */
+/* # 421 "libgcc1.S" */
+/* # 433 "libgcc1.S" */
+/* # 456 "libgcc1.S" */
+/* # 500 "libgcc1.S" */
+/* # 580 "libgcc1.S" */
diff --git a/lib_arm/_umodsi3.S b/lib_arm/_umodsi3.S
new file mode 100644
index 0000000..e4aebe8
--- /dev/null
+++ b/lib_arm/_umodsi3.S
@@ -0,0 +1,88 @@
+/* # 1 "libgcc1.S" */
+@ libgcc1 routines for ARM cpu.
+@ Division routines, written by Richard Earnshaw, (rearnsha@armltd.co.uk)
+/* # 145 "libgcc1.S" */
+dividend	.req	r0
+divisor		.req	r1
+overdone	.req	r2
+curbit		.req	r3
+/* ip		.req	r12	*/
+/* sp		.req	r13	*/
+/* lr		.req	r14	*/
+/* pc		.req	r15	*/
+	.text
+	.globl	 __umodsi3
+	.type  __umodsi3       ,function
+	.align 0
+ __umodsi3      :
+	cmp	divisor, #0
+	beq	Ldiv0
+	mov	curbit, #1
+	cmp	dividend, divisor
+	movcc  	pc, lr
+Loop1:
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+	cmp	divisor, #0x10000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #4
+	movcc	curbit, curbit, lsl #4
+	bcc	Loop1
+Lbignum:
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+	cmp	divisor, #0x80000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #1
+	movcc	curbit, curbit, lsl #1
+	bcc	Lbignum
+Loop3:
+	@ Test for possible subtractions.  On the final pass, this may
+	@ subtract too much from the dividend, so keep track of which
+	@ subtractions are done, we can fix them up afterwards...
+	mov	overdone, #0
+	cmp	dividend, divisor
+	subcs	dividend, dividend, divisor
+	cmp	dividend, divisor, lsr #1
+	subcs	dividend, dividend, divisor, lsr #1
+	orrcs	overdone, overdone, curbit, ror #1
+	cmp	dividend, divisor, lsr #2
+	subcs	dividend, dividend, divisor, lsr #2
+	orrcs	overdone, overdone, curbit, ror #2
+	cmp	dividend, divisor, lsr #3
+	subcs	dividend, dividend, divisor, lsr #3
+	orrcs	overdone, overdone, curbit, ror #3
+	mov	ip, curbit
+	cmp	dividend, #0			@ Early termination?
+	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
+	movne	divisor, divisor, lsr #4
+	bne	Loop3
+	@ Any subtractions that we should not have done will be recorded in
+	@ the top three bits of "overdone".  Exactly which were not needed
+	@ are governed by the position of the bit, stored in ip.
+	@ If we terminated early, because dividend became zero,
+	@ then none of the below will match, since the bit in ip will not be
+	@ in the bottom nibble.
+	ands	overdone, overdone, #0xe0000000
+	moveq  	pc, lr				@ No fixups needed
+	tst	overdone, ip, ror #3
+	addne	dividend, dividend, divisor, lsr #3
+	tst	overdone, ip, ror #2
+	addne	dividend, dividend, divisor, lsr #2
+	tst	overdone, ip, ror #1
+	addne	dividend, dividend, divisor, lsr #1
+	mov 	pc, lr
+Ldiv0:
+	str	lr, [sp, #-4]!
+	bl	 __div0       (PLT)
+	mov	r0, #0			@ about as wrong as it could be
+	ldmia	sp!, {pc}
+	.size  __umodsi3       , . -  __umodsi3
+/* # 320 "libgcc1.S" */
+/* # 421 "libgcc1.S" */
+/* # 433 "libgcc1.S" */
+/* # 456 "libgcc1.S" */
+/* # 500 "libgcc1.S" */
+/* # 580 "libgcc1.S" */
diff --git a/lib_arm/arm9.c b/lib_arm/arm9.c
new file mode 100644
index 0000000..6ad2417
--- /dev/null
+++ b/lib_arm/arm9.c
@@ -0,0 +1,397 @@
+/*
+ *  lib_arm/arm9.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.1 $
+ *  !Author:     Markus Pietrek
+ *  !References: [1] ARM Document DDI0198D_926_TRM.pdf
+ *               [2] Cache/TCM initialization (926Dhry)
+ *                   http://www.arm.com/support/downloads/info/2317.html
+ *               [3] DDI0151C_920T_TRM.pdf
+ *  !Descr: dcache on enables also the MMU for a flat memory model, otherwise
+ *          it can't work. The SDRAM
+ *          banks (reported by bdinfo) are configured for caching-writeback.
+ *          dcache off disables the MMU as well.
+ *          No specific commands have been added, so that the least set of
+ *          changes needs to be added to the booting mechanism.
+*/
+
+#include <common.h>
+
+#if defined(CONFIG_ARM926EJS) || defined(CONFIG_ARM920T)
+
+#include <command.h>
+
+/* return byte count of x in megabytes */
+#define MiB( x )	( (x) * 1024 * 1024 )
+
+/* See also ARM926EJ-S Technical Reference Manual */
+#define C1_MMU		(1<<0)		/* mmu off/on */
+#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
+#define C1_DC		(1<<2)		/* dcache off/on */
+
+#define C1_BIG_ENDIAN	(1<<7)		/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)		/* system protection */
+#define C1_ROM_PROT	(1<<9)		/* ROM protection */
+#define C1_IC		(1<<12)		/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)		/* location of vectors: low/high addresses */
+
+#define DOMAIN_USED	15      /* we use only one, no special meaning */
+
+/* domain control (p15,c3) */
+#define DOMAIN_CLIENT		1
+
+/* First Level Descriptor for Section, see [1] 3.2.
+ * Keep this low-level stuff in #define*/
+#define FL_SEC_MAX_ENTRIES	4096
+#define FL_SEC_ALIGNMENT	16384
+
+/* bit fields */
+#define FL_SEC_PAGE		0x00000002  /* section descriptor */
+#define FL_SEC_CACHE_B		0x00000004  /* Bufferable,[1] 4.3, Table 4-4 */
+#define FL_SEC_CACHE_C		0x00000008  /* Cacheable, [1] 4.3, Table 4-4 */
+#define FL_SEC_BACKWARD		0x00000010  /* for backward compatibility */
+#define FL_SEC_DOMAIN(x)	(( ( x ) & 0xf) << 5)
+#define FL_SEC_AP_CLIENT	0x00000400  /* Check against permission */
+#define FL_SEC_BASE(x)		(( ( x ) & (FL_SEC_MAX_ENTRIES - 1 )) << 20)  /* Base register starts at 20 */
+
+/* general settings for our flat memory model */
+#define FL_CFG_PAGE_COMMON	( FL_SEC_PAGE      | \
+               		          FL_SEC_BACKWARD  | \
+                                  FL_SEC_DOMAIN( DOMAIN_USED ) | \
+                                  FL_SEC_AP_CLIENT )
+
+/* No caching by default. Simulating no MMU behaviour */
+#define FL_CFG_PAGE_EXTERN	FL_CFG_PAGE_COMMON
+/* SDRAM is cached-writeback for best performance. Failures in DMA
+   handling are detected most easily */
+#define FL_CFG_PAGE_SDRAM	( FL_CFG_PAGE_COMMON | \
+                                  FL_SEC_CACHE_B     | \
+                                  FL_SEC_CACHE_C )
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ********** local variables ********** */
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* contains the Translation Table/First Level Descriptors
+ * Must be aligned on 16KiB boundary, [1] 3.2.1 */
+static uint32_t auiTranslationTable[ FL_SEC_MAX_ENTRIES ] __attribute__ ((aligned( FL_SEC_ALIGNMENT )));
+#endif
+/* ********** functions ********** */
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__(
+		"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
+		: "=r" (value)
+		:
+		: "memory");
+
+#ifdef MMU_DEBUG
+	printf ("p15/c1 is = %08lx\n", value);
+#endif
+	return value;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+#ifdef MMU_DEBUG
+	printf ("write %08lx to p15/c1\n", value);
+#endif
+	__asm__ __volatile__(
+		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
+		:
+		: "r" (value)
+		: "memory");
+
+	read_p15_c1 ();
+}
+#endif
+/* write to co-processor 15, register #2, (translation table base) */
+static inline void set_translation_table_base( void* pvBase )
+{
+	asm volatile (
+		"mcr	p15, 0, %0, c2, c0, 0   @ write it\n"
+		:
+		: "r" ( pvBase )
+		: "memory");
+}
+
+/* write to co-processor 15, register #3, (domain access control) */
+static inline void set_domain_ctrl( uint32_t uiDomain, uint32_t uiMode )
+{
+	asm volatile (
+		"mcr	p15, 0, %0, c3, c0, 0   @ write it\n"
+		:
+		: "r" ( (uiMode) << ((uiDomain) * 2 ) )
+		: "memory");
+}
+
+void dcache_flush( void )
+{
+        int iDummyForSync;
+
+        if( !dcache_status() )
+                /* no cache */
+                return;
+
+        /* [1], 9.3 */
+#if defined(CONFIG_ARM926EJS)
+	asm volatile(
+                /* clean all cache lines until there are no unclean ones */
+                "1:\n"
+                "mrc p15, 0, r15, c7, c10, 3\n"
+                "bne 1b\n" );
+      /* until no more are unclean */
+#elif defined(CONFIG_ARM920T)
+        /* [1], 2-23 A=6, S=3 from
+         * [3], 4.3 16KiB, 64 ways, 32bytes per line*/
+        /* from linux/arch/arm/mm/proc-arm920.S */
+        asm volatile(
+                "mov	r1, #(8 - 1) << 5	@ 8 segments\n"
+                "1:\n"
+                "orr	r3, r1, #(64 - 1) << 26 @ 64 entries\n"
+                "2:\n"
+                "mcr	p15, 0, r3, c7, c10, 2	@ clean D index\n"
+                "subs	r3, r3, #1 << 26\n"
+                "bcs	2b				@ entries 63 to 0\n"
+                "subs	r1, r1, #1 << 5\n"
+                "bcs	1b				@ segments 7 to 0\n"
+                :
+                :
+                : "r1", "r3"
+                );
+#else
+# error need flush
+#endif
+	asm volatile(
+                /* invalidate I cache */
+                "mcr	p15, 0, ip, c7, c5, 0\n"
+                /* drain writebuffer */
+                "mcr p15, 0, r0,  c7, c10, 4\n"
+                /* nonbuffered store to signal L2 world to synchronize */
+                "mov r0, #0\n"
+                "str r0, %0\n"
+                :
+                : "m" ( iDummyForSync )
+                : "r0"
+                );
+}
+
+void dcache_invalidate( void )
+{
+        if( !dcache_status() )
+                /* no cache */
+                return;
+
+        /* write back the current contents */
+        dcache_flush();
+
+#if defined(CONFIG_ARM926EJS)
+        {
+                int i = 0;
+                /* invalidate data cache only */
+                asm ("mcr p15, 0, %0, c7, c6, 0": :"r" (i));
+        }
+#elif defined(CONFIG_ARM920T)
+        asm volatile(
+                "mov	r1, #(8 - 1) << 5	@ 8 segments\n"
+                "1:\n"
+                "orr	r3, r1, #(64 - 1) << 26 @ 64 entries\n"
+                "2:\n"
+                "mcr	p15, 0, r3, c7, c14, 2	@ clean+invalidateD index\n"
+                "subs	r3, r3, #1 << 26\n"
+                "bcs	2b				@ entries 63 to 0\n"
+                "subs	r1, r1, #1 << 5\n"
+                "bcs	1b				@ segments 7 to 0\n"
+                :
+                :
+                : "r1", "r3"
+                );
+#else
+# error need some implementation
+#endif
+}
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+/* prepare the translation table so the MMU knows where to find the SDRAM */
+static void translation_table_init( void )
+{
+        uint32_t* puiSection = &auiTranslationTable[ 0 ];
+        int i;
+
+        /* where can the MMU find the first level descriptors/translat */
+        set_translation_table_base( puiSection );
+
+        /* create flat mapping, each page is 1 MiB */
+        for( i = 0; i < ARRAY_SIZE( auiTranslationTable ); i++, puiSection++) {
+                uint32_t uiCfgPage = FL_CFG_PAGE_EXTERN;
+                int j;
+
+                /* check whether we are in SDRAM and return setting */
+                for( j = 0; j < ARRAY_SIZE( gd->bd->bi_dram ); j++ ) {
+                        if( gd->bd->bi_dram[ j ].size &&
+                            ( MiB( i ) >= gd->bd->bi_dram[ j ].start ) &&
+                            ( MiB( i ) < ( gd->bd->bi_dram[ j ].start + gd->bd->bi_dram[ j ].size ) ) ) {
+                                uiCfgPage = FL_CFG_PAGE_SDRAM;
+                                break;
+                        }
+                } /* for( j = 0 ) */
+
+                *puiSection = uiCfgPage | FL_SEC_BASE( i );
+        }
+
+        /* configure how the domain can be used */
+        set_domain_ctrl( DOMAIN_USED, DOMAIN_CLIENT );
+}
+
+static void mmu_dcache_enable( void )
+{
+	int i = 0;
+        
+	/* set up the pages */
+        translation_table_init();
+
+	/* invalidate data cache only */
+	asm ("mcr p15, 0, %0, c7, c6, 0": :"r" (i));
+
+        /* enable mmu */
+        write_p15_c1( read_p15_c1() | ( C1_MMU | C1_DC ) );
+
+        /* two nops for the instruction pipeline. They are read unmapped, but
+         * executed with mapping enabled. There shouldn't be any problems if
+         * these ones are missed, but be safe */
+	asm volatile (
+                "mov r0,r0\n"
+                "mov r0, r0\n"
+                );
+}
+
+static void mmu_dcache_disable( void )
+{
+        dcache_invalidate();
+
+        write_p15_c1( read_p15_c1() & ~( C1_MMU | C1_DC ) );
+
+        /* two nops for the instruction pipeline. They are read mapped, but
+         * executed with mapping disabled. There shouldn't be any problems if
+         * these ones are missed, but be safe */
+	asm volatile (
+                "mov r0,r0\n"
+                "mov r0, r0\n"
+                );
+}
+
+static void cp_delay (void)
+{
+	volatile int i;
+
+	/* copro seems to need some delay between reading and writing */
+	for (i = 0; i < 100; i++);
+}
+#endif
+
+int cpu_init (void)
+{
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	return 0;
+}
+
+int cleanup_before_linux (void)
+{
+	/*
+	 * this function is called just before we call linux
+	 * it prepares the processor for linux
+	 *
+	 * we turn off caches etc ...
+	 */
+
+	disable_interrupts ();
+
+        icache_disable();
+        dcache_disable();
+
+	return (0);
+}
+
+int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	disable_interrupts ();
+
+        serial_tx_flush();
+
+	reset_cpu (0);
+	/*NOTREACHED*/
+	return (0);
+}
+
+void icache_enable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	ulong reg;
+
+	reg = read_p15_c1 ();		/* get control reg. */
+	cp_delay ();
+	write_p15_c1 (reg | C1_IC);
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+void icache_disable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg & ~C1_IC);
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+int icache_status (void)
+{
+	return (read_p15_c1 () & C1_IC) != 0;
+}
+
+void dcache_enable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	if(! dcache_status())
+		/* we need MMU for caching */
+		mmu_dcache_enable();
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+void dcache_disable (void)
+{
+#if (CONFIG_COMMANDS & CFG_CMD_CACHE)
+	if(dcache_status())
+		mmu_dcache_disable();
+#endif  /* (CONFIG_COMMANDS & CFG_CMD_CACHE) */
+}
+
+int dcache_status (void)
+{
+	return (read_p15_c1 () & C1_DC) != 0;
+}
+#endif /* (CONFIG_ARM926EJS) || defined(CONFIG_ARM920T) */
diff --git a/lib_arm/armlinux.c b/lib_arm/armlinux.c
new file mode 100644
index 0000000..5b3c0e4
--- /dev/null
+++ b/lib_arm/armlinux.c
@@ -0,0 +1,436 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * Copyright (C) 2001  Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <image.h>
+#include <zlib.h>
+#include <asm/byteorder.h>
+#ifdef CONFIG_HAS_DATAFLASH
+#include <dataflash.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*cmd_boot.c*/
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
+    defined (CONFIG_CMDLINE_TAG) || \
+    defined (CONFIG_INITRD_TAG) || \
+    defined (CONFIG_SERIAL_TAG) || \
+    defined (CONFIG_REVISION_TAG) || \
+    defined (CONFIG_VFD) || \
+    defined (CONFIG_LCD)
+static void setup_start_tag (bd_t *bd);
+
+# ifdef CONFIG_SETUP_MEMORY_TAGS
+static void setup_memory_tags (bd_t *bd);
+# endif
+static void setup_commandline_tag (bd_t *bd, char *commandline);
+
+#if 0
+static void setup_ramdisk_tag (bd_t *bd);
+#endif
+# ifdef CONFIG_INITRD_TAG
+static void setup_initrd_tag (bd_t *bd, ulong initrd_start,
+			      ulong initrd_end);
+# endif
+static void setup_end_tag (bd_t *bd);
+
+# if defined (CONFIG_VFD) || defined (CONFIG_LCD)
+static void setup_videolfb_tag (gd_t *gd);
+# endif
+
+
+static struct tag *params;
+#endif /* CONFIG_SETUP_MEMORY_TAGS || CONFIG_CMDLINE_TAG || CONFIG_INITRD_TAG */
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+extern image_header_t header;	/* from cmd_bootm.c */
+
+
+void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		     ulong addr, ulong *len_ptr, int verify)
+{
+	ulong len = 0, checksum;
+	ulong initrd_start, initrd_end;
+	ulong data;
+	void (*theKernel)(int zero, int arch, uint params);
+	image_header_t *hdr = &header;
+	bd_t *bd = gd->bd;
+	int machid = bd->bi_arch_number;
+	char *s;
+
+#ifdef CONFIG_CMDLINE_TAG
+	char *commandline = getenv ("bootargs");
+#endif
+
+	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);
+
+	s = getenv ("machid");
+	if (s) {
+		machid = simple_strtoul (s, NULL, 16);
+		printf ("Using machid 0x%x from environment\n", machid);
+	}
+
+	/*
+	 * Check if there is an initrd image
+	 */
+	if (argc >= 3) {
+		SHOW_BOOT_PROGRESS (9);
+
+		addr = get_input(argv[2]);
+		if((long) addr == -1)
+			return;
+
+		printf ("## Loading Ramdisk Image at %08lx ...\n", addr);
+
+		/* Copy header so we can blank CRC field for re-calculation */
+#ifdef CONFIG_HAS_DATAFLASH
+		if (addr_dataflash (addr)) {
+			read_dataflash (addr, sizeof (image_header_t),
+					(char *) &header);
+		} else
+#endif
+			memcpy (&header, (char *) addr,
+				sizeof (image_header_t));
+
+		if (ntohl (hdr->ih_magic) != IH_MAGIC) {
+			printf ("Bad Magic Number\n");
+			SHOW_BOOT_PROGRESS (-10);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		data = (ulong) & header;
+		len = sizeof (image_header_t);
+
+		checksum = ntohl (hdr->ih_hcrc);
+		hdr->ih_hcrc = 0;
+
+		if (crc32 (0, (unsigned char *) data, len) != checksum) {
+			printf ("Bad Header Checksum\n");
+			SHOW_BOOT_PROGRESS (-11);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		SHOW_BOOT_PROGRESS (10);
+
+		print_image_hdr (hdr);
+
+		data = addr + sizeof (image_header_t);
+		len = ntohl (hdr->ih_size);
+
+#ifdef CONFIG_HAS_DATAFLASH
+		if (addr_dataflash (addr)) {
+			read_dataflash (data, len, (char *) CFG_LOAD_ADDR);
+			data = CFG_LOAD_ADDR;
+		}
+#endif
+
+		if (verify) {
+			ulong csum = 0;
+
+			printf ("   Verifying Checksum ... ");
+			csum = crc32 (0, (unsigned char *) data, len);
+			if (csum != ntohl (hdr->ih_dcrc)) {
+				printf ("Bad Data CRC\n");
+				SHOW_BOOT_PROGRESS (-12);
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			printf ("OK\n");
+		}
+
+		SHOW_BOOT_PROGRESS (11);
+
+		if ((hdr->ih_os != IH_OS_LINUX) ||
+		    (hdr->ih_arch != IH_CPU_ARM) ||
+		    (hdr->ih_type != IH_TYPE_RAMDISK)) {
+			printf ("No Linux ARM Ramdisk Image\n");
+			SHOW_BOOT_PROGRESS (-13);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+#if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
+		/*
+		 *we need to copy the ramdisk to SRAM to let Linux boot
+		 */
+		memmove ((void *) ntohl(hdr->ih_load), (uchar *)data, len);
+		data = ntohl(hdr->ih_load);
+#endif /* CONFIG_B2 || CONFIG_EVB4510 */
+
+		/*
+		 * Now check if we have a multifile image
+		 */
+	} else if ((hdr->ih_type == IH_TYPE_MULTI) && (len_ptr[1])) {
+		ulong tail = ntohl (len_ptr[0]) % 4;
+		int i;
+
+		SHOW_BOOT_PROGRESS (13);
+
+		/* skip kernel length and terminator */
+		data = (ulong) (&len_ptr[2]);
+		/* skip any additional image length fields */
+		for (i = 1; len_ptr[i]; ++i)
+			data += 4;
+		/* add kernel length, and align */
+		data += ntohl (len_ptr[0]);
+		if (tail) {
+			data += 4 - tail;
+		}
+
+		len = ntohl (len_ptr[1]);
+
+	} else {
+		/*
+		 * no initrd image
+		 */
+		SHOW_BOOT_PROGRESS (14);
+
+		len = data = 0;
+	}
+
+#ifdef	DEBUG
+	if (!data) {
+		printf ("No initrd\n");
+	}
+#endif
+
+	if (data) {
+		initrd_start = data;
+		initrd_end = initrd_start + len;
+	} else {
+		initrd_start = 0;
+		initrd_end = 0;
+	}
+
+	SHOW_BOOT_PROGRESS (15);
+
+	debug ("## Transferring control to Linux (at address %08lx) ...\n",
+	       (ulong) theKernel);
+
+#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
+    defined (CONFIG_CMDLINE_TAG) || \
+    defined (CONFIG_INITRD_TAG) || \
+    defined (CONFIG_SERIAL_TAG) || \
+    defined (CONFIG_REVISION_TAG) || \
+    defined (CONFIG_LCD) || \
+    defined (CONFIG_VFD)
+	setup_start_tag (bd);
+#ifdef CONFIG_SERIAL_TAG
+	setup_serial_tag (&params);
+#endif
+#ifdef CONFIG_REVISION_TAG
+	setup_revision_tag (&params);
+#endif
+#ifdef CONFIG_SETUP_MEMORY_TAGS
+	setup_memory_tags (bd);
+#endif
+#ifdef CONFIG_CMDLINE_TAG
+	setup_commandline_tag (bd, commandline);
+#endif
+#ifdef CONFIG_INITRD_TAG
+	if (initrd_start && initrd_end)
+		setup_initrd_tag (bd, initrd_start, initrd_end);
+#endif
+#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
+	setup_videolfb_tag ((gd_t *) gd);
+#endif
+	setup_end_tag (bd);
+#endif
+
+	/* we assume that the kernel is in place */
+	printf ("\nStarting kernel ...\n\n");
+
+#ifdef CONFIG_USB_DEVICE
+	{
+		extern void udc_disconnect (void);
+		udc_disconnect ();
+	}
+#endif
+
+#if defined(CONFIG_SILENT_CONSOLE) && defined(CONFIG_ALLOW_SERIAL_DISABLE)
+	/* We want the kernel to remain silent even for the dots
+	 * printed during kernel uncompress. For that, it is
+	 * needed to disable all serial ports */
+	if (gd->flags & GD_FLG_SILENT) {
+		serial_disable();
+	}
+#endif
+	cleanup_before_linux ();
+
+	theKernel (0, machid, bd->bi_boot_params);
+}
+
+
+#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
+    defined (CONFIG_CMDLINE_TAG) || \
+    defined (CONFIG_INITRD_TAG) || \
+    defined (CONFIG_SERIAL_TAG) || \
+    defined (CONFIG_REVISION_TAG) || \
+    defined (CONFIG_LCD) || \
+    defined (CONFIG_VFD)
+static void setup_start_tag (bd_t *bd)
+{
+	params = (struct tag *) bd->bi_boot_params;
+
+	params->hdr.tag = ATAG_CORE;
+	params->hdr.size = tag_size (tag_core);
+
+	params->u.core.flags = 0;
+	params->u.core.pagesize = 0;
+	params->u.core.rootdev = 0;
+
+	params = tag_next (params);
+}
+
+
+#ifdef CONFIG_SETUP_MEMORY_TAGS
+static void setup_memory_tags (bd_t *bd)
+{
+	int i;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		params->hdr.tag = ATAG_MEM;
+		params->hdr.size = tag_size (tag_mem32);
+
+		params->u.mem.start = bd->bi_dram[i].start;
+		params->u.mem.size = bd->bi_dram[i].size;
+
+		params = tag_next (params);
+	}
+}
+#endif /* CONFIG_SETUP_MEMORY_TAGS */
+
+
+static void setup_commandline_tag (bd_t *bd, char *commandline)
+{
+	char *p;
+
+	if (!commandline)
+		return;
+
+	/* eat leading white space */
+	for (p = commandline; *p == ' '; p++);
+
+	/* skip non-existent command lines so the kernel will still
+	 * use its default command line.
+	 */
+	if (*p == '\0')
+		return;
+
+	params->hdr.tag = ATAG_CMDLINE;
+	params->hdr.size =
+		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
+
+	strcpy (params->u.cmdline.cmdline, p);
+
+	params = tag_next (params);
+}
+
+
+#ifdef CONFIG_INITRD_TAG
+static void setup_initrd_tag (bd_t *bd, ulong initrd_start, ulong initrd_end)
+{
+	/* an ATAG_INITRD node tells the kernel where the compressed
+	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
+	 */
+	params->hdr.tag = ATAG_INITRD2;
+	params->hdr.size = tag_size (tag_initrd);
+
+	params->u.initrd.start = initrd_start;
+	params->u.initrd.size = initrd_end - initrd_start;
+
+	params = tag_next (params);
+}
+#endif /* CONFIG_INITRD_TAG */
+
+
+#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
+extern ulong calc_fbsize (void);
+static void setup_videolfb_tag (gd_t *gd)
+{
+	/* An ATAG_VIDEOLFB node tells the kernel where and how large
+	 * the framebuffer for video was allocated (among other things).
+	 * Note that a _physical_ address is passed !
+	 *
+	 * We only use it to pass the address and size, the other entries
+	 * in the tag_videolfb are not of interest.
+	 */
+	params->hdr.tag = ATAG_VIDEOLFB;
+	params->hdr.size = tag_size (tag_videolfb);
+
+	params->u.videolfb.lfb_base = (u32) gd->fb_base;
+	/* Fb size is calculated according to parameters for our panel
+	 */
+	params->u.videolfb.lfb_size = calc_fbsize();
+
+	params = tag_next (params);
+}
+#endif /* CONFIG_VFD || CONFIG_LCD */
+
+#ifdef CONFIG_SERIAL_TAG
+void setup_serial_tag (struct tag **tmp)
+{
+	struct tag *params = *tmp;
+	struct tag_serialnr serialnr;
+	void get_board_serial(struct tag_serialnr *serialnr);
+
+	get_board_serial(&serialnr);
+	params->hdr.tag = ATAG_SERIAL;
+	params->hdr.size = tag_size (tag_serialnr);
+	params->u.serialnr.low = serialnr.low;
+	params->u.serialnr.high= serialnr.high;
+	params = tag_next (params);
+	*tmp = params;
+}
+#endif
+
+#ifdef CONFIG_REVISION_TAG
+void setup_revision_tag(struct tag **in_params)
+{
+	u32 rev = 0;
+	u32 get_board_rev(void);
+
+	rev = get_board_rev();
+	params->hdr.tag = ATAG_REVISION;
+	params->hdr.size = tag_size (tag_revision);
+	params->u.revision.rev = rev;
+	params = tag_next (params);
+}
+#endif  /* CONFIG_REVISION_TAG */
+
+
+static void setup_end_tag (bd_t *bd)
+{
+	params->hdr.tag = ATAG_NONE;
+	params->hdr.size = 0;
+}
+
+#endif /* CONFIG_SETUP_MEMORY_TAGS || CONFIG_CMDLINE_TAG || CONFIG_INITRD_TAG */
diff --git a/lib_arm/board.c b/lib_arm/board.c
new file mode 100644
index 0000000..1e005b1
--- /dev/null
+++ b/lib_arm/board.c
@@ -0,0 +1,626 @@
+/*
+ * (C) Copyright 2002-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * To match the U-Boot user interface on ARM platforms to the U-Boot
+ * standard (as on PPC platforms), some messages with debug character
+ * are removed from the default U-Boot build.
+ *
+ * Define DEBUG here if you want additional info as shown below
+ * printed upon startup:
+ *
+ * U-Boot code: 00F00000 -> 00F3C774  BSS: -> 00FC3274
+ * IRQ Stack: 00ebff7c
+ * FIQ Stack: 00ebef7c
+ */
+
+#include <common.h>
+#include <command.h>
+#include <devices.h>
+#include <version.h>
+#include <net.h>
+#include <serial.h>             /* serial_initialize */
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#include <nand.h>
+#endif
+
+#ifdef CONFIG_STATUS_LED
+# include <status_led.h>
+#endif /* CONFIG_STATUS_LED */
+
+#ifdef CONFIG_DRIVER_SMC91111
+#include "../drivers/smc91111.h"
+#endif
+#ifdef CONFIG_DRIVER_LAN91C96
+#include "../drivers/lan91c96.h"
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP)
+# define UBOOT
+# include "../common/digi/cmd_nvram/lib/include/nvram.h"
+#endif  /* CONFIG_COMMANDS & CFG_CMD_BSP */
+
+#undef DEBUG  /* defined in nand.h */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+unsigned int nand_init (void);
+extern nand_info_t nand_info[];
+#endif
+
+#ifndef CFG_NO_FLASH
+extern flash_info_t flash_info[];       /* info for FLASH chips */
+#endif
+
+#ifdef CONFIG_ONE_NAND
+void onenand_init(void);
+#endif
+
+ulong monitor_flash_len;
+
+#ifdef CONFIG_HAS_DATAFLASH
+extern int  AT91F_DataflashInit(void);
+extern void dataflash_print_info(void);
+#endif
+
+#ifndef CONFIG_IDENT_STRING
+#define CONFIG_IDENT_STRING ""
+#endif
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ " - GCC "__VERSION__")"CONFIG_IDENT_STRING;
+
+#ifdef CONFIG_DRIVER_CS8900
+extern void cs8900_get_enetaddr (uchar * addr);
+#endif
+
+#ifdef CONFIG_DRIVER_RTL8019
+extern void rtl8019_get_enetaddr (uchar * addr);
+#endif
+
+extern int lcd_display_init(void);
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+static ulong mem_malloc_start = 0;
+static ulong mem_malloc_end = 0;
+static ulong mem_malloc_brk = 0;
+
+static
+void mem_malloc_init (ulong dest_addr)
+{
+	mem_malloc_start = dest_addr;
+	mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
+	mem_malloc_brk = mem_malloc_start;
+
+	 memset ((void *) mem_malloc_start, 0,
+			mem_malloc_end - mem_malloc_start);
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+
+	return ((void *) old);
+}
+
+/************************************************************************
+ * Init Utilities							*
+ ************************************************************************
+ * Some of this code should be moved into the core functions,
+ * or dropped completely,
+ * but let's get it working (again) first...
+ */
+
+static int init_baudrate (void)
+{
+	char tmp[64];	/* long enough for environment variables */
+	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
+			? (int) simple_strtoul (tmp, NULL, 10)
+			: CONFIG_BAUDRATE;
+
+	return (0);
+}
+
+int display_banner (void)
+{
+	printf ("\n\n%s\n\n", version_string);
+	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	       _armboot_start, _bss_start, _bss_end);
+#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
+	debug("\t\bMalloc and Stack is above the U-Boot Code.\n");
+#else
+	debug("\t\bMalloc and Stack is below the U-Boot Code.\n");
+#endif
+#ifdef CONFIG_MODEM_SUPPORT
+	debug ("Modem Support enabled\n");
+#endif
+#ifdef CONFIG_USE_IRQ
+	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
+	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
+#endif
+
+	return (0);
+}
+
+/*
+ * WARNING: this code looks "cleaner" than the PowerPC version, but
+ * has the disadvantage that you either get nothing, or everything.
+ * On PowerPC, you might see "DRAM: " before the system hangs - which
+ * gives a simple yet clear indication which part of the
+ * initialization if failing.
+ */
+int display_dram_config (void)
+{
+	int i;
+
+#ifdef DEBUG
+	puts ("RAM Configuration:\n");
+
+	for(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
+		printf ("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
+		print_size (gd->bd->bi_dram[i].size, "\n");
+	}
+#else
+	ulong size = 0;
+
+	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
+		size += gd->bd->bi_dram[i].size;
+	}
+
+	puts("DRAM:  ");
+	print_size(size, "\n");
+#endif
+
+	return (0);
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+int display_nand_config (void)
+{
+	int i;
+	ulong size = 0;
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
+		size += nand_info[i].size;
+	puts("NAND:  ");
+	print_size(size, "\n");
+	return 0;
+}
+#endif
+
+#ifndef CFG_NO_FLASH
+int display_flash_config (void)
+{
+	int i;
+	ulong size = 0;
+
+	for( i = 0; i < CFG_MAX_FLASH_BANKS; i++ )
+		size += flash_info[i].size;
+
+	puts ("Flash: ");
+	print_size (size, "\n");
+
+	return 0;
+}
+#endif /* CFG_NO_FLASH */
+
+
+/*
+ * Breathe some life into the board...
+ *
+ * Initialize a serial port as console, and carry out some hardware
+ * tests.
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependent #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+int print_cpuinfo (void); /* test-only */
+
+init_fnc_t *init_sequence[] = {
+	cpu_init,		/* basic cpu dependent setup */
+	board_init,		/* basic board dependent setup */
+	dram_init,		/* configure available RAM banks */
+	interrupt_init,		/* set up exceptions */
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+#ifndef CONFIG_SILENT_CONSOLE
+	serial_init,		/* serial communications setup */
+#endif
+	console_init_f,		/* stage 1 init of console */
+	NULL,
+};
+
+init_fnc_t *init_sequence_display[] = {
+	display_banner,         /* say that we are here */
+#if defined(CONFIG_DISPLAY_CPUINFO)
+	print_cpuinfo,          /* display cpu info (and speed) */
+#endif
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+	checkboard,             /* display board info */
+#endif
+	display_dram_config,
+	NULL,
+};
+
+void start_armboot (void)
+{
+	init_fnc_t **init_fnc_ptr;
+	char *s;
+
+#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
+	unsigned long addr = 0;
+#endif
+
+	/* Pointer is writable since we allocated a register for it */
+#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
+	ulong gd_base;
+
+	gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);
+#ifdef CONFIG_USE_IRQ
+	gd_base -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
+#endif
+	gd = (gd_t*)gd_base;
+#else
+	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
+#endif
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset ((void*)gd, 0, sizeof (gd_t));
+	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
+	memset (gd->bd, 0, sizeof (bd_t));
+
+	monitor_flash_len = _bss_start - _armboot_start;
+
+#ifdef CONFIG_SERIAL_MULTI
+        serial_initialize();
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP)
+        /* baudrate is being read from NvRAM. If one mirror image is wrong,
+           don't do any output yet in the default baudrate as we will switch
+           later to the second image. */
+        NvEnableOutput( 0 );
+#endif  /* CONFIG_COMMANDS & CFG_CMD_BSP */
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+#ifndef CFG_NO_FLASH
+	/* configure available FLASH banks */
+	flash_init ();
+#endif /* CFG_NO_FLASH */
+
+#ifdef CONFIG_VFD
+#	ifndef PAGE_SIZE
+#	  define PAGE_SIZE 4096
+#	endif
+	/*
+	 * reserve memory for VFD display (always full pages)
+	 */
+	/* bss_end is defined in the board-specific linker script */
+	addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
+	size = vfd_setmem (addr);
+	gd->fb_base = addr;
+#endif /* CONFIG_VFD */
+
+	/* armboot_start is defined in the board-specific linker script */
+#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
+	mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);
+#else
+	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	nand_init();		/* go init the NAND */
+#endif
+
+#ifdef CONFIG_ONE_NAND
+	puts ("ONENAND:");
+	onenand_init();		/* go init the One-NAND */
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+	AT91F_DataflashInit();
+	dataflash_print_info();
+#endif
+
+	/* initialize environment */
+	env_relocate ();
+
+#if (!defined(CONFIG_SILENT_CONSOLE) && !defined(CONFIG_UBOOT_JTAG_CONSOLE))
+	/* now we have a valid environment, even when reading from NAND.
+	 * Switch to the configured baudrate. */
+	update_baudrate_from_env(); /* take baudrate from environment */
+#endif
+
+	for (init_fnc_ptr = init_sequence_display; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+	gd->bd->fb_base = 0xffffffff;
+#ifdef CONFIG_LCD
+#	ifndef PAGE_SIZE
+#	  define PAGE_SIZE 4096
+#	endif
+	/*
+	 * reserve memory for LCD display (always full pages)
+	 */
+
+	/* Set selected display data */
+	if (!lcd_display_init()) {
+		char* saddr;
+		saddr = getenv ("fb_base");
+		if(saddr != NULL)
+			addr = simple_strtoul( saddr, NULL, 16 );
+		addr = lcd_setmem (addr);
+		gd->fb_base = addr;
+		gd->bd->fb_base = addr;
+	}
+#endif /* CONFIG_LCD */
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+	display_nand_config();
+#endif
+
+#ifndef CFG_NO_FLASH
+	display_flash_config();
+#endif /* CFG_NO_FLASH */
+
+#if (CONFIG_COMMANDS & CFG_CMD_BSP)
+        /* print any error messages of NVRAM reading */
+        NvEnableOutput( 1 );
+        NvPrintStatus();
+#endif  /* CONFIG_COMMANDS & CFG_CMD_BSP */
+
+#ifdef CONFIG_VFD
+	/* must do this after the framebuffer is allocated */
+	drv_vfd_init();
+#endif /* CONFIG_VFD */
+
+	/* IP Address */
+	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
+
+	/* MAC Address */
+	{
+		int i;
+		ulong reg;
+		char *s, *e;
+		char tmp[64];
+
+		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
+		s = (i > 0) ? tmp : NULL;
+
+		for (reg = 0; reg < 6; ++reg) {
+			gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+
+#ifdef CONFIG_HAS_ETH1
+		i = getenv_r ("eth1addr", tmp, sizeof (tmp));
+		s = (i > 0) ? tmp : NULL;
+
+		for (reg = 0; reg < 6; ++reg) {
+			gd->bd->bi_enet1addr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+#endif
+	}
+
+	devices_init ();	/* get the devices list going. */
+
+#ifdef CONFIG_CMC_PU2
+	load_sernum_ethaddr ();
+#endif /* CONFIG_CMC_PU2 */
+
+	jumptable_init ();
+
+	console_init_r ();	/* fully init console as a device */
+
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r ();
+#endif
+
+	/* enable exceptions */
+	enable_interrupts ();
+
+	/* Perform network card initialisation if necessary */
+#ifdef CONFIG_DRIVER_CS8900
+	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
+#endif
+
+#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
+	if (getenv ("ethaddr")) {
+		smc_set_mac_addr(gd->bd->bi_enetaddr);
+	}
+#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */
+
+	/* Initialize from environment */
+	if ((s = getenv ("loadaddr")) != NULL) {
+		load_addr = simple_strtoul (s, NULL, 16);
+	}
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+	if ((s = getenv ("bootfile")) != NULL) {
+		copy_filename (BootFile, s, sizeof (BootFile));
+	}
+#endif	/* CFG_CMD_NET */
+
+#ifdef BOARD_LATE_INIT
+	board_late_init ();
+#endif
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+#if defined(CONFIG_NET_MULTI)
+	puts ("Net:   ");
+#endif
+	eth_initialize(gd->bd);
+#endif
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop ();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
+
+void hang (void)
+{
+	puts ("### ERROR ### Please RESET the board ###\n");
+	for (;;);
+}
+
+#ifdef CONFIG_MODEM_SUPPORT
+static inline void mdm_readline(char *buf, int bufsiz);
+
+/* called from main loop (common/main.c) */
+extern void  dbg(const char *fmt, ...);
+int mdm_init (void)
+{
+	char env_str[16];
+	char *init_str;
+	int i;
+	extern char console_buffer[];
+	extern void enable_putc(void);
+	extern int hwflow_onoff(int);
+
+	enable_putc(); /* enable serial_putc() */
+
+#ifdef CONFIG_HWFLOW
+	init_str = getenv("mdm_flow_control");
+	if (init_str && (strcmp(init_str, "rts/cts") == 0))
+		hwflow_onoff (1);
+	else
+		hwflow_onoff(-1);
+#endif
+
+	for (i = 1;;i++) {
+		sprintf(env_str, "mdm_init%d", i);
+		if ((init_str = getenv(env_str)) != NULL) {
+			serial_puts(init_str);
+			serial_puts("\n");
+			for(;;) {
+				mdm_readline(console_buffer, CFG_CBSIZE);
+				dbg("ini%d: [%s]", i, console_buffer);
+
+				if ((strcmp(console_buffer, "OK") == 0) ||
+					(strcmp(console_buffer, "ERROR") == 0)) {
+					dbg("ini%d: cmd done", i);
+					break;
+				} else /* in case we are originating call ... */
+					if (strncmp(console_buffer, "CONNECT", 7) == 0) {
+						dbg("ini%d: connect", i);
+						return 0;
+					}
+			}
+		} else
+			break; /* no init string - stop modem init */
+
+		udelay(100000);
+	}
+
+	udelay(100000);
+
+	/* final stage - wait for connect */
+	for(;i > 1;) { /* if 'i' > 1 - wait for connection
+				  message from modem */
+		mdm_readline(console_buffer, CFG_CBSIZE);
+		dbg("ini_f: [%s]", console_buffer);
+		if (strncmp(console_buffer, "CONNECT", 7) == 0) {
+			dbg("ini_f: connected");
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+/* 'inline' - We have to do it fast */
+static inline void mdm_readline(char *buf, int bufsiz)
+{
+	char c;
+	char *p;
+	int n;
+
+	n = 0;
+	p = buf;
+	for(;;) {
+		c = serial_getc();
+
+		/*		dbg("(%c)", c); */
+
+		switch(c) {
+		case '\r':
+			break;
+		case '\n':
+			*p = '\0';
+			return;
+
+		default:
+			if(n++ > bufsiz) {
+				*p = '\0';
+				return; /* sanity check */
+			}
+			*p = c;
+			p++;
+			break;
+		}
+	}
+}
+#endif	/* CONFIG_MODEM_SUPPORT */
diff --git a/lib_arm/cache.c b/lib_arm/cache.c
new file mode 100644
index 0000000..eab3719
--- /dev/null
+++ b/lib_arm/cache.c
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* for now: just dummy functions to satisfy the linker */
+
+#include <common.h>
+
+#if defined(CONFIG_ARM926EJS) || defined(CONFIG_ARM920T)
+# define HAVE_DCACHE
+void dcache_invalidate( void );
+void dcache_flush( void );
+#endif
+
+void  flush_cache_all( void )
+{
+#ifdef HAVE_DCACHE
+        dcache_flush();
+#endif
+}
+
+void  flush_cache (unsigned long dummy1, unsigned long dummy2)
+{
+#ifdef CONFIG_OMAP2420
+	void arm1136_cache_flush(void);
+
+	arm1136_cache_flush();
+#endif
+
+        flush_cache_all();
+	return;
+}
+
+void  invalidate_cache_all( void )
+{
+#ifdef HAVE_DCACHE
+        dcache_invalidate();
+#endif
+}
diff --git a/lib_arm/div0.c b/lib_arm/div0.c
new file mode 100644
index 0000000..6267bf1
--- /dev/null
+++ b/lib_arm/div0.c
@@ -0,0 +1,30 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Replacement (=dummy) for GNU/Linux division-by zero handler */
+void __div0 (void)
+{
+	extern void hang (void);
+
+	hang();
+}
diff --git a/lib_generic/Makefile b/lib_generic/Makefile
new file mode 100644
index 0000000..1621c99
--- /dev/null
+++ b/lib_generic/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)libgeneric.a
+
+COBJS	= bzlib.o bzlib_crctable.o bzlib_decompress.o \
+	  bzlib_randtable.o bzlib_huffman.o \
+	  crc32.o ctype.o display_options.o ldiv.o \
+	  string.o vsprintf.o zlib.o
+	  #string.o vsprintf.o zlib.o
+
+SRCS 	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/lib_generic/bzlib.c b/lib_generic/bzlib.c
new file mode 100644
index 0000000..87e6a6e
--- /dev/null
+++ b/lib_generic/bzlib.c
@@ -0,0 +1,1600 @@
+#include <config.h>
+#include <common.h>
+#include <watchdog.h>
+#ifdef CONFIG_BZIP2
+
+/*
+ * This file is a modified version of bzlib.c from the bzip2-1.0.2
+ * distribution which can be found at http://sources.redhat.com/bzip2/
+ */
+
+/*-------------------------------------------------------------*/
+/*--- Library top-level functions.                          ---*/
+/*---                                               bzlib.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+/*--
+   CHANGES
+   ~~~~~~~
+   0.9.0 -- original version.
+
+   0.9.0a/b -- no changes in this file.
+
+   0.9.0c
+      * made zero-length BZ_FLUSH work correctly in bzCompress().
+      * fixed bzWrite/bzRead to ignore zero-length requests.
+      * fixed bzread to correctly handle read requests after EOF.
+      * wrong parameter order in call to bzDecompressInit in
+	bzBuffToBuffDecompress.  Fixed.
+--*/
+
+#include "bzlib_private.h"
+
+/*---------------------------------------------------*/
+/*--- Compression stuff                           ---*/
+/*---------------------------------------------------*/
+
+
+/*---------------------------------------------------*/
+#ifndef BZ_NO_STDIO
+void BZ2_bz__AssertH__fail ( int errcode )
+{
+   fprintf(stderr,
+      "\n\nbzip2/libbzip2: internal error number %d.\n"
+      "This is a bug in bzip2/libbzip2, %s.\n"
+      "Please report it to me at: jseward@acm.org.  If this happened\n"
+      "when you were using some program which uses libbzip2 as a\n"
+      "component, you should also report this bug to the author(s)\n"
+      "of that program.  Please make an effort to report this bug;\n"
+      "timely and accurate bug reports eventually lead to higher\n"
+      "quality software.  Thanks.  Julian Seward, 30 December 2001.\n\n",
+      errcode,
+      BZ2_bzlibVersion()
+   );
+
+   if (errcode == 1007) {
+   fprintf(stderr,
+      "\n*** A special note about internal error number 1007 ***\n"
+      "\n"
+      "Experience suggests that a common cause of i.e. 1007\n"
+      "is unreliable memory or other hardware.  The 1007 assertion\n"
+      "just happens to cross-check the results of huge numbers of\n"
+      "memory reads/writes, and so acts (unintendedly) as a stress\n"
+      "test of your memory system.\n"
+      "\n"
+      "I suggest the following: try compressing the file again,\n"
+      "possibly monitoring progress in detail with the -vv flag.\n"
+      "\n"
+      "* If the error cannot be reproduced, and/or happens at different\n"
+      "  points in compression, you may have a flaky memory system.\n"
+      "  Try a memory-test program.  I have used Memtest86\n"
+      "  (www.memtest86.com).  At the time of writing it is free (GPLd).\n"
+      "  Memtest86 tests memory much more thorougly than your BIOSs\n"
+      "  power-on test, and may find failures that the BIOS doesn't.\n"
+      "\n"
+      "* If the error can be repeatably reproduced, this is a bug in\n"
+      "  bzip2, and I would very much like to hear about it.  Please\n"
+      "  let me know, and, ideally, save a copy of the file causing the\n"
+      "  problem -- without which I will be unable to investigate it.\n"
+      "\n"
+   );
+   }
+
+   exit(3);
+}
+#endif
+
+
+/*---------------------------------------------------*/
+static
+int bz_config_ok ( void )
+{
+   if (sizeof(int)   != 4) return 0;
+   if (sizeof(short) != 2) return 0;
+   if (sizeof(char)  != 1) return 0;
+   return 1;
+}
+
+
+/*---------------------------------------------------*/
+static
+void* default_bzalloc ( void* opaque, Int32 items, Int32 size )
+{
+   void* v = malloc ( items * size );
+   return v;
+}
+
+static
+void default_bzfree ( void* opaque, void* addr )
+{
+   if (addr != NULL) free ( addr );
+}
+
+#ifndef BZ_NO_COMPRESS
+/*---------------------------------------------------*/
+static
+void prepare_new_block ( EState* s )
+{
+   Int32 i;
+   s->nblock = 0;
+   s->numZ = 0;
+   s->state_out_pos = 0;
+   BZ_INITIALISE_CRC ( s->blockCRC );
+   for (i = 0; i < 256; i++) s->inUse[i] = False;
+   s->blockNo++;
+}
+
+
+/*---------------------------------------------------*/
+static
+void init_RL ( EState* s )
+{
+   s->state_in_ch  = 256;
+   s->state_in_len = 0;
+}
+
+
+static
+Bool isempty_RL ( EState* s )
+{
+   if (s->state_in_ch < 256 && s->state_in_len > 0)
+      return False; else
+      return True;
+}
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzCompressInit)
+		    ( bz_stream* strm,
+		     int        blockSize100k,
+		     int        verbosity,
+		     int        workFactor )
+{
+   Int32   n;
+   EState* s;
+
+   if (!bz_config_ok()) return BZ_CONFIG_ERROR;
+
+   if (strm == NULL ||
+       blockSize100k < 1 || blockSize100k > 9 ||
+       workFactor < 0 || workFactor > 250)
+     return BZ_PARAM_ERROR;
+
+   if (workFactor == 0) workFactor = 30;
+   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
+   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;
+
+   s = BZALLOC( sizeof(EState) );
+   if (s == NULL) return BZ_MEM_ERROR;
+   s->strm = strm;
+
+   s->arr1 = NULL;
+   s->arr2 = NULL;
+   s->ftab = NULL;
+
+   n       = 100000 * blockSize100k;
+   s->arr1 = BZALLOC( n                  * sizeof(UInt32) );
+   s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );
+   s->ftab = BZALLOC( 65537              * sizeof(UInt32) );
+
+   if (s->arr1 == NULL || s->arr2 == NULL || s->ftab == NULL) {
+      if (s->arr1 != NULL) BZFREE(s->arr1);
+      if (s->arr2 != NULL) BZFREE(s->arr2);
+      if (s->ftab != NULL) BZFREE(s->ftab);
+      if (s       != NULL) BZFREE(s);
+      return BZ_MEM_ERROR;
+   }
+
+   s->blockNo           = 0;
+   s->state             = BZ_S_INPUT;
+   s->mode              = BZ_M_RUNNING;
+   s->combinedCRC       = 0;
+   s->blockSize100k     = blockSize100k;
+   s->nblockMAX         = 100000 * blockSize100k - 19;
+   s->verbosity         = verbosity;
+   s->workFactor        = workFactor;
+
+   s->block             = (UChar*)s->arr2;
+   s->mtfv              = (UInt16*)s->arr1;
+   s->zbits             = NULL;
+   s->ptr               = (UInt32*)s->arr1;
+
+   strm->state          = s;
+   strm->total_in_lo32  = 0;
+   strm->total_in_hi32  = 0;
+   strm->total_out_lo32 = 0;
+   strm->total_out_hi32 = 0;
+   init_RL ( s );
+   prepare_new_block ( s );
+   return BZ_OK;
+}
+
+
+/*---------------------------------------------------*/
+static
+void add_pair_to_block ( EState* s )
+{
+   Int32 i;
+   UChar ch = (UChar)(s->state_in_ch);
+   for (i = 0; i < s->state_in_len; i++) {
+      BZ_UPDATE_CRC( s->blockCRC, ch );
+   }
+   s->inUse[s->state_in_ch] = True;
+   switch (s->state_in_len) {
+      case 1:
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 break;
+      case 2:
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 break;
+      case 3:
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 break;
+      default:
+	 s->inUse[s->state_in_len-4] = True;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = (UChar)ch; s->nblock++;
+	 s->block[s->nblock] = ((UChar)(s->state_in_len-4));
+	 s->nblock++;
+	 break;
+   }
+}
+
+
+/*---------------------------------------------------*/
+static
+void flush_RL ( EState* s )
+{
+   if (s->state_in_ch < 256) add_pair_to_block ( s );
+   init_RL ( s );
+}
+
+
+/*---------------------------------------------------*/
+#define ADD_CHAR_TO_BLOCK(zs,zchh0)               \
+{                                                 \
+   UInt32 zchh = (UInt32)(zchh0);                 \
+   /*-- fast track the common case --*/           \
+   if (zchh != zs->state_in_ch &&                 \
+       zs->state_in_len == 1) {                   \
+      UChar ch = (UChar)(zs->state_in_ch);        \
+      BZ_UPDATE_CRC( zs->blockCRC, ch );          \
+      zs->inUse[zs->state_in_ch] = True;          \
+      zs->block[zs->nblock] = (UChar)ch;          \
+      zs->nblock++;                               \
+      zs->state_in_ch = zchh;                     \
+   }                                              \
+   else                                           \
+   /*-- general, uncommon cases --*/              \
+   if (zchh != zs->state_in_ch ||                 \
+      zs->state_in_len == 255) {                  \
+      if (zs->state_in_ch < 256)                  \
+	 add_pair_to_block ( zs );                \
+      zs->state_in_ch = zchh;                     \
+      zs->state_in_len = 1;                       \
+   } else {                                       \
+      zs->state_in_len++;                         \
+   }                                              \
+}
+
+
+/*---------------------------------------------------*/
+static
+Bool copy_input_until_stop ( EState* s )
+{
+   Bool progress_in = False;
+
+   if (s->mode == BZ_M_RUNNING) {
+
+      /*-- fast track the common case --*/
+      while (True) {
+	 /*-- block full? --*/
+	 if (s->nblock >= s->nblockMAX) break;
+	 /*-- no input? --*/
+	 if (s->strm->avail_in == 0) break;
+	 progress_in = True;
+	 ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );
+	 s->strm->next_in++;
+	 s->strm->avail_in--;
+	 s->strm->total_in_lo32++;
+	 if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;
+      }
+
+   } else {
+
+      /*-- general, uncommon case --*/
+      while (True) {
+	 /*-- block full? --*/
+	 if (s->nblock >= s->nblockMAX) break;
+	 /*-- no input? --*/
+	 if (s->strm->avail_in == 0) break;
+	 /*-- flush/finish end? --*/
+	 if (s->avail_in_expect == 0) break;
+	 progress_in = True;
+	 ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );
+	 s->strm->next_in++;
+	 s->strm->avail_in--;
+	 s->strm->total_in_lo32++;
+	 if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;
+	 s->avail_in_expect--;
+      }
+   }
+   return progress_in;
+}
+
+
+/*---------------------------------------------------*/
+static
+Bool copy_output_until_stop ( EState* s )
+{
+   Bool progress_out = False;
+
+   while (True) {
+
+      /*-- no output space? --*/
+      if (s->strm->avail_out == 0) break;
+
+      /*-- block done? --*/
+      if (s->state_out_pos >= s->numZ) break;
+
+      progress_out = True;
+      *(s->strm->next_out) = s->zbits[s->state_out_pos];
+      s->state_out_pos++;
+      s->strm->avail_out--;
+      s->strm->next_out++;
+      s->strm->total_out_lo32++;
+      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+   }
+
+   return progress_out;
+}
+
+
+/*---------------------------------------------------*/
+static
+Bool handle_compress ( bz_stream* strm )
+{
+   Bool progress_in  = False;
+   Bool progress_out = False;
+   EState* s = strm->state;
+
+   while (True) {
+
+      if (s->state == BZ_S_OUTPUT) {
+	 progress_out |= copy_output_until_stop ( s );
+	 if (s->state_out_pos < s->numZ) break;
+	 if (s->mode == BZ_M_FINISHING &&
+	     s->avail_in_expect == 0 &&
+	     isempty_RL(s)) break;
+	 prepare_new_block ( s );
+	 s->state = BZ_S_INPUT;
+	 if (s->mode == BZ_M_FLUSHING &&
+	     s->avail_in_expect == 0 &&
+	     isempty_RL(s)) break;
+      }
+
+      if (s->state == BZ_S_INPUT) {
+	 progress_in |= copy_input_until_stop ( s );
+	 if (s->mode != BZ_M_RUNNING && s->avail_in_expect == 0) {
+	    flush_RL ( s );
+	    BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );
+	    s->state = BZ_S_OUTPUT;
+	 }
+	 else
+	 if (s->nblock >= s->nblockMAX) {
+	    BZ2_compressBlock ( s, False );
+	    s->state = BZ_S_OUTPUT;
+	 }
+	 else
+	 if (s->strm->avail_in == 0) {
+	    break;
+	 }
+      }
+
+   }
+
+   return progress_in || progress_out;
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )
+{
+   Bool progress;
+   EState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   preswitch:
+   switch (s->mode) {
+
+      case BZ_M_IDLE:
+	 return BZ_SEQUENCE_ERROR;
+
+      case BZ_M_RUNNING:
+	 if (action == BZ_RUN) {
+	    progress = handle_compress ( strm );
+	    return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;
+	 }
+	 else
+	 if (action == BZ_FLUSH) {
+	    s->avail_in_expect = strm->avail_in;
+	    s->mode = BZ_M_FLUSHING;
+	    goto preswitch;
+	 }
+	 else
+	 if (action == BZ_FINISH) {
+	    s->avail_in_expect = strm->avail_in;
+	    s->mode = BZ_M_FINISHING;
+	    goto preswitch;
+	 }
+	 else
+	    return BZ_PARAM_ERROR;
+
+      case BZ_M_FLUSHING:
+	 if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;
+	 if (s->avail_in_expect != s->strm->avail_in)
+	    return BZ_SEQUENCE_ERROR;
+	 progress = handle_compress ( strm );
+	 if (s->avail_in_expect > 0 || !isempty_RL(s) ||
+	     s->state_out_pos < s->numZ) return BZ_FLUSH_OK;
+	 s->mode = BZ_M_RUNNING;
+	 return BZ_RUN_OK;
+
+      case BZ_M_FINISHING:
+	 if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;
+	 if (s->avail_in_expect != s->strm->avail_in)
+	    return BZ_SEQUENCE_ERROR;
+	 progress = handle_compress ( strm );
+	 if (!progress) return BZ_SEQUENCE_ERROR;
+	 if (s->avail_in_expect > 0 || !isempty_RL(s) ||
+	     s->state_out_pos < s->numZ) return BZ_FINISH_OK;
+	 s->mode = BZ_M_IDLE;
+	 return BZ_STREAM_END;
+   }
+   return BZ_OK; /*--not reached--*/
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )
+{
+   EState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   if (s->arr1 != NULL) BZFREE(s->arr1);
+   if (s->arr2 != NULL) BZFREE(s->arr2);
+   if (s->ftab != NULL) BZFREE(s->ftab);
+   BZFREE(strm->state);
+
+   strm->state = NULL;
+
+   return BZ_OK;
+}
+#endif /* BZ_NO_COMPRESS */
+
+/*---------------------------------------------------*/
+/*--- Decompression stuff                         ---*/
+/*---------------------------------------------------*/
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompressInit)
+		     ( bz_stream* strm,
+		       int        verbosity,
+		       int        small )
+{
+   DState* s;
+
+   if (!bz_config_ok()) return BZ_CONFIG_ERROR;
+
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   if (small != 0 && small != 1) return BZ_PARAM_ERROR;
+   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;
+
+   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
+   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;
+
+   s = BZALLOC( sizeof(DState) );
+   if (s == NULL) return BZ_MEM_ERROR;
+   s->strm                  = strm;
+   strm->state              = s;
+   s->state                 = BZ_X_MAGIC_1;
+   s->bsLive                = 0;
+   s->bsBuff                = 0;
+   s->calculatedCombinedCRC = 0;
+   strm->total_in_lo32      = 0;
+   strm->total_in_hi32      = 0;
+   strm->total_out_lo32     = 0;
+   strm->total_out_hi32     = 0;
+   s->smallDecompress       = (Bool)small;
+   s->ll4                   = NULL;
+   s->ll16                  = NULL;
+   s->tt                    = NULL;
+   s->currBlockNo           = 0;
+   s->verbosity             = verbosity;
+
+   return BZ_OK;
+}
+
+
+/*---------------------------------------------------*/
+static
+void unRLE_obuf_to_output_FAST ( DState* s )
+{
+   UChar k1;
+
+   if (s->blockRandomised) {
+
+      while (True) {
+	 /* try to finish existing run */
+	 while (True) {
+	    if (s->strm->avail_out == 0) return;
+	    if (s->state_out_len == 0) break;
+	    *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+	    BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+	    s->state_out_len--;
+	    s->strm->next_out++;
+	    s->strm->avail_out--;
+	    s->strm->total_out_lo32++;
+	    if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+	 }
+
+	 /* can a new run be started? */
+	 if (s->nblock_used == s->save_nblock+1) return;
+
+
+	 s->state_out_len = 1;
+	 s->state_out_ch = s->k0;
+	 BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 2;
+	 BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 3;
+	 BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 s->state_out_len = ((Int32)k1) + 4;
+	 BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK;
+	 s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
+      }
+
+   } else {
+
+      /* restore */
+      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;
+      UChar         c_state_out_ch       = s->state_out_ch;
+      Int32         c_state_out_len      = s->state_out_len;
+      Int32         c_nblock_used        = s->nblock_used;
+      Int32         c_k0                 = s->k0;
+      UInt32*       c_tt                 = s->tt;
+      UInt32        c_tPos               = s->tPos;
+      char*         cs_next_out          = s->strm->next_out;
+      unsigned int  cs_avail_out         = s->strm->avail_out;
+      /* end restore */
+
+      UInt32       avail_out_INIT = cs_avail_out;
+      Int32        s_save_nblockPP = s->save_nblock+1;
+      unsigned int total_out_lo32_old;
+
+      while (True) {
+
+	 /* try to finish existing run */
+	 if (c_state_out_len > 0) {
+	    while (True) {
+	       if (cs_avail_out == 0) goto return_notr;
+	       if (c_state_out_len == 1) break;
+	       *( (UChar*)(cs_next_out) ) = c_state_out_ch;
+	       BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
+	       c_state_out_len--;
+	       cs_next_out++;
+	       cs_avail_out--;
+	    }
+	    s_state_out_len_eq_one:
+	    {
+	       if (cs_avail_out == 0) {
+		  c_state_out_len = 1; goto return_notr;
+	       };
+	       *( (UChar*)(cs_next_out) ) = c_state_out_ch;
+	       BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
+	       cs_next_out++;
+	       cs_avail_out--;
+	    }
+	 }
+	 /* can a new run be started? */
+	 if (c_nblock_used == s_save_nblockPP) {
+	    c_state_out_len = 0; goto return_notr;
+	 };
+	 c_state_out_ch = c_k0;
+	 BZ_GET_FAST_C(k1); c_nblock_used++;
+	 if (k1 != c_k0) {
+	    c_k0 = k1; goto s_state_out_len_eq_one;
+	 };
+	 if (c_nblock_used == s_save_nblockPP)
+	    goto s_state_out_len_eq_one;
+
+	 c_state_out_len = 2;
+	 BZ_GET_FAST_C(k1); c_nblock_used++;
+	 if (c_nblock_used == s_save_nblockPP) continue;
+	 if (k1 != c_k0) { c_k0 = k1; continue; };
+
+	 c_state_out_len = 3;
+	 BZ_GET_FAST_C(k1); c_nblock_used++;
+	 if (c_nblock_used == s_save_nblockPP) continue;
+	 if (k1 != c_k0) { c_k0 = k1; continue; };
+
+	 BZ_GET_FAST_C(k1); c_nblock_used++;
+	 c_state_out_len = ((Int32)k1) + 4;
+	 BZ_GET_FAST_C(c_k0); c_nblock_used++;
+      }
+
+      return_notr:
+      total_out_lo32_old = s->strm->total_out_lo32;
+      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);
+      if (s->strm->total_out_lo32 < total_out_lo32_old)
+	 s->strm->total_out_hi32++;
+
+      /* save */
+      s->calculatedBlockCRC = c_calculatedBlockCRC;
+      s->state_out_ch       = c_state_out_ch;
+      s->state_out_len      = c_state_out_len;
+      s->nblock_used        = c_nblock_used;
+      s->k0                 = c_k0;
+      s->tt                 = c_tt;
+      s->tPos               = c_tPos;
+      s->strm->next_out     = cs_next_out;
+      s->strm->avail_out    = cs_avail_out;
+      /* end save */
+   }
+}
+
+
+/*---------------------------------------------------*/
+__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )
+{
+   Int32 nb, na, mid;
+   nb = 0;
+   na = 256;
+   do {
+      mid = (nb + na) >> 1;
+      if (indx >= cftab[mid]) nb = mid; else na = mid;
+   }
+   while (na - nb != 1);
+   return nb;
+}
+
+
+/*---------------------------------------------------*/
+static
+void unRLE_obuf_to_output_SMALL ( DState* s )
+{
+   UChar k1;
+
+   if (s->blockRandomised) {
+
+      while (True) {
+	 /* try to finish existing run */
+	 while (True) {
+	    if (s->strm->avail_out == 0) return;
+	    if (s->state_out_len == 0) break;
+	    *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+	    BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+	    s->state_out_len--;
+	    s->strm->next_out++;
+	    s->strm->avail_out--;
+	    s->strm->total_out_lo32++;
+	    if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+	 }
+
+	 /* can a new run be started? */
+	 if (s->nblock_used == s->save_nblock+1) return;
+
+
+	 s->state_out_len = 1;
+	 s->state_out_ch = s->k0;
+	 BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 2;
+	 BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 3;
+	 BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;
+	 k1 ^= BZ_RAND_MASK; s->nblock_used++;
+	 s->state_out_len = ((Int32)k1) + 4;
+	 BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK;
+	 s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
+      }
+
+   } else {
+
+      while (True) {
+	 /* try to finish existing run */
+	 while (True) {
+	    if (s->strm->avail_out == 0) return;
+	    if (s->state_out_len == 0) break;
+	    *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+	    BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+	    s->state_out_len--;
+	    s->strm->next_out++;
+	    s->strm->avail_out--;
+	    s->strm->total_out_lo32++;
+	    if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+	 }
+
+	 /* can a new run be started? */
+	 if (s->nblock_used == s->save_nblock+1) return;
+
+	 s->state_out_len = 1;
+	 s->state_out_ch = s->k0;
+	 BZ_GET_SMALL(k1); s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 2;
+	 BZ_GET_SMALL(k1); s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 s->state_out_len = 3;
+	 BZ_GET_SMALL(k1); s->nblock_used++;
+	 if (s->nblock_used == s->save_nblock+1) continue;
+	 if (k1 != s->k0) { s->k0 = k1; continue; };
+
+	 BZ_GET_SMALL(k1); s->nblock_used++;
+	 s->state_out_len = ((Int32)k1) + 4;
+	 BZ_GET_SMALL(s->k0); s->nblock_used++;
+      }
+
+   }
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompress) ( bz_stream *strm )
+{
+   DState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   while (True) {
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	WATCHDOG_RESET();
+#endif
+      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;
+      if (s->state == BZ_X_OUTPUT) {
+	 if (s->smallDecompress)
+	    unRLE_obuf_to_output_SMALL ( s ); else
+	    unRLE_obuf_to_output_FAST  ( s );
+	 if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) {
+	    BZ_FINALISE_CRC ( s->calculatedBlockCRC );
+	    if (s->verbosity >= 3)
+	       VPrintf2 ( " {0x%x, 0x%x}", s->storedBlockCRC,
+			  s->calculatedBlockCRC );
+	    if (s->verbosity >= 2) VPrintf0 ( "]" );
+	    if (s->calculatedBlockCRC != s->storedBlockCRC)
+	       return BZ_DATA_ERROR;
+	    s->calculatedCombinedCRC
+	       = (s->calculatedCombinedCRC << 1) |
+		    (s->calculatedCombinedCRC >> 31);
+	    s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
+	    s->state = BZ_X_BLKHDR_1;
+	 } else {
+	    return BZ_OK;
+	 }
+      }
+      if (s->state >= BZ_X_MAGIC_1) {
+	 Int32 r = BZ2_decompress ( s );
+	 if (r == BZ_STREAM_END) {
+	    if (s->verbosity >= 3)
+	       VPrintf2 ( "\n    combined CRCs: stored = 0x%x, computed = 0x%x",
+			  s->storedCombinedCRC, s->calculatedCombinedCRC );
+	    if (s->calculatedCombinedCRC != s->storedCombinedCRC)
+	       return BZ_DATA_ERROR;
+	    return r;
+	 }
+	 if (s->state != BZ_X_OUTPUT) return r;
+      }
+   }
+
+   AssertH ( 0, 6001 );
+
+   return 0;  /*NOTREACHED*/
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )
+{
+   DState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   if (s->tt   != NULL) BZFREE(s->tt);
+   if (s->ll16 != NULL) BZFREE(s->ll16);
+   if (s->ll4  != NULL) BZFREE(s->ll4);
+
+   BZFREE(strm->state);
+   strm->state = NULL;
+
+   return BZ_OK;
+}
+
+
+#ifndef BZ_NO_STDIO
+/*---------------------------------------------------*/
+/*--- File I/O stuff                              ---*/
+/*---------------------------------------------------*/
+
+#define BZ_SETERR(eee)                    \
+{                                         \
+   if (bzerror != NULL) *bzerror = eee;   \
+   if (bzf != NULL) bzf->lastErr = eee;   \
+}
+
+typedef
+   struct {
+      FILE*     handle;
+      Char      buf[BZ_MAX_UNUSED];
+      Int32     bufN;
+      Bool      writing;
+      bz_stream strm;
+      Int32     lastErr;
+      Bool      initialisedOk;
+   }
+   bzFile;
+
+
+/*---------------------------------------------*/
+static Bool myfeof ( FILE* f )
+{
+   Int32 c = fgetc ( f );
+   if (c == EOF) return True;
+   ungetc ( c, f );
+   return False;
+}
+
+
+/*---------------------------------------------------*/
+BZFILE* BZ_API(BZ2_bzWriteOpen)
+		    ( int*  bzerror,
+		      FILE* f,
+		      int   blockSize100k,
+		      int   verbosity,
+		      int   workFactor )
+{
+   Int32   ret;
+   bzFile* bzf = NULL;
+
+   BZ_SETERR(BZ_OK);
+
+   if (f == NULL ||
+       (blockSize100k < 1 || blockSize100k > 9) ||
+       (workFactor < 0 || workFactor > 250) ||
+       (verbosity < 0 || verbosity > 4))
+      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };
+
+   if (ferror(f))
+      { BZ_SETERR(BZ_IO_ERROR); return NULL; };
+
+   bzf = malloc ( sizeof(bzFile) );
+   if (bzf == NULL)
+      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };
+
+   BZ_SETERR(BZ_OK);
+   bzf->initialisedOk = False;
+   bzf->bufN          = 0;
+   bzf->handle        = f;
+   bzf->writing       = True;
+   bzf->strm.bzalloc  = NULL;
+   bzf->strm.bzfree   = NULL;
+   bzf->strm.opaque   = NULL;
+
+   if (workFactor == 0) workFactor = 30;
+   ret = BZ2_bzCompressInit ( &(bzf->strm), blockSize100k,
+			      verbosity, workFactor );
+   if (ret != BZ_OK)
+      { BZ_SETERR(ret); free(bzf); return NULL; };
+
+   bzf->strm.avail_in = 0;
+   bzf->initialisedOk = True;
+   return bzf;
+}
+
+
+/*---------------------------------------------------*/
+void BZ_API(BZ2_bzWrite)
+	     ( int*    bzerror,
+	       BZFILE* b,
+	       void*   buf,
+	       int     len )
+{
+   Int32 n, n2, ret;
+   bzFile* bzf = (bzFile*)b;
+
+   BZ_SETERR(BZ_OK);
+   if (bzf == NULL || buf == NULL || len < 0)
+      { BZ_SETERR(BZ_PARAM_ERROR); return; };
+   if (!(bzf->writing))
+      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
+   if (ferror(bzf->handle))
+      { BZ_SETERR(BZ_IO_ERROR); return; };
+
+   if (len == 0)
+      { BZ_SETERR(BZ_OK); return; };
+
+   bzf->strm.avail_in = len;
+   bzf->strm.next_in  = buf;
+
+   while (True) {
+      bzf->strm.avail_out = BZ_MAX_UNUSED;
+      bzf->strm.next_out = bzf->buf;
+      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );
+      if (ret != BZ_RUN_OK)
+	 { BZ_SETERR(ret); return; };
+
+      if (bzf->strm.avail_out < BZ_MAX_UNUSED) {
+	 n = BZ_MAX_UNUSED - bzf->strm.avail_out;
+	 n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),
+		       n, bzf->handle );
+	 if (n != n2 || ferror(bzf->handle))
+	    { BZ_SETERR(BZ_IO_ERROR); return; };
+      }
+
+      if (bzf->strm.avail_in == 0)
+	 { BZ_SETERR(BZ_OK); return; };
+   }
+}
+
+
+/*---------------------------------------------------*/
+void BZ_API(BZ2_bzWriteClose)
+		  ( int*          bzerror,
+		    BZFILE*       b,
+		    int           abandon,
+		    unsigned int* nbytes_in,
+		    unsigned int* nbytes_out )
+{
+   BZ2_bzWriteClose64 ( bzerror, b, abandon,
+			nbytes_in, NULL, nbytes_out, NULL );
+}
+
+
+void BZ_API(BZ2_bzWriteClose64)
+		  ( int*          bzerror,
+		    BZFILE*       b,
+		    int           abandon,
+		    unsigned int* nbytes_in_lo32,
+		    unsigned int* nbytes_in_hi32,
+		    unsigned int* nbytes_out_lo32,
+		    unsigned int* nbytes_out_hi32 )
+{
+   Int32   n, n2, ret;
+   bzFile* bzf = (bzFile*)b;
+
+   if (bzf == NULL)
+      { BZ_SETERR(BZ_OK); return; };
+   if (!(bzf->writing))
+      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
+   if (ferror(bzf->handle))
+      { BZ_SETERR(BZ_IO_ERROR); return; };
+
+   if (nbytes_in_lo32 != NULL) *nbytes_in_lo32 = 0;
+   if (nbytes_in_hi32 != NULL) *nbytes_in_hi32 = 0;
+   if (nbytes_out_lo32 != NULL) *nbytes_out_lo32 = 0;
+   if (nbytes_out_hi32 != NULL) *nbytes_out_hi32 = 0;
+
+   if ((!abandon) && bzf->lastErr == BZ_OK) {
+      while (True) {
+	 bzf->strm.avail_out = BZ_MAX_UNUSED;
+	 bzf->strm.next_out = bzf->buf;
+	 ret = BZ2_bzCompress ( &(bzf->strm), BZ_FINISH );
+	 if (ret != BZ_FINISH_OK && ret != BZ_STREAM_END)
+	    { BZ_SETERR(ret); return; };
+
+	 if (bzf->strm.avail_out < BZ_MAX_UNUSED) {
+	    n = BZ_MAX_UNUSED - bzf->strm.avail_out;
+	    n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),
+			  n, bzf->handle );
+	    if (n != n2 || ferror(bzf->handle))
+	       { BZ_SETERR(BZ_IO_ERROR); return; };
+	 }
+
+	 if (ret == BZ_STREAM_END) break;
+      }
+   }
+
+   if ( !abandon && !ferror ( bzf->handle ) ) {
+      fflush ( bzf->handle );
+      if (ferror(bzf->handle))
+	 { BZ_SETERR(BZ_IO_ERROR); return; };
+   }
+
+   if (nbytes_in_lo32 != NULL)
+      *nbytes_in_lo32 = bzf->strm.total_in_lo32;
+   if (nbytes_in_hi32 != NULL)
+      *nbytes_in_hi32 = bzf->strm.total_in_hi32;
+   if (nbytes_out_lo32 != NULL)
+      *nbytes_out_lo32 = bzf->strm.total_out_lo32;
+   if (nbytes_out_hi32 != NULL)
+      *nbytes_out_hi32 = bzf->strm.total_out_hi32;
+
+   BZ_SETERR(BZ_OK);
+   BZ2_bzCompressEnd ( &(bzf->strm) );
+   free ( bzf );
+}
+
+
+/*---------------------------------------------------*/
+BZFILE* BZ_API(BZ2_bzReadOpen)
+		   ( int*  bzerror,
+		     FILE* f,
+		     int   verbosity,
+		     int   small,
+		     void* unused,
+		     int   nUnused )
+{
+   bzFile* bzf = NULL;
+   int     ret;
+
+   BZ_SETERR(BZ_OK);
+
+   if (f == NULL ||
+       (small != 0 && small != 1) ||
+       (verbosity < 0 || verbosity > 4) ||
+       (unused == NULL && nUnused != 0) ||
+       (unused != NULL && (nUnused < 0 || nUnused > BZ_MAX_UNUSED)))
+      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };
+
+   if (ferror(f))
+      { BZ_SETERR(BZ_IO_ERROR); return NULL; };
+
+   bzf = malloc ( sizeof(bzFile) );
+   if (bzf == NULL)
+      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };
+
+   BZ_SETERR(BZ_OK);
+
+   bzf->initialisedOk = False;
+   bzf->handle        = f;
+   bzf->bufN          = 0;
+   bzf->writing       = False;
+   bzf->strm.bzalloc  = NULL;
+   bzf->strm.bzfree   = NULL;
+   bzf->strm.opaque   = NULL;
+
+   while (nUnused > 0) {
+      bzf->buf[bzf->bufN] = *((UChar*)(unused)); bzf->bufN++;
+      unused = ((void*)( 1 + ((UChar*)(unused))  ));
+      nUnused--;
+   }
+
+   ret = BZ2_bzDecompressInit ( &(bzf->strm), verbosity, small );
+   if (ret != BZ_OK)
+      { BZ_SETERR(ret); free(bzf); return NULL; };
+
+   bzf->strm.avail_in = bzf->bufN;
+   bzf->strm.next_in  = bzf->buf;
+
+   bzf->initialisedOk = True;
+   return bzf;
+}
+
+
+/*---------------------------------------------------*/
+void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )
+{
+   bzFile* bzf = (bzFile*)b;
+
+   BZ_SETERR(BZ_OK);
+   if (bzf == NULL)
+      { BZ_SETERR(BZ_OK); return; };
+
+   if (bzf->writing)
+      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
+
+   if (bzf->initialisedOk)
+      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );
+   free ( bzf );
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzRead)
+	   ( int*    bzerror,
+	     BZFILE* b,
+	     void*   buf,
+	     int     len )
+{
+   Int32   n, ret;
+   bzFile* bzf = (bzFile*)b;
+
+   BZ_SETERR(BZ_OK);
+
+   if (bzf == NULL || buf == NULL || len < 0)
+      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };
+
+   if (bzf->writing)
+      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };
+
+   if (len == 0)
+      { BZ_SETERR(BZ_OK); return 0; };
+
+   bzf->strm.avail_out = len;
+   bzf->strm.next_out = buf;
+
+   while (True) {
+
+      if (ferror(bzf->handle))
+	 { BZ_SETERR(BZ_IO_ERROR); return 0; };
+
+      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {
+	 n = fread ( bzf->buf, sizeof(UChar),
+		     BZ_MAX_UNUSED, bzf->handle );
+	 if (ferror(bzf->handle))
+	    { BZ_SETERR(BZ_IO_ERROR); return 0; };
+	 bzf->bufN = n;
+	 bzf->strm.avail_in = bzf->bufN;
+	 bzf->strm.next_in = bzf->buf;
+      }
+
+      ret = BZ2_bzDecompress ( &(bzf->strm) );
+
+      if (ret != BZ_OK && ret != BZ_STREAM_END)
+	 { BZ_SETERR(ret); return 0; };
+
+      if (ret == BZ_OK && myfeof(bzf->handle) &&
+	  bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)
+	 { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };
+
+      if (ret == BZ_STREAM_END)
+	 { BZ_SETERR(BZ_STREAM_END);
+	   return len - bzf->strm.avail_out; };
+      if (bzf->strm.avail_out == 0)
+	 { BZ_SETERR(BZ_OK); return len; };
+
+   }
+
+   return 0; /*not reached*/
+}
+
+
+/*---------------------------------------------------*/
+void BZ_API(BZ2_bzReadGetUnused)
+		     ( int*    bzerror,
+		       BZFILE* b,
+		       void**  unused,
+		       int*    nUnused )
+{
+   bzFile* bzf = (bzFile*)b;
+   if (bzf == NULL)
+      { BZ_SETERR(BZ_PARAM_ERROR); return; };
+   if (bzf->lastErr != BZ_STREAM_END)
+      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
+   if (unused == NULL || nUnused == NULL)
+      { BZ_SETERR(BZ_PARAM_ERROR); return; };
+
+   BZ_SETERR(BZ_OK);
+   *nUnused = bzf->strm.avail_in;
+   *unused = bzf->strm.next_in;
+}
+#endif
+
+
+/*---------------------------------------------------*/
+/*--- Misc convenience stuff                      ---*/
+/*---------------------------------------------------*/
+#ifndef BZ_NO_COMPRESS
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzBuffToBuffCompress)
+			 ( char*         dest,
+			   unsigned int* destLen,
+			   char*         source,
+			   unsigned int  sourceLen,
+			   int           blockSize100k,
+			   int           verbosity,
+			   int           workFactor )
+{
+   bz_stream strm;
+   int ret;
+
+   if (dest == NULL || destLen == NULL ||
+       source == NULL ||
+       blockSize100k < 1 || blockSize100k > 9 ||
+       verbosity < 0 || verbosity > 4 ||
+       workFactor < 0 || workFactor > 250)
+      return BZ_PARAM_ERROR;
+
+   if (workFactor == 0) workFactor = 30;
+   strm.bzalloc = NULL;
+   strm.bzfree = NULL;
+   strm.opaque = NULL;
+   ret = BZ2_bzCompressInit ( &strm, blockSize100k,
+			      verbosity, workFactor );
+   if (ret != BZ_OK) return ret;
+
+   strm.next_in = source;
+   strm.next_out = dest;
+   strm.avail_in = sourceLen;
+   strm.avail_out = *destLen;
+
+   ret = BZ2_bzCompress ( &strm, BZ_FINISH );
+   if (ret == BZ_FINISH_OK) goto output_overflow;
+   if (ret != BZ_STREAM_END) goto errhandler;
+
+   /* normal termination */
+   *destLen -= strm.avail_out;
+   BZ2_bzCompressEnd ( &strm );
+   return BZ_OK;
+
+   output_overflow:
+   BZ2_bzCompressEnd ( &strm );
+   return BZ_OUTBUFF_FULL;
+
+   errhandler:
+   BZ2_bzCompressEnd ( &strm );
+   return ret;
+}
+#endif /* BZ_NO_COMPRESS */
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzBuffToBuffDecompress)
+			   ( char*         dest,
+			     unsigned int* destLen,
+			     char*         source,
+			     unsigned int  sourceLen,
+			     int           small,
+			     int           verbosity )
+{
+   bz_stream strm;
+   int ret;
+
+   if (destLen == NULL || source == NULL)
+	  return BZ_PARAM_ERROR;
+
+   strm.bzalloc = NULL;
+   strm.bzfree = NULL;
+   strm.opaque = NULL;
+   ret = BZ2_bzDecompressInit ( &strm, verbosity, small );
+   if (ret != BZ_OK) return ret;
+
+   strm.next_in = source;
+   strm.next_out = dest;
+   strm.avail_in = sourceLen;
+   strm.avail_out = *destLen;
+
+   ret = BZ2_bzDecompress ( &strm );
+   if (ret == BZ_OK) goto output_overflow_or_eof;
+   if (ret != BZ_STREAM_END) goto errhandler;
+
+   /* normal termination */
+   *destLen -= strm.avail_out;
+   BZ2_bzDecompressEnd ( &strm );
+   return BZ_OK;
+
+   output_overflow_or_eof:
+   if (strm.avail_out > 0) {
+      BZ2_bzDecompressEnd ( &strm );
+      return BZ_UNEXPECTED_EOF;
+   } else {
+      BZ2_bzDecompressEnd ( &strm );
+      return BZ_OUTBUFF_FULL;
+   };
+
+   errhandler:
+   BZ2_bzDecompressEnd ( &strm );
+   return ret;
+}
+
+
+/*---------------------------------------------------*/
+/*--
+   Code contributed by Yoshioka Tsuneo
+   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),
+   to support better zlib compatibility.
+   This code is not _officially_ part of libbzip2 (yet);
+   I haven't tested it, documented it, or considered the
+   threading-safeness of it.
+   If this code breaks, please contact both Yoshioka and me.
+--*/
+/*---------------------------------------------------*/
+
+/*---------------------------------------------------*/
+/*--
+   return version like "0.9.0c".
+--*/
+const char * BZ_API(BZ2_bzlibVersion)(void)
+{
+   return BZ_VERSION;
+}
+
+
+#ifndef BZ_NO_STDIO
+/*---------------------------------------------------*/
+
+#if defined(_WIN32) || defined(OS2) || defined(MSDOS)
+#   include <fcntl.h>
+#   include <io.h>
+#   define SET_BINARY_MODE(file) setmode(fileno(file),O_BINARY)
+#else
+#   define SET_BINARY_MODE(file)
+#endif
+static
+BZFILE * bzopen_or_bzdopen
+	       ( const char *path,   /* no use when bzdopen */
+		 int fd,             /* no use when bzdopen */
+		 const char *mode,
+		 int open_mode)      /* bzopen: 0, bzdopen:1 */
+{
+   int    bzerr;
+   char   unused[BZ_MAX_UNUSED];
+   int    blockSize100k = 9;
+   int    writing       = 0;
+   char   mode2[10]     = "";
+   FILE   *fp           = NULL;
+   BZFILE *bzfp         = NULL;
+   int    verbosity     = 0;
+   int    workFactor    = 30;
+   int    smallMode     = 0;
+   int    nUnused       = 0;
+
+   if (mode == NULL) return NULL;
+   while (*mode) {
+      switch (*mode) {
+      case 'r':
+	 writing = 0; break;
+      case 'w':
+	 writing = 1; break;
+      case 's':
+	 smallMode = 1; break;
+      default:
+	 if (isdigit((int)(*mode))) {
+	    blockSize100k = *mode-BZ_HDR_0;
+	 }
+      }
+      mode++;
+   }
+   strcat(mode2, writing ? "w" : "r" );
+   strcat(mode2,"b");   /* binary mode */
+
+   if (open_mode==0) {
+      if (path==NULL || strcmp(path,"")==0) {
+	fp = (writing ? stdout : stdin);
+	SET_BINARY_MODE(fp);
+      } else {
+	fp = fopen(path,mode2);
+      }
+   } else {
+#ifdef BZ_STRICT_ANSI
+      fp = NULL;
+#else
+      fp = fdopen(fd,mode2);
+#endif
+   }
+   if (fp == NULL) return NULL;
+
+   if (writing) {
+      /* Guard against total chaos and anarchy -- JRS */
+      if (blockSize100k < 1) blockSize100k = 1;
+      if (blockSize100k > 9) blockSize100k = 9;
+      bzfp = BZ2_bzWriteOpen(&bzerr,fp,blockSize100k,
+			     verbosity,workFactor);
+   } else {
+      bzfp = BZ2_bzReadOpen(&bzerr,fp,verbosity,smallMode,
+			    unused,nUnused);
+   }
+   if (bzfp == NULL) {
+      if (fp != stdin && fp != stdout) fclose(fp);
+      return NULL;
+   }
+   return bzfp;
+}
+
+
+/*---------------------------------------------------*/
+/*--
+   open file for read or write.
+      ex) bzopen("file","w9")
+      case path="" or NULL => use stdin or stdout.
+--*/
+BZFILE * BZ_API(BZ2_bzopen)
+	       ( const char *path,
+		 const char *mode )
+{
+   return bzopen_or_bzdopen(path,-1,mode,/*bzopen*/0);
+}
+
+
+/*---------------------------------------------------*/
+BZFILE * BZ_API(BZ2_bzdopen)
+	       ( int fd,
+		 const char *mode )
+{
+   return bzopen_or_bzdopen(NULL,fd,mode,/*bzdopen*/1);
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )
+{
+   int bzerr, nread;
+   if (((bzFile*)b)->lastErr == BZ_STREAM_END) return 0;
+   nread = BZ2_bzRead(&bzerr,b,buf,len);
+   if (bzerr == BZ_OK || bzerr == BZ_STREAM_END) {
+      return nread;
+   } else {
+      return -1;
+   }
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )
+{
+   int bzerr;
+
+   BZ2_bzWrite(&bzerr,b,buf,len);
+   if(bzerr == BZ_OK){
+      return len;
+   }else{
+      return -1;
+   }
+}
+
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzflush) (BZFILE *b)
+{
+   /* do nothing now... */
+   return 0;
+}
+
+
+/*---------------------------------------------------*/
+void BZ_API(BZ2_bzclose) (BZFILE* b)
+{
+   int bzerr;
+   FILE *fp = ((bzFile *)b)->handle;
+
+   if (b==NULL) {return;}
+   if(((bzFile*)b)->writing){
+      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);
+      if(bzerr != BZ_OK){
+	 BZ2_bzWriteClose(NULL,b,1,NULL,NULL);
+      }
+   }else{
+      BZ2_bzReadClose(&bzerr,b);
+   }
+   if(fp!=stdin && fp!=stdout){
+      fclose(fp);
+   }
+}
+
+
+/*---------------------------------------------------*/
+/*--
+   return last error code
+--*/
+static char *bzerrorstrings[] = {
+       "OK"
+      ,"SEQUENCE_ERROR"
+      ,"PARAM_ERROR"
+      ,"MEM_ERROR"
+      ,"DATA_ERROR"
+      ,"DATA_ERROR_MAGIC"
+      ,"IO_ERROR"
+      ,"UNEXPECTED_EOF"
+      ,"OUTBUFF_FULL"
+      ,"CONFIG_ERROR"
+      ,"???"   /* for future */
+      ,"???"   /* for future */
+      ,"???"   /* for future */
+      ,"???"   /* for future */
+      ,"???"   /* for future */
+      ,"???"   /* for future */
+};
+
+
+const char * BZ_API(BZ2_bzerror) (BZFILE *b, int *errnum)
+{
+   int err = ((bzFile *)b)->lastErr;
+
+   if(err>0) err = 0;
+   *errnum = err;
+   return bzerrorstrings[err*-1];
+}
+#endif
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                           bzlib.c ---*/
+/*-------------------------------------------------------------*/
+
+#endif /* CONFIG_BZIP2 */
diff --git a/lib_generic/bzlib_crctable.c b/lib_generic/bzlib_crctable.c
new file mode 100644
index 0000000..63770cd
--- /dev/null
+++ b/lib_generic/bzlib_crctable.c
@@ -0,0 +1,148 @@
+#include <config.h>
+#ifdef CONFIG_BZIP2
+
+/*-------------------------------------------------------------*/
+/*--- Table for doing CRCs                                  ---*/
+/*---                                            crctable.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+
+#include "bzlib_private.h"
+
+/*--
+  I think this is an implementation of the AUTODIN-II,
+  Ethernet & FDDI 32-bit CRC standard.  Vaguely derived
+  from code by Rob Warnock, in Section 51 of the
+  comp.compression FAQ.
+--*/
+
+UInt32 BZ2_crc32Table[256] = {
+
+   /*-- Ugly, innit? --*/
+
+   0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L,
+   0x130476dcL, 0x17c56b6bL, 0x1a864db2L, 0x1e475005L,
+   0x2608edb8L, 0x22c9f00fL, 0x2f8ad6d6L, 0x2b4bcb61L,
+   0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL, 0x384fbdbdL,
+   0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,
+   0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L,
+   0x6a1936c8L, 0x6ed82b7fL, 0x639b0da6L, 0x675a1011L,
+   0x791d4014L, 0x7ddc5da3L, 0x709f7b7aL, 0x745e66cdL,
+   0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL, 0x95609039L,
+   0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,
+   0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L,
+   0xad2f2d84L, 0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL,
+   0xd4326d90L, 0xd0f37027L, 0xddb056feL, 0xd9714b49L,
+   0xc7361b4cL, 0xc3f706fbL, 0xceb42022L, 0xca753d95L,
+   0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,
+   0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL,
+   0x34867077L, 0x30476dc0L, 0x3d044b19L, 0x39c556aeL,
+   0x278206abL, 0x23431b1cL, 0x2e003dc5L, 0x2ac12072L,
+   0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L, 0x1fcdbb16L,
+   0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,
+   0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL,
+   0x6b93dddbL, 0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L,
+   0x5e9f46bfL, 0x5a5e5b08L, 0x571d7dd1L, 0x53dc6066L,
+   0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL, 0x40d816baL,
+   0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,
+   0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L,
+   0x8aad2b2fL, 0x8e6c3698L, 0x832f1041L, 0x87ee0df6L,
+   0x99a95df3L, 0x9d684044L, 0x902b669dL, 0x94ea7b2aL,
+   0xe0b41de7L, 0xe4750050L, 0xe9362689L, 0xedf73b3eL,
+   0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,
+   0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L,
+   0xd5b88683L, 0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL,
+   0x690ce0eeL, 0x6dcdfd59L, 0x608edb80L, 0x644fc637L,
+   0x7a089632L, 0x7ec98b85L, 0x738aad5cL, 0x774bb0ebL,
+   0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,
+   0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L,
+   0x251d3b9eL, 0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L,
+   0x36194d42L, 0x32d850f5L, 0x3f9b762cL, 0x3b5a6b9bL,
+   0x0315d626L, 0x07d4cb91L, 0x0a97ed48L, 0x0e56f0ffL,
+   0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,
+   0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L,
+   0xe22b20d2L, 0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL,
+   0xd727bbb6L, 0xd3e6a601L, 0xdea580d8L, 0xda649d6fL,
+   0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L, 0xc960ebb3L,
+   0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,
+   0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL,
+   0x9b3660c6L, 0x9ff77d71L, 0x92b45ba8L, 0x9675461fL,
+   0x8832161aL, 0x8cf30badL, 0x81b02d74L, 0x857130c3L,
+   0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L, 0x50c9b640L,
+   0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,
+   0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L,
+   0x68860bfdL, 0x6c47164aL, 0x61043093L, 0x65c52d24L,
+   0x119b4be9L, 0x155a565eL, 0x18197087L, 0x1cd86d30L,
+   0x029f3d35L, 0x065e2082L, 0x0b1d065bL, 0x0fdc1becL,
+   0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,
+   0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L,
+   0xc5a92679L, 0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L,
+   0xd6ad50a5L, 0xd26c4d12L, 0xdf2f6bcbL, 0xdbee767cL,
+   0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL, 0xeee2ed18L,
+   0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,
+   0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L,
+   0x9abc8bd5L, 0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL,
+   0xafb010b1L, 0xab710d06L, 0xa6322bdfL, 0xa2f33668L,
+   0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L, 0xb1f740b4L
+};
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                        crctable.c ---*/
+/*-------------------------------------------------------------*/
+
+#endif /* CONFIG_BZIP2 */
diff --git a/lib_generic/bzlib_decompress.c b/lib_generic/bzlib_decompress.c
new file mode 100644
index 0000000..a575052
--- /dev/null
+++ b/lib_generic/bzlib_decompress.c
@@ -0,0 +1,677 @@
+#include <config.h>
+#include <common.h>
+#include <watchdog.h>
+#ifdef CONFIG_BZIP2
+
+/*-------------------------------------------------------------*/
+/*--- Decompression machinery                               ---*/
+/*---                                          decompress.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+
+#include "bzlib_private.h"
+
+
+/*---------------------------------------------------*/
+static
+void makeMaps_d ( DState* s )
+{
+   Int32 i;
+   s->nInUse = 0;
+   for (i = 0; i < 256; i++)
+      if (s->inUse[i]) {
+	 s->seqToUnseq[s->nInUse] = i;
+	 s->nInUse++;
+      }
+}
+
+
+/*---------------------------------------------------*/
+#define RETURN(rrr)                               \
+   { retVal = rrr; goto save_state_and_return; };
+
+#define GET_BITS(lll,vvv,nnn)                     \
+   case lll: s->state = lll;                      \
+   while (True) {                                 \
+      if (s->bsLive >= nnn) {                     \
+	 UInt32 v;                                \
+	 v = (s->bsBuff >>                        \
+	     (s->bsLive-nnn)) & ((1 << nnn)-1);   \
+	 s->bsLive -= nnn;                        \
+	 vvv = v;                                 \
+	 break;                                   \
+      }                                           \
+      if (s->strm->avail_in == 0) RETURN(BZ_OK);  \
+      s->bsBuff                                   \
+	 = (s->bsBuff << 8) |                     \
+	   ((UInt32)                              \
+	      (*((UChar*)(s->strm->next_in))));   \
+      s->bsLive += 8;                             \
+      s->strm->next_in++;                         \
+      s->strm->avail_in--;                        \
+      s->strm->total_in_lo32++;                   \
+      if (s->strm->total_in_lo32 == 0)            \
+	 s->strm->total_in_hi32++;                \
+   }
+
+#define GET_UCHAR(lll,uuu)                        \
+   GET_BITS(lll,uuu,8)
+
+#define GET_BIT(lll,uuu)                          \
+   GET_BITS(lll,uuu,1)
+
+/*---------------------------------------------------*/
+#define GET_MTF_VAL(label1,label2,lval)           \
+{                                                 \
+   if (groupPos == 0) {                           \
+      groupNo++;                                  \
+      if (groupNo >= nSelectors)                  \
+	 RETURN(BZ_DATA_ERROR);                   \
+      groupPos = BZ_G_SIZE;                       \
+      gSel = s->selector[groupNo];                \
+      gMinlen = s->minLens[gSel];                 \
+      gLimit = &(s->limit[gSel][0]);              \
+      gPerm = &(s->perm[gSel][0]);                \
+      gBase = &(s->base[gSel][0]);                \
+   }                                              \
+   groupPos--;                                    \
+   zn = gMinlen;                                  \
+   GET_BITS(label1, zvec, zn);                    \
+   while (1) {                                    \
+      if (zn > 20 /* the longest code */)         \
+	 RETURN(BZ_DATA_ERROR);                   \
+      if (zvec <= gLimit[zn]) break;              \
+      zn++;                                       \
+      GET_BIT(label2, zj);                        \
+      zvec = (zvec << 1) | zj;                    \
+   };                                             \
+   if (zvec - gBase[zn] < 0                       \
+       || zvec - gBase[zn] >= BZ_MAX_ALPHA_SIZE)  \
+      RETURN(BZ_DATA_ERROR);                      \
+   lval = gPerm[zvec - gBase[zn]];                \
+}
+
+
+/*---------------------------------------------------*/
+Int32 BZ2_decompress ( DState* s )
+{
+   UChar      uc;
+   Int32      retVal;
+   Int32      minLen, maxLen;
+   bz_stream* strm = s->strm;
+
+   /* stuff that needs to be saved/restored */
+   Int32  i;
+   Int32  j;
+   Int32  t;
+   Int32  alphaSize;
+   Int32  nGroups;
+   Int32  nSelectors;
+   Int32  EOB;
+   Int32  groupNo;
+   Int32  groupPos;
+   Int32  nextSym;
+   Int32  nblockMAX;
+   Int32  nblock;
+   Int32  es;
+   Int32  N;
+   Int32  curr;
+   Int32  zt;
+   Int32  zn;
+   Int32  zvec;
+   Int32  zj;
+   Int32  gSel;
+   Int32  gMinlen;
+   Int32* gLimit;
+   Int32* gBase;
+   Int32* gPerm;
+
+   if (s->state == BZ_X_MAGIC_1) {
+      /*initialise the save area*/
+      s->save_i           = 0;
+      s->save_j           = 0;
+      s->save_t           = 0;
+      s->save_alphaSize   = 0;
+      s->save_nGroups     = 0;
+      s->save_nSelectors  = 0;
+      s->save_EOB         = 0;
+      s->save_groupNo     = 0;
+      s->save_groupPos    = 0;
+      s->save_nextSym     = 0;
+      s->save_nblockMAX   = 0;
+      s->save_nblock      = 0;
+      s->save_es          = 0;
+      s->save_N           = 0;
+      s->save_curr        = 0;
+      s->save_zt          = 0;
+      s->save_zn          = 0;
+      s->save_zvec        = 0;
+      s->save_zj          = 0;
+      s->save_gSel        = 0;
+      s->save_gMinlen     = 0;
+      s->save_gLimit      = NULL;
+      s->save_gBase       = NULL;
+      s->save_gPerm       = NULL;
+   }
+
+   /*restore from the save area*/
+   i           = s->save_i;
+   j           = s->save_j;
+   t           = s->save_t;
+   alphaSize   = s->save_alphaSize;
+   nGroups     = s->save_nGroups;
+   nSelectors  = s->save_nSelectors;
+   EOB         = s->save_EOB;
+   groupNo     = s->save_groupNo;
+   groupPos    = s->save_groupPos;
+   nextSym     = s->save_nextSym;
+   nblockMAX   = s->save_nblockMAX;
+   nblock      = s->save_nblock;
+   es          = s->save_es;
+   N           = s->save_N;
+   curr        = s->save_curr;
+   zt          = s->save_zt;
+   zn          = s->save_zn;
+   zvec        = s->save_zvec;
+   zj          = s->save_zj;
+   gSel        = s->save_gSel;
+   gMinlen     = s->save_gMinlen;
+   gLimit      = s->save_gLimit;
+   gBase       = s->save_gBase;
+   gPerm       = s->save_gPerm;
+
+   retVal = BZ_OK;
+
+   switch (s->state) {
+
+      GET_UCHAR(BZ_X_MAGIC_1, uc);
+      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_UCHAR(BZ_X_MAGIC_2, uc);
+      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_UCHAR(BZ_X_MAGIC_3, uc)
+      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)
+      if (s->blockSize100k < (BZ_HDR_0 + 1) ||
+	  s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);
+      s->blockSize100k -= BZ_HDR_0;
+
+      if (s->smallDecompress) {
+	 s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );
+	 s->ll4  = BZALLOC(
+		      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)
+		   );
+	 if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);
+      } else {
+	 s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );
+	 if (s->tt == NULL) RETURN(BZ_MEM_ERROR);
+      }
+
+      GET_UCHAR(BZ_X_BLKHDR_1, uc);
+
+      if (uc == 0x17) goto endhdr_2;
+      if (uc != 0x31) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_2, uc);
+      if (uc != 0x41) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_3, uc);
+      if (uc != 0x59) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_4, uc);
+      if (uc != 0x26) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_5, uc);
+      if (uc != 0x53) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_6, uc);
+      if (uc != 0x59) RETURN(BZ_DATA_ERROR);
+
+      s->currBlockNo++;
+      if (s->verbosity >= 2)
+	 VPrintf1 ( "\n    [%d: huff+mtf ", s->currBlockNo );
+
+      s->storedBlockCRC = 0;
+      GET_UCHAR(BZ_X_BCRC_1, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_2, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_3, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_4, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+
+      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);
+
+      s->origPtr = 0;
+      GET_UCHAR(BZ_X_ORIGPTR_1, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+      GET_UCHAR(BZ_X_ORIGPTR_2, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+      GET_UCHAR(BZ_X_ORIGPTR_3, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+
+      if (s->origPtr < 0)
+	 RETURN(BZ_DATA_ERROR);
+      if (s->origPtr > 10 + 100000*s->blockSize100k)
+	 RETURN(BZ_DATA_ERROR);
+
+      /*--- Receive the mapping table ---*/
+      for (i = 0; i < 16; i++) {
+	 GET_BIT(BZ_X_MAPPING_1, uc);
+	 if (uc == 1)
+	    s->inUse16[i] = True; else
+	    s->inUse16[i] = False;
+      }
+
+      for (i = 0; i < 256; i++) s->inUse[i] = False;
+
+      for (i = 0; i < 16; i++)
+	 if (s->inUse16[i])
+	    for (j = 0; j < 16; j++) {
+	       GET_BIT(BZ_X_MAPPING_2, uc);
+	       if (uc == 1) s->inUse[i * 16 + j] = True;
+	    }
+      makeMaps_d ( s );
+      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);
+      alphaSize = s->nInUse+2;
+
+      /*--- Now the selectors ---*/
+      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);
+      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);
+      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);
+      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);
+      for (i = 0; i < nSelectors; i++) {
+	 j = 0;
+	 while (True) {
+	    GET_BIT(BZ_X_SELECTOR_3, uc);
+	    if (uc == 0) break;
+	    j++;
+	    if (j >= nGroups) RETURN(BZ_DATA_ERROR);
+	 }
+	 s->selectorMtf[i] = j;
+      }
+
+      /*--- Undo the MTF values for the selectors. ---*/
+      {
+	 UChar pos[BZ_N_GROUPS], tmp, v;
+	 for (v = 0; v < nGroups; v++) pos[v] = v;
+
+	 for (i = 0; i < nSelectors; i++) {
+	    v = s->selectorMtf[i];
+	    tmp = pos[v];
+	    while (v > 0) { pos[v] = pos[v-1]; v--; }
+	    pos[0] = tmp;
+	    s->selector[i] = tmp;
+	 }
+      }
+
+      /*--- Now the coding tables ---*/
+      for (t = 0; t < nGroups; t++) {
+	 GET_BITS(BZ_X_CODING_1, curr, 5);
+	 for (i = 0; i < alphaSize; i++) {
+	    while (True) {
+	       if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);
+	       GET_BIT(BZ_X_CODING_2, uc);
+	       if (uc == 0) break;
+	       GET_BIT(BZ_X_CODING_3, uc);
+	       if (uc == 0) curr++; else curr--;
+	    }
+	    s->len[t][i] = curr;
+	 }
+      }
+
+      /*--- Create the Huffman decoding tables ---*/
+      for (t = 0; t < nGroups; t++) {
+	 minLen = 32;
+	 maxLen = 0;
+	 for (i = 0; i < alphaSize; i++) {
+	    if (s->len[t][i] > maxLen) maxLen = s->len[t][i];
+	    if (s->len[t][i] < minLen) minLen = s->len[t][i];
+	 }
+	 BZ2_hbCreateDecodeTables (
+	    &(s->limit[t][0]),
+	    &(s->base[t][0]),
+	    &(s->perm[t][0]),
+	    &(s->len[t][0]),
+	    minLen, maxLen, alphaSize
+	 );
+	 s->minLens[t] = minLen;
+      }
+
+      /*--- Now the MTF values ---*/
+
+      EOB      = s->nInUse+1;
+      nblockMAX = 100000 * s->blockSize100k;
+      groupNo  = -1;
+      groupPos = 0;
+
+      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;
+
+      /*-- MTF init --*/
+      {
+	 Int32 ii, jj, kk;
+	 kk = MTFA_SIZE-1;
+	 for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {
+	    for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
+	       s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);
+	       kk--;
+	    }
+	    s->mtfbase[ii] = kk + 1;
+	 }
+      }
+      /*-- end MTF init --*/
+
+      nblock = 0;
+      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);
+
+      while (True) {
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	WATCHDOG_RESET();
+#endif
+	 if (nextSym == EOB) break;
+
+	 if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {
+
+	    es = -1;
+	    N = 1;
+	    do {
+	       if (nextSym == BZ_RUNA) es = es + (0+1) * N; else
+	       if (nextSym == BZ_RUNB) es = es + (1+1) * N;
+	       N = N * 2;
+	       GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);
+	    }
+	       while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);
+
+	    es++;
+	    uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];
+	    s->unzftab[uc] += es;
+
+	    if (s->smallDecompress)
+	       while (es > 0) {
+		  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+		  s->ll16[nblock] = (UInt16)uc;
+		  nblock++;
+		  es--;
+	       }
+	    else
+	       while (es > 0) {
+		  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+		  s->tt[nblock] = (UInt32)uc;
+		  nblock++;
+		  es--;
+	       };
+
+	    continue;
+
+	 } else {
+
+	    if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+
+	    /*-- uc = MTF ( nextSym-1 ) --*/
+	    {
+	       Int32 ii, jj, kk, pp, lno, off;
+	       UInt32 nn;
+	       nn = (UInt32)(nextSym - 1);
+
+	       if (nn < MTFL_SIZE) {
+		  /* avoid general-case expense */
+		  pp = s->mtfbase[0];
+		  uc = s->mtfa[pp+nn];
+		  while (nn > 3) {
+		     Int32 z = pp+nn;
+		     s->mtfa[(z)  ] = s->mtfa[(z)-1];
+		     s->mtfa[(z)-1] = s->mtfa[(z)-2];
+		     s->mtfa[(z)-2] = s->mtfa[(z)-3];
+		     s->mtfa[(z)-3] = s->mtfa[(z)-4];
+		     nn -= 4;
+		  }
+		  while (nn > 0) {
+		     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--;
+		  };
+		  s->mtfa[pp] = uc;
+	       } else {
+		  /* general case */
+		  lno = nn / MTFL_SIZE;
+		  off = nn % MTFL_SIZE;
+		  pp = s->mtfbase[lno] + off;
+		  uc = s->mtfa[pp];
+		  while (pp > s->mtfbase[lno]) {
+		     s->mtfa[pp] = s->mtfa[pp-1]; pp--;
+		  };
+		  s->mtfbase[lno]++;
+		  while (lno > 0) {
+		     s->mtfbase[lno]--;
+		     s->mtfa[s->mtfbase[lno]]
+			= s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];
+		     lno--;
+		  }
+		  s->mtfbase[0]--;
+		  s->mtfa[s->mtfbase[0]] = uc;
+		  if (s->mtfbase[0] == 0) {
+		     kk = MTFA_SIZE-1;
+		     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+			WATCHDOG_RESET();
+#endif
+			for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
+			   s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];
+			   kk--;
+			}
+			s->mtfbase[ii] = kk + 1;
+		     }
+		  }
+	       }
+	    }
+	    /*-- end uc = MTF ( nextSym-1 ) --*/
+
+	    s->unzftab[s->seqToUnseq[uc]]++;
+	    if (s->smallDecompress)
+	       s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else
+	       s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);
+	    nblock++;
+
+	    GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);
+	    continue;
+	 }
+      }
+
+      /* Now we know what nblock is, we can do a better sanity
+	 check on s->origPtr.
+      */
+      if (s->origPtr < 0 || s->origPtr >= nblock)
+	 RETURN(BZ_DATA_ERROR);
+
+      s->state_out_len = 0;
+      s->state_out_ch  = 0;
+      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );
+      s->state = BZ_X_OUTPUT;
+      if (s->verbosity >= 2) VPrintf0 ( "rt+rld" );
+
+      /*-- Set up cftab to facilitate generation of T^(-1) --*/
+      s->cftab[0] = 0;
+      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];
+      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];
+
+      if (s->smallDecompress) {
+
+	 /*-- Make a copy of cftab, used in generation of T --*/
+	 for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];
+
+	 /*-- compute the T vector --*/
+	 for (i = 0; i < nblock; i++) {
+	    uc = (UChar)(s->ll16[i]);
+	    SET_LL(i, s->cftabCopy[uc]);
+	    s->cftabCopy[uc]++;
+	 }
+
+	 /*-- Compute T^(-1) by pointer reversal on T --*/
+	 i = s->origPtr;
+	 j = GET_LL(i);
+	 do {
+	    Int32 tmp = GET_LL(j);
+	    SET_LL(j, i);
+	    i = j;
+	    j = tmp;
+	 }
+	    while (i != s->origPtr);
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	WATCHDOG_RESET();
+#endif
+	 s->tPos = s->origPtr;
+	 s->nblock_used = 0;
+	 if (s->blockRandomised) {
+	    BZ_RAND_INIT_MASK;
+	    BZ_GET_SMALL(s->k0); s->nblock_used++;
+	    BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK;
+	 } else {
+	    BZ_GET_SMALL(s->k0); s->nblock_used++;
+	 }
+
+      } else {
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	WATCHDOG_RESET();
+#endif
+	 /*-- compute the T^(-1) vector --*/
+	 for (i = 0; i < nblock; i++) {
+	    uc = (UChar)(s->tt[i] & 0xff);
+	    s->tt[s->cftab[uc]] |= (i << 8);
+	    s->cftab[uc]++;
+	 }
+
+	 s->tPos = s->tt[s->origPtr] >> 8;
+	 s->nblock_used = 0;
+	 if (s->blockRandomised) {
+	    BZ_RAND_INIT_MASK;
+	    BZ_GET_FAST(s->k0); s->nblock_used++;
+	    BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK;
+	 } else {
+	    BZ_GET_FAST(s->k0); s->nblock_used++;
+	 }
+
+      }
+
+      RETURN(BZ_OK);
+
+
+    endhdr_2:
+
+      GET_UCHAR(BZ_X_ENDHDR_2, uc);
+      if (uc != 0x72) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_3, uc);
+      if (uc != 0x45) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_4, uc);
+      if (uc != 0x38) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_5, uc);
+      if (uc != 0x50) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_6, uc);
+      if (uc != 0x90) RETURN(BZ_DATA_ERROR);
+
+      s->storedCombinedCRC = 0;
+      GET_UCHAR(BZ_X_CCRC_1, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_2, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_3, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_4, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+
+      s->state = BZ_X_IDLE;
+      RETURN(BZ_STREAM_END);
+
+      default: AssertH ( False, 4001 );
+   }
+
+   AssertH ( False, 4002 );
+
+   save_state_and_return:
+
+   s->save_i           = i;
+   s->save_j           = j;
+   s->save_t           = t;
+   s->save_alphaSize   = alphaSize;
+   s->save_nGroups     = nGroups;
+   s->save_nSelectors  = nSelectors;
+   s->save_EOB         = EOB;
+   s->save_groupNo     = groupNo;
+   s->save_groupPos    = groupPos;
+   s->save_nextSym     = nextSym;
+   s->save_nblockMAX   = nblockMAX;
+   s->save_nblock      = nblock;
+   s->save_es          = es;
+   s->save_N           = N;
+   s->save_curr        = curr;
+   s->save_zt          = zt;
+   s->save_zn          = zn;
+   s->save_zvec        = zvec;
+   s->save_zj          = zj;
+   s->save_gSel        = gSel;
+   s->save_gMinlen     = gMinlen;
+   s->save_gLimit      = gLimit;
+   s->save_gBase       = gBase;
+   s->save_gPerm       = gPerm;
+
+   return retVal;
+}
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                      decompress.c ---*/
+/*-------------------------------------------------------------*/
+
+#endif /* CONFIG_BZIP2 */
diff --git a/lib_generic/bzlib_huffman.c b/lib_generic/bzlib_huffman.c
new file mode 100644
index 0000000..effae98
--- /dev/null
+++ b/lib_generic/bzlib_huffman.c
@@ -0,0 +1,232 @@
+#include <config.h>
+#ifdef CONFIG_BZIP2
+
+/*-------------------------------------------------------------*/
+/*--- Huffman coding low-level stuff                        ---*/
+/*---                                             huffman.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+
+#include "bzlib_private.h"
+
+/*---------------------------------------------------*/
+#define WEIGHTOF(zz0)  ((zz0) & 0xffffff00)
+#define DEPTHOF(zz1)   ((zz1) & 0x000000ff)
+#define MYMAX(zz2,zz3) ((zz2) > (zz3) ? (zz2) : (zz3))
+
+#define ADDWEIGHTS(zw1,zw2)                           \
+   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
+   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
+
+#define UPHEAP(z)                                     \
+{                                                     \
+   Int32 zz, tmp;                                     \
+   zz = z; tmp = heap[zz];                            \
+   while (weight[tmp] < weight[heap[zz >> 1]]) {      \
+      heap[zz] = heap[zz >> 1];                       \
+      zz >>= 1;                                       \
+   }                                                  \
+   heap[zz] = tmp;                                    \
+}
+
+#define DOWNHEAP(z)                                   \
+{                                                     \
+   Int32 zz, yy, tmp;                                 \
+   zz = z; tmp = heap[zz];                            \
+   while (True) {                                     \
+      yy = zz << 1;                                   \
+      if (yy > nHeap) break;                          \
+      if (yy < nHeap &&                               \
+	  weight[heap[yy+1]] < weight[heap[yy]])      \
+	 yy++;                                        \
+      if (weight[tmp] < weight[heap[yy]]) break;      \
+      heap[zz] = heap[yy];                            \
+      zz = yy;                                        \
+   }                                                  \
+   heap[zz] = tmp;                                    \
+}
+
+
+/*---------------------------------------------------*/
+void BZ2_hbMakeCodeLengths ( UChar *len,
+			     Int32 *freq,
+			     Int32 alphaSize,
+			     Int32 maxLen )
+{
+   /*--
+      Nodes and heap entries run from 1.  Entry 0
+      for both the heap and nodes is a sentinel.
+   --*/
+   Int32 nNodes, nHeap, n1, n2, i, j, k;
+   Bool  tooLong;
+
+   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
+   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
+   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ];
+
+   for (i = 0; i < alphaSize; i++)
+      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
+
+   while (True) {
+
+      nNodes = alphaSize;
+      nHeap = 0;
+
+      heap[0] = 0;
+      weight[0] = 0;
+      parent[0] = -2;
+
+      for (i = 1; i <= alphaSize; i++) {
+	 parent[i] = -1;
+	 nHeap++;
+	 heap[nHeap] = i;
+	 UPHEAP(nHeap);
+      }
+
+      AssertH( nHeap < (BZ_MAX_ALPHA_SIZE+2), 2001 );
+
+      while (nHeap > 1) {
+	 n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
+	 n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
+	 nNodes++;
+	 parent[n1] = parent[n2] = nNodes;
+	 weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
+	 parent[nNodes] = -1;
+	 nHeap++;
+	 heap[nHeap] = nNodes;
+	 UPHEAP(nHeap);
+      }
+
+      AssertH( nNodes < (BZ_MAX_ALPHA_SIZE * 2), 2002 );
+
+      tooLong = False;
+      for (i = 1; i <= alphaSize; i++) {
+	 j = 0;
+	 k = i;
+	 while (parent[k] >= 0) { k = parent[k]; j++; }
+	 len[i-1] = j;
+	 if (j > maxLen) tooLong = True;
+      }
+
+      if (! tooLong) break;
+
+      for (i = 1; i < alphaSize; i++) {
+	 j = weight[i] >> 8;
+	 j = 1 + (j / 2);
+	 weight[i] = j << 8;
+      }
+   }
+}
+
+
+/*---------------------------------------------------*/
+void BZ2_hbAssignCodes ( Int32 *code,
+			 UChar *length,
+			 Int32 minLen,
+			 Int32 maxLen,
+			 Int32 alphaSize )
+{
+   Int32 n, vec, i;
+
+   vec = 0;
+   for (n = minLen; n <= maxLen; n++) {
+      for (i = 0; i < alphaSize; i++)
+	 if (length[i] == n) { code[i] = vec; vec++; };
+      vec <<= 1;
+   }
+}
+
+
+/*---------------------------------------------------*/
+void BZ2_hbCreateDecodeTables ( Int32 *limit,
+				Int32 *base,
+				Int32 *perm,
+				UChar *length,
+				Int32 minLen,
+				Int32 maxLen,
+				Int32 alphaSize )
+{
+   Int32 pp, i, j, vec;
+
+   pp = 0;
+   for (i = minLen; i <= maxLen; i++)
+      for (j = 0; j < alphaSize; j++)
+	 if (length[j] == i) { perm[pp] = j; pp++; };
+
+   for (i = 0; i < BZ_MAX_CODE_LEN; i++) base[i] = 0;
+   for (i = 0; i < alphaSize; i++) base[length[i]+1]++;
+
+   for (i = 1; i < BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];
+
+   for (i = 0; i < BZ_MAX_CODE_LEN; i++) limit[i] = 0;
+   vec = 0;
+
+   for (i = minLen; i <= maxLen; i++) {
+      vec += (base[i+1] - base[i]);
+      limit[i] = vec-1;
+      vec <<= 1;
+   }
+   for (i = minLen + 1; i <= maxLen; i++)
+      base[i] = ((limit[i-1] + 1) << 1) - base[i];
+}
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                         huffman.c ---*/
+/*-------------------------------------------------------------*/
+
+#endif /* CONFIG_BZIP2 */
diff --git a/lib_generic/bzlib_private.h b/lib_generic/bzlib_private.h
new file mode 100644
index 0000000..87d8f94
--- /dev/null
+++ b/lib_generic/bzlib_private.h
@@ -0,0 +1,530 @@
+/*
+ * This file is a modified version of bzlib_private.h from the bzip2-1.0.2
+ * distribution which can be found at http://sources.redhat.com/bzip2/
+ */
+
+/*-------------------------------------------------------------*/
+/*--- Private header file for the library.                  ---*/
+/*---                                       bzlib_private.h ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+
+#ifndef _BZLIB_PRIVATE_H
+#define _BZLIB_PRIVATE_H
+
+#include <malloc.h>
+
+#include "bzlib.h"
+
+#ifndef BZ_NO_STDIO
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#endif
+
+
+/*-- General stuff. --*/
+
+#define BZ_VERSION  "1.0.2, 30-Dec-2001"
+
+typedef char            Char;
+typedef unsigned char   Bool;
+typedef unsigned char   UChar;
+typedef int             Int32;
+typedef unsigned int    UInt32;
+typedef short           Int16;
+typedef unsigned short  UInt16;
+
+#define True  ((Bool)1)
+#define False ((Bool)0)
+
+#ifndef __GNUC__
+#define __inline__  /* */
+#endif
+
+#ifndef BZ_NO_STDIO
+extern void BZ2_bz__AssertH__fail ( int errcode );
+#define AssertH(cond,errcode) \
+   { if (!(cond)) BZ2_bz__AssertH__fail ( errcode ); }
+#if BZ_DEBUG
+#define AssertD(cond,msg) \
+   { if (!(cond)) {       \
+      fprintf ( stderr,   \
+	"\n\nlibbzip2(debug build): internal error\n\t%s\n", msg );\
+      exit(1); \
+   }}
+#else
+#define AssertD(cond,msg) /* */
+#endif
+#define VPrintf0(zf) \
+   fprintf(stderr,zf)
+#define VPrintf1(zf,za1) \
+   fprintf(stderr,zf,za1)
+#define VPrintf2(zf,za1,za2) \
+   fprintf(stderr,zf,za1,za2)
+#define VPrintf3(zf,za1,za2,za3) \
+   fprintf(stderr,zf,za1,za2,za3)
+#define VPrintf4(zf,za1,za2,za3,za4) \
+   fprintf(stderr,zf,za1,za2,za3,za4)
+#define VPrintf5(zf,za1,za2,za3,za4,za5) \
+   fprintf(stderr,zf,za1,za2,za3,za4,za5)
+#else
+extern void bz_internal_error ( int errcode );
+#define AssertH(cond,errcode) \
+   { if (!(cond)) bz_internal_error ( errcode ); }
+#define AssertD(cond,msg) /* */
+#define VPrintf0(zf) /* */
+#define VPrintf1(zf,za1) /* */
+#define VPrintf2(zf,za1,za2) /* */
+#define VPrintf3(zf,za1,za2,za3) /* */
+#define VPrintf4(zf,za1,za2,za3,za4) /* */
+#define VPrintf5(zf,za1,za2,za3,za4,za5) /* */
+#endif
+
+
+#define BZALLOC(nnn) (strm->bzalloc)(strm->opaque,(nnn),1)
+#define BZFREE(ppp)  (strm->bzfree)(strm->opaque,(ppp))
+
+
+/*-- Header bytes. --*/
+
+#define BZ_HDR_B 0x42   /* 'B' */
+#define BZ_HDR_Z 0x5a   /* 'Z' */
+#define BZ_HDR_h 0x68   /* 'h' */
+#define BZ_HDR_0 0x30   /* '0' */
+
+/*-- Constants for the back end. --*/
+
+#define BZ_MAX_ALPHA_SIZE 258
+#define BZ_MAX_CODE_LEN    23
+
+#define BZ_RUNA 0
+#define BZ_RUNB 1
+
+#define BZ_N_GROUPS 6
+#define BZ_G_SIZE   50
+#define BZ_N_ITERS  4
+
+#define BZ_MAX_SELECTORS (2 + (900000 / BZ_G_SIZE))
+
+
+/*-- Stuff for randomising repetitive blocks. --*/
+
+extern Int32 BZ2_rNums[512];
+
+#define BZ_RAND_DECLS                          \
+   Int32 rNToGo;                               \
+   Int32 rTPos                                 \
+
+#define BZ_RAND_INIT_MASK                      \
+   s->rNToGo = 0;                              \
+   s->rTPos  = 0                               \
+
+#define BZ_RAND_MASK ((s->rNToGo == 1) ? 1 : 0)
+
+#define BZ_RAND_UPD_MASK                       \
+   if (s->rNToGo == 0) {                       \
+      s->rNToGo = BZ2_rNums[s->rTPos];         \
+      s->rTPos++;                              \
+      if (s->rTPos == 512) s->rTPos = 0;       \
+   }                                           \
+   s->rNToGo--;
+
+
+/*-- Stuff for doing CRCs. --*/
+
+extern UInt32 BZ2_crc32Table[256];
+
+#define BZ_INITIALISE_CRC(crcVar)              \
+{                                              \
+   crcVar = 0xffffffffL;                       \
+}
+
+#define BZ_FINALISE_CRC(crcVar)                \
+{                                              \
+   crcVar = ~(crcVar);                         \
+}
+
+#define BZ_UPDATE_CRC(crcVar,cha)              \
+{                                              \
+   crcVar = (crcVar << 8) ^                    \
+	    BZ2_crc32Table[(crcVar >> 24) ^    \
+			   ((UChar)cha)];      \
+}
+
+
+/*-- States and modes for compression. --*/
+
+#define BZ_M_IDLE      1
+#define BZ_M_RUNNING   2
+#define BZ_M_FLUSHING  3
+#define BZ_M_FINISHING 4
+
+#define BZ_S_OUTPUT    1
+#define BZ_S_INPUT     2
+
+#define BZ_N_RADIX 2
+#define BZ_N_QSORT 12
+#define BZ_N_SHELL 18
+#define BZ_N_OVERSHOOT (BZ_N_RADIX + BZ_N_QSORT + BZ_N_SHELL + 2)
+
+
+/*-- Structure holding all the compression-side stuff. --*/
+
+typedef
+   struct {
+      /* pointer back to the struct bz_stream */
+      bz_stream* strm;
+
+      /* mode this stream is in, and whether inputting */
+      /* or outputting data */
+      Int32    mode;
+      Int32    state;
+
+      /* remembers avail_in when flush/finish requested */
+      UInt32   avail_in_expect;
+
+      /* for doing the block sorting */
+      UInt32*  arr1;
+      UInt32*  arr2;
+      UInt32*  ftab;
+      Int32    origPtr;
+
+      /* aliases for arr1 and arr2 */
+      UInt32*  ptr;
+      UChar*   block;
+      UInt16*  mtfv;
+      UChar*   zbits;
+
+      /* for deciding when to use the fallback sorting algorithm */
+      Int32    workFactor;
+
+      /* run-length-encoding of the input */
+      UInt32   state_in_ch;
+      Int32    state_in_len;
+      BZ_RAND_DECLS;
+
+      /* input and output limits and current posns */
+      Int32    nblock;
+      Int32    nblockMAX;
+      Int32    numZ;
+      Int32    state_out_pos;
+
+      /* map of bytes used in block */
+      Int32    nInUse;
+      Bool     inUse[256];
+      UChar    unseqToSeq[256];
+
+      /* the buffer for bit stream creation */
+      UInt32   bsBuff;
+      Int32    bsLive;
+
+      /* block and combined CRCs */
+      UInt32   blockCRC;
+      UInt32   combinedCRC;
+
+      /* misc administratium */
+      Int32    verbosity;
+      Int32    blockNo;
+      Int32    blockSize100k;
+
+      /* stuff for coding the MTF values */
+      Int32    nMTF;
+      Int32    mtfFreq    [BZ_MAX_ALPHA_SIZE];
+      UChar    selector   [BZ_MAX_SELECTORS];
+      UChar    selectorMtf[BZ_MAX_SELECTORS];
+
+      UChar    len     [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    code    [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    rfreq   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      /* second dimension: only 3 needed; 4 makes index calculations faster */
+      UInt32   len_pack[BZ_MAX_ALPHA_SIZE][4];
+
+   }
+   EState;
+
+
+/*-- externs for compression. --*/
+
+extern void
+BZ2_blockSort ( EState* );
+
+extern void
+BZ2_compressBlock ( EState*, Bool );
+
+extern void
+BZ2_bsInitWrite ( EState* );
+
+extern void
+BZ2_hbAssignCodes ( Int32*, UChar*, Int32, Int32, Int32 );
+
+extern void
+BZ2_hbMakeCodeLengths ( UChar*, Int32*, Int32, Int32 );
+
+
+/*-- states for decompression. --*/
+
+#define BZ_X_IDLE        1
+#define BZ_X_OUTPUT      2
+
+#define BZ_X_MAGIC_1     10
+#define BZ_X_MAGIC_2     11
+#define BZ_X_MAGIC_3     12
+#define BZ_X_MAGIC_4     13
+#define BZ_X_BLKHDR_1    14
+#define BZ_X_BLKHDR_2    15
+#define BZ_X_BLKHDR_3    16
+#define BZ_X_BLKHDR_4    17
+#define BZ_X_BLKHDR_5    18
+#define BZ_X_BLKHDR_6    19
+#define BZ_X_BCRC_1      20
+#define BZ_X_BCRC_2      21
+#define BZ_X_BCRC_3      22
+#define BZ_X_BCRC_4      23
+#define BZ_X_RANDBIT     24
+#define BZ_X_ORIGPTR_1   25
+#define BZ_X_ORIGPTR_2   26
+#define BZ_X_ORIGPTR_3   27
+#define BZ_X_MAPPING_1   28
+#define BZ_X_MAPPING_2   29
+#define BZ_X_SELECTOR_1  30
+#define BZ_X_SELECTOR_2  31
+#define BZ_X_SELECTOR_3  32
+#define BZ_X_CODING_1    33
+#define BZ_X_CODING_2    34
+#define BZ_X_CODING_3    35
+#define BZ_X_MTF_1       36
+#define BZ_X_MTF_2       37
+#define BZ_X_MTF_3       38
+#define BZ_X_MTF_4       39
+#define BZ_X_MTF_5       40
+#define BZ_X_MTF_6       41
+#define BZ_X_ENDHDR_2    42
+#define BZ_X_ENDHDR_3    43
+#define BZ_X_ENDHDR_4    44
+#define BZ_X_ENDHDR_5    45
+#define BZ_X_ENDHDR_6    46
+#define BZ_X_CCRC_1      47
+#define BZ_X_CCRC_2      48
+#define BZ_X_CCRC_3      49
+#define BZ_X_CCRC_4      50
+
+
+/*-- Constants for the fast MTF decoder. --*/
+
+#define MTFA_SIZE 4096
+#define MTFL_SIZE 16
+
+
+/*-- Structure holding all the decompression-side stuff. --*/
+
+typedef
+   struct {
+      /* pointer back to the struct bz_stream */
+      bz_stream* strm;
+
+      /* state indicator for this stream */
+      Int32    state;
+
+      /* for doing the final run-length decoding */
+      UChar    state_out_ch;
+      Int32    state_out_len;
+      Bool     blockRandomised;
+      BZ_RAND_DECLS;
+
+      /* the buffer for bit stream reading */
+      UInt32   bsBuff;
+      Int32    bsLive;
+
+      /* misc administratium */
+      Int32    blockSize100k;
+      Bool     smallDecompress;
+      Int32    currBlockNo;
+      Int32    verbosity;
+
+      /* for undoing the Burrows-Wheeler transform */
+      Int32    origPtr;
+      UInt32   tPos;
+      Int32    k0;
+      Int32    unzftab[256];
+      Int32    nblock_used;
+      Int32    cftab[257];
+      Int32    cftabCopy[257];
+
+      /* for undoing the Burrows-Wheeler transform (FAST) */
+      UInt32   *tt;
+
+      /* for undoing the Burrows-Wheeler transform (SMALL) */
+      UInt16   *ll16;
+      UChar    *ll4;
+
+      /* stored and calculated CRCs */
+      UInt32   storedBlockCRC;
+      UInt32   storedCombinedCRC;
+      UInt32   calculatedBlockCRC;
+      UInt32   calculatedCombinedCRC;
+
+      /* map of bytes used in block */
+      Int32    nInUse;
+      Bool     inUse[256];
+      Bool     inUse16[16];
+      UChar    seqToUnseq[256];
+
+      /* for decoding the MTF values */
+      UChar    mtfa   [MTFA_SIZE];
+      Int32    mtfbase[256 / MTFL_SIZE];
+      UChar    selector   [BZ_MAX_SELECTORS];
+      UChar    selectorMtf[BZ_MAX_SELECTORS];
+      UChar    len  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+
+      Int32    limit  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    base   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    perm   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    minLens[BZ_N_GROUPS];
+
+      /* save area for scalars in the main decompress code */
+      Int32    save_i;
+      Int32    save_j;
+      Int32    save_t;
+      Int32    save_alphaSize;
+      Int32    save_nGroups;
+      Int32    save_nSelectors;
+      Int32    save_EOB;
+      Int32    save_groupNo;
+      Int32    save_groupPos;
+      Int32    save_nextSym;
+      Int32    save_nblockMAX;
+      Int32    save_nblock;
+      Int32    save_es;
+      Int32    save_N;
+      Int32    save_curr;
+      Int32    save_zt;
+      Int32    save_zn;
+      Int32    save_zvec;
+      Int32    save_zj;
+      Int32    save_gSel;
+      Int32    save_gMinlen;
+      Int32*   save_gLimit;
+      Int32*   save_gBase;
+      Int32*   save_gPerm;
+
+   }
+   DState;
+
+
+/*-- Macros for decompression. --*/
+
+#define BZ_GET_FAST(cccc)                     \
+    s->tPos = s->tt[s->tPos];                 \
+    cccc = (UChar)(s->tPos & 0xff);           \
+    s->tPos >>= 8;
+
+#define BZ_GET_FAST_C(cccc)                   \
+    c_tPos = c_tt[c_tPos];                    \
+    cccc = (UChar)(c_tPos & 0xff);            \
+    c_tPos >>= 8;
+
+#define SET_LL4(i,n)                                          \
+   { if (((i) & 0x1) == 0)                                    \
+	s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0xf0) | (n); else    \
+	s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0x0f) | ((n) << 4);  \
+   }
+
+#define GET_LL4(i)                             \
+   ((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 0x4)) & 0xF)
+
+#define SET_LL(i,n)                          \
+   { s->ll16[i] = (UInt16)(n & 0x0000ffff);  \
+     SET_LL4(i, n >> 16);                    \
+   }
+
+#define GET_LL(i) \
+   (((UInt32)s->ll16[i]) | (GET_LL4(i) << 16))
+
+#define BZ_GET_SMALL(cccc)                            \
+      cccc = BZ2_indexIntoF ( s->tPos, s->cftab );    \
+      s->tPos = GET_LL(s->tPos);
+
+
+/*-- externs for decompression. --*/
+
+extern Int32
+BZ2_indexIntoF ( Int32, Int32* );
+
+extern Int32
+BZ2_decompress ( DState* );
+
+extern void
+BZ2_hbCreateDecodeTables ( Int32*, Int32*, Int32*, UChar*,
+			   Int32,  Int32, Int32 );
+
+
+#endif
+
+
+/*-- BZ_NO_STDIO seems to make NULL disappear on some platforms. --*/
+
+#ifdef BZ_NO_STDIO
+#ifndef NULL
+#define NULL 0
+#endif
+#endif
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                   bzlib_private.h ---*/
+/*-------------------------------------------------------------*/
diff --git a/lib_generic/bzlib_randtable.c b/lib_generic/bzlib_randtable.c
new file mode 100644
index 0000000..a0dd573
--- /dev/null
+++ b/lib_generic/bzlib_randtable.c
@@ -0,0 +1,128 @@
+#include <config.h>
+#ifdef CONFIG_BZIP2
+
+/*-------------------------------------------------------------*/
+/*--- Table for randomising repetitive blocks               ---*/
+/*---                                           randtable.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software.  If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote
+     products derived from this software without specific prior written
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+
+#include "bzlib_private.h"
+
+
+/*---------------------------------------------*/
+Int32 BZ2_rNums[512] = {
+   619, 720, 127, 481, 931, 816, 813, 233, 566, 247,
+   985, 724, 205, 454, 863, 491, 741, 242, 949, 214,
+   733, 859, 335, 708, 621, 574, 73, 654, 730, 472,
+   419, 436, 278, 496, 867, 210, 399, 680, 480, 51,
+   878, 465, 811, 169, 869, 675, 611, 697, 867, 561,
+   862, 687, 507, 283, 482, 129, 807, 591, 733, 623,
+   150, 238, 59, 379, 684, 877, 625, 169, 643, 105,
+   170, 607, 520, 932, 727, 476, 693, 425, 174, 647,
+   73, 122, 335, 530, 442, 853, 695, 249, 445, 515,
+   909, 545, 703, 919, 874, 474, 882, 500, 594, 612,
+   641, 801, 220, 162, 819, 984, 589, 513, 495, 799,
+   161, 604, 958, 533, 221, 400, 386, 867, 600, 782,
+   382, 596, 414, 171, 516, 375, 682, 485, 911, 276,
+   98, 553, 163, 354, 666, 933, 424, 341, 533, 870,
+   227, 730, 475, 186, 263, 647, 537, 686, 600, 224,
+   469, 68, 770, 919, 190, 373, 294, 822, 808, 206,
+   184, 943, 795, 384, 383, 461, 404, 758, 839, 887,
+   715, 67, 618, 276, 204, 918, 873, 777, 604, 560,
+   951, 160, 578, 722, 79, 804, 96, 409, 713, 940,
+   652, 934, 970, 447, 318, 353, 859, 672, 112, 785,
+   645, 863, 803, 350, 139, 93, 354, 99, 820, 908,
+   609, 772, 154, 274, 580, 184, 79, 626, 630, 742,
+   653, 282, 762, 623, 680, 81, 927, 626, 789, 125,
+   411, 521, 938, 300, 821, 78, 343, 175, 128, 250,
+   170, 774, 972, 275, 999, 639, 495, 78, 352, 126,
+   857, 956, 358, 619, 580, 124, 737, 594, 701, 612,
+   669, 112, 134, 694, 363, 992, 809, 743, 168, 974,
+   944, 375, 748, 52, 600, 747, 642, 182, 862, 81,
+   344, 805, 988, 739, 511, 655, 814, 334, 249, 515,
+   897, 955, 664, 981, 649, 113, 974, 459, 893, 228,
+   433, 837, 553, 268, 926, 240, 102, 654, 459, 51,
+   686, 754, 806, 760, 493, 403, 415, 394, 687, 700,
+   946, 670, 656, 610, 738, 392, 760, 799, 887, 653,
+   978, 321, 576, 617, 626, 502, 894, 679, 243, 440,
+   680, 879, 194, 572, 640, 724, 926, 56, 204, 700,
+   707, 151, 457, 449, 797, 195, 791, 558, 945, 679,
+   297, 59, 87, 824, 713, 663, 412, 693, 342, 606,
+   134, 108, 571, 364, 631, 212, 174, 643, 304, 329,
+   343, 97, 430, 751, 497, 314, 983, 374, 822, 928,
+   140, 206, 73, 263, 980, 736, 876, 478, 430, 305,
+   170, 514, 364, 692, 829, 82, 855, 953, 676, 246,
+   369, 970, 294, 750, 807, 827, 150, 790, 288, 923,
+   804, 378, 215, 828, 592, 281, 565, 555, 710, 82,
+   896, 831, 547, 261, 524, 462, 293, 465, 502, 56,
+   661, 821, 976, 991, 658, 869, 905, 758, 745, 193,
+   768, 550, 608, 933, 378, 286, 215, 979, 792, 961,
+   61, 688, 793, 644, 986, 403, 106, 366, 905, 644,
+   372, 567, 466, 434, 645, 210, 389, 550, 919, 135,
+   780, 773, 635, 389, 707, 100, 626, 958, 165, 504,
+   920, 176, 193, 713, 857, 265, 203, 50, 668, 108,
+   645, 990, 626, 197, 510, 357, 358, 850, 858, 364,
+   936, 638
+};
+
+
+/*-------------------------------------------------------------*/
+/*--- end                                       randtable.c ---*/
+/*-------------------------------------------------------------*/
+
+#endif /* CONFIG_BZIP2 */
diff --git a/lib_generic/crc32.c b/lib_generic/crc32.c
new file mode 100644
index 0000000..0bc4c51
--- /dev/null
+++ b/lib_generic/crc32.c
@@ -0,0 +1,203 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+#include <common.h>	/* to get command definitions like CFG_CMD_JFFS2 */
+#endif
+
+#include "zlib.h"
+
+#define local static
+#define ZEXPORT	/* empty */
+#ifdef DUPLICATE_DEFINTION
+unsigned long crc32 (unsigned long, const unsigned char *, unsigned int);
+#endif
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uLongf crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uLong c;
+  int n, k;
+  uLong poly;            /* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uLongf crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+#if 0
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uLongf * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uLongf *)crc_table;
+}
+#endif
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+#ifdef DUPLICATE
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const Bytef *buf;
+    uInt len;
+#endif
+uint32_t crc32 (uint32_t crc, const unsigned char *buf, uint len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) || \
+	((CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY))
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+
+    return crc;
+}
+
+#endif	/* CFG_CMD_JFFS2 */
diff --git a/lib_generic/ctype.c b/lib_generic/ctype.c
new file mode 100644
index 0000000..6ed0468
--- /dev/null
+++ b/lib_generic/ctype.c
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  linux/lib/ctype.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/ctype.h>
+
+unsigned char _ctype[] = {
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 0-7 */
+_C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,		/* 8-15 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 16-23 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 24-31 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,			/* 32-39 */
+_P,_P,_P,_P,_P,_P,_P,_P,			/* 40-47 */
+_D,_D,_D,_D,_D,_D,_D,_D,			/* 48-55 */
+_D,_D,_P,_P,_P,_P,_P,_P,			/* 56-63 */
+_P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,	/* 64-71 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 72-79 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 80-87 */
+_U,_U,_U,_P,_P,_P,_P,_P,			/* 88-95 */
+_P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,	/* 96-103 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 104-111 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 112-119 */
+_L,_L,_L,_P,_P,_P,_P,_C,			/* 120-127 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,   /* 160-175 */
+_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,       /* 176-191 */
+_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,       /* 192-207 */
+_U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,       /* 208-223 */
+_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,       /* 224-239 */
+_L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L};      /* 240-255 */
diff --git a/lib_generic/display_options.c b/lib_generic/display_options.c
new file mode 100644
index 0000000..9b23dd2
--- /dev/null
+++ b/lib_generic/display_options.c
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+int display_options (void)
+{
+	extern char version_string[];
+
+#if defined(BUILD_TAG)
+	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
+#else
+	printf ("\n\n%s\n\n", version_string);
+#endif
+	return 0;
+}
+
+/*
+ * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
+ * allow for optional trailing string (like "\n")
+ */
+void print_size (unsigned long long size, const char *s)
+{
+	ulong m, n;
+	ulong d = 1 << 20;		/* 1 MB */
+	char  c = 'M';
+
+	if (size < d) {			/* print in kB */
+		c = 'k';
+		d = 1 << 10;
+	}
+
+	n = size / d;
+
+	m = (10 * (size - (n * d)) + (d / 2) ) / d;
+
+	if (m >= 10) {
+		m -= 10;
+		n += 1;
+	}
+
+	printf ("%2ld", n);
+	if (m) {
+		printf (".%ld", m);
+	}
+	printf (" %cB%s", c, s);
+}
diff --git a/lib_generic/ldiv.c b/lib_generic/ldiv.c
new file mode 100644
index 0000000..5d231a2
--- /dev/null
+++ b/lib_generic/ldiv.c
@@ -0,0 +1,55 @@
+/* Copyright (C) 1992, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+typedef struct {
+	long    quot;
+	long    rem;
+} ldiv_t;
+/* Return the `ldiv_t' representation of NUMER over DENOM.  */
+ldiv_t
+ldiv (long int numer, long int denom)
+{
+  ldiv_t result;
+
+  result.quot = numer / denom;
+  result.rem = numer % denom;
+
+  /* The ANSI standard says that |QUOT| <= |NUMER / DENOM|, where
+     NUMER / DENOM is to be computed in infinite precision.  In
+     other words, we should always truncate the quotient towards
+     zero, never -infinity.  Machine division and remainer may
+     work either way when one or both of NUMER or DENOM is
+     negative.  If only one is negative and QUOT has been
+     truncated towards -infinity, REM will have the same sign as
+     DENOM and the opposite sign of NUMER; if both are negative
+     and QUOT has been truncated towards -infinity, REM will be
+     positive (will have the opposite sign of NUMER).  These are
+     considered `wrong'.  If both are NUM and DENOM are positive,
+     RESULT will always be positive.  This all boils down to: if
+     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
+     case, to get the right answer, add 1 to QUOT and subtract
+     DENOM from REM.  */
+
+  if (numer >= 0 && result.rem < 0)
+    {
+      ++result.quot;
+      result.rem -= denom;
+    }
+
+  return result;
+}
diff --git a/lib_generic/string.c b/lib_generic/string.c
new file mode 100644
index 0000000..ba4adee
--- /dev/null
+++ b/lib_generic/string.c
@@ -0,0 +1,684 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * stupid library routines.. The optimized versions should generally be found
+ * as inline code in <asm-xx/string.h>
+ *
+ * These are buggy as well..
+ *
+ * * Fri Jun 25 1999, Ingo Oeser <ioe@informatik.tu-chemnitz.de>
+ * -  Added strsep() which will replace strtok() soon (because strsep() is
+ *    reentrant and should be faster). Use only strsep() in new code, please.
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+
+#ifndef __HAVE_ARCH_STRNICMP 
+/**
+ * strnicmp - Case insensitive, length-limited string comparison
+ * @s1: One string
+ * @s2: The other string
+ * @len: the maximum number of characters to compare
+ */
+int strnicmp(const char *s1, const char *s2, size_t len)
+{
+	/* Yes, Virginia, it had better be unsigned */
+	unsigned char c1, c2;
+
+	c1 = 0;	c2 = 0;
+	if (len) {
+		do {
+			c1 = *s1; c2 = *s2;
+			s1++; s2++;
+			if (!c1)
+				break;
+			if (!c2)
+				break;
+			if (c1 == c2)
+				continue;
+			c1 = tolower(c1);
+			c2 = tolower(c2);
+			if (c1 != c2)
+				break;
+		} while (--len);
+	}
+	return (int)c1 - (int)c2;
+}
+#endif
+char * ___strtok;
+
+#ifndef __HAVE_ARCH_STRCPY
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+		/* nothing */;
+	return tmp;
+}
+#endif
+
+#define __HAVE_ARCH_STRNCPY
+#ifndef __HAVE_ARCH_STRNCPY
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+	char *tmp = dest;
+
+	while (count-- && (*dest++ = *src++) != '\0')
+		/* nothing */;
+
+	return tmp;
+}
+#endif
+
+#define __HAVE_ARCH_STRCAT
+#ifndef __HAVE_ARCH_STRCAT
+/**
+ * strcat - Append one %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ */
+char * strcat(char * dest, const char * src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+		dest++;
+	while ((*dest++ = *src++) != '\0')
+		;
+
+	return tmp;
+}
+#endif
+
+#define __HAVE_ARCH_STRNCAT
+#ifndef __HAVE_ARCH_STRNCAT
+/**
+ * strncat - Append a length-limited, %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ * @count: The maximum numbers of bytes to copy
+ *
+ * Note that in contrast to strncpy, strncat ensures the result is
+ * terminated.
+ */
+char * strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count) {
+		while (*dest)
+			dest++;
+		while ((*dest++ = *src++)) {
+			if (--count == 0) {
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+
+	return tmp;
+}
+#endif
+
+#define __HAVE_ARCH_STRCMP
+#ifndef __HAVE_ARCH_STRCMP
+/**
+ * strcmp - Compare two strings
+ * @cs: One string
+ * @ct: Another string
+ */
+int strcmp(const char * cs,const char * ct)
+{
+	register signed char __res;
+
+	while (1) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+	}
+
+	return __res;
+}
+#endif
+
+#define __HAVE_ARCH_STRNCMP
+#ifndef __HAVE_ARCH_STRNCMP
+/**
+ * strncmp - Compare two length-limited strings
+ * @cs: One string
+ * @ct: Another string
+ * @count: The maximum number of bytes to compare
+ */
+int strncmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+		count--;
+	}
+
+	return __res;
+}
+#endif
+
+#define __HAVE_ARCH_STRCHR
+#ifndef __HAVE_ARCH_STRCHR
+/**
+ * strchr - Find the first occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+#endif
+
+#define __HAVE_ARCH_STRRCHR
+#ifndef __HAVE_ARCH_STRRCHR
+/**
+ * strrchr - Find the last occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strrchr(const char * s, int c)
+{
+       const char *p = s + strlen(s);
+       do {
+	   if (*p == (char)c)
+	       return (char *)p;
+       } while (--p >= s);
+       return NULL;
+}
+#endif
+
+#define __HAVE_ARCH_STRLEN
+#ifndef __HAVE_ARCH_STRLEN
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#define __HAVE_ARCH_STRNLEN
+#ifndef __HAVE_ARCH_STRNLEN
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+	const char *sc;
+
+	for (sc = s; count-- && *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#define __HAVE_ARCH_STRDUP
+#ifndef __HAVE_ARCH_STRDUP
+char * strdup(const char *s)
+{
+	char *new;
+
+	if ((s == NULL)	||
+	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
+		return NULL;
+	}
+
+	strcpy (new, s);
+	return new;
+}
+#endif
+
+#define __HAVE_ARCH_STRSPN
+#ifndef __HAVE_ARCH_STRSPN
+/**
+ * strspn - Calculate the length of the initial substring of @s which only
+ * 	contain letters in @accept
+ * @s: The string to be searched
+ * @accept: The string to search for
+ */
+size_t strspn(const char *s, const char *accept)
+{
+	const char *p;
+	const char *a;
+	size_t count = 0;
+
+	for (p = s; *p != '\0'; ++p) {
+		for (a = accept; *a != '\0'; ++a) {
+			if (*p == *a)
+				break;
+		}
+		if (*a == '\0')
+			return count;
+		++count;
+	}
+
+	return count;
+}
+#endif
+
+#define __HAVE_ARCH_STRPBRK
+#ifndef __HAVE_ARCH_STRPBRK
+/**
+ * strpbrk - Find the first occurrence of a set of characters
+ * @cs: The string to be searched
+ * @ct: The characters to search for
+ */
+char * strpbrk(const char * cs,const char * ct)
+{
+	const char *sc1,*sc2;
+
+	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
+		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
+			if (*sc1 == *sc2)
+				return (char *) sc1;
+		}
+	}
+	return NULL;
+}
+#endif
+
+#define __HAVE_ARCH_STRTOK
+#ifndef __HAVE_ARCH_STRTOK
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : ___strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		___strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	___strtok = send;
+	return (sbegin);
+}
+#endif
+
+#define __HAVE_ARCH_STRSEP
+#ifndef __HAVE_ARCH_STRSEP
+/**
+ * strsep - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * strsep() updates @s to point after the token, ready for the next call.
+ *
+ * It returns empty tokens, too, behaving exactly like the libc function
+ * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
+ * Same semantics, slimmer shape. ;)
+ */
+char * strsep(char **s, const char *ct)
+{
+	char *sbegin = *s, *end;
+
+	if (sbegin == NULL)
+		return NULL;
+
+	end = strpbrk(sbegin, ct);
+	if (end)
+		*end++ = '\0';
+	*s = end;
+
+	return sbegin;
+}
+#endif
+
+#define __HAVE_ARCH_STRSWAB
+#ifndef __HAVE_ARCH_STRSWAB
+/**
+ * strswab - swap adjacent even and odd bytes in %NUL-terminated string
+ * s: address of the string
+ *
+ * returns the address of the swapped string or NULL on error. If
+ * string length is odd, last byte is untouched.
+ */
+char *strswab(const char *s)
+{
+	char *p, *q;
+
+	if ((NULL == s) || ('\0' == *s)) {
+		return (NULL);
+	}
+
+	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
+		char  tmp;
+
+		tmp = *p;
+		*p  = *q;
+		*q  = tmp;
+	}
+
+	return (char *) s;
+}
+#endif
+
+#define __HAVE_ARCH_MEMSET
+#ifndef __HAVE_ARCH_MEMSET
+/**
+ * memset - Fill a region of memory with the given value
+ * @s: Pointer to the start of the area.
+ * @c: The byte to fill the area with
+ * @count: The size of the area.
+ *
+ * Do not use memset() to access IO space, use memset_io() instead.
+ */
+void * memset(void * s,int c,size_t count)
+{
+	char *xs = (char *) s;
+
+	while (count--)
+		*xs++ = c;
+
+	return s;
+}
+#endif
+
+#define __HAVE_ARCH_BCOPY
+#ifndef __HAVE_ARCH_BCOPY
+/**
+ * bcopy - Copy one area of memory to another
+ * @src: Where to copy from
+ * @dest: Where to copy to
+ * @count: The size of the area.
+ *
+ * Note that this is the same as memcpy(), with the arguments reversed.
+ * memcpy() is the standard, bcopy() is a legacy BSD function.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+char * bcopy(const char * src, char * dest, int count)
+{
+	char *tmp = dest;
+
+	while (count--)
+		*tmp++ = *src++;
+
+	return dest;
+}
+#endif
+
+#define __HAVE_ARCH_MEMCPY
+#ifndef __HAVE_ARCH_MEMCPY
+/**
+ * memcpy - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void * memcpy(void * dest,const void *src,size_t count)
+{
+	char *tmp = (char *) dest, *s = (char *) src;
+
+	while (count--)
+		*tmp++ = *s++;
+
+	return dest;
+}
+#endif
+
+/**
+ * memcpy16 - memcpy with 16bit accesses
+ * @pvDst: Where to copy to
+ * @pvSrc: Where to copy from
+ * @iLen: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void* memcpy16( void* pvDst, const void* pvSrc, __kernel_size_t iLen )
+{
+        const u16* puhSrc = (const u16*) pvSrc;
+        const u8*  pucSrc;
+        u16* puhDst = (u16*) pvDst;
+        u8*  pucDst;
+
+        /* larger chunks */
+	for( ; iLen >= 32; iLen -= 32 ) {
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+                *puhDst++ = *puhSrc++;
+	}
+
+        /* byte chunks */
+        pucSrc = (const u8*) puhSrc;
+        pucDst = (u8*) puhDst;
+
+	for( ; iLen > 0; iLen-- )
+                *pucDst++ = *pucSrc++;
+
+        return pvDst;
+}
+
+/**
+ * memcpy32 - memcpy with 32bit accesses
+ * @pvDst: Where to copy to
+ * @pvSrc: Where to copy from
+ * @iLen: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void* memcpy32( void* pvDst, const void* pvSrc, __kernel_size_t iLen )
+{
+        const u32* puiSrc = (const u32*) pvSrc;
+        const u8*  pucSrc;
+        u32* puiDst = (u32*) pvDst;
+        u8*  pucDst;
+
+        /* larger chunks */
+	for( ; iLen >= 32; iLen -= 32 ) {
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+                *puiDst++ = *puiSrc++;
+	}
+
+        /* byte chunks */
+        pucSrc = (const u8*) puiSrc;
+        pucDst = (u8*) puiDst;
+        
+	for( ; iLen > 0; iLen-- )
+                *pucDst++ = *pucSrc++;
+
+        return pvDst;
+}
+
+#define __HAVE_ARCH_MEMMOVE
+#ifndef __HAVE_ARCH_MEMMOVE
+/**
+ * memmove - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * Unlike memcpy(), memmove() copes with overlapping areas.
+ */
+void * memmove(void * dest,const void *src,size_t count)
+{
+	char *tmp, *s;
+
+	if (dest <= src) {
+		tmp = (char *) dest;
+		s = (char *) src;
+		while (count--)
+			*tmp++ = *s++;
+		}
+	else {
+		tmp = (char *) dest + count;
+		s = (char *) src + count;
+		while (count--)
+			*--tmp = *--s;
+		}
+
+	return dest;
+}
+#endif
+
+#define __HAVE_ARCH_MEMCMP
+#ifndef __HAVE_ARCH_MEMCMP
+/**
+ * memcmp - Compare two areas of memory
+ * @cs: One area of memory
+ * @ct: Another area of memory
+ * @count: The size of the area.
+ */
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	int res = 0;
+
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+#endif
+
+#define __HAVE_ARCH_MEMSCAN
+#ifndef __HAVE_ARCH_MEMSCAN
+/**
+ * memscan - Find a character in an area of memory.
+ * @addr: The memory area
+ * @c: The byte to search for
+ * @size: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or 1 byte past
+ * the area if @c is not found
+ */
+void * memscan(void * addr, int c, size_t size)
+{
+	unsigned char * p = (unsigned char *) addr;
+
+	while (size) {
+		if (*p == c)
+			return (void *) p;
+		p++;
+		size--;
+	}
+	return (void *) p;
+}
+#endif
+
+#define __HAVE_ARCH_STRSTR
+#ifndef __HAVE_ARCH_STRSTR
+/**
+ * strstr - Find the first substring in a %NUL terminated string
+ * @s1: The string to be searched
+ * @s2: The string to search for
+ */
+char * strstr(const char * s1,const char * s2)
+{
+	int l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+	return NULL;
+}
+#endif
+
+#define __HAVE_ARCH_MEMCHR
+#ifndef __HAVE_ARCH_MEMCHR
+/**
+ * memchr - Find a character in an area of memory.
+ * @s: The memory area
+ * @c: The byte to search for
+ * @n: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or %NULL
+ * if @c is not found
+ */
+void *memchr(const void *s, int c, size_t n)
+{
+	const unsigned char *p = s;
+	while (n-- != 0) {
+		if ((unsigned char)c == *p++) {
+			return (void *)(p-1);
+		}
+	}
+	return NULL;
+}
+
+#endif
diff --git a/lib_generic/vsprintf.c b/lib_generic/vsprintf.c
new file mode 100644
index 0000000..2740f2e
--- /dev/null
+++ b/lib_generic/vsprintf.c
@@ -0,0 +1,385 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#include <common.h>
+#if !defined (CONFIG_PANIC_HANG)
+#include <command.h>
+/*cmd_boot.c*/
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+	unsigned long result = 0,value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+long simple_strtol(const char *cp,char **endp,unsigned int base)
+{
+	if(*cp=='-')
+		return -simple_strtoul(cp+1,endp,base);
+	return simple_strtoul(cp,endp,base);
+}
+
+#ifdef CFG_64BIT_STRTOUL
+unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit (cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit (*cp) && (value = isdigit (*cp)
+				? *cp - '0'
+				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *) cp;
+	return result;
+}
+#endif /* CFG_64BIT_STRTOUL */
+
+/* we use this so that we can do without the ctype library */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SPECIAL	32		/* 0x */
+#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
+
+#define do_div(n,base) ({ \
+	int __res; \
+	__res = ((unsigned long) n) % (unsigned) base; \
+	n = ((unsigned long) n) / (unsigned) base; \
+	__res; \
+})
+
+#ifdef CFG_64BIT_VSPRINTF
+static char * number(char * str, long long num, int base, int size, int precision ,int type)
+#else
+static char * number(char * str, long num, int base, int size, int precision ,int type)
+#endif
+{
+	char c,sign,tmp[66];
+	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
+	int i;
+
+	if (type & LARGE)
+		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	if (type & LEFT)
+		type &= ~ZEROPAD;
+	if (base < 2 || base > 36)
+		return 0;
+	c = (type & ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type & SIGN) {
+		if (num < 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type & PLUS) {
+			sign = '+';
+			size--;
+		} else if (type & SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type & SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++]='0';
+	else while (num != 0)
+		tmp[i++] = digits[do_div(num,base)];
+	if (i > precision)
+		precision = i;
+	size -= precision;
+	if (!(type&(ZEROPAD+LEFT)))
+		while(size-->0)
+			*str++ = ' ';
+	if (sign)
+		*str++ = sign;
+	if (type & SPECIAL) {
+		if (base==8)
+			*str++ = '0';
+		else if (base==16) {
+			*str++ = '0';
+			*str++ = digits[33];
+		}
+	}
+	if (!(type & LEFT))
+		while (size-- > 0)
+			*str++ = c;
+	while (i < precision--)
+		*str++ = '0';
+	while (i-- > 0)
+		*str++ = tmp[i];
+	while (size-- > 0)
+		*str++ = ' ';
+	return str;
+}
+
+/* Forward decl. needed for IP address printing stuff... */
+int sprintf(char * buf, const char *fmt, ...);
+
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	int len;
+#ifdef CFG_64BIT_VSPRINTF
+	unsigned long long num;
+#else
+	unsigned long num;
+#endif
+	int i, base;
+	char * str;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'q' for integer fields */
+
+	for (str=buf ; *fmt ; ++fmt) {
+		if (*fmt != '%') {
+			*str++ = *fmt;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+		repeat:
+			++fmt;		/* this also skips first '%' */
+			switch (*fmt) {
+				case '-': flags |= LEFT; goto repeat;
+				case '+': flags |= PLUS; goto repeat;
+				case ' ': flags |= SPACE; goto repeat;
+				case '#': flags |= SPECIAL; goto repeat;
+				case '0': flags |= ZEROPAD; goto repeat;
+				}
+
+		/* get field width */
+		field_width = -1;
+		if (is_digit(*fmt))
+			field_width = skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width < 0) {
+				field_width = -field_width;
+				flags |= LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (is_digit(*fmt))
+				precision = skip_atoi(&fmt);
+			else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision < 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+		case 'c':
+			if (!(flags & LEFT))
+				while (--field_width > 0)
+					*str++ = ' ';
+			*str++ = (unsigned char) va_arg(args, int);
+			while (--field_width > 0)
+				*str++ = ' ';
+			continue;
+
+		case 's':
+			s = va_arg(args, char *);
+			if (!s)
+				s = "<NULL>";
+
+			len = strnlen(s, precision);
+
+			if (!(flags & LEFT))
+				while (len < field_width--)
+					*str++ = ' ';
+			for (i = 0; i < len; ++i)
+				*str++ = *s++;
+			while (len < field_width--)
+				*str++ = ' ';
+			continue;
+
+		case 'p':
+			if (field_width == -1) {
+				field_width = 2*sizeof(void *);
+				flags |= ZEROPAD;
+			}
+			str = number(str,
+				(unsigned long) va_arg(args, void *), 16,
+				field_width, precision, flags);
+			continue;
+
+
+		case 'n':
+			if (qualifier == 'l') {
+				long * ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else {
+				int * ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			continue;
+
+		case '%':
+			*str++ = '%';
+			continue;
+
+		/* integer number formats - set up the flags and "break" */
+		case 'o':
+			base = 8;
+			break;
+
+		case 'X':
+			flags |= LARGE;
+		case 'x':
+			base = 16;
+			break;
+
+		case 'd':
+		case 'i':
+			flags |= SIGN;
+		case 'u':
+			break;
+
+		default:
+			*str++ = '%';
+			if (*fmt)
+				*str++ = *fmt;
+			else
+				--fmt;
+			continue;
+		}
+#ifdef CFG_64BIT_VSPRINTF
+		if (qualifier == 'q')  /* "quad" for 64 bit variables */
+			num = va_arg(args, unsigned long long);
+		else
+#endif
+		if (qualifier == 'l')
+			num = va_arg(args, unsigned long);
+		else if (qualifier == 'h') {
+			num = (unsigned short) va_arg(args, int);
+			if (flags & SIGN)
+				num = (short) num;
+		} else if (flags & SIGN)
+			num = va_arg(args, int);
+		else
+			num = va_arg(args, unsigned int);
+		str = number(str, num, base, field_width, precision, flags);
+	}
+	*str = '\0';
+	return str-buf;
+}
+
+int sprintf(char * buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsprintf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
+
+void panic(const char *fmt, ...)
+{
+	va_list	args;
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	putc('\n');
+	va_end(args);
+#if defined (CONFIG_PANIC_HANG)
+	hang();
+#else
+	udelay (100000);	/* allow messages to go out */
+	do_reset (NULL, 0, 0, NULL);
+#endif
+}
diff --git a/lib_generic/zlib.c b/lib_generic/zlib.c
new file mode 100644
index 0000000..668ac8f
--- /dev/null
+++ b/lib_generic/zlib.c
@@ -0,0 +1,2161 @@
+/*
+ * This file is derived from various .h and .c files from the zlib-0.95
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.  See zlib.h for conditions of
+ * distribution and use.
+ *
+ * Changes that have been made include:
+ * - changed functions not used outside this file to "local"
+ * - added minCompression parameter to deflateInit2
+ * - added Z_PACKET_FLUSH (see zlib.h for details)
+ * - added inflateIncomp
+ */
+
+/*+++++*/
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* From: zutil.h,v 1.9 1995/05/03 17:27:12 jloup Exp */
+
+#define _Z_UTIL_H
+
+#include "zlib.h"
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+#define FAR
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern char *z_errmsg[]; /* indexed by 1-zlib_error */
+
+#define ERR_RETURN(strm,err) return (strm->msg=z_errmsg[1-err], err)
+/* To be used only when the state is known to be valid */
+
+#ifndef NULL
+#define NULL	((void *) 0)
+#endif
+
+	/* common constants */
+
+#define DEFLATED   8
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+	 /* functions */
+
+#include <linux/string.h>
+#define zmemcpy memcpy
+#define zmemzero(dest, len)	memset(dest, 0, len)
+
+/* Diagnostic functions */
+#ifdef DEBUG_ZLIB
+#  include <stdio.h>
+#  ifndef verbose
+#    define verbose 0
+#  endif
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (*check_func) OF((uLong check, Bytef *buf, uInt len));
+
+/* voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size)); */
+/* void   zcfree  OF((voidpf opaque, voidpf ptr)); */
+
+#define ZALLOC(strm, items, size) \
+	   (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr, size)	\
+	   (*((strm)->zfree))((strm)->opaque, (voidpf)(addr), (size))
+#define TRY_FREE(s, p, n) {if (p) ZFREE(s, p, n);}
+
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/*+++++*/
+/* infblock.h -- header to use infblock.c
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state FAR inflate_blocks_statef;
+
+local inflate_blocks_statef * inflate_blocks_new OF((
+    z_stream *z,
+    check_func c,               /* check function */
+    uInt w));                   /* window size */
+
+local int inflate_blocks OF((
+    inflate_blocks_statef *,
+    z_stream *,
+    int));                      /* initial return code */
+
+local void inflate_blocks_reset OF((
+    inflate_blocks_statef *,
+    z_stream *,
+    uLongf *));                  /* check value on output */
+
+local int inflate_blocks_free OF((
+    inflate_blocks_statef *,
+    z_stream *,
+    uLongf *));                  /* check value on output */
+
+local int inflate_addhistory OF((
+    inflate_blocks_statef *,
+    z_stream *));
+
+local int inflate_packet_flush OF((
+    inflate_blocks_statef *));
+
+/*+++++*/
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Huffman code lookup table entry--this entry is four bytes for machines
+   that have 16-bit pointers (e.g. PC's in the small or medium model). */
+
+typedef struct inflate_huft_s FAR inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        /* number of extra bits or operation */
+      Byte Bits;        /* number of bits in this code or subcode */
+    } what;
+    uInt Nalloc;	/* number of these allocated here */
+    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
+  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
+  union {
+    uInt Base;          /* literal, length base, or distance base */
+    inflate_huft *Next; /* pointer to next level of table */
+  } more;
+};
+
+#ifdef DEBUG_ZLIB
+  local uInt inflate_hufts;
+#endif
+
+local int inflate_trees_bits OF((
+    uIntf *,                    /* 19 code lengths */
+    uIntf *,                    /* bits tree desired/actual depth */
+    inflate_huft * FAR *,       /* bits tree result */
+    z_stream *));               /* for zalloc, zfree functions */
+
+local int inflate_trees_dynamic OF((
+    uInt,                       /* number of literal/length codes */
+    uInt,                       /* number of distance codes */
+    uIntf *,                    /* that many (total) code lengths */
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    z_stream *));               /* for zalloc, zfree functions */
+
+local int inflate_trees_fixed OF((
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *));     /* distance tree result */
+
+local int inflate_trees_free OF((
+    inflate_huft *,             /* tables to free */
+    z_stream *));               /* for zfree function */
+
+
+/*+++++*/
+/* infcodes.h -- header to use infcodes.c
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state FAR inflate_codes_statef;
+
+local inflate_codes_statef *inflate_codes_new OF((
+    uInt, uInt,
+    inflate_huft *, inflate_huft *,
+    z_stream *));
+
+local int inflate_codes OF((
+    inflate_blocks_statef *,
+    z_stream *,
+    int));
+
+local void inflate_codes_free OF((
+    inflate_codes_statef *,
+    z_stream *));
+
+
+/*+++++*/
+/* inflate.c -- zlib interface to inflate modules
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* inflate private state */
+struct internal_state {
+
+  /* mode */
+  enum {
+      METHOD,   /* waiting for method byte */
+      FLAG,     /* waiting for flag byte */
+      BLOCKS,   /* decompressing blocks */
+      CHECK4,   /* four check bytes to go */
+      CHECK3,   /* three check bytes to go */
+      CHECK2,   /* two check bytes to go */
+      CHECK1,   /* one check byte to go */
+      DONE,     /* finished check, done */
+      BAD}      /* got an error--stay here */
+    mode;               /* current inflate mode */
+
+  /* mode dependent information */
+  union {
+    uInt method;        /* if FLAGS, method byte */
+    struct {
+      uLong was;                /* computed check value */
+      uLong need;               /* stream check value */
+    } check;            /* if CHECK, check values to compare */
+    uInt marker;        /* if BAD, inflateSync's marker bytes count */
+  } sub;        /* submode */
+
+  /* mode independent information */
+  int  nowrap;          /* flag for no wrapper */
+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
+  inflate_blocks_statef
+    *blocks;            /* current inflate_blocks state */
+
+};
+
+
+int inflateReset(z)
+z_stream *z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
+  inflate_blocks_reset(z->state->blocks, z, &c);
+  Trace((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+
+int inflateEnd(z)
+z_stream *z;
+{
+  uLong c;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z, &c);
+  ZFREE(z, z->state, sizeof(struct internal_state));
+  z->state = Z_NULL;
+  Trace((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int inflateInit2(z, w)
+z_stream *z;
+int w;
+{
+  /* initialize state */
+  if (z == Z_NULL)
+    return Z_STREAM_ERROR;
+/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
+/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
+  if ((z->state = (struct internal_state FAR *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  /* handle undocumented nowrap option (no zlib header or check) */
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  /* set window size */
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  /* create inflate_blocks state */
+  if ((z->state->blocks =
+       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, 1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Trace((stderr, "inflate: allocated\n"));
+
+  /* reset state */
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+int inflateInit(z)
+z_stream *z;
+{
+  return inflateInit2(z, DEF_WBITS);
+}
+
+
+#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int inflate(z, f)
+z_stream *z;
+int f;
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->next_in == Z_NULL)
+    return Z_STREAM_ERROR;
+  r = Z_BUF_ERROR;
+  while (1) switch (z->state->mode)
+  {
+    case METHOD:
+      NEEDBYTE
+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
+      {
+	z->state->mode = BAD;
+	z->msg = "unknown compression method";
+	z->state->sub.marker = 5;       /* can't try inflateSync */
+	break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+	z->state->mode = BAD;
+	z->msg = "invalid window size";
+	z->state->sub.marker = 5;       /* can't try inflateSync */
+	break;
+      }
+      z->state->mode = FLAG;
+    case FLAG:
+      NEEDBYTE
+      if ((b = NEXTBYTE) & 0x20)
+      {
+	z->state->mode = BAD;
+	z->msg = "invalid reserved bit";
+	z->state->sub.marker = 5;       /* can't try inflateSync */
+	break;
+      }
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+	z->state->mode = BAD;
+	z->msg = "incorrect header check";
+	z->state->sub.marker = 5;       /* can't try inflateSync */
+	break;
+      }
+      Trace((stderr, "inflate: zlib header ok\n"));
+      z->state->mode = BLOCKS;
+    case BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
+	  r = inflate_packet_flush(z->state->blocks);
+      if (r == Z_DATA_ERROR)
+      {
+	z->state->mode = BAD;
+	z->state->sub.marker = 0;       /* can try inflateSync */
+	break;
+      }
+      if (r != Z_STREAM_END)
+	return r;
+      r = Z_OK;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+	z->state->mode = DONE;
+	break;
+      }
+      z->state->mode = CHECK4;
+    case CHECK4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = CHECK3;
+    case CHECK3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = CHECK2;
+    case CHECK2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = CHECK1;
+    case CHECK1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+	z->state->mode = BAD;
+	z->msg = "incorrect data check";
+	z->state->sub.marker = 5;       /* can't try inflateSync */
+	break;
+      }
+      Trace((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = DONE;
+    case DONE:
+      return Z_STREAM_END;
+    case BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+
+ empty:
+  if (f != Z_PACKET_FLUSH)
+    return r;
+  z->state->mode = BAD;
+  z->state->sub.marker = 0;       /* can try inflateSync */
+  return Z_DATA_ERROR;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+
+int inflateIncomp(z)
+z_stream *z;
+{
+    if (z->state->mode != BLOCKS)
+	return Z_DATA_ERROR;
+    return inflate_addhistory(z->state->blocks, z);
+}
+
+
+int inflateSync(z)
+z_stream *z;
+{
+  uInt n;       /* number of bytes to look at */
+  Bytef *p;     /* pointer to bytes */
+  uInt m;       /* number of marker bytes found in a row */
+  uLong r, w;   /* temporaries to save total_in and total_out */
+
+  /* set up */
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->mode != BAD)
+  {
+    z->state->mode = BAD;
+    z->state->sub.marker = 0;
+  }
+  if ((n = z->avail_in) == 0)
+    return Z_BUF_ERROR;
+  p = z->next_in;
+  m = z->state->sub.marker;
+
+  /* search */
+  while (n && m < 4)
+  {
+    if (*p == (Byte)(m < 2 ? 0 : 0xff))
+      m++;
+    else if (*p)
+      m = 0;
+    else
+      m = 4 - m;
+    p++, n--;
+  }
+
+  /* restore */
+  z->total_in += p - z->next_in;
+  z->next_in = p;
+  z->avail_in = n;
+  z->state->sub.marker = m;
+
+  /* return no joy or set up to restart on a new block */
+  if (m != 4)
+    return Z_DATA_ERROR;
+  r = z->total_in;  w = z->total_out;
+  inflateReset(z);
+  z->total_in = r;  z->total_out = w;
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+#undef NEEDBYTE
+#undef NEXTBYTE
+
+/*+++++*/
+/* infutil.h -- types and macros common to blocks and codes
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* inflate blocks semi-private state */
+struct inflate_blocks_state {
+
+  /* mode */
+  enum {
+      TYPE,     /* get type bits (3, including end bit) */
+      LENS,     /* get lengths for stored */
+      STORED,   /* processing stored block */
+      TABLE,    /* get table lengths */
+      BTREE,    /* get bit lengths tree for a dynamic block */
+      DTREE,    /* get length, distance trees for a dynamic block */
+      CODES,    /* processing fixed or dynamic block */
+      DRY,      /* output remaining window bytes */
+      DONEB,     /* finished last block, done */
+      BADB}      /* got a data error--stuck here */
+    mode;               /* current inflate_block mode */
+
+  /* mode dependent information */
+  union {
+    uInt left;          /* if STORED, bytes left to copy */
+    struct {
+      uInt table;               /* table lengths (14 bits) */
+      uInt index;               /* index into blens (or border) */
+      uIntf *blens;             /* bit lengths of codes */
+      uInt bb;                  /* bit length tree depth */
+      inflate_huft *tb;         /* bit length decoding tree */
+      int nblens;		/* # elements allocated at blens */
+    } trees;            /* if DTREE, decoding info for trees */
+    struct {
+      inflate_huft *tl, *td;    /* trees to free */
+      inflate_codes_statef
+	 *codes;
+    } decode;           /* if CODES, current state */
+  } sub;                /* submode */
+  uInt last;            /* true if this block is the last block */
+
+  /* mode independent information */
+  uInt bitk;            /* bits in bit buffer */
+  uLong bitb;           /* bit buffer */
+  Bytef *window;        /* sliding window */
+  Bytef *end;           /* one byte after sliding window */
+  Bytef *read;          /* window read pointer */
+  Bytef *write;         /* window write pointer */
+  check_func checkfn;   /* check function */
+  uLong check;          /* check on output */
+
+};
+
+
+/* defines for inflate input/output */
+/*   update pointers and return */
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+/*   get bytes and bits */
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+/*   output bytes */
+#define WAVAIL (q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=WAVAIL;}
+#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+/*   load local pointers */
+#define LOAD {LOADIN LOADOUT}
+
+/*
+ * The IBM 150 firmware munges the data right after _etext[].  This
+ * protects it. -- Cort
+ */
+#if 0
+local uInt protect_mask[] = {0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0 ,0};
+#endif
+/* And'ing with mask[n] masks the lower n bits */
+local uInt inflate_mask[] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+/* copy as much as possible from the sliding window to the output area */
+local int inflate_flush OF((
+    inflate_blocks_statef *,
+    z_stream *,
+    int));
+
+/*+++++*/
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+local int inflate_fast OF((
+    uInt,
+    uInt,
+    inflate_huft *,
+    inflate_huft *,
+    inflate_blocks_statef *,
+    z_stream *));
+
+
+/*+++++*/
+/* infblock.c -- interpret and process block types to last block
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* Table for deflate from PKZIP's appnote.txt. */
+local uInt border[] = { /* Order of the bit length code lengths */
+	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+/*
+   Notes beyond the 1.93a appnote.txt:
+
+   1. Distance pointers never point before the beginning of the output
+      stream.
+   2. Distance pointers can point back across blocks, up to 32k away.
+   3. There is an implied maximum of 7 bits for the bit length table and
+      15 bits for the actual data.
+   4. If only one code exists, then it is encoded using one bit.  (Zero
+      would be more efficient, but perhaps a little confusing.)  If two
+      codes exist, they are coded using one bit each (0 and 1).
+   5. There is no way of sending zero distance codes--a dummy must be
+      sent if there are none.  (History: a pre 2.0 version of PKZIP would
+      store blocks with no distance codes, but this was discovered to be
+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+      zero distance codes, which is sent as one code of zero bits in
+      length.
+   6. There are up to 286 literal/length codes.  Code 256 represents the
+      end-of-block.  Note however that the static length tree defines
+      288 codes just to fill out the Huffman codes.  Codes 286 and 287
+      cannot be used though, since there is no length base or extra bits
+      defined for them.  Similarily, there are up to 30 distance codes.
+      However, static trees define 32 codes (all 5 bits) to fill out the
+      Huffman codes, but the last two had better not show up in the data.
+   7. Unzip can check dynamic Huffman blocks for complete code sets.
+      The exception is that a single code would not be complete (see #4).
+   8. The five bits following the block type is really the number of
+      literal codes sent minus 257.
+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+      (1+6+6).  Therefore, to output three times the length, you output
+      three codes (1+1+1), whereas to output four times the same length,
+      you only need two codes (1+3).  Hmm.
+  10. In the tree reconstruction algorithm, Code = Code + Increment
+      only if BitLength(i) is not zero.  (Pretty obvious.)
+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+  12. Note: length code 284 can represent 227-258, but length code 285
+      really is 258.  The last length deserves its own, short code
+      since it gets used a lot in very redundant files.  The length
+      258 is special since 258 - 3 (the min match length) is 255.
+  13. The literal/length and distance code bit lengths are read as a
+      single stream of lengths.  It is possible (and advantageous) for
+      a repeat code (16, 17, or 18) to go across the boundary between
+      the two sets of lengths.
+ */
+
+
+local void inflate_blocks_reset(s, z, c)
+inflate_blocks_statef *s;
+z_stream *z;
+uLongf *c;
+{
+  if (s->checkfn != Z_NULL)
+    *c = s->check;
+  if (s->mode == BTREE || s->mode == DTREE)
+    ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
+  if (s->mode == CODES)
+  {
+    inflate_codes_free(s->sub.decode.codes, z);
+    inflate_trees_free(s->sub.decode.td, z);
+    inflate_trees_free(s->sub.decode.tl, z);
+  }
+  s->mode = TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    s->check = (*s->checkfn)(0L, Z_NULL, 0);
+  if (z->outcb != Z_NULL)
+    (*z->outcb)(Z_NULL, 0);
+  Trace((stderr, "inflate:   blocks reset\n"));
+}
+
+
+local inflate_blocks_statef *inflate_blocks_new(z, c, w)
+z_stream *z;
+check_func c;
+uInt w;
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s, sizeof(struct inflate_blocks_state));
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = TYPE;
+  Trace((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, &s->check);
+  return s;
+}
+
+
+local int inflate_blocks(s, z, r)
+inflate_blocks_statef *s;
+z_stream *z;
+int r;
+{
+  uInt t;               /* temporary storage */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input based on current state */
+  while (1) switch (s->mode)
+  {
+    case TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+	case 0:                         /* stored */
+	  Trace((stderr, "inflate:     stored block%s\n",
+		 s->last ? " (last)" : ""));
+	  DUMPBITS(3)
+	  t = k & 7;                    /* go to byte boundary */
+	  DUMPBITS(t)
+	  s->mode = LENS;               /* get length of stored block */
+	  break;
+	case 1:                         /* fixed */
+	  Trace((stderr, "inflate:     fixed codes block%s\n",
+		 s->last ? " (last)" : ""));
+	  {
+	    uInt bl, bd;
+	    inflate_huft *tl, *td;
+
+	    inflate_trees_fixed(&bl, &bd, &tl, &td);
+	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+	    if (s->sub.decode.codes == Z_NULL)
+	    {
+	      r = Z_MEM_ERROR;
+	      LEAVE
+	    }
+	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
+	    s->sub.decode.td = Z_NULL;
+	  }
+	  DUMPBITS(3)
+	  s->mode = CODES;
+	  break;
+	case 2:                         /* dynamic */
+	  Trace((stderr, "inflate:     dynamic codes block%s\n",
+		 s->last ? " (last)" : ""));
+	  DUMPBITS(3)
+	  s->mode = TABLE;
+	  break;
+	case 3:                         /* illegal */
+	  DUMPBITS(3)
+	  s->mode = BADB;
+	  z->msg = "invalid block type";
+	  r = Z_DATA_ERROR;
+	  LEAVE
+      }
+      break;
+    case LENS:
+      NEEDBITS(32)
+      if (((~b) >> 16) != (b & 0xffff))
+      {
+	s->mode = BADB;
+	z->msg = "invalid stored block lengths";
+	r = Z_DATA_ERROR;
+	LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      /* dump bits */
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? STORED : TYPE;
+      break;
+    case STORED:
+      if (n == 0)
+	LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      zmemcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+	break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+	      z->total_out + (q >= s->read ? q - s->read :
+	      (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? DRY : TYPE;
+      break;
+    case TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+#ifndef PKZIP_BUG_WORKAROUND
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+	s->mode = BADB;
+	z->msg = "too many length or distance symbols";
+	r = Z_DATA_ERROR;
+	LEAVE
+      }
+#endif
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if (t < 19)
+	t = 19;
+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+	r = Z_MEM_ERROR;
+	LEAVE
+      }
+      s->sub.trees.nblens = t;
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = BTREE;
+    case BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+	NEEDBITS(3)
+	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+	DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+			     &s->sub.trees.tb, z);
+      if (t != Z_OK)
+      {
+	r = t;
+	if (r == Z_DATA_ERROR)
+	  s->mode = BADB;
+	LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = DTREE;
+    case DTREE:
+      while (t = s->sub.trees.table,
+	     s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+	inflate_huft *h;
+	uInt i, j, c;
+
+	t = s->sub.trees.bb;
+	NEEDBITS(t)
+	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+	t = h->word.what.Bits;
+	c = h->more.Base;
+	if (c < 16)
+	{
+	  DUMPBITS(t)
+	  s->sub.trees.blens[s->sub.trees.index++] = c;
+	}
+	else /* c == 16..18 */
+	{
+	  i = c == 18 ? 7 : c - 14;
+	  j = c == 18 ? 11 : 3;
+	  NEEDBITS(t + i)
+	  DUMPBITS(t)
+	  j += (uInt)b & inflate_mask[i];
+	  DUMPBITS(i)
+	  i = s->sub.trees.index;
+	  t = s->sub.trees.table;
+	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+	      (c == 16 && i < 1))
+	  {
+	    s->mode = BADB;
+	    z->msg = "invalid bit length repeat";
+	    r = Z_DATA_ERROR;
+	    LEAVE
+	  }
+	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+	  do {
+	    s->sub.trees.blens[i++] = c;
+	  } while (--j);
+	  s->sub.trees.index = i;
+	}
+      }
+      inflate_trees_free(s->sub.trees.tb, z);
+      s->sub.trees.tb = Z_NULL;
+      {
+	uInt bl, bd;
+	inflate_huft *tl, *td;
+	inflate_codes_statef *c;
+
+	bl = 9;         /* must be <= 9 for lookahead assumptions */
+	bd = 6;         /* must be <= 9 for lookahead assumptions */
+	t = s->sub.trees.table;
+	t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+				  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
+	if (t != Z_OK)
+	{
+	  if (t == (uInt)Z_DATA_ERROR)
+	    s->mode = BADB;
+	  r = t;
+	  LEAVE
+	}
+	Tracev((stderr, "inflate:       trees ok\n"));
+	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+	{
+	  inflate_trees_free(td, z);
+	  inflate_trees_free(tl, z);
+	  r = Z_MEM_ERROR;
+	  LEAVE
+	}
+	ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
+	s->sub.decode.codes = c;
+	s->sub.decode.tl = tl;
+	s->sub.decode.td = td;
+      }
+      s->mode = CODES;
+    case CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+	return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      inflate_trees_free(s->sub.decode.td, z);
+      inflate_trees_free(s->sub.decode.tl, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+	      z->total_out + (q >= s->read ? q - s->read :
+	      (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+	s->mode = TYPE;
+	break;
+      }
+      if (k > 7)              /* return unused byte, if any */
+      {
+	Assert(k < 16, "inflate_codes grabbed too many bytes")
+	k -= 8;
+	n++;
+	p--;                    /* can always return one */
+      }
+      s->mode = DRY;
+    case DRY:
+      FLUSH
+      if (s->read != s->write)
+	LEAVE
+      s->mode = DONEB;
+    case DONEB:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADB:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+local int inflate_blocks_free(s, z, c)
+inflate_blocks_statef *s;
+z_stream *z;
+uLongf *c;
+{
+  inflate_blocks_reset(s, z, c);
+  ZFREE(z, s->window, s->end - s->window);
+  ZFREE(z, s, sizeof(struct inflate_blocks_state));
+  Trace((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+/*
+ * This subroutine adds the data at next_in/avail_in to the output history
+ * without performing any output.  The output buffer must be "caught up";
+ * i.e. no pending output (hence s->read equals s->write), and the state must
+ * be BLOCKS (i.e. we should be willing to see the start of a series of
+ * BLOCKS).  On exit, the output will also be caught up, and the checksum
+ * will have been updated if need be.
+ */
+local int inflate_addhistory(s, z)
+inflate_blocks_statef *s;
+z_stream *z;
+{
+    uLong b;              /* bit buffer */  /* NOT USED HERE */
+    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
+    uInt t;               /* temporary storage */
+    Bytef *p;             /* input data pointer */
+    uInt n;               /* bytes available there */
+    Bytef *q;             /* output window write pointer */
+    uInt m;               /* bytes to end of window or read pointer */
+
+    if (s->read != s->write)
+	return Z_STREAM_ERROR;
+    if (s->mode != TYPE)
+	return Z_DATA_ERROR;
+
+    /* we're ready to rock */
+    LOAD
+    /* while there is input ready, copy to output buffer, moving
+     * pointers as needed.
+     */
+    while (n) {
+	t = n;  /* how many to do */
+	/* is there room until end of buffer? */
+	if (t > m) t = m;
+	/* update check information */
+	if (s->checkfn != Z_NULL)
+	    s->check = (*s->checkfn)(s->check, q, t);
+	/* output callback */
+	if (z->outcb != Z_NULL)
+	    (*z->outcb)(q, t);
+	zmemcpy(q, p, t);
+	q += t;
+	p += t;
+	n -= t;
+	z->total_out += t;
+	s->read = q;    /* drag read pointer forward */
+/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
+	if (q == s->end) {
+	    s->read = q = s->window;
+	    m = WAVAIL;
+	}
+    }
+    UPDATE
+    return Z_OK;
+}
+
+
+/*
+ * At the end of a Deflate-compressed PPP packet, we expect to have seen
+ * a `stored' block type value but not the (zero) length bytes.
+ */
+local int inflate_packet_flush(s)
+    inflate_blocks_statef *s;
+{
+    if (s->mode != LENS)
+	return Z_DATA_ERROR;
+    s->mode = TYPE;
+    return Z_OK;
+}
+
+
+/*+++++*/
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+
+local int huft_build OF((
+    uIntf *,            /* code lengths in bits */
+    uInt,               /* number of codes */
+    uInt,               /* number of "simple" codes */
+    uIntf *,            /* list of base values for non-simple codes */
+    uIntf *,            /* list of extra bits for non-simple codes */
+    inflate_huft * FAR*,/* result: starting table */
+    uIntf *,            /* maximum lookup bits (returns actual) */
+    z_stream *));       /* for zalloc function */
+
+local voidpf falloc OF((
+    voidpf,             /* opaque pointer (not used) */
+    uInt,               /* number of items */
+    uInt));             /* size of item */
+
+local void ffree OF((
+    voidpf q,           /* opaque pointer (not used) */
+    voidpf p,           /* what to free (not used) */
+    uInt n));		/* number of bytes (not used) */
+
+/* Tables for deflate from PKZIP's appnote.txt. */
+local uInt cplens[] = { /* Copy lengths for literal codes 257..285 */
+	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+	/* actually lengths - 2; also see note #13 above about 258 */
+local uInt cplext[] = { /* Extra bits for literal codes 257..285 */
+	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 192, 192}; /* 192==invalid */
+local uInt cpdist[] = { /* Copy offsets for distance codes 0..29 */
+	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+	8193, 12289, 16385, 24577};
+local uInt cpdext[] = { /* Extra bits for distance codes */
+	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+	12, 12, 13, 13};
+
+/*
+   Huffman code decoding is performed using a multi-level table lookup.
+   The fastest way to decode is to simply build a lookup table whose
+   size is determined by the longest code.  However, the time it takes
+   to build this table can also be a factor if the data being decoded
+   is not very long.  The most common codes are necessarily the
+   shortest codes, so those codes dominate the decoding time, and hence
+   the speed.  The idea is you can have a shorter table that decodes the
+   shorter, more probable codes, and then point to subsidiary tables for
+   the longer codes.  The time it costs to decode the longer codes is
+   then traded against the time it takes to make longer tables.
+
+   This results of this trade are in the variables lbits and dbits
+   below.  lbits is the number of bits the first level table for literal/
+   length codes can decode in one step, and dbits is the same thing for
+   the distance codes.  Subsequent tables are also less than or equal to
+   those sizes.  These values may be adjusted either when all of the
+   codes are shorter than that, in which case the longest code length in
+   bits is used, or when the shortest code is *longer* than the requested
+   table size, in which case the length of the shortest code in bits is
+   used.
+
+   There are two different values for the two tables, since they code a
+   different number of possibilities each.  The literal/length table
+   codes 286 possible values, or in a flat code, a little over eight
+   bits.  The distance table codes 30 possible values, or a little less
+   than five bits, flat.  The optimum values for speed end up being
+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+   The optimum values may differ though from machine to machine, and
+   possibly even between compilers.  Your mileage may vary.
+ */
+
+
+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
+#define BMAX 15         /* maximum bit length of any code */
+#define N_MAX 288       /* maximum number of codes in any set */
+
+#ifdef DEBUG_ZLIB
+  uInt inflate_hufts;
+#endif
+
+local int huft_build(b, n, s, d, e, t, m, zs)
+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
+uInt n;                 /* number of codes (assumed <= N_MAX) */
+uInt s;                 /* number of simple-valued codes (0..s-1) */
+uIntf *d;               /* list of base values for non-simple codes */
+uIntf *e;               /* list of extra bits for non-simple codes */
+inflate_huft * FAR *t;  /* result: starting table */
+uIntf *m;               /* maximum lookup bits, returns actual */
+z_stream *zs;           /* for zalloc function */
+/* Given a list of code lengths and a maximum table size, make a set of
+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+   if the given code set is incomplete (the tables are still built in this
+   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
+   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
+{
+
+  uInt a;                       /* counter for codes of length k */
+  uInt c[BMAX+1];               /* bit length count table */
+  uInt f;                       /* i repeats in table every f entries */
+  int g;                        /* maximum code length */
+  int h;                        /* table level */
+  register uInt i;              /* counter, current code */
+  register uInt j;              /* counter */
+  register int k;               /* number of bits in current code */
+  int l;                        /* bits per table (returned in m) */
+  register uIntf *p;            /* pointer into c[], b[], or v[] */
+  inflate_huft *q;              /* points to current table */
+  struct inflate_huft_s r;      /* table entry for structure assignment */
+  inflate_huft *u[BMAX];        /* table stack */
+  uInt v[N_MAX];                /* values in order of bit length */
+  register int w;               /* bits before this table == (l * h) */
+  uInt x[BMAX+1];               /* bit offsets, then code stack */
+  uIntf *xp;                    /* pointer into x */
+  int y;                        /* number of dummy codes added */
+  uInt z;                       /* number of entries in current table */
+
+
+  /* Generate counts for each bit length */
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4                            /* clear c[]--assume BMAX+1 is 16 */
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  /* assume all entries <= BMAX */
+  } while (--i);
+  if (c[0] == n)                /* null input--all zero length codes */
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  /* Find minimum and maximum length, bound *m by those */
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        /* minimum code length */
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        /* maximum code length */
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  /* Adjust last length count to fill out codes, if needed */
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  /* Generate starting offsets into the value table for each length */
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 /* note that i == g from above */
+    *xp++ = (j += *p++);
+  }
+
+
+  /* Make a table of values in order of bit lengths */
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+
+
+  /* Generate the Huffman codes and for each, make the table entries */
+  x[0] = i = 0;                 /* first Huffman code is zero */
+  p = v;                        /* grab values in bit order */
+  h = -1;                       /* no tables yet--level -1 */
+  w = -l;                       /* bits decoded == (l * h) */
+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
+  q = (inflate_huft *)Z_NULL;   /* ditto */
+  z = 0;                        /* ditto */
+
+  /* go through the bit lengths (k already is bits in shortest code) */
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      /* here i is the Huffman code of length k bits for value *p */
+      /* make tables up to required level */
+      while (k > w + l)
+      {
+	h++;
+	w += l;                 /* previous table always l bits */
+
+	/* compute minimum size table less than or equal to l bits */
+	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
+	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
+	{                       /* too few codes for k-w bit table */
+	  f -= a + 1;           /* deduct codes from patterns left */
+	  xp = c + k;
+	  if (j < z)
+	    while (++j < z)     /* try smaller tables up to z bits */
+	    {
+	      if ((f <<= 1) <= *++xp)
+		break;          /* enough codes to use up j bits */
+	      f -= *xp;         /* else deduct codes from patterns */
+	    }
+	}
+	z = 1 << j;             /* table entries for j-bit table */
+
+	/* allocate and link in new table */
+	if ((q = (inflate_huft *)ZALLOC
+	     (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
+	{
+	  if (h)
+	    inflate_trees_free(u[0], zs);
+	  return Z_MEM_ERROR;   /* not enough memory */
+	}
+	q->word.Nalloc = z + 1;
+#ifdef DEBUG_ZLIB
+	inflate_hufts += z + 1;
+#endif
+	*t = q + 1;             /* link to list for huft_free() */
+	*(t = &(q->next)) = Z_NULL;
+	u[h] = ++q;             /* table starts after link */
+
+	/* connect to last table, if there is one */
+	if (h)
+	{
+	  x[h] = i;             /* save pattern for backing up */
+	  r.bits = (Byte)l;     /* bits to dump before this table */
+	  r.exop = (Byte)j;     /* bits in this table */
+	  r.next = q;           /* pointer to this table */
+	  j = i >> (w - l);     /* (get around Turbo C bug) */
+	  u[h-1][j] = r;        /* connect to last table */
+	}
+      }
+
+      /* set up table entry in r */
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+	r.exop = 128 + 64;      /* out of values--invalid code */
+      else if (*p < s)
+      {
+	r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+	r.base = *p++;          /* simple code is just the value */
+      }
+      else
+      {
+	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
+	r.base = d[*p++ - s];
+      }
+
+      /* fill code-like entries with r */
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+	q[j] = r;
+
+      /* backwards increment the k-bit code i */
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+	i ^= j;
+      i ^= j;
+
+      /* backup over finished tables */
+      while ((i & ((1 << w) - 1)) != x[h])
+      {
+	h--;                    /* don't need to update q */
+	w -= l;
+      }
+    }
+  }
+
+
+  /* Return Z_BUF_ERROR if we were given an incomplete table */
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+local int inflate_trees_bits(c, bb, tb, z)
+uIntf *c;               /* 19 code lengths */
+uIntf *bb;              /* bits tree desired/actual depth */
+inflate_huft * FAR *tb; /* bits tree result */
+z_stream *z;            /* for zfree function */
+{
+  int r;
+
+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
+  if (r == Z_DATA_ERROR)
+    z->msg = "oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR)
+  {
+    inflate_trees_free(*tb, z);
+    z->msg = "incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  return r;
+}
+
+
+local int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
+uInt nl;                /* number of literal/length codes */
+uInt nd;                /* number of distance codes */
+uIntf *c;               /* that many (total) code lengths */
+uIntf *bl;              /* literal desired/actual bit depth */
+uIntf *bd;              /* distance desired/actual bit depth */
+inflate_huft * FAR *tl; /* literal/length tree result */
+inflate_huft * FAR *td; /* distance tree result */
+z_stream *z;            /* for zfree function */
+{
+  int r;
+
+  /* build literal/length tree */
+  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = "oversubscribed literal/length tree";
+    else if (r == Z_BUF_ERROR)
+    {
+      inflate_trees_free(*tl, z);
+      z->msg = "incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    return r;
+  }
+
+  /* build distance tree */
+  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = "oversubscribed literal/length tree";
+    else if (r == Z_BUF_ERROR) {
+#ifdef PKZIP_BUG_WORKAROUND
+      r = Z_OK;
+    }
+#else
+      inflate_trees_free(*td, z);
+      z->msg = "incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    inflate_trees_free(*tl, z);
+    return r;
+#endif
+  }
+
+  /* done */
+  return Z_OK;
+}
+
+
+/* build fixed tables only once--keep them here */
+local int fixed_lock = 0;
+local int fixed_built = 0;
+#define FIXEDH 530      /* number of hufts used by fixed tables */
+local uInt fixed_left = FIXEDH;
+local inflate_huft fixed_mem[FIXEDH];
+local uInt fixed_bl;
+local uInt fixed_bd;
+local inflate_huft *fixed_tl;
+local inflate_huft *fixed_td;
+
+
+local voidpf falloc(q, n, s)
+voidpf q;        /* opaque pointer (not used) */
+uInt n;         /* number of items */
+uInt s;         /* size of item */
+{
+  Assert(s == sizeof(inflate_huft) && n <= fixed_left,
+	 "inflate_trees falloc overflow");
+  if (q) s++; /* to make some compilers happy */
+  fixed_left -= n;
+  return (voidpf)(fixed_mem + fixed_left);
+}
+
+
+local void ffree(q, p, n)
+voidpf q;
+voidpf p;
+uInt n;
+{
+  Assert(0, "inflate_trees ffree called!");
+  if (q) q = p; /* to make some compilers happy */
+}
+
+
+local int inflate_trees_fixed(bl, bd, tl, td)
+uIntf *bl;               /* literal desired/actual bit depth */
+uIntf *bd;               /* distance desired/actual bit depth */
+inflate_huft * FAR *tl;  /* literal/length tree result */
+inflate_huft * FAR *td;  /* distance tree result */
+{
+  /* build fixed tables if not built already--lock out other instances */
+  while (++fixed_lock > 1)
+    fixed_lock--;
+  if (!fixed_built)
+  {
+    int k;              /* temporary variable */
+    unsigned c[288];    /* length list for huft_build */
+    z_stream z;         /* for falloc function */
+
+    /* set up fake z_stream for memory routines */
+    z.zalloc = falloc;
+    z.zfree = ffree;
+    z.opaque = Z_NULL;
+
+    /* literal table */
+    for (k = 0; k < 144; k++)
+      c[k] = 8;
+    for (; k < 256; k++)
+      c[k] = 9;
+    for (; k < 280; k++)
+      c[k] = 7;
+    for (; k < 288; k++)
+      c[k] = 8;
+    fixed_bl = 7;
+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
+
+    /* distance table */
+    for (k = 0; k < 30; k++)
+      c[k] = 5;
+    fixed_bd = 5;
+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
+
+    /* done */
+    fixed_built = 1;
+  }
+  fixed_lock--;
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
+
+
+local int inflate_trees_free(t, z)
+inflate_huft *t;        /* table to free */
+z_stream *z;            /* for zfree function */
+/* Free the malloc'ed tables built by huft_build(), which makes a linked
+   list of the tables it made, with the links in a dummy first entry of
+   each table. */
+{
+  register inflate_huft *p, *q;
+
+  /* Go through linked list, freeing from the malloced (t[-1]) address. */
+  p = t;
+  while (p != Z_NULL)
+  {
+    q = (--p)->next;
+    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
+    p = q;
+  }
+  return Z_OK;
+}
+
+/*+++++*/
+/* infcodes.c -- process literals and length/distance pairs
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* inflate codes private state */
+struct inflate_codes_state {
+
+  /* mode */
+  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+      START,    /* x: set up for LEN */
+      LEN,      /* i: get length/literal/eob next */
+      LENEXT,   /* i: getting length extra (have base) */
+      DIST,     /* i: get distance next */
+      DISTEXT,  /* i: getting distance extra */
+      COPY,     /* o: copying bytes in window, waiting for space */
+      LIT,      /* o: got literal, waiting for output space */
+      WASH,     /* o: got eob, possibly still output waiting */
+      END,      /* x: got eob and all data flushed */
+      BADCODE}  /* x: got error */
+    mode;               /* current inflate_codes mode */
+
+  /* mode dependent information */
+  uInt len;
+  union {
+    struct {
+      inflate_huft *tree;       /* pointer into tree */
+      uInt need;                /* bits needed */
+    } code;             /* if LEN or DIST, where in tree */
+    uInt lit;           /* if LIT, literal */
+    struct {
+      uInt get;                 /* bits to get for extra */
+      uInt dist;                /* distance back to copy from */
+    } copy;             /* if EXT or COPY, where and how much */
+  } sub;                /* submode */
+
+  /* mode independent information */
+  Byte lbits;           /* ltree bits decoded per branch */
+  Byte dbits;           /* dtree bits decoder per branch */
+  inflate_huft *ltree;          /* literal/length/eob tree */
+  inflate_huft *dtree;          /* distance tree */
+
+};
+
+
+local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
+uInt bl, bd;
+inflate_huft *tl, *td;
+z_stream *z;
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+local int inflate_codes(s, z, r)
+inflate_blocks_statef *s;
+z_stream *z;
+int r;
+{
+  uInt j;               /* temporary storage */
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  Bytef *f;             /* pointer to copy strings from */
+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input and output based on current state */
+  while (1) switch (c->mode)
+  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+    case START:         /* x: set up for LEN */
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+	UPDATE
+	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+	LOAD
+	if (r != Z_OK)
+	{
+	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+	  break;
+	}
+      }
+#endif /* !SLOW */
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           /* i: get length/literal/eob next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               /* literal */
+      {
+	c->sub.lit = t->base;
+	Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+		 "inflate:         literal '%c'\n" :
+		 "inflate:         literal 0x%02x\n", t->base));
+	c->mode = LIT;
+	break;
+      }
+      if (e & 16)               /* length */
+      {
+	c->sub.copy.get = e & 15;
+	c->len = t->base;
+	c->mode = LENEXT;
+	break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+	c->sub.code.need = e;
+	c->sub.code.tree = t->next;
+	break;
+      }
+      if (e & 32)               /* end of block */
+      {
+	Tracevv((stderr, "inflate:         end of block\n"));
+	c->mode = WASH;
+	break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = "invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        /* i: getting length extra (have base) */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          /* i: get distance next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               /* distance */
+      {
+	c->sub.copy.get = e & 15;
+	c->sub.copy.dist = t->base;
+	c->mode = DISTEXT;
+	break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+	c->sub.code.need = e;
+	c->sub.code.tree = t->next;
+	break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = "invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       /* i: getting distance extra */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          /* o: copying bytes in window, waiting for space */
+#ifndef __TURBOC__ /* Turbo C bug for following expression */
+      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+	  s->end - (c->sub.copy.dist - (q - s->window)) :
+	  q - c->sub.copy.dist;
+#else
+      f = q - c->sub.copy.dist;
+      if ((uInt)(q - s->window) < c->sub.copy.dist)
+	f = s->end - (c->sub.copy.dist - (q - s->window));
+#endif
+      while (c->len)
+      {
+	NEEDOUT
+	OUTBYTE(*f++)
+	if (f == s->end)
+	  f = s->window;
+	c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           /* o: got literal, waiting for output space */
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          /* o: got eob, possibly more output */
+      FLUSH
+      if (s->read != s->write)
+	LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       /* x: got error */
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+local void inflate_codes_free(c, z)
+inflate_codes_statef *c;
+z_stream *z;
+{
+  ZFREE(z, c, sizeof(struct inflate_codes_state));
+  Tracev((stderr, "inflate:       codes free\n"));
+}
+
+/*+++++*/
+/* inflate_util.c -- data and routines common to blocks and codes
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* copy as much as possible from the sliding window to the output area */
+local int inflate_flush(s, z, r)
+inflate_blocks_statef *s;
+z_stream *z;
+int r;
+{
+  uInt n;
+  Bytef *p, *q;
+
+  /* local copies of source and destination pointers */
+  p = z->next_out;
+  q = s->read;
+
+  /* compute number of bytes to copy as far as end of window */
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  /* update counters */
+  z->avail_out -= n;
+  z->total_out += n;
+
+  /* update check information */
+  if (s->checkfn != Z_NULL)
+    s->check = (*s->checkfn)(s->check, q, n);
+
+  /* output callback */
+  if (z->outcb != Z_NULL)
+    (*z->outcb)(q, n);
+
+  /* copy as far as end of window */
+  zmemcpy(p, q, n);
+  p += n;
+  q += n;
+
+  /* see if more to copy at beginning of window */
+  if (q == s->end)
+  {
+    /* wrap pointers */
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    /* compute bytes to copy */
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    /* update counters */
+    z->avail_out -= n;
+    z->total_out += n;
+
+    /* update check information */
+    if (s->checkfn != Z_NULL)
+      s->check = (*s->checkfn)(s->check, q, n);
+
+    /* output callback */
+    if (z->outcb != Z_NULL)
+	(*z->outcb)(q, n);
+
+    /* copy */
+    zmemcpy(p, q, n);
+    p += n;
+    q += n;
+  }
+
+  /* update pointers */
+  z->next_out = p;
+  s->read = q;
+
+  /* done */
+  return r;
+}
+
+
+/*+++++*/
+/* inffast.c -- process literals and length/distance pairs fast
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define base more.Base
+#define next more.Next
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* macros for bit input with no checking and for returning unused bytes */
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}
+
+/* Called with number of bytes left to write in window at least 258
+   (the maximum string length) and number of input bytes available
+   at least ten.  The ten bytes are six bytes for the longest length/
+   distance pair plus four bytes for overloading the bit buffer. */
+
+local int inflate_fast(bl, bd, tl, td, s, z)
+uInt bl, bd;
+inflate_huft *tl, *td;
+inflate_blocks_statef *s;
+z_stream *z;
+{
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  uInt ml;              /* mask for literal/length tree */
+  uInt md;              /* mask for distance tree */
+  uInt c;               /* bytes to copy */
+  uInt d;               /* distance back to copy from */
+  Bytef *r;             /* copy source pointer */
+
+  /* load input, output, bit values */
+  LOAD
+
+  /* initialize masks */
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  /* do until not enough input or output space for fast loop */
+  do {                          /* assume called with m >= 258 && n >= 10 */
+    /* get literal/length code */
+    GRABBITS(20)                /* max bits for literal/length code */
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+		"inflate:         * literal '%c'\n" :
+		"inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    do {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+	/* get extra bits for length */
+	e &= 15;
+	c = t->base + ((uInt)b & inflate_mask[e]);
+	DUMPBITS(e)
+	Tracevv((stderr, "inflate:         * length %u\n", c));
+
+	/* decode distance base of block to copy */
+	GRABBITS(15);           /* max bits for distance code */
+	e = (t = td + ((uInt)b & md))->exop;
+	do {
+	  DUMPBITS(t->bits)
+	  if (e & 16)
+	  {
+	    /* get extra bits to add to distance base */
+	    e &= 15;
+	    GRABBITS(e)         /* get extra bits (up to 13) */
+	    d = t->base + ((uInt)b & inflate_mask[e]);
+	    DUMPBITS(e)
+	    Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+	    /* do the copy */
+	    m -= c;
+	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
+	    {                                   /*  just copy */
+	      r = q - d;
+	      *q++ = *r++;  c--;        /* minimum count is three, */
+	      *q++ = *r++;  c--;        /*  so unroll loop a little */
+	    }
+	    else                        /* else offset after destination */
+	    {
+	      e = d - (q - s->window);  /* bytes from offset to end */
+	      r = s->end - e;           /* pointer to offset */
+	      if (c > e)                /* if source crosses, */
+	      {
+		c -= e;                 /* copy to end of window */
+		do {
+		  *q++ = *r++;
+		} while (--e);
+		r = s->window;          /* copy rest from start of window */
+	      }
+	    }
+	    do {                        /* copy all or what's left */
+	      *q++ = *r++;
+	    } while (--c);
+	    break;
+	  }
+	  else if ((e & 64) == 0)
+	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
+	  else
+	  {
+	    z->msg = "invalid distance code";
+	    UNGRAB
+	    UPDATE
+	    return Z_DATA_ERROR;
+	  }
+	} while (1);
+	break;
+      }
+      if ((e & 64) == 0)
+      {
+	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
+	{
+	  DUMPBITS(t->bits)
+	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+		    "inflate:         * literal '%c'\n" :
+		    "inflate:         * literal 0x%02x\n", t->base));
+	  *q++ = (Byte)t->base;
+	  m--;
+	  break;
+	}
+      }
+      else if (e & 32)
+      {
+	Tracevv((stderr, "inflate:         * end of block\n"));
+	UNGRAB
+	UPDATE
+	return Z_STREAM_END;
+      }
+      else
+      {
+	z->msg = "invalid literal/length code";
+	UNGRAB
+	UPDATE
+	return Z_DATA_ERROR;
+      }
+    } while (1);
+  } while (m >= 258 && n >= 10);
+
+  /* not enough input or output--restore pointers and return */
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
+
+
+/*+++++*/
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
+
+char *zlib_version = ZLIB_VERSION;
+
+char *z_errmsg[] = {
+"stream end",          /* Z_STREAM_END    1 */
+"",                    /* Z_OK            0 */
+"file error",          /* Z_ERRNO        (-1) */
+"stream error",        /* Z_STREAM_ERROR (-2) */
+"data error",          /* Z_DATA_ERROR   (-3) */
+"insufficient memory", /* Z_MEM_ERROR    (-4) */
+"buffer error",        /* Z_BUF_ERROR    (-5) */
+""};
+
+
+/*+++++*/
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf)  {s1 += *buf++; s2 += s1;}
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+#define DO16(buf) DO8(buf); DO8(buf);
+
+/* ========================================================================= */
+uLong adler32(adler, buf, len)
+    uLong adler;
+    Bytef *buf;
+    uInt len;
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+	k = len < NMAX ? len : NMAX;
+	len -= k;
+	while (k >= 16) {
+	    DO16(buf);
+	    k -= 16;
+	}
+	if (k != 0) do {
+	    DO1(buf);
+	} while (--k);
+	s1 %= BASE;
+	s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
diff --git a/rtc/cc9c_rtc.c b/rtc/cc9c_rtc.c
new file mode 100644
index 0000000..5b4daaf
--- /dev/null
+++ b/rtc/cc9c_rtc.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2006 by FS Forth-Systeme, a DIGI International Company
+ * All rights reserved.
+ *
+ * $Id:
+ * @Author: Joachim Jaeger (Joachim_Jaeger@digi.com)
+ * @Descr: Driver for internal RTC of NS9360 CPU
+ * @References: Code comes from NetOS sources for CC9P9360
+ * @TODO:
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Date & Time support for the built-in Netsilicon NS9360 RTC
+ *
+ * This RTC device is configured with 24-hour mode.
+ * The range of years is from 1900 to 2999.
+ *
+ * This NS9360 Real Time Clock (RTC) device is added in @link naRtcDeviceTable .
+ * Use the device id defined in naRtcDeviceTable to access this NS9360 RTC.
+ * NS9360 RTC supports only 1 alarm and the id is 0.
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if defined(CONFIG_RTC_NS9360) && (CONFIG_COMMANDS & CFG_CMD_DATE)
+
+#if defined(CONFIG_CC9C) || (CONFIG_CCW9C)
+# include <ns9360_rtc.h>
+#endif
+
+#include <rtc.h>
+
+/*---------------------------------------------------------------------*/
+#undef DEBUG_RTC
+
+#ifdef DEBUG_RTC
+#define DEBUGR(fmt,args...) printf(fmt ,##args)
+#else
+#define DEBUGR(fmt,args...)
+#endif
+/*---------------------------------------------------------------------*/
+
+/* decimal number converts to BCD (2 digits) */
+#define DECIMAL_TO_BCD(a)   ((((a & 0xff)/10) << 4) + ((a & 0xff)%10))
+
+static unsigned int  rtc_initialized = _RTC_NOT_INITIALIZED;
+
+/*
+ * This function is used to convert the given bcd value to decimal value.
+ * It converts the bcd value in the given bits to the decimal value.
+ *
+ * @param    value              value that contains BCD to be converted into decimal
+ * @param    unit_shift         index to the 1st bit of the BCD value
+ * @param    hi_mask            number of bits of the tens unit
+ *                        
+ * @return  "decimal value"     decimal value of the given BCD.
+ */
+static unsigned long reg_bcd_to_decimal(unsigned int value, unsigned unit_shift, unsigned hi_mask) {
+#define BCD_TO_DECIMAL(a)   ((10 * (a >> 4)) + (a & 0xf) )
+
+	unsigned long bcd_value;
+	unsigned long ret_value = 0;
+    
+	/* get the bcd value */
+	bcd_value = (value >> unit_shift);
+                
+	/* mask off the rest of the bits */
+	if (hi_mask > 0)
+		bcd_value &= ((0x10 << hi_mask) - 1); /* contains tens unit */
+	else
+		bcd_value &= 0xf;  /* no tens unit */
+
+	ret_value = BCD_TO_DECIMAL(bcd_value);
+
+	return ret_value;
+}    
+
+/*
+ * Initializes the real time clock. This function enables and sets up the 
+ * specified real time clock device.
+ *
+ */
+void rtc_reset (void) {
+	
+	ulong reg_value;
+	
+	if ((rtc_initialized & _RTC_TIME_INITIALIZED) == 0) {
+		/* enable rtc device */
+		*get_sys_reg_addr( NS9750_SYS_CLOCK ) |= NS9750_SYS_CLOCK_RTC;
+		/* setup the RTC clock control frequency */
+		*get_sys_reg_addr( NS9750_SYS_RTC_CTRL_BASE ) = (CONFIG_SYS_CLK_FREQ/200);
+
+		/* switch to 24h mode */
+		*get_rtc_reg_addr( NA_RTC_REG_HOUR_MODE ) &= ~NA_RTC_REG_HOUR_MODE_24H;
+
+		/* writes 1 & 0 to ensure it disables the IRQ */
+		*get_rtc_reg_addr( NA_RTC_REG_IRQ_ENABLE ) = NA_RTC_REG_IRQ_ALARM_ALL;
+		*get_rtc_reg_addr( NA_RTC_REG_IRQ_ENABLE ) &= ~NA_RTC_REG_IRQ_ALARM_ALL;
+            
+		/* clear all time in the alarm */
+		*get_rtc_reg_addr( NA_RTC_REG_ALARM_ENABLE ) &= ~NA_RTC_REG_ALARM_ALL;
+            
+		/* enable RTC & Calendar operations */    
+		*get_rtc_reg_addr( NA_RTC_REG_GEN_CNTRL ) &= ~NA_RTC_GEN_CNTRL_ON;
+		
+		/* we initialized all necessary registers */
+		rtc_initialized |= _RTC_TIME_INITIALIZED;  
+             
+		/* Make a read to clear the status in the event register */
+		reg_value = *get_rtc_reg_addr( NA_RTC_REG_EVENT_STATUS );
+	}
+}
+
+/*
+ * Sets time to the real time clock device. It writes specified time 
+ * into specified real-time clock control.
+ *  
+ */
+void rtc_set (struct rtc_time *tmp) {
+    
+	ulong reg_value;
+	
+	if ((rtc_initialized & _RTC_TIME_INITIALIZED) == 0)
+		rtc_reset();
+
+	/* Disable RTC & Calendar operations */
+	*get_rtc_reg_addr( NA_RTC_REG_GEN_CNTRL ) |= NA_RTC_GEN_CNTRL_ON;
+	
+	/*********************
+	* Update Time
+	*********************/  
+	reg_value = 0x0;
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_sec)) << SECONDS_BCD_START_BIT_INDEX);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_min)) << MINUTES_BCD_START_BIT_INDEX);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_hour)) << HOURS_BCD_START_BIT_INDEX);
+	*get_rtc_reg_addr( NA_RTC_REG_TIME_TIME ) = reg_value;
+	DEBUGR("RTC_SET: RTC time setting: 0x%x\n",reg_value);
+	
+	/*********************
+	* Update Date
+	*********************/ 
+	reg_value = 0x0;
+	reg_value |= (DECIMAL_TO_BCD(tmp->tm_wday) + 1);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_mon)) << MONTH_BCD_START_BIT_INDEX);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_mday)) << DATE_BCD_START_BIT_INDEX);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_year%100)) << YEAR_BCD_START_BIT_INDEX);
+	reg_value |= ((DECIMAL_TO_BCD(tmp->tm_year/100)) << CENTURY_YEAR_BCD_START_BIT_INDEX);
+	*get_rtc_reg_addr( NA_RTC_REG_CALENDAR_TIME ) = reg_value;
+	DEBUGR("RTC_SET: RTC date setting: 0x%x\n",reg_value);
+	
+	/* Make sure time and calendar are valid */
+	reg_value = *get_rtc_reg_addr( NA_RTC_REG_GEN_STATUS );
+	if ((reg_value & NA_RTC_VALID_STATUS) != NA_RTC_VALID_STATUS) {
+		/* TODO  */
+		printf("RTC_SET: RTC setting failed! Status: 0x%x\n",reg_value);
+		rtc_initialized = _RTC_NOT_INITIALIZED;
+	}
+	
+	/* enable RTC & Calendar operations */    
+	*get_rtc_reg_addr( NA_RTC_REG_GEN_CNTRL ) &= ~NA_RTC_GEN_CNTRL_ON;
+}
+
+/*
+ * Gets time from the real time device. 
+ * It reads the time from specified real time control.
+ * 
+ */
+void rtc_get (struct rtc_time *tmp)
+{
+	ulong reg_value;
+	
+	if ((rtc_initialized & _RTC_TIME_INITIALIZED) == 0)
+		rtc_reset();
+
+	/*
+	* Hours, minutes, and seconds are in binary coded decimal.
+	*/
+	reg_value = *get_rtc_reg_addr( NA_RTC_REG_TIME_TIME );
+	
+	tmp->tm_sec = reg_bcd_to_decimal(reg_value, SECONDS_BCD_START_BIT_INDEX, SECONDS_BCD_TENS_UNIT);
+	tmp->tm_min = reg_bcd_to_decimal(reg_value, MINUTES_BCD_START_BIT_INDEX, MINUTES_BCD_TENS_UNIT);
+	tmp->tm_hour = reg_bcd_to_decimal(reg_value, HOURS_BCD_START_BIT_INDEX, HOURS_BCD_TENS_UNIT);
+
+	/*
+	* Date, month, and year are binary coded decimal.  Year is only two digits.
+	*/
+	reg_value = *get_rtc_reg_addr( NA_RTC_REG_CALENDAR_TIME );
+
+	tmp->tm_wday = (reg_value & DAYWEEK_BCD_START_BIT_MASK) - 1;
+	tmp->tm_mon = reg_bcd_to_decimal(reg_value, MONTH_BCD_START_BIT_INDEX, MONTH_BCD_TENS_UNIT);
+	tmp->tm_mday = reg_bcd_to_decimal(reg_value, DATE_BCD_START_BIT_INDEX, DATE_BCD_TENS_UNIT);
+	tmp->tm_year = reg_bcd_to_decimal(reg_value, YEAR_BCD_START_BIT_INDEX, YEAR_BCD_TENS_UNIT);
+	tmp->tm_year += (reg_bcd_to_decimal(reg_value, CENTURY_YEAR_BCD_START_BIT_INDEX, 
+						CENTURY_YEAR_BCD_TENS_UNIT) * 100); 
+
+	DEBUGR ("Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+	
+}
+
+#endif	/* CONFIG_RTC_NS9360 && CFG_CMD_DATE */
diff --git a/rtc/ns921x_rtc.c b/rtc/ns921x_rtc.c
new file mode 100644
index 0000000..4a287a1
--- /dev/null
+++ b/rtc/ns921x_rtc.c
@@ -0,0 +1,187 @@
+/*
+ *  rtc/ns921x_rtc.c
+ *
+ *  Copyright (C) 2007 by Digi International Inc.
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version2  as published by
+ *  the Free Software Foundation.
+*/
+/*
+ *  !Revision:   $Revision: 1.9 $
+ *  !Author:     Markus Pietrek
+ *  !Descr:      Some system registers (SYS_CLOCK and SYS_RTC) have been
+ *               changed. Therefore, cc9c_rtc.c is not merged into it.
+ *  !References: [1] NS9215 Hardware Reference Manual, Preliminary January 2007
+ *               [2] netos:rtc_drv.c 1.4
+*/
+
+#include <common.h>
+
+#if defined(CONFIG_RTC_NS921X) && (CONFIG_COMMANDS & CFG_CMD_DATE)
+
+#include <rtc.h>                /* rtc_time */
+#include <bcd.h>                /* bcd2bin */
+
+#include <asm-arm/arch-ns9xxx/ns921x_rtc.h>
+#include <asm-arm/arch-ns9xxx/ns921x_sys.h>
+#include <asm-arm/arch-ns9xxx/io.h>  /* rtc_readl */
+
+#define CLEAR( x ) memset( &x, 0, sizeof( x ) )
+
+#define TIMEOUT		1000000 /* us */
+
+static void rtc_cold_boot( void )
+{
+        unsigned int uiTimeout = TIMEOUT;
+
+        /* configure RTC for CPU access */
+        sys_rmw32( SYS_RTC, |  SYS_RTC_INT_READY_CLEAR );
+        sys_rmw32( SYS_RTC, & ~SYS_RTC_INT_READY_CLEAR );
+
+        /* [2] */
+        sys_rmw32( SYS_RTC, | SYS_RTC_NORMAL );
+        while( ! (sys_readl( SYS_RTC ) & SYS_RTC_INT_READY ) ) {
+                /* wait for RTC to become ready */
+                if( !uiTimeout ) {
+                        eprintf( "RTC Timed Out\n" );
+                        break;
+                }
+                uiTimeout--;
+                udelay( 1 );
+        }
+
+        while( ! (sys_readl( SYS_RTC ) & SYS_RTC_NORMAL_STAT ) ) {
+                /* wait for RTC to become accessable */
+                if( !uiTimeout ) {
+                        eprintf( "RTC Timed Out\n" );
+                        break;
+                }
+                uiTimeout--;
+                udelay( 1 );
+        }
+}
+
+/**
+ * rtc_lowlevel_init - setups the hardware
+ */
+void rtc_lowlevel_init( void )
+{
+        static char bAlreadyInitialized = 0;
+
+        if( !bAlreadyInitialized ) {
+                sys_rmw32( SYS_CLOCK, | SYS_CLOCK_RTC );
+
+                if( ! (sys_readl( SYS_RTC ) & SYS_RTC_NORMAL_STAT ) )
+                        /* RTC has not been started yet, e.g. reset */
+                        rtc_cold_boot();
+
+                sys_rmw32( SYS_RTC,  | SYS_RTC_INT_READY_CLEAR );
+                sys_rmw32( SYS_RTC, &~ SYS_RTC_INT_READY_CLEAR );
+
+                rtc_writel( RTC_24H_24, RTC_24H );
+
+                /* clear events */
+                rtc_readl( RTC_EVENT );
+
+                /* kick it if not running */
+                rtc_rmw32( RTC_CTRL, & ~( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+
+                bAlreadyInitialized = 1;
+        }
+}
+
+/**
+ * rtc_reset - bring rtc into known state (same as battery of)
+ */
+void rtc_reset( void )
+{
+        rtc_lowlevel_init();
+}
+
+/**
+ * rtc_get - returns current time/date
+ */
+void rtc_get( struct rtc_time* pTime )
+{
+        u32 uiDate;
+        u32 uiDateDetectWrap;
+        u32 uiTime;
+        u32 uiStatus;
+
+        rtc_lowlevel_init();
+
+        uiDate = rtc_readl( RTC_DATE );
+        uiTime = rtc_readl( RTC_TIME );
+
+        /* date could have wrapped around just after a read, so time is
+         * 00:00:00 but date is from yesterday. Detect this and read again  */
+        uiDateDetectWrap = rtc_readl( RTC_DATE );
+        if( uiDate != uiDateDetectWrap ) {
+                /* wrapped, use new date and get new time */
+                uiDate = uiDateDetectWrap;
+                uiTime = rtc_readl( RTC_TIME );
+        }
+
+        uiStatus = rtc_readl( RTC_GEN_STAT );
+        if( ( uiStatus & RTC_GEN_STAT_ALL_VALID ) != RTC_GEN_STAT_ALL_VALID )
+                eprintf( "RTC reports invalid configuration: 0x%08x\n",
+                         uiStatus );
+
+        /* convert to U-Boot */
+        CLEAR( *pTime );
+
+        pTime->tm_sec  = bcd2bin( RTC_TIME_S_GET( uiTime ) );
+        pTime->tm_min  = bcd2bin( RTC_TIME_M_GET( uiTime ) );
+        pTime->tm_hour = bcd2bin( RTC_TIME_HR_GET( uiTime ) );
+        pTime->tm_mday = bcd2bin( RTC_DATE_D_GET( uiDate ) );
+        pTime->tm_mon  = bcd2bin( RTC_DATE_M_GET( uiDate ) );
+        pTime->tm_year = bcd2bin( RTC_DATE_C_GET( uiDate ) ) * 100 +
+                bcd2bin( RTC_DATE_Y_GET( uiDate ) );
+        pTime->tm_wday = bcd2bin( RTC_DATE_DAY_GET( uiDate ) - 1 );
+        /* yday and isdst not set */
+}
+
+/**
+ * rtc_set - updates battery powered RTC
+ */
+void rtc_set( struct rtc_time* pTime )
+{
+        u32 uiDate;
+        u32 uiTime;
+        u32 uiStatus;
+
+        rtc_lowlevel_init();
+
+        uiTime =
+                RTC_TIME_S_SET( bin2bcd( pTime->tm_sec ) ) |
+                RTC_TIME_M_SET( bin2bcd( pTime->tm_min ) ) |
+                RTC_TIME_HR_SET( bin2bcd( pTime->tm_hour ) );
+        uiDate =
+                RTC_DATE_D_SET( bin2bcd( pTime->tm_mday ) ) |
+                RTC_DATE_M_SET( bin2bcd( pTime->tm_mon  ) )  |
+                RTC_DATE_Y_SET( bin2bcd( pTime->tm_year % 100 ) ) |
+                RTC_DATE_C_SET( bin2bcd( pTime->tm_year / 100 ) ) |
+		/* NET+OS saves Sunday as 1, so let's do that, too */
+                RTC_DATE_DAY_SET( bin2bcd( pTime->tm_wday ) + 1 );
+
+        /* disable RTC operation while we update */
+        rtc_rmw32( RTC_CTRL, | ( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+
+        rtc_writel( uiTime, RTC_TIME );
+        /* msecs are 0. This gives us a whole second to write date */
+        rtc_writel( uiDate, RTC_DATE );
+
+        /* check for valid settings. do_date() performs a get() after a set(),
+         * but* someone else might not */
+        uiStatus = rtc_readl( RTC_GEN_STAT );
+        if( ( uiStatus & RTC_GEN_STAT_ALL_VALID ) != RTC_GEN_STAT_ALL_VALID )
+                eprintf( "RTC reports invalid configuration: 0x%08x\n",
+                         uiStatus );
+
+        /* let it continue */
+        rtc_rmw32( RTC_CTRL, & ~( RTC_CTRL_CAL | RTC_CTRL_TIME ) );
+}
+
+#endif  /* defined(CONFIG_RTC_NS921X) && (CONFIG_COMMANDS & CFG_CMD_DATE) */
